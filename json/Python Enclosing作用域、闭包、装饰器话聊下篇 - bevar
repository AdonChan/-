{"title": "Python Enclosing作用域、闭包、装饰器话聊下篇 - bevar ", "index": "装饰器,python", "content": "Python Enclosing作用域、闭包、装饰器话聊下篇\nPython Enclosing作用域、闭包、装饰器的基础篇，请看Python Enclosing作用域、闭包、装饰器话聊上篇\nJaglawz: 我经常看到有人的装饰器是带参数的，这又是咋回事呢？\nPylego: 这个其实很简单的，你还记得上次我说:\n@deco\ndef foo():\n    pass\n\n# 相当于: foo = deco(foo)\n# 那么\n@new_deco(*args, **kwargs)\ndef bar():\n    pass\n    \n# 相当于: bar = new_deco(*args, **kwargs)(bar)\nJaglawz: 也就是说，new_deco返回的是一个装饰器函数，然后再去装饰其他函数。那类装饰器又是怎么回事呢？\nPylego: 你知道Python的对象可以像函数一样调用吗？\nfrom hashlib import sha256\n\n\nclass HashCache(object):\n    def __init__(self):\n        self.cache = {}\n        \n    def __call__(self, string):\n        if string not in self.cache:\n            self.cache[string] = sha256(string).hexdigest()\n        return self.cache[string]\n            \n            \nhc = HashCahce()\nhc('foo')  # 像函数一样调用hc对象\nhc('foo')\nhc('bar')\nJaglawz: 如果是这样的话我就明白了。\nclass FibCache(object):\n    def __init__(self, func):\n        self.func = func\n        self.cache = {}\n    \n    def __call__(self, n):\n        if n not in self.cache:\n            self.cache[n] = self.func(n)\n        return self.cache[n]\n        \n        \n@FibCache\ndef fib(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fib(n-1) + fib(n-2)\n        \n# 相当于: fib = FibCache(fib)\n# fib(10)相当于FibCache(fib)(10)\n# 装饰后的fib是FibCache的一个对象而已\n\n# 也就是说作为装饰器的类的构造方法要接收一个待装饰的函数，然后__call__函数的参数要和待装饰的函数的参数是一样的(除了self)，这样的类就可以用来装饰函数了\nPylego: 你这个装饰器厉害，还给fibnacci函数加了缓存，佩服！\nJaglawz: 我不会告诉你我是看了大神的杰作然后吓吓唬吓唬你的！\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "4"}