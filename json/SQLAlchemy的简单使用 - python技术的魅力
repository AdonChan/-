{"title": "SQLAlchemy的简单使用 - python技术的魅力 ", "index": "python,sqlalchemy", "content": "1.简述\n最近在学习tornado，发现没有Orm模型。其自带的torndb模块不支持python3，学习一下SQLAlchemy供以后工作中使用。\n本文学习使用 SQLAlchemy 连接 MySQL 数据库，创建一个博客应用所需要的数据表，并介绍了使用 SQLAlchemy 进行简单了 CURD 操作及使用 Faker 生成测试数据。\n1.1 知识要点\n\n学会用 SQLALchemy 连接数据库(MySQL, SQLite, PostgreSQL), 创建数据表；\n掌握表数据之间一对一，一对多及多对多的关系并能转化为对应 SQLAlchemy 描述；\n掌握使用 SQLAlchemy 进行 CURD 操作；\n学会使用 Faker 生成测试数据\n\n2. ORM 与 SQLAlchemy 简单介绍\nORM 全称 Object Relational Mapping, 翻译过来叫对象关系映射。简单的说，ORM 将数据库中的表与面向对象语言中的类建立了一种对应关系。这样，我们要操作数据库，数据库中的表或者表中的一条记录就可以直接通过操作类或者类实例来完成。\n\nSQLAlchemy 是Python 社区最知名的 ORM 工具之一，为高效和高性能的数据库访问设计，实现了完整的企业级持久模型。\n接下来我们将使用 SQLAlchemy 和 MySQL 构建一个博客应用的实验库。\n3. 连接与创建\n安装SQLAlchemy\npip install sqlalchemy\n数据库我们采用Mysql，安装过程这里省略。可参考我的lnmp安装步骤 http://www.jianshu.com/p/1e51985b46dd\n启动mysql服务\nsystemctl start mysqld\n进入数据库命令行\nmysql\n更改数据库授权，远程主机可访问\nupdate mysql.user set Host='%' where HOST='localhost' and User='root';\n接下来我们使用图形化数据库操作工具（Navicat Premium）来操作数据库创建一个blog的数据库\n\n安装数据库驱动\npip install pymysql\n3.1 连接数据库\n\n新建一个db.py的文件，写入下面的内容：\n#!/usr/bin/env python\n# _*_ coding:utf-8 _*_\n__author__ = 'junxi'\n\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.ext.declarative import declarative_base\n\n\nengine = create_engine('mysql+pymysql://blog:123456@localhost:3306/blog?charset=utf8')\nBase = declarative_base()\n\nprint(engine)\n运行：\nEngine(mysql+pymysql://blog:***@localhost:3306/blog?charset=utf8)\n3.2 描述表结构\n\n要使用 ORM, 我们需要将数据表的结构用 ORM 的语言描述出来。SQLAlchmey 提供了一套 Declarative 系统来完成这个任务。我们以创建一个 users 表为例，看看它是怎么用 SQLAlchemy 的语言来描述的：\n编辑db.py:\n#!/usr/bin/env python\n# _*_ coding:utf-8 _*_\n__author__ = 'junxi'\n\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy import Column, String, Integer, Text, Boolean, DateTime, ForeignKey, Table\nfrom sqlalchemy.orm import relationship, sessionmaker\n\n\nengine = create_engine('mysql+pymysql://blog:123456@localhost:3306/blog?charset=utf8')\nBase = declarative_base()\n\n\nclass User(Base):\n    __tablename__ = 'users'\n\n    id = Column(Integer, primary_key=True)\n    username = Column(String(64), nullable=False, index=True)\n    password = Column(String(64), nullable=False)\n    email = Column(String(64), nullable=False, index=True)\n\n    def __repr__(self):\n        return \"%s(%r)\" % (self.__class__.__name__, self.username)\n\n\nif __name__ == '__main__':\n    Base.metadata.create_all(engine)\n我们看到，在 User 类中，用 __tablename__ 指定在 MySQL 中表的名字。我们创建了三个基本字段，类中的每一个 Column 代表数据库中的一列，在 Colunm中，指定该列的一些配置。第一个字段代表类的数据类型，上面我们使用 String, Integer 俩个最常用的类型，其他常用的包括：\nTextBooleanSmallIntegerDateTimeForeignKeynullable=False 代表这一列不可以为空，index=True 表示在该列创建索引。\n另外定义 __repr__ 是为了方便调试，你可以不定义，也可以定义的更详细一些。\n运行 db.py\n运行程序，我们在Mysql命令行中看看表是如何创建的：\nC:\\Windows\\system32>mysql -ublog -p123456\n\nmysql> use blog;\nDatabase changed\n\nmysql> show create table users\\G;\n*************************** 1. row ***************************\n       Table: users\nCreate Table: CREATE TABLE `users` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `username` varchar(64) NOT NULL,\n  `password` varchar(64) NOT NULL,\n  `email` varchar(64) NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `ix_users_username` (`username`),\n  KEY `ix_users_email` (`email`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\n1 row in set (0.00 sec)\n4. 关系定义\n4.1 一对多关系\n\n一个普通的博客应用，用户和文章显然是一个一对多的关系，一篇文章属于一个用户，一个用户可以写很多篇文章，那么他们之间的关系可以这样定义：\nclass User(Base):\n    __tablename__ = 'users'\n\n    id = Column(Integer, primary_key=True)\n    username = Column(String(64), nullable=False, index=True)\n    password = Column(String(64), nullable=False)\n    email = Column(String(64), nullable=False, index=True)\n    articles = relationship('Article')\n\n    def __repr__(self):\n        return \"%s(%r)\" % (self.__class__.__name__, self.username)\n\n\nclass Article(Base):\n    __tablename__ = 'articles'\n\n    id = Column(Integer, primary_key=True)\n    title = Column(String(255), nullable=False, index=True, name=\"标题\")\n    content = Column(Text)\n    user_id = Column(Integer, ForeignKey(\"users.id\"))\n    author = relationship('User')\n\n    def __repr__(self):\n        return \"%s(%r)\" % (self.__class__.__name__, self.title)\n每篇文章有一个外键指向 users 表中的主键 id， 而在 User 中使用 SQLAlchemy 提供的 relationship 描述 关系。而用户与文章的之间的这个关系是双向的，所以我们看到上面的两张表中都定义了 relationship。\nSQLAlchemy 提供了 backref 让我们可以只需要定义一个关系：articles = relationship('Article', backref='author')添加了这个就可以不用再在 Article 中定义 relationship 了！\n4.2 一对一关系\n\n在 User 中我们只定义了几个必须的字段， 但通常用户还有很多其他信息，但这些信息可能不是必须填写的，我们可以把它们放到另一张 UserInfo 表中，这样User 和 UserInfo 就形成了一对一的关系。你可能会奇怪一对一关系为什么不在一对多关系前面？那是因为一对一关系是基于一对多定义的：\nclass User(Base):\n    __tablename__ = 'users'\n\n    id = Column(Integer, primary_key=True)\n    username = Column(String(64), nullable=False, index=True)\n    password = Column(String(64), nullable=False)\n    email = Column(String(64), nullable=False, index=True)\n    articles = relationship('Article')\n    userinfo = relationship('UserInfo', backref='user', uselist=False)\n\n    def __repr__(self):\n        return \"%s(%r)\" % (self.__class__.__name__, self.username)\n\n\nclass UserInfo(Base):\n    __tablename__ = 'userinfos'\n\n    id = Column(Integer, primary_key=True)\n    name = Column(String(64))\n    qq = Column(String(11))\n    phone = Column(String(11))\n    link = Column(String(64))\n    user_id = Column(Integer, ForeignKey('users.id'))\n定义方法和一对多相同，只是需要添加 userlist=False 。\n4.3 多对多关系\n一篇博客通常有一个分类，好几个标签。标签与博客之间就是一个多对多的关系。多对多关系不能直接定义，需要分解成俩个一对多的关系，为此，需要一张额外的表来协助完成：\n\"\"\"\n# 这是创建表的另一种写法\narticle_tag = Table(\n    'article_tag', Base.metadata,\n    Column('article_id', Integer, ForeignKey('articles.id')),\n    Column('tag_id', Integer, ForeignKey('tags.id'))\n)\n\"\"\"\n\n\nclass ArticleTag(Base):\n    __tablename__ = 'article_tag'\n\n    id = Column(Integer, primary_key=True)\n    article_id = Column(Integer, ForeignKey('articles.id'))\n    tag_id = Column(Integer, ForeignKey('tags.id'))\n\n\nclass Tag(Base):\n    __tablename__ = 'tags'\n\n    id = Column(Integer, primary_key=True)\n    name = Column(String(64), nullable=False, index=True)\n\n    def __repr__(self):\n        return \"%s(%r)\" % (self.__class__.__name__, self.name)\n4.4 映射到数据库\n#!/usr/bin/env python\n# _*_ coding:utf-8 _*_\n__author__ = 'junxi'\n\n\"\"\"\nmysql://username:password@hostname/database\npostgresql://username:password@hostname/database\nsqlite:////absolute/path/to/database\nsqlite:///c:/absolute/path/to/database\n\"\"\"\n\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy import Column, String, Integer, Text, Boolean, DateTime, ForeignKey, Table\nfrom sqlalchemy.orm import relationship, sessionmaker\n\nengine = create_engine('mysql+pymysql://blog:123456@localhost:3306/blog?charset=utf8')\nBase = declarative_base()\n\n# print(engine)\n\n\nclass User(Base):\n    __tablename__ = 'users'\n\n    id = Column(Integer, primary_key=True)\n    username = Column(String(64), nullable=False, index=True)\n    password = Column(String(64), nullable=False)\n    email = Column(String(64), nullable=False, index=True)\n    articles = relationship('Article')\n    userinfo = relationship('UserInfo', backref='user', uselist=False)\n\n    def __repr__(self):\n        return \"%s(%r)\" % (self.__class__.__name__, self.username)\n\n\nclass UserInfo(Base):\n    __tablename__ = 'userinfos'\n\n    id = Column(Integer, primary_key=True)\n    name = Column(String(64))\n    qq = Column(String(11))\n    phone = Column(String(11))\n    link = Column(String(64))\n    user_id = Column(Integer, ForeignKey('users.id'))\n\n\nclass Article(Base):\n    __tablename__ = 'articles'\n\n    id = Column(Integer, primary_key=True)\n    title = Column(String(255), nullable=False, index=True)\n    content = Column(Text)\n    user_id = Column(Integer, ForeignKey(\"users.id\"))\n    author = relationship('User')\n\n    def __repr__(self):\n        return \"%s(%r)\" % (self.__class__.__name__, self.title)\n\n\n\"\"\"\n# 这是创建表的另一种写法\narticle_tag = Table(\n    'article_tag', Base.metadata,\n    Column('article_id', Integer, ForeignKey('articles.id')),\n    Column('tag_id', Integer, ForeignKey('tags.id'))\n)\n\"\"\"\n\n\nclass ArticleTag(Base):\n    __tablename__ = 'article_tag'\n\n    id = Column(Integer, primary_key=True)\n    article_id = Column(Integer, ForeignKey('articles.id'))\n    tag_id = Column(Integer, ForeignKey('tags.id'))\n\n\nclass Tag(Base):\n    __tablename__ = 'tags'\n\n    id = Column(Integer, primary_key=True)\n    name = Column(String(64), nullable=False, index=True)\n\n    def __repr__(self):\n        return \"%s(%r)\" % (self.__class__.__name__, self.name)\n\n\nif __name__ == '__main__':\n    Base.metadata.create_all(engine)\n进入MySQL查看:\nmysql> use blog;\nDatabase changed\nmysql> show tables;\n+----------------+\n| Tables_in_blog |\n+----------------+\n| article_tag    |\n| articles       |\n| tags           |\n| userinfos      |\n| users          |\n+----------------+\n5 rows in set (0.00 sec)\n所有的表都已经创建好了！\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}