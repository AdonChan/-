{"title": "【正经的AI on Python入门系列】0.来学点Python吧！从一个斗图小工具开始 - Akers的技术分享 ", "index": "python", "content": "Before The Beginning\n    近年，技术圈炒的最火的两个话(ba)题(gua)不外乎就是人工智障智能以及炒币区块链了，这个系列文章我主要以一个小菜鸟的角度一步一步的对人工智能的相关知识做一点了解，也算是一个颤颤巍巍追着AI浪潮公交车的社会主义五好青年，咳咳，扯远了...其实对于人工智能，严格意义上更多的是一个科学领域的课题，其中更多的是数学、语言学、社会学、神经科学的研究内容，对于我们这种社会底层的小码农想要进入这个领域往往可能面临的是一大堆的专业名词，一大堆的技术论文，一大堆公开课还有一大堆的不知道到底搞懂没有但是吹的很牛逼的培训机构讲师，门都没入就被各种忽悠到西伯利亚去了。    因此，本文将会以一些正经的严谨的有深度的（大概吧）的课题，慢慢的接触人工智能的相关知识。\nWhy Python?\n    提起人工智能，就不得不提Python语言，但实际上Python不是什么新东西，反而这是一门相当老的语言了起源甚至可以追溯到80年代末90年代初，那为何它会在人工智能这个风口独领风骚占据了半壁江山呢？Python的特点总体可以归纳成以下几点：\n\n成熟完善的社区——比起go、koltin之类的新兴语言，相关资料简直是好找一个数量级\n大量的库——其中包括了Python的库、用Python包装的C/C++库、甚至各种语言的库\n与生俱来的C/c++互操作性——其实不止C，Python与很多语言都具备良好的互操作性，胶水语言的大名不是白叫的\n语法简单优雅——Python的哲学就是简单，甚至某些问题只会提供你唯一的解决方案，不够灵活但简单啊！而且，对于一些不是计算机专业人士来说，他的语法可能更接近自然语言，更容易被接受，而且是真正的编程语言（它的竞争对手——各种Shell脚本语言哭晕在厕所）\n\nHellow World!\n好的，按照国际管理，我们先用python来写个hellow world\nP.S. 本文基于Python3，而且一些语法细节也不会一一讲解，更完整的语法还请查阅官网文档！如非特殊情况的话还是更推荐大家学习Python3，至于Python2跟Python3的区别就不在赘述了。\n创建项目文件\nPython源码以.py为后缀，以下为一个最简例子：\nexample-1: helloWorld.py\n# -*- coding:utf-8 -*-\n#__author__ = 'akers'\n\nprint(\"hellow world !\")\n没错，就是这么简单！用python helloWorld.py运行，就能看到打印的Hellow World了！（没错，我单词打错了，仅此一家，版权所有，如有雷同，纯属巧合，本人不保留追究权利！）因为Python柔和了面向对象、面向过程、函数式编程等多种编程方式，因此类似这种直接在源文件中书写命令也是支持的，这种写法在制作一些小工具、小脚本、小实验的时候非常非常的方便，但我们要严谨一点对吧，所以我们再来个正经点的：\nPython中的main函数\n以下为一个Python的main方法的最简例子：example-1: hello_world_main.py\n# -*- coding:utf-8 -*-\n#__author__ = 'akers'\n\nif __name__ == \"__main__\":\n    print(\"hellow world !\");\n在上面例子中的if __name__ == \"__main__\":即为平时我们熟知的main方法了，那至于一些觉得这个很别扭的，看不惯的，可以使用如下这种格式的：\n# -*- coding:utf-8 -*-\n#__author__ = 'akers'\n\nimport sys #包导入\n\n# 常见的main函数定义\ndef main(argv=[]):\n    print(\"hellow world: \", argv)\n\n\n# 你看不到我，你看不到我\nif __name__ == \"__main__\":\n    main(sys.argv) # sys.argv获取命令行参数\n这样是不是就亲切很多了呢，跟你熟悉的java和c是不是就一样一样了呢....额....你说那个__name__啥的，没事你就当没看见了！啊？你问这个__name__是什么？其实它是一个内置变量，如果是直接执行的话，编译器会传入\"main\"如果是作为包引入，会传入包名。然后，本期文章就到此结束了，才怪！下面让我们把HelloWorld完善一下\n更高大上的hello world\n首先，我们准备两个素材\n先准备一个底图\n然后请出——————————馆长大人：\n然后，使用PIL库组合一下它们\n\nPIL是Python的一个视觉处理库，目前已经停止维护了，但它后继有人啊，pillow库fork了它，因此一般我们说PIL的时候，实际上用的是pillowPython的外部依赖，需要通过pip工具进行安装，然后才能在代码里import到相应的包，下面以安装过pillow为例：\npip install pillow\n\n引入依赖包\nfrom PIL import Image,ImageDraw,ImageFont\n加载图片\n#导入表情背景\nbackground=Image.open('./resources/background/pander/default.png')\n#导入表情\nfaceImg=Image.open('./resources/face/jgz/laugth.png')\n组合图片\n#创建底图\ntarget=Image.new('RGBA', (250, 250), (0, 0, 0, 0))\n#表情背景贴到底图上\ntarget.paste(background, (0,0))\n#表情图贴在合适的位置上，注意啊，别挡到背景图\ntarget.paste(faceImg, (62,37))\n加上点文字\n#ImageDraw为PIL的绘图模块\ndraw = ImageDraw.Draw(target)\n#设置字体\nfont = ImageFont.truetype('./resources/msyh.ttc', 30)\n#底图上的10,200位置写入文字\ndraw.text((10, 200), argv[1],fill='black', font=font)\n上面的argv[1]就是取第一个命令行参数\n走你！\n运行一下我们脚本：\npython emofigther.py \"Hellow World!\"\n然后，你就会得到一个Hellow World!(没错，我依然打错单词了！)\n随便再扩展一下\n我相信你们的斗图之魂已经有点按耐不住了，但是等等，现在生成的图片还得到output文件夹找，非常不方便是吧，能不能实现在运行脚本后，生成的图片自动放到剪贴板呢？当然可以！我们可以用pywin32这个package，他提供了一套用python封装的win32库（windows应用开发的一套底层库）接口。\nfrom io import BytesIO\nimport win32clipboard as clip\nimport sys, platform, win32con\n\nif 'Windows' in platform.platform() or 'windows' in platform.platform():\n    # 打开字节流\n    output = BytesIO()\n    # 打开剪贴板\n    clip.OpenClipboard() \n    # 先清空剪贴板\n    clip.EmptyClipboard()\n    # 将图片保存到字节流\n    target.save(output, format=\"BMP\")\n    # 去掉字节流中的前14个字符（BMP位图文件头）\n    data = output.getvalue()[14:]\n    # 将图片放入剪贴板，这里是不带文件头的数据\n    clip.SetClipboardData(win32con.CF_DIB, data) \n    clip.CloseClipboard()\n    output.close()\n然后再运行下我们的emofigther\npython emofigther.py \"Ctrl-V大法好！\"\n然后找个地方试试Ctrl-V，惊喜不惊喜，意外不意外？\nEnding\n至此，我们已经用python轻松愉快的学会了制作一个斗图工具了\n本章节的所有例子，都可以在我的GitHub上找到：sources of example-1\n等等，有BUG！好吧，目前我们的小工具可能还存在着一些小小的瑕疵：\n\n文本是左对齐的，如何进行居中呢？\n当字数过多的时候，怎么保证能全部显示呢？\n底图与表情都只有一款，好单调啊，都斗不过别人了，咋办呢？\n\n恩，为了解决这些问题，我们——————\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "0"}