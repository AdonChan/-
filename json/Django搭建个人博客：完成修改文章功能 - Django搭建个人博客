{"title": "Django搭建个人博客：完成修改文章功能 - Django搭建个人博客 ", "index": "python,django", "content": "目前为止我们已经完成了文章的新建、删除以及查看，还剩最后一项，即对已经完成的文章进行修改。\n实际上修改文章与新建文章有点类似，不同的地方有两点：\n\n修改是在原有文章的基础上，因此需要传递 id 指明具体需要修改的文章\n加载页面时需要将旧的内容作为默认值填写到表单中，因此需要将文章对象传递到html中\n\n按照这个思路，接下来先写视图函数。\n视图函数\n在ariticle/views.py中增加修改文章的视图函数article_update()：\narticle/views.py\n\n...\n\n# 更新文章\ndef article_update(request, id):\n    \"\"\"\n    更新文章的视图函数\n    通过POST方法提交表单，更新titile、body字段\n    GET方法进入初始表单页面\n    id： 文章的 id\n    \"\"\"\n\n    # 获取需要修改的具体文章对象\n    article = ArticlePost.objects.get(id=id)\n    # 判断用户是否为 POST 提交表单数据\n    if request.method == \"POST\":\n        # 将提交的数据赋值到表单实例中\n        article_post_form = ArticlePostForm(data=request.POST)\n        # 判断提交的数据是否满足模型的要求\n        if article_post_form.is_valid():\n            # 保存新写入的 title、body 数据并保存\n            article.title = request.POST['title']\n            article.body = request.POST['body']\n            article.save()\n            # 完成后返回到修改后的文章中。需传入文章的 id 值\n            return redirect(\"article:article_detail\", id=id)\n        # 如果数据不合法，返回错误信息\n        else:\n            return HttpResponse(\"表单内容有误，请重新填写。\")\n\n    # 如果用户 GET 请求获取数据\n    else:\n        # 创建表单类实例\n        article_post_form = ArticlePostForm()\n        # 赋值上下文，将 article 文章对象也传递进去，以便提取旧的内容\n        context = { 'article': article, 'article_post_form': article_post_form }\n        # 将响应返回到模板中\n        return render(request, 'article/update.html', context)\n更新的视图与创建文章非常相似，但又有点小区别：\n\n文章的 id 作为参数传递进来了\n用户POST提交表单时没有创建新的文章，而是在之前的文章中修改\n\nredirect函数没有返回文章列表，而是返回到修改后的文章页面去了，因此需要同时把文章的id也打包传递进去，这是url所规定的\nGET获取页面时将article对象也传递到模板中去，以便后续的调用\n\n编写模板\n模板文件就与创建文章的更像了，不过我们这里还是重新写一遍。\n新建templates/article/update.html并写入：\ntemplates/article/update.html\n\n{% extends \"base.html\" %} {% load staticfiles %}\n{% block title %} 更新文章 {% endblock title %}\n{% block content %}\n<div class=\"container\">\n    <div class=\"row\">\n        <div class=\"col-12\">\n            <br>\n            <form method=\"post\" action=\".\">\n                {% csrf_token %}\n                <div class=\"form-group\">\n                    <label for=\"title\">文章标题</label>\n                    <!-- 在 value 属性中指定文本框的初始值为旧的内容，即 article 对象中的 title 字段 -->\n                    <input type=\"text\" class=\"form-control\" id=\"title\" name=\"title\" value=\"{{ article.title }}\">\n                </div>\n                <div class=\"form-group\">\n                    <label for=\"body\">文章正文</label>\n                    <!-- 文本域不需要 value 属性，直接在标签体中嵌入数据即可 -->\n                    <textarea type=\"text\" class=\"form-control\" id=\"body\" name=\"body\" rows=\"12\">{{ article.body }}</textarea>\n                </div>\n                <button type=\"submit\" class=\"btn btn-primary\">完成</button>\n            </form>\n        </div>\n    </div>\n</div>\n{% endblock content %}\n在模板中，分别将文章旧的标题和正文作为初始值，传递了进去，其他就与新建文章的模板完全没区别了。\n有读者可能就会问了，既然这两个函数、模板都很相似，能不能合并成一个函数、模板呢？当然是可以的，合并相同功能的函数可以让代码更加简洁漂亮，也便于后期的维护。有兴趣的读者可以自己尝试一下。\nURL 和入口\n接下来的套路都懂的，配置路由article/urls.py：\narticle/urls.py\n\n...\n\nurlpatterns = [\n    ...\n    \n    # 更新文章\n    path('article-update/<int:id>/', views.article_update, name='article_update'),\n]\n在文章详情页面tempaltes/article/detail.html中添加修改文章的入口：\ntempaltes/article/detail.html\n\n...\n<div class=\"col-12 alert alert-success\">作者：{{ article.author }}\n    · <a href=\"#\" onclick=\"confirm_delete()\">删除文章</a>\n    · <a href=\"{% url \"article:article_update\" article.id %}\">编辑文章</a>\n</div>\n启动服务器，可以看到修改文章的功能就实现了。同样的，如有故障也不要着急，在Debug页面寻找出错的线索，求助网络帮忙解决吧。\n总结\n至此我们就实现了一篇文章的增、删、改、查四个基础功能，也算小有成就。\n当然还有很多进阶的功能可以去做，不过我们在这里先休息休息，来罐快乐水庆祝一下。\n下一章开始解决更加燃眉之急的内容：用户管理。\n\n有疑问请在杜赛的个人网站留言，我会尽快回复。\n或Email私信我：dusaiphoto@foxmail.com\n项目完整代码：Django_blog_tutorial\n\n\n转载请告知作者并注明出处。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "0"}