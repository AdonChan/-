{"title": "Python入门指引 - 个人文章 ", "index": "python", "content": "Python是比较热的语言，个人兴趣参考官方文档：https://docs.python.org/2/tut...边看边翻译了一下（后面会持续更新），有兴趣的可以看看。\nPython具有高级的数据结构，能高效地面向对象编程。它的优雅的语法、动态类型、解释属性使它能快速地在大部分平台开发应用程序。它的第三方包、工具和库都可以在这里找到：https://www.python.org/。\nPython很容易通过C/C++函数或数据类型进行扩展。写扩展参看:扩展指导， C/C++的Python API\n更多文档参看Python标准库，Python的API\n通过这个入门教程，你将学习到Pyton的一些常用特性和标准库的一些方法或模块。\n写在前面\n对于每天在电脑面前工作的人来说，可能你需要做一些自动化的工作，比如批量替换，查找更改等，或者你想写一些界面程序，游戏等。\n而对于专业的软件开发人员来说，通过C/C++/Java库去开发、测试、编译等又太繁琐了。\n这时候，Python是最佳的选择。\n你可以写一些shell脚本或者bat脚本去移动文件或者修改数据，但不是很适合写界面程序或者游戏。C/C++/Java又太繁琐了。而Python比较适合快速的在各个平台（windows, Mac, Unix）完成你要的工作。\nPython是一门真正的编程语言，它有高级的数据结构，比如可灵活操作的数组和字典。\nPython是模块化的，它的标准库里面有你可用的一些模块，这些模块提供了比如文件I/O，sockets等功能。\nPython可以写出比C/C++/Java更简洁的程序，原因有三：1 有高级的数据结构2 通过缩进进行区分声明块而不是括号3 不需要变量或者参数声明\nPython是可扩展的。你可以把Python解释器嵌入到C程序中。\n使用Python解释器\n运行python解释器\n方式1：Python解释器在linux下一般安装在/usr/local/bin/python目录下，切换到该目录下，输入以下命令可以运行python解释器\npython\nwindows下一般安装在C:Python27目录下，win+r快捷键，然后输入一下cmd，打开dos界面，输入以下命令，设置环境变量：\nset path=%path%;C:\\python27\n则任意目录下，输入python命令即可打开python解释器方式2：\npython -c command [arg] ..\n因为命令行可能有一些特殊字符或者空白，最好用单引号引起来。退出python解释器：Unix下在命令行界面输入快捷键：Control-D, Windows下输入Control-Z。或者输入：\nquit()\n调用python模块（模块也就是python源文件）：\npython -m module [arg] ...\n进入交互命令模式：\npython -i ...\n参数传递\n命令行的参数会赋值给sys模块的argv变量。可以通过import sys访问参数。argv的长度至少有1。当没有参数的时候，sys.argv[0]是一个空串。当脚本的名字为\"-\",则sys.argv[0]是\"-\",当用了-c命令，则sys.argv[0]的值为\"-c\"。当用了-m，sys.argv[0]的值为模块的名字。-c和-m后面的参数，python解释器不会处理。\n交互模式\n多行模式前面是... 单行是>>>\n>>> the_world_is_flat = 1\n>>> if the_world_is_flat:\n...     print \"Be careful not to fall off!\"\n...\n解释器和环境\n设置代码编码\n一般情况是不用设置的 默认为utf-8\n#!/usr/bin/env python\n# -*- coding: cp-1252 -*-\nPython介绍\n开头标识注释，>>>和...开头标识python语句\n>>>\n>>> #这是注释\n... a = 1;#这是注释\n>>> print a\n1\n把python当做计算器\n数字\n>>> 2 + 2\n4\n>>> 50 - 5*6\n20\n>>> (50 - 5.0*6) / 4\n5.0\n>>> 8 / 5.0\n1.6\n这里2是int 5.0是float,/的结果是什么类型是根据参与计算的两个数，如果有一个数是float则返回float类型。//操作符是向下取数，小数位为0。\n>>> 12//7.0\n1.0\n>>>\n%是求余**是多次方\n>>> 5**2\n25\n>>>\n声明变量n=12如果使用一个未声明的变量会报错\n>>> n\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nNameError: name 'n' is not defined\n>>>\n多项式计算，会自动进行数据类型的转换：int和float一起计算，int会自动转为float\n交互模式下，最后一个打印的变量会赋值给_\n>>> tax = 12.5 / 100\n>>> price = 100.50\n>>> price * tax\n12.5625\n>>> price + _\n113.0625\n>>> round(_, 2)\n113.06\n_是只读的，不能被赋值。\n字符串\n单引号或者双引号里表示字符串，用来转义如果不想要转义：字符串前加一个r\n>>> print 'C:\\some\\name'  # here \\n means newline!\nC:\\some\name\n>>> print r'C:\\some\\name'  # note the r before the quote\nC:\\some\\name\n多行字符串：三个\"\"\"或者'''\nprint \"\"\"\\\nUsage: thingy [OPTIONS]\n     -h                        Display this usage message\n     -H hostname               Hostname to connect to\n\"\"\"\n标识去掉换行，没有输出是这样的：\n>>> print \"\"\"\n... aef\n... asdf\n... \"\"\"\n\naef\nasdf\n字符串拼接：+ 字符串重复:*\n>>> \"un\"*2 +\" awef\"\n'unun awef'\n>>>\n自动拼接：\n>>> 'Py' 'thon'\n'Python'\n获取字符串的单个字符\n>>> a = \"python\"\n>>> a[0]\n'p'\n负数标识从尾部开始读取: -0等于0 最后一个字符是-1\n>>> a = \"python\"\n>>> a[-1]\n'n'\n>>>\n取区间：\n>>> a = \"python\"\n>>> a[0:2]\n'py'\n>>> a[2:]\n'thon'\n>>> a[:4]\n'pyth'\n>>> a[-2:]\n'on'\n>>>\n越界访问数组会报错：\n>>> word[42]  # the word only has 6 characters\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nIndexError: string index out of range\n但是取不存在的区间不会报错：\n>>> a[-2:45]\n'on'\n>>>\n字符串无法被修改：\n>>> word[0] = 'J'\n  ...\nTypeError: 'str' object does not support item assignment\n>>> word[2:] = 'py'\n  ...\nTypeError: 'str' object does not support item assignment\nunicode字符串\n支持unicode字符串：字符串前加u\n>>> u'Hello World !'\nu'Hello World !'\n>>> u'Hello\\u0020World !'\nu'Hello World !'\n0x0020标识空格支持原始模式： 字符串前面加入urpython的默认编码方式是：ASCII码，如果Unicode字符串被打印或者写到文件或者是str()方法转化都会默认转为ASCII码，如果字符串不在0-127范围就会报错\n>>> u\"abc\"\nu'abc'\n>>> str(u\"abc\")\n'abc'\n>>> u\"äöü\"\nu'\\xe4\\xf6\\xfc'\n>>> str(u\"äöü\")\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in ?\nUnicodeEncodeError: 'ascii' codec can't encode characters in position 0-2: ordinal not in range(128)\n转换为特定编码：方法的参数为小写\n>>> u\"äöü\".encode('utf-8')\n'\\xc3\\xa4\\xc3\\xb6\\xc3\\xbc'\n数组\n定义一个数组\n>>> squares = [1, 4, 9, 16, 25]\n>>> squares\n[1, 4, 9, 16, 25]\n获取数组内元素\n>>> squares[0]  # indexing returns the item\n1\n>>> squares[-1]\n25\n>>> squares[-3:]  # slicing returns a new list 例子三\n[9, 16, 25]\n获取数组内片段，比如上面例子三，会返回一个新的数组拷贝，原数组不会发生改变数组合并：\n>>> squares + [36, 49, 64, 81, 100]\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n字符串的内容是不能被更改的，而数组是可以被更改的：\n>>> cubes = [1, 8, 27, 65, 125]  # something's wrong here\n>>> 4 ** 3  # the cube of 4 is 64, not 65!\n64\n>>> cubes[3] = 64  # replace the wrong value\n>>> cubes\n[1, 8, 27, 64, 125]\n给数组添加元素：\n>>> cubes.append(216)  # add the cube of 6\n>>> cubes.append(7 ** 3)  # and the cube of 7\n>>> cubes\n[1, 8, 27, 64, 125, 216, 343]\n可以赋值给截取的数组：\n>>> letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']\n>>> letters\n['a', 'b', 'c', 'd', 'e', 'f', 'g']\n>>> # replace some values\n>>> letters[2:5] = ['C', 'D', 'E']\n>>> letters\n['a', 'b', 'C', 'D', 'E', 'f', 'g']\n>>> # now remove them\n>>> letters[2:5] = []\n>>> letters\n['a', 'b', 'f', 'g']\n>>> # clear the list by replacing all the elements with an empty list\n>>> letters[:] = []\n>>> letters\n[]\n获取数组的长度：\n>>> letters = ['a', 'b', 'c', 'd']\n>>> len(letters)\n4\n数组的元素也可以是一个数组：\n>>> a = ['a', 'b', 'c']\n>>> n = [1, 2, 3]\n>>> x = [a, n]\n>>> x\n[['a', 'b', 'c'], [1, 2, 3]]\n>>> x[0]\n['a', 'b', 'c']\n>>> x[0][1]\n'b'\n终于开始编程了！\n如何实现一个斐波那契:\n>>> # 这是一个注释\n... a, b = 0, 1  #分别给a赋值为0 b赋值为1 \n>>> while b < 10:#这是一个循环\n...     print b  #打印b的值（并且这里的代码前面有空格（也就是行缩进））\n...     a, b = b, a+b #a赋值为b，b赋值为a+b的和\n...\n1\n1\n2\n3\n5\n8\n之前说过，行缩进标识接下来是一个代码块。print方法，可以控制格式，比如增加空格：\n>>> i = 256*256\n>>> print 'The value of i is', i\nThe value of i is 65536\n在print语句最后加一个逗号，避免打印结果换行：\n>>> a, b = 0, 1\n>>> while b < 1000:\n...     print b,\n...     a, b = b, a+b\n...\n1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987\n控制流\nif语句\n>>> x = int(raw_input(\"Please enter an integer: \"))\nPlease enter an integer: 42\n>>> if x < 0: #冒号可以开启多行模式\n...     x = 0\n...     print 'Negative changed to zero'\n... elif x == 0:\n...     print 'Zero'\n... elif x == 1:\n...     print 'Single'\n... else:\n...     print 'More'\n...\nif…elif..else(不是必须的)…\nfor\nPython的for可以遍历数组和字符串（这个和C语言的for语句有略微不同)\n>>> # Measure some strings:\n... words = ['cat', 'window', 'defenestrate']\n>>> for w in words:\n...     print w, len(w)\n...\ncat 3\nwindow 6\ndefenestrate 12\n在循环内修改一个数组：首先通过截取数组的方法对原数组进行拷贝（这个知识点之前有提过）\n>>> for w in words[:]:  # words[:]可以对原数组进行拷贝\n...     if len(w) > 6:\n...         words.insert(0, w)\n...\n>>> words\n['defenestrate', 'cat', 'window', 'defenestrate']\nrange()函数\nrange函数能根据算法创建一个数组\n>>> range(5, 10) #创建所有元素为5到10区间并递增的数组\n[5, 6, 7, 8, 9]\n>>> range(0, 10, 3)#递增3\n[0, 3, 6, 9]\n>>> range(-10, -100, -30)#递减30\n[-10, -40, -70]\n遍历数组的索引：\n>>> a = ['Mary', 'had', 'a', 'little', 'lamb']\n>>> for i in range(len(a)):\n...     print i, a[i]\n...\n0 Mary\n1 had\n2 a\n3 little\n4 lamb\n退出循环\nbreak语句执行会退出里层的for循环;continue会跳过后面语句的执行（和C语言用法一样）。\n>>> for n in range(2, 10):\n...     for x in range(2, n):\n...         if n % x == 0:\n...             print n, 'equals', x, '*', n/x\n...             break\n...     else:\n...         # loop fell through without finding a factor\n...         print n, 'is a prime number'\n...\n2 is a prime number\n3 is a prime number\n4 equals 2 * 2\n5 is a prime number\n6 equals 2 * 3\n7 is a prime number\n8 equals 2 * 4\n9 equals 3 * 3\npass语句\npass语句不会做任何事，只是用来占位用的\n>>> class MyEmptyClass:\n...     pass\n...\n>>> def initlog(*args):\n...     pass   # Remember to implement this!\n...\n定义函数和调用函数\n>>> def fib(n):    # def关键字标识定义函数，这里函数名为fib\n...     \"\"\"Print a Fibonacci series up to n.\"\"\" #\n...     a, b = 0, 1\n...     while a < n:\n...         print a,\n...         a, b = b, a+b\n...\n>>> # Now call the function we just defined:\n... fib(2000)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597\n注意函数体要代码要缩进函数可以被赋值(fib会被加入符号表)：\n>>> fib\n<function fib at 10042ed0>\n>>> f = fib # f也会被加入符号表\n>>> f(100)\n0 1 1 2 3 5 8 13 21 34 55 89\n即便函数没有return，也会返回一个None\n>>> fib(0)\n>>> print fib(0)\nNone\nreturn后面没有跟任何东西也是返回None\n>>> def fib2(n):  # return Fibonacci series up to n\n...     result = []\n...     a, b = 0, 1\n...     while a < n:\n...         result.append(a)    # 这里是调用数组的append方法\n...         a, b = b, a+b\n...     return result\n...\n>>> f100 = fib2(100)    # call it\n>>> f100                # write the result\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n定义带参数的函数\n参数带默认值：retries的默认值为4\ndef ask_ok(prompt, retries=4, complaint='Yes or no, please!'):\n    while True: # True是关键字\n        ok = raw_input(prompt) #raw_input是内置的函数，用于IO输入\n        if ok in ('y', 'ye', 'yes'):\n            return True\n        if ok in ('n', 'no', 'nop', 'nope'):\n            return False\n        retries = retries - 1\n        if retries < 0:\n            raise IOError('refusenik user') # raise是关键字 抛出异常\n        print complaint\n默认值可以为变量：i是一个变量\ni = 5\n\ndef f(arg=i):\n    print arg\n\ni = 6\nf()\n默认参数如果是一个可变的对象，会被赋值多次：\ndef f(a, L=[]):\n    L.append(a)\n    return L\n\nprint f(1)\nprint f(2)\nprint f(3)\n会打印出：\n\n[1]\n[1, 2]\n[1, 2, 3]\n如果你不想L被改变，你可以这么做：\ndef f(a, L=None):\n    if L is None:\n        L = []\n    L.append(a)\n    return L\n如果只接受一个参数，但是传递了两个参数会报错：\n>>> def function(a):\n...     pass\n...\n>>> function(0, a=0)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: function() got multiple values for keyword argument 'a'\n**kewords接收字典参数：\n\ndef cheeseshop(kind, *arguments, **keywords):\n    print \"-- Do you have any\", kind, \"?\"\n    print \"-- I'm sorry, we're all out of\", kind\n    for arg in arguments:\n        print arg\n    print \"-\" * 40\n    keys = sorted(keywords.keys()) #按字典顺序 \n    for kw in keys:\n        print kw, \":\", keywords[kw]\n*arg接受不确定个数的参数：\ndef write_multiple_items(file, separator, *args):\n    file.write(separator.join(args))\n自动解析参数：\n>>> range(3, 6)             # 正常情况调用方式\n[3, 4, 5]\n>>> args = [3, 6]\n>>> range(*args)            # 从一个数组里解析参数\n[3, 4, 5]\n>>> def parrot(voltage, state='a stiff', action='voom'):\n...     print \"-- This parrot wouldn't\", action,\n...     print \"if you put\", voltage, \"volts through it.\",\n...     print \"E's\", state, \"!\"\n...\n>>> d = {\"voltage\": \"four million\", \"state\": \"bleedin' demised\", \"action\": \"VOOM\"}\n>>> parrot(**d)\n-- This parrot wouldn't VOOM if you put four million volts through it. E's bleedin' demised !\n文档字符串:\n>>> def my_function():\n...     \"\"\"Do nothing, but document it.\n...\n...     No, really, it doesn't do anything.\n...     \"\"\"\n...     pass\n...\n>>> print my_function.__doc__\nDo nothing, but document it.\n\n    No, really, it doesn't do anything.\nLambda表达式一个匿名函数，lambda a, b: a+b. a和b是两个参数，结果返回a和b的和：\n>>> def make_incrementor(n):\n...     return lambda x: x + n\n...\n>>> f = make_incrementor(42)\n>>> f(0)\n42\n>>> f(1)\n43\nlambda也可以作为参数传递：\n>>> pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]\n>>> pairs.sort(key=lambda pair: pair[1])\n>>> pairs\n[(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]\n编码格式建议\n不用Tab缩进，用4倍空格缩进必要时换行（避免单行超出79个字符）用空格区分函数或者类或者函数内部的一大段代码代码前面加上必要的注释用文档字符串操作符liagn两边或者逗号后面必须空格函数采用lower_case_width_underscore方式命令，类用驼峰(CanekCase)方式命名；总是用self当作类的第一个方法的参数不要用特殊的编码格式（ASCII是兼容所有的）\n数据结构\n数组\npython数据默认有一些常用方法：比如append, extend, insert等等\n作为堆栈使用\n>>> stack = [3, 4, 5]\n>>> stack.append(6)\n>>> stack.append(7)\n>>> stack\n[3, 4, 5, 6, 7]\n>>> stack.pop()\n7\n>>> stack\n[3, 4, 5, 6]\n>>> stack.pop()\n6\n>>> stack.pop()\n5\n>>> stack\n[3, 4]\n作为队列使用\n>>> from collections import deque\n>>> queue = deque([\"Eric\", \"John\", \"Michael\"])\n>>> queue.append(\"Terry\")          # Terry arrives\n>>> queue.append(\"Graham\")          # Graham arrives\n>>> queue.popleft()                # The first to arrive now leaves\n'Eric'\n>>> queue.popleft()                # The second to arrive now leaves\n'John'\n>>> queue                          # Remaining queue in order of arrival\ndeque(['Michael', 'Terry', 'Graham'])\n一些常用的方法\nfilter(function, sequence) : 返回function的值为true的所有值\n>>> def f(x): return x % 3 == 0 or x % 5 == 0\n...\n>>> filter(f, range(2, 25))\n[3, 5, 6, 9, 10, 12, 15, 18, 20, 21, 24]\nmap(function, sequence)： 返回处理后的值\n>>> def cube(x): return x*x*x\n...\n>>> map(cube, range(1, 11))\n[1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]\n传递两个数组： 分别从一个数组里取出一个数 返回相加后的结果\n>>> seq = range(8)\n>>> def add(x, y): return x+y\n...\n>>> map(add, seq, seq)\n[0, 2, 4, 6, 8, 10, 12, 14]\nreduce(function, sequence) ：把数组的第一个和第二个参数想加的和和第三个数再加。。如果数组为空，会返回异常\n>>> def add(x,y): return x+y\n...\n>>> reduce(add, range(1, 11))\n55\nreduce可以指定开始的第一个数的索引：\n>>> def sum(seq):\n...    def add(x,y): return x+y\n...    return reduce(add, seq, 0)\n...\n>>> sum(range(1, 11))\n55\n>>> sum([])\n0\n创建数组的几种形式：\n>>> squares = []\n>>> for x in range(10):\n...    squares.append(x**2)\n...\n>>> squares\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\nsquares = [x**2 for x in range(10)]\nsquares = map(lambda x: x**2, range(10))\n更复杂点的例子：x，y作为一个整体 必须加上括号\n>>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]\n[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]\n更多例子：\n>>> freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']\n>>> [weapon.strip() for weapon in freshfruit]\n['banana', 'loganberry', 'passion fruit']\n>>> [x, x**2 for x in range(6)]\n  File \"<stdin>\", line 1, in <module>\n    [x, x**2 for x in range(6)]\n              ^\nSyntaxError: invalid syntax\n>>> # flatten a list using a listcomp with two 'for'\n>>> vec = [[1,2,3], [4,5,6], [7,8,9]]\n>>> [num for elem in vec for num in elem]\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n>>> from math import pi\n>>> [str(round(pi, i)) for i in range(1, 6)]\n['3.1', '3.14', '3.142', '3.1416', '3.14159']\n二维数组\n>>> matrix = [\n...    [1, 2, 3, 4],\n...    [5, 6, 7, 8],\n...    [9, 10, 11, 12],\n... ]\n复杂点的例子：\n>>> [[row[i] for row in matrix] for i in range(4)]\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\n相当于：\n>>> transposed = []\n>>> for i in range(4):\n...    transposed.append([row[i] for row in matrix])\n...\n>>> transposed\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\n删除数组内元素：del\n>>> a = [-1, 1, 66.25, 333, 333, 1234.5]\n>>> del a[0]\n>>> a\n[1, 66.25, 333, 333, 1234.5]\n>>> del a[2:4]\n>>> a\n[1, 66.25, 1234.5]\n>>> del a[:]\n>>> a\n[]\n删除整个数组：\n>>> del a\n新类型：元组。\n输入可以加括号，也可以不加。输出都是带括号的。\n>>> t = 12345, 54321, 'hello!'  # 输入 没加括号\n>>> t[0]\n12345\n>>> t\n(12345, 54321, 'hello!')  # 输出 带括号\n>>> # Tuples may be nested:\n... u = t, (1, 2, 3, 4, 5)\n>>> u\n((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))\n>>> # 无法被修改\n... t[0] = 88888\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: 'tuple' object does not support item assignment\n>>> # 内部的元素可以是可变的类型 比如数组等\n... v = ([1, 2, 3], [3, 2, 1])\n>>> v\n([1, 2, 3], [3, 2, 1])\n空元组和只有一个元素的元组：\n>>> empty = ()\n>>> singleton = 'hello',    # <-- note trailing comma\n>>> len(empty)\n0\n>>> len(singleton)\n1\n>>> singleton\n('hello',)\n逆序元素：\n>>> t = (12345, 54321, 'hello!')\n>>> x, y, z = t\n新的类型：集合\n创建空集合：set()\n>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n>>> fruit = set(basket)              # 创建集合\n>>> fruit\nset(['orange', 'pear', 'apple', 'banana'])\n>>> 'orange' in fruit                # 测试是否oranage是否是集合fruit内部\nTrue\n>>> 'crabgrass' in fruit\nFalse\n集合a, b 之间的交集 并集\n>>> a = set('abracadabra')\n>>> b = set('alacazam')\n>>> a                                  # unique letters in a\nset(['a', 'r', 'b', 'c', 'd'])\n>>> a - b                              # letters in a but not in b\nset(['r', 'd', 'b'])\n>>> a | b                              # letters in either a or b\nset(['a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'])\n>>> a & b                              # letters in both a and b\nset(['a', 'c'])\n>>> a ^ b                              # letters in a or b but not both\nset(['r', 'd', 'b', 'm', 'z', 'l'])\n>>> a = {x for x in 'abracadabra' if x not in 'abc'}\n>>> a\nset(['r', 'd'])\n新的类型：字典\n字典是根据key索引的，而key数据类型可以为数字或者字符串，元组的元素都是不可变的，也可以作为key。数组不能作为key，因为数组可被修改\n>>> tel = {'jack': 4098, 'sape': 4139}\n>>> tel['guido'] = 4127\n>>> tel\n{'sape': 4139, 'guido': 4127, 'jack': 4098}\n>>> tel['jack']\n4098\n>>> del tel['sape']\n>>> tel['irv'] = 4127\n>>> tel\n{'guido': 4127, 'irv': 4127, 'jack': 4098}\n>>> tel.keys()\n['guido', 'irv', 'jack']\n>>> 'guido' in tel\nTrue\ndict方法直接创建字典：\n>>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])\n{'sape': 4139, 'jack': 4098, 'guido': 4127}\n>>> {x: x**2 for x in (2, 4, 6)}\n{2: 4, 4: 16, 6: 36}\n>>> dict(sape=4139, guido=4127, jack=4098)\n{'sape': 4139, 'jack': 4098, 'guido': 4127}\n遍历\n通过enumerate方法\n>>> for i, v in enumerate(['tic', 'tac', 'toe']):\n...    print i, v\n...\n0 tic\n1 tac\n2 toe\n一次性遍历多个（这个特性不错。。\n>>> questions = ['name', 'quest', 'favorite color']\n>>> answers = ['lancelot', 'the holy grail', 'blue']\n>>> for q, a in zip(questions, answers):\n...    print 'What is your {0}?  It is {1}.'.format(q, a)\n...\nWhat is your name?  It is lancelot.\nWhat is your quest?  It is the holy grail.\nWhat is your favorite color?  It is blue\n逆序遍历：reversed\n>>> for i in reversed(xrange(1,10,2)):\n...    print i\n...\n9\n7\n5\n3\n1\n对数组排序(sorted方法)，然后遍历：\n>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n>>> for f in sorted(set(basket)):\n...    print f\n...\napple\nbanana\norange\npear\n遍历字典的时候，获得key和value:\n>>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}\n>>> for k, v in knights.iteritems():\n...    print k, v\n...\ngallahad the pure\nrobin the brave\n遍历的时候改变一个数组：\n>>> import math\n>>> raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8]\n>>> filtered_data = []\n>>> for value in raw_data:\n...    if not math.isnan(value):\n...        filtered_data.append(value)\n...\n>>> filtered_data\n[56.2, 51.7, 55.3, 52.5, 47.8]\n更多条件语句\n比较运算符：in和not in判断是否在序列里面； is和is not用来比较两个对象是否是同一个对象；比较可以链式： a < b == c 判断a小于b，并且b等于c布尔操作符：and和or  优先级比比较运算符低   not优先级最高 or最低\n布尔运算符，当一个满足条件不会继续下面的计算\n比较结果可以被赋值：\n>>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'\n>>> non_null = string1 or string2 or string3\n>>> non_null\n'Trondheim'\n模块\n退出解释器后，所有声明的函数或者变量都不存在了。所以我们需要创建一个python脚本，可持续地运行。每一个脚本文件称之为一个模块。比如我们创建一个文件:fibo.py\n# 这是一个模块\n\ndef fib(n):    # 定义函数fib\n    a, b = 0, 1\n    while b < n:\n        print b,\n        a, b = b, a+b\n\ndef fib2(n):  # 定义函数fib2\n    result = []\n    a, b = 0, 1\n    while b < n:\n        result.append(b)\n        a, b = b, a+b\n    return result\n在解释器里面导入这个模块：\n>>> import fibo\n访问模块的函数：\n>>> fibo.fib(1000)\n1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987\n>>> fibo.fib2(100)\n[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n>>> fibo.__name__\n'fibo'\n函数赋给一个变量\n>>> fib = fibo.fib\n>>> fib(500)\n1 1 2 3 5 8 13 21 34 55 89 144 233 377\n执行模块脚本\n这样运行一个模块\npython fibo.py <arguments>\n和导入一个模块，并且把__name__设置为__main__是一样的：相当于把下面的代码放到模块的底部\nif __name__ == \"__main__\":\n    import sys\n    fib(int(sys.argv[1]))\n这样单纯导入是不会运行这个脚本的：\n>>> import fibo\n>>>\n模块寻找路径\n1 内置模块2 搜索sys.path里面的所有目录\nsys.path初始化的内容：当前目录PYTHONPATH （目录路径，它和环境变量的PATH语法一致）Python安装路径\nsys.path会被修改，当前目录优先于标准库路径。\n编译后的Python文件\n如果 spam.pyc（编译后的Python文件）和spam.py共存，会优先用编译后的文件。spam.pyc保存的编译时间和spam.py的修改时间不一致，则编译后的文件会被忽略（也就是用spam.py文件）。spam.pyc文件是平台独立的，也就是说能被各个平台共享。\n标准模块\nPython有自己的标准库。为了达到更底层的东西，有些模块已经内置到解析器中。而且有些内置模块依赖于环境，比如winreg模块只在window环境下提供。而一个值得关注的模块是：sys，它被内置到了每个Python解释器中。sys.ps1和sys.ps2表示Python的提示符\n>>>import sys\n>>>sys.ps1\n'>>> '\n>>> sys.ps2\n'... '\n>>> sys.ps1 = 'C> '\nC> print 'Yuck!'\nYuck!\nC>\nsys.path的值是解释器的模块搜索路径。我们可以增加路径：\n>>> import sys\n>>> sys.path.append('/ufs/guido/lib/python')\ndir()函数\ndir()函数返回一个字符串的数组，它被用来表示一个模块定义了哪些名字\n>>> import fibo, sys\n>>> dir(fibo)\n['__name__', 'fib', 'fib2']\n>>> dir(sys)  \n['__displayhook__', '__doc__', '__excepthook__', '__name__', '__package__',\n'__stderr__', '__stdin__', '__stdout__', '_clear_type_cache',\n'_current_frames', '_getframe', '_mercurial', 'api_version', 'argv',\n'builtin_module_names', 'byteorder', 'call_tracing', 'callstats',\n'copyright', 'displayhook', 'dont_write_bytecode', 'exc_clear', 'exc_info',\n'exc_traceback', 'exc_type', 'exc_value', 'excepthook', 'exec_prefix',\n'executable', 'exit', 'flags', 'float_info', 'float_repr_style',\n'getcheckinterval', 'getdefaultencoding', 'getdlopenflags',\n'getfilesystemencoding', 'getobjects', 'getprofile', 'getrecursionlimit',\n'getrefcount', 'getsizeof', 'gettotalrefcount', 'gettrace', 'hexversion',\n'long_info', 'maxint', 'maxsize', 'maxunicode', 'meta_path', 'modules',\n'path', 'path_hooks', 'path_importer_cache', 'platform', 'prefix', 'ps1',\n'py3kwarning', 'setcheckinterval', 'setdlopenflags', 'setprofile',\n'setrecursionlimit', 'settrace', 'stderr', 'stdin', 'stdout', 'subversion',\n'version', 'version_info', 'warnoptions']\n不带参数则返回当前你定义的模块函数变量名字\n>>> a = [1, 2, 3, 4, 5]\n>>> import fibo\n>>> fib = fibo.fib\n>>> dir()\n['__builtins__', '__name__', '__package__', 'a', 'fib', 'fibo', 'sys']\ndir()不会返回内置的函数和变量。如果要打印内置的话，需要传递__builtin__\n>>> import __builtin__\n>>> dir(__builtin__)  \n['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException',\n'BufferError', 'BytesWarning', 'DeprecationWarning', 'EOFError',\n'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FloatingPointError',\n'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning',\n'IndentationError', 'IndexError', 'KeyError', 'KeyboardInterrupt',\n'LookupError', 'MemoryError', 'NameError', 'None', 'NotImplemented',\n'NotImplementedError', 'OSError', 'OverflowError',\n'PendingDeprecationWarning', 'ReferenceError', 'RuntimeError',\n'RuntimeWarning', 'StandardError', 'StopIteration', 'SyntaxError',\n'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'True',\n'TypeError', 'UnboundLocalError', 'UnicodeDecodeError',\n'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError',\n'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning',\n'ZeroDivisionError', '_', '__debug__', '__doc__', '__import__',\n'__name__', '__package__', 'abs', 'all', 'any', 'apply', 'basestring',\n'bin', 'bool', 'buffer', 'bytearray', 'bytes', 'callable', 'chr',\n'classmethod', 'cmp', 'coerce', 'compile', 'complex', 'copyright',\n'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval',\n'execfile', 'exit', 'file', 'filter', 'float', 'format', 'frozenset',\n'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input',\n'int', 'intern', 'isinstance', 'issubclass', 'iter', 'len', 'license',\n'list', 'locals', 'long', 'map', 'max', 'memoryview', 'min', 'next',\n'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit',\n'range', 'raw_input', 'reduce', 'reload', 'repr', 'reversed', 'round',\n'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super',\n'tuple', 'type', 'unichr', 'unicode', 'vars', 'xrange', 'zip']\n包\n包是组织Python模块的一种方式，比如A.B 标识包A下有一个子模块B。一个包的结构类似如下：\nsound/                          Top-level package\n      __init__.py              Initialize the sound package\n      formats/                  Subpackage for file format conversions\n              __init__.py\n              wavread.py\n              wavwrite.py\n              aiffread.py\n              aiffwrite.py\n              auread.py\n              auwrite.py\n              ...\n      effects/                  Subpackage for sound effects\n              __init__.py\n              echo.py\n              surround.py\n              reverse.py\n              ...\n      filters/                  Subpackage for filters\n              __init__.py\n              equalizer.py\n              vocoder.py\n              karaoke.py\n              ...\n那么我们怎么导入它:\nimport sound.effects.echo\n然后怎么引用: 必须用全名引用\nsound.effects.echo.echofilter(input, output, delay=0.7, atten=4)\n另外一种引用的方式是：\nfrom sound.effects import echo\n这种方式引入，可以避免全名\necho.echofilter(input, output, delay=0.7, atten=4)\n当然，你也可以引入函数或者变量：\nfrom sound.effects.echo import echofilter\n直接调用函数：\nechofilter(input, output, delay=0.7, atten=4)\n注意：以下方式导入，最后一个（subsubitem）必须是包\nimport item.subitem.subsubitem\n导入包\n在sound/effects/__init__.py 这个里面定义：\n__all__ = [\"echo\", \"surround\", \"reverse\"]\n那么：通过以下方式会导入上面all指定的模块\nfrom sound.effects import *\n如果all没定义，那么import导入的情况是不一定的。\nimport sound.effects.echo\nimport sound.effects.surround\nfrom sound.effects import *\n比如上面这种写法，会导入echo和surround\n不推荐使用*。\n内部包引用\n可以使用相对导入：\nfrom . import echo\nfrom .. import formats\nfrom ..filters import equalizer\n输入和输出\n输出格式\n输出方法：sys.stdout标准输出， print write()方法等格式输出: str.format()转为字符串用repr()和str()函数 ：\n>>> s = 'Hello, world.'\n>>> str(s)\n'Hello, world.'\n>>> repr(s)\n\"'Hello, world.'\"\n>>> str(1.0/7.0)\n'0.142857142857'\n>>> repr(1.0/7.0)\n'0.14285714285714285'\n>>> x = 10 * 3.25\n>>> y = 200 * 200\n>>> s = 'The value of x is ' + repr(x) + ', and y is ' + repr(y) + '...'\n>>> print s\nThe value of x is 32.5, and y is 40000...\n>>> # The repr() of a string adds string quotes and backslashes:\n... hello = 'hello, world\\n'\n>>> hellos = repr(hello)\n>>> print hellos\n'hello, world\\n'\n>>> # The argument to repr() may be any Python object:\n... repr((x, y, ('spam', 'eggs')))\n\"(32.5, 40000, ('spam', 'eggs'))\"\n打印表格形式：\n>>> for x in range(1, 11):\n...    print repr(x).rjust(2), repr(x*x).rjust(3),\n...    # Note trailing comma on previous line\n...    print repr(x*x*x).rjust(4)\n...\n1  1    1\n2  4    8\n3  9  27\n4  16  64\n5  25  125\n6  36  216\n7  49  343\n8  64  512\n9  81  729\n10 100 1000\n\n>>> for x in range(1,11):\n...    print '{0:2d} {1:3d} {2:4d}'.format(x, x*x, x*x*x)\n...\n1  1    1\n2  4    8\n3  9  27\n4  16  64\n5  25  125\n6  36  216\n7  49  343\n8  64  512\n9  81  729\n10 100 1000\nstr.rjust() 对字符串右对齐str.zfill() 字符串保证位数\n>>> '12'.zfill(5)\n'00012'\n>>> '-3.14'.zfill(7)\n'-003.14'\n>>> '3.14159265359'.zfill(5)\n'3.14159265359'\nstr.format()的基本使用：\n>>> print 'We are the {} who say \"{}!\"'.format('knights', 'Ni')\nWe are the knights who say \"Ni!\"\n交换位置：\n>>> print '{0} and {1}'.format('spam', 'eggs')\nspam and eggs\n>>> print '{1} and {0}'.format('spam', 'eggs')\neggs and spam\n通过key访问：\n>>> print 'This {food} is {adjective}.'.format(\n...      food='spam', adjective='absolutely horrible')\nThis spam is absolutely horrible.\n混合使用：\n>>> print 'The story of {0}, {1}, and {other}.'.format('Bill', 'Manfred',\n...                                                    other='Georg')\nThe story of Bill, Manfred, and Georg.\n'!s' (调用str()) and '!r' (调用repr()) 打印前进行格式转换：\n>>> import math\n>>> print 'The value of PI is approximately {}.'.format(math.pi)\nThe value of PI is approximately 3.14159265359.\n>>> print 'The value of PI is approximately {!r}.'.format(math.pi)\nThe value of PI is approximately 3.141592653589793.\n':' 可控制小数点：\n>>> import math\n>>> print 'The value of PI is approximately {0:.3f}.'.format(math.pi)\nThe value of PI is approximately 3.142.\n控制表格：\n>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}\n>>> for name, phone in table.items():\n...    print '{0:10} ==> {1:10d}'.format(name, phone)\n...\nJack      ==>      4098\nDcab      ==>      7678\nSjoerd    ==>      4127\n通过[]访问key:\n>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}\n>>> print ('Jack: {0[Jack]:d}; Sjoerd: {0[Sjoerd]:d}; '\n...        'Dcab: {0[Dcab]:d}'.format(table))\nJack: 4098; Sjoerd: 4127; Dcab: 8637678\n% 操作符也可以格式化(老式的)\n>>> import math\n>>> print 'The value of PI is approximately %5.3f.' % math.pi\nThe value of PI is approximately 3.142.\n读写文件\nopen（）打开文件：open(filename, mode)\n>>> f = open('workfile', 'w')\n>>> print f\n<open file 'workfile', mode 'w' at 80a0960\n‘b’标识二进制形式，跨平台\n文件对象的方法\n读文件：f.read(size)\n>>> f.read()\n'This is the entire file.\\n'\n>>> f.read()\n''\n带换行：\n>>> f.readline()\n'This is the first line of the file.\\n'\n>>> f.readline()\n'Second line of the file\\n'\n>>> f.readline()\n''\n读取一个文件的所有行：\n>> for line in f:\n        print line,\n\nThis is the first line of the file.\nSecond line of the file\n或者list(f) or f.readlines()字符串写入文件：\n>>> f.write('This is a test\\n')\n将其他类型写入文件需先转为字符串：\n>>> value = ('the answer', 42)\n>>> s = str(value)\n>>> f.write(s)\nf.tell() 返回一个整数，表示当前文件的位置（计算字节）。比如：\n>>> f = open('workfile', 'r+')\n>>> f.write('0123456789abcdef')\n>>> f.seek(5)      # 到第6个字节\n>>> f.read(1)\n'5'\n>>> f.seek(-3, 2)  # 倒数（2表示倒数）第三个字节位置\n>>> f.read(1)\n'd'\n释放文件资源：\n>>> f.close()\n>>> f.read()\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: I/O operation on closed file\n最佳实践是带上with：即便有异常抛出也能释放文件资源\n>>> with open('workfile', 'r') as f:\n...    read_data = f.read()\n>>> f.closed\nTrue\n保存JSON数据\n序列化：将json转为字符串 反序列化：将字符串转为json\n>>> import json\n>>> json.dumps([1, 'simple', 'list'])\n'[1, \"simple\", \"list\"]'\n将对象序列化到一个文件中：f是一个文件对象\njson.dump(x, f)\n从文件中读取：\nx = json.load(f)\n错误和异常\n语法错误\n>>> while True print 'Hello world'\n  File \"<stdin>\", line 1\n    while True print 'Hello world'\n                  ^\nSyntaxError: invalid syntax\n执行异常\n>>> 10 * (1/0)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nZeroDivisionError: integer division or modulo by zero\n>>> 4 + spam*3\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nNameError: name 'spam' is not defined\n>>> '2' + 2\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: cannot concatenate 'str' and 'int' objects\n处理异常\n>>> while True:\n...    try:\n...        x = int(raw_input(\"Please enter a number: \"))\n...        break\n...    except ValueError:\n...        print \"Oops!  That was no valid number.  Try again...\"\n...\n这里只捕获了ValueError，如果捕获更多异常：\n... except (RuntimeError, TypeError, NameError):\n...    pass\nimport sys\n\ntry:\n    f = open('myfile.txt')\n    s = f.readline()\n    i = int(s.strip())\nexcept IOError as e:\n    print \"I/O error({0}): {1}\".format(e.errno, e.strerror)\nexcept ValueError:\n    print \"Could not convert data to an integer.\"\nexcept:\n    print \"Unexpected error:\", sys.exc_info()[0]\n    raise\ntry...except...else..else后面的代码一定会执行\nfor arg in sys.argv[1:]:\n    try:\n        f = open(arg, 'r')\n    except IOError:\n        print 'cannot open', arg\n    else:\n        print arg, 'has', len(f.readlines()), 'lines'\n        f.close()\n抛出异常：\n>>> try:\n...    raise Exception('spam', 'eggs')\n... except Exception as inst:\n...    print type(inst)    # 异常实例\n...    print inst.args      # arguments 存储在.args中\n...    print inst          # __str__方法使得能直接打印参数而不需要引用它。\n...    x, y = inst.args\n...    print 'x =', x\n...    print 'y =', y\n...\n<type 'exceptions.Exception'>\n('spam', 'eggs')\n('spam', 'eggs')\nx = spam\n函数内部的异常也能捕获：\n>>> def this_fails():\n...    x = 1/0\n...\n>>> try:\n...    this_fails()\n... except ZeroDivisionError as detail:\n...    print 'Handling run-time error:', detail\n...\nHandling run-time error: integer division or modulo by zero\n抛出异常\n>>> raise NameError('HiThere')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nNameError: HiThere\n不处理异常，直接将异常抛出：\n>>> try:\n...    raise NameError('HiThere')\n... except NameError:\n...    print 'An exception flew by!'\n...    raise\n...\nAn exception flew by!\nTraceback (most recent call last):\n  File \"<stdin>\", line 2, in <module>\nNameError: HiThere\n自定义异常\n>>> class MyError(Exception):\n...    def __init__(self, value):\n...        self.value = value\n...    def __str__(self):\n...        return repr(self.value)\n...\n>>> try:\n...    raise MyError(2*2)\n... except MyError as e:\n...    print 'My exception occurred, value:', e.value\n...\nMy exception occurred, value: 4\n>>> raise MyError('oops!')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n__main__.MyError: 'oops!'\n重写了__init__方法，并且定义了一个value属性。一般定义异常的方式是这样的：\nclass Error(Exception):\n    \"\"\"Base class for exceptions in this module.\"\"\"\n    pass\n\nclass InputError(Error):\n    \"\"\"Exception raised for errors in the input.\n\n    Attributes:\n        expr -- input expression in which the error occurred\n        msg  -- explanation of the error\n    \"\"\"\n\n    def __init__(self, expr, msg):\n        self.expr = expr\n        self.msg = msg\n\nclass TransitionError(Error):\n    \"\"\"Raised when an operation attempts a state transition that's not\n    allowed.\n\n    Attributes:\n        prev -- state at beginning of transition\n        next -- attempted new state\n        msg  -- explanation of why the specific transition is not allowed\n    \"\"\"\n\n    def __init__(self, prev, next, msg):\n        self.prev = prev\n        self.next = next\n        self.msg = msg\n清理工作\n>>> try:\n...    raise KeyboardInterrupt\n... finally:\n...    print 'Goodbye, world!'\n...\nGoodbye, world!\nKeyboardInterrupt\nTraceback (most recent call last):\n  File \"<stdin>\", line 2, in <module>\nfinally总是会被执行，而且如果异常没有被处理的话，在finally里面的代码执行完后会被重新抛出。一个更复杂点的例子：\n>>> def divide(x, y):\n...    try:\n...        result = x / y\n...    except ZeroDivisionError:\n...        print \"division by zero!\"\n...    else:\n...        print \"result is\", result\n...    finally:\n...        print \"executing finally clause\"\n...\n>>> divide(2, 1)\nresult is 2\nexecuting finally clause\n>>> divide(2, 0)\ndivision by zero!\nexecuting finally clause\n>>> divide(\"2\", \"1\")\nexecuting finally clause\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"<stdin>\", line 3, in divide\nTypeError: unsupported operand type(s) for /: 'str' and 'str'\n预清理\n一定要带上with保证文件资源被释放\nwith open(\"myfile.txt\") as f:\n    for line in f:\n        print line,\nPython类\n定义类\nclass MyClass:\n    \"\"\"A simple example class\"\"\"\n    i = 12345\n\n    def f(self):\n        return 'hello world'\n引用类的属性和方法\nMyClass.i和 MyClass.fMyClass.__doc_ => “A simple example class”\n定义init方法，设置默认属性\ndef __init__(self):\n    self.data = []\n传递给类的参数会传递给init:\n>>> class Complex:\n...    def __init__(self, realpart, imagpart):\n...        self.r = realpart\n...        self.i = imagpart\n...\n>>> x = Complex(3.0, -4.5)\n>>> x.r, x.i\n(3.0, -4.5)\n类共享变量和实例变量\nclass Dog:\n\n    kind = 'canine'        # 类共享变量\n\n    def __init__(self, name):\n        self.name = name    # 实例变量\n\n>>> d = Dog('Fido')\n>>> e = Dog('Buddy')\n>>> d.kind                  # shared by all dogs\n'canine'\n>>> e.kind                  # shared by all dogs\n'canine'\n>>> d.name                  # unique to d\n'Fido'\n>>> e.name                  # unique to e\n'Buddy'\n注意引用变量避免被所有实例共享\nclass Dog:\n\n    tricks = []            # mistaken use of a class variable\n\n    def __init__(self, name):\n        self.name = name\n\n    def add_trick(self, trick):\n        self.tricks.append(trick)\n\n>>> d = Dog('Fido')\n>>> e = Dog('Buddy')\n>>> d.add_trick('roll over')\n>>> e.add_trick('play dead')\n>>> d.tricks                # 这里tricks被所有实例共享了\n['roll over', 'play dead']\n正确的用法：\nclass Dog:\n\n    def __init__(self, name):\n        self.name = name\n        self.tricks = []    # creates a new empty list for each dog\n\n    def add_trick(self, trick):\n        self.tricks.append(trick)\n\n>>> d = Dog('Fido')\n>>> e = Dog('Buddy')\n>>> d.add_trick('roll over')\n>>> e.add_trick('play dead')\n>>> d.tricks\n['roll over']\n>>> e.tricks\n['play dead']\n函数的定义可以在类外部(不推荐)\n# Function defined outside the class\ndef f1(self, x, y):\n    return min(x, x+y)\n\nclass C:\n    f = f1\n\n    def g(self):\n        return 'hello world'\n\n    h = g\n通过self引用函数\nclass Bag:\n    def __init__(self):\n        self.data = []\n\n    def add(self, x):\n        self.data.append(x)\n\n    def addtwice(self, x):\n        self.add(x)\n        self.add(x)\n每一个值都是一个对象，它的对象存储在object.__class__\n继承\n语法：\nclass DerivedClassName(BaseClassName):\n    <statement-1>\n    .\n    .\n    .\n    <statement-N>\n或(moduleName是导入的模块)\nclass DerivedClassName(moduleName.BaseClassName):\n如果引用的属性没有在当前类中找到，会找他的基类。继承的类可以重写基类的方法。有两个内置的函数很有用：判断实例的类型：isinstance(obj, int) 判断是否是继承自int类 ( 如果obj.__class__ 是int或者继承自int类 返回true)issubclass(bool, int)： 判断bool是否是int的子类\n多继承\nclass DerivedClassName(Base1, Base2, Base3):\n    <statement-1>\n    .\n    .\n    .\n    <statement-N>\n私有变量和类内引用\n私有变量一般是以_下划线开头内部调用方法__双下划线开头：\nclass Mapping:\n    def __init__(self, iterable):\n        self.items_list = []\n        self.__update(iterable)\n\n    def update(self, iterable):\n        for item in iterable:\n            self.items_list.append(item)\n\n    __update = update  # 拷贝一份update方法\n\nclass MappingSubclass(Mapping):\n\n    def update(self, keys, values): # 子类可以重写update方法 并且不会影响到init方法\n        for item in zip(keys, values):\n            self.items_list.append(item)\n异常也是一个类\n语法：\nraise Class, instance\nraise instance  （raise instance.__class__, instance的简写）\n比如：\nclass B:\n    pass\nclass C(B):\n    pass\nclass D(C):\n    pass\n\nfor c in [B, C, D]:\n    try:\n        raise c()\n    except D:\n        print \"D\"\n    except C:\n        print \"C\"\n    except B:\n        print \"B\"\n遍历\n大部分的对象都可以遍历\nfor element in [1, 2, 3]:\n    print element\nfor element in (1, 2, 3):\n    print element\nfor key in {'one':1, 'two':2}:\n    print key\nfor char in \"123\":\n    print char\nfor line in open(\"myfile.txt\"):\n    print line,\n内部：for语句调用了iter()方法，然后调用next()方法访问下一个元素，如果没有下一个会抛出StopInteration异常\n>>> s = 'abc'\n>>> it = iter(s)\n>>> it\n<iterator object at 0x00A1DB50>\n>>> it.next()\n'a'\n>>> it.next()\n'b'\n>>> it.next()\n'c'\n>>> it.next()\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n    it.next()\nStopIteration\n给类增加遍历器：\nclass Reverse:\n    \"\"\"Iterator for looping over a sequence backwards.\"\"\"\n    def __init__(self, data):\n        self.data = data\n        self.index = len(data)\n\n    def __iter__(self):\n        return self\n\n    def next(self):\n        if self.index == 0:\n            raise StopIteration\n        self.index = self.index - 1\n        return self.data[self.index]\n使用：\n>>> rev = Reverse('spam')\n>>> iter(rev)\n<__main__.Reverse object at 0x00A1DB50>\n>>> for char in rev:\n...    print char\n...\nm\na\np\ns\n标准库相关\n系统接口\n>>> import os\n>>> os.getcwd()      # 返回当前目录\n'C:\\\\Python26'\n>>> os.chdir('/server/accesslogs')  # 改变工作目录\n>>> os.system('mkdir today')  # 运行shell命令：mkdir\n0\n>>> import os\n>>> dir(os)\n<returns a list of all module functions>\n>>> help(os)\n<returns an extensive manual page created from the module's docstrings>\n文件操作：\n>>> import shutil\n>>> shutil.copyfile('data.db', 'archive.db')\n>>> shutil.move('/build/executables', 'installdir')\n文件通配符\n>>> import glob\n>>> glob.glob('*.py')\n['primes.py', 'random.py', 'quote.py']\n命令行参数\n比如我们跑了这个命令:python demo.py one two three demo.py里面的写法是：\n>>> import sys\n>>> print sys.argv\n['demo.py', 'one', 'two', 'three']\ngetopt模块和argparse模块提供了更多灵活的方式访问命令行参数\n退出程序和打印错误\nsys.exit()打印错误：\n>>> sys.stderr.write('Warning, log file not found starting a new one\\n')\nWarning, log file not found starting a new one\n字符串匹配\n>>> import re\n>>> re.findall(r'\\bf[a-z]*', 'which foot or hand fell fastest')\n['foot', 'fell', 'fastest']\n>>> re.sub(r'(\\b[a-z]+) \\1', r'\\1', 'cat in the the hat')\n'cat in the hat'\n>>> 'tea for too'.replace('too', 'two')\n'tea for two'\n数学\n>>> import math\n>>> math.cos(math.pi / 4.0)\n0.70710678118654757\n>>> math.log(1024, 2)\n10.0\n>>> import random\n>>> random.choice(['apple', 'pear', 'banana'])\n'apple'\n>>> random.sample(xrange(100), 10)  # sampling without replacement\n[30, 83, 16, 4, 8, 81, 41, 50, 18, 33]\n>>> random.random()    # random float\n0.17970987693706186\n>>> random.randrange(6)    # random integer chosen from range(6)\n4\n网络访问\n>>> import urllib2\n>>> for line in urllib2.urlopen('http://tycho.usno.navy.mil/cgi-bin/timer.pl'):\n...    if 'EST' in line or 'EDT' in line:  # look for Eastern Time\n...        print line\n\n<BR>Nov. 25, 09:43:32 PM EST\n\n>>> import smtplib\n>>> server = smtplib.SMTP('localhost')\n>>> server.sendmail('soothsayer@example.org', 'jcaesar@example.org',\n... \"\"\"To: jcaesar@example.org\n... From: soothsayer@example.org\n...\n... Beware the Ides of March.\n... \"\"\")\n>>> server.quit()\n日期\n>>> # dates are easily constructed and formatted\n>>> from datetime import date\n>>> now = date.today()\n>>> now\ndatetime.date(2003, 12, 2)\n>>> now.strftime(\"%m-%d-%y. %d %b %Y is a %A on the %d day of %B.\")\n'12-02-03. 02 Dec 2003 is a Tuesday on the 02 day of December.'\n\n>>> # dates support calendar arithmetic\n>>> birthday = date(1964, 7, 31)\n>>> age = now - birthday\n>>> age.days\n14368\n数据压缩\n>>> import zlib\n>>> s = 'witch which has which witches wrist watch'\n>>> len(s)\n41\n>>> t = zlib.compress(s)\n>>> len(t)\n37\n>>> zlib.decompress(t)\n'witch which has which witches wrist watch'\n>>> zlib.crc32(s)\n226805979\n性能测试\n>>> from timeit import Timer\n>>> Timer('t=a; a=b; b=t', 'a=1; b=2').timeit()\n0.57535828626024577\n>>> Timer('a,b = b,a', 'a=1; b=2').timeit()\n0.54962537085770791\n质量控制\n运行文档内的测试代码：\ndef average(values):\n    \"\"\"Computes the arithmetic mean of a list of numbers.\n\n    >>> print average([20, 30, 70])\n    40.0\n    \"\"\"\n    return sum(values, 0.0) / len(values)\n\nimport doctest\ndoctest.testmod()  # automatically validate the embedded tests\n运行测试集：\nimport unittest\n\nclass TestStatisticalFunctions(unittest.TestCase):\n\n    def test_average(self):\n        self.assertEqual(average([20, 30, 70]), 40.0)\n        self.assertEqual(round(average([1, 5, 7]), 1), 4.3)\n        with self.assertRaises(ZeroDivisionError):\n            average([])\n        with self.assertRaises(TypeError):\n            average(20, 30, 70)\n\nunittest.main()  # Calling from the command line invokes all tests\n格式化输出\n>>> import repr\n>>> repr.repr(set('supercalifragilisticexpialidocious'))\n\"set(['a', 'c', 'd', 'e', 'f', 'g', ...])\"\n自动换行和格式化：\n>>> import pprint\n>>> t = [[[['black', 'cyan'], 'white', ['green', 'red']], [['magenta',\n...    'yellow'], 'blue']]]\n...\n>>> pprint.pprint(t, width=30)\n[[[['black', 'cyan'],\n  'white',\n  ['green', 'red']],\n  [['magenta', 'yellow'],\n  'blue']]]\n限制宽度输出：\n>>> import textwrap\n>>> doc = \"\"\"The wrap() method is just like fill() except that it returns\n... a list of strings instead of one big string with newlines to separate\n... the wrapped lines.\"\"\"\n...\n>>> print textwrap.fill(doc, width=40)\nThe wrap() method is just like fill()\nexcept that it returns a list of strings\ninstead of one big string with newlines\nto separate the wrapped lines.\n本地化输出：\n>>> import locale\n>>> locale.setlocale(locale.LC_ALL, 'English_United States.1252')\n'English_United States.1252'\n>>> conv = locale.localeconv()          # get a mapping of conventions\n>>> x = 1234567.8\n>>> locale.format(\"%d\", x, grouping=True)\n'1,234,567'\n>>> locale.format_string(\"%s%.*f\", (conv['currency_symbol'],\n...                      conv['frac_digits'], x), grouping=True)\n'$1,234,567.80'\n模板\n>>> from string import Template\n>>> t = Template('${village}folk send $$10 to $cause.')\n>>> t.substitute(village='Nottingham', cause='the ditch fund')\n'Nottinghamfolk send $10 to the ditch fund.'\nsubstitute会替换模板的关键字。如果传递的参数不对会报异常，建议用safe_substitute：\n>>> t = Template('Return the $item to $owner.')\n>>> d = dict(item='unladen swallow')\n>>> t.substitute(d)\nTraceback (most recent call last):\n  ...\nKeyError: 'owner'\n>>> t.safe_substitute(d)\n'Return the unladen swallow to $owner.'\n自定义分隔符号：\n>>> import time, os.path\n>>> photofiles = ['img_1074.jpg', 'img_1076.jpg', 'img_1077.jpg']\n>>> class BatchRename(Template):\n...    delimiter = '%'\n>>> fmt = raw_input('Enter rename style (%d-date %n-seqnum %f-format):  ')\nEnter rename style (%d-date %n-seqnum %f-format):  Ashley_%n%f\n\n>>> t = BatchRename(fmt)\n>>> date = time.strftime('%d%b%y')\n>>> for i, filename in enumerate(photofiles):\n...    base, ext = os.path.splitext(filename)\n...    newname = t.substitute(d=date, n=i, f=ext)\n...    print '{0} --> {1}'.format(filename, newname)\n\nimg_1074.jpg --> Ashley_0.jpg\nimg_1076.jpg --> Ashley_1.jpg\nimg_1077.jpg --> Ashley_2.jpg\n多线程\nimport threading, zipfile\n\nclass AsyncZip(threading.Thread):\n    def __init__(self, infile, outfile):\n        threading.Thread.__init__(self)\n        self.infile = infile\n        self.outfile = outfile\n\n    def run(self):\n        f = zipfile.ZipFile(self.outfile, 'w', zipfile.ZIP_DEFLATED)\n        f.write(self.infile)\n        f.close()\n        print 'Finished background zip of: ', self.infile\n\nbackground = AsyncZip('mydata.txt', 'myarchive.zip')\nbackground.start()\nprint 'The main program continues to run in foreground.'\n\nbackground.join()    # Wait for the background task to finish\nprint 'Main program waited until background was done.'\n建议用单线程，然后Queue模块实现多线程的操作，更加容易试错和设计。\n日志\nimport logging\nlogging.debug('Debugging information')\nlogging.info('Informational message')\nlogging.warning('Warning:config file %s not found', 'server.conf')\nlogging.error('Error occurred')\nlogging.critical('Critical error -- shutting down')\n弱引用\n>>> import weakref, gc\n>>> class A:\n...    def __init__(self, value):\n...        self.value = value\n...    def __repr__(self):\n...        return str(self.value)\n...\n>>> a = A(10)                  # 创建一个引用\n>>> d = weakref.WeakValueDictionary()\n>>> d['primary'] = a            # 不会创建引用\n>>> d['primary']                # \n10\n>>> del a                      # 删除\n>>> gc.collect()                # 运行垃圾回收\n0\n>>> d['primary']                # 这个时候访问会报错\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n    d['primary']                \n  File \"C:/python26/lib/weakref.py\", line 46, in __getitem__\n    o = self.data[key]()\nKeyError: 'primary'\nLists相关工具集\n队列：\n>>> from collections import deque\n>>> d = deque([\"task1\", \"task2\", \"task3\"])\n>>> d.append(\"task4\")\n>>> print \"Handling\", d.popleft()\nHandling task1\n操作排序：已经排序的插入一个元素\n>>> import bisect\n>>> scores = [(100, 'perl'), (200, 'tcl'), (400, 'lua'), (500, 'python')]\n>>> bisect.insort(scores, (300, 'ruby'))\n>>> scores\n[(100, 'perl'), (200, 'tcl'), (300, 'ruby'), (400, 'lua'), (500, 'python')]\n精确的浮点操作：\n>>> from decimal import *\n>>> x = Decimal('0.70') * Decimal('1.05')\n>>> x\nDecimal('0.7350')\n>>> x.quantize(Decimal('0.01'))  # round to nearest cent\nDecimal(huanying guanzhu : '0.74')\n>>> round(.70 * 1.05, 2)        # same calculation with floats\n0.73\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "2"}