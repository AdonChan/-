{"title": "leetcode上两道题的思考 - 个人文章 ", "index": "python", "content": "第一道题：给定一棵二叉树，在二叉树的所有路径中找到路径上结点之和为题目给定值的子路径。路径不一定以根节点为开头，也不一定以叶节点为结尾。并且根据分析路径之间应该可以重叠。求出满足这样要求的路径的数目，并返回。\n      10\n     /  \\\n    5   -3\n   / \\    \\\n  3   2   11\n / \\   \\\n3  -2   1\n\n当给出以上的二叉树，并以8为路径节点和时，5->3，5->2->1,-3->11三条路径满足条件返回三。\n对于根节点来讲，满足条件的路径，包括以根节点为起点的路径，以及不以根节点为起点的路径。我们先定义一个函数，这个函数有两个节点node和sum，它的含义是，求出从node开始的，路径上各节点之和为sum的这样的路径的个数。注意是从node开始的。\nresult初始化为0。如果当前node的value等于sum，则将result加1。由于可能会有负数节点，因此不能立刻返回result，应该分别再递归的去计算以node的左孩子和右孩子为起点，和为sum-node.value的路径的数目。代码如下：\n    def path_num_from(self, node, sum):\n        if node is None:\n            return 0\n\n        res = 0\n        if node.val == sum:\n            res += 1\n\n        res += self.path_num_from(node.left, sum - node.val)\n        res += self.path_num_from(node.right, sum - node.val)\n\n        return res\n之前已经提到过，本题所求的路径不仅包含以根节点为起点的路径，还包含不以根节点为起点的路径。因此我们再定义一个函数，来算出，包含根节点的路径，和不包含根节点的路径。\n    def __pathSum(self, node, sum):\n        if node is None:\n            return 0\n\n        return self.find_path(node, sum) + self.__pathSum(node.left, sum) + self.__pathSum(node.right, sum)\n题目得解。\n第二道题：给定一个数，将其拆分为n个平方数的和，求最小的n。例如13 = 9 + 4   13 = 9 + 1 + 1 + 1 + 113是9和4两个平方数的和，也是9和4个1的和（如果用重复，按出现的次数计数，1计数4次而不是1次），因为2小于5，所以返回2。\n这道题不能用贪心算法求解。当n=12时，如果用贪心算法，结果就是9+1+1+1，返回4。但是更优的解是4+4+4，返回3。\n假设给出的数字为n。先建立一个set。set中存放所有的，小于n的平方数。比如给出数字13时，set中添加1,4,9。因为16大于13，所以不添加。以15举例。set为 1,4,9。建立一个队列。\n第一轮：15减去9，得到6。将6放入队列中。15减去4，得到11。将11放入队列中。15减去1，得到14，将14放入队列中。第一轮遍历完毕。此时队列中还有6,11,14\n第二轮：6比9小，所以不能再减9。6减4，得到2，将2放入队列中。6减1，得到5，将5放入队列中。11减9，得到2，将2放入队列中。11减4，得到7，将7放入队列中。11减1，得到10，将10放入队列中。第二轮遍历完毕。去掉重复的数，此时队列中还有2,5,7,10。\n第三轮：2减1，得到1，将1放入队列中。5减4，得到1，将1放入队列中。5减1，得到4，将4放入队列中。7减4，得到3，将3放入队列中。7减1，得到6，将6放入队列中。10减4，得到6，将6放入队列中。10减1，得到9，将9放入队列中。第三轮遍历完毕。去掉重复元素，此时队列中还有1,3,4,6,9。\n第四轮：1减1，得到0。结束循环。直接返回此时层数。由于遍历了四轮，因此返回4。\n代码如下：\n def numSquares(self, n):\n        nums_to_subtract = []\n        i = 1\n        while i**2 <= n:\n            nums_to_subtract.append(i**2)\n            i += 1\n\n        depth = 0\n        current_level_nodes = {n}\n\n        while True:\n            nodes = current_level_nodes\n            current_level_nodes = set()\n            depth += 1\n            for num_left in nodes:\n                for num in nums_to_subtract:\n                    if num_left < num:\n                        break\n                    elif num_left > num:\n                        current_level_nodes.add(num_left - num)\n                    else:\n                        return depth\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}