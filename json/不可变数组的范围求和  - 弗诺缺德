{"title": "不可变数组的范围求和  - 弗诺缺德 ", "index": "php,css,html,python,html5", "content": "给定一个整数数组 nums，计算出从第 i 个元素到第 j 个元素的和 ( i ≤ j )，包括 nums[ i ] 和 nums[ j ]。例子：\nconst nums = Object.freeze([-2, 0, 3, -5, 2, -1]);\n\nsumRange(0, 2) -> 1\nsumRange(2, 5) -> -1\nsumRange(0, 5) -> -3\n注意：\n假定数组的值不会改变（如上面代码，nums 因为 Object.freeze 的缘故可读不可写）\nsumRange 可能会被使用很多次，求不同范围的值\n数组可能规模很大（比如超过 10000 个数），注意运行时间\n\n解题思路\n这道题看起来十分简单对吧，简单写一个函数应该谁都会：\nconst Immutable = Sup => class extends Sup {\n  constructor(...args){\n    super(...args);\n    Object.freeze(this);\n  }\n}\n\nclass NumArray extends Immutable(Array){\n  sumRange(i, j){\n    let sum = 0;\n    for(; i <= j; i++){\n      sum += this[i];\n    }\n    return sum;    \n  }\n}\n上面的代码里面我们重构了数组，这里我用了一点点小技巧来让数组元素不可变，这个技巧在我之前的一篇译文“六个漂亮的 ES6 技巧”中被提到，很多同学不理解那篇文章的第6个技巧，在这里我使用了一下，当然这无关我们今天讨论的主题。\n于是我们可以用新的数组对象来计算 sumRange：\nvar nums = new NumArray(-2, 0, 3, -5, 2, -1);\n\nnums.sumRange(0, 2) -> 1\nnums.sumRange(2, 5) -> -1\nnums.sumRange(0, 5) -> -3\n到这里为止，我们似乎并没有改变什么，我们只是继承了 Array 类，把 sumRange 改成了对象的方法而已，它还是一样很慢。\n那接下来我们要怎么做呢？\n因为前面说过了，sumRange 要被调用很多次，所以我们要尽可能减少 sumRange 调用的复杂度对吗？按照前面的方式，我们用一个循环来对从 i 到 j 进行求和，有没有更快的方法？答案是：空间换时间，查表！查表\n查表不是查水表，因为 sumRange 要计算很多次，所以我们可以事先在 NumArray 构造的时候将 sumRange 需要查的值算好存入一个表中。\n二维表？R/C     0     1     2     3     4     50     -2     -2     1     -4     -2     -31         0     3     -2     0     -12             3     -2     0     -13                 -5     -3     -44                     2     15                         -1\n二维表可以将每一对 i, j 完全映射一个值，这样的话，空间复杂度变成了 O( n2 )，记得我们前面说了，这个数组可能会很大，有 10000 个元素，如果用这样的映射表，内存就溢出了。实际上，使用二维表是愚蠢的，因为我们可以很容易找到以下对应关系：\nsumRange(i, j) === sumRange(0, j) - sumRange(0, i - 1); //(i > 0)\n一维表\n我们只需要将 NumArray 的每一个元素对应从第 1 元素开始求和，将结果保存成一个一维表，我们就可以用 O( 1 ) 时间复杂度来计算 sumRange( i, j ) ！\n以下是经过优化之后的 NumArray：\nconst UniqueID = Sup => class extends Sup {\n  constructor(...args){\n      super(...args);\n      Object.defineProperty(this, \"id\", {\n        value: Symbol(),\n        writable: false,\n        enumerable: false\n      });\n    }\n}\n\nconst Immutable = Sup => class extends Sup {\n  constructor(...args){\n    super(...args);\n    Object.freeze(this);\n  }\n}\n\nconst NumArray = (function(){\n  let sumTable = {};\n  return class  extends Immutable(UniqueID(Array)){\n    constructor(...args){\n      super(...args);\n      let sum = 0;\n      let table = [0];\n\n      for(let i = 0; i < this.length; i++){\n        sum += this[i];\n        table.push(sum);\n      }\n      sumTable[this.id] = table;\n    }\n    sumRange(i, j){\n      let table = sumTable[this.id];\n      return table[j + 1] - table[i];   \n    }\n  }\n})();\n上面的代码里，我们在构造 NumArray 的时候同时创建了一个私有属性 sumTable，它的第 1 个元素是 0，第 i + 1 个元素等于 sumRange(0, i)，因此我们就可以快速通过：\nsumRange(i, j){\n  let table = sumTable[this.id];\n  return table[j + 1] - table[i];   \n}\n来计算出 sumRange(i, j) 的值了。 \n进一步优化\n上面的代码通过查表大大加快了 sumRange 的执行速度，由于数组 NumArray 是不可变的，因此我们在它被构造的时候创建好 sumTable，那么 sumRange 就完全只需要查表加上一次减法运算就可以完成了。这么做提升了 sumRange 的性能，代价是构造 NumArray 对象的时候带来额外的建表开销。\n不过，我们可以不在构造对象的时候建表，而在对象的 sumRange 方法第一次被使用的时候建表。这样的话，我们就将性能开销延从构造对象时迟到了第一次使用 sumRange 时，如果恰巧某种原因，NumArray 对象没有被使用，那么 sumTable 就永远也不会被创建。看下面的代码：\n将创建 sumTable 的工作放在 sumRange 第一次被调用时\nconst UniqueID = Sup => class extends Sup {\n  constructor(...args){\n    super(...args);\n    Object.defineProperty(this, \"id\", {\n      value: Symbol(),\n      writable: false,\n      enumerable: false\n    });\n  }\n};\n\nconst Immutable = Sup => class extends Sup {\n  constructor(...args){\n    super(...args);\n    Object.freeze(this);\n  }\n};\n\nconst NumArray = (function(){\n  let sumTable = {};\n  return class  extends Immutable(UniqueID(Array)){\n    sumRange(i, j){\n      if(!sumTable[this.id]){\n        let table = [0], sum = 0;\n        for(let i = 0; i < this.length; i++){\n          sum += this[i];\n          table.push(sum);\n        }\n        sumTable[this.id] = table;\n      }\n      let table = sumTable[this.id];\n      return table[j + 1] - table[i];\n    }\n  }\n})();\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "3"}