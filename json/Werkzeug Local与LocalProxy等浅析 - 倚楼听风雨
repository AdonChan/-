{"title": "Werkzeug Local与LocalProxy等浅析 - 倚楼听风雨 ", "index": "python,werkzeug,flask", "content": "首先贴出官方文档地址：http://werkzeug.pocoo.org/doc...几个local？threading.localwerkzeug.local模块中的：LocalLocalStackLocaProxy\nwhy not threading.local?\nthreading.local,以前接触过java的，对这个再熟悉不过了。线程局部变量，也就是每个线程的私有变量，具有线程隔离性。\n按我们正常的理解，应该是每一个http请求对应一个处理线程。那么这样看来使用threading.local应该够了，为什么werkzeug还自己搞了一套？装逼？非也。\n在python中，除了线程之外，还有个叫协程的东东，(这里不提进程)。java中貌似是无法实现协程的。而python的协程感觉高大尚的样子，python3.5开始对协程内置支持，而且也有相关开源库greenlet等。\n协程是什么？举个例子，比如一个线程在处理IO时，该线程是处于空闲状态的，等待IO返回。但是此时如果不让我们的线程干等着cpu时间片耗光，有没有其他办法，解决思路就是采用协程处理任务，一个线程中可以运行多个协程，当当前协程去处理IO时，线程可以马上调度其他协程继续运行，而不是干等着不干活。\n这么一说，我们知道了协程会复用线程，WSGI不保证每个请求必须由一个线程来处理，如果WSGI服务器不是每个线程派发一个请求，而是每个协程派发一个请求，所以如果使用thread local变量可能会造成请求间数据相互干扰，因为一个线程中存在多个请求。所以werkzeug给出了自己的解决方案：werkzeug.local模块。\nfrom werkzeug.local import Local, LocalManager\n\nlocal = Local()\nlocal_manager = LocalManager([local])\n\ndef application(environ, start_response):\n    local.request = request = Request(environ)\n    ...\n\napplication = local_manager.make_middleware(application)\nLocal配合LocalManager会确保不管是协程还是线程，只要当前请求处理完成之后清除Local中对应的内容。\n>>> loc = Local()\n>>> loc.foo = 42\n>>> release_local(loc)\n>>> hasattr(loc, 'foo')\n当然，你也可以调用werkzeug.local.release_local(local)手动释放Local或者LocalStack ，但是不能清除代理对象LocalProxy(代理对象底层保留了对Local对象的引用，以便在之后释放)的数据。\n>>> ls = LocalStack()\n>>> ls.push(42)\n>>> ls.top\n42\n>>> ls.push(23)\n>>> ls.top\n23\n>>> ls.pop()\n23\n>>> ls.top\nLocalStack，与Local类似，但是管理数据的方式是采用栈的方式，可以通过LocalManager对象强制释放，但是不建议这么做，而是通过其pop方法弹出。\nfrom werkzeug.local import Local\nl = Local()\n\n# these are proxies\nrequest = l('request')\nuser = l('user')\n\n\nfrom werkzeug.local import LocalStack\n_response_local = LocalStack()\n\n# this is a proxy\nresponse = _response_local()\nwerkzeug.local.LocalProxy:Local对象的一个代理。如果你需要创建Local或LocalStack对象的代理，可以直接call。\nsession = LocalProxy(lambda: get_current_request().session)\n\nfrom werkzeug.local import Local, LocalProxy\nlocal = Local()\nrequest = LocalProxy(local, 'request')\n\n>>> from werkzeug.local import LocalProxy\n>>> isinstance(request, LocalProxy)\nTrue\n你也可以通过LocalProxy构造一个代理对象，参数为可以调用的对象或者函数。_get_current_object()返回被代理的对象。\nwerkzeug.local模块关键部分代码：\nimport copy\nfrom functools import update_wrapper\nfrom werkzeug.wsgi import ClosingIterator\nfrom werkzeug._compat import PY2, implements_bool\ntry:\n    from greenlet import getcurrent as get_ident\nexcept ImportError:\n    try:\n        from thread import get_ident\n    except ImportError:\n        from _thread import get_ident\n\n\ndef release_local(local):\n    local.__release_local__()\n\n\nclass Local(object):\n    __slots__ = ('__storage__', '__ident_func__')\n\n    def __init__(self):\n        object.__setattr__(self, '__storage__', {})\n        object.__setattr__(self, '__ident_func__', get_ident)\n\n    def __iter__(self):\n        return iter(self.__storage__.items())\n\n    def __call__(self, proxy):\n        \"\"\"Create a proxy for a name.\"\"\"\n        return LocalProxy(self, proxy)\n\n    def __release_local__(self):\n        self.__storage__.pop(self.__ident_func__(), None)\n\n    def __getattr__(self, name):\n        try:\n            return self.__storage__[self.__ident_func__()][name]\n        except KeyError:\n            raise AttributeError(name)\n\n    def __setattr__(self, name, value):\n        ident = self.__ident_func__()\n        storage = self.__storage__\n        try:\n            storage[ident][name] = value\n        except KeyError:\n            storage[ident] = {name: value}\n\n    def __delattr__(self, name):\n        try:\n            del self.__storage__[self.__ident_func__()][name]\n        except KeyError:\n            raise AttributeError(name)\n\n\nclass LocalStack(object):\n\n    def __init__(self):\n        self._local = Local()\n\n    def __release_local__(self):\n        self._local.__release_local__()\n\n    def __call__(self):\n        def _lookup():\n            rv = self.top\n            if rv is None:\n                raise RuntimeError('object unbound')\n            return rv\n        return LocalProxy(_lookup)\n\n    def push(self, obj):\n        rv = getattr(self._local, 'stack', None)\n        if rv is None:\n            self._local.stack = rv = []\n        rv.append(obj)\n        return rv\n\n    def pop(self):\n        stack = getattr(self._local, 'stack', None)\n        if stack is None:\n            return None\n        elif len(stack) == 1:\n            release_local(self._local)\n            return stack[-1]\n        else:\n            return stack.pop()\n\n    @property\n    def top(self):\n        try:\n            return self._local.stack[-1]\n        except (AttributeError, IndexError):\n            return None\n\n\nclass LocalManager(object):\n\n    def cleanup(self):\n        for local in self.locals:\n            release_local(local)\n\n    def make_middleware(self, app):\n        def application(environ, start_response):\n            return ClosingIterator(app(environ, start_response), self.cleanup)\n        return application\n\n\n@implements_bool\nclass LocalProxy(object):\n\n    def __init__(self, local, name=None):\n        object.__setattr__(self, '_LocalProxy__local', local)\n        object.__setattr__(self, '__name__', name)\n\n    def _get_current_object(self):\n        if not hasattr(self.__local, '__release_local__'):\n            return self.__local()\n        try:\n            return getattr(self.__local, self.__name__)\n        except AttributeError:\n            raise RuntimeError('no object bound to %s' % self.__name__)\n\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "5"}