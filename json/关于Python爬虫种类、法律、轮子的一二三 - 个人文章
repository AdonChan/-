{"title": "关于Python爬虫种类、法律、轮子的一二三 - 个人文章 ", "index": "网页爬虫,crawler,python", "content": "Welcome to the D-age\n对于网络上的公开数据，理论上只要由服务端发送到前端都可以由爬虫获取到。但是Data-age时代的到来，数据是新的黄金，毫不夸张的说，数据是未来的一切。基于统计学数学模型的各种人工智能的出现，离不开数据驱动。数据采集、清洗是最末端的技术成本，网络爬虫也是基础采集脚本。但是有几个值得关注的是：\n\n对于实时变化的网络环境，爬虫的持续有效性如何保证\n数据采集、清洗规则的适用范围\n数据采集的时间与质量--效率\n爬与反爬的恩怨\n爬虫的法律界限\n\n法律的边界,技术无罪\n对于上面几个关注点，我最先关注的便是爬虫的法律界限 ，我曾经咨询过一个律师：\nQ: 老师，我如果用爬虫爬取今日头条这种类型网站的千万级公开数据，算不算违法呢？A: 爬取的公开数据不得进行非法使用或者商业利用\n简单的概括便是爬虫爬取的数据如果进行商业出售或者有获利的使用，便构成了“非法使用”。而一般的爬虫程序并不违法，其实这是从法律专业的一方来解读，如果加上技术层面的维度，那么应该从这几方面考虑：\n\n爬取的数据量\n爬取数据的类型（数据具有巨大的商业价值，未经对方许可，任何人不得非法获取其数据并用于经营行为）\n爬取的数据用途 (同行竞争？出售？经营？分析？实验？...)\n是否遵循网站的robots.txt 即 机器人协议\n爬取行为是否会对对方网站造成不能承受的损失（大量的爬取请求会把一个小型网站拖垮）\n\n其实爬虫构成犯罪的案例是开始增多的，相关新闻:\n\n当爬虫遇上法律会有什么风险？\n程序员爬虫竟构成犯罪？\n爬虫相关法律知识\n\n如果你的上级或公司要求你爬取某些网站的大量公开数据，你会怎么办呢？可以参考第2条新闻。法律矛盾点关键在于前面考虑的前三点，如果是个人隐私数据，是不能爬取的，如果是非公开数据，是不能爬取的，而对于其他大量的公开数据爬取，看人家查不查的到你，要不要起诉你。技术在你的手上，非法与否在于你怎么去用。最好的爬取道德原则是：\n\n减少并发请求\n延长请求间隔\n不进行公开出售数据\n遵循网站 robots协议\n\n当然，反爬最有效的便(目的均在于拦截爬虫进入网站数据范围)是:\n\n要求用户密码+验证码\n加密数据\njs混淆\ncss混淆\n针对IP请求频率封锁\n针对cookie、session单个账户请求频率封锁单日请求次数\n对关键数据进行拆分合并\n对爬虫投毒（返回假数据）\n完善robots.txt\n识别点击九宫图中没有包含xxx的图片等（终极验证码)\n设置黑白名单、IP用户组等\n\n工欲善其事\n针对网站的公开数据进行爬取，我们一般都要先对网站数据进行分析，定位，以确定其采集规则，如果网站设置了访问权限，那么便不属于我们的爬虫采集范围了:)分析好采集规则，写好了采集数据持久化（存入数据库、导出为word、excel、csv、下载等）的相关代码，整个爬虫运行正常。那么怎样才能提高采集速度呢？\n\n多进程采集\n多线程采集\n异步协程采集\n多进程 + 多线程采集\n多进程 + 异步协程采集\n分布式采集\n\n异步爬虫是同步爬虫的升级版，在同步爬虫中，无论你怎么优化代码，同步IO的阻塞是最大的致命伤。同步阻塞会让采集任务一个个排着长队领票等待执行。而异步采集不会造成IO阻塞，充分利用了IO阻塞任务的等待时间去执行其他任务。\n在IO 模型中，只有IO多路复用（I/O  multiplexing）{在内核处理IO请求结果为可读或可写时调用回调函数} 不阻塞 “内核拷贝IO请求数据到用户空间”这个过程，实现异步IO操作。\n同步爬虫\n一般的同步爬虫，我们可以写一个，（以爬取图片网站图片为例），我们来看看其下载该网址所有图片所花费的时间：\n以下代码为后面多个例程的共同代码:\n#coding:utf-8\nimport time\nfrom lxml import etree\nimport urllib.request as request\n\n#目标网址\nurl = 'http://www.quanjing.com/creative/SearchCreative.aspx?id=7'\n\ndef download_one_pic(url:str,name:str,suffix:str='jpg'):\n    #下载单张图片\n    path = '.'.join([name,suffix])\n    response = request.urlopen(url)\n    wb_data = response.read()\n    with open(path,'wb') as f:\n        f.write(wb_data)\n\ndef download_many_pic(urls:list):\n    #下载多张图片\n    start = time.time()\n    for i in urls:\n        ts = str(int(time.time() * 1000))\n        download_one_pic(i, ts)\n    end = time.time()\n    print(u'下载完成,%d张图片,耗时:%.2fs' % (len(urls), (end - start)))\n\ndef get_pic_urls(url:str)->list:\n    #获取页面所有图片链接\n    response = request.urlopen(url)\n    wb_data = response.read()\n    html = etree.HTML(wb_data)\n    pic_urls = html.xpath('//a[@class=\"item lazy\"]/img/@src')\n    return pic_urls\n\ndef allot(pic_urls:list,n:int)->list:\n    #根据给定的组数，分配url给每一组\n    _len = len(pic_urls)\n    base = int(_len / n)\n    remainder = _len % n\n    groups = [pic_urls[i * base:(i + 1) * base] for i in range(n)]\n    remaind_group = pic_urls[n * base:]\n    for i in range(remainder):\n        groups[i].append(remaind_group[i])\n    return [i for i in groups if i]\n\n同步爬虫:\ndef crawler():\n    #同步下载\n    pic_urls = get_pic_urls(url)\n    download_many_pic(pic_urls)\n\n执行同步爬虫，\ncrawler()\n输出（时间可能不一样，取决于你的网速）：\n下载完成,196张图片,耗时:49.04s\n在同一个网络环境下，排除网速时好时坏，可以下载多几次取平均下载时间，在我的网络环境下，我下载了5次，平均耗时约55.26s\n多进程爬虫\n所以为了提高采集速度，我们可以写一个多进程爬虫（以爬取图片网站图片为例）:为了对应多进程的进程数n，我们可以将图片链接列表分成n组，多进程爬虫:\nfrom multiprocessing.pool import Pool\ndef multiprocess_crawler(processors:int):\n    #多进程爬虫\n    pool = Pool(processors)\n    pic_urls = get_pic_src(url)\n    #对应多进程的进程数processors，我们可以将图片链接列表分成processors组\n    url_groups = allot(pic_urls,processors)\n    for i in url_groups:\n        pool.apply_async(func=download_many_pic,args=(i,))\n    pool.close()\n    pool.join()\n\n执行爬虫,进程数设为4，一般是cpu数量：\nmultiprocess_crawler(4)\n输出:\n下载完成,49张图片,耗时:18.22s\n下载完成,49张图片,耗时:18.99s\n下载完成,49张图片,耗时:18.97s\n下载完成,49张图片,耗时:19.51s\n可以看出，多进程比原先的同步爬虫快许多，整个程序耗时19.51s，为什么不是同步爬虫的55s/4 ≈ 14s呢？因为进程间的切换需要耗时。如果把进程数增大，那么:\n进程数:10 , 耗时：12.3s\n进程数:30 , 耗时：2.81s\n进程数:40 , 耗时：11.34s\n对于多进程爬虫来说，虽然实现异步爬取，但也不是越多进程越好，进程间切换的开销不仅会让你崩溃，有时还会让你的程序崩溃。一般用进程池Pool维护，Pool的processors设为CPU数量。进程的数量设置超过100个便让我的程序崩溃退出。使用进程池可以保证当前在跑的进程数量控制为设置的数量，只有池子没满才能加新的进程进去。\n多线程爬虫\n多线程版本可以在单进程下进行异步采集，但线程间的切换开销也会随着线程数的增大而增大。当线程间需要共享变量内存时，此时会有许多不可预知的变量读写操作发生，python为了使线程同步，给每个线程共享变量加了全局解释器锁GIL。而我们的爬虫不需要共享变量，因此是线程安全的，不用加锁。多线程版本：\nimport random\nfrom threading import Thread\n\ndef run_multithread_crawler(pic_urls:list,threads:int):\n    begin = 0\n    start = time.time()\n    while 1:\n        _threads = []\n        urls = pic_urls[begin:begin+threads]\n        if not urls:\n            break\n        for i in urls:\n            ts = str(int(time.time()*10000))+str(random.randint(1,100000))\n            t = Thread(target=download_one_pic,args=(i,ts))\n            _threads.append(t)\n        for t in _threads:\n            t.setDaemon(True)\n            t.start()\n        for t in _threads:\n            t.join()\n        begin += threads\n    end = time.time()\n    print(u'下载完成,%d张图片,耗时:%.2fs' % (len(pic_urls), (end - start)))\n\ndef multithread_crawler(threads:int):\n    pic_urls = get_pic_src(url)\n    run_multithread_crawler(pic_urls,threads)\n\n并发线程数太多会让我们的系统开销越大，使程序花费时间越长，同时也会增大目标网站识别爬虫机器行为的几率。因此设置好一个适当的线程数以及爬取间隔是良好的爬虫习惯。执行多线程爬虫，设置线程数为50\nmultithreads_crawler(50)\n输出：\n下载完成,196张图片,耗时:3.10s\n增大线程数，输出：\n线程数:50,耗时:3.10s\n线程数:60,耗时:3.07s\n线程数:70,耗时:2.50s\n线程数:80,耗时:2.31s\n线程数:120,耗时:3.67s\n可以看到，线程可以有效的提高爬取效率，缩短爬取时间，但必须是一个合理的线程数，越多有时并不是越好的，一般是几十到几百个之间，数值比多进程进程数大许多。\n异步协程爬虫\nPython3.5引入了async/await 异步协程语法。详见PEP492由于asyncio提供了基于socket的异步I/O，支持TCP和UDP协议，但是不支持应用层协议HTTP，所以需要安装异步http请求的aiohttp模块单进程下的异步协程爬虫：\nimport asyncio\nfrom asyncio import Semaphore\nfrom aiohttp import ClientSession,TCPConnector\n\nasync def download(session:ClientSession,url:str,name:str,sem:Semaphore,suffix:str='jpg'):\n    path = '.'.join([name,suffix])\n    async with sem:\n        async with session.get(url) as response:\n            wb_data = await response.read()\n            with open(path,'wb') as f:\n                f.write(wb_data)\n\nasync def run_coroutine_crawler(pic_urls:list,concurrency:int):\n    # 异步协程爬虫,最大并发请求数concurrency\n    tasks = []\n    sem = Semaphore(concurrency)\n    conn =TCPConnector(limit=concurrency)\n    async with ClientSession(connector=conn) as session:\n        for i in pic_urls:\n            ts = str(int(time.time() * 10000)) + str(random.randint(1, 100000))\n            tasks.append(asyncio.create_task(download(session,i,ts,sem)))\n        start = time.time()\n        await asyncio.gather(*tasks)\n        end = time.time()\n        print(u'下载完成,%d张图片,耗时:%.2fs' % (len(pic_urls), (end - start)))\n\ndef coroutine_crawler(concurrency:int):\n    pic_urls = get_pic_src(url)\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(run_coroutine_crawler(pic_urls,concurrency))\n    loop.close()\n\n执行异步协程爬虫，设置最大并发请求数为100：\ncoroutine_crawler(100)\n输出：\n下载完成,196张图片,耗时:2.27s\n可以看出，异步多协程的下载请求效率并不比多线程差，由于磁盘IO读写阻塞，所以还可以进一步优化，使用aiofiles。针对比较大的多媒体数据下载，异步磁盘IO可以使用aiofiles,以上述例子download可以改为:\nimport aiofiles\nasync def download(session:ClientSession,url:str,name:str,sem:Semaphore,suffix:str='jpg'):\n    path = '.'.join([name,suffix])\n    async with sem:\n        async with session.get(url) as response:\n           async with aiofiles.open(path,'wb') as fd:\n            while 1:\n                wb_data_chunk = await response.content.read(1024)\n                if not wb_data_chunk:\n                    break\n                await fd.write(wb_data_chunk)\n多进程 + 多线程 爬虫\n实际采集大量数据的过程中，往往是多种手段来实现爬虫，这样可以充分利用机器CPU，节省采集时间。下面使用多进程（进程数为CPU数，4）+ 多线程 （线程数设为50）来对例子进行更改(上面各个例子导入的模块默认使用):\ndef mixed_process_thread_crawler(processors:int,threads:int):\n    pool = Pool(processors)\n    pic_urls = get_pic_src(url)\n    url_groups = allot(pic_urls,processors)\n    for group in url_groups:\n        pool.apply_async(run_multithread_crawler,args=(group,threads))\n    pool.close()\n    pool.join()\n执行爬虫：\nmixed_process_thread_crawler(4,50)\n输出：\n下载完成,49张图片,耗时:2.73s\n下载完成,49张图片,耗时:2.76s\n下载完成,49张图片,耗时:2.76s\n下载完成,49张图片,耗时:2.76s\n采集时间与异步协程和多线程并无多大的差异，可以使用更大数据量做实验区分。因为多进程+多线程，CPU切换上下文也会造成一定的开销，所以进程数与线程数不能太大，并发请求的时间间隔也要考虑进去。\n多进程 + 异步协程 爬虫\n使用多进程（进程数为CPU数，4）+ 异步协程（最大并发请求数设为50）来对例子进行更改(上面各个例子导入的模块默认使用):\ndef _coroutine_crawler(pic_urls:list,concurrency:int):\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(run_coroutine_crawler(pic_urls, concurrency))\n    loop.close()\n\ndef mixed_process_coroutine_crawler(processors:int,concurrency:int):\n    pool = Pool(processors)\n    pic_urls = get_pic_src(url)\n    url_groups = allot(pic_urls, processors)\n    for group in url_groups:\n        pool.apply_async(_coroutine_crawler, args=(group, concurrency))\n    pool.close()\n    pool.join()\n执行爬虫 ：\nmixed_process_coroutine_crawler(4,50)\n输出：\n下载完成,49张图片,耗时:2.56s\n下载完成,49张图片,耗时:2.54s\n下载完成,49张图片,耗时:2.56s\n下载完成,49张图片,耗时:2.62s\n效果与多进程 + 多线程 爬虫差不多，但是CPU减少了切换线程上下文的开销，而是对每一个协程任务进行监视回调唤醒。使用IO多路复用的底层原理实现。\n分布式采集\n关于分布式采集将会单独写一章，使用Map-Reduce+redis来实现分布式爬虫。\n轮子们，你们辛苦了\n现实生活中的爬虫不止上面那些，但是基本的骨架是一样的，对于特定的网站需要制定特定的采集规则，所以通用的数据采集爬虫很难实现。所以针对某个网站的数据采集爬虫是需要定制的，但是在不同之中包含着许多的相同、重复性的过程，比如说采集流程，或者对请求头部的伪造，数据持久化的处理等，采集框架应运而生。Scrapy就是目前比较成熟的一个爬虫框架。它可以帮助我们大大减少重复性的代码编写，可以更好的组织采集流程。而我们只需要喝一杯咖啡，编写自己的采集规则，让Scrapy去给我们管理各种各样的爬虫，做些累活。如果你是一个爬虫爱好者，那么scrapy是你的不错选择。由于好奇scrapy的实现流程，所以我才开始打开他的源码学习。有些人觉得scrapy太重，他的爬虫只需要简单的采集，自己写一下就可以搞定了。但如果是大量的爬虫采集呢？怎么去管理这些爬虫呢？怎样才能提高采集效率呀？Scrapy helps~！！另外还有另一个Python采集框架：pyspider。国人编写的，cool~感谢轮子们的父母，还有那些辛苦工作的轮子们，你们辛苦了~\n本文所用代码 均在GitHub上，地址:这里\n\n                ", "mainLikeNum": ["23 "], "mainBookmarkNum": "17"}