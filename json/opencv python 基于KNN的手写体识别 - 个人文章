{"title": "opencv python 基于KNN的手写体识别 - 个人文章 ", "index": "opencv-python,opencv,python", "content": "OCR of Hand-written Data using kNN \nOCR of Hand-written Digits\n我们的目标是构建一个可以读取手写数字的应用程序, 为此，我们需要一些train_data和test_data. OpenCV附带一个images digits.png（在文件夹opencv\\sources\\samples\\data\\中），它有5000个手写数字（每个数字500个,每个数字是20x20图像）.所以首先要将图片切割成5000个不同图片,每个数字变成一个单行400像素.前面的250个数字作为训练数据，后250个作为测试数据.\nimport numpy as np\nimport cv2\nimport matplotlib.pyplot as plt\n\nimg = cv2.imread('digits.png')\ngray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)\n\n# Now we split the image to 5000 cells, each 20x20 size\ncells = [np.hsplit(row,100) for row in np.vsplit(gray,50)]\n\n# Make it into a Numpy array. It size will be (50,100,20,20)\nx = np.array(cells)\n\n# Now we prepare train_data and test_data.\ntrain = x[:,:50].reshape(-1,400).astype(np.float32) # Size = (2500,400)\ntest = x[:,50:100].reshape(-1,400).astype(np.float32) # Size = (2500,400)\n\n# Create labels for train and test data\nk = np.arange(10)\ntrain_labels = np.repeat(k,250)[:,np.newaxis]\ntest_labels = train_labels.copy()\n\n# Initiate kNN, train the data, then test it with test data for k=1\nknn = cv2.ml.KNearest_create()\nknn.train(train, cv2.ml.ROW_SAMPLE, train_labels)\nret,result,neighbours,dist = knn.findNearest(test,k=5)\n\n# Now we check the accuracy of classification\n# For that, compare the result with test_labels and check which are wrong\nmatches = result==test_labels\ncorrect = np.count_nonzero(matches)\naccuracy = correct*100.0/result.size\nprint( accuracy )\n\n输出：91.76\n进一步提高准确率的方法是增加训练数据,特别是错误的数据.每次训练时最好是保存训练数据,以便下次使用.\n# save the data\nnp.savez('knn_data.npz',train=train, train_labels=train_labels)\n\n# Now load the data\nwith np.load('knn_data.npz') as data:\n    print( data.files )\n    train = data['train']\n    train_labels = data['train_labels']\nOCR of English Alphabets\n在opencv / samples / data /文件夹中附带一个数据文件letter-recognition.data.在每一行中,第一列是一个字母表,它是我们的标签. 接下来的16个数字是它的不同特征.\nimport numpy as np\nimport cv2\nimport matplotlib.pyplot as plt\n\n\n# Load the data, converters convert the letter to a number\ndata= np.loadtxt('letter-recognition.data', dtype= 'float32', delimiter = ',',\n                    converters= {0: lambda ch: ord(ch)-ord('A')})\n\n# split the data to two, 10000 each for train and test\ntrain, test = np.vsplit(data,2)\n\n# split trainData and testData to features and responses\nresponses, trainData = np.hsplit(train,[1])\nlabels, testData = np.hsplit(test,[1])\n\n# Initiate the kNN, classify, measure accuracy.\nknn = cv2.ml.KNearest_create()\nknn.train(trainData, cv2.ml.ROW_SAMPLE, responses)\nret, result, neighbours, dist = knn.findNearest(testData, k=5)\n\ncorrect = np.count_nonzero(result == labels)\naccuracy = correct*100.0/10000\nprint( accuracy )\n输出：93.06\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}