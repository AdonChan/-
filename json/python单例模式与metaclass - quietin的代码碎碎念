{"title": "python单例模式与metaclass - quietin的代码碎碎念 ", "index": "python", "content": "单例模式的实现方式\n将类实例绑定到类变量上\nclass Singleton(object):\n    _instance = None\n\n    def __new__(cls, *args):\n        if not isinstance(cls._instance, cls):\n            cls._instance = super(Singleton, cls).__new__(cls, *args)\n        return cls._instance\n但是子类在继承后可以重写__new__以失去单例特性\nclass D(Singleton):\n\n    def __new__(cls, *args):\n        return super(D, cls).__new__(cls, *args)\n使用装饰器实现\ndef singleton(_cls):\n    inst = {}\n\n    def getinstance(*args, **kwargs):\n        if _cls not in inst:\n            inst[_cls] = _cls(*args, **kwargs)\n        return inst[_cls]\n    return getinstance\n\n@singleton\nclass MyClass(object):\n    pass\n问题是这样装饰以后返回的不是类而是函数，当然你可以singleton里定义一个类来解决问题，但这样就显得很麻烦了\n使用__metaclass__，这个方式最推荐\nclass Singleton(type):\n    _inst = {}\n    \n    def __call__(cls, *args, **kwargs):\n        if cls not in cls._inst:\n            cls._inst[cls] = super(Singleton, cls).__call__(*args)\n        return cls._inst[cls]\n\n\nclass MyClass(object):\n    __metaclass__ = Singleton\nmetaclass\n元类就是用来创建类的东西，可以简单把元类称为“类工厂”，类是元类的实例。type就是Python的内建元类，type也是自己的元类，任何一个类\n>>> type(MyClass)\ntype\n>>> type(type)\ntype\npython在创建类MyClass的过程中，会在类的定义中寻找__metaclass__，如果存在则用其创建类MyClass，否则使用内建的type来创建类。对于类有继承的情况，如果当前类没有找到，会继续在父类中寻找__metaclass__，直到所有父类中都没有找到才使用type创建类。如果模块里有__metaclass__的全局变量的话，其中的类都将以其为元类\n查看type的定义，\ntype(object) -> the object's typetype(name, bases, dict) -> a new type\n所以利用type定义一个类的元类，可以用函数返回一个上面第二种定义的对象，也可以继承type并重写其中的方法。  \n直接使用type生成的对象作为元类，函数作用是使属性变为大写\ndef update_(name, bases, dct):\n    attrs = ((name, value) for name, value in dct.items() if not name.startswith('__'))\n    uppercase_attr = {name.upper(): value for name, value in attrs}\n    return type(name, bases, uppercase_attr)\n\n\nclass Singleton(object):\n    __metaclass__ = update_\n    abc = 2\n\nd = Singleton()\nprint d.ABC\n# 2\n上一节中，单例模式元类实现用的是类继承方式，而对于第一种__new__的方式，本质上调用的是type.__new__，不过使用super能使继承更清晰一些并避免一些问题\n这里简单说明一下，__new__是在__init__前调用的方法，会创建对象并返回，而__init__则是用传入的参数将对象初始化。看一下type中这两者以及__call__的实现\ndef __init__(cls, what, bases=None, dict=None): # known special case of type.__init__\n        \"\"\"\n        type(object) -> the object's type\n        type(name, bases, dict) -> a new type\n        # (copied from class doc)\n        \"\"\"\n        pass\n\n@staticmethod # known case of __new__\ndef __new__(S, *more): # real signature unknown; restored from __doc__\n    \"\"\" T.__new__(S, ...) -> a new object with type S, a subtype of T \"\"\"\n    pass\n\ndef __call__(self, *more): # real signature unknown; restored from __doc__\n    \"\"\" x.__call__(...) <==> x(...) \"\"\"\n    pass\n前面提到类相当于元类的实例化，再联系创建单例模式时使用的函数，用的是__call__，其实用三种magic method中任何一种都是可以的，来看一下使用元类时各方法的调用情况\nclass Basic(type):\n    def __new__(cls, name, bases, newattrs):\n        print \"new: %r %r %r %r\" % (cls, name, bases, newattrs)\n        return super(Basic, cls).__new__(cls, name, bases, newattrs)\n\n    def __call__(self, *args):\n        print \"call: %r %r\" % (self, args)\n        return super(Basic, self).__call__(*args)\n\n    def __init__(cls, name, bases, newattrs):\n        print \"init: %r %r %r %r\" % (cls, name, bases, newattrs)\n        super(Basic, cls).__init__(name, bases, dict)\n\n\nclass Foo:\n    __metaclass__ = Basic\n\n    def __init__(self, *args, **kw):\n        print \"init: %r %r %r\" % (self, args, kw)\n\na = Foo('a')\nb = Foo('b')\n结果\nnew: <class '__main__.Basic'> 'Foo' () {'__module__': '__main__', '__metaclass__': <class '__main__.Basic'>, '__init__': <function init at 0x106fd5320>}init: <class '__main__.Foo'> 'Foo' () {'__module__': '__main__', '__metaclass__': <class '__main__.Basic'>, '__init__': <function init at 0x106fd5320>}call: <class '__main__.Foo'> ('a',)init: <__main__.Foo object at 0x106fee990> ('a',) {}call: <class '__main__.Foo'> ('b',)init: <__main__.Foo object at 0x106feea50> ('b',) {}\n元类的__init__和__new__只在创建类Foo调用了一次，而创建Foo的实例时，每次都会调用元类的__call__方法\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "16"}