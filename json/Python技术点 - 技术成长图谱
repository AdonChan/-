{"title": "Python技术点 - 技术成长图谱 ", "index": "python", "content": "Python基础类型：\n1.Tuple元组，内容不可改变，但是允许元素内部存在list等类型的元素，并且允许改变列表的值，所谓内容不可变指的是在内存中指向的地址是不变的。\ntemp=(1,2,[3,4])    \ntemp[-1].append(5).  \nprint temp #(1,2,[3,4,5]). \n在创建单元素的Tuple时，在初始化的时候一定要在元素的后面加上\",\"  (temp=(1,)) 否则temp的类型为int 而不是tuple\n2.Set集合，元素中不允许存在重复元素，通过Add方法添加重复元素也不会报错，元素中不允许存在list等类型的元素，集合内的元素不存在特定顺序，所以无法按照索引的方式读取。\n3.Dict字典，字典的键-值对中键是不可以重复且无序，遍历字典存在方法items()  获取键-值对形成的元组list，keys() 获取由字典中所有的键组成的list，values() 获取由字典中的值组成的list，iteritems() 字典对象本身提供的迭代方法，免去了转化为list的过程，更省内存。\n4.List列表，这里主要记录下列表的迭代方法，要是在一次迭代中既获取list的索引，还可以获取list的值，可以使用enumerate() 先将list元素和索引转换为元组列表[(index,item)]。\nPython函数\n1.函数通过Def定义，函数的参数可以是函数的签名，变量也可以指向函数，接收函数为参数的函数称之为高阶函数。\n2.内置函数map() 实现对可迭代对象进行进一步处理。filter()实现对可迭代对象按条件过滤结果，zip()函数实现对2个可迭代对象进行压缩为一个元组列表。以上方法在对于遍历元素时可以帮助简化代码及方便对可迭代对象的处理。\n3.闭包是在内层函数引用了外层函数的变量并返回内部函数，实现对函数内部状态的封装，有点像类。\n4.Python装饰器实际就是一个高级函数，以函数为参数返回一个新的函数。在某些场景下类似于AOP，需要在函数的上方指定装饰器。函数的参数必须和装饰器最内层函数个数一致或者使用可变参数(args,*kw)。\n例如要实现对被调用函数的日志记载，就可以使用装饰器实现。对于要实现带参数的装饰器也很简单，在最外层再嵌套一次函数即可实现。\ndef log(type):\n      def returnFunc(func):\n            def internelFunc(a,b):\n                    print  type\n                    func(a,b)\n          return internelFunc\n     return returnFunc\n@log(\"INFO\")\ndef testA(a,b):\n      print a + b\ntestA(1,2) # INFO \\n 3\n5.被装饰的函数，访问函数__name__ 和__doc__属性返回的装饰器最内层函数对应的值，要想不被发现采用了装饰器，可以最内层函数签名的上方使用@functools.wraps(func) 实现对func函数的上述属性复制到最内层函数上。\n6.偏函数通过使用@functools.partial来实现把一个多参数函数，通过设置默认值转化为一个少参数的新函数. 个人认为用处不大，对于常用的函数直接封装为一个函数给定默认值即可。\ntestB=functools.partial(testA,a=2)\ntestB(b=2)\nPython模块\n1.Python模块包实际就是文件夹，但是需要在文件夹的内部存在一个__init__.py文件，这是规定，否则不会认为是一个包，在引用多级包时通过“.”来分割(包1.包2.包3)\n2.在Python的旧版中要测试新版本的功能，可以在旧版中使用 from __future__ import division\n例如在python2.7中 10/3 结果是 3，但是引入上述包之后，10/3 结果是 3.33333  这是在新版中才有的特性\n某些模块存在C语言编译的版本(例如：cStingIO等)，在进行包导入操作时，应该先检查是否存在对应的C语言编译版本，这样可以提升Python文件的执行速度。Python是动态语言，解释执行代码运行速度慢。\nPython面向对象\n1.类中定义私有方法在方法的前面加上2个“_” 即可实现， 只在类内可以访问。\n2.类的静态方法和静态变量都是可以通过类的实例访问的，类方法需要在方法上方添加装饰器@classmethod，当类实例对类变量进行动态赋值时，对类变量并不会有任何影响，只不过是给实例本身添加一个同名的属性。\n3.对类实例中的某个属性赋值时需要进行检验有效性，在C#中常用的方法是定义一个私有字段，然后定义get和set属性，通过set属性进行有效性检验，在Python也可以这么实现，但是在Python内部提供可一个装饰器@property可以简化实现\nclass  A：\n      def __init__(self):\n            self.__age=20\n      @property\n      def age(self):\n            return self.__age\n      @age.setter\n      def  age(self,age):\n            #校验有效性\n            self.__age=age\na=A()\na.age=15\n4.类继承优先级别为从右向左，子类调用父类的方法或者是给父类进行赋值操作，只需要使用super(子类名，self). 方法或属性即可。但是父类一定要继承object，否则就会报错。\n5.类中还有一个默认的特殊方法或属性，我们在使用时默认调用，可以通过dir()方法查看，例如我们在实例化类的时候，类会自动调用__init__()方法。在调用len()方法时，会调用__len__() 方法。对动态属性的限制时会调用__slots__属性等。如果有特殊需要可以使用这些方法来实现自定义操作。\n对于要使用某些语法糖，需要实现某些特殊的方法，例如想使用 with语法糖，就必须实现__enter__()和__exit__()方法。\nPython文件\n1.文件的打开权限：\nr :打开文件，文件不存在报异常w :写入文件，文件不存在则创建。写入已经存在的文件，会先清空文件在写入文件。a :追加文件，文件不存在则创建。在文件的末尾处追加内容。r+ :打开文件，具有读写权限。文件不存在则报错，写文件时不会清空文件内容，会从文件的开头进行覆盖，因为文件的指针在文件的开头，先用 read() 方法，之后在进行写文件就会变成追加的方式。w+ :写入文件，具有读写权限。文件不存在则创建。在进行文件读取操作是，默认情况下read()为空字符，因在使用写入操作时，文件内容先被清空之后在进行写入操作。a+ :追加文件，具有读写权限。文件不存在则创建。\n上述打开方式都存在对应的二进制，分别为：rb，wb，ab，rb+，wb+，ab+，记住每次read()或write()之后的指针位置，就可以掌握上面的每种模式，当前文件指针的位置使用tell()方法获取。设置文件指针的方法为seek() \n2.在对文件进行写入操作的时候，当写入的文件为unicode格式的文字时，需要先转化为utf-8\nunicode.encode(u'非白即黑'，'utf-8')\n\n以上是在学习Python中一些需要注意的地方的总结，并不是讲解Python基础，随着逐渐深入，后续还会有更新。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "3"}