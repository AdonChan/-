{"title": "python多线程、锁、event事件机制的简单使用 - python技术的魅力 ", "index": "多线程,python", "content": "线程和进程\n1、线程共享创建它的进程的地址空间,进程有自己的地址空间2、线程可以访问进程所有的数据，线程可以相互访问\n3、线程之间的数据是独立的\n4、子进程复制线程的数据\n5、子进程启动后是独立的 ，父进程只能杀掉子进程，而不能进行数据交换\n6、修改线程中的数据，都是会影响其他的线程，而对于进程的更改，不会影响子进程\n\nthreading.Thread\nThread 是threading模块中最重要的类之一，可以使用它来创建线程。有两种方式来创建线程：一种是通过继承Thread类，重写它的run方法；另一种是创建一个threading.Thread对象，在它的初始化函数（__init__）中将可调用对象作为参数传入。\n先来看看通过继承threading.Thread类来创建线程的例子：\nimport threading\nimport time\n\nclass MyThread(threading.Thread):\n    def __init__(self, arg):\n        # super(MyThread, self).__init__() # 新式类继承原有方法写法\n        threading.Thread.__init__(self)\n        self.arg = arg\n\n    def run(self):\n        time.sleep(2)\n        print(self.arg)\n\nfor i in range(10):\n    thread = MyThread(i)\n    print(thread.name)\n    thread.start()\n另外一种创建线程的方法：\nimport threading\nimport time\n\ndef process(arg):\n    time.sleep(2)\n    print(arg)\n\nfor i in range(10):\n    t = threading.Thread(target=process, args=(i,))\n    print(t.name)\n    t.start()\nThread类还定义了以下常用方法与属性：\nThread.getName() 获取线程名称Thread.setName() 设置线程名称Thread.name 线程名称Thread.ident  获取线程的标识符。线程标识符是一个非零整数，只有在调用了start()方法之后该属性才有效，否则它只返回None\n判断线程是否是激活的（alive）。从调用start()方法启动线程，到run()方法执行完毕或遇到未处理异常而中断 这段时间内，线程是激活的\nThread.is_alive()  Thread.isAlive()\nThread.join([timeout]) 调用Thread.join将会使主调线程堵塞，直到被调用线程运行结束或超时。参数timeout是一个数值类型，表示超时时间，如果未提供该参数，那么主调线程将一直堵塞到被调线程结束\n\nPython GIL(Global Interpreter Lock)\nGIL并不是Python的特性，它是在实现Python解析器(CPython)时所引入的一个概念。就好比C++是一套语言（语法）标准，但是可以用不同的编译器来编译成可执行代码。有名的编译器例如GCC，INTEL C++，Visual C++等。Python也一样，同样一段代码可以通过CPython，PyPy，Psyco等不同的Python执行环境来执行。像其中的JPython就没有GIL。然而因为CPython是大部分环境下默认的Python执行环境。所以在很多人的概念里CPython就是Python，也就想当然的把GIL归结为Python语言的缺陷。所以这里要先明确一点：GIL并不是Python的特性，Python完全可以不依赖于GIL。\n线程锁的使用：\n# 锁：GIL 全局解释器 它是为了保证线程在运行过程中不被抢占\nnumber = 0\nlock = threading.RLock()    # 创建锁\n\n\ndef run(num):\n    lock.acquire()  # 加锁\n    global number\n    number += 1\n    print(number)\n    time.sleep(2)\n    lock.release()  # 释放锁\n\nfor i in range(10):\n    t = threading.Thread(target=run, args=(i, ))\n    t.start()\nJoin & Daemon\n主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(),这个的意思是，把主线程A设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出.这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。\nclass MyThread1(threading.Thread):\n    def __init__(self):\n        threading.Thread.__init__(self)\n\n    def run(self):\n        print(\"thread start\")\n        time.sleep(3)\n        print('thread end')\n\nprint('main start')\nthread1 = MyThread1()\n# thread1.setDaemon(True)     # 设置子线程是否跟随主线程一起结束\nthread1.start()\ntime.sleep(1)\nprint('satrt join')\n# thread1.join()    # 使主线程阻塞，直至子线程运行完毕再继续主线程\nprint('end join')\ndef run(n):\n    print('[%s]------running----\\n' % n)\n    time.sleep(2)\n    print('--done--')\n\n\ndef main():\n    for i in range(5):\n        t = threading.Thread(target=run, args=[i,])\n        t.start()\n        # t.join()\n        print('starting thread', t.getName())\n\n\nm = threading.Thread(target=main,args=[])\n# m.setDaemon(True)  # 将主线程设置为Daemon线程,它退出时,其它子线程会同时退出,不管是否执行完任务\nm.start()\n# m.join()    # 使主线程阻塞，直至子线程运行完毕再继续主线程\nprint(\"---main thread done----\")\n线程锁(互斥锁Mutex)\n一个进程下可以启动多个线程，多个线程共享父进程的内存空间，也就意味着每个线程可以访问同一份数据，此时，如果2个线程同时要修改同一份数据，会出现什么状况？\nnum = 100  # 设定一个共享变量\n\ndef subNum():\n    global num # 在每个线程中都获取这个全局变量\n    print('--get num:', num)\n    time.sleep(2)\n    num -= 1 # 对此公共变量进行-1操作\n\nthread_list = []\nfor i in range(100):\n    t = threading.Thread(target=subNum)\n    t.start()\n    thread_list.append(t)\n\nfor t in thread_list: # 等待所有线程执行完毕\n    t.join()\n\nprint('final num:', num)\n# 加锁版本\n\ndef subNum():\n    global num  # 在每个线程中都获取这个全局变量\n    print('--get num:', num)\n    time.sleep(1)\n    lock.acquire()  # 修改数据前加锁\n    num -= 1  # 对此公共变量进行-1操作\n    lock.release()  # 修改后释放\n\n\nnum = 100  # 设定一个共享变量\nthread_list = []\nlock = threading.Lock()  # 生成全局锁\nfor i in range(100):\n    t = threading.Thread(target=subNum)\n    t.start()\n    thread_list.append(t)\n\nfor t in thread_list:  # 等待所有线程执行完毕\n    t.join()\n\nprint('final num:', num)\nRlock与Lock的区别：\nRLock允许在同一线程中被多次acquire。而Lock却不允许这种情况。否则会出现死循环，程序不知道解哪一把锁。注意：如果使用RLock，那么acquire和release必须成对出现，即调用了n次acquire，必须调用n次的release才能真正释放所占用的锁\nEvents\nPython提供了Event对象用于线程间通信，它是由线程设置的信号标志，如果信号标志位真，则其他线程等待直到信号接触。Event对象实现了简单的线程通信机制，它提供了设置信号，清除信号，等待等用于实现线程间的通信。\nevent = threading.Event() 创建一个event\n1 设置信号event.set()\n使用Event的set（）方法可以设置Event对象内部的信号标志为真。Event对象提供了isSet（）方法来判断其内部信号标志的状态。当使用event对象的set（）方法后，isSet（）方法返回真\n2 清除信号event.clear()\n使用Event对象的clear（）方法可以清除Event对象内部的信号标志，即将其设为假，当使用Event的clear方法后，isSet()方法返回假\n3 等待event.wait()\nEvent对象wait的方法只有在内部信号为真的时候才会很快的执行并完成返回。当Event对象的内部信号标志位假时，则wait方法一直等待到其为真时才返回。也就是说必须set新号标志位真\n\ndef do(event):\n    print('start')\n    event.wait()\n    print('execute')\n\nevent_obj = threading.Event()\nfor i in range(10):\n    t = threading.Thread(target=do, args=(event_obj,))\n    t.start()\n\nevent_obj.clear()\ninp = input('输入内容:')\nif inp == 'true':\n    event_obj.set()\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "0"}