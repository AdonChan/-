{"title": "python学习笔记 - fork, multiprocessing - helloword ", "index": "python", "content": "fork\nLinux/Unix系统提供了一个非常特殊的函数fork().该函数在调用之后，调用它的进程会被复制一份，包括当前的RAM和接下来要执行的代码。关于fork的具体内容可以阅读更多的文章：http://blog.csdn.net/jason314...http://blog.csdn.net/cywosp/a...\n调用的fork()函数，它在主进程中返回的是子进程的pid；它在子进程中反馈的是0.那么，我们就可以根据fork()函数返回的值来判断是在主进程中还是在子进程中了。在Python中，为我们提供了os.fork()。\nimport os\n\nprint \"Process (%s) is running\" % os.getpid()\ni = 100\npid = os.fork()\nif pid == 0:\n    print \"Son process (%s) is running\" % os.getpid()\nelse:\n    print \"Main process (%s) is running\" % os.getpid()\n上面的代码用到了几个函数，罗列如下：\n\nos.fork(),创建进程，在主进程中返回子进程的id，在子进程中返回0.\nos.getpid() 获取到当前进程的id。\nos.getppid() 获取当前进程父进程的id。\n\n但是唯一遗憾的是，fork()函数只能在linuxunix系统中使用，不能在windows系统中使用。\nmultiprocessing\nPython提供了跨平台的多进程支持，multiprocessing. multiprocessing模块提供了一个Process类代表一个进程。我们可以用Process创建一个进程。\nfrom multiprocessing import Process\nimport time\n\n\ndef son_process(name):\n    time.sleep(2)\n    print \"Process %s is running\" % name\n\n\nif __name__ == '__main__':\n    son_process = Process(target=son_process, args=('Son',))\n    print \"Son process is started\"\n    son_process.start()\n    son_process.join()\n    print \"Son process is ended - Printed by Main Process\"\n上面主要用到了\n\nProcess(target, attrs) 构造一个进程\nprocess.start() 进程开始\nprocess.join() 进程同步，Main进程序等待子程序完成后在执行后代码。\n\n需要注意的是，在windows下，如果子进程序不是在__main__中创建的，那么就会出错。因为windows在创建子进程的时候，会将创建它的py文件import进去。import进去机会执行，那么就会不断地创建子进程，所以会出错。因此在windows下，需要将其包含在__main__中。\nPool\n上面的提到的Process主要用于创建一个进程，如何创建多个呢？Python在multiprocessing包里为我们提供了Pool类。我们可以使用Pool.apply_async(func, args)函数来创建子进程。代码：\nfrom multiprocessing import Pool\nimport time\n\n\ndef son_process(name):\n    time.sleep(5)\n    print \"Process %s is running\\n\" % name\n\n\npool = Pool(4)\nprint \"Son process is started\"\nfor x in range(0, 10):\n    pool.apply_async(son_process, args=('son_%d'%x,))\npool.close()\nprint \"Mark\"\npool.join()\n\nprint \"Son process is ended - Printed by Main Process\"\n\nPool(4)\njoin()Wait for the worker processes to exit. One must call close() or terminate() before using join().即主进程会在.join()处等待worker进程们结束后再执行。\n\napply() 和 apply_async()\napply()和apply_async()的区别就是前者是阻塞式的，后者是非阻塞式的。阻塞式意思就是需要等待子进程完成后才能执行主线程后续的内容。非阻塞意思就是无需等待子进程，两者是同步进行的。\nmap() 和 map_async()\n跟高阶函数map()一致，Pool的map()函数是将一个可迭代对象的每一个元素作用域func。map也分阻塞和非阻塞。\nimap() 和 imap_unordered()\nimap 与 map的区别是，map是当所有的进程都已经执行完了，并将结果返回了，那么才返回map()函数的一个list结果。imap()则是立即返回一个iterable可迭代对象。其迭代随着进行返回的结果而逐步迭代。\nimap()和 imap_unordered()的区别\nimap_unordered()不保证返回的结果顺序与进程添加的顺序一致。\n怎么取得进程的结果？\n阻塞式函数：Pool.apply()直接返回结果Pool.map() 直接返回一个list非阻塞式函数Pool.apply_async()和Pool.map_async() 返回一个AsyncResult对象。AsyncResult对象具有:get()函数可以获取结果。imap() imap_unordered()则是返回可迭代函数。\n一个有用的函数 multiprocessing.cpu_count()\nmultiprocess.cpu_count()可以返回本计算机cpu的数量。我们在新建一个进程池的时候，如果不填写任何参数，那么进程池的容量默认就是cpu的数量。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "3"}