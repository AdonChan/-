{"title": "动态规划法（十）最长公共子序列（LCS）问题 - 个人文章 ", "index": "python,java,动态规划", "content": "问题介绍\n  给定一个序列$X=<x_1,x_2,....,x_m>$，另一个序列$Z=<z_1,z_2,....,z_k>$满足如下条件时称为X的子序列：存在一个严格递增的X的下标序列${i_1,i_2,...,i_k}$，对所有的$j=1,2,...,k$满足$x_{i_j}=z_j.$  给定两个序列$X$和$Y$,如果$Z$同时是$X$和$Y$的子序列，则称$Z$是$X$和$Y$的公共子序列。最长公共子序列（LCS）问题指的是：求解两个序列$X$和$Y$的长度最长的公共子序列。例如，序列$X=\\{A,B,C,B,D,A,B\\}$和$Y=\\{B,D,C,A,B,A\\}$的最长公共子序列为$\\{B,C,B,A\\}$，长度为4。  本文将具体阐释如何用动态规划法（Dynamic Programming）来求解最长公共子序列（LCS）问题。\n算法分析\n1. LCS的子结构\n  给定一个序列$X=<x_1,x_2,....,x_m>$，对$i=0,1,...,m$，定义$X$的第i前缀为$X_i=<x_1,x_2,....,x_i>$,其中$X_0$为空序列。  （LCS的子结构）令$X=<x_1,x_2,....,x_m>$和$Y=<y_1,y_2,....,y_n>$为两个序列，$Z=<z_1,z_2,....,z_k>$为$X$和$Y$的任意LCS，则：\n\n如果$x_m=y_n,$则$z_k=x_m=y_n$且$Z_{k-1}$是$X_{m-1}$和$Y_{n-1}$的一个LCS。\n如果$x_m\\neq y_n,$则$z_k \\neq x_m$意味着$Z_{k-1}$是$X_{m-1}$和$Y$的一个LCS。\n如果$x_m\\neq y_n,$则$z_k\\neq y_n$且$Z_{k-1}$是$X$和$Y_{n-1}$的一个LCS。\n\n2. 构造递归解\n  在求$X=<x_1,x_2,....,x_m>$和$Y=<y_1,y_2,....,y_n>$的一个LCS时，需要求解一个或两个子问题：如果$x_m=y_n$，应求解$X_{m-1}$和$Y_{n-1}$的一个LCS，再将$x_m=y_n$追加到这个LCS的末尾，就得到$X$和$Y$的一个LCS；如果$x_m\\neq y_n$，需求解$X_{m-1}$和$Y$的一个LCS与$X$和$Y_{n-1}$的一个LCS，两个LCS较长者即为$X$和$Y$的一个LCS。当然，可以看出，LCS问题容易出现重叠子问题，这时候，就需要用动态规划法来解决。  定义$c[i,j]$表示$X_i$和$Y_j$的LCS的长度。如果$i=0$或$j=0$，则$c[i,j]=0.$利用LCS的子结构，可以得到如下公式：\n$$\nc[i,j]=\\left\\{\n     \\begin{array}{lr}\n     0,\\qquad 若i=0或j=0\\\\\n     c[i-1, j-1]+1,\\qquad 若i,j>0且x_i=y_j\\\\\n    \\max(c[i, j-1], c[i-1, j]),\\qquad 若i,j>0且x_i\\neq y_j\n     \\end{array}\n\\right.\n$$\n3. 计算LCS的长度\n  计算LCS长度的伪代码为LCS-LENGTH. 过程LCS-LENGTH接受两个子序列$X=<x_1,x_2,....,x_m>$和$Y=<y_1,y_2,....,y_n>$为输入。它将$c[i, j]$的值保存在表$c$中，同时，维护一个表$b$，帮助构造最优解。过程LCS-LENGTH的伪代码如下：\nLCS-LENGTH(X, Y):\nm = X.length\nn = Y.length\nlet b[1...m, 1...n] and c[0...m, 0...n] be new table\n\nfor i = 1 to m\n    c[i, 0] = 0\nfor j = 1 to n\n    c[0, j] = 0\n\nfor i = 1 to m\n    for j = 1 to n\n        if x[i] == y[j]\n           c[i,j] = c[i-1, j-1]+1\n           b[i,j] = 'diag'\n           \n        elseif c[i-1, j] >= c[i, j-1]\n            c[i,j] = c[i-1, j]\n            b[i,j] = 'up'\n            \n        else\n            c[i,j] = c[i, j-1]\n            b[i,j] = 'left'\n            \nreturn c and b\n4. 寻找LCS\n  为了寻找$X$和$Y$的一个LCS， 我们需要用到LCS-LENGTH过程中的表$b$，只需要简单地从$b[m, n]$开始，并按箭头方向追踪下去即可。当在表项$b[i,j]$中遇到一个'diag'时，意味着$x_i=y_j$是LCS的一个元素。按照这种方法，我们可以按逆序依次构造出LCS的所有元素。伪代码PRINT-LCS如下：\nPRINT-LCS(b, X, i, j):\n    if i == 0 or j == 0\n        return\n    if b[i,j] == 'diag'\n        PRINT-LCS(b, X, i-1, j-1)\n        print x[i]\n    elseif b[i,j] == 'up':\n        PRINT-LCS(b, X, i-1, j)\n    else\n        PRINT-LCS(b, X, i, j-1)\n程序实现\n  有了以上对LCS问题的算法分析，我们不难写出具体的程序来实现它。下面将会给出Python代码和Java代码，供读者参考。  完整的Python代码如下：\nimport numpy as np\n\n# using dynamic programming to solve LCS problem\n# parameters: X,Y -> list\ndef LCS_LENGTH(X, Y):\n    m = len(X) # length of X\n    n = len(Y) # length of Y\n\n    # create two tables, b for directions, c for solution of sub-problem\n    b = np.array([[None]*(n+1)]*(m+1))\n    c = np.array([[0]*(n+1)]*(m+1))\n\n    # use DP to sole LCS problem\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if X[i-1] == Y[j-1]:\n                c[i,j] = c[i-1,j-1]+1\n                b[i,j] = 'diag'\n            elif c[i-1,j] >= c[i, j-1]:\n                c[i,j] = c[i-1,j]\n                b[i,j] = 'up'\n            else:\n                c[i,j] = c[i,j-1]\n                b[i,j] = 'left'\n    #print(b)\n    #print(c)\n    return b,c\n\n# print longest common subsequence of X and Y\ndef print_LCS(b, X, i, j):\n\n    if i == 0 or j == 0:\n        return None\n    if b[i,j] == 'diag':\n        print_LCS(b, X, i-1, j-1)\n        print(X[i-1], end=' ')\n    elif b[i,j] == 'up':\n        print_LCS(b, X, i-1, j)\n    else:\n        print_LCS(b, X, i, j-1)\n\nX = 'conservatives'\nY = 'breather'\n\nb,c = LCS_LENGTH(X,Y)\nprint_LCS(b, X, len(X), len(Y))\n输出结果如下：\ne a t e \n  完整的Java代码如下：\npackage DP_example;\n\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class LCS {\n    // 主函数\n    public static void main(String[] args) {\n        // 两个序列X和Y\n        List<String> X = Arrays.asList(\"A\",\"B\",\"C\",\"B\",\"D\",\"A\",\"B\");\n        List<String> Y = Arrays.asList(\"B\",\"D\",\"C\",\"A\",\"B\",\"A\");\n\n        int m = X.size(); //X的长度\n        int n = Y.size(); // Y的长度\n        String[][] b = LCS_length(X, Y); //获取维护表b的值\n\n        print_LCS(b, X, m, n); // 输出LCS\n    }\n\n    /*\n    函数LCS_length：获取维护表b的值\n    传入参数： 两个序列X和Y\n    返回值： 维护表b\n     */\n    public static String[][] LCS_length(List X, List Y){\n        int m = X.size(); //X的长度\n        int n = Y.size(); // Y的长度\n        int[][] c = new int[m+1][n+1];\n        String[][] b = new String[m+1][n+1];\n\n        // 对表b和表c进行初始化\n        for(int i=1; i<m+1; i++){\n            for(int j=1; j<n+1; j++){\n                c[i][j] = 0;\n                b[i][j] = \"\";\n            }\n        }\n        \n        // 利用自底向上的动态规划法获取b和c的值\n        for(int i=1; i<m+1; i++){\n            for(int j=1; j<n+1; j++){\n                if(X.get(i-1) == Y.get(j-1)){\n                    c[i][j] = c[i-1][j-1]+1;\n                    b[i][j] = \"diag\";\n                }\n                else if(c[i-1][j] >= c[i][j-1]){\n                    c[i][j] = c[i-1][j];\n                    b[i][j] = \"up\";\n                }\n                else{\n                    c[i][j] = c[i][j-1];\n                    b[i][j] = \"left\";\n                }\n            }\n        }\n\n        return b;\n    }\n\n    // 输出最长公共子序列\n    public static int print_LCS(String[][] b, List X, int i, int j){\n\n        if(i == 0 || j == 0)\n            return 0;\n\n        if(b[i][j].equals(\"diag\")){\n            print_LCS(b, X, i-1, j-1);\n            System.out.print(X.get(i-1)+\" \");\n        }\n        else if(b[i][j].equals(\"up\"))\n            print_LCS(b, X, i-1, j);\n        else\n            print_LCS(b, X, i, j-1);\n\n        return 1;\n    }\n}\n输出结果如下：\nB C B A \n参考文献\n\n算法导论（第三版）  机械工业出版社\nhttps://www.geeksforgeeks.org...\n\n注意：本人现已开通两个微信公众号： 因为Python（微信号为：python_math）以及轻松学会Python爬虫（微信号为：easy_web_scrape）， 欢迎大家关注哦~~\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}