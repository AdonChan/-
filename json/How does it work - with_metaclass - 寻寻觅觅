{"title": "How does it work - with_metaclass - 寻寻觅觅 ", "index": "python", "content": "我在看源代码的时候，经常蹦出这一句：How does it work!竟然有这种操作？本系列文章，试图剖析代码中发生的魔法。顺便作为自己的阅读笔记，以作提高。\n先简单介绍下Python中的元类(metaclass)。元类就是创建类的类，对于元类来说，类是它的实例，isinstance(cls, metaclass)将返回True。Python中的所有类，都是type的实例，换句话说，type是元类的基类。使用type创建一个类的方法如下：\n>>>type('MyClass', (), {})\n<class '__main__.MyClass'>type接受三个参数，第一个参数是类名称，第二个参数是继承的基类的元组，第三个参数是类的命名空间。上例中，我们创建了一个无基类（直接继承object），无初始命名空间的类MyClass。\n注：使用type创建的类和使用元类的类，都是新式类\n使用元类后，该类将由定义的元类实例化来创建。定义的方法在Python 2与Python 3中有所不同：\n\n# Python 2:\nclass MyClass(object):\n    __metaclass__ = MyMeta\n\n# Python 3:\nclass MyClass(metaclass=MyMeta):\n    pass\n如果你的项目需要兼容Python 2和Python 3，就需要使用一种方法，同时支持Python 2和Python 3。元类有两个基本特性：\n元类实例化得到类元类能被子类继承根据这两个特性，我们不难得到解决方案：\n用元类实例化得到一个临时类定义类时继承这个临时类我们可以写出一个with_metaclass函数：\n\ndef with_metaclass(meta, *bases):\n    \"\"\"Compatible metaclass\n\n    :param meta: the metaclass\n    :param *bases: base classes\n    \"\"\"\n    return meta('temp_class', bases, {})\n\n# Testing:\nclass TestMeta(type):\n    def __new__(cls, name, bases, d):\n        d['a'] = 'xyz'\n        return type.__new__(cls, name, bases, d)\n\n\nclass Foo(object):pass\n\nclass Bar(with_metaclass(TestMeta, Foo)): pass\n我们就创建了一个以TestMeta为元类，继承Foo的类Bar。验证：\n>>> Bar.a\n'xyz'\n>>> Bar.__mro__\n(<class '__main__.Bar'>, <class '__main__.temp_class'>, <class '__main__.Foo'>, <class 'object'>)\n一切正常，但我们看到在Bar的mro里混进了一个临时类temp_class，你忽略它吧，有时会很麻烦。作为完美主义者，我想寻找一种解决办法，不要在mro中引入多余的类。\nPython的six模块专门为解决Python 2to3兼容问题而生，模块里带有一个with_metaclass函数，我们来看它是怎么实现的：（为了debug，添加了一个print语句）\n\ndef with_metaclass(meta, *bases):\n    class metaclass(type):\n        def __new__(cls, name, this_bases, d):\n            print(cls, \"new is called\")\n            return meta(name, bases, d)\n    return type.__new__(metaclass, 'temp_class', (), {})\n\n# Testing:\nclass TestMeta(type):\n    def __new__(cls, name, bases, d):\n        d['a'] = 'xyz'\n        print(cls, \"new is called\")\n        return type.__new__(cls, name, bases, d)\n一时看不懂？没关系，我们来用用看，为了看清楚过程，我们分成两步执行：\n>>> temp = with_metaclass(TestMeta, Foo)\n>>> class Bar(temp): pass\n...\n<class '__main__.with_metaclass.<locals>.metaclass'> new is called\n<class '__main__.TestMeta'> new is called\n>>> Bar.a\n'xyz'\n>>> Bar.__mro__\n(<class '__main__.Bar'>, <class '__main__.Foo'>, <class 'object'>)\n我们明明生成了一个临时类temp_class，但后来竟然消失了！下面来仔细分析函数的运行过程。首先我们看到，执行第一步生成临时类时，两个__new__都没有调用，而第二步定义类时，两个__new__都调用了。奥秘就在函数的返回语句return type.__new__(metaclass, 'temp_class', (), {})，它创建了一个临时类，具有如下属性：\n名称为temp_class是函数内部类metaclass的实例，它的元类是metaclass没有基类创建时仅调用了type的__new__的方法这是一个metaclass实例的不完全版本。接下来，定义Bar时，Bar得到继承的元类metaclass，过程如下：\n实例化metaclass调用metaclass.__new__返回meta(name, bases, d)， meta=TestMeta，bases=(Foo,)调用TestMeta.__new__实例化得到BarBar的基类由第3步得到，于是就去除了temp_class，这其实用到了闭包，with_metaclass返回的临时类中，本身无任何属性，但包含了元类和基类的所有信息，并在下一步定义类时将所有信息解包出来。\n以上就是with_metaclass源代码的解析，通过这篇文章，相信能加深元类与闭包的理解。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}