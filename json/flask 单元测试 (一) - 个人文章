{"title": "flask 单元测试 (一) - 个人文章 ", "index": "python,flask", "content": "框架选择：\n根据 https://blog.zengrong.net/pos...得知：  flask项目本身使用的是pytest  nose是对标准库unittest的封装，现在比较流行，但文档没有pytest做的好，且近几年一直处于维护状态没有更新。  Flask-Testing flask扩展  最终选择：pytest\npytest\n特点:\n\n非常容易上手，入门简单，文档丰富，文档中有很多实例可以参考\n能够支持简单的单元测试和复杂的功能测试\n支持参数化\n执行测试过程中可以将某些测试跳过，或者对某些预期失败的case标记成失败\n支持重复执行失败的case\n支持运行由nose, unittest编写的测试case\n具有很多第三方插件，并且可以自定义扩展\n方便的和持续集成工具集成\n\n在命令行输入如下命令检查pytest是否已安装\npy.test --version\n如果没有\npip install -U pytest\n第一个例子：测试函数\n# content of test_sample.py\n\n\ndef func(x):\n    return x+1\n\n\ndef test_func():\n    assert func(3) == 5\n\n运行:  执行测试时需要下面几步：\n\n从命令行进入测试文件所在目录，pytest会在该目录中寻找以test开头的文件\n找到测试文件，进入测试文件中寻找以test_开头的函数并执行\n测试函数以断言assert结尾\n\n$ py.test\n============================= test session starts ==============================\nplatform darwin -- Python 3.5.1, pytest-2.8.1, py-1.4.30, pluggy-0.3.1\nrootdir: /Users/fc/project/test/pytest_sample, inifile:\ncollected 1 items\n\ntest_sample.py F\n\n=================================== FAILURES ===================================\n__________________________________ test_func ___________________________________\n\n    def test_func():\n>       assert func(3) == 5\nE       assert 4 == 5\nE        +  where 4 = func(3)\n\ntest_sample.py:9: AssertionError\n=========================== 1 failed in 0.01 seconds ===========================\n第二个例子: 测试类\n# content of test_class.py\n\n\nclass TestClass(object):\n    def test_one(self):\n        x = 'this'\n        assert 'h' in x\n\n    def test_two(self):\n        x = 'hello'\n        assert hasattr(x, 'check')\n\n运行下面的-q是 quiet的意思,就是忽略一些很细节的信息  使用测试类时，注意下面几点：\n\n测试类所在的文件以test_开头\n测试类以Test开头，并且不能带有__init__方法\n类中测试函数以test_开头\n测试函数以assert断言结尾\n\nbogon:pytest_sample fc$ py.test -q test_class.py\n.F\n=================================== FAILURES ===================================\n______________________________ TestClass.test_two ______________________________\n\nself = <test_class.TestClass object at 0x10595b080>\n\n    def test_two(self):\n        x = 'hello'\n>       assert hasattr(x, 'check')\nE       assert hasattr('hello', 'check')\n\ntest_class.py:11: AssertionError\n1 failed, 1 passed in 0.01 seconds\n第三个例子：参数化测试函数\nimport pytest\n\nparams = [\n    (2, 3, 5),\n    (4, 5, 9),\n    (6, 7, 12)\n]\n\n\n@pytest.mark.parametrize('a, b, expected', params)\ndef test_add(a, b, expected):\n    assert a + b == expected\n\n运行结果\n$ py.test -q test_params.py\n..F\n=================================== FAILURES ===================================\n_______________________________ test_add[6-7-12] _______________________________\n\na = 6, b = 7, expected = 12\n\n    @pytest.mark.parametrize('a, b, expected', params)\n    def test_add(a, b, expected):\n>       assert a + b == expected\nE       assert (6 + 7) == 12\n\ntest_params.py:12: AssertionError\n1 failed, 2 passed in 0.01 seconds\n说明：\n\nparams是要进行测试的参数list，其中元素为tuple，每个tuple对应一套参数\n@pytest.mark.parametrize装饰器的第一个参数是一个字符串，不过这个字符串其实是以逗号分隔的一组参数，这个参数就是其所装饰的函数的参数。\n@pytest.mark.parametrize装饰器将params中的参数一套一套拿出来放入其所装饰的函数中执行\n\n第四个例子 fixture params\nimport pytest\n\n\n@pytest.fixture(params=[1, 2, 3])\ndef test_data(request):\n    return request.param\n\n\ndef test_not_2(test_data):\n    assert test_data != 2\n\n运行结果：\n$ py.test -q fixture_params.py\n.F.\n======================================= FAILURES =======================================\n____________________________________ test_not_2[2] _____________________________________\n\ntest_data = 2\n\n    def test_not_2(test_data):\n>       assert test_data != 2\nE       assert 2 != 2\n\nfixture_params.py:10: AssertionError\n1 failed, 2 passed in 0.01 seconds\n说明：\n\n把一个函数定用@pytest.fixture装饰，那这个函数就是fixture函数\n一个fixture函数可以被其他测试函数调用，将函数名当作参数即可，fixture的返回值会当作测试函数的参数\nfixture函数中的params字段默认为None，如果有值，则每个值都会调用执行一次\n\n在flask项目中使用pytest\nflask应用demo代码\nfrom flask import Flask\n\n\napp = Flask(__name__)\n\n\n@app.route('/')\ndef index():\n    return 'hello'\n\n\n@app.route('/login')\ndef login():\n    return 'login'\n\n\n@app.route('/logout')\ndef logout():\n    return 'logout'\n\n\n@app.errorhandler(404)\ndef page_not_found():\n    return '404'\n\n\nif __name__ == '__main__':\n    app.run()\n\nflask demo的测试代码\nfrom flaskr import app\n\n\nclass TestClass(object):\n    def setup_class(self):\n        \"\"\"测试开始时候执行, 用来做准备工作，一般用来初始化资源。\"\"\"\n        app.config['TESTING'] = True  # 这将会使得处理请求时的错误捕捉失效，以便于 您在进行对应用发出请求的测试时获得更好的错误反馈。\n        # 测试客户端将会给我们一个通向应用的简单接口，我们可以激发 对向应用发送请求的测试，并且此客户端也会帮我们记录 Cookie 的 动态。\n        self.app = app.test_client()\n\n    def teardown_class(self):\n        \"\"\"测试结束时执行， 用来做收尾工作， 一般用来关闭资源\"\"\"\n        pass\n\n    def test_login(self):\n        response = self.app.get('/login')\n        assert b'login' == response.data\n\n    def test_logout(self):\n        response = self.app.get('logout')\n        assert b'logout' == response.data\n\n    def test_index(self):\n        response = self.app.get('/')\n        assert b'hello' == response.data\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}