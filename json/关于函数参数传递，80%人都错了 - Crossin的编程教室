{"title": "关于函数参数传递，80%人都错了 - Crossin的编程教室 ", "index": "python", "content": "还记得上一次关于变量作用域文章 ：\nCrossin：全菊变量和菊部变量zhuanlan.zhihu.com\n我们在公众号（Crossin的编程教室）里做了个问题投票：\n\n\ndef func(m):\n    m[0] = 20\n    m = [4, 5, 6]\n    return m\n\nl = [1, 2, 3]\nfunc(l)\nprint('l =', l)\n\n\n实际的输出我想大家都尝试过了吧，应该是选项二：  [20, 2, 3]\n和80%人想象中的结果不一样。\n\n这是为什么呢？\n在 Python 的官方文档 FAQ 里有这样一句话\nRemember that arguments are passed by assignment in Python.  要记住，Python 里的参数是通过赋值传递的。\nhttps://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference\n所以要弄清楚参数传递，先得弄清 Python 的赋值。\n或许在很多人的直观印象中，变量是一个容器；给变量赋值，就像是往一个存储的容器中填入一个数据；再次赋值就是把容器中的数据换掉。\n然而，\n在 Python 中，这种理解是不准确的！  在 Python 中，这种理解是不准确的！  在 Python 中，这种理解是不准确的！\n若是想要个形象的类比， Python 中的变量更像是是个标签；给变量赋值，就是把标签贴在一个物体上；再次赋值就是把标签贴在另一个物体上 。\n体会下这两种设计的差异：\n· 前者，变量是一个固定的存在，赋值只会改变其中的数值，而变量本身没有改动。  · 后者，变量不存在实体，它仅仅是一个标签，一旦赋值就被设置到另一个物体上，不变的是那些物体。\n这些“物体”就是 对象 。 Python 中所有东西都是对象 ，包括函数、类、模块，甚至是字符串’hello’，数字1、2、3，都是对象。\n用个例子来说明：\n\n\na = 1\nb = 2\nc = 1\n# 再次赋值\na = b\n\n\n在这个代码里，a 和 c 其实指向的是同一个对象—整数 1。给 a 赋值为 b 之后，a 就变成了指向 2 的标签，但 1 和 c 都不会受影响。\n示意图：\n\n更有说服力一点的验证：\n\n\na = 1\nprint('a', a, id(a))\nb = 2\nprint('b', b, id(b))\nc = 1\nprint('c', c, id(c))\n# 再次赋值\na = b\nprint('a', a, id(a))\n\n\n输出：\n\n\na 1 4301490544\nb 2 4301490576\nc 1 4301490544\na 2 4301490576\n\n\nid() 可以认为是获取一个对象的地址。可以看出，a 和 c 开始其实是同一个地址，而后来赋值之后，a 又和 b 是同一个地址。\n每次给变量重新赋值，它就指向了新的地址，与原来的地址无关了。\n回到函数的调用上：  Python 里的参数是通过赋值传递的\n\n\n def fn(x):\n    x = 3\n\na = 1\nfn(a)\nprint(a)\n\n\n输出结果为 1，a 没有变化。\n调用 fn(a) 的时候，就相当于做了一次 x = a，把 a 赋值给了 x，也就是把 x 这个标签贴在了 a 的对象上。只不过 x 的作用域仅限于函数 fn 内部。\n当 x 在函数内部又被赋值为 3 时，就是把 x 又贴在了 3 这个对象上，与之前的 a 不在有关系。所以外部的 a 不会有任何变化。\n把其中的数值换成其他对象，效果也是一样的：\n\n\ndef fn(x):\n    x = [4,5,6]\n\na = [1,2,3]\nfn(a)\nprint(a)\n\n\n输出结果为 [1,2,3]，a 没有变化。（记住这个例子，最后我们还会提到）\n那上次的题目又是怎么回事？\n我们再来看一个赋值：\n\n\na = [1,2,3]\nprint('a', a, id(a))\nb = a\nprint('b', b, id(b))\nb[1] = 5\nprint('a', a, id(a))\nprint('b', b, id(b))\n\n\n输出：\n\n\na [1, 2, 3] 4490723464\nb [1, 2, 3] 4490723464\na [1, 5, 3] 4490723464\nb [1, 5, 3] 4490723464\n\n\n这个是不是好理解一点？b 赋值为 a 后，和 a 指向同一个列表对象。[1] 这个基于 index 的赋值是 list 对象本身的一种操作，并没有给 b 重新贴标签，改变的是对象本身。所以 b 指向的还是原来的对象，此对象的改动自然也会体现在 a 身上。同理，b.append(7) 这样的操作也会是类似的效果。\n\n再来回顾下原问题呢：\n\n\ndef func(m):\n    m[0] = 20\n    # m = [4, 5, 6]\n    return m\n\nl = [1, 2, 3]\nfunc(l)\nprint('l =', l)\n\n\n去掉那句 m=[4,5,6] 的干扰，函数的调用就相当于：\n\n\nl = [1, 2, 3]\nm = l\nm[0] = 20\n\n\nl 的值变成 [20,2,3] 没毛病吧。而对 m 重新赋值之后，m 与 l 无关，但不影响已经做出的修改。\n这就是这道题的解答。上次留言里有些同学已经解释的很准确了。\n另外说下， 函数的返回值 return，也相当于是一次赋值 。只不过，这时候是把函数内部返回值所指向的对象，赋值给外面函数的调用者：\n\n\ndef fn(x):\n    x = 3\n    print('x', x, id(x))\n    return x\n\na = 1\na = fn(a)\nprint('a', a, id(a))\n\n\n输出：\n\n\nx 3 4556777904\na 3 4556777904\n\n\n函数结束后，x 这个标签虽然不存在了，但 x 所指向的对象依然存在，就是 a 指向的新对象。\n所以，如果你想要通过一个函数来修改外部变量的值，有几种方法：\n\n通过返回值赋值\n使用全局变量\n修改 list 或 dict 对象的内部元素\n修改类的成员变量\n\n有相当多的教程把 Python 的函数参数传递分为可变对象和不可变对象（这个概念下次来说）来说明，然后类比到 C++ 的值传递和引用传递。我很反对这样去理解：\n\n对于没有学过 C++ 的人来说，这个解释属于循环论证，还是没说清问题。\nPython 本来就不存在值传递/引用传递的概念，这个比较没有意义。\n这个类比实际上是错误的。就算类比，也应该是相当于 C++ 里的指针值传递。\n用可变对象/不可变对象来划分很容易产生误解，比如我们前面例子中的 x=[4,5,6]，它是可变对象，但一样不影响外部参数的值。\n\n这点前面贴出的官方文档里也直说了：\nSince assignment just creates references to objects, there’s no alias between an argument name in the caller and callee, and so no call-by-reference per se.  赋值是创建了一份对象的引用（也就是地址），形参和实参之间不存在别名的关系，本质上不存在引用传递。\n网上很容易搜到“参数是可变对象就相当于引用传递”这种错误的理解。也不知道他们是对 Python 的参数传递有什么误解，还是对C++的引用传递有什么误解。结果就是，让很多初学者从网上看了几篇教程之后，更糊涂了。\n所以呢，找到一个靠谱的教程是非常重要滴\n════  其他文章及回答：\n如何自学Python | 新手引导 | 精选Python问答 | Python单词表 | 区块链 | 人工智能 | 双11 | 嘻哈 | 爬虫 | 排序算法 | 我用Python | 高考 | 世界杯\n欢迎搜索及关注： Crossin的编程教室\n\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "1"}