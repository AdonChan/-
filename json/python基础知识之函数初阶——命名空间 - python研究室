{"title": "python基础知识之函数初阶——命名空间 - python研究室 ", "index": "python", "content": "python中的命名空间分三种：\n内置的命名空间，在启动解释器的时候自动加载进内存的各种名字所在的空间，比如print,input等不需要定义就可以使用的名字\n全局命名空间，就是从上到下所有我们定义的变量名和函数名所在的空间，是在程序从上到下被执行的过程中加载进内存的。\n局部命名空间，比如函数在执行时所开辟的空间，里面存放了函数内部定义的各种名字，随着函数执行结束 这个局部命名空间就消失了。\n在局部命名空间可以使用全局和内置命名空间中的名字\n在全局命名空间可以使用内置命名空间中的名字，但不能使用局部命名空间的。\n在内置命名空间不能使用全局和局部的名字。\n可以形象地理解成内置命名空间具有最高级别，不需要定义就可以使用，全局命名空间次之，最低级是局部命名空间。\n当低级命名空间使用名字时首先会在自身的命名空间里查找，如果有就使用，没有的话就到上一级命名空间内查找，如果有就使用，没有就继续到更上一级空间内查找，直到顶层的内置命名空间，如果有就使用，没有则会报错。\n举个例子如下：\nnum = 1 #这是全局命名空间内定义的num = 1\ndef func1(): #这个函数会创建一个局部命名空间1\n    num = 2  #这是在局部命名空间1定义的num = 2\n    def func2(): #这个函数会创建一个局部命名空间2\n        num = 3 #这是在局部命名空间2 内 定义的num = 3\n        print(num) #这是在局部命名空间2内 使用num 变量\n    func2() # 调用函数func2时 会执行该命令创建局部命名空间2\nfunc1()  #调用函数func1时会创建局部命名空间1，\n#这几个命名空间的级别顺序是：内置>全局>局部1>局部2\n#当print(num)指令执行时它会在局部2内查找是否有num，发现有则直接引用，如果没有则会到上一级（局部1）中查找，局部1没有则继续到上一级（全局）查找\n再看一个例子：\n#max()函数是内置的函数，如果我们在全局命名空间中定义了函数名为max的函数时，则该函数就失效了，也就是说在自身空间内找到了max()后就不去内置命名空间查找了\ndef max(a,b,c):\n    return 'max失效了？'\nprint(max(1,2,3))#\n正常情况下应该输出3（max函数功能是返回最大值），但是因为我们把max这个名字占用了，所以当使用时程序就不去上一级空间（内置命名空间）去查找了\n与命名空间有关的两个函数globals()和locals()可以用globals()查看全局命名空间的所有定义的名字可以用locals()查看当前命名空间的所有定义的名字，在全局则返回全局，在局部则返回局部这两个函数的返回值可以看作是字典，格式都是{key1:value1,key2:value2,.....}\n当函数1内嵌套函数2时，对于函数1内的不可变数据类型的变量，函数2内可以引用，但不可修改\ndef func1():\n    a = 1\n    def func2():\n        a = a + 1 \n#此处会报一个严重错误，因为a同时出现在等号两边，Python会先执行等号右边的表达式，\n#发现你在引用a，然后它会先在本空间查找a，结果找到了等号左边的a，其结果就是“在定义变量前引用变量”\n        pass      \n    func2()\nfunc1()\n#如果想要修改，可以使用nonlocal(python3中新增)\ndef func1():\n    a = 1\n    def func2():\n        nonlocal a\n        a = a + 1\n    func2()\n    print(a) \nfunc1()\n#我们可以看出，执行func2()后再输出a，a已经变成2了\n    2\nnonlocal只能作用于局部变量，当使用后它会自动查找上一级局部命名空间是否有该变量，如果没有继续向上查找，直到最上一级“局部命名空间”\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}