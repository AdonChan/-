{"title": "python yield - 个人文章 ", "index": "python", "content": "yield\n为了精通 yield ,你必须要理解：当你调用这个函数的时候，函数内部的代码并不立马执行 ，这个函数只是返回一个生成器对象，这有点蹊跷不是吗。\n那么，函数内的代码什么时候执行呢？当你使用for进行迭代的时候.现在到了关键点了！\n第一次迭代中你的函数会执行，从开始到达 yield 关键字，然后返回 yield 后的值作为第一次迭代的返回值. 然后，每次执行这个函数都会继续执行你在函数内部定义的那个循环的下一次，再返回那个值，直到没有可以返回的。\n1、通常的for...in...循环中，in后面是一个数组，这个数组就是一个可迭代对象，类似的还有链表，字符串，文件。它可以是mylist = [1, 2, 3]，也可以是mylist = [x*x for x in range(3)]。它的缺陷是所有数据都在内存中，如果有海量数据的话将会非常耗内存。2、生成器是可以迭代的，但只可以读取它一次。因为用的时候才生成。比如 mygenerator = (x*x for x in range(3))，注意这里用到了()，它就不是数组，而上面的例子是[]。3、我理解的生成器(generator)能够迭代的关键是它有一个next()方法，工作原理就是通过重复调用next()方法，直到捕获一个异常。4、带有 yield 的函数不再是一个普通函数，而是一个生成器generator，可用于迭代，工作原理同上。5、yield 是一个类似 return 的关键字，迭代一次遇到yield时就返回yield后面(右边)的值。重点是：下一次迭代时，从上一次迭代遇到的yield后面的代码(下一行)开始执行。6、简要理解：yield就是 return 返回一个值，并且记住这个返回的位置，下次迭代就从这个位置后(下一行)开始。7、带有yield的函数不仅仅只用于for循环中，而且可用于某个函数的参数，只要这个函数的参数允许迭代参数。比如array.extend函数，它的原型是array.extend(iterable)。8、send(msg)与next()的区别在于send可以传递参数给yield表达式，这时传递的参数会作为yield表达式的值，而yield的参数是返回给调用者的值。——换句话说，就是send可以强行修改上一个yield表达式值。比如函数中有一个yield赋值，a = yield 5，第一次迭代到这里会返回5，a还没有赋值。第二次迭代时，使用.send(10)，那么，就是强行修改yield 5表达式的值为10，本来是5的，那么a=109、send(msg)与next()都有返回值，它们的返回值是当前迭代遇到yield时，yield后面表达式的值，其实就是当前迭代中yield后面的参数。10、第一次调用时必须先next()或send(None)，否则会报错，send后之所以为None是因为这时候没有上一个yield(根据第8条)。可以认为，next()等同于send(None)。代码示例1：\n#encoding:UTF-8  \ndef yield_test(n):  \n    for i in range(n):  \n        yield call(i)  \n        print(\"i=\",i)  \n    #做一些其它的事情      \n    print(\"do something.\")      \n    print(\"end.\")  \n  \ndef call(i):  \n    return i*2  \n  \n#使用for循环  \nfor i in yield_test(5):  \n    print(i,\",\")  \n结果是：\n\n0 ,  i= 0  2 ,  i= 1  4 ,  i= 2  6 ,  i= 3  8 ,  i= 4  do something.  end.  \n理解的关键在于：下次迭代时，代码从yield的下一跳语句开始执行。\n\nyield from\npython yield from 语法yield from 是 Python3.3 后新加的语言结构。和其他语言的await关键字类似，它表示：*在生成器 gen 中使用 yield from subgen()时，subgen 会获得控制权，把产出的值传个gen的调用方，即调用方可以直接控制subgen。于此同时，gen会阻塞，等待subgen终止。yield语法比较简单, 教程也很多 , yield from的中文讲解很少 , python官网是这样解释的\nPEP 380 adds the yield from expression, allowing a generator to delegate part of its operations to another generator. This allows a section of code containing yield to be factored out and placed in another generator. Additionally, the subgenerator is allowed to return with a value, and the value is made available to the delegating generator.\n官网链接\n大意是说 yield from 表达式允许一个生成器代理另一个生成器, 这样就允许生成器被替换为另一个生成器, 子生成器允许返回值\ndef g1(x):     \n     yield  range(x)\ndef g2(x):\n     yield  from range(x)\n\nit1 = g1(5)\nit2 = g2(5)\n#it1[0] = range(0,5)\n#it2 = range(0,5)\nprint( [ x for x in it1] )\n#out [range(0, 5)]\nprint( [ x for x in it2] )\n#out [0, 1, 2, 3, 4]\n可以看到 , yield返回一个生成器 , 这个生成器就是range自身 , yield from 也返回一个生成器, 这个生成器是由range代理的\nyield from 在递归结构中常用 , 例如\nclass Node:\n    def __init__(self, value):\n        self._value = value\n        self._children = []\n\n    def __repr__(self):\n        return 'Node({!r})'.format(self._value)\n\n    def add_child(self, node):\n        self._children.append(node)\n\n    def __iter__(self):\n        return iter(self._children)\n\n    def depth_first(self):\n        yield self\n        for c in self:\n            yield from c.depth_first()\n如果不加上from , depth_first 只能返回根节点的值yield from 详细解释http://blog.gusibi.com/post/p...\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "3"}