{"title": "SSH连接与自动化部署工具paramiko与Fabric - 倚楼听风雨 ", "index": "python,fabric,paramiko", "content": "paramiko\nparamiko是基于Python实现的SSH2远程安全连接，支持认证及密钥方法。可以实现远程命令执行，文件传输，中间SSH代理等功能，相对于Pexpect，封装层次更高。\npip install Paramiko\nhttp://www.paramiko.org/demo:https://github.com/paramiko/p...\n如果在linux环境，还需安装依赖：crypto,ecdsa，python3-devel。\nparamiko包含两个核心组件:SSHClient类，SFTPClient类\n密钥方式登录\nimport paramiko, base64,getpass\n \nparamiko.util.log_to_file('syslogin.log') #日志记录\ntry:\n        key=paramiko.RSAKey.from_private_key_file('pk_path')\nexcept paramiko.PasswordRequiredException:\n        password = getpass.getpass('RSA key password: ')\n        key = paramiko.RSAKey.from_private_key_file('pk_path', password)    # 需要口令的私钥\n#key = paramiko.RSAKey(data=base64.decodestring('AAA...'))\nclient = paramiko.SSHClient()\n# client.get_host_keys().add('ssh.example.com', 'ssh-rsa', key)\nclient.load_system_host_keys()#~/.ssh/known_hosts\nclient.connect('ssh.example.com', 22,username='strongbad', password='thecheat',pkey=key)\nstdin, stdout, stderr = client.exec_command('ls')\n# stdin, stdout, stderr=ssh.exec_command('sudo su')\n# stdin.write('123456')\nfor line in stdout:\n    print('... ' + line.strip('\\n'))\n#使用send\n# cmds=['sudo su\\n', 'cd /var/log\\n', 'ls\\n'] #利用send函数发送cmd到SSH server，添加'\\n'做回车来执行shell命令。注意不同的情况，如果执行完telnet命令后，telnet的换行符是\\r\\n\n# ssh=s.invoke_shell() #在SSH server端创建一个交互式的shell，且可以按自己的需求配置伪终端，可以在invoke_shell()函数中添加参数配置。\n# for cmd in cmds:\n#         time.sleep(1)\n#         ssh.send(cmd) #利用send函数发送cmd到SSH server，\n#         out = ssh.recv(1024) #.recv(bufsize)通过recv函数获取回显。\n#         print out\nclient.close()\n\n用户名密码方式登录\n#####################################################################################\nimport paramiko\n \nparamiko.util.log_to_file('syslogin.log') #日志记录\nclient = paramiko.SSHClient()\nclient.set_missing_host_key_policy(paramiko.AutoAddPolicy())\nclient.connect('192.168.8.248', 22, username='root', password='password', timeout=4)\nstdin, stdout, stderr = client.exec_command('ls -l')\n#print(stdout.read())\nfor line in stdout.readlines():\n  print(line)\nclient.close()\n\nSSHClient方法参数说明connect(hostname, port=22, username=None, password=None, pkey=None, key_filename=None, timeout=None, allow_agent=True, look_for_keys=True, compress=False, sock=None, gss_auth=False, gss_kex=False, gss_deleg_creds=True, gss_host=None, banner_timeout=None)\npkey-私钥类型key_filename-str or list(str) 私钥文件或其列表timeout-以秒为单位allow_agent-为False时禁用连接到SSH代理look_for_keys-为False时禁用在~/.ssh中搜索私钥文件exec_command(command, bufsize=-1, timeout=None, get_pty=False)command-字符串\nload_system_host_keys(filename=None)指定公钥文件,默认为~/.ssh/known_hosts\nset_missing_host_key_policy(policy):设置连接的远程主机没有本地主机密钥时的策略。目前支持三种： RejectPolicy (the default), AutoAddPolicy, WarningPolicy\n上传与下载文件\n#上传批量文件到远程主机\nimport paramiko\nimport os\nimport datetime\n \nhostname = '74.63.229.*'\nusername = 'root'\npassword = 'abc123'\nport = 22\nlocal_dir = '/tmp/'\nremote_dir = '/tmp/test/'\nif __name__ == \"__main__\":\n    #    try:\n    t = paramiko.Transport((hostname, port))\n    t.connect(username=username, password=password)\n    sftp = paramiko.SFTPClient.from_transport(t)\n    #        files=sftp.listdir(dir_path)\n    files = os.listdir(local_dir)\n    for f in files:\n        '#########################################'\n        'Beginning to upload file %s ' % datetime.datetime.now()\n        'Uploading file:', os.path.join(local_dir, f)\n        # sftp.get(os.path.join(dir_path,f),os.path.join(local_path,f))\n        sftp.put(os.path.join(local_dir, f), os.path.join(remote_dir, f))\n        'Upload file success %s ' % datetime.datetime.now()\n    t.close()\n\n参考http://www.cnblogs.com/yangsh...\nFabric\nFabric是基于paramiko的基础上做了一层更高的封装，操作起来更加方便。官网：http://www.fabfile.org/index....github:https://github.com/fabric/fab...\n依赖crypto，paramiko.注意：fabric目前不支持Python3.不过github上有个支持py3的版本https://github.com/mathiasert...\n在windows上的安装：1、安装pycrypto.有几种方式安装：A.win7下安装 MSVC2010,然后通过pip install pycrypto编译安装.\nB.选择别人编译好的。pycrypto-for-python-3-2及以下pycrypto-for-python-3-4\n2、支持Python3的版本安装：pip install Fabric3\nfabfile.py\nfrom fabric.api import run\ndef host_type():\n    run('uname -s')\n\n通过fab命令执行。-f指定文件，-H指定主机列表.\n$ fab -f fabfile.py -H localhost,linuxbox host_type\n\nfab参数说明：-f 指定入口3文件-g 指定网关设备(中转，堡垒机)IP-H 指定目标主机，多个用“,”分割-P 异步运行多主机任务-R 指定角色，以角色来区分机组-t 设备连接超时时间，秒-T 远程主机命令执行超时时间，秒-w 当命令执行失败，发出警告，而不是终止任务。当然我们完全可以在代码中设定这些选项值，而无需在命令行指定。如下：全局属性设定env对象的作用是定义fabfile的全局设定，支持多个属性及自定义属性。\nenv.hosts,定义目标主机，列表env.exclude_hosts,排除主机，列表env.user,定义用户名,strenv.port , 定义端口，strenv.password,定义密码，strenv.passwords,字典，但是形式如下：env.passwords={ 'root@192.168.1.21:22':'123456','root@192.168.2.21:22':'1234'}env.key_filename=None 指定SSH密钥文件,str or listenv.gateway指定网关设备(中转，堡垒机)IP,strenv.roledefs定义角色分组，字典：env.roledefs={ 'web':['192.168.1.21','192.168.1.23'],'db':['192.168.1.22','192.168.1.24']}env.parallel=False是否并发执行任务env.path=' ' 定义在run/sudo/local使用的$PATH环境变量env.command_timeout=Noneenv.timeout=10env.shell=“/bin/bash -l -c”env.ssh_config_path=“$HOME/.ssh/config”env.sudo_password=Noneenv.sudo_passwords={}env.use_ssh_config=Falseenv.warn_only=False,如果为True,当操作遇到错误时，发出警告并继续执行，而不是终止env.变量名 自定义变量\n例如：\n@roles('web')\ndef webtask():\n    run('/etc/init.d/nginx start')\n@roles('db')\ndef dbtask():\n    run('/etc/init.d/mysql start')\n \n@roles('web','db')\ndef publicstask():\n    run('uptime')\ndef deploy():\n    execute(webtask)\n    execute(dbtask)\n    execute(publictask)\n\n然后终端执行命令就可以了\n$ fab deploy\n命令行传参：\ndef hello(name=\"world\"):\n    print(\"Hello %s!\" % name)\n$ fab hello:name=Jeff\nHello Jeff!\nDone.\n\n常用API\nfabric.api模块:\nlocal,执行本地命令,如local('uname -s')lcd,切换本地目录,如lcd('/home')cd,切换远程目录run,执行远程命令sudo,sudo方式执行远程命令put,上传文件到远程主机 put('/home/aaa','/home/xby/aaa')get,从远程主机下载文件到本地 get('/opt/bbb','/home/bbb')prompt,获取用户输入confirm，获得提示信息确认,如confirm('Continue[Y/N]?')reboot,重启远程主机，如reboot()@task函数装饰器，标识函数为fab可调用的，否则对fab不可见@runs_once,标识函数只会执行一次，不受多台主机影响。@roles,表示函数执行时的主机角色@parallel(pool_size=)@with_settings()\nfabric.contrib.console.confirm(question, default=True) 用户输入Y/n,返回True/False\n示例1：查看本地与远程主机信息：\nfrom fabric.api import *\n \nenv.user='root'\nenv.hosts=['192.168.1.2','192.168.1.3']\nenv.password='123'\n \n@runs_once #即使有多台主机，但它只会执行一次\ndef local_task():\n    local('uname -a')\ndef remote_task():\n    with cd(\"/data/logs\"): #这个with的作用是让后面的表达式语句继承当前的状态，实现\"cd /data/logs && ls -l\"的效果。\n        run(\"ls -l\")\n$ fab -f sample.py local_task\n$ fab -f sample.py remote_task\n\n示例2：动态获取远程目录\nfrom fabric.api import *\nfrom fabric.contrib.console import confirm\n \nenv.user='root'\nenv.hosts=['192.168.1.2','192.168.1.3']\nenv.password='123'\n \n@runs_once\ndef input_raw():\n    return prompt(\"please input dir name:\",default='/home')\ndef worktask(dirname):\n    run(\"ls -l \"+dirname)\n@task\ndef go():\n    dirname=input_raw()\n    worktask(dirname)\n\n示例3：网关模式文件上传与执行\n其实只要定义好env.gateway的ip就行了。相比paramiko确实简化了不少。\nfrom fabric.api import *\nfrom fabric.contrib.console import confirm\nfrom fabric.context_managers import *\n \nenv.user='root'\nenv.hosts=['192.168.1.2','192.168.1.3']\nenv.password='123'\nenv.gateway='192.168.22.2'\n \nlpath='/home/install/lnmp.tar.gz'\nrpath='/tmp/install'\n \n@task\ndef put_task():\n      run(\"mkdir -p /tmp/install\")\n      with settings(warn_only=True): #put出现异常时，发出警告，继续执行，不要终止。\n        result=put(lpath,rpath) #上传\n       if result.failed and not confirm(\"put failed,continue[Y/N]?\"):\n        abort(\"Aborting\")\n@task \ndef run_task():\n      with cd(\"/tmp/install\"):\n         run(\"tar -zxvf lnmp.tar.gz\")\n       with cd(\"lnmp\"):\n        run(\"./install.sh\")\n \n@task go():\n  put_task()\n  run_task()\n\n多彩输出\nfabric.colors.blue(text, bold=False)fabric.colors.cyan(text, bold=False)fabric.colors.green(text, bold=False)fabric.colors.magenta(text, bold=False)fabric.colors.red(text, bold=False)fabric.colors.white(text, bold=False)fabric.colors.yellow(text, bold=False)\nfrom fabric.colors import red, green\nprint(red(\"This sentence is red, except for \" + green(\"these words, which are green\") + \".\"))\n\n示例-Fabric部署Flask应用\n示例1：它可以把当前的源代码上传至服务器，并安装到一个预先存在 的 virtual 环境:\nfrom fabric.api import *\n# 使用远程命令的用户名\nenv.user = 'appuser'\n# 执行命令的服务器\nenv.hosts = ['server1.example.com', 'server2.example.com']\ndef pack():\n    # 创建一个新的分发源，格式为 tar 压缩包\n    local('python setup.py sdist --formats=gztar', capture=False)\ndef deploy():\n    # 定义分发版本的名称和版本号\n    dist = local('python setup.py --fullname', capture=True).strip()\n    # 把 tar 压缩包格式的源代码上传到服务器的临时文件夹\n    put('dist/%s.tar.gz' % dist, '/tmp/yourapplication.tar.gz')\n    # 创建一个用于解压缩的文件夹，并进入该文件夹\n    run('mkdir /tmp/yourapplication')\n    with cd('/tmp/yourapplication'):\n        run('tar xzf /tmp/yourapplication.tar.gz')\n        # 现在使用 virtual 环境的 Python 解释器来安装包\n        run('/var/www/yourapplication/env/bin/python setup.py install')\n    # 安装完成，删除文件夹\n    run('rm -rf /tmp/yourapplication /tmp/yourapplication.tar.gz')\n    # 最后 touch .wsgi 文件，让 mod_wsgi 触发应用重载\n    run('touch /var/www/yourapplication.wsgi')\n\n参考：<<Python自动化运维>>\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "10"}