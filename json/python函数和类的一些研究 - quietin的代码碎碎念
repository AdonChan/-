{"title": "python函数和类的一些研究 - quietin的代码碎碎念 ", "index": "python", "content": "bound与unbound\n通常认为实例方法是bound的，而类方法是unbound的，这种说法也没错，只是对于不同类型变量来说，结果是不同的\nclass A(object):\n    \"\"\"test class\"\"\"\n    _instance = None\n    \n    def __private(self):\n        pass\n\n    def _protect(self):\n        pass\n\n    def fs(self):\n        pass\n\n    @staticmethod\n    def sm():\n        pass\n\n    @classmethod\n    def fc(cls):\n        pass\n测试一下, 结果显示的都是bound method\n>>> a = A()\n>>> a.fs\n<bound method A.fs of <__main__.A object at 0x101fa3250>>\n>>> a.fc\n<bound method type.fc of <class '__main__.A'>>\n直接从类访问，结果fs这个实例方法显示的是unbound。可以知道bound的意义并不是始终不变的，对于不同的对象来说意义并不一样。\n>>> A.fs\n<unbound method A.fs>\n>>> A.fc\n<bound method type.fc of <class '__main__.A'>>\npython里面类方法和实例方法可以等价变换\na.fs()\n# equals\nA.fs(a)\n从描述器的角度看\n>>> A.__dict__['fs'].__get__(None, A)\n<unbound method A.fs>\n\n>>> A.__dict__['fs'].__get__(a, A)\n<bound method A.fs of <__main__.A object at 0x101fa3250>>\n\n>>> A.__dict__['fc'].__get__(None, A)\n<bound method type.fc of <class '__main__.A'>>\n不过实例a调用静态方法会出错(TypeError），因为实例对方法的调用提供了self参数，但sm是没有参数的。但是这提供了另一种思路）比如在python的多进程编程中，进程跑的函数如果是实例函数的会因为无法序列化而失败，但如果是staticmethod就没有问题，静态函数的本质其实也就是普通函数。所以可以这样\nclass B(object):\n    @staticmethod\n    def run(inst):\n        inst.foo()\n    \n    def foo(self):\n        print 'foo'\n\nb = B()\nB.run(b)\n在2.x中区分实例函数和类函数可以用im_self\n>>> A.fs.im_self\nNone\n>>> A.fc.im_self\n<class '__main__.A'>\n至于通过实例引用方法时的im_self的值，大家自己可以探索下\n获取类中所有定义的方法\n使用dir函数\n>>> dir(A)\n['_A__private',\n '__class__',\n '__delattr__',\n '__dict__',\n '__doc__',\n '__format__',\n '__getattribute__',\n '__hash__',\n '__init__',\n '__module__',\n '__new__',\n '__reduce__',\n '__reduce_ex__',\n '__repr__',\n '__setattr__',\n '__sizeof__',\n '__str__',\n '__subclasshook__',\n '__weakref__',\n '_instance',\n '_protect',\n 'fc',\n 'fs',\n 'sm']\n2  使用inspect.getmembers这个除了函数名的字符串以外，连对象的type也得到了，结果更加详细\n>>> inspect.getmembers(A)\n[('_A__private', <unbound method A.__private>),\n ('__class__', type),\n ('__delattr__', <slot wrapper '__delattr__' of 'object' objects>),\n ('__dict__',\n  <dictproxy {'_A__private': <function __main__.__private>,\n   '__dict__': <attribute '__dict__' of 'A' objects>,\n   '__doc__': 'test class',\n   '__module__': '__main__',\n   '__weakref__': <attribute '__weakref__' of 'A' objects>,\n   '_instance': None,\n   '_protect': <function __main__._protect>,\n   'fc': <classmethod at 0x1022a50f8>,\n   'fs': <function __main__.fs>,\n   'sm': <staticmethod at 0x1022a5088>}>),\n ('__doc__', 'test class'),\n ('__format__', <method '__format__' of 'object' objects>),\n ('__getattribute__', <slot wrapper '__getattribute__' of 'object' objects>),\n ('__hash__', <slot wrapper '__hash__' of 'object' objects>),\n ('__init__', <slot wrapper '__init__' of 'object' objects>),\n ('__module__', '__main__'),\n ('__new__', <function __new__>),\n ('__reduce__', <method '__reduce__' of 'object' objects>),\n ('__reduce_ex__', <method '__reduce_ex__' of 'object' objects>),\n ('__repr__', <slot wrapper '__repr__' of 'object' objects>),\n ('__setattr__', <slot wrapper '__setattr__' of 'object' objects>),\n ('__sizeof__', <method '__sizeof__' of 'object' objects>),\n ('__str__', <slot wrapper '__str__' of 'object' objects>),\n ('__subclasshook__', <function __subclasshook__>),\n ('__weakref__', <attribute '__weakref__' of 'A' objects>),\n ('_instance', None),\n ('_protect', <unbound method A._protect>),\n ('fc', <bound method type.fc of <class '__main__.A'>>),\n ('fs', <unbound method A.fs>),\n ('sm', <function __main__.sm>)]\n判断某个属性是否可调用\na = A()\ncallable(getattr(a, 'testattr', None))\n获得一个对象中所有可调用的方法\n[method for method in dir(object) if callable(getattr(object, method))]\n隐藏属性\n重写__dict__或者__dir__\nclass C(object):\n    __dict__ = {}\n    \n    def __dir__(self):\n        return ['cherry']\n注意，这里的__dict__不是类的，是实例的，类的__dict__是不可写的，不信可以试试__dir__很奇怪，如果dir函数用在C的实例上，确实会返回['cherry']，但dir(C)还是能得到类中所有属性，有点掩耳盗铃的感觉，待继续研究\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "10"}