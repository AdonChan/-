{"title": "requests-html快速入门 - 太不白的学习频道 ", "index": "python,web,网页爬虫", "content": "Python上有一个非常著名的HTTP库——requests，相比大家都听说过，用过的人都说好！现在requests库的作者又发布了一个新库，叫做requests-html，看名字也能猜出来，这是一个解析HTML的库，而且用起来和requests一样爽，下面就来介绍一下它。\n安装\n安装requests-html非常简单，一行命令即可做到。需要注意一点就是，requests-html只支持Python 3.6及更新的版本，所以使用老版本的Python的同学需要更新一下Python版本了。看了下源代码，因为requests-html广泛使用了一个Python 3.6中的新特性——类型注解。\npip install requests-html\n基本使用\n获取网页\nrequests-html和其他解析HTML库最大的不同点在于HTML解析库一般都是专用的，所以我们需要用另一个HTTP库先把网页下载下来，然后传给那些HTML解析库。而requests-html自带了这个功能，所以在爬取网页等方面非常方便。\n下面的代码获取了糗事百科上面的文字段子页面，返回的对象r是requests.Reponse类型，更确切的说是继承自前者的requests_html.HTMLResponse类型。这里其实和requests库的使用方法差不多，获取到的响应对象其实其实也没啥用，这里的关键就在于r.html这个属性，它会返回requests_html.HTML这个类型，它是整个requests_html库中最核心的一个类，负责对HTML进行解析。我们学习requests_html这个库，其实也就是学习这个HTML类的使用方法。\nfrom requests_html import HTMLSession\n\nsession = HTMLSession()\nr = session.get('https://www.qiushibaike.com/text/')\n// 查看页面内容\nprint(r.html.html)\n获取链接\nlinks和absolute_links两个属性分别返回HTML对象所包含的所有链接和绝对链接（均不包含锚点）。\n# 获取链接\nprint(r.html.links)\nprint(r.html.absolute_links)\n结果为下（因为结果太长，所以我随便取了一点，看个意思就行）：\n{'/article/104353012', '/article/120616112', '/users/32331196/'}\n{'https://www.qiushibaike.com/imgrank/', 'https://www.qiushibaike.com/article/120669516', 'https://www.qiushibaike.com/article/120682041'}\n获取元素\nrequest-html支持CSS选择器和XPATH两种语法来选取HTML元素。首先先来看看CSS选择器语法，它需要使用HTML的find函数，该函数有5个参数，作用如下：\n\nselector，要用的CSS选择器；\nclean，布尔值，如果为真会忽略HTML中style和script标签造成的影响（原文是sanitize，大概这么理解）;\ncontaining，如果设置该属性，会返回包含该属性文本的标签；\nfirst，布尔值，如果为真会返回第一个元素，否则会返回满足条件的元素列表；\n_encoding，编码格式。\n\n下面是几个简单例子：\n# 首页菜单文本\nprint(r.html.find('div#menu', first=True).text)\n# 首页菜单元素\nprint(r.html.find('div#menu a'))\n# 段子内容\nprint(list(map(lambda x: x.text, r.html.find('div.content span'))))\n结果如下，因为段子太多，所以随便选了两个：\n热门 24小时 热图 文字 穿越 糗图 新鲜\n[<Element 'a' href='/' rel=('nofollow',)>, <Element 'a' href='/hot/'>, <Element 'a' href='/imgrank/'>, <Element 'a' id='highlight' href='/text/'>, <Element 'a' href='/history/'>, <Element 'a' href='/pic/'>, <Element 'a' href='/textnew/'>]\n['有一次，几位大城市的朋友来家里玩，我招待他们吃风干羊肉做臊子的饸饹面，这是我们老家最具特色的美食！饭快熟的时候，老婆让我在园子里摘点“芫荽 ”，朋友问我，“芫荽”是什么东东？我给他们翻译解释说：我们本地土话叫“芫荽”，你们城里人讲普通话叫香菜，他们还大笑了一场。\\n前天下雨没事儿干，翻看新华字典，突然发现“芫荽”才是香菜的学名，Tm香菜才是土话！而且我们地方方言就这两个字发音还特别标准！', '昨天晚上跟老婆吵架，他抓起我的手机就摔了。我立马摔了他的，结果我的还能用，他的坏了。高潮是人家立刻出门买了个新的！我艹，是不是中计了？？', '小姨要去高铁站，我看着大大小小的箱子说：坐公交车要转车，转来转去要一个多小时，太不方便了，不如我开车送你吧。\\n小姨迟疑了一下，同意了。\\n我准时把小姨送到了高铁站，正好赶上检票。\\n小姨高兴地说：自己开车就是方便，不过幸好你妈聪明，让我们提前两个多小时就出发了！'\n然后是XPATH语法，这需要另一个函数xpath的支持，它有4个参数如下：\n\nselector，要用的XPATH选择器；\nclean，布尔值，如果为真会忽略HTML中style和script标签造成的影响（原文是sanitize，大概这么理解）;\nfirst，布尔值，如果为真会返回第一个元素，否则会返回满足条件的元素列表；\n_encoding，编码格式。\n\n还是上面的例子，不过这次使用XPATH语法：\nprint(r.html.xpath(\"//div[@id='menu']\", first=True).text)\nprint(r.html.xpath(\"//div[@id='menu']/a\"))\nprint(r.html.xpath(\"//div[@class='content']/span/text()\"))\n输出和上面那个几乎一样，之所以说是“几乎”，因为第三个输出会多出几个换行符，不知道什么原因。需要注意的一点是如果XPATH中包含text()或@href这样的子属性，那么结果相应的会变成简单的字符串类型，而不是HTML元素。\n['\\n\\n\\n我一份文件忘家里了，又懒得回家取，就给小姨子发短信息:   帮我把文件送来，晚上我谢谢你。等半天也没送来文件，我只好打个车回家自己拿，到家一进屋，我就发现气氛不对劲，老婆铁青着脸，两手掐着腰，小姨子站旁边对我怒目而视。']\n元素内容\n糗事百科首页LOGO的HTML代码如下所示：\n<div class=\"logo\" id=\"hd_logo\">\n<a href=\"/\"><h1>糗事百科</h1></a>\n</div>\n我们来选取这个元素：\ne = r.html.find(\"div#hd_logo\", first=True)\n要获取元素的文本内容，用text属性：\nprint(e.text)\n# 糗事百科\n要获取元素的attribute，用attr属性：\nprint(e.attrs)\n# {'class': ('logo',), 'id': 'hd_logo'}\n要获取元素的HTML代码，用html属性：\nprint(e.html)\n# <div class=\"logo\" id=\"hd_logo\">\n# <a href=\"/\"><h1>糗事百科</h1></a>\n# </div>\n要搜索元素的文本内容，用search函数，比如说我们现在想知道是糗事什么科：\nprint(e.search(\"糗事{}科\")[0])\n# 百\n最后还有前面提到的两个链接属性：\nprint(e.absolute_links)\nprint(e.links)\n# {'https://www.qiushibaike.com/'}\n# {'/'}\n进阶用法\n这一部分我懒得找例子了，所以用官网上的例子。\nJavaScript支持\n有些网站是使用JavaScript渲染的，这样的网站爬取到的结果只有一堆JS代码，这样的网站requests-html也可以处理，关键一步就是在HTML结果上调用一下render函数，它会在用户目录（默认是~/.pyppeteer/）中下载一个chromium，然后用它来执行JS代码。下载过程只在第一次执行，以后就可以直接使用chromium来执行了。唯一缺点就是chromium下载实在太太太太太太慢了，没有科学上网的同学可能无法使用该功能了。\n>>> r = session.get('http://python-requests.org/')\n\n>>> r.html.render()\n[W:pyppeteer.chromium_downloader] start chromium download.\nDownload may take a few minutes.\n[W:pyppeteer.chromium_downloader] chromium download done.\n[W:pyppeteer.chromium_downloader] chromium extracted to: C:\\Users\\xxxx\\.pyppeteer\\local-chromium\\571375\n>>> r.html.search('Python 2 will retire in only {months} months!')['months']\n'<time>25</time>'\nrender函数还有一些参数，顺便介绍一下（这些参数有的还有默认值，直接看源代码方法参数列表即可）：\n\nretries: 加载页面失败的次数\nscript: 页面上需要执行的JS脚本（可选）\nwait: 加载页面钱的等待时间（秒），防止超时（可选）\nscrolldown: 页面向下滚动的次数\nsleep: 在页面初次渲染之后的等待时间\nreload: 如果为假，那么页面不会从浏览器中加载，而是从内存中加载\nkeep_page: 如果为真，允许你用r.html.page访问页面\n\n比如说简书的用户页面上用户的文章列表就是一个异步加载的例子，初始只显示最近几篇文章，如果想爬取所有文章，就需要使用scrolldown配合sleep参数模拟下滑页面，促使JS代码加载所有文章。\n智能分页\n有些网站会分页显示内容，例如reddit。\n>>> r = session.get('https://reddit.com')\n>>> for html in r.html:\n...     print(html)\n<HTML url='https://www.reddit.com/'>\n<HTML url='https://www.reddit.com/?count=25&after=t3_81puu5'>\n<HTML url='https://www.reddit.com/?count=50&after=t3_81nevg'>\n<HTML url='https://www.reddit.com/?count=75&after=t3_81lqtp'>\n<HTML url='https://www.reddit.com/?count=100&after=t3_81k1c8'>\n<HTML url='https://www.reddit.com/?count=125&after=t3_81p438'>\n<HTML url='https://www.reddit.com/?count=150&after=t3_81nrcd'>\n…\n这样的话，请求下一个网页就很容易了。\n>>> r = session.get('https://reddit.com')\n>>> r.html.next()\n'https://www.reddit.com/?count=25&after=t3_81pm82'\n直接使用HTML\n前面介绍的都是通过网络请求HTML内容，其实requests-html当然可以直接使用，只需要直接构造HTML对象即可：\n>>> from requests_html import HTML\n>>> doc = \"\"\"<a href='https://httpbin.org'>\"\"\"\n\n>>> html = HTML(html=doc)\n>>> html.links\n{'https://httpbin.org'}\n直接渲染JS代码也可以：\n# 和上面一段代码接起来\n>>> script = \"\"\"\n        () => {\n            return {\n                width: document.documentElement.clientWidth,\n                height: document.documentElement.clientHeight,\n                deviceScaleFactor: window.devicePixelRatio,\n            }\n        }\n    \"\"\"\n>>> val = html.render(script=script, reload=False)\n\n>>> print(val)\n{'width': 800, 'height': 600, 'deviceScaleFactor': 1}\n\n>>> print(html.html)\n<html><head></head><body><a href=\"https://httpbin.org\"></a></body></html>\n自定义请求\n前面都是简单的用GET方法获取请求，如果需要登录等比较复杂的过程，就不能用get方法了。HTMLSession类包含了丰富的方法，可以帮助我们完成需求。下面介绍一下这些方法。\n自定义用户代理\n有些网站会使用UA来识别客户端类型，有时候需要伪造UA来实现某些操作。如果查看文档的话会发现HTMLSession上的很多请求方法都有一个额外的参数**kwargs，这个参数用来向底层的请求传递额外参数。我们先向网站发送一个请求，看看返回的网站信息。\nfrom pprint import pprint\nr = session.get('http://httpbin.org/get')\npprint(json.loads(r.html.html))\n返回的结果如下：\n{'args': {},\n 'headers': {'Accept': '*/*',\n             'Accept-Encoding': 'gzip, deflate',\n             'Connection': 'close',\n             'Host': 'httpbin.org',\n             'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) '\n                           'AppleWebKit/603.3.8 (KHTML, like Gecko) '\n                           'Version/10.1.2 Safari/603.3.8'},\n 'origin': '110.18.237.233',\n 'url': 'http://httpbin.org/get'}\n可以看到UA是requests-html自带的UA，下面换一个UA：\nua = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:62.0) Gecko/20100101 Firefox/62.0'\nr = session.get('http://httpbin.org/get', headers={'user-agent': ua})\npprint(json.loads(r.html.html))\n可以看到UA确实发生了变化：\n{'args': {},\n 'headers': {'Accept': '*/*',\n             'Accept-Encoding': 'gzip, deflate',\n             'Connection': 'close',\n             'Host': 'httpbin.org',\n             'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:62.0) '\n                           'Gecko/20100101 Firefox/62.0'},\n 'origin': '110.18.237.233',\n 'url': 'http://httpbin.org/get'}\n当然这里仅仅是换了一个UA，如果你有需要可以在header中修改其他参数。\n模拟表单登录\nHTMLSession带了一整套的HTTP方法，包括get、post、delete等，对应HTTP中各个方法。比如下面我们就来模拟一下表单登录：\n# 表单登录\nr = session.post('http://httpbin.org/post', data={'username': 'yitian', 'passwd': 123456})\npprint(json.loads(r.html.html))\n结果如下，可以看到forms中确实收到了提交的表单值：\n{'args': {},\n 'data': '',\n 'files': {},\n 'form': {'passwd': '123456', 'username': 'yitian'},\n 'headers': {'Accept': '*/*',\n             'Accept-Encoding': 'gzip, deflate',\n             'Connection': 'close',\n             'Content-Length': '29',\n             'Content-Type': 'application/x-www-form-urlencoded',\n             'Host': 'httpbin.org',\n             'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) '\n                           'AppleWebKit/603.3.8 (KHTML, like Gecko) '\n                           'Version/10.1.2 Safari/603.3.8'},\n 'json': None,\n 'origin': '110.18.237.233',\n 'url': 'http://httpbin.org/post'}\n如果有上传文件的需要，做法也是类似的。如果了解过requests库的同学可能对这里的做法比较熟悉，没有错，这其实就是requests的用法。requests-html通过暴露**kwargs的方法，让我们可以对请求进行定制，将额外参数直接传递给底层的requests方法。所以如果有什么疑问的话，直接去看requests文档就好了。\n爬虫例子\n文章写完了感觉有点空洞，所以补充了几个小例子。不得不说requests-html用起来还是挺爽的，一些小爬虫例子用scrapy感觉有点大材小用，用requests和BeautifulSoup又感觉有点啰嗦，requests-html的出现正好弥补了这个空白。大家学习一下这个库，好处还是很多的。\n爬取简书用户文章\n简书用户页面的文章列表就是一个典型的异步加载例子，用requests-html的话可以轻松搞定，如下所示，仅仅5行代码。\nr = session.get('https://www.jianshu.com/u/7753478e1554')\nr.html.render(scrolldown=50, sleep=.2)\ntitles = r.html.find('a.title')\nfor i, title in enumerate(titles):\n    print(f'{i+1} [{title.text}](https://www.jianshu.com{title.attrs[\"href\"]})')\n当然这个例子还有所不足，就是通用性稍差，因为文章列表没有分页机制，需要一直往下拉页面，考虑到不同的用户文章数不同，需要先获取用户总文章数，然后在计算一下应该下滑页面多少次，这样才能取得较好的效果。这里仅仅简单获取一些我自己的文章，就不往复杂写了。\n爬取天涯论坛\n以前经常在天涯论坛上追一些帖子，现在正好写一个爬虫，把连载的好帖子一次性爬下来弄成一个文件。\n# 爬取天涯论坛帖子\nurl = 'http://bbs.tianya.cn/post-culture-488321-1.shtml'\nr = session.get(url)\n# 楼主名字\nauthor = r.html.find('div.atl-info span a', first=True).text\n# 总页数\ndiv = r.html.find('div.atl-pages', first=True)\nlinks = div.find('a')\ntotal_page = 1 if links == [] else int(links[-2].text)\n# 标题\ntitle = r.html.find('span.s_title span', first=True).text\n\nwith io.open(f'{title}.txt', 'x', encoding='utf-8') as f:\n    for i in range(1, total_page + 1):\n        s = url.rfind('-')\n        r = session.get(url[:s + 1] + str(i) + '.shtml')\n        # 从剩下的里面找楼主的帖子\n        items = r.html.find(f'div.atl-item[_host={author}]')\n        for item in items:\n            content: str = item.find('div.bbs-content', first=True).text\n            # 去掉回复\n            if not content.startswith('@'):\n                f.write(content + \"\\n\")\n爬完之后，看了一下，700多k的文件，效果不错。\n\n                ", "mainLikeNum": ["19 "], "mainBookmarkNum": "19"}