{"title": "像老大一样优化 Python - SegmentFault 业界资讯 ", "index": "性能优化,优化,python", "content": "\n  我们应该忘掉一些小的效率问题，在 97% 的情况下是这么说的：过早优化是万恶之源。—— Donald Knuth\n\n\n如果不首先想想这句Knuth的名言，就开始进行优化工作是不明智的。可是，你很快写出来加入一些特性的代码，可能会很丑陋，你需要注意了。这篇文章就是为这时候准备的。\n\n那么接下来就是一些很有用的工具和模式来快速优化Python。它的主要目的很简单：尽快发现瓶颈，修复它们并且确认你修复了它们。\n\n写一个测试\n\n在你开始优化前，写一个高级测试来证明原来代码很慢。你可能需要采用一些最小值数据集来复现它足够慢。通常一两个显示运行时秒的程序就足够处理一些改进的地方了。\n\n有一些基础测试来保证你的优化没有改变原有代码的行为也是很必要的。你也能够在很多次运行测试来优化代码的时候稍微修改这些测试的基准。\n\n那么现在，我们来来看看优化工具把。\n\n简单的计时器\n\n计时器很简单，这是一个最灵活的记录执行时间的方法。你可以把它放到任何地方并且副作用很小。运行你自己的计时器非常简单，并且你可以将其定制，使它以你期望的方式工作。例如，你个简单的计时器如下：\n\nimport time\n\ndef timefunc(f):\n    def f_timer(*args, **kwargs):\n        start = time.time()\n        result = f(*args, **kwargs)\n        end = time.time()\n        print f.__name__, 'took', end - start, 'time'\n        return result\n    return f_timer\n\ndef get_number():\n    for x in xrange(5000000):\n        yield x\n\n@timefunc\ndef expensive_function():\n    for x in get_number():\n        i = x ^ x ^ x\n    return 'some result!'\n\n# prints \"expensive_function took 0.72583088875 seconds\"\nresult = expensive_function()\n\n\n当然，你可以用上下文管理来让它功能更加强大，添加一些检查点或者一些其他的功能：\n\nimport time\n\nclass timewith():\n    def __init__(self, name=''):\n        self.name = name\n        self.start = time.time()\n\n    @property\n    def elapsed(self):\n        return time.time() - self.start\n\n    def checkpoint(self, name=''):\n        print '{timer} {checkpoint} took {elapsed} seconds'.format(\n            timer=self.name,\n            checkpoint=name,\n            elapsed=self.elapsed,\n        ).strip()\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, type, value, traceback):\n        self.checkpoint('finished')\n        pass\n\ndef get_number():\n    for x in xrange(5000000):\n        yield x\n\ndef expensive_function():\n    for x in get_number():\n        i = x ^ x ^ x\n    return 'some result!'\n\n# prints something like:\n# fancy thing done with something took 0.582462072372 seconds\n# fancy thing done with something else took 1.75355315208 seconds\n# fancy thing finished took 1.7535982132 seconds\nwith timewith('fancy thing') as timer:\n    expensive_function()\n    timer.checkpoint('done with something')\n    expensive_function()\n    expensive_function()\n    timer.checkpoint('done with something else')\n\n# or directly\ntimer = timewith('fancy thing')\nexpensive_function()\ntimer.checkpoint('done with something')\n\n\n计时器还需要你做一些挖掘。包装一些更高级的函数，并且确定瓶颈在哪，然后深入的函数里，能够不停的重现。当你发现一些不合适的代码，修复它，然后测试一遍以确认它被修复了。\n\n一些小技巧：不要忘了好用的timeit模块！它对小块代码做基准测试而不是实际调查更加有用。\n\n\nTimer 优点：很容易理解和实现。也非常容易在修改后进行比较。对于很多语言都适用。\nTimer 缺点：有时候对于非常复杂的代码有点过于简单，你可能会花更多时间放置或移动引用代码而不是修复问题！\n\n\n内建优化器\n\n启用内建的优化器就像是用一门大炮。它非常强大，但是有点不太好用，使用和解释起来比较复杂。\n\n你可以了解更多关于profile模块的东西，但是它的基础是非常简单的：你能够启用和禁用优化器，而且它能打印所有的函数调用和执行时间。它能给你编译和打印出输出。一个简单的装饰器如下：\n\nimport cProfile\n\ndef do_cprofile(func):\n    def profiled_func(*args, **kwargs):\n        profile = cProfile.Profile()\n        try:\n            profile.enable()\n            result = func(*args, **kwargs)\n            profile.disable()\n            return result\n        finally:\n            profile.print_stats()\n    return profiled_func\n\ndef get_number():\n    for x in xrange(5000000):\n        yield x\n\n@do_cprofile\ndef expensive_function():\n    for x in get_number():\n        i = x ^ x ^ x\n    return 'some result!'\n\n# perform profiling\nresult = expensive_function()\n\n\n在上面代码的情况下，你应该看到有些东西在终端打印出来，打印的内容如下：\n\n5000003 function calls in 1.626 seconds\n\n   Ordered by: standard name\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n  5000001    0.571    0.000    0.571    0.000 timers.py:92(get_number)\n        1    1.055    1.055    1.626    1.626 timers.py:96(expensive_function)\n        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}\n\n\n你可以看到，它给出了不同函数的调用次数，但它遗漏了一些关键的信息：是哪个函数让运行这么慢？\n\n可是，这对于基础优化来说是个好的开始。有时候甚至能用更少的精力找到解决方案。我经常用它来在深入挖掘究竟是哪个函数慢或者调用次数过多之前来调试程序。\n\n内建优点：没有额外的依赖并且非常快。对于快速的高等级检查非常有用。\n内建缺点：信息相对有限，需要进一步的调试；报告有点不太直接，尤其是对于复杂的代码。\n\nLine Profiler\n\n如果内建的优化器是一门大炮，那么line profiler可以看作是一门离子加农炮。它非常的重量级和强大。\n\n在这个例子里，我们会用非常棒的line_profiler库。为了容易使用，我们会再次用装饰器包装一下，这种简单的方法也可以防止把它放在生产代码里。\n\ntry:\n    from line_profiler import LineProfiler\n\n    def do_profile(follow=[]):\n        def inner(func):\n            def profiled_func(*args, **kwargs):\n                try:\n                    profiler = LineProfiler()\n                    profiler.add_function(func)\n                    for f in follow:\n                        profiler.add_function(f)\n                    profiler.enable_by_count()\n                    return func(*args, **kwargs)\n                finally:\n                    profiler.print_stats()\n            return profiled_func\n        return inner\n\nexcept ImportError:\n    def do_profile(follow=[]):\n        \"Helpful if you accidentally leave in production!\"\n        def inner(func):\n            def nothing(*args, **kwargs):\n                return func(*args, **kwargs)\n            return nothing\n        return inner\n\ndef get_number():\n    for x in xrange(5000000):\n        yield x\n\n@do_profile(follow=[get_number])\ndef expensive_function():\n    for x in get_number():\n        i = x ^ x ^ x\n    return 'some result!'\n\nresult = expensive_function()\n\n\n如果你运行上面的代码，你就可以看到一下的报告：\n\nTimer unit: 1e-06 s\n\nFile: test.py\nFunction: get_number at line 43\nTotal time: 4.44195 s\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n    43                                           def get_number():\n    44   5000001      2223313      0.4     50.1      for x in xrange(5000000):\n    45   5000000      2218638      0.4     49.9          yield x\n\nFile: test.py\nFunction: expensive_function at line 47\nTotal time: 16.828 s\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n    47                                           def expensive_function():\n    48   5000001     14090530      2.8     83.7      for x in get_number():\n    49   5000000      2737480      0.5     16.3          i = x ^ x ^ x\n    50         1            0      0.0      0.0      return 'some result!'\n\n\n你可以看到，有一个非常详细的报告，能让你完全洞悉代码运行的情况。和内置的 cProfiler 不同，它能计算话在语言核心特性的时间，比如循环和导入并且给出在不同的行花费的时间。\n\n这些细节能让我们更容易理解函数内部。如果你在研究某个第三方库，你可以直接将其导入并加上装饰器来分析它。\n\n一些小技巧：只装饰你的测试函数并将问题函数作为接下来的参数。\n\n\nLine Profiler 优点：有非常直接和详细的报告。能够追踪第三方库里的函数。\nLine Profiler 缺点：因为它会让代码比真正运行时慢很多，所以不要用它来做基准测试。这是额外的需求。\n\n\n总结和最佳实践\n\n你应该用更简单的工具来对测试用例进行根本的检查，并且用更慢但能显示更多细节的line_profiler来深入到函数内部。\n\n九成情况下，你可能会发现在一个函数里循环调用或一个错误的数据结构消耗了90%的时间。一些调整工具是非常适合你的。\n\n如果你仍然觉得这太慢，而是用一些你自己的秘密武器，如比较属性访问技术或调整平衡检查技术。你也可以用如下的方法：\n\n1．忍受缓慢或者缓存它们\n\n2．重新思考整个实现\n\n3．更多使用优化的数据结构\n\n4．写一个C扩展\n\n注意了，优化代码是种罪恶的快感！用合适的方法来为你的Python代码加速很有意思，但是注意不要破坏了本身的逻辑。可读的代码比运行速度更重要。先把它缓存起来再进行优化其实更好。\n\n\n\n原文： Profiling Python Like a Boss\n转载翻译自： 伯乐在线 - 贱圣OMG\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "7"}