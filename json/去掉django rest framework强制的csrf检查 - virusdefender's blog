{"title": "去掉django rest framework强制的csrf检查 - virusdefender's blog ", "index": "django,python", "content": "近期的项目，前端的js是在localhost上跑的，然后向我们后端的开发服务器进行请求。但是突然前端说所有的post请求都报csrf校验错误了，甚是奇怪，之前为了开发方便已经把django的csrf middleware注释掉了啊，为什么还会错误，由于返回值格式还是django rest的通用格式，肯定问题是出在这里面，于是翻了一下它的源代码看了看。\n\nfrom django.middleware.csrf import CsrfViewMiddleware\n\nclass CSRFCheck(CsrfViewMiddleware):\n    def _reject(self, request, reason):\n        # Return the failure reason instead of an HttpResponse\n        return reason\n\nclass SessionAuthentication(BaseAuthentication):\n    \"\"\"\n    Use Django's session framework for authentication.\n    \"\"\"\n\n    def authenticate(self, request):\n        \"\"\"\n        Returns a `User` if the request session currently has a logged in user.\n        Otherwise returns `None`.\n        \"\"\"\n\n        # Get the underlying HttpRequest object\n        request = request._request\n        user = getattr(request, 'user', None)\n\n        # Unauthenticated, CSRF validation not required\n        if not user or not user.is_active:\n            return None\n\n        self.enforce_csrf(request)\n\n        # CSRF passed with authenticated user\n        return (user, None)\n\n    def enforce_csrf(self, request):\n        \"\"\"\n        Enforce CSRF validation for session based authentication.\n        \"\"\"\n        reason = CSRFCheck().process_view(request, None, (), {})\n        if reason:\n            # CSRF failed, bail with explicit error message\n            raise exceptions.PermissionDenied('CSRF Failed: %s' % reason)\n\n\n原来是这样，最近给系统增加了用户登陆功能，使用的就是SessionAuthorization和TokenAuthorization，然后在SessionAuthorization中调用了self.enforce_csrf(request)而这个调用的又是上面的CSRFCheck，这个类是重载了django里面的csrf middleware，而且没发现有地方可以关掉这个功能，即使在django里面去掉这个middleware，但是这个还是会调用的。\n\n那怎么去掉这个功能呢，我们现在就是要进行跨域请求。\n\n\n最简单了，直接注释掉上面的self.enforce_csrf(request)这一行代码就行了或者在设置中添加一项，比如改成\n\nGLOBAL_CSRF_CHECK = True\nif GLOBAL_CSRF_CHECK：\n    self.enforce_csrf(request)\n\n\n\n我们继续看源代码，到middleware的代码里面去。\n\nclass CsrfViewMiddleware(object):\n    \"\"\"\n    Middleware that requires a present and correct csrfmiddlewaretoken\n    for POST requests that have a CSRF cookie, and sets an outgoing\n    CSRF cookie.\n\n    This middleware should be used in conjunction with the csrf_token template\n    tag.\n    \"\"\"\n    # The _accept and _reject methods currently only exist for the sake of the\n    # requires_csrf_token decorator.\n    def _accept(self, request):\n        # Avoid checking the request twice by adding a custom attribute to\n        # request.  This will be relevant when both decorator and middleware\n        # are used.\n        request.csrf_processing_done = True\n        return None\n\n    def _reject(self, request, reason):\n        logger.warning('Forbidden (%s): %s',\n                       reason, request.path,\n            extra={\n                'status_code': 403,\n                'request': request,\n            }\n        )\n        return _get_failure_view()(request, reason=reason)\n\n    def process_view(self, request, callback, callback_args, callback_kwargs):\n\n        if getattr(request, 'csrf_processing_done', False):\n            return None\n\n        try:\n            csrf_token = _sanitize_token(\n                request.COOKIES[settings.CSRF_COOKIE_NAME])\n            # Use same token next time\n            request.META['CSRF_COOKIE'] = csrf_token\n        except KeyError:\n            csrf_token = None\n            # Generate token and store it in the request, so it's\n            # available to the view.\n            request.META[\"CSRF_COOKIE\"] = _get_new_csrf_key()\n\n        # Wait until request.META[\"CSRF_COOKIE\"] has been manipulated before\n        # bailing out, so that get_token still works\n        if getattr(callback, 'csrf_exempt', False):\n            return None\n\n        # Assume that anything not defined as 'safe' by RFC2616 needs protection\n        if request.method not in ('GET', 'HEAD', 'OPTIONS', 'TRACE'):\n            if getattr(request, '_dont_enforce_csrf_checks', False):\n                # Mechanism to turn off CSRF checks for test suite.\n                # It comes after the creation of CSRF cookies, so that\n                # everything else continues to work exactly the same\n                # (e.g. cookies are sent, etc.), but before any\n                # branches that call reject().\n                return self._accept(request)\n\n            if request.is_secure():\n                # Suppose user visits http://example.com/\n                # An active network attacker (man-in-the-middle, MITM) sends a\n                # POST form that targets https://example.com/detonate-bomb/ and\n                # submits it via JavaScript.\n                #\n                # The attacker will need to provide a CSRF cookie and token, but\n                # that's no problem for a MITM and the session-independent\n                # nonce we're using. So the MITM can circumvent the CSRF\n                # protection. This is true for any HTTP connection, but anyone\n                # using HTTPS expects better! For this reason, for\n                # https://example.com/ we need additional protection that treats\n                # http://example.com/ as completely untrusted. Under HTTPS,\n                # Barth et al. found that the Referer header is missing for\n                # same-domain requests in only about 0.2% of cases or less, so\n                # we can use strict Referer checking.\n                referer = request.META.get('HTTP_REFERER')\n                if referer is None:\n                    return self._reject(request, REASON_NO_REFERER)\n\n                # Note that request.get_host() includes the port.\n                good_referer = 'https://%s/' % request.get_host()\n                if not same_origin(referer, good_referer):\n                    reason = REASON_BAD_REFERER % (referer, good_referer)\n                    return self._reject(request, reason)\n\n            if csrf_token is None:\n                # No CSRF cookie. For POST requests, we insist on a CSRF cookie,\n                # and in this way we can avoid all CSRF attacks, including login\n                # CSRF.\n                return self._reject(request, REASON_NO_CSRF_COOKIE)\n\n            # Check non-cookie token for match.\n            request_csrf_token = \"\"\n            if request.method == \"POST\":\n                request_csrf_token = request.POST.get('csrfmiddlewaretoken', '')\n\n            if request_csrf_token == \"\":\n                # Fall back to X-CSRFToken, to make things easier for AJAX,\n                # and possible for PUT/DELETE.\n                request_csrf_token = request.META.get('HTTP_X_CSRFTOKEN', '')\n\n            if not constant_time_compare(request_csrf_token, csrf_token):\n                return self._reject(request, REASON_BAD_TOKEN)\n\n        return self._accept(request)\n\n    def process_response(self, request, response):\n        if getattr(response, 'csrf_processing_done', False):\n            return response\n\n        # If CSRF_COOKIE is unset, then CsrfViewMiddleware.process_view was\n        # never called, probaby because a request middleware returned a response\n        # (for example, contrib.auth redirecting to a login page).\n        if request.META.get(\"CSRF_COOKIE\") is None:\n            return response\n\n        if not request.META.get(\"CSRF_COOKIE_USED\", False):\n            return response\n\n        # Set the CSRF cookie even if it's already set, so we renew\n        # the expiry timer.\n        response.set_cookie(settings.CSRF_COOKIE_NAME,\n                            request.META[\"CSRF_COOKIE\"],\n                            max_age = 60 * 60 * 24 * 7 * 52,\n                            domain=settings.CSRF_COOKIE_DOMAIN,\n                            path=settings.CSRF_COOKIE_PATH,\n                            secure=settings.CSRF_COOKIE_SECURE,\n                            httponly=settings.CSRF_COOKIE_HTTPONLY\n                            )\n        # Content varies with the CSRF cookie, so set the Vary header.\n        patch_vary_headers(response, ('Cookie',))\n        response.csrf_processing_done = True\n        return response\n\n\n里面主要有两个函数，一个是process view，另一个是process response。这里就不得不说django middleware的工作原理了。\n\nhttps://docs.djangoproject.com/en/1.6/topics/http/middleware/\n\nprocess_request() is called on each request, before Django decides which view to execute.\n\nprocess_view() is called just before Django calls the view.\n\nprocess_response() is called on all responses before they’re returned to the browser.\n\n\n所以这个middleware的process view会在请求到达view函数之前被调用，可以理解为一个过滤器吧。\n\n if request.method not in ('GET', 'HEAD', 'OPTIONS', 'TRACE'):\n            if getattr(request, '_dont_enforce_csrf_checks', False):\n                return self._accept(request)\n\n\n这里request里面有_dont_enforce_csrf_checks就直接进入view了，没有下面的检查了。所以我们只要自己给request添加一个这样的属性就好了。最直接的方法还是去写一个middleware啊，哈哈。\n\n代码很简单\n\nclass DisableCSRFCheck(object):\n    def process_request(self, request):\n        setattr(request, '_dont_enforce_csrf_checks', True)\n\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "6"}