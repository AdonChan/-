{"title": "Python每日一练0022 - python每日练习 ", "index": "python3.x,python", "content": "问题\n你想在一个文件里每次读入固定大小的字节，比如每次读入4个字节并转成int，或者每次读入x个字节并进行结构化，例如：\nl = [5, 2, 4, 1, 2, 4, 5, 6, 8]\nwith open('test', 'wb') as fd:\n    for num in l:\n        fd.write(num.to_bytes(4, 'big'))\n解决方案\n可以简单的用while循环来完成\nwith open('test', 'rb') as fd:\n    r = fd.read(4)\n    while r:\n        print(int.from_bytes(r, 'big'), end=' ')\n        r = fd.read(4)\n输出为5 2 4 1 2 4 5 6 8\n但更优雅的做法是结合使用iter和functools.partial\nfrom functools import partial\nwith open('test', 'rb') as fd:\n    for r in iter(partial(fd.read, 4), b''):\n        print(int.from_bytes(r, 'big'), end=' ')\n输出同样是5 2 4 1 2 4 5 6 8 \n讨论\nfunctools.partial的作用是对一个函数进行包装（可以将一些参数的值固定）并生成一个新的签名，例如：\n>>> from functools import partial\n>>> basetwo = partial(int, base=2)\n>>> basetwo.__doc__ = 'Convert base 2 string to an int.'\n>>> basetwo('10010')\n18\nfunctools.partial的大致实现如下：\ndef partial(func, *args, **keywords):\n    def newfunc(*fargs, **fkeywords):\n        newkeywords = keywords.copy()\n        newkeywords.update(fkeywords)\n        return func(*args, *fargs, **newkeywords)\n    newfunc.func = func\n    newfunc.args = args\n    newfunc.keywords = keywords\n    return newfunc\n而iter的作用是当只有一个参数时，对这个对象进行迭代，所以这个对象必须实现__iter()__或__getitem()__方法，例如：\n>>> l = [1, 2, 3, 4]\n>>> for i in iter(l):\n...     print(i, end=' ')\n...\n>>> 1 2 3 4\n但当有两个参数时，第一个参数必须是可调用的（比如函数），第二个参数是终止的值，当调用第一个参数返回的结果等于第二个参数时，迭代就停止了，例如：\nwith open('mydata.txt') as fp:\n    for line in iter(fp.readline, ''):\n        process_line(line)\n所以综合两个方法来看上面的iter(partial(fd.read, 4), b'')，就是每次调用fd.read(4)直到返回一个空的bytes\n来源\nPython Cookbook\n关注\n欢迎关注我的微信公众号：python每日一练\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}