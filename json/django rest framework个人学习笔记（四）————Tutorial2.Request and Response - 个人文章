{"title": "django rest framework个人学习笔记（四）————Tutorial2.Request and Response - 个人文章 ", "index": "django-rest-framework,python", "content": "官网地址\nRequest 和 Response\n这一章将开始覆盖Rest framework的核心。让我们来介绍一些基础组件。\nRestquest object\nRest framework 引入了一个继承于django HttpRequest的对象Request，并提供更灵活的解析。Request的核心是request.data属性，他类似于request.POST,但对web api更有用。\nrequest.POST #只处理form data,而且只适用于'POST'方法\nrequest.data #处理所有数据，适用于 'POST','PUT','PATCH'\nResponse Object\nRest framework 也引入了Response对象，它是一个TemplateResponse类型，并根据客户端需求正确返回需要的类型。\nreturn Response(data) # 根据客户端的需求返回不同的类型。\nStatus codes\n在你的views中使用HTTP状态码，总是不太容易阅读的，而且稍不注意，你会返回一个错误的状态码。Rest framework为每个状态码提供了更为明确的标识符。例如 status模块中的 HTTP_400-BAD_REQUEST。\n装饰API views\nREST framework为你提供了两个装饰器，你能够使用它们来写你的API views。\n\n\n@api_view装饰器适用于function based views\n\nAPIView装饰器适用于 class-based views这些方法提供一些功能，例如确保你的view收到的请求类型是Request,并将上下文添加到Response当中，这样就能根据客户端的需要返回。\n\n装饰器还提供行为，例如适当的时候返回405 Method Not Allowed和当访问request.data或者输入错误时，处理所有的'ParseError'异常。\n结合之前的内容\n好，来开始使用新的组件来写我们的views。我们再也不需要在views.py中使用JSONResonse了。我们来开始重构我们的views.\nfrom rest_framework import status\nfrom rest_framework.decorators import api_view\nfrom rest_framework.response import Response\nfrom snippets.models import Snippet\nfrom snippets.serializers import SnippetSerializer\n\n\n@api_view(['GET', 'POST'])\ndef snippet_list(request):\n    \"\"\"\n    List all snippets, or create a new snippet.\n    \"\"\"\n    if request.method == 'GET':\n        snippets = Snippet.objects.all()\n        serializer = SnippetSerializer(snippets, many=True)\n        return Response(serializer.data)\n\n    elif request.method == 'POST':\n        serializer = SnippetSerializer(data=request.data)\n        if serializer.is_valid():\n            serializer.save()\n            return Response(serializer.data, status=status.HTTP_201_CREATED)\n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n我们所展示的示例view和之前相比，有了相当大的进展。它更小更简洁，如果我们正在使用Form API,会发现这个代码非常的相似。我们也能够使用 named status codes。\n接下来，我们将在views.py模块中展示一个snippet的详情。\n@api_view(['GET','PUT','DELETE'])\ndef snippet_detail(request,pk)\n'''\n检索，更新或者删除一个snippet\n'''\n    try:\n        snippet = Snippet.objects.get(pk=pk)\n    except Snippet.DoesNotExist:\n        return Response(status=status.HTTP_404_NOT_FOUND)\n        \n    if request.method == \"GET\":\n        serializer = SnippetSerializer(snippet)\n        return Response(serializer.date)\n    elif request.method == \"PUT\"：\n        serializer = SnippetSerializer(snippet,data=request.data)\n        if serializer.is_valid():\n            serializer.save()\n            return Response(serializer.data)\n        return Response(serializer.errors,status=status.HTPP_400_BAD_REQUEST)\n        \n    elif request.method == \"DELETE\":\n        snippe.delete()\n        return Response(status.status.HTTP_204_NO_CONTENT)\n这一切都应该感觉特别熟悉-它和标准的Django views没多少不同。\n注意:我们不再明确指定 request和response的响应类型。request.data能够处理所有进来的json请求，但他也能够处理其他的格式。同样，我们在response中返回我们的数据，但是由REST framework 来帮助我们来为不同的请求做出正确的响应内容。\n添加url\n为我们刚才编写的两个view添加url.\ndef snippet_list(request,format=None)\ndef snippet_detail(request,pk,format=None)\n现在，我们稍微修改一下我们的urls.py文件。\nfrom django.conf.urls import url\nfrom rest_framework.urlpatterns import format_suffix_patterns\nfrom snippets import views\n\nurlpatterns = [\n    url(r'^snippets/$',views.snippet_list),\n    url(r'^snippets/(?P<pk>[0-9]+)$',views.snippet_detail),\n]\n\nurlpatterns = format_suffix_patterns(urlpatterns)\n我们不是必须要添加这些额外的url patterns,但是它给我们一个简单，干净的特定格式。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "2"}