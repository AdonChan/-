{"title": "Python Logging 日志记录入门 - Solomon's 技术文集 ", "index": "debug,logging,python", "content": "\nPython Logging原来真的远比我想象的要复杂很多很多，学习路线堪比git。但是又绕不过去，alternatives又少，所以必须要予以重视，踏踏实实认认真真的来好好学学才行。\n学习Logging的目的：简单脚本还好，print足够。但是稍微复杂点，哪怕是三四个文件加起来两三百行代码，调试也开始变复杂起来了。再加上如果是后台长期运行的那种脚本，运行信息的调查更是复杂起来。一开始我还在各种查crontab的日志查看，或者是python后台运行查看，或者是python stdout的获取等等，全都找错了方向。真正的解决方案在于正确的logging。记录好了的话，我不需要去找python的控制台输出stdout，也不需要找crontab的日志，只需要查看log文件即可。下面是python的logging学习记录。\n最简单的日志输出（无文件记录）\nimport logging\n \nlogging.error(\"出现了错误\")\nlogging.info(\"打印信息\")\nlogging.warning(\"警告信息\")\n首先，忘掉logging.info()! 忘掉logging.basicConfig()!\n网上各种关于python logging的文章实在是太不体谅新手了，logging这么复杂的东西竟然想表现得很简单，还用各种简单的东西做假象。实际上我们真正要用起来的日志，绝对是不会直接用logging.info()和logging.basicConfig()这样的，这是此模块的官方推出来迷惑人的——看似让你一键上手，快速看到结果，但是跟实际真的不搭！所以为了后面解释起来轻松，必须先警告这点：忘记它们俩！记住，唯一要用到logging.什么的，就只有logging.getLogger()这一次。\n了解logging的工作流\n不想上流程图一类的东西，那样反而更迷糊。简单说吧：logging模块是会自动将你自定制的logger对象全局化的，也就是说，你在自己的模块里只要定义了一次某个logger，比如叫log，那么只要是在同一个模块中运行的其他文件都能读取到它。比如说，你在主文件main.py中自定义了一个logger，可能设置了什么输出文件、输出格式什么的，然后你在main.py中会引用一些别的文件或模块，比如sub.py，那么在这个sub.py中你什么都不用设置，只要用一句logger = logging.getLogger('之前在main.py定义的日志名')即可获得之前的一切自定义设置。\n当然，被调用的文件（先称为子模块）中，用logging.getLogger('日志名')时，最好在日志名后加一个.子名称这样的，比如main.sub。这样输出的时候就会显示出来某条日志记录是来自于这个文件里了。当然，.前面的父级logger必须名字一致，是会被识别出来的！然后，子日志还可以再子日志，甚至一个子模块可以再让所有函数各又一个子子日志，比如main.sub.func1这样的。logging都会根据.识别出来上下级关系的。\n这样一说，实际上也就是class类继承的那种机制了。你按照父级名称继承，然后还可以改写自己的新设置等。\n了解了这些概念以后，才能来谈代码。实际上也就好理解多了。\n设置logger的方法\n看来看去，这篇文章说得比较全面也最清楚，以下很多都参考到它的内容：Python 101: An Intro to logging\n一般想要自定义一个logger，比如让它输出信息时按照什么格式显示，输出到哪个文件，要不要输出到屏幕一类，有三种方法可以达到设置：\n\n直接在python代码里设置\n用外部的config.ini文件配置\n用python的dict字典配置\n\n三种达到的目的都是一样的，字典用的人很少也不方便，配置文件比较好用只是.ini的语法不是很方便读，且不容易做到变量的动态设置，所以一般直接在python代码里写就好。\n常用设置语句\n以下是程序主入口文件的通用写法，注意，一定要在主入口定义好logger，这样其他所有的子模块才能够继承到。\n#   main.py\nimport logging\nimport otherMod2   # 等下会调用到的子模块\n\ndef main():\n    \"\"\"\n    这个文件是程序的主入口\n    \"\"\"\n\n    define_logger()\n\n    log = logging.getLogger('exampleApp')\n\n    # 输出信息测试\n    logger.info(\"Program started\")\n    result = otherMod2.add(7, 8)     # 这个是来自别的模块的方法\n    logger.info(\"Done!\")\n\ndef define_logger():\n    logger = logging.getLogger(\"exampleApp\")\n    logger.setLevel(logging.INFO)\n\n    # 设置输出格式\n    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n \n    # 设置日志文件处理器\n    fh = logging.FileHandler(\"new_snake.log\")\n    fh.setFormatter(formatter)    # 为这个处理器添加格式\n\n    # 设置屏幕stdout输出处理器\n    sh  = logging.StreamHandler(stream=None)\n    sh.setFormatter(formatter)\n \n    # 把处理器加到logger上\n    logger.addHandler(fh)\n    logger.addHandler(sh)\n \nif __name__ == \"__main__\":\n    main()\n下面是子模块中的调用方法（很简单）：\n# otherMod2.py\nimport logging\n \nmodule_logger = logging.getLogger(\"exampleApp.otherMod2\")\n\ndef add(x, y):\n    # 这里一句`getLogger`就继承到父级的logger了\n    logger = logging.getLogger(\"exampleApp.otherMod2.add\")\n\n    # 输出测试\n    logger.info(\"added %s and %s to get %s\" % (x, y, x+y))\n    return x+y\n注意，主文件中，在什么地方定义logger都可以，可以在main()里也可以在任何单独的函数或类里，无所谓。只要在调用子模块之前定义好了就可以了。一旦定义过，日志名就会被记下来，然后子模块就可以轻松继承到。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}