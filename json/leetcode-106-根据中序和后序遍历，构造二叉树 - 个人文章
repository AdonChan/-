{"title": "leetcode-106-根据中序和后序遍历，构造二叉树 - 个人文章 ", "index": "python", "content": "题目描述：\n\nGiven inorder and postorder traversal of a tree, construct the binary tree.\n\nNote:\nYou may assume that duplicates do not exist in the tree.\n\nFor example, given\ninorder = [9,3,15,20,7]\npostorder = [9,15,7,20,3]\nReturn the following binary tree:\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n\ninorder =   [6,8,4,9,3,15,20,7]\npostorder = [6,4,8,9,15,7,20,3]\n            3\n           / \\\n          9  20\n         /  /  \\\n        8  15   7\n       / \\\n      6  4 ps: 以 postorder为中心进行分类\n\n题目分析：根据中序和后序遍历，构造二叉树。 根据动态规划方法，找出循环的共性。构造子二叉树，需要节点，和左右连接，从后序遍历找出根节点，从inorder对目标序列进行切分，如此往复。\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        if not postorder:\n            return None\n        node_center_frompost=postorder.pop()\n        index_center_inorder=inorder.index(node_center_frompost)\n        node=TreeNode(node_center_frompost)\n        node.left=self.buildTree(inorder[:index_center_inorder],postorder[:index_center_inorder])\n        node.right=self.buildTree(inorder[index_center_inorder+1:],postorder[index_center_inorder:])\n        return node\n\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}