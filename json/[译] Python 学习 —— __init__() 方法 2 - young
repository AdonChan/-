{"title": "[译] Python 学习 —— __init__() 方法 2 - young ", "index": "python,python3.x", "content": "注：原书作者 Steven F. Lott，原书名为 Mastering Object-oriented Python\n通过工厂函数对 __init__() 加以利用\n我们可以通过工厂函数来构建一副完整的扑克牌。这会比枚举所有52张扑克牌要好得多。在Python中，我们有如下两种常见的工厂方法：\n\n定义一个函数，该函数会创建所需类的对象。\n定义一个类，该类有创建对象的方法。这是一个完整的工厂设计模式，正如设计模式书所描述的那样。在诸如Java这样的语言中，工厂类层次结构是必须的，因为该语言不支持独立的函数。\n\n在Python中，类不是必须的。只有当相关的工厂非常复杂的时候才会显现出优势。Python的优势就是当一个简单的函数可以做的更好时我们决不强迫使用类层次结构。\n虽然这是一本关于面向对象编程的书，但函数真是一个好东西。这是常见也是最地道的Python。\n如果需要的话，我们总是可以重写一个函数为适当的可调用对象，可以将一个可调用对象重构到我们的工厂类层次结构中。我们将在第五章《使用Callables和Contexts》中学习可调用对象。\n一般，类定义的优点是通过继承实现代码重用。工厂类的函数就是包装一些目标类层次结构和复杂对象的构造。如果我们有一个工厂类，当扩展目标类层次结构的时候，我们可以添加子类到工厂类中。这给我们提供了多态工厂类，不同的工厂类定义具有相同的方法签名，可以交替使用。\n这个类级别的多态对于静态编译语言如Java或C++非常有用。编译器可以解决类和方法生成代码的细节。\n如果选择的工厂定义不能重用任何代码，则类层次结构在Python中不会有任何帮助。我们可以简单的使用具有相同签名的函数。\n以下是我们各种Card子类的工厂函数：\ndef card(rank, suit):\n    if rank == 1:\n        return AceCard('A', suit)\n    elif 2 <= rank < 11: \n        return NumberCard(str(rank), suit)\n    elif 11 <= rank < 14:\n        name = {11: 'J', 12: 'Q', 13: 'K' }[rank]\n        return FaceCard(name, suit)\n    else:\n        raise Exception(\"Rank out of range\")\n这个函数通过rank数值和suit对象构建Card类。现在我们可以更简单的构建牌了。我们已经将构造过程封装到一个单一的工厂函数中处理，允许应用程序在不知道精确的类层次结构和多态设计是如何工作的情况下进行构建。\n下面是如何通过这个工厂函数构建一副牌的示例：\ndeck = [card(rank, suit) for rank in range(1,14) for suit in (Club, Diamond, Heart, Spade)]\n它枚举了所有的牌值和花色来创建完整的52张牌。\n1. 错误的工厂设计和模糊的else子句\n注意card()函数里面的if语句结构。我们没有使用“包罗万象”的else子句来做任何处理；我们只是抛出异常。使用“包罗万象”的else子句会引出相关的小争论。\n一方面，从属于else子句的条件不能不言而喻，因为它可能隐藏着细微的设计错误。另一方面，一些else子句确实是显而易见的。\n重要的是要避免含糊的else子句。\n考虑下面工厂函数定义的变体：\ndef card2(rank, suit):\n    if rank == 1: \n        return AceCard('A', suit)\n    elif 2 <= rank < 11: \n        return NumberCard(str(rank), suit)\n    else:\n        name = {11: 'J', 12: 'Q', 13: 'K'}[rank]\n        return FaceCard(name, suit)\n以下是当我们尝试创建整副牌将会发生的事情：\ndeck2 = [card2(rank, suit) for rank in range(13) for suit in (Club, Diamond, Heart, Spade)]\n它起作用了吗？如果if条件更复杂了呢？\n一些程序员扫视的时候可以理解这个if语句。其他人将难以确定是否所有情况都正确执行了。\n对于Python高级编程，我们不应该把它留给读者去演绎条件是否适用于else子句。对于菜鸟来说条件应该是显而易见的，至少也应该是显式的。\n何时使用“包罗万象”的else\n尽量的少使用，使用它只有当条件是显而易见的时候。当有疑问时，显式的使用并抛出异常。\n避免含糊的else子句。\n2. 简单一致的使用elif序列\n我们的工厂函数card()是两种常见工厂设计模式的混合物:\n\nif-elif序列\n映射\n\n为了简单起见，最好是专注于这些技术的一个而不是两个。\n我们总是可以用映射来代替elif条件。（是的，总是。但相反是不正确的；改变elif条件为映射将是具有挑战性的。）\n以下是没有映射的Card工厂：\ndef card3(rank, suit):\n    if rank == 1: \n        return AceCard('A', suit)\n    elif 2 <= rank < 11: \n        return NumberCard(str(rank), suit)\n    elif rank == 11:\n        return FaceCard('J', suit)\n    elif rank == 12:\n        return FaceCard('Q', suit)\n    elif rank == 13:\n        return FaceCard('K', suit)\n    else:\n        raise Exception(\"Rank out of range\")\n我们重写了card()工厂函数。映射已经转化为额外的elif子句。这个函数有个优点就是它比之前的版本更加一致。\n3. 简单的使用映射和类对象\n在一些示例中，我们可以使用映射来代替一连串的elif条件。很可能发现条件太复杂，这个时候或许只有使用一连串的elif条件来表达才是明智的选择。对于简单示例，无论如何，映射可以做的更好且可读性更强。\n因为class是最好的对象，我们可以很容易的映射rank参数到已经构造好的类中。\n以下是仅使用映射的Card工厂：\n def card4(rank, suit):\n    class_ = {1: AceCard, 11: FaceCard, 12: FaceCard, 13: FaceCard}.get(rank, NumberCard)\n    return class_(rank, suit)\n我们已经映射rank对象到类中。然后，我们给类传递rank值和suit值来创建最终的Card实例。\n最好我们使用defaultdict类。无论如何，对于微不足道的静态映射不会比这更简单了。看起来像下面代码片段那样：\ndefaultdict(lambda: NumberCard, {1: AceCard, 11: FaceCard, 12: FaceCard, 12: FaceCard})\n注意：defaultdict类默认必须是无参数的函数。我们已经使用了lambda创建必要的函数来封装常量。这个函数，无论如何，都有一些缺陷。对于我们之前版本中缺少1到A和13到K的转换。当我们试图增加这些特性时，一定会出现问题的。\n我们需要修改映射来提供可以和字符串版本的rank对象一样的Card子类。对于这两部分的映射我们还可以做什么？有四种常见解决方案：\n\n可以做两个并行的映射。我们不建议这样，但是会强调展示不可取的地方。\n可以映射个二元组。这个同样也会有一些缺点。\n可以映射到partial()函数。partial()函数是functools模块的一个特性。\n可以考虑修改我们的类定义，这种映射更容易。可以在下一节将__init__()置入子类定义中看到。\n\n我们来看看每一个具体的例子。\n3.1. 两个并行映射\n以下是两个并行映射解决方案的关键代码：\nclass_ = {1: AceCard, 11: FaceCard, 12: FaceCard, 13: FaceCard}.get(rank, NumberCard)\nrank_str = {1:'A', 11:'J', 12:'Q', 13:'K'}.get(rank, str(rank))\nreturn class_(rank_str, suit)\n这并不可取的。它涉及到重复映射键1、11、12和13序列。重复是糟糕的，因为在软件更新后并行结构依然保持这种方式。\n不要使用并行结构\n并行结构必须使用元组或一些其他合适的集合来替代。\n3.2. 映射到元组的值\n以下是二元组映射的关键代码：\nclass_, rank_str= {\n    1: (AceCard,'A'),\n    11: (FaceCard,'J'),\n    12: (FaceCard,'Q'),\n    13: (FaceCard,'K'),\n}.get(rank, (NumberCard, str(rank)))\nreturn class_(rank_str, suit)\n这是相当不错的，不需要过多的代码来分类打牌中的特殊情况。当我们需要改变Card类层次结构来添加额外的Card子类时，我们可以看到它是如何被修改或被扩展。\n将rank值映射到一个类对象的确让人感觉奇怪，且只有类初始化所需两个参数中的一个。将牌值映射到一个简单的类或没有提供一些混乱参数（但不是所有）的函数对象似乎会更合理。\n3.3. partial函数解决方案\n相比映射到函数的二元组和参数之一，我们可以创建一个partial()函数。这是一个已经提供一些（但不是所有）参数的函数。我们将从functools库中使用partial()函数来创建一个带有rank参数的partial类。\n以下是将rank映射到partial()函数，可用于对象创建：\nfrom functools import partial\n\npart_class = {\n   1: partial(AceCard, 'A'),\n   11: partial(FaceCard, 'J'),\n   12: partial(FaceCard, 'Q'),\n   13: partial(FaceCard, 'K'),\n}.get(rank, partial(NumberCard, str(rank)))\nreturn part_class(suit)\n映射将rank对象与partial()函数联系在一起，并分配给part_class。这个partial()函数可以被应用到suit对象来创建最终的对象。partial()函数是一种常见的函数式编程技术。它在我们有一个函数来替代对象方法这一特定的情况下使用。\n不过总体而言，partial()函数对于大多数面向对象编程并没有什么帮助。相比创建partial()函数，我们可以简单地更新类的方法来接受不同组合的参数。partial()函数类似于给对象创建一个流畅的接口。\n3.4. 连贯的工厂类接口\n在某些情况下，我们设计的类在方法使用上定义好了顺序，按顺序求方法的值很像partial()函数。\n在一个对象表示法中我们可能会有x.a().b()。我们可以把它当成x(a, b)。x.a()函数是等待b()的一类partial()函数。我们可以认为它就像x(a)(b)那样。\n这里的概念是，Python给我们提供两种选择来管理状态。我们既可以更新对象又可以创建有状态性的（在某种程度上）partial()函数。由于这种等价，我们可以重写partial()函数到一个流畅的工厂对象中。使得rank对象的设置为一个流畅的方法来返回self。设置suit对象将真实的创建Card实例。\n以下是一个流畅的Card工厂类，有两个方法函数，必须在特定顺序中使用：\nclass CardFactory:\n    def rank(self, rank):\n        self.class_, self.rank_str = {\n            1: (AceCard, 'A'),\n            11: (FaceCard,'J'),\n            12: (FaceCard,'Q'),\n            13: (FaceCard,'K'),\n        }.get(rank, (NumberCard, str(rank)))\n        return self\n    def suit(self, suit):\n        return self.class_(self.rank_str, suit)\nrank()方法更新构造函数的状态，suit()方法真实的创建了最终的Card对象。\n这个工厂类可以像下面这样使用：\ncard8 = CardFactory()\ndeck8 = [card8.rank(r+1).suit(s) for r in range(13) for s in (Club, Diamond, Heart, Spade)]\n首先，我们创建一个工厂实例，然后我们使用那个实例创建Card实例。这并没有实质性改变__init__()在Card类层次结构中的运作方式。然而，它确实改变了我们应用程序创建对象的方式。\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "14"}