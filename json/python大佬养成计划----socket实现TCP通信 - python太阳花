{"title": "python大佬养成计划----socket实现TCP通信 - python太阳花 ", "index": "python", "content": "TCP\nTCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能，用户数据报协议（UDP）是同一层内 [1]  另一个重要的传输协议。在因特网协议族（Internet protocol suite）中，TCP层是位于IP层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。\n下面是socket实现TCP通信的示意图，我们根据示意图来编写程序\nTCP服务端\n服务器进程首先要绑定一个端口并监听来自其他客户端的连接。 如果某个客户端连接过来了， 服务器就与该客户端建立Socket连接， 随后的通信就靠这个Socket连接了。\n我们来编写一个简单的服务器程序， 它接收客户端连接，回复客户端发来的请求。\nimport socket\nserver = socket.socket()\nserver.bind(('192.168.1.165',8900))\n#调用 listen() 方法开始监听端口， 传入的参数指定等待连接的最大数量\nserver.listen(4)\nserObj,address = server.accept()\n#当有客户端访问时，实现两边的交流，如果有一方退出，整个程序退出。\n#服务器程序通过一个永久循环来接受来自客户端的连接\n#这里虽然给出最大连接数为4，但单线程程序也只会响应一个连接\nwhile True:\n#建立连接后，服务端等待客户端发送的数据，实现通信\n    re_data = serObj.recv(1024).decode('utf-8')\n    print('client>>',re_data)\n    if re_data == 'quit':\n        break\n    send_data = input('server>>')\n    serObj.send(send_data.encode('utf-8'))\n    if send_data == 'quit':\n        break\nserObj.close()\nserver.close()\nTCP客户端\n大多数连接都是可靠的TCP连接。 创建TCP连接时， 主动发起连接的叫客户端， 被动响应连接的叫服务器。\n举个例子， 当我们在浏览器中访问新浪时， 我们自己的计算机就是客户端， 浏览器会主动向新浪的服务器发起连接。 如果一切顺利， 新浪的服务器接受了我们的连接， 一个TCP连接就建立起来的， 后面的通信就是发送网页内容了。\n\n客户端要主动发起TCP连接， 必须知道服务器的IP地址和端口号。\nimport socket\nclient = socket.socket()\nclient.connect(('192.168.1.165',8900))\nwhile True:\n    send_data = input(\"client>>\")\n    client.send(send_data.encode('utf-8'))\n    if send_data == 'quit':\n        break\n    re_data = client.recv(1024).decode('utf-8')\n    if re_data == 'quit':\n        break\n    print(\"server>>\",re_data)\n\nclient.close()\n用一个窗口运行客户端、另一个窗口运行服务端，可以更直观看见效果。这里我的08_pra.py是服务端程序，09_pra.py是客户端程序\n刚建立连接时的示意图\n一次通信完成的示意图\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}