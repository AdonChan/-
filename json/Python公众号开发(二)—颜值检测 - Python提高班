{"title": "Python公众号开发(二)—颜值检测 - Python提高班 ", "index": "人工智能,微信公众平台,微信,公众号,python", "content": "上篇文章，我们把自己的程序接入了微信公众号，并且能把用户发送的文本及图片文件原样返回。今天我们把用户的图片通过腾讯的AI平台分析后再返回给用户。\n为了防止我的文章被到处转载，贴一下我的公众号【智能制造专栏】，欢迎大家关注。\ngithub仓库地址https://github.com/injetlee/Python/tree/master/wechat\n效果图\n\n\n\n一. 接入腾讯AI平台\n我们先看一下官方人脸检测与分析接口的描述：\n检测给定图片（Image）中的所有人脸（Face）的位置和相应的面部属性。位置包括（x, y, w, h），面部属性包括性别（gender）, 年龄（age）, 表情（expression）, 魅力（beauty）, 眼镜（glass）和姿态（pitch，roll，yaw）。\n请求参数包括下面几个：\n\napp_id 应用标识，我们在AI平台注册后就可以得到app_id\ntime_stamp 时间戳\nnonce_str 随机字符串\nsign 签名信息，需要我们自己去计算\nimage 需要检测的图片（上限1M）\nmode 检测模式\n\n1.接口鉴权，构造请求参数\n官方给了我们接口鉴权的计算方法。\n\n将<key, value>请求参数对按key进行字典升序排序，得到有序的参数对列表N\n将列表N中的参数对按URL键值对的格式拼接成字符串，得到字符串T（如：key1=value1&key2=value2），URL键值拼接过程value部分需要URL编码，URL编码算法用大写字母，例如%E8，而不是小写%e8\n将应用密钥以app_key为键名，组成URL键值拼接到字符串T末尾，得到字符串S（如：key1=value1&key2=value2&app_key=密钥)\n对字符串S进行MD5运算，将得到的MD5值所有字符转换成大写，得到接口请求签名\n\n2.请求接口地址\n请求接口信息，我们用 requests 发送请求，会得到返回的 json 格式的图像信息pip install requests安装requests。\n3.处理返回的信息\n处理返回的信息，把信息展示在图片上，再把处理后的图片保存。这里我们用到 opencv ,和 pillow 两个库pip install pillow和pip install opencv-python来安装。\n开始编写代码，我们新建一个face_id.py 文件来对接AI平台，并且返回检测后的图像数据。\nimport time\nimport random\nimport base64\nimport hashlib\nimport requests\nfrom urllib.parse import urlencode\nimport cv2\nimport numpy as np\nfrom PIL import Image, ImageDraw, ImageFont\nimport os\n\n\n# 一.计算接口鉴权，构造请求参数\n\ndef random_str():\n    '''得到随机字符串nonce_str'''\n    str = 'abcdefghijklmnopqrstuvwxyz'\n    r = ''\n    for i in range(15):\n        index = random.randint(0,25)\n        r += str[index]\n    return r\n\n\ndef image(name):\n    with open(name, 'rb') as f:\n        content = f.read()\n    return base64.b64encode(content)\n\n\ndef get_params(img):\n    '''组织接口请求的参数形式，并且计算sign接口鉴权信息，\n    最终返回接口请求所需要的参数字典'''\n    params = {\n        'app_id': '1106860829',\n        'time_stamp': str(int(time.time())),\n        'nonce_str': random_str(),\n        'image': img,\n        'mode': '0'\n\n    }\n\n    sort_dict = sorted(params.items(), key=lambda item: item[0], reverse=False)  # 排序\n    sort_dict.append(('app_key', 'P8Gt8nxi6k8vLKbS'))  # 添加app_key\n    rawtext = urlencode(sort_dict).encode()  # URL编码\n    sha = hashlib.md5()\n    sha.update(rawtext)\n    md5text = sha.hexdigest().upper()  # 计算出sign，接口鉴权\n    params['sign'] = md5text  # 添加到请求参数列表中\n    return params\n\n# 二.请求接口URL\n\n\ndef access_api(img):\n    frame = cv2.imread(img)\n    nparry_encode = cv2.imencode('.jpg', frame)[1]\n    data_encode = np.array(nparry_encode)\n    img_encode = base64.b64encode(data_encode)  # 图片转为base64编码格式\n    url = 'https://api.ai.qq.com/fcgi-bin/face/face_detectface'\n    res = requests.post(url, get_params(img_encode)).json()  # 请求URL,得到json信息\n    # 把信息显示到图片上\n    if res['ret'] == 0:  # 0代表请求成功\n        pil_img = Image.fromarray(cv2.cvtColor(frame, cv2.COLOR_BGR2RGB))  # 把opencv格式转换为PIL格式，方便写汉字\n        draw = ImageDraw.Draw(pil_img)\n        for obj in res['data']['face_list']:\n            img_width = res['data']['image_width']  # 图像宽度\n            img_height = res['data']['image_height']  # 图像高度\n            # print(obj)\n            x = obj['x']  # 人脸框左上角x坐标\n            y = obj['y']  # 人脸框左上角y坐标\n            w = obj['width']  # 人脸框宽度\n            h = obj['height']  # 人脸框高度\n            # 根据返回的值，自定义一下显示的文字内容\n            if obj['glass'] == 1:  # 眼镜\n                glass = '有'\n            else:\n                glass = '无'\n            if obj['gender'] >= 70:  # 性别值从0-100表示从女性到男性\n                gender = '男'\n            elif 50 <= obj['gender'] < 70:\n                gender = \"娘\"\n            elif obj['gender'] < 30:\n                gender = '女'\n            else:\n                gender = '女汉子'\n            if 90 < obj['expression'] <= 100:  # 表情从0-100，表示笑的程度\n                expression = '一笑倾城'\n            elif 80 < obj['expression'] <= 90:\n                expression = '心花怒放'\n            elif 70 < obj['expression'] <= 80:\n                expression = '兴高采烈'\n            elif 60 < obj['expression'] <= 70:\n                expression = '眉开眼笑'\n            elif 50 < obj['expression'] <= 60:\n                expression = '喜上眉梢'\n            elif 40 < obj['expression'] <= 50:\n                expression = '喜气洋洋'\n            elif 30 < obj['expression'] <= 40:\n                expression = '笑逐颜开'\n            elif 20 < obj['expression'] <= 30:\n                expression = '似笑非笑'\n            elif 10 < obj['expression'] <= 20:\n                expression = '半嗔半喜'\n            elif 0 <= obj['expression'] <= 10:\n                expression = '黯然伤神'\n            delt = h // 5  # 确定文字垂直距离\n            # 写入图片\n            if len(res['data']['face_list']) > 1:  # 检测到多个人脸，就把信息写入人脸框内\n                font = ImageFont.truetype('yahei.ttf', w // 8, encoding='utf-8')  # 提前把字体文件下载好\n                draw.text((x + 10, y + 10), '性别 :' + gender, (76, 176, 80), font=font)\n                draw.text((x + 10, y + 10 + delt * 1), '年龄 :' + str(obj['age']), (76, 176, 80), font=font)\n                draw.text((x + 10, y + 10 + delt * 2), '表情 :' + expression, (76, 176, 80), font=font)\n                draw.text((x + 10, y + 10 + delt * 3), '魅力 :' + str(obj['beauty']), (76, 176, 80), font=font)\n                draw.text((x + 10, y + 10 + delt * 4), '眼镜 :' + glass, (76, 176, 80), font=font)\n            elif img_width - x - w < 170:  # 避免图片太窄，导致文字显示不完全\n                font = ImageFont.truetype('yahei.ttf', w // 8, encoding='utf-8')\n                draw.text((x + 10, y + 10), '性别 :' + gender, (76, 176, 80), font=font)\n                draw.text((x + 10, y + 10 + delt * 1), '年龄 :' + str(obj['age']), (76, 176, 80), font=font)\n                draw.text((x + 10, y + 10 + delt * 2), '表情 :' + expression, (76, 176, 80), font=font)\n                draw.text((x + 10, y + 10 + delt * 3), '魅力 :' + str(obj['beauty']), (76, 176, 80), font=font)\n                draw.text((x + 10, y + 10 + delt * 4), '眼镜 :' + glass, (76, 176, 80), font=font)\n            else:\n                font = ImageFont.truetype('yahei.ttf', 20, encoding='utf-8')\n                draw.text((x + w + 10, y + 10), '性别 :' + gender, (76, 176, 80), font=font)\n                draw.text((x + w + 10, y + 10 + delt * 1), '年龄 :' + str(obj['age']), (76, 176, 80), font=font)\n                draw.text((x + w + 10, y + 10 + delt * 2), '表情 :' + expression, (76, 176, 80), font=font)\n                draw.text((x + w + 10, y + 10 + delt * 3), '魅力 :' + str(obj['beauty']), (76, 176, 80), font=font)\n                draw.text((x + w + 10, y + 10 + delt * 4), '眼镜 :' + glass, (76, 176, 80), font=font)\n\n            draw.rectangle((x, y, x + w, y + h), outline=\"#4CB050\")  # 画出人脸方框\n            cv2img = cv2.cvtColor(np.array(pil_img), cv2.COLOR_RGB2BGR)  # 把 pil 格式转换为 cv\n            cv2.imwrite('faces/{}'.format(os.path.basename(img)), cv2img)  # 保存图片到 face 文件夹下\n            return '检测成功'\n    else:\n        return '检测失败'\n到这里我们的人脸检测接口接入及图片处理就完成了。之后在收到用户发送的图片信息后，调用这个函数，把处理后的图片返回给用户就可以。\n返回图片给用户\n当收到用户图片时，需要以下几个步骤：\n保存图片\n当接收到用户图片后，我们要先把图片保存起来，之后才能去调用人脸分析接口，把图片信息传递过去，我们需要编写一个 img_download 函数来下载图片。详见下方代码\n调用人脸分析接口\n图片下载后，调用 face_id.py 文件里的接口函数，得到处理后的图片。\n上传图片\n检测结果是一张新的图片，要把图片发送给用户我们需要一个 Media_ID,要获取Media_ID必须先把图片上传为临时素材，所以这里我们需要一个img_upload函数来上传图片，并且在上传时需要用到一个access_token,我们通过一个函数来获取. 获取access_token必须要把我们自己的IP地址加入白名单，否则是获取不到的。请登录“微信公众平台-开发-基本配置”提前将服务器IP地址添加到IP白名单中，可以在http://ip.qq.com/查看本机的IP...\n开始编写代码，我们新建一个 utils.py 来下载、上传图片\nimport requests\nimport json\nimport threading\nimport time\nimport os\n\ntoken = ''\napp_id = 'wxfc6adcdd7593a712'\nsecret = '429d85da0244792be19e0deb29615128'\n\n\ndef img_download(url, name):\n    r = requests.get(url)\n    with open('images/{}-{}.jpg'.format(name, time.strftime(\"%Y_%m_%d%H_%M_%S\", time.localtime())), 'wb') as fd:\n        fd.write(r.content)\n    if os.path.getsize(fd.name) >= 1048576:\n        return 'large'\n    # print('namename', os.path.basename(fd.name))\n    return os.path.basename(fd.name)\n\n\ndef get_access_token(appid, secret):\n    '''获取access_token,100分钟刷新一次'''\n\n    url = 'https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid={}&secret={}'.format(appid, secret)\n    r = requests.get(url)\n    parse_json = json.loads(r.text)\n    global token\n    token = parse_json['access_token']\n    global timer\n    timer = threading.Timer(6000, get_access_token)\n    timer.start()\n\n\ndef img_upload(mediaType, name):\n    global token\n    url = \"https://api.weixin.qq.com/cgi-bin/media/upload?access_token=%s&type=%s\" % (token, mediaType)\n    files = {'media': open('{}'.format(name), 'rb')}\n    r = requests.post(url, files=files)\n    parse_json = json.loads(r.text)\n    return parse_json['media_id']\n\nget_access_token(app_id, secret)\n返回给用户\n我们简单修改下收到图片后的逻辑，收到图片后经过人脸检测，上传获得Media_ID,我们要做的就是把图片返回给用户即可。直接看connect.py的代码\nimport falcon\nfrom falcon import uri\nfrom wechatpy.utils import check_signature\nfrom wechatpy.exceptions import InvalidSignatureException\nfrom wechatpy import parse_message\nfrom wechatpy.replies import TextReply, ImageReply\n\nfrom utils import img_download, img_upload\nfrom face_id import access_api\n\n\nclass Connect(object):\n\n    def on_get(self, req, resp):\n        query_string = req.query_string\n        query_list = query_string.split('&')\n        b = {}\n        for i in query_list:\n            b[i.split('=')[0]] = i.split('=')[1]\n\n        try:\n            check_signature(token='lengxiao', signature=b['signature'], timestamp=b['timestamp'], nonce=b['nonce'])\n            resp.body = (b['echostr'])\n        except InvalidSignatureException:\n            pass\n        resp.status = falcon.HTTP_200\n\n    def on_post(self, req, resp):\n        xml = req.stream.read()\n        msg = parse_message(xml)\n        if msg.type == 'text':\n            reply = TextReply(content=msg.content, message=msg)\n            xml = reply.render()\n            resp.body = (xml)\n            resp.status = falcon.HTTP_200\n        elif msg.type == 'image':\n            name = img_download(msg.image, msg.source)  # 下载图片\n            r = access_api('images/' + name)\n            if r == '检测成功':\n                media_id = img_upload('image', 'faces/' + name)  # 上传图片，得到 media_id\n                reply = ImageReply(media_id=media_id, message=msg)\n            else:\n                reply = TextReply(content='人脸检测失败，请上传1M以下人脸清晰的照片', message=msg)\n            xml = reply.render()\n            resp.body = (xml)\n            resp.status = falcon.HTTP_200\n\napp = falcon.API()\nconnect = Connect()\napp.add_route('/connect', connect)\n\n至此我们的工作就做完了，我们的公众号可以进行颜值检测了。本来我打算用在自己公众号上的，但是还存在下面几个问题，所以没有使用。\n\n微信的机制，我们的程序必须在5s内给出响应。不然就会报'公众号提供的服务出现故障'。然而处理图片有时会比较慢，经常会超过5s。所以正确的处理方式应该是拿到用户的请求后立即返回一个空字符串表示我们收到了，之后单独创建一个线程去处理图片，当图片处理完后通过客服接口发送给用户。可惜的是未认证的公众号没有客服接口，所以没办法，超过5s就会报错。\n无法自定义菜单，一旦启用了自定义开发，菜单也需要自定义配置，但是未认证的公众号没有权限通过程序来配置菜单，只能在微信后台配置。\n\n所以，我并没有在我的公众号上启用这个程序，但是如果有认证的公众号，可以尝试开发各种好玩的功能。\n上篇：Python微信公众号开发—小白篇(一)\n\n                ", "mainLikeNum": ["10 "], "mainBookmarkNum": "7"}