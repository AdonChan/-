{"title": "《Python有什么好学的》之修饰器 - 个人文章 ", "index": "python", "content": "“Python有什么好学的”这句话可不是反问句，而是问句哦。\n主要是煎鱼觉得太多的人觉得Python的语法较为简单，写出来的代码只要符合逻辑，不需要太多的学习即可，即可从一门其他语言跳来用Python写（当然这样是好事，谁都希望入门简单）。\n于是我便记录一下，如果要学Python的话，到底有什么好学的。记录一下Python有什么值得学的，对比其他语言有什么特别的地方，有什么样的代码写出来更Pythonic。一路回味，一路学习。\n什么是修饰器，为什么叫修饰器\n修饰器英文是Decorator，\n我们假设这样一种场景：古老的代码中有几个很是复杂的函数F1、F2、F3...，复杂到看都不想看，反正我们就是不想改这些函数，但是我们需要改造加功能，在这个函数的前后加功能，这个时候我们很容易就实现这个需求：\ndef hi():\n    \"\"\"hi func，假装是很复杂的函数\"\"\"\n    return 'hi'\n\ndef aop(func):\n    \"\"\"aop func\"\"\"\n    print('before func')\n    print(func())\n    print('after func')\n    \nif __name__ == '__main__':\n    aop(hi)\n\n以上是很是简单的实现，利用Python参数可以传函数引用的特性，就可以实现了这种类似AOP的效果。\n这段代码目前没有什么问题，接下来煎鱼加需求：需求为几十个函数都加上这样的前后的功能，而所有调用这些函数地方也要相应地升级。\n看起来这个需求比较扯，偏偏这个需求却是较为广泛：在调用函数的前后加上log输出、在调用函数的前后计算调用时间、在调用函数的前后占用和释放资源等等。\n一种比较笨的方法就是，为这几十个函数逐一添加一个入口函数，针对a函数添加一个a_aop函数，针对b函数添加一个b_aop函数...如此这样。问题也很明显：\n\n工作量大\n代码变得臃肿复杂\n原代码有多处调用了这些函数，可以会升级不完全\n\n于是接下来有请修饰器出场，修饰器可以统一地给这些函数加这样的功能：\ndef aop(func):\n    \"\"\"aop func\"\"\"\n    def wrapper():\n        \"\"\"wrapper func\"\"\"\n        print('before func')\n        func()\n        print('after func')\n    return wrapper\n\n@aop\ndef hi():\n    \"\"\"hi func\"\"\"\n    print('hi')\n    \n@aop\ndef hello():\n    \"\"\"hello func\"\"\"\n    print('hello')\n\nif __name__ == '__main__':\n    hi()\n    hello()\n\n以上aop函数就是修饰器的函数，使用该修饰器时只要在待加函数上一行加@修饰器函数名即可，如实例代码中就是@aop。\n加上了@aop后，调用新功能的hi函数就喝原来的调用一样：就是hi()而不是aop(hi)，也意味着所有调用这些函数的地方不需要修改就可以升级。\n简单地来说，大概修饰器就是以上的这样子。\n@是个什么\n对于新手来说，上面例子中，@就是一样奇怪的东西：为什么这样子用就可以实现煎鱼需求的功能了。\n其实我们还可以不用@，煎鱼换一种写法：\ndef hi():\n    \"\"\"hi func\"\"\"\n    print('hi')\n\ndef aop(func):\n    \"\"\"aop func\"\"\"\n    def wrapper():\n        \"\"\"wrapper func\"\"\"\n        print('before func')\n        func()\n        print('after func')\n    return wrapper\n\nif __name__ == '__main__':\n    hi()\n\n    print('')\n\n    hi = aop(hi)\n    hi()\n\n上面的例子中的aop函数就是之前说过的修饰器函数。\n如例子main函数中第一次调用hi函数时，由于hi函数没叫修饰器，因此我们可以从输出结果中看到程序只输出了一个hi而没有前后功能。\n然后煎鱼加了一个hi = aop(hi)后再调用hi函数，得到的输出结果和加修饰器的一样，换言之：\n@aop 等效于hi = aop(hi)\n因此，我们对于@，可以理解是，它通过闭包的方式把新函数的引用赋值给了原来函数的引用。\n有点拗口。aop(hi)是新函数的引用，至于返回了引用的原因是aop函数中运用闭包返回了函数引用。而hi这个函数的引用，本来是指向旧函数的，通过hi = aop(hi)赋值后，就指向新函数了。\n被调函数加参数\n以上的例子中，我们都假设被调函数是无参的，如hi、hello函数都是无参的，我们再看一眼煎鱼刚才的写的修饰器函数：\ndef aop(func):\n    \"\"\"aop func\"\"\"\n    def wrapper():\n        \"\"\"wrapper func\"\"\"\n        print('before func')\n        func()\n        print('after func')\n    return wrapper\n很明显，闭包函数wrapper中，调用被调函数用的是func()，是无参的。同时就意味着，如果func是一个带参数的函数，再用这个修饰器就会报错。\n@aop\ndef hi_with_deco(a):\n    \"\"\"hi func\"\"\"\n    print('hi' + str(a))\n\nif __name__ == '__main__':\n    # hi()\n    hi_with_deco(1)\n\n就是参数的问题。这个时候，我们把修饰器函数改得通用一点即可，其中import了一个函数（也是修饰器函数）：\nfrom functools import wraps\n\ndef aop(func):\n    \"\"\"aop func\"\"\"\n    @wraps(func)\n    def wrap(*args, **kwargs):\n        print('before')\n        func(*args, **kwargs)\n        print('after')\n\n    return wrap\n\n@aop\ndef hi(a, b, c):\n    \"\"\"hi func\"\"\"\n    print('test hi: %s, %s, %s' % (a, b, c))\n\n@aop\ndef hello(a, b):\n    \"\"\"hello func\"\"\"\n    print('test hello: %s, %s' % (a, b))\n\nif __name__ == '__main__':\n    hi(1, 2, 3)\n    hello('a', 'b')\n\n这是一种很奇妙的东西，就是在写修饰器函数的时候，还用了别的修饰器函数。那也没什么，毕竟修饰器函数也是函数啊，有什么所谓。\n带参数的修饰器\n思路到了这里，煎鱼不禁思考一个问题：修饰器函数也是函数，那函数也是应该能传参的。函数传参的话，不同的参数可以输出不同的结果，那么，修饰器函数传参的话，不同的参数会怎么样呢？\n其实很简单，修饰器函数不同的参数，能生成不同的修饰器啊。\n如，我这次用这个修饰器是把时间日志打到test.log，而下次用修饰器的时候煎鱼希望是能打到test2.log。这样的需求，除了写两个修饰器函数外，还可以给修饰器加参数选项：\nfrom functools import wraps\n\ndef aop_with_param(aop_test_str):\n    def aop(func):\n        \"\"\"aop func\"\"\"\n        @wraps(func)\n        def wrap(*args, **kwargs):\n            print('before ' + str(aop_test_str))\n            func(*args, **kwargs)\n            print('after ' + str(aop_test_str))\n        return wrap\n    return aop\n\n@aop_with_param('abc')\ndef hi(a, b, c):\n    \"\"\"hi func\"\"\"\n    print('test hi: %s, %s, %s' % (a, b, c))\n\n@aop_with_param('pppppp')\ndef hi2(a, b, c):\n    \"\"\"hi func\"\"\"\n    print('test hi: %s, %s, %s' % (a, b, c))\n\nif __name__ == '__main__':\n    hi(1, 2, 3)\n    print('')\n    hi2(2, 3, 4)\n\n同样的，可以加一个参数，也可以加多个参数，这里就不说了。\n修饰器类\n大道同归，逻辑复杂了之后，人们都喜欢将函数的思维层面抽象上升到对象的层面。原因往往是对象能拥有多个函数，对象往往能管理更复杂的业务逻辑。\n显然，修饰器函数也有对应的修饰器类。写起来也没什么难度，和之前的生成器一样简单：\nfrom functools import wraps\n\nclass aop(object):\n    def __init__(self, aop_test_str):\n        self.aop_test_str = aop_test_str\n\n    def __call__(self, func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            print('before ' + self.aop_test_str)\n            func()\n            print('after ' + self.aop_test_str)\n\n        return wrapper\n        \n@aop('pppppp')\ndef hi():\n    print('hi')\n看得出来，这个修饰器类也不过是多了个__call__函数，而这个__call__函数的内容和之前写的修饰器函数一个样！而使用这个修饰器的方法，和之前也一样，一样的如例子中的@aop('pppppp')。\n甚至，煎鱼过于无聊，还试了一下继承的修饰器类：\nclass sub_aop(aop):\n    def __init__(self, sub_aop_str, *args, **kwargs):\n        self.sub_aop_str = sub_aop_str\n        super(sub_aop, self).__init__(*args, **kwargs)\n\n    def __call__(self, func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            print('before ' + self.sub_aop_str)\n            super(sub_aop, self).__call__(func)()\n            print('after ' + self.sub_aop_str)\n        return wrapper\n        \n@sub_aop('ssssss', 'pppppp')\ndef hello():\n    print('hello')\n    \nif __name__ == '__main__':\n    hello()\n你们猜猜结果怎么样？\n先这样吧\n若有错误之处请指出，更多地请关注造壳。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}