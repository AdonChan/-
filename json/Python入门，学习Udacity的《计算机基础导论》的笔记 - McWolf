{"title": "Python入门，学习Udacity的《计算机基础导论》的笔记 - McWolf ", "index": "python", "content": "此文是记录我在udacity.com学习python的过程，主要目的是怕学了后面的wan了前面的，方便复习。也希望能帮到和我一样的初学者，这个课程的是Udacity的《计算机基础导论》，https://classroom.udacity.com...\n准备工作\n\n下载ATOM编辑器：https://atom.io/\n安装扩展包：atom-beautify,autocomplete-python,script\n在ATOM里新建一个Python文件，敲入代码，然后按Ctrl+Shift+B就可以测试运行代码啦\n\n当然，学一下MarkDown语法，然后在SegmentFault上注册个账号，做一下笔记也是必不可少的步骤。因为写公开笔记，需要别人也能看得懂你的笔记，这逼迫自己的代码与备注必须写清楚，而且这种把自己输入的东西再输出的方法，可以更好的帮助自己学习。\n计算光1纳秒行径多少厘米\nspeed_of_light = 299792458   #申明一个变量speed_of_light的值是299792458米/秒\ncentimeters = 100            #申明一个变量centimeters 代表1米=100厘米\nnanosecond = 1.0/1000000000  #申明一个变量nanosecond 代表1纳秒=十亿分之一秒\nprint speed_of_light * centimeters / nanosecond #python 2.x的打印命令方式\nprint (speed_of_light * centimeters / nanosecond) #python 3.x的打印命令方式\n结果是2.99792458,约等于3秒\n计算2.7G的CPU每次1hz时间，光在CPU中行径的距离。\n这是我第一次明白了，CPU工艺提升是怎么提高性能的，CPU小了，电子从一端到达另一端的需要的距离变短了。不得不承认，老外的课程确实比国内的课程更有趣。\nspeed_of_light = 299792458.0 #光的速度 米/秒\ncycles_per_second = 2700000000.0 #2.7G的CPU相当于每秒运行的Hz数\nprint (speed_of_light / cycles_per_second)\n答案是11CM。所以提升CPU性能的2个关键：1.降低电子需要行径的距离；2.提高每秒发射电子的次数。\n选择序列\nname =\"Jianpin Yuan\"\n#序列是从0开始算的，所以0代表第1位，1代表第2位，-1代表倒数第1位\nprint (name[0]) #打印 索引字符串的第1个字符，得到结果J\nprint (name[1:4]) #打印 索引字符串的第2到第5个之间的字符，得到结果ian\nprint (name[1:]) #打印 索引字符串的第2到最后之间的字符，得到结果ianpin Yuan\nprint (name[-1]) #打印 索引字符串的倒数第1个字符，得到结果n\nprint (name[1+1*2]) #打印 索引字符串的倒数第4个字符，得到结果n\nprint (\"Q\" + name[1:]) #打印 Q+name的第二到结尾的字符，使其变成一个新名字\nprint (name.find(\"in\",6)) #打印 在name里的第7位开始查找in，得到-1，代表在找到底都没有找到in\n查找字符串中的字符串\n爬虫程序在网页里寻找a href链接，并且输入这个rul地址\npage =('<div id=\"top_bin\"><div id=\"top_content\" class=\"width960\">'\n'<div class=\"udacity float-left\"><a href=\"http://udacity.com\">') #网页内容\nstart_link = page.find('<a href=') #找到<a href=的位置\nstart_url = page.find(\"http\",start_link) #从<a href=的位置开始寻找http，也就是url开始的地方。这个方法有个缺陷就是站内链接是不包含http的，所以通过搜索\"更合适\nend_of_url = page.find('\">',start_link) #搜索\">来确定url结束的位置\nurl = page[start_url:end_of_url] #索取url开始位置与结束位置之间的内容\nprint (url)\n以上是我的写法，下面是课程的写法。课程的方法明显更好\npage =('<div id=\"top_bin\"><div id=\"top_content\" class=\"width960\">'\n'<div class=\"udacity float-left\"><a href=\"http://udacity.com\">') #网页内容\nstart_link = page.find('<a href=') #找到<a href=的位置\nstart_quote = page.find('\"',start_link) #从<a href=的位置开始寻找\"，也就是url开始的地方。\nend_quote = page.find('\"',start_link + 1) #搜索第2个\"来确定url结束的位置，如果不+1的话，找到的位置还是第一个\"的位置\nurl = page[start_url + 1:end_of_url] #索取url开始位置与结束位置之间的内容，如果不加1，那么\"也会包含在url里面\nprint (url)\n在变量text中找到第2个zip的位置\n方法1，申明一个新的变量,基于这个变量+1寻找下一个zip的位置\ntext = \"all zip files are zipped\"\nnew_text = text.find(\"zip\")\nprint (text.find(\"zip\",new_text +1))\n方法2，套用第一次find找到的位置+1\nprint (text.find(\"zip\",text.find(\"zip\")+1))\n我因为看不太懂题目的意思，以为是只能写一行代码，想了好久写出了第2个方法\n将数字变成字符串\nx=3.1314\nnewx=str(x) #数字3.1314转换成字符串3.1314了\n四舍五入\n方法1，我编写的方法str(x).find(\".\")是找到小数点在x中的位置x的小数点后1位找5，找到原X+1，找不到原X+0\nx = 9.84159\nx = x + str(x)[str(x).find(\".\") +1:str(x).find(\".\") +2].find(\"5\") + 1\nx = x + str(x)[str(x).find(\".\") +1:str(x).find(\".\") +2].find(\"6\") + 1\nx = x + str(x)[str(x).find(\".\") +1:str(x).find(\".\") +2].find(\"7\") + 1\nx = x + str(x)[str(x).find(\".\") +1:str(x).find(\".\") +2].find(\"8\") + 1\nx = x + str(x)[str(x).find(\".\") +1:str(x).find(\".\") +2].find(\"9\") + 1\nprint (str(x)[:str(x).find(\".\")])\n方法2，老师的方法X+0.5，然后取小数点前面的整数花了2个小时解出来上面方法1的我，瞬间受到了1万点伤害，趴在地上吐血半小时\nx = 9.84159\nx = x + 0.5\nprint (str(x)[:str(x).find(\".\")])\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "2"}