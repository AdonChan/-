{"title": "正则化&&逻辑回归 - 个人文章 ", "index": "机器学习,python,tensorflow", "content": "正则化：简单性\n查看以下泛化曲线，该曲线显示的是训练集和验证集相对于训练迭代次数的损失。\n上图显示的是某个模型的训练损失逐渐减少，但验证损失最终增加。换言之，该泛化曲线显示该模型与训练集中的数据过拟合。根据奥卡姆剃刀定律，或许我们可以通过降低复杂模型的复杂度来防止过拟合，这种原则称为正则化。\n一般来说，监督学习可以看做最小化下面的目标函数.其中，第一项L(yi,f(xi;w)) 衡量我们的模型（分类或者回归）对第i个样本的预测值f(xi;w)和真实的标签yi之前的误差.第二项，也就是对参数w的规则化函数Ω(w)去约束我们的模型尽量的简单\n\n我们不仅要保证训练误差最小，我们更希望我们的模型测试误差小，所以我们需要加上第二项，也就是对参数w的规则化函数Ω(w)去约束我们的模型尽量的简单,机器学习的大部分带参模型都和这个不但形似，而且神似。是的，其实大部分无非就是变换这两项而已。对于第一项Loss函数，如果是Square loss，那就是最小二乘了；如果是Hinge Loss，那就是著名的SVM了；如果是exp-Loss，那就是牛逼的 Boosting了；如果是log-Loss，那就是Logistic Regression了；还有等等。不同的loss函数，具有不同的拟合特性，这个也得就具体问题具体分析的\n在这之前，我们都是以最小化损失（经验风险最小化）为目标：\n但训练损失小并不是我们的最终目标，我们的目标是希望模型的测试损失小，也就是能准确的预测新的样本。所以，我们需要保证模型“简单”的基础上最小化训练误差，这样得到的参数才具有好的泛化性能。现在是以最小化损失和复杂度为目标，这称为结构风险最小化：\n\n现在，我们的训练优化算法是一个由两项内容组成的函数：一个是损失项，用于衡量模型与数据的拟合度，另一个是正则化项，用于衡量模型复杂度。\n详细理解正则化L1范数和L0范数可以实现稀疏，L1因具有比L0更好的优化求解特性而被广泛应用。L1会趋向于产生少量的特征，而其他的特征都是0，而L2会选择更多的特征，这些特征都会接近于0\n这里，只考虑 L2 正则化公式来量化复杂度，该公式将正则化项定义为所有特征权重的平方和：\n\n在这个公式中，接近于 0 的权重对模型复杂度几乎没有影响，而离群值权重则可能会产生巨大的影响。例如，某个线性模型具有以下权重：{w1 = 0.2, w2 = 0.5, w3 = 5, w4 = 1, w5 = 0.25, w6 = 0.75}\nL2 正则化项为各权重平方和： 26.915\n但是 w3的平方值为 25，几乎贡献了全部的复杂度。所有 5 个其他权重的平方和对 L2 正则化项的贡献仅为 1.915。所以我们让L2范数的规则项||W||2最小，可以使得W的每个元素都很小，都接近于0。，但与L1范数不同，它不会让它等于0，而是接近于0，这里是有很大的区别的哦。而越小的参数说明模型越简单，越简单的模型则越不容易产生过拟合现象。为什么越小的参数说明模型越简单？我也不懂，我的理解是：限制了参数很小，实际上就限制了多项式某些分量的影响很小（看上面线性回归的模型的那个拟合的图），这样就相当于减少参数个数。这里也一句话总结下：通过L2范数，我们可以实现了对模型空间的限制，从而在一定程度上避免了过拟合。\n简化正则化：lambda\n模型开发者通过以下方式来调整正则化项的整体影响：用正则化项的值乘以名为 lambda（又称为正则化率）的标量。也就是说，模型开发者会执行以下运算：\n\n执行 L2 正则化对模型具有以下影响\n\n使权重值接近于 0（但并非正好为 0）\n使权重的平均值接近于 0，且呈正态（钟形曲线或高斯曲线）分布。\n\n增加 lambda 值将增强正则化效果。 例如，lambda 值较高的权重直方图可能会如图所示。\n\n降低 lambda 的值往往会得出比较平缓的直方图\n\n在选择 lambda 值时，目标是在简单化和训练数据拟合之间达到适当的平衡：\n\n如果您的 lambda 值过高(注重考虑正则，模型偏向于优化复杂模型)，则模型会非常简单，但是您将面临数据欠拟合的风险。您的模型将无法从训练数据中获得足够的信息来做出有用的预测。\n如果您的 lambda 值过低(注重考虑训练损失)，则模型会比较复杂，并且您将面临数据过拟合的风险。您的模型将因获得过多训练数据特点方面的信息而无法泛化到新数据。\n\nL2 正则化可能会导致对于某些信息缺乏的特征，模型会学到适中的权重。L2 正则化降低较大权重的程度高于降低较小权重的程度。随着权重越来越接近于 0.0，L2 将权重“推”向 0.0 的力度越来越弱。L2 正则化会使相似度高(存在噪点)两个特征的权重几乎相同\n逻辑回归：Logistic Regression\n逻辑回归会生成一个介于 0 到 1 之间（不包括 0 和 1）的概率值，而不是确切地预测结果是 0 还是 1。以用于检测垃圾邮件的逻辑回归模型为例。如果此模型推断某一特定电子邮件的值为 0.932，则意味着该电子邮件是垃圾邮件的概率为 93.2%。更准确地说，这意味着在无限训练样本的极限情况下，模型预测其值为 0.932 的这组样本实际上有 93.2% 是垃圾邮件，其余的 6.8% 不是垃圾邮件。\n逻辑回归模型如何确保输出值始终落在 0 和 1 之间。巧合的是，S 型函数生成的输出值正好具有这些特性，其定义如下：\n\nS型函数会产生以下曲线图：\n\n如果 z 表示使用逻辑回归训练的模型的线性层的输出，则 S 型(z) 函数会生成一个介于 0 和 1 之间的值（概率）。用数学方法表示为：\n\n其中：\n\ny' 是逻辑回归模型针对特定样本的输出。\n\nz 是 b + w1x1 + w2x2 + … wNxN\n   - “w”值是该模型学习的权重和偏差。\n   - “x”值是特定样本的特征值。\n\n\n\n请注意，z 也称为对数几率，因为 S 型函数的反函数表明，z 可定义为标签“1”（例如“狗叫”）的概率除以标签“0”（例如“狗不叫”）的概率得出的值的对数：\n\n假设我们的样本是{x, y}，y是0或者1，表示正类或者负类，x是我们的m维的样本特征向量。那么这个样本x属于正类，也就是y=1的“概率”可以通过下面的逻辑函数来表示：\n\n这里θ是模型参数，也就是回归系数，σ是sigmoid函数。实际上这个函数是由下面的对数几率（也就是x属于正类的可能性和负类的可能性的比值的对数）变换得到的：\n\n逻辑回归与线性回归的不同点在于：为了将线性回归输出的很大范围的数，例如从负无穷到正无穷，压缩到0和1之间，这样的输出值表达为“可能性”才能说服广大民众。。另外，对于二分类来说，可以简单的认为：如果样本x属于正类的概率大于0.5，那么就判定它是正类，否则就是负类。所以说，LogisticRegression 就是一个被logistic方程归一化后的线性回归，仅此而已。\n逻辑回归的损失函数\n线性回归的损失函数是平方损失。逻辑回归的损失函数是对数损失函数，定义如下：\n\n其中：\n\n(xy)ϵD 是包含很多有标签样本 (x,y) 的数据集。\n“y”是有标签样本中的标签。由于这是逻辑回归，因此“y”的每个值必须是 0 或 1。\n“y'”是对于特征集“x”的预测值（介于 0 和 1 之间）。\n\n对数损失函数的方程式与 Shannon 信息论中的熵测量密切相关。它也是似然函数的负对数（假设“y”属于伯努利分布）。实际上，最大限度地降低损失函数的值会生成最大的似然估计值。\n上图中，当接近其中一个条形时，损失就会变得越大，而且变化速度非常惊人。这些渐近线的作用是非常重要的。否则，在指定的数据集上，模型会尽可能更紧密地拟合数据，让损失接近于0. 因此，大多数逻辑回归模型会使用以下两个策略之一来降低模型复杂性：\n\nL2 正则化。\n早停法，即，限制训练步数或学习速率。\n\n正则化在逻辑回归建模中极其重要。如果没有正则化，逻辑回归的渐近性会不断促使损失在高维度空间内达到 0.\n假设您向每个样本分配一个唯一 ID，且将每个 ID 映射到其自己的特征。如果您未指定正则化函数，模型会变得完全过拟合。这是因为模型会尝试促使所有样本的损失达到 0 但始终达不到，从而使每个指示器特征的权重接近正无穷或负无穷。当有大量罕见的特征组合且每个样本中仅一个时，包含特征组合的高维度数据会出现这种情况。幸运的是，使用 L2 或早停法可以防止出现此类问题。\n逻辑回归特点：容易扩展到庞大的数据中；预测速度快，可用于延迟时间极短的预测如果我们需要非线性逻辑回归，可添加特征交叉乘积来实现。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "2"}