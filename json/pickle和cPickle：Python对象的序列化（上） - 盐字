{"title": "pickle和cPickle：Python对象的序列化（上） - 盐字 ", "index": "技术文档,多进程,序列化,python", "content": "目的：Python对象序列化\n可用性：pickle至少1.4版本，cPickle 1.5版本以上\n\n\npickle模块实现了一种算法，将任意一个Python对象转化成一系列字节（byets）。此过程也调用了serializing对象。代表对象的字节流之后可以被传输或存储，再重构后创建一个拥有相同特征（the same characteristics）的新的对象。\n\ncPickle使用C而不是Python，实现了相同的算法。这比Python实现要快好几倍，但是它不允许用户从Pickle派生子类。如果子类对你的使用来说无关紧要，那么cPickle是个更好的选择。\n\n警告:本文档直接说明，pickle不提供安全保证。如果你在多线程通信（inter-process communication）或者数据存储或存储数据中使用pickle，一定要小心。请勿信任你不能确定为安全的数据。\n\n导入\n\n如平常一样，尝试导入cPickle，给它赋予一个别名“pickle”。如果因为某些原因导入失败，退而求其次到Python的原生（native）实现pickle模块。如果cPickle可用，能给你提供一个更快速的执行，否则只能是轻便的执行（the portable implementation）。\n\npythontry:\n   import cPickle as pickle\nexcept:\n   import pickle\n\n\n编码和解码\n\n第一个例子将一种数据结构编码成一个字符串，然后把该字符串打印至控制台。使用一种包含所有原生类型（native types）的数据结构。任何类型的实例都可被腌渍（pickled，译者注：模块名称pickle的中文含义为腌菜），在稍后的例子中会演示。使用pickle.dumps()来创建一个表示该对象值的字符串。\n\npythontry:\n    import cPickle as pickle\nexcept:\n    import pickle\nimport pprint\n\ndata = [ { 'a':'A', 'b':2, 'c':3.0 } ]\nprint 'DATA:',\npprint.pprint(data)\n\ndata_string = pickle.dumps(data)\nprint 'PICKLE:', data_string\n\n\npickle默认仅由ASCII字符组成。也可以使用更高效的二进制格式（binary format），只是因为在打印的时候更易于理解，本页的所有例子都使用ASCII输出。\n\npython$ python pickle_string.py\n\nDATA:[{'a': 'A', 'b': 2, 'c': 3.0}]\nPICKLE: (lp1\n(dp2\nS'a'\nS'A'\nsS'c'\nF3\nsS'b'\nI2\nsa.\n\n\n数据被序列化以后，你可以将它们写入文件、套接字、管道等等中。之后你也可以从文件中读取出来、将它反腌渍（unpickled）而构造一个具有相同值得新对象。\n\npythontry:\n    import cPickle as pickle\nexcept:\n    import pickle\nimport pprint\n\ndata1 = [ { 'a':'A', 'b':2, 'c':3.0 } ]\nprint 'BEFORE:',\npprint.pprint(data1)\n\ndata1_string = pickle.dumps(data1)\n\ndata2 = pickle.loads(data1_string)\nprint 'AFTER:',\npprint.pprint(data2)\n\nprint 'SAME?:', (data1 is data2)\nprint 'EQUAL?:', (data1 == data2)\n\n\n如你所见，这个新构造的对象与原对象相同，但并非同一对象。这不足为奇。\n\npython$ python pickle_unpickle.py\n\nBEFORE:[{'a': 'A', 'b': 2, 'c': 3.0}]\nAFTER:[{'a': 'A', 'b': 2, 'c': 3.0}]\nSAME?: False\nEQUAL?: True\n\n\n与流一起工作\n\n除dumps()和loads()外，pickle还提供一对用在类文件流（file-like streams）的转化函数。可以往一个流中写对个对象，然后从流中把它们读取出来，此过程不需要预先写入的对象有几个、它们多大。\n\npythontry:\n    import cPickle as pickle\nexcept:\n    import pickle\nimport pprint\nfrom StringIO import StringIO\n\nclass SimpleObject(object):\n\n    def __init__(self, name):\n        self.name = name\n        l = list(name)\n        l.reverse()\n        self.name_backwards = ''.join(l)\n        return\n\ndata = []\ndata.append(SimpleObject('pickle'))\ndata.append(SimpleObject('cPickle'))\ndata.append(SimpleObject('last'))\n\n# 使用StringIO模拟一个文件\nout_s = StringIO()\n\n# 写入该流\nfor o in data:\n    print 'WRITING: %s (%s)' % (o.name, o.name_backwards)\n    pickle.dump(o, out_s)\n    out_s.flush()\n\n# 建立一个可读流\nin_s = StringIO(out_s.getvalue())\n\n# 读数据\nwhile True:\n    try:\n        o = pickle.load(in_s)\n    except EOFError:\n        break\n    else:\n        print 'READ: %s (%s)' % (o.name, o.name_backwards)\n\n\n这个例子使用SringIO缓存器（buffer）模拟流，所以在建立可读流的时候我们玩了一把。一个简单数据库的格式化也可以使用pickles来存储对象，只是shelve与之工作更加简便。\n\npython$ python pickle_stream.py\n\nWRITING: pickle (elkcip)\nWRITING: cPickle (elkciPc)\nWRITING: last (tsal)\nREAD: pickle (elkcip)\nREAD: cPickle (elkciPc)\nREAD: last (tsal)\n\n\n除了存储数据，pickles在进程间通信（inter-process communication）中也非常称手。例如，使用os.fork()和os.pipe()可以创立工作者进程（worker processes），从一个管道（pipe）读取作业指令（job instruction）然后将结果写入另一个管道。管理工作者池（worker pool）和将作业送入、接受响应（response）的核心代码可被重用，因为作业和响应并不属于某个特定类中。如果你使用管道或者套接字（sockets），在通过连至另一端（end）的连接倾倒（dumps）所有对象、推送数据之后，别忘了冲洗（flush）。如果你想写自己的工作者池管理器，请看multiprocessing。\n\n\n  原文：pickle and cPickle – Python object serialization - Python Module of the Week 的前半部分\n\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "4"}