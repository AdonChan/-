{"title": "基本线性数据结构的Python实现 - 代码时间 ", "index": "数据结构与算法,数据结构,python", "content": "本篇主要实现四种数据结构，分别是数组、堆栈、队列、链表。我不知道我为什么要用Python来干C干的事情，总之Python就是可以干。\n所有概念性内容可以在参考资料中找到出处\n数组\n数组的设计\n数组设计之初是在形式上依赖内存分配而成的，所以必须在使用前预先请求空间。这使得数组有以下特性：\n\n请求空间以后大小固定，不能再改变（数据溢出问题）；\n在内存中有空间连续性的表现，中间不会存在其他程序需要调用的数据，为此数组的专用内存空间；\n在旧式编程语言中（如有中阶语言之称的C），程序不会对数组的操作做下界判断，也就有潜在的越界操作的风险（比如会把数据写在运行中程序需要调用的核心部分的内存上）。\n\n因为简单数组强烈倚赖电脑硬件之内存，所以不适用于现代的程序设计。欲使用可变大小、硬件无关性的数据类型，Java等程序设计语言均提供了更高级的数据结构：ArrayList、Vector等动态数组。\nPython的数组\n从严格意义上来说:Python里没有严格意义上的数组。List可以说是Python里的数组，下面这段代码是CPython的实现List的结构体:\ntypedef struct {\n    PyObject_VAR_HEAD\n    /* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */\n    PyObject **ob_item;\n\n    /* ob_item contains space for 'allocated' elements.  The number\n     * currently in use is ob_size.\n     * Invariants:\n     *     0 <= ob_size <= allocated\n     *     len(list) == ob_size\n     *     ob_item == NULL implies ob_size == allocated == 0\n     * list.sort() temporarily sets allocated to -1 to detect mutations.\n     *\n     * Items must normally not be NULL, except during construction when\n     * the list is not yet visible outside the function that builds it.\n     */\n    Py_ssize_t allocated;\n} PyListObject;\n取自CPython-Github\n还有一篇文章讲List实现,感兴趣的朋友可以去看看。中文版。\n当然，在Python里它就是数组。后面的一些结构也将用List来实现。\n堆栈\n什么是堆栈\n堆栈（英语：stack），也可直接称栈，在计算机科学中，是一种特殊的串列形式的数据结构，它的特殊之处在于只能允许在链接串列或阵列的一端（称为堆叠顶端指标，英语：top）进行加入资料（英语：push）和输出资料（英语：pop）的运算。另外堆叠也可以用一维阵列或连结串列的形式来完成。堆叠的另外一个相对的操作方式称为伫列。\n由于堆叠数据结构只允许在一端进行操作，因而按照后进先出（LIFO, Last In First Out）的原理运作。\n特点\n\n先入后出，后入先出。\n除头尾节点之外，每个元素有一个前驱，一个后继。\n\n操作\n从原理可知，对堆栈(栈)可以进行的操作有:\n\ntop():获取堆栈顶端对象\npush():向栈里添加一个对象\npop():从栈里推出一个对象\n\n实现\nclass my_stack(object):\n    def __init__(self, value):\n        self.value = value\n        # 前驱\n        self.before = None\n        # 后继\n        self.behind = None\n\n    def __str__(self):\n        return str(self.value)\n\n\ndef top(stack):\n    if isinstance(stack, my_stack):\n        if stack.behind is not None:\n            return top(stack.behind)\n        else:\n            return stack\n\n\ndef push(stack, ele):\n    push_ele = my_stack(ele)\n    if isinstance(stack, my_stack):\n      stack_top = top(stack)\n      push_ele.before = stack_top\n      push_ele.before.behind = push_ele\n    else:\n      raise Exception('不要乱扔东西进来好么')\n\n\ndef pop(stack):\n    if isinstance(stack, my_stack):\n        stack_top = top(stack)\n        if stack_top.before is not None:\n            stack_top.before.behind = None\n            stack_top.behind = None\n            return stack_top\n        else:\n            print('已经是栈顶了')\n队列\n什么是队列\n和堆栈类似，唯一的区别是队列只能在队头进行出队操作，所以队列是是先进先出（FIFO, First-In-First-Out）的线性表\n特点\n\n先入先出,后入后出\n除尾节点外,每个节点有一个后继\n（可选）除头节点外,每个节点有一个前驱\n\n操作\n\npush（）:入队\npop（）：出队\n\n实现\n普通队列\nclass MyQueue():\n    def __init__(self, value=None):\n        self.value = value\n        # 前驱\n        # self.before = None\n        # 后继\n        self.behind = None\n\n    def __str__(self):\n        if self.value is not None:\n            return str(self.value)\n        else:\n            return 'None'\n\n\ndef create_queue():\n    \"\"\"仅有队头\"\"\"\n    return MyQueue()\n\n\ndef last(queue):\n    if isinstance(queue, MyQueue):\n        if queue.behind is not None:\n            return last(queue.behind)\n        else:\n            return queue\n\n\ndef push(queue, ele):\n    if isinstance(queue, MyQueue):\n        last_queue = last(queue)\n        new_queue = MyQueue(ele)\n        last_queue.behind = new_queue\n\n\ndef pop(queue):\n    if queue.behind is not None:\n        get_queue = queue.behind\n        queue.behind = queue.behind.behind\n        return get_queue\n    else:\n        print('队列里已经没有元素了')\n\ndef print_queue(queue):\n    print(queue)\n    if queue.behind is not None:\n        print_queue(queue.behind)\n链表\n什么是链表\n链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。\n特点\n使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。\n操作\n\ninit():初始化\ninsert(): 插入\ntrave(): 遍历\ndelete(): 删除\nfind(): 查找\n\n实现\n此处仅实现双向列表\nclass LinkedList():\n    def __init__(self, value=None):\n        self.value = value\n        # 前驱\n        self.before = None\n        # 后继\n        self.behind = None\n\n    def __str__(self):\n        if self.value is not None:\n            return str(self.value)\n        else:\n            return 'None'\n\n\ndef init():\n    return LinkedList('HEAD')\n\n\ndef delete(linked_list):\n    if isinstance(linked_list, LinkedList):\n        if linked_list.behind is not None:\n            delete(linked_list.behind)\n            linked_list.behind = None\n            linked_list.before = None\n        linked_list.value = None\n\n\ndef insert(linked_list, index, node):\n    node = LinkedList(node)\n    if isinstance(linked_list, LinkedList):\n        i = 0\n        while linked_list.behind is not None:\n            if i == index:\n                break\n            i += 1\n            linked_list = linked_list.behind\n        if linked_list.behind is not None:\n            node.behind = linked_list.behind\n            linked_list.behind.before = node\n        node.before, linked_list.behind = linked_list, node\n\n\ndef remove(linked_list, index):\n    if isinstance(linked_list, LinkedList):\n        i = 0\n        while linked_list.behind is not None:\n            if i == index:\n                break\n            i += 1\n            linked_list = linked_list.behind\n        if linked_list.behind is not None:\n            linked_list.behind.before = linked_list.before\n        if linked_list.before is not None:\n            linked_list.before.behind = linked_list.behind\n        linked_list.behind = None\n        linked_list.before = None\n        linked_list.value = None\n\n\ndef trave(linked_list):\n    if isinstance(linked_list, LinkedList):\n        print(linked_list)\n        if linked_list.behind is not None:\n            trave(linked_list.behind)\n\n\ndef find(linked_list, index):\n    if isinstance(linked_list, LinkedList):\n        i = 0\n        while linked_list.behind is not None:\n            if i == index:\n                return linked_list\n            i += 1\n            linked_list = linked_list.behind\n        else:\n            if i < index:\n                raise Exception(404)\n            return linked_list\n以上所有源代码均在Github共享，欢迎提出issue或PR，希望与大家共同进步!\n\n参考资料\nWiki百科: 数据结构、数组、队列、链表\n\nEOF\n转载请注明出处：https://zhuanlan.zhihu.com/p/...\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "5"}