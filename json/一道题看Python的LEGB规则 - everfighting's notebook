{"title": "一道题看Python的LEGB规则 - everfighting's notebook ", "index": "python", "content": "例题\n《核心编程(第二版)》变量作用域和命名空间一节有以下一道题目\n# coding=utf-8\n#!/usr/bin/env python\n\ndef proc1():\n    j,k = 3,4\n    print \"j == %d and k == %d\" % (j,k)\n    k = 5\n\ndef proc2():\n    j = 6\n    proc1()\n    print \"j == %d and k == %d\" % (j,k)\n\nk = 7\nproc1()\nprint \"j == %d and k == %d\" % (j,k)\n\nj = 8\nproc2()\nprint \"j == %d and k == %d\" % (j,k)\n\n请问输出结果是什么？\n要想解这道题，必须先了解Python中的一些概念：\nLEGB\nPython 的变量名解析机制有时称为LEGB。\nL: Local 是函数内的名字空间，包括局部变量和形参E: Enclosing 外部嵌套函数的名字空间（闭包中常见）G: Global 全局变量，函数定义所在模块的名字空间B: Builtin 内置模块的名字空间\n查找的顺序为：L--->E--->G--->B查找一个x 的变量，Python 首先在函数内部，局部（Local）范围来查找这个变量；\n如果没有找到，则到包含这个函数定义的外围去查找（称作 Enclosing)，这个外围或许是另外一个函数（包括匿名函数）。\n如果还是没有，继续朝外查找，一直到模块级别，从这里定义了全局（Global）变量中寻找；\n如果仍然没有找到，则查找 Python 内置变量(Built-in)，看是否有相同名字的。\n注：在上述查找过程中，一旦变量找到，就不再继续朝外围查找。也就是说 LEGB 同时也定义了从 L 到 B 得优先级。\n题解\n上题目输出结果如下：\nj == 3 and k == 4\nname 'j' is not defined #注释对应代码后出现以下三列结果\nj == 3 and k == 4\nj == 6 and k == 7\nj == 8 and k == 7\n\n具体解释如下：\n\nproc1() 函数内部就有j,k，停止向上查找，故j == 3 and k == 4\nprint \"j == %d and k == %d\" % (j,k),程序从上往下执行，当前只定义k=7,j还未定义，因为已经是全局变量了，Builtin中未定义j,因此返回未定义的错误。\nproc2()中会调用proc1()依旧先打印j == 3 and k == 4   proc2()内部需要打印，j,k值，j本地已经定义为6，k未定义，则向上查找，查找到全局变另种定义了k=7,因此输出：j == 6 and k == 7\nprint \"j == %d and k == %d\" % (j,k)，前面的程序已经给j,k进行了赋值，直接输出即可，j == 8 and k == 7\n\n来源参考：\n1.理解 Python 的 LEGB2.零基础学python-16.3 变量名解析：LEGB原则\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "2"}