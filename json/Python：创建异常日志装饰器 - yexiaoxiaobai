{"title": "Python：创建异常日志装饰器 - yexiaoxiaobai ", "index": "logger,装饰器,decorator,exception,python", "content": "Python: How to Create an Exception Logging Decorator\nexception_decor.py\nimport functools\nimport logging\n \ndef create_logger():\n    \"\"\"\n    Creates a logging object and returns it\n    \"\"\"\n    logger = logging.getLogger(\"example_logger\")\n    logger.setLevel(logging.INFO)\n \n    # create the logging file handler\n    fh = logging.FileHandler(\"/path/to/test.log\")\n \n    fmt = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n    formatter = logging.Formatter(fmt)\n    fh.setFormatter(formatter)\n \n    # add handler to logger object\n    logger.addHandler(fh)\n    return logger\n \n \ndef exception(function):\n    \"\"\"\n    A decorator that wraps the passed in function and logs \n    exceptions should one occur\n    \"\"\"\n    @functools.wraps(function)\n    def wrapper(*args, **kwargs):\n        logger = create_logger()\n        try:\n            return function(*args, **kwargs)\n        except:\n            # log the exception\n            err = \"There was an exception in  \"\n            err += function.__name__\n            logger.exception(err)\n \n            # re-raise the exception\n            raise\n    return wrapper\n\n在该代码中，有两个函数。第一个函数创建了日志对象并返回该日志对象。第二个函数是我们的装饰器函数。我们在一个try/except中封装传递的函数，当logger中发生任何异常的时候，进行日志记录。并且我还记录了当异常发生时的函数名称。\n现在让我们测试下该装饰器。\n\n    from exception_decor import exception\n     \n    @exception\n    def zero_divide():\n        1 / 0\n     \n    if __name__ == '__main__':\n        zero_divide()\n\n运行以上测试代码后，会出现以下错误日志：\n2016-06-09 08:26:50,874 - example_logger - ERROR - There was an exception in  zero_divide\nTraceback (most recent call last):\n  File \"/home/mike/exception_decor.py\", line 29, in wrapper\n    return function(*args, **kwargs)\n  File \"/home/mike/test_exceptions.py\", line 5, in zero_divide\n    1 / 0\nZeroDivisionError: integer division or modulo by zero\n传递一个 logger 到装饰器\n# exception_logger.py\n \nimport logging\n \ndef create_logger():\n    \"\"\"\n    Creates a logging object and returns it\n    \"\"\"\n    logger = logging.getLogger(\"example_logger\")\n    logger.setLevel(logging.INFO)\n \n    # create the logging file handler\n    fh = logging.FileHandler(r\"/path/to/test.log\")\n \n    fmt = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n    formatter = logging.Formatter(fmt)\n    fh.setFormatter(formatter)\n \n    # add handler to logger object\n    logger.addHandler(fh)\n    return logger\n \nlogger = create_logger()\n现在修改前面出现的装饰器，以便可以接受 logger 作为参数。\n# exception_decor.py\n \nimport functools\n \n \ndef exception(logger):\n    \"\"\"\n    A decorator that wraps the passed in function and logs \n    exceptions should one occur\n \n    @param logger: The logging object\n    \"\"\"\n \n    def decorator(func):\n \n        def wrapper(*args, **kwargs):\n            try:\n                return func(*args, **kwargs)\n            except:\n                # log the exception\n                err = \"There was an exception in  \"\n                err += func.__name__\n                logger.exception(err)\n \n            # re-raise the exception\n            raise\n        return wrapper\n    return decorator\n最后修改测试脚本：\nfrom exception_decor import exception\nfrom exception_logger import logger\n \n@exception(logger)\ndef zero_divide():\n    1 / 0\n \nif __name__ == '__main__':\n    zero_divide()\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "6"}