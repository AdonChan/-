{"title": "由一个例子到python的名字空间 - shomy ", "index": "namespaces,python", "content": "源自我的博客\n前言\npython里面最核心的内容就是:名字空间(namespace)\n\n例子引入\n例1\n#!/usr/bin/env python\n# encoding: utf-8\n\n\ndef func1():\n    x = 1\n    print globals()\n    print 'before func1:', locals()\n\n    def func2():\n        a = 1\n        print 'before fun2:', locals()\n        a += x\n        print 'after fun2:', locals()\n\n    func2()\n    print 'after func1:', locals()\n    print globals()\n\nif __name__ == '__main__':\n    func1()\n可以正常输出结果：　并且需要注意，在func2使用x变量之前的名字空间就已经有了'x':1.\nbefore func1: {'x': 1}\nbefore fun2: {'a': 1, 'x': 1}\nafter fun2: {'a': 2, 'x': 1}\nafter func1: {'x': 1, 'func2': <function func2 at 0x7f7c89700b90>}\n稍微改一点:如下\n例2:\n#!/usr/bin/env python\n# encoding: utf-8\n\n\ndef func1():\n    x = 1\n    print 'before func1:', locals()\n\n    def func2():\n        print 'before fun2:', locals()\n        x += x #就是这里使用x其余地方不变\n        print 'after fun2:', locals()\n\n    func2()\n    print 'after func1:', locals()\n\nif __name__ == '__main__':\n    func1()\n输出就开始报错: 而且在before func2也没有了x.\nbefore func1: {'x': 1}\nbefore fun2: {}\nTraceback (most recent call last):\n  File \"test.py\", line 18, in <module>\n    func1()\n  File \"test.py\", line 14, in func1\n    func2()\n  File \"test.py\", line 11, in func2\n    x += x\nUnboundLocalError: local variable 'x' referenced before assignment\n\n这两个例子正好涉及到了python里面最核心的内容：名字空间，正好总结一下，然后在解释这几个例子。\n\n名字空间(Namespace)\n比如我们定义一个\"变量\"\nIn [14]: a\nNameError: name 'a' is not defined\n所以，这里更准确的叫法应该是名字。 一些语言中比如c,c++,java 变量名是内存地址别名, 而Python 的名字就是一个字符串，它与所指向的目标对象关联构成名字空间里面的一个键值对{name: object}，因此可以这么说，python的名字空间就是一个字典.。\n分类\npython里面有很多名字空间，每个地方都有自己的名字空间，互不干扰，不同空间中的两个相同名字的变量之间没有任何联系一般有4种: LEGB四种\n\nlocals: 函数内部的名字空间，一般包括函数的局部变量以及形式参数\nenclosiing function: 在嵌套函数中外部函数的名字空间, 对fun2来说，　fun1的名字空间就是。\nglobals: 当前的模块空间，模块就是一些py文件。也就是说，globals()类似全局变量。\n__builtins__:  内置模块空间，　也就是内置变量或者内置函数的名字空间。\n\n当程序引用某个变量的名字时，就会从当前名字空间开始搜索。搜索顺序规则便是: LEGB.\nlocals  -> enclosing function -> globals -> __builtins\n一层一层的查找，找到了之后，便停止搜索，如果最后没有找到,则抛出在NameError的异常。这里暂时先不讨论赋值操作。比如例1中的a = x + 1　这行代码，需要引用x, 则按照LEGB的顺序查找，locals()也就是func2的名字空间没有，进而开始E，也就是func1,里面有，找到了，停止搜索，还有后续工作，就是把x也加到自己的名字空间，这也是为什么fun2的名字空间里面也有x的原因。\n访问方式\n其实上面都已经说了，这里暂时简单列一下\n\n使用locals()访问局部命名空间\n使用globals()访问全局命名空间这里有一点需要注意，就是涉及到了from A import B　和import A的一点区别。\n\n#!/usr/bin/env python\n# encoding: utf-8\n\nimport copy\nfrom copy import deepcopy\n\n\ndef func():\n    x = 123\n    print 'func locals:',locals()\n\ns = 'hello world'\nif __name__ == '__main__':\n    func()\n    print 'globals:', globals()\n输出结果:\nfunc locals: {'x': 123}\nglobals: {'__builtins__': <module '__builtin__' (built-in)>,\n '__file__': 'test.py',\n '__package__': None, \n's': 'hello world',\n'func': <function func at 0x7f1c3d617c80>,\n 'deepcopy': <function deepcopy at 0x7f1c3d6177d0>, \n'__name__': '__main__',\n 'copy': <module 'copy' from '/usr/lib/python2.7/copy.pyc'>, \n'__doc__': None}\n从输出结果可以看出globals()包含了定义的函数，变量等。对于 'deepcopy': <function deepcopy at 0x7f1c3d6177d0>可以看出deepcopy已经被导入到自己的名字空间了，而不是在copy里面。　而导入的import copy则还保留着自身的名字空间。因此要访问copy的方法，就需要使用copy.function了。这也就是为什么推荐使用import module的原因，因为from A import B这样会把B引入自身的名字空间，容易发生覆盖或者说污染。\n生存周期\n每个名字空间都有自己的生存周期，如下:\n\n__builtins__: 在python解释器启动的时候，便已经创建,直到退出\nglobals: 在模块定义被读入时创建，通常也一直保存到解释器退出。\nlocals : 在函数调用时创建, 直到函数返回，或者抛出异常之后，销毁。　另外递归函数每一次均有自己的名字空间。\n\n看着没有问题，但是有很多地方需要考虑。比如名字空间都是在代码编译时期确定的，而不是执行期间。这个也就可以解释为什么在例1中，before func2:的locals()里面包含了x: 1　这一项。再看下面这个，\ndef func():\n    if False:\n        x = 10 #该语句永远不执行\n    print x\n肯定会报错的，但是错误不是\nNameError: global name 'x' is not defined\n而是:\nUnboundLocalError: local variable 'x' referenced before assignment\n虽然x = 10永远不会执行，但是在执行之前的编译阶段，就会把x作为locals变量，但是后面编译到print的时候，发现没有赋值,因此直接抛出异常，locals()里面便不会有x。这个就跟例子2中,before func2里面没有x是一个道理。\n赋值\n为什么要把赋值单独列出来呢，因为赋值操作对名字空间的影响很大，而且很多地方需要注意。核心就是: 赋值修改的是命名空间，而不是对象, 比如:\na = 10\n这个语句就是把a放入到了对应的命名空间, 然后让它指向一个值为10的整数对象。\na = []\na.append(1)\n\n这个就是把a放入到名字空间，然后指向一个列表对象,　然而后面的a.append(1)这句话只是修改了list的内容，并没有修改它的内存地址。因此并没有涉及到修改名字空间。赋值操作有个特点就是: 赋值操作总是在最里层的作用域.也就说，只要编译到了有赋值操作，就会在当前名字空间内新创建一个名字，然后开始才绑定对象。即便该名字已存在于赋值语句发生的上一层作用域中；\n总结\n分析例子\n现在再看例子2, 就清晰多了， x += x 编译到这里时，发现了赋值语句，于是准备把x新加入最内层名字空间也就是func2中，即使上层函数已经存在了;  但是赋值的时候，又要用到x的值， 然后就会报错:\nUnboundLocalError: local variable 'x' referenced before assignment\n这样看起来好像就是  内部函数只可以读取外部函数的变量，而不能做修改，其实本质还是因为赋值涉及到了新建locals()的名字。在稍微改一点:\n#!/usr/bin/env python\n# encoding: utf-8\n\ndef func1():\n    x = [1,2]\n    print 'before func1:', locals()\n\n    def func2():\n        print 'before fun2:', locals()\n        x[0] += x[0] #就是这里使用x[0]其余地方不变\n        print 'after fun2:', locals()\n\n    func2()\n    print 'after func1:', locals()\n\nif __name__ == '__main__':\n    func1()\n\n这个结果就是：\n\nbefore func1: {'x': [1, 2]}\nbefore fun2: {'x': [1, 2]}\nafter fun2: {'x': [2, 2]}\nafter func1: {'x': [2, 2], 'func2': <function func2 at 0x7fb67b253b18>}\n\n咋正确了呢---这不应该要报错吗？ 其实不然，就跟上面的a.append(1)是一个道理。x[0] += x[0] 这个并不是对x的赋值操作。按照LEGB原则， 搜到func1有变量x并且是个list, 然后将其加入到自己的locals(), 后面的x[0] += x[0], 就开始读取x的元素，并没有影响func2的名字空间。另外无论func1与func2的名字空间的x 没有什么关系，只不过都是对[1, 2]这个列表对象的一个引用。这个例子其实也给了我们一个启发，我们知道内部函数无法直接修改外部函数的变量值，如例2，如果借助list的话， 就可以了吧！比如把想要修改的变量塞到一个list里面，然后在内部函数里面做改变！当然python3.x里面有了nonlocal关键字，直接声明一下就可以修改了。看到这里，对作用域理解应该有一点点了吧。\n延伸\n与闭包的不同\n我们都知道闭包是把外部函数的值放到func.func_closure里面，为什么不像上面的例子一样直接放到函数的名字空间呢？这是因为locals()空间是在函数调用的时候才创建！ 而闭包只是返回了一个函数， 并没有调用，也就没有所谓的空间。\nlocals()与globals()\n在最外层的模块空间里locals()就是globals()\nIn [2]: locals() is globals()\nOut[2]: True\n另外我们可以手动修改globals()来创建名字\nIn [3]: globals()['a'] = 'abcde'\nIn [4]: a\nOut[4]: 'abcde'\n但是locals()在函数里面的话， 貌似是不起作用的，如下：\nIn [5]: def func():\n   ...:     x = 10\n   ...:     print x\n   ...:     print locals()\n   ...:     locals()['x'] = 20\n   ...:     print x\nIn [6]: func()\n10\n{'x': 10}\n10\n\n这是因为解释器会将 locals 名字复制到 一个叫FAST的 区域来优化访问速度，而实际上解释器访问对象时，是从FAST区域里面读取的，而非locals()。所以直接修改locals()并不能影响x(可以使用exec 动态访问，不再细述)。 不过赋值操作，会同时刷新locals()和FAST区域。\n\n查了不少资料，说了这么多，我只想说，作为python最核心的东西，名字空间还有很多很多地方需要探究，比如\n\n作用域(scope)与名字空间, 这里只是模糊了二者的区别\n面向对象，也就是类的名字空间， 又有不一样的地方。。。\n\n学一点记录一点吧。\n参考\n123\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "19"}