{"title": "Python3结合Sciter编写桌面程序第三节 - 个人文章 ", "index": "python", "content": "第三节 协程！？\n继续...基础框架搭好了，下面来正式的来一个项目吧\nbehance\n全球设计师的作品展示平台\n就从这拉几张图吧，具体的网页解析方式网上有很多，在此略过，我已经取出了一些图片地址，保存在了list.txt里，这次就用这些吧。\n综合多种因素，最后选用了协程来下载图片\n即asyncio\n框架则用了aiohttp\n实现思路：\n\n\n目的\n将网络上的图片（最好是缩略图）先下载到本地，记录图片信息，比如ID以便获得更高质量的图片，将图片显示到界面\n\n\n问题\n\n为了更快速的展示页面，我需要同时下载一定数量的图片...\n我需要动态的将下载任务发送给后台服务...\n\n\n\n这里可以在程序启动的时候设置一个配置列表cfg\nfrom os import path as osPath, getcwd, mkdir\n...\ndef __init__(self):\n    ...\n    self.cfg = self.initCfg()\n\ndef initCfg(self):\n        cfg = {}\n        # 代理，没有可不用设置\n        # cfg['proxies'] = '127.0.0.1:61274'\n        # 加载图片列表\n        filename = \"list.txt\"\n        if osPath.exists(filename):\n            with open(filename, \"r\") as f:\n                cfg['picList'] = f.read().strip().split(\"\\n\")\n        # 设置图片的保存位置\n        current_folder = getcwd()\n        cfg['pic_temp'] = osPath.join( current_folder, 'pic_temp')\n        if not osPath.isdir( cfg['pic_temp'] ):\n            mkdir(cfg['pic_temp'])\n        return cfg\n然后传递给服务进程就可以了\np = Process(target = startServiceP, args = ( self.GuiQueue, self.ServiceQueue, self.cfg ))\n先来修改一下html的内容，添加一个自定义控件，用来存放图片：\n<section#body>\n    <button class=\"click-me\">点我下载图片</button>\n    <widget id=\"pic-view\"></widget>\n</section>\n在服务进程ServiceEvent里添加一个方法getPicByList()\ndef getPicByList(self, msg):\n        # 为图片创建占位图\n        imgidList = self.__creatPlaceholderImg()\n        for imgid in imgidList:\n            picHttp = self.cfg['picList'].pop(0)\n            file_name = picHttp.split(\"/\")[-1]\n            file_path = osPath.join( self.cfg['pic_temp'], file_name )\n            # 图片下载完成后需要执行的任务\n            _GuiRecvMsgDict = {\n                'fun' : 'setImgBg',\n                'msg' : {'id':imgid,'fpath':file_path}\n            }\n            if not osPath.isfile(file_path):\n                # 将下载任务动态添加到协程循环中\n                self.__run_coroutine_threadsafe(\n                    {'id': imgid,'http': picHttp,'fpath': file_path},\n                    _GuiRecvMsgDict\n                )\n            else:\n                self.__putGui( 'setImgBg', {'id':imgid,'fpath':file_path} )\n当用户点击下载图片的按钮后会执行到这个方法，为了更好的体验，在图片下载之前先为其占据了空间，可以在其上显示loading动画，更重要的一点是，通过它可以控制图片的显示顺序，因为用协程下载图片，你无法预知完成的顺序...\ndef __creatPlaceholderImg(self):\n        # 先创建5个占位图\n        html = ''\n        imgidList = []\n        time_now = ''\n        for i in range(0, 5):\n            time_now = '-'.join( ( str(i), str(time()) ) )\n            # 储存图片的id\n            imgidList.append( time_now )\n            html += self.html % ( time_now )\n        self.__putGui('creatPlaceholderImg', html)\n        return imgidList\n之后就到了动态创建协程的部分了\ndef __run_coroutine_threadsafe(self, data, _GuiRecvMsgDict):\n        asyncio.run_coroutine_threadsafe(self.dld.stream_download(\n            data,\n            _GuiRecvMsgDict\n        ), self.new_loop)\n但在正式介绍run_coroutine_threadsafe()之前，我们需要先开启一个协程循环\n但我们已经开启了一个用于处理队列的循环了，没办法再开一个（也不排除是咱太菜），于是另开了一个线程专来处理协程\nclass ServiceEvent(object):\n    '''服务进程'''\n    def __init__(self, _GuiQueue, cfg):\n        ...\n        # 主线程中创建一个事件循环\n        self.new_loop = asyncio.new_event_loop()\n        self.dld = AsyncioDownload( self.new_loop, self.GuiQueue, self.proxies )\nclass AsyncioDownload(object):\n    '''使用协程下载图片'''\n    def __init__(self, loop, _GuiRecvMsg, proxies=None ):\n        self.GuiRecvMsg = _GuiRecvMsg\n        self._session = None\n        self.loop = loop\n        self.prox = ''.join(('http://', proxies)) if proxies else proxies\n        self.timeout = 10\n        # 启动一个线程，传递主线程中创建的事件循环\n        t = Thread(target=self.start_loop, args=(self.loop,))\n        t.setDaemon(True)    # 设置子线程为守护线程\n        t.start()\n\n    def start_loop(self, loop):\n        # 启动事件循环\n        asyncio.set_event_loop(loop)\n        loop.run_forever()\n\n    def __session(self):\n        if self._session is None:\n            self._session = aiohttp.ClientSession(loop=self.loop)\n        return self._session\n\n    async def stream_download(self, d, _GuiRecvMsgDict):\n        try:\n            client = self.__session()\n            async with client.get( d['http'], proxy=self.prox, timeout=self.timeout) as response:\n                if response.status != 200:\n                    print('error')\n                    return\n                # 保存图片到本地\n                if not osPath.isfile(d['fpath']):\n                    with open(d['fpath'], 'ab') as file:\n                        while True:\n                            chunk = await response.content.read(1024)\n                            if not chunk:\n                                break\n                            file.write(chunk)\n                # 图片下载完成后告知主线程\n                self.GuiRecvMsg.put(_GuiRecvMsgDict)\n        except asyncio.TimeoutError:\n            pass\n最后，主进程获得图片的id及路径，显示到窗口中\nfunction setImgBg( d ){\n    var div = $(div[imgid=\"{d.id}\"]);\n    if(div){\n        div.post( ::this.style#background-image = \"url(\" + d.fpath + \")\" );\n    }\n}\n源码\n总结：\n完成这个项目使用了\n\n多进程  ---- 后台服务\n多线程  ---- 事件循环\n协程      ---- IO操作\n\n相对一个单纯的爬虫脚本来说，还是有点复杂的，尤其是交互，难怪这么多人不愿意写界面...\n虽然还有不足，但本次项目的内容就到这了。\n谢谢。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}