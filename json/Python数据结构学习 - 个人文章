{"title": "Python数据结构学习 - 个人文章 ", "index": "python", "content": "注：本片文章是个人学习总结，内容来自《简明Python教程》\nList 有序列表\nList是一种保存有序项的数据结构。\n项目列表应该使用方括号扩起来，以便 Python 能够理解您正在定义一个列表。一旦创建了列表，你就可以在列表中增加，删除或者搜索列表中的项 。 正因为我们可以增加和删除项，所以我们称列表是一种 可变 数据类型，也就是说这个类型可以被改变。\nshoplist = ['apple','mango','carrot','banana']\n\n<!--获取长度-->\nlen(shoplist)  //4\n\n<!--遍历list-->\nfor item in shoplist:\n    print(item)\n\n<!--添加元素-->\nshoplist.append('rice')\n\n<!--list排序-->\nshoplist.sort()\n\n<!--赋值-->\nshoplist[0] = 'Google'\n\n<!--删除元素-->\ndel shoplist[1]\n元组tuple\n元组用于将多个对象组合在一起。可以将它们近似看作列表，但是没有列表类提供的许多功能。元组的一个重要特征是，它们和字符串一样是 不可变的 ，即你不能修改元组。\n元组是由一些特殊的项定义的，这些项在一对可选的圆括号中，由逗号隔开。\n元组通常用于这种情况，也就是语句或者用户自定义的函数可以安全地认为值的集合（即，值的元组）不会改变的情况。\n<!--元组一旦定义后就不能在进行增删修改-->\n\nzoo = ('Python','Java','JavaScript','php')\n\n==注意：包含0或1个项的元组==一个空的元组是由一堆空的圆括号组成的，例如，myempty = ().\n但是对于一个项的元组且必须仅在第一个项的后面用一个括号来指定该元组，比如\nmyempty = (1,),因为因为如果没有逗号会造成歧义: a = (1)\n\n>>> a = 2\n>>> b = (a,11,22)\n>>> b\n(2, 11, 22)\n>>> a = 3\n>>> b\n(2, 11, 22)\n\n>>> c = [1,1]\n>>> d = (c,22,33)\n>>> d\n([1, 1], 22, 33)\n>>> c[1] = 4\n>>> d\n([1, 4], 22, 33)\n元组中可以包含变量，变量可以改变，但元组的值不会变，元组中变量的值在里第一次创建就确定了，无法通过变量去改变。但是如果你的元组中的变量是一个列表list，那么元组中的值会随着列表list改变而改变\n\n字典\n字典是一种键值对集合，键必须是唯一的，而且键只能用不可变对象，比如字符串，但键值没有多大限制。\nd = {key1:value1,key2:value2}\n字典的常用方法有del删除键值对，添加键值对直接用索引操作符访问一个键并为其赋值，遍历字典则用items方法。\nab = {\n    'Swaroop': 'swaroop@swaroopch.com',\n    'Larry': 'larry@wall.org',\n    'Matsumoto': 'matz@ruby-lang.org',\n    'Spammer': 'spammer@hotmail.com'\n}\n<!--添加键值对-->\nad['addKey'] = 'value'\n\n<!--删除键值对-->\ndel ab['Larry']\n\n<!--遍历字典-->\n\nfor key,value in ad.items():\n    print('Contact {} at {}'.format(key,value)\n序列\n列表list、元组tuple和dict都是序列的一种。\n序列的主要特征是：成员测试（例如：in 与 not in 表达式）和索引操作，这两种操作让我们可以直接从序列中提取特定的部分。\n序列还有一种特殊的操作叫做切片，切片可以让我们得到序列的一部分。\nshoplist = ['apple','mango','carrot','banana']\nname = 'swaroop'\n\n# 字符串索引 #\nprint('Item 0 is', shoplist[0])\nprint('Item 1 is', shoplist[1])\nprint('Item 2 is', shoplist[2])\nprint('Item 3 is', shoplist[3])\nprint('Item -1 is', shoplist[-1])\nprint('Item -2 is', shoplist[-2])\nprint('Character 0 is', name[0])\n\n# 列表切片 #\nprint('Item 1 to 3 is', shoplist[1:3])\nprint('Item 2 to end is', shoplist[2:])\nprint('Item 1 to -1 is', shoplist[1:-1])\nprint('Item start to end is', shoplist[:])\n\n# 字符串切片 #\nprint('characters 1 to 3 is', name[1:3])\nprint('characters 2 to end is', name[2:])\nprint('characters 1 to -1 is', name[1:-1])\nprint('characters start to end is', name[:])\n引用\n当你创建了一个对象，并把它赋值给一个变量时，这个变量只是 引用 了这个对象，变量并不能代表对象自身！因此，你可以把变量名当作一个指针，它指向储存对象的那一块计算机内存。这称作绑定名称到对象。\nprint('Simple Assignment')\nshoplist = ['apple', 'mango', 'carrot', 'banana']\n# mylist 只是指向同一个对象的另一个别名！\nmylist = shoplist\n\n# 我买下了第一件商品，所以把它从列表中移除\ndel shoplist[0]\n\nprint('shoplist is', shoplist)\nprint('mylist is', mylist)\n# 注意到 shoplist 和 mylist 产生了同样的输出\n# 输出的都是没有 'apple' 的相同列表\n# 这验证了它们都指向着同一个对象\n\nprint('Copy by making a full slice')\n# 通过全切片来获得一个副本\nmylist = shoplist[:]\n# 移除第一个元素\ndel mylist[0]\n\nprint('shoplist is', shoplist)\nprint('mylist is', mylist)\n# 注意到现在这两个列表有差异了\n输出：\n$ python ds_reference.py\nSimple Assignment\nshoplist is ['mango', 'carrot', 'banana']\nmylist is ['mango', 'carrot', 'banana']\nCopy by making a full slice\nshoplist is ['mango', 'carrot', 'banana']\nmylist is ['carrot', 'banana']\n记住：如果你想要获得列表、或者类似的序列、或更复杂对象的副本，只要不是像整数一样简单的 对象，你都需要通过切片操作来获得它的副本。如果你直接把一个变量名赋值给另一个，它们两个都会引用同一个对象。在赋值时你需要注意这一点，不然可能会造成意想不到的结果，从而带来麻烦。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}