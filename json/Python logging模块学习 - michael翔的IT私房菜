{"title": "Python logging模块学习 - michael翔的IT私房菜 ", "index": "python", "content": "logging example\n\n\nLevel\nWhen it’s used\nNumeric value\n\n\n\nDEBUG\nDetailed information, typically of interest only when diagnosing problems.\n10\n\n\nINFO\nConfirmation that things are working as expected.\n20\n\n\nWARNING\nAn indication that something unexpected happened, or indicative of some problem in the near future (e.g. ‘disk space low’). The software is still working as expected.\n30\n\n\nERROR\nDue to a more serious problem, the software has not been able to perform some function.\n40\n\n\nCRITICAL\nA serious error, indicating that the program itself may be unable to continue running.\n50\n\n\n\nThe default level is WARNING, which means that only events of this level and above will be tracked, unless the logging package is configured to do otherwise.\nLoggers\nHandlers\nFormatters\n官方-logrecord-attributes\nlogging to a file\nif you run the above script several times, the messages from successive runs are appended to the file example.log. If you want each run to start afresh, not remembering the messages from earlier runs, you can specify the filemode argument, by changing the call in the above example to:\nlogging.basicConfig(filename='example.log', filemode='w', level=logging.DEBUG)\nConfiguring Logging\nThe logging library takes a modular approach and offers several categories of components: loggers, handlers, filters, and formatters.\n\nLoggers expose the interface that application code directly uses.\nHandlers send the log records (created by loggers) to the appropriate destination.\nFilters provide a finer grained facility for determining which log records to output.\nFormatters specify the layout of log records in the final output.\n\nA good convention to use when naming loggers is to use a module-level logger, in each module which uses logging, named as follows:\nlogger = logging.getLogger(__name__)\nLogging.getLogger([name])方法返回一个logger实例的引用,如果name参数给出,则用这个参数的值作为名字,如果没有则用root做默认值。\nThis means that logger names track the package/module hierarchy, and it’s intuitively obvious where events are logged just from the logger name.\nProgrammers can configure logging in three ways:\n\nCreating loggers, handlers, and formatters explicitly using Python code that calls the configuration methods listed above.\nCreating a logging config file and reading it using the fileConfig() function.\nCreating a dictionary of configuration information and passing it to the dictConfig() function.\n\nFor the reference documentation on the last two options, see Configuration functions. The following example configures a very simple logger, a console handler, and a simple formatter using Python code:\nimport logging\n\n# create logger\nlogger = logging.getLogger('simple_example')\nlogger.setLevel(logging.DEBUG)\n\n# create console handler and set level to debug\nch = logging.StreamHandler()\nch.setLevel(logging.DEBUG)\n\n# create formatter\nformatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n\n# add formatter to ch\nch.setFormatter(formatter)\n\n# add ch to logger\nlogger.addHandler(ch)\n\n# 'application' code\nlogger.debug('debug message')\nlogger.info('info message')\nlogger.warn('warn message')\nlogger.error('error message')\nlogger.critical('critical message')\noutput:\n2018-05-28 19:23:50,651 - simple_example - DEBUG - debug message\n2018-05-28 19:23:50,651 - simple_example - INFO - info message\n2018-05-28 19:23:50,651 - simple_example - WARNING - warn message\n2018-05-28 19:23:50,651 - simple_example - ERROR - error message\n2018-05-28 19:23:50,651 - simple_example - CRITICAL - critical message\n\nThe following Python module creates a logger, handler, and formatter nearly identical to those in the example listed above, with the only difference being the names of the objects:\nimport logging\nimport logging.config\n\nlogging.config.fileConfig('logging.conf')\n\n# create logger\nlogger = logging.getLogger('simpleExample')\n\n# 'application' code\nlogger.debug('debug message')\nlogger.info('info message')\nlogger.warn('warn message')\nlogger.error('error message')\nlogger.critical('critical message')\nHere is the logging.conf file:\n\n[loggers]\nkeys=root,simpleExample\n\n[handlers]\nkeys=consoleHandler\n\n[formatters]\nkeys=simpleFormatter\n\n[logger_root]\nlevel=DEBUG\nhandlers=consoleHandler\n\n[logger_simpleExample]\nlevel=DEBUG\nhandlers=consoleHandler\nqualname=simpleExample\npropagate=0\n\n[handler_consoleHandler]\nclass=StreamHandler\nlevel=DEBUG\nformatter=simpleFormatter\nargs=(sys.stdout,)\n\n[formatter_simpleFormatter]\nformat=%(asctime)s - %(name)s - %(levelname)s - %(message)s\ndatefmt=\nThe output is nearly identical to that of the non-config-file-based example:\n$ python simple_logging_config.py\n2005-03-19 15:38:55,977 - simpleExample - DEBUG - debug message\n2005-03-19 15:38:55,979 - simpleExample - INFO - info message\n2005-03-19 15:38:56,054 - simpleExample - WARNING - warn message\n2005-03-19 15:38:56,055 - simpleExample - ERROR - error message\n2005-03-19 15:38:56,130 - simpleExample - CRITICAL - critical message\n捕获异常，记录跟踪信息\n出错的时候记录日志是好的，但是没有 traceback 的话也没什么用。你应当捕获异常，并在日志中附加 traceback 信息。下面是一个例子：\ntry:\n    open('/path/to/does/not/exist', 'rb')\nexcept (SystemExit, KeyboardInterrupt):\n    raise\nexcept Exception, e:\n    logger.error('Failed to open file', exc_info=True)\n调用 logger 来记录日志时，指定 exc_info=True 参数，traceback 信息将会被存入日志中。结果是这样的：\nERROR:__main__:Failed to open file\nTraceback (most recent call last):\n  File \"example.py\", line 6, in <module>\n    open('/path/to/does/not/exist', 'rb')\nIOError: [Errno 2] No such file or directory: '/path/to/does/not/exist'\n你也可以调用 logger.exception(msg, *args)，这跟 logger.error(msg, *args, exc_info=True) 是一样的。\nExample\n利用YAML配置文件进行设置\n1.logging_cf.yaml：\nversion: 1\ndisable_existing_loggers: False\nformatters:\n    simple:\n        format: \"%(asctime)s - %(name)s - %(module)s - %(filename)s - %(lineno)d - %(levelname)s - %(message)s\"\nhandlers:\n    console:\n        class: logging.StreamHandler\n        level: DEBUG\n        formatter: simple\n        stream: ext://sys.stdout\n    info_file_handler:\n        class: logging.handlers.RotatingFileHandler\n        level: INFO\n        formatter: simple\n        filename: info.log\n        maxBytes: 10485760 # 10MB\n        backupCount: 20\n        encoding: utf8\n    error_file_handler:\n        class: logging.handlers.RotatingFileHandler\n        level: ERROR\n        formatter: simple\n        filename: errors.log\n        maxBytes: 10485760 # 10MB\n        backupCount: 20\n        encoding: utf8\nloggers:\n    my_module:\n        level: ERROR\n        handlers: [console]\n        propagate: no\nroot:\n    level: INFO\n    handlers: [console, info_file_handler, error_file_handler]\n2.myapp.py--应用启动入口\nimport logging\nimport mylib\nfrom util import log_conf\n\n\ndef main():\n    log_conf.setup_logging()\n    logger = logging.getLogger('my_module')\n    logger.info('Started')\n    mylib.do_something()\n    logger.info('Finished')\n\n\nif __name__ == '__main__':\n    main()\n\n3.mylib.py--某module\nimport logging\nfrom util import log_conf\n\nlog_conf.setup_logging()\nlogger = logging.getLogger(__name__)  # 如果不指定logger name，就默认用的root的配置\n\n\ndef do_something():\n    logger.debug('Doing something')\n    logger.info('Info mylib  michael翔')\n    print(__name__)\n简单配置\nlogging模块最简单的用法，是直接使用basicConfig方法来对logging进行配置\nimport logging\n\n# 设置默认的level为DEBUG\n# 设置log的格式\nlogging.basicConfig(\n    level=logging.DEBUG,\n    format=\"[%(asctime)s] %(name)s:%(levelname)s: %(message)s\"\n)\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.DEBUG)\nsh = logging.StreamHandler()\nformatter = logging.Formatter('%(asctime)s-%(name)s-%(filename)s-%(module)s-%(lineno)d-%(levelname)s-%(message)s')\nsh.setFormatter(formatter)\nlogger.addHandler(sh)\n\nlogger.debug('debug message')\nlogger.info('info message')\nlogger.warning('warn message')\nlogger.error('error message')\nlogger.critical('critical message')\nGitHub\nMichael728/python-logging\n参考\n\npython logging 官方文档\nGood logging practice in Python\n【翻译】Python 日志实践\n【推荐】python(logging )日志模块学习-logger等类型的说明\nPython标准模块logging\nLogging Cookbook\nPython的标准logging模块(1)\n\n\npython中利用logging包进行日志记录时的logging.level设置选择\n每个 Python 程序员都要知道的日志实践\n日志（Logging）\npython: difference between logging.Logger and logging.getLogger\nlogging模块学习\nPython logging 模块指导 【译】\n替换你的print（logging模块超简明指南）\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}