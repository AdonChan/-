{"title": "python classmethod 与 staticmethod 小谈 - Yi_Zhi_Yu的世界 ", "index": "静态方法,静态函数,python2.7,python", "content": "概念\npython 的classmethod 与staticmethod 这两个有什么区别？ 二者又有什么联系？在google和baidu之后， 得到的大致的联系就是二者都是对类的方法的静态调用的装饰器， 即对类的方法的静态调用可以用这两种方式实现。区别体现在classmethod 也可以用类的实例调用， 而staticmethod 则不能如此\n原因\n假设 class A 中 使用  classmethod 装饰函数 a, 如下：\nclass A():\n    _info = \"hello world\"\n    @classmethod\n    def a(arg):\n        print arg._info\n那么对a的调用既可以直接类似静态调用\nA.a()\n也可以先实例化， 再调用：\naaa = A()\naaa.a()\n但如果把classmethod 换成staticmehtod：\nclass A():\n    _info = \"hello world\"\n    @staticmethod\n    def a(arg):\n        print arg._info\n就只能静态调用了(staticmethod 名字就已经看得出来了)\n原因是， classmethod 是类(不是实例化的对象)作为第一个参数传递给了函数， 比如在第一个例子里的aaa.a()和A.a(),  都是直接将类或者对象的类(再一次， 不是实例)传递进去， 进而实现静态调用\n而staticmethod 只是将函数声明为静态方法， 没有传递任何内容进去\n静态变量范围\n在实验过程中， 类的静态变量对类的实例产生了一些有趣的影响， 如下\nclass c():\n    _num = 0\n\n    def add(self,num):\n        self._num += num\n\n    def add_c(self,num)\n        c._num += num\n\n    def get(self):\n        return self._nu\n\n    def get_c(self):\n        return c._num\n        \n if __name__ == \"__main_\n    c1 = c()\n    c2 = c()\n\n    c1.add_c(3)\n    c2.add_c(2)\n    c1.add(9)\n    c2.add(4)\n    print c1.get()#?\n    print c2.get()#?\n    print c1.get_c()#?\n    print c2.get_c()#?\n结果依次应该是什么呢，如下\n14\n9\n5\n5\n\n让我们产生疑问的是第一个和第二个的结果怎么是14 和 9, 很明显3+2+9 = 14， 3+2+4 = 9， 是通过这两种方式的结果， 看起来就像 add_c 里的类的变量影响了 add里的类的实例。 \n确实如此， 对类的变量的修改会影响类的实例的变量的使用， 所以我们在通过  classname.variable 的方式对类变量做修改的时候一定要小心。\n而类的实例并不会影响类的静态变量，只是会修改对象实例本身的值， 所以后面两个的结果总是5,5\n同样， 如果我们使用classmethod 和staticmethod\n @staticmethod\n def get_sm():\n     return c._num\n\n @classmethod\n def get_cm(arg):\n     print arg\n     return arg._num\n结果也将仅仅是静态变量变化后的结果， 与类的实例无关\nPS： 以上是对classmethod 和staticmethod 的暂时做的了解的总结， 如有纰漏， 请及时指正\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "5"}