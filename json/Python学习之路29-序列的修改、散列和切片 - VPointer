{"title": "Python学习之路29-序列的修改、散列和切片 - VPointer ", "index": "slice,python", "content": "《流畅的Python》笔记。本篇是“面向对象惯用方法”的第三篇。本篇将以上一篇中的Vector2d为基础，定义多维向量Vector。\n\n1. 前言\n自定义Vector类的行为将与Python标准中的不可变扁平序列一样，它将支持如下功能：\n\n基本的序列协议：__len__和__getitem__；\n正确表述拥有很多元素的实例；\n适当的切片支持，用于生成新的Vector实例；\n综合各个元素的值计算散列值；\n自定义的格式语言扩展。\n\n本篇还将通过__getattr__方法实现属性的动态存取（虽然序列类型通常不会这么做），以及穿插讨论一个概念：把协议当做正式接口。我们将说明协议和鸭子类型之间的关系，以及对自定义类型的影响。\n2. 初版Vector\nVector的构造方法将和所有内置序列类型一样，以可迭代对象为参数。如果其中元素过多，repr()函数返回的字符串将会使用...省略一部分内容，它的初始版本如下：\n# 代码1\nfrom array import array\nimport reprlib\nimport math\n\nclass Vector:\n    typecode = \"d\"\n\n    def __init__(self, components):  # 以可迭代对象为参数\n        self._components = array(self.typecode, components)\n\n    def __iter__(self):\n        return iter(self._components)\n\n    def __repr__(self):\n        components = reprlib.repr(self._components)\n        components = components[components.find(\"[\"):-1]\n        return \"Vector({})\".format(components)\n\n    def __str__(self):   # 和Vector2d相同\n        return str(tuple(self))\n\n    def __bytes__(self):\n        return (bytes([ord(self.typecode)]) + bytes(self._components))\n\n    def __eq__(self, other):   # 和Vector2d相同\n        return tuple(self) == tuple(other)\n\n    def __abs__(self):\n        return math.sqrt(sum(x * x for x in self))\n\n    def __bool__(self):   # 和Vector2d相同\n        return bool(abs(self))\n\n    @classmethod\n    def frombytes(cls, octets):\n        typecode = chr(octets[0])\n        memv = memoryview(octets[1:]).cast(typecode)\n        return cls(memv)   # 去掉了Vector2d中的星号*\n之所以没有直接继承制Vector2d，既是因为这两个类的构造方法不兼容，也是因为我们要为Vector实现序列协议。\n3. 协议和鸭子类型\n协议和鸭子类型在之前的文章中也有所提及。在面向对象编程中，协议是非正式的接口，只在文档中定义，在代码中不定义。\n在Python中，只要实现了协议需要的某些方法，其实就算实现了协议，而不一定需要继承。比如只要实现了__len__和__getitem__这两个方法，那么这个类就是满足序列协议的，而不需要从什么“序列基类”继承。\n鸭子类型：和现实中相反，Python中确定一个东西是不是“鸭子”，不是测它的“DNA”是不是”鸭子“的DNA，而是看这东西像不像只鸭子。只要像”鸭子“，那它就是“鸭子”。比如，只要一个类实现了__len__和__getitem__方法，那它就是序列类，而不必管它是从哪来的；文件类对象也常是鸭子类型。\n4. 第2版Vector：支持切片\n让Vector变为序列类型，并能正确返回切片：\n# 代码2，将以下代码添加到初版Vector中\nclass Vector:\n    -- snip --\n    def __len__(self):\n        return len(self._components)\n    \n    def __getitem__(self, index):\n        cls = type(self)\n        if isinstance(index, slice):  # 如果index是个切片类型，则构造新实例\n            return cls(self._components[index])\n        elif isinstance(index, numbers.Integral):  # 如果index是个数，则直接返回\n            return self._components[index]\n        else:\n            msg = \"{cls.__name__} indices must be integers\"\n            raise TypeError(msg.format(cls=cls))\n如果__getitem__函数直接返回切片：return self._components[index]，那么得到的数据将是array类型，而不是Vector类型。正是为了使切片的类型正确，这里才做了类型判断。\n上述代码中用到了slice类型，它是Python的内置类型，这里顺便补充一下切片原理，直接上代码：\n# 代码3\n>>> class MySeq:\n...     def __getitem__(self, index):\n...         return index  # 直接返回传给它的值\n...    \n>>> s = MySeq()\n>>> s[1]   \n1  # 单索引，没啥新奇的\n>>> s[1:3]\nslice(1, 3, None)  # 返回来一个slice类型\n>>> s[1:10:2]\nslice(1, 10, 2)    # 注意slice类型的结构\n>>> s[1:10:2, 9]\n(slice(1, 10, 2), 9)   # 如果[]中有逗号，__getitem__收到的是元组\n>>> s[1:10:2, 7:9]\n(slice(1, 10, 2), slice(7, 9, None))\n\n>>> dir(slice)  # 注意最后四个元素\n['__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', \n'__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__',\n'__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__',\n'__sizeof__', '__str__', '__subclasshook__', 'indices', 'start', 'step', 'stop']\n当我们用dir()函数获取slice的属性时，发现它有start，stop和step数据属性，并且还有一个indices方法，这里重点说说这个indices方法。它接收一个长度参数len，并根据这个len将slice类型的start，stop和step三个参数正确转换成在长度范围内的非负数，具体用法如下：\n# 代码4\n>>> slice(None, 10, 2).indices(5)\n(0, 5, 2)  # 将这些烦人的索引统统转换成明确的正向索引\n>>> slice(-3, None, None).indices(5)\n(2, 5, 1)\n自定义Vector类中并没有使用这个方法，因为Vector的底层我们使用了array.array数据类型，切片的具体操作不用我们自行编写。但如果你的类没有这样的底层序列类型做支撑，那么slice.indices方法将为你节省大量时间。\n5. 第3版Vector：动态存储属性\n目前版本的Vector中，没有办法通过名称访问向量的分量（如v.x和v.y），而且现在的Vector可能存在大量分量。不过，如果能通过单个字母访问前几个分量的话，这样将很方便，也更人性化。现在，我们想用x，y，z，t四个字母分别代替v[0]，v[1]，v[2]和v[3]，但具体做法并不是为实例添加这四个属性，并且我们也不想在运行时实例能动态添加单个字母的属性，更不想实例能通过这四个字母修改Vector中self._components的值。换句话说，我们只想通过这四个字母提供一种较为方便的访问方式，仅此而已。而要实现这样的功能，则需要实现__getattr__和__setattr__方法，以下是它们的代码：\n# 代码5.1\nclass Vector:\n    -- snip --\n    \n    shortcut_name = \"xyzt\"\n\n    def __getattr__(self, name):\n        cls = type(self)\n        if len(name) == 1:   # 如果属性是单个字母\n            pos = cls.shortcut_name.find(name)    \n            if 0 <= pos < len(self._components):  # 判断是不是xyzt中的一个\n                return self._components[pos]   \n        msg = \"{.__name__!r} object has no attribute {!r}\"  # 想要获取其他属性时则抛出异常\n        raise AttributeError(msg.format(cls, name))\n\n    def __setattr__(self, name, value):\n        cls = type(self)\n        if len(name) == 1:   # 不允许创建单字母实例属性，即便是x,y,z,t\n            if name in cls.shortcut_name:  # 如果name是xyzt中的一个，设置特殊的错误信息\n                error = \"readonly attibute {attr_name!r}\"\n            elif name.islower():  # 为小写字母设置特殊的错误信息\n                error = \"can't set attributes 'a' to 'z' in {cls_name!r}\"\n            else:\n                error = \"\"\n            if error:   # 当用户试图动态创建属性时抛出异常\n                msg = error.format(cls_name=cls.__name__, attr_name=name)\n                raise AttributeError(msg)\n        super().__setattr__(name, value)   \n解释：\n\n属性查找失败后，解释器会调用__getattr__方法。简单来说，对my_obj.x表达式，Python会检查my_obj实例有没有名为x的实例属性；如果没有，则到它所属的类中查找有没有名为x的类属性；如果还是没有，则顺着继承树继续查找。如果依然找不到，则会调用my_obj所属类中定义的__getattr__方法，传入self和属性名的字符串形式（如'x'）；\n\n__getattr__和__setattr_方法一般同时定义，否则对象的行为很容易出现不一致。比如，如果这里只定义__getattr__方法，则会出现如下尴尬的代码：\n# 代码5.2\n>>> v = Vector(range(5))\n>>> v\nVector([0.0, 1.0, 2.0, 3.0, 4.0])\n>>> v.x\n0.0\n>>> v.x = 10  # 按理说这里应该报错才对，因为不允许修改\n>>> v.x\n10\n>>> v  # 其实是v创建了新实例属性x，这也是为什么我们要定义__setattr__\nVector([0.0, 1.0, 2.0, 3.0, 4.0])   # 行为不一致\n\n我们没有禁止动态添加属性，只是禁止为单个字母属性赋值，如果属性名的长度大于1，这样的属性是可以动态添加的；\n如果你看过上一篇文章，那么你可能会想到用__slots__来禁止添加属性，但我们这里仍然选择实现__setattr__来实现此功能。__slots__属性最好只用于节省内存，而且仅在内存严重不足时才用它，别为了秀操作而写一些别人看着很别扭的代码（只写给自己看的除外）。\n\n6. 第4版Vector：散列和快速等值测试\n目前这个Vector是不可散列的，现在我们来实现__hash__方法。具体方法和上一篇一样，也是用各个分量的哈希值进行异或运算，由于Vector的分量可能很多，这里我们使用functools.reduce函数来归约异或值。同时，我们还将改写之前那个简洁版的__eq__，使其更高效（至少对大型向量来说更高效）：\n# 代码6，请自行导入所需的模块\nclass Vector:\n    -- snip --\n    def __hash__(self):\n        hashs = (hash(x) for x in self._components)   # 先求各个分量的哈希值\n        return functools.reduce(operator.xor, hashs, 0)  # 然后将所有哈希值归约成一个值\n\n    def __eq__(self, other): # 不用像之前那样：生成元组只为使用元组的__eq__方法\n        return len(self) == len(self) and all(a == b for a, b in zip(self, other))\n解释：\n\n此处的__hash__方法实际上执行的是一个映射归约的过程。每个分量被映射成了它们的哈希值，这些哈希值再归约成一个值；\n这里的functool.reduce传入了第三个参数，并且建议最好传入第三个参数。传入第三个参数能避免这个异常：TypeError: reduce() of empty sequence with no initial value。如果序列为空，第三个参数就是返回值；否则，在归约中它将作为第一个参数；\n在__eq__方法中先比较两序列的长度并不仅仅是一种捷径。zip函数并行遍历多个可迭代对象，如果其中一个耗尽，它会立即停止生成值，而且不发出警告；\n\n补充一个小知识：zip函数和文件压缩没有关系，它的名字取自拉链头（zipper fastener），这个小物件把两个拉链条的链牙要合在一起，是不是很形象？\n7. 第5版Vector：格式化\nVector2d中，当传入'p'时，以极坐标的形式格式化数据；由于Vector的维度可能大于2，现在，当传入参数'h'时，我们使用球面坐标格式化数据，即'<r, Φ1, Φ2, Φ3>'。同时，还需要定义两个辅助方法：\n\n\nangle(n)，用于计算某个角坐标；\n\nangles()，返回由所有角坐标构成的可迭代对象。\n\n至于这两个的数学原理就不解释了。以下是最后要添加的代码：\n# 代码7\nclass Vector:\n    -- snip --\n    def angle(self, n):\n        r = math.sqrt(sum(x * x for x in self[n:]))\n        a = math.atan2(r, self[n - 1])\n        if (n == len(self) - 1) and (self[-1] < 0):\n            return math.pi * 2 - a\n        return a\n\n    def angles(self):\n        return (self.angle(n) for n in range(1, len(self)))\n\n    def __format__(self, format_spec=\"\"):\n        if format_spec.endswith(\"h\"):   # 如果格式说明符以'h'结尾\n            format_spec = format_spec[:-1]   # 格式说明符前面部分保持不变\n            coords = itertools.chain([abs(self)], self.angles())  # \n            outer_fmt = \"<{}>\"\n        else:\n            coords = self\n            outer_fmt = \"({})\"\n        components = (format(c, format_spec) for c in coords)\n        return outer_fmt.format(\", \".join(components))\nitertools.chain函数生成生成器表达式，将多个可迭代对象连接成在一起进行迭代。关于生成器的更多内容将在以后的文章中介绍。\n至此，多维Vector暂时告一段落。\n\n迎大家关注我的微信公众号\"代码港\" & 个人网站 www.vpointer.net ~\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}