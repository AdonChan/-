{"title": "python综合学习四之Numpy和Pandas(下) - Corwien ", "index": "python,numpy,pandas", "content": "这一节继续学习Numpy和Pandas。\n一、numpy基础运算二\n通过上一节的学习，我们可以了解到一部分矩阵中元素的计算和查找操作。然而在日常使用中，对应元素的索引也是非常重要的。依然，让我们先从一个脚本开始 ：\n# -*- coding:utf-8 -*-\n\n\"\"\"\n@author: Corwien\n@file: np_yunsuan.py\n@time: 18/8/26 23:37\n\"\"\"\n\nimport numpy as np\nA = np.arange(2, 14).reshape(3, 4)\n# array([[ 2, 3, 4, 5]\n#        [ 6, 7, 8, 9]\n#        [10,11,12,13]])\n         \nprint(np.argmin(A))    # 0\nprint(np.argmax(A))    # 11\n常用方法\n其中的 argmin() 和 argmax() 两个函数分别对应着求矩阵中最小元素和最大元素的索引。相应的，在矩阵的12个元素中，最小值即2，对应索引0，最大值为13，对应索引为11。\n如果需要计算统计中的均值，可以利用下面的方式，将整个矩阵的均值求出来：\nprint(np.mean(A))        # 7.5\nprint(np.average(A))     # 7.5\n仿照着前一节中dot() 的使用法则，mean()函数还有另外一种写法：\nprint(A.mean())          # 7.5\n同样的，我们可以写出求解中位数的函数：\nprint(A.median())       # 7.5\n另外，和matlab中的cumsum()累加函数类似，Numpy中也具有cumsum()函数，其用法如下：\nprint(np.cumsum(A)) \n\n# [2 5 9 14 20 27 35 44 54 65 77 90]\n在cumsum()函数中：生成的每一项矩阵元素均是从原矩阵首项累加到对应项的元素之和。比如元素9，在cumsum()生成的矩阵中序号为3，即原矩阵中2，3，4三个元素的和。\n下面我们介绍一下nonzero()函数：\nprint(np.nonzero(A))    \n\n# (array([0,0,0,0,1,1,1,1,2,2,2,2]),array([0,1,2,3,0,1,2,3,0,1,2,3]))\n这个函数将所有非零元素的行与列坐标分割开，重构成两个分别关于行和列的矩阵。\n索引\n一维索引\n在元素列表或者数组中，我们可以用如同a[2]一样的表示方法，同样的，在Numpy中也有相对应的表示方法：\n# -*- coding:utf-8 -*-\n\n\"\"\"\n@author: Corwien\n@file: np_index.py\n@time: 18/8/28 00:49\n\"\"\"\n\nimport numpy as np\nA = np.arange(3, 11)\n\nprint(A)    # [3 4 5 6 7 8 9 10]\nprint(A[3]) # 6\n\n让我们将矩阵转换为二维的，此时进行同样的操作：\nA = np.arange(3, 11).reshape(2, 4)\n\n\"\"\"\n[[ 3  4  5  6]\n [ 7  8  9 10]]\n\"\"\"\n\nprint(A[1]) # [ 7  8  9 10]\n实际上这时的A[1]对应的就是矩阵A中第二行(从0开始算第一行)的所有元素。\n二维索引\n如果你想要表示具体的单个元素，可以仿照上述的例子：\nprint(A[1][1])      # 8\n此时对应的元素即A[1][1]，在A中即横纵坐标都为1，第二行第二列的元素，即8（因为计数从0开始）。同样的还有其他的表示方法：\nprint(A[1, 1])      # 8\n在Python的 list 中，我们可以利用:对一定范围内的元素进行切片操作，在Numpy中我们依然可以给出相应的方法：\nprint(A[1, 1:3])    # [8 9]\n这一表示形式即针对第二行中第2到第4列元素进行切片输出（不包含第4列）。 \n此时我们适当的利用for函数进行打印：\nfor row in A:\n    print(row)\n    \n\"\"\"    \n[ 3,  4,  5, 6]\n[ 7,  8,  9, 10]\n\"\"\"\n此时它会逐行进行打印操作。如果想进行逐列打印，就需要稍稍变化一下：\nfor column in A.T:\n    print(column)\n\"\"\"  \n[3 7]\n[4 8]\n[5 9]\n[ 6 10]\n\"\"\"\n上述表示方法即对A进行转置，再将得到的矩阵逐行输出即可得到原矩阵的逐列输出。\n最后依然说一些关于迭代输出的问题：\nimport numpy as np\nA = np.arange(3,15).reshape((3,4))\n         \nprint(A.flatten())   \n# array([3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])\n\nfor item in A.flat:\n    print(item)\n    \n# 3\n# 4\n……\n# 14\n这一脚本中的flatten是一个展开性质的函数，将多维的矩阵进行展开成1行的数列。而flat是一个迭代器，本身是一个object属性。\n合并\n\n\nnp.vstack() # vertical stack 上下合并\n\nnp.hstack() # horizontal stack 左右合并\n\nnp.newaxis() # 中转置操作\n\nnp.concatenate() # 多个合并\n\n分割\n创建数据\n# -*- coding:utf-8 -*-\n\n\"\"\"\n@author: Corwien\n@file: np_split.py\n@time: 18/8/28 01:21\n\"\"\"\n\nimport numpy as np\n\nA = np.arange(12).reshape((3, 4))\nprint(A)\n\"\"\"\narray([[ 0,  1,  2,  3],\n    [ 4,  5,  6,  7],\n    [ 8,  9, 10, 11]])\n\"\"\"\n   \n纵向分割\nprint(np.split(A, 2, axis=1))\n\"\"\"\n[array([[0, 1],\n        [4, 5],\n        [8, 9]]), array([[ 2,  3],\n        [ 6,  7],\n        [10, 11]])]\n\"\"\"\n横向分割\nprint(np.split(A, 3, axis=0))\n\n# [array([[0, 1, 2, 3]]), array([[4, 5, 6, 7]]), array([[ 8,  9, 10, 11]])]\n错误的分割\n范例的Array只有4列，只能等量对分，因此输入以上程序代码后Python就会报错。\nprint(np.split(A, 3, axis=1))\n\n# ValueError: array split does not result in an equal division\n为了解决这种情况, 我们会有下面这种方式.\n不等量的分割\n在机器学习时经常会需要将数据做不等量的分割，因此解决办法为np.array_split()\nprint(np.array_split(A, 3, axis=1))\n\"\"\"\n[array([[0, 1],\n        [4, 5],\n        [8, 9]]), array([[ 2],\n        [ 6],\n        [10]]), array([[ 3],\n        [ 7],\n        [11]])]\n\"\"\"\n成功将Array不等量分割!\n其他的分割方式\n在numpy里还有np.vsplit()与横np.hsplit()方式可用。\nprint(np.vsplit(A, 3)) #等于 print(np.split(A, 3, axis=0))\n\n# [array([[0, 1, 2, 3]]), array([[4, 5, 6, 7]]), array([[ 8,  9, 10, 11]])]\n\n\nprint(np.hsplit(A, 2)) #等于 print(np.split(A, 2, axis=1))\n\"\"\"\n[array([[0, 1],\n       [4, 5],\n       [8, 9]]), array([[ 2,  3],\n        [ 6,  7],\n        [10, 11]])]\n\"\"\"\ncopy & deep copy\n= 的赋值方式会带有关联性\nimport numpy as np\n\na = np.arange(4)\n# array([0, 1, 2, 3])\n\nb = a\nc = a\nd = b\n改变a的第一个值，b、c、d的第一个值也会同时改变。\na[0] = 11\nprint(a)\n# array([11,  1,  2,  3])\n确认b、c、d是否与a相同。\nb is a  # True\nc is a  # True\nd is a  # True\n同样更改d的值，a、b、c也会改变。\nd[1:3] = [22, 33]   # array([11, 22, 33,  3])\nprint(a)            # array([11, 22, 33,  3])\nprint(b)            # array([11, 22, 33,  3])\nprint(c)            # array([11, 22, 33,  3])\ncopy() 的赋值方式没有关联性\ndeep copy 为深赋值，重新建了一个地址\nb = a.copy()    # deep copy\nprint(b)        # array([11, 22, 33,  3])\na[3] = 44\nprint(a)        # array([11, 22, 33, 44])\nprint(b)        # array([11, 22, 33,  3])\n此时a与b已经没有关联。\n二、pandas基础\n1、Numpy和Pandas有什么不同\n如果用 python 的列表和字典来作比较, 那么可以说 Numpy 是列表形式的，没有数值标签，而 Pandas 就是字典形式。Pandas是基于Numpy构建的，让Numpy为中心的应用变得更加简单。\n要使用pandas，首先需要了解他主要两个数据结构：Series和DataFrame。\nSeries\n# -*- coding:utf-8 -*-\n\n\"\"\"\n@author: Corwien\n@file: pd_new.py\n@time: 18/8/30 00:22\n\"\"\"\n\nimport pandas as pd\nimport numpy as np\n\ns = pd.Series([1, 3, 6, np.nan, 44, 1])\n\nprint s\n结果打印：\n/Users/corwien/anaconda2/bin/python /Users/corwien/Code/python/baseLearn/pandas/pd_new.py\n\n0     1.0\n1     3.0\n2     6.0\n3     NaN\n4    44.0\n5     1.0\ndtype: float64\nSeries的字符串表现形式为：索引在左边，值在右边。由于我们没有为数据指定索引。于是会自动创建一个0到N-1（N为长度）的整数型索引。\nDataFrame\ndates = pd.date_range('20180830', periods=6)\ndf = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=['A', 'B', 'C', 'D'])\n\nprint(df)\n\"\"\"\n                   A         B         C         D\n2018-08-30 -0.838769 -0.366117 -0.501002 -0.418720\n2018-08-31  0.062155  1.467156  1.995968 -0.460316\n2018-09-01  0.553028  0.144778  1.944617  1.709808\n2018-09-02 -0.116423 -1.134185  1.231541  0.862480\n2018-09-03 -0.823016  0.491625 -1.448212 -0.921488\n2018-09-04 -0.226200  0.353459  0.219459  0.635181\n\"\"\"\nDataFrame是一个表格型的数据结构，它包含有一组有序的列，每列可以是不同的值类型（数值，字符串，布尔值等）。DataFrame既有行索引也有列索引， 它可以被看做由Series组成的大字典。\n我们可以根据每一个不同的索引来挑选数据, 比如挑选 B 的元素:\nDataFrame 的一些简单运用\nprint(df['b'])\n\n\"\"\"\n2018-08-30    0.391123\n2018-08-31   -0.508613\n2018-09-01    1.618023\n2018-09-02   -1.168342\n2018-09-03   -0.915434\n2018-09-04    0.595129\nFreq: D, Name: B, dtype: float64\n\"\"\"\n我们在创建一组没有给定行标签和列标签的数据 df1:\ndf1 = pd.DataFrame(np.arange(12).reshape((3,4)))\nprint(df1)\n\n\"\"\"\n   0  1   2   3\n0  0  1   2   3\n1  4  5   6   7\n2  8  9  10  11\n\"\"\"\n这样,他就会采取默认的从0开始 index. 还有一种生成 df 的方法, 如下 df2:\ndf2 = pd.DataFrame({'A' : 1.,\n                    'B' : pd.Timestamp('20130102'),\n                    'C' : pd.Series(1,index=list(range(4)),dtype='float32'),\n                    'D' : np.array([3] * 4,dtype='int32'),\n                    'E' : pd.Categorical([\"test\",\"train\",\"test\",\"train\"]),\n                    'F' : 'foo'})\n                    \nprint(df2)\n\n\"\"\"\n     A          B    C  D      E    F\n0  1.0 2013-01-02  1.0  3   test  foo\n1  1.0 2013-01-02  1.0  3  train  foo\n2  1.0 2013-01-02  1.0  3   test  foo\n3  1.0 2013-01-02  1.0  3  train  foo\n\"\"\"\n这种方法能对每一列的数据进行特殊对待. 如果想要查看数据中的类型, 我们可以用 dtype 这个属性:\nprint(df2.dtypes)\n\n\"\"\"\ndf2.dtypes\nA           float64\nB    datetime64[ns]\nC           float32\nD             int32\nE          category\nF            object\ndtype: object\n\"\"\"\n同样, 每种数据的名称也能看到:\nprint(df2.columns)\n# Index(['A', 'B', 'C', 'D', 'E', 'F'], dtype='object')\n想知道数据的总结, 可以用 describe():\ndf2.describe()\n\n\"\"\"\n         A    C    D\ncount  4.0  4.0  4.0\nmean   1.0  1.0  3.0\nstd    0.0  0.0  0.0\nmin    1.0  1.0  3.0\n25%    1.0  1.0  3.0\n50%    1.0  1.0  3.0\n75%    1.0  1.0  3.0\nmax    1.0  1.0  3.0\n\"\"\"\n\n                ", "mainLikeNum": ["7 "], "mainBookmarkNum": "5"}