{"title": "[译] 属性访问、特性和描述符 2 - young ", "index": "python,python3.x", "content": "注：原书作者 Steven F. Lott，原书名为 Mastering Object-oriented Python\n__getattribute__()方法\n__getattribute__()方法是一个更底层的属性处理。它的默认实现试图把一个属性作为一个已经存在于内部__dict__（或__slots__）的属性来定位值。如果没有找到该属性，它会调用__getattr__()。如果值被定位为描述符（参见下面《创建描述符》部分），则处理描述符；否则只是简单的返回值。\n通过重写此方法，我们可以完成以下任何一个任务：\n\n我们可以有效地防止对属性的访问。这种方法通过抛出异常来代替返回一个值，可以使一个属性比我们仅仅使用下划线（_）将一个命名标记为私有更私密。\n我们可以发明新的属性，类似于__getattr__()如何发明新的属性。然而，在这种情况下，我们可以通过默认版本的__getattribute__()来绕过默认查找。\n我们可以让属性执行唯一且不同的任务。这会使得程序非常难以理解和维护。这是一个糟糕的想法。\n我们可以改变描述符的行为。虽然技术上可能，但改变一个描述符的行为是一个可怕的想法。\n\n在我们实现__getattribute__()方法时，重要的是要注意在方法体中不能有任何的内部属性访问。如果我们试图通过self.name获取值，将导致无限递归。\n__getattribute__()方法不能提供任何简单的self.name属性访问，这将导致无限递归。\n为了在__getattribute__()方法中获取属性值，我们必须显式地访问object定义的基础方法，如以下所示声明：\nobject.__getattribute__(self, name)\n例如，我们可以使用__getattribute__()修改我们的不可变类以及防止访问内部__dict__属性。下面这个类，隐藏了所有以下划线（_）开头的命名：\nclass BlackJackCard3:\n    \"\"\"Abstract Superclass\"\"\"\n    def __init__(self, rank, suit, hard, soft):\n        super().__setattr__('rank', rank)\n        super().__setattr__('suit', suit)\n        super().__setattr__('hard', hard)\n        super().__setattr__('soft', soft)\n\n    def __setattr__(self, name, value):\n        if name in self.__dict__:\n            raise AttributeError(\"Cannot set {name}\".format(name=name))\n        raise AttributeError(\"'{__class__.__name__}' has no attribute\n        '{name}'\".format(__class__= self.__class__, name= name))\n\n    def __getattribute__(self, name):\n        if name.startswith('_'):\n            raise AttributeError\n        return object.__getattribute__(self, name)\n我们已经覆写了__getattribute__()的私有名称以及Python内部名称来抛出一个属性错误。这前面的示例有一个微小的优势：我们不再允许调整对象。我们将会看到该类的实例交互的示例。\n下面示例是该类对象的变形：\n>>> c = BlackJackCard3('A', '♠', 1, 11)\n>>> c.rank = 12\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"<stdin>\", line 9, in __setattr__\n  File \"<stdin>\", line 13, in __getattribute__\nAttributeError\n>>> c.__dict__['rank']= 12\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"<stdin>\", line 13, in __getattribute__\nAttributeError\n通常建议，搞混__getattribute__()不是一个好主意。默认方法相当复杂，而且几乎所有我们需要的都是作为特性利用或作为__getattr__()的改变。\n创建描述符\n描述符是调和属性访问的一个类。描述符类可用来获取、设置或删除属性值。描述符对象是在类定义的时候构建在一个类中的。\n描述符设计模式有两个部分：一个所有者类和属性描述符本身。所有者类给它的属性使用一个或多个描述符。描述符类定义了获取、设置和删除方法的组合。描述符类的一个实例将会是所有者类的一个属性。\n特性是基于所有者类的方法函数。描述符不像特性，是一个类的实例，与所有者类不同。因此，描述符通常是可重用的通用属性。所有者类可以有多个不同描述符类的实例来类管理具有相似行为的属性。\n不像其他属性，描述符在类级别上创建。它们不是在__init()__初始化时创建。然而描述符的值可以在初始化期间设置，描述符通常是作为类的一部分，在任何方法函数之外来构建的。\n当所有者类被定义时，每个描述符对象都是被绑定到一个不同的类级别属性的描述符类实例。\n被确认为一个描述符，一个类必须实现以下三个方法的任意组合。\n\nDescriptor.__get__(self, instance, owner) -> object：在这个方法中，instance参数是即将被访问的对象的self变量。owner参数是所有者类的对象。如果这个描述符在类的上下文中被调用，instance参数将得到一个None值。这必须返回描述符的值。\nDescriptor.__set__(self, instance, value)：在这个方法中，instance参数是即将被访问的对象的self变量。value参数是描述符需要设置的新值。\nDescriptor.__delete__(self, instance)在这个方法中，instance参数是即将被访问的对象的self变量。该描述符的方法必须删除这个属性的值。\n\n有时，一个描述符类还将需要一个__init__()方法函数来初始化描述符的内部状态。\n有两种基于已定义方法的描述符，如下所示：\n\n非数据描述符：这种描述符定义__set__()或__delete__()或两者皆有。它不能定义__get__()。非数据描述符对象往往会被用作表达式的一部分。它可能是一个可调用对象，或者它可能有自己的属性或方法。一个不可变的非数据描述符必须实现__set__()，但可能只是抛出AttributeError。这些描述符设计时很简单，因为接口更灵活。\n数据描述符：这种描述符至少定义__get__()。通常，它定义__get__()和__set__()来创建一个可变对象。鉴于描述符将在很大程度上是不可见的，则不能更进一步的再定义属性或方法。属性的引用有一个数据描述符的数据被委托给描述符的__get__()、__set__()或__delete__()方法。这些是很难设计的，所以我们稍后来再看。\n\n描述符有各种各样的用例。在内部，Python使用描述符有以下几个原因：\n\n在隐藏的内部，类的方法是作为描述符来实现。这些非数据描述符应用方法函数到对象以及不同的参数值。\nproperty()函数通过给一个字段创建数据描述符来实现。\n一个类方法或静态方法被实现为一个描述符；这被应用到类中来代替类的实例。\n\n当我们在第11章《通过SQLite存储和检索对象》看到对象-关系映射的时候，我们将看到许多ORM类定义大量使用描述符将Python类映射到SQL表和列。\n当我们考虑一个描述符的目的，我们还必须为数据作为描述符可以正常工作来考察三种常见用例，如下所示：\n\n描述符对象有数据或获取到了数据。在这种情况下，描述符对象的self变量是有意义的且描述符是有状态的。数据描述符的__get__()方法返回这个内部数据。非数据描述符，描述符有其他方法或属性来访问这些数据。\n包含数据的所有者实例。在这种情况下，描述符对象必须使用instance参数来引用值到所有者对象中。数据描述符的__get__()方法从实例获取数据。非数据描述符有其他方法访问实例数据。\n包含相关数据的所有者类。在这种情况下，描述符对象必须使用owner参数。这是常用的当描述符实现了应用于整个类的静态方法或类方法。\n\n我们将仔细看下第一种情况。我们看看创建带有__get__()和__set__()方法的数据描述符。我们也会看看创建没有__get__()方法的非数据描述符。\n第二种情况（所有者实例中的数据）展示了@property装饰器都做了些什么。可能的优势是描述符有一个传统的特性将计算从拥有者类移到描述符类中。这倾向于分片类设计且可能不是最好的方法。如果计算是真正史诗般的复杂，策略模式可能会更好。\n第三种情况展示@staticmethod和@classmethod装饰器是如何实现的。我们不需要重新发明轮子。\n1、使用非数据描述符\n我们经常会有一些紧密绑定了属性值的小对象。对于这个示例，我们将看看数值被绑定到单位的举措。\n下面是一个简单的非数据描述符类，它缺少一个__get__()方法：\nclass UnitValue_1:\n    \"\"\"Measure and Unit combined.\"\"\"\n    def __init__(self, unit):\n        self.value = None\n        self.unit = unit\n        self.default_format = \"5.2f\"\n\n    def __set__(self, instance, value):\n        self.value = value\n\n    def __str__(self):\n        return \"{value:{spec}} {unit}\"\n        .format(spec=self.default_format, **self.__dict__)\n\n    def __format__(self, spec=\"5.2f\"):\n        #print( \"formatting\", spec )\n        if spec == \"\":\n            spec = self.default_format\n        return \"{value:{spec}} {unit}\".format(spec=spec, **self.__dict__)\n这个类定义了一对简单的值，一个可变的（值），另一个是有效的不可变对象（单位）。\n当这个描述符被访问时，描述符对象本身是可用的，且描述符的其他方法或属性可以被使用。我们可以使用这个描述符来创建类去管理尺寸和其他与物理单位有关的数值。\n下面是一个类，做速度-时间-距离的及早计算：\nclass RTD_1:\n    rate = UnitValue_1(\"kt\")\n    time = UnitValue_1(\"hr\")\n    distance = UnitValue_1(\"nm\")\n    def __init__(self, rate=None, time=None, distance=None):\n        if rate is None:\n            self.time = time\n            self.distance = distance\n            self.rate = distance / time\n        if time is None:\n            self.rate = rate\n            self.distance = distance\n            self.time = distance / rate\n        if distance is None:\n            self.rate = rate\n            self.time = time\n            self.distance = rate * time\n\n    def __str__(self):\n        return \"rate: {0.rate} time: {0.time} distance:{0.distance}\".format(self)\n一旦对象被创建且属性被加载，丢失的值就已经被计算。一旦计算，描述符可以检查获取值或单位的名称。此外，描述符对str()有一个方便的响应和请求格式。\n下面是描述符和RTD_1类之间的交互：\n>>> m1 = RTD_1(rate=5.8, distance=12)\n>>> str(m1)\n'rate:  5.80 kt time:  2.07 hr distance: 12.00 nm'\n>>> print(\"Time:\", m1.time.value, m1.time.unit)\nTime: 2.0689655172413794 hr\n我们创建了一个带有rate和distance参数的RTD_1实例。这些都是用来计算rate和distance描述符的__set__()方法。\n当我们请求str(m1)，这会计算RTD_1的所有str()方法，转而使用rate、time和distance描述符的__format__()方法。这为我们提供了数字和单位。\n鉴于非数据描述符没有__get__()且不返回其内部值，我们可以访问描述符的单个元素。\n2、使用数据描述符\n数据描述符设计要复杂一些，因为它对接口有限制。它必须有一个__get__()方法，且只能有__set__()或__delete__()。这是所有的接口：这些方法从一到三，没有其他方法。引入一个额外的方法意味着Python不会把该类当作一个正确的数据描述符。\n我们会使用描述符设计一个简单的单位转换模式，可以在__get__()和__set__()方法做适当的转换。\n下面是一个单位描述符的超类，它在其他单位和标准单位之间做转换：\nclass Unit:\n    conversion = 1.0\n    def __get__(self, instance, owner):\n        return instance.kph * self.conversion\n\n    def __set__(self, instance, value):\n        instance.kph = value / self.conversion\n该类用简单的乘法和除法将标准单位转换为其他非标准单位，反之亦然。\n通过这个超类，我们可以从一个标准单位定义一些转换。在前面的示例，标准单位是千米时（公里/小时）。\n以下是这两个转换描述符\nclass Knots(Unit):\n    conversion = 0.5399568\n\nclass MPH(Unit):\n    conversion = 0.62137119\n继承方法非常有用。唯一改变的是转换因子。这些类可用于处理涉及单位转换的值。我们可以处理英里每小时或可交换的节点。下面是一个标准单位的单位描述符，公里每小时：\nclass KPH(Unit):\n\n    def __get__(self, instance, owner):\n        return instance._kph\n\n    def __set__(self, instance, value):\n        instance._kph = value\n这个类代表一个标准，所以不做任何转换。它使用一个私有变量实例保存速度千米每小时的标准值。避免任何算术转换是一个简单的技术优化。避免任何一个公共字段的引用是至关重要的，来规避无限递归。\n下面这个类，它对于一个给定的尺寸提供了一组转换：\nclass Measurement:\n    kph = KPH()\n    knots = Knots()\n    mph = MPH()\n    def __init__(self, kph=None, mph=None, knots=None):\n        if kph:\n            self.kph = kph\n        elif mph:\n            self.mph = mph\n        elif knots:\n            self.knots = knots\n        else:\n            raise TypeError\n\n    def __str__(self):\n        return \"rate: {0.kph} kph = {0.mph} mph = {0.knots} knots\".format(self)\n对于不同的单位每个类级别的属性都是描述符。各种描述符的获取和设置方法会做适当的转换。我们可以使用这个类在各种单位之间进行速度转换。\n以下是与Measurement类交互的一个例子：\n>>> m2 = Measurement(knots=5.9)\n>>> str(m2)\n'rate: 10.92680006993152 kph = 6.789598762345432 mph = 5.9 knots'\n>>> m2.kph\n10.92680006993152\n>>> m2.mph\n6.789598762345432\n我们通过设置不同的描述符创建了一个Measurement类的对象。在第一个示例中，我们设置了节点描述符。\n当我们显示的值是一个大字符串，则每个描述符的__get__()都将被使用。这些方法从所有者对象获取内部kph字段值，应用一个转换因子，且返回一个结果值。\nkph字段还使用了一个描述符。这个描述符不做任何转换；然而，它只是返回了缓存在所有者对象的私有值。KPH和Knots描述符要求所有者类实现一个kph属性。\n总结，设计要素和权衡\n在这一章，我们研究了几种使用一个对象属性的方式。我们可以使用内置object类的特性以及获取和设置属性值。我们可以定义属性来修改属性的行为。\n如果我们想要更复杂，我们可以调整底层__getattr__()、__setattr__()、__delattr__()或__getattribute__()特殊方法实现。这些让我们可以更精细的控制字段的行为。当我们接触到这些方法我们走的很顺利，因为我们可以对Python的行为进行基本（和令人困惑的）改变。\n在内部，Python使用描述符来实现特性，例如方法函数、静态方法函数和属性。描述符许多很酷的用例已经是语言的最好的特性。\n来自其他语言（特别是Java和c++）的程序员通常有试图让所有属性私有以及编写大量的getter和setter函数的冲动。\n在Python中，将所有属性作当作公有的是相当简单的。这意味着如下：\n\n它们应该有良好的文档记录。\n它们应该正确的反映对象的状态，它们不应该是暂时的或临时的值。\n一个字段有令人困惑的（或易变的）字段值是非常罕见的，一个以下划线（_）开头的命名作为“不是已定义接口中的一部分”不是真的私有。\n\n把私有字段看做麻烦事是很重要的。在语言中封装并没有因为缺乏复杂的私有机制而受损；而会因为糟糕的设计而受损。\n1、特性对属性\n在大多数情况下，字段可以设置在类之外且没有不良后果。我们的Hand类的示例展示了这一点。对于许多版本的类，我们可以简单地追加到hand.cards，以及完美的工作通过特性延迟计算total。\n在改变属性这种情况下，会导致相应的其他字段的变化，这需要一些更复杂的类设计：\n\n一个方法函数可以阐明状态变化。当需要多个参数值时这将是必要的。\n一个特性setter可能比一个方法函数更清晰。当需要单个值时这将是一个明智的选择。\n我们还可以使用原地操作符。我们将到第七章《创造数字》看到这些。\n\n没有严格的规则。在这种情况下，我们需要设置一个参数值，方法函数和特性之间的区别完全是API语法和如何传达意图的区别。\n为了计算值，特性允许延迟计算，而一个属性需要及早计算。这是性能的问题。延迟计算对及早计算的优势是基于对用例的预期。\n2、使用描述符设计\n很多描述符的示例已经是Python的一部分。我们不需要重复特性、类方法或静态方法。\n创建新的描述符最引人注目的情况是在Python和一些非Python之间建立映射关系。例如，对象-关系数据库映射，需要大量的维护以确保一个Python类有正确的属性以正确的顺序匹配一个SQL表和列。同样，当映射到一些Python之外，一个描述符类可以处理数据编码和解码或从外部获取数据来源。\n当构建一个web服务端，我们可能会考虑使用描述符来做web服务请求。例如，__get__()方法可能会变成一个HTTP的GET请求，__set__()方法可能会变成一个HTTP的PUT请求。\n在某些情况下，一个单一的请求可能填充几个描述符的数据。在这种情况下，__get__()方法将检查实例的缓存以及在一个HTTP请求之前返回一个值。\n通过属性来操作许多数据描述符操作会非常简单。这给我们提供开始的机会：首先编写属性。如果属性处理变得非常昂贵和复杂，则我们可以切换到描述符来对类进行重构。\n3、展望未来\n在下一章，我们将密切关注将在5、6、7章探索的ABCs（抽象基类）。这些基础知识将帮助我们定义类，它会与现有Python特性很好地集成。它们还将允许我们创建执行一致的设计和扩展的类层次结构。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "7"}