{"title": "Python中不尽如人意的断言Assertion - Python测试开发 ", "index": "调试,python", "content": "Python Assert 为何不尽如人意\nPython中的断言用起来非常简单，你可以在assert后面跟上任意判断条件，如果断言失败则会抛出异常。\n>>> assert 1 + 1 == 2\n>>> assert isinstance('Hello', str)\n>>> assert isinstance('Hello', int)\n\nTraceback (most recent call last):\n  File \"<input>\", line 1, in <module>\nAssertionError\n其实assert看上去不错，然而用起来并不爽。就比如有人告诉你程序错了，但是不告诉哪里错了。很多时候这样的assert还不如不写，写了我就想骂娘。直接抛一个异常来得更痛快一些。\n改进方案 #1\n一个稍微改进一丢丢的方案就是把必要的信息也放到assert语句后面，比如这样。\n>>> s = \"nothin is impossible.\"\n>>> key = \"nothing\"\n>>> assert key in s, \"Key: '{}' is not in Target: '{}'\".format(key, s)\n\nTraceback (most recent call last):\n  File \"<input>\", line 1, in <module>\nAssertionError: Key: 'nothing' is not in Target: 'nothin is impossible.'\n看上去还行吧，但是其实写的很蛋疼。假如你是一名测试汪，有成千上万的测试案例需要做断言做验证，相信你面对以上做法，心中一定有千万只那种马奔腾而过。\n改进方案 #2\n不管你是你是搞测试还是开发的，想必听过不少测试框架。你猜到我要说什么了吧？对，不用测试框架里的断言机制，你是不是洒。\npy.test\npy.test 是一个轻量级的测试框架，所以它压根就没写自己的断言系统，但是它对Python自带的断言做了强化处理，如果断言失败，那么框架本身会尽可能多地提供断言失败的原因。那么也就意味着，用py.test实现测试，你一行代码都不用改。\nimport pytest\n\ndef test_case():\n    expected = \"Hello\"\n    actual = \"hello\"\n    assert expected == actual\n\nif __name__ == '__main__':\n    pytest.main()\n\n\"\"\"\n================================== FAILURES ===================================\n__________________________________ test_case __________________________________\n\n    def test_case():\n        expected = \"Hello\"\n        actual = \"hello\"\n>       assert expected == actual\nE       assert 'Hello' == 'hello'\nE         - Hello\nE         ? ^\nE         + hello\nE         ? ^\n\nassertion_in_python.py:7: AssertionError\n========================== 1 failed in 0.05 seconds ===========================\n\"\"\"\"\nunittest\nPython自带的unittest单元测试框架就有了自己的断言方法self.assertXXX()，而且不推荐使用assert XXX语句。\nimport unittest\n\nclass TestStringMethods(unittest.TestCase):\n\n    def test_upper(self):\n        self.assertEqual('foo'.upper(), 'FoO')\n\nif __name__ == '__main__':\n    unittest.main()\n    \n\"\"\"\nFailure\nExpected :'FOO'\nActual   :'FoO'\n\nTraceback (most recent call last):\n  File \"assertion_in_python.py\", line 6, in test_upper\n    self.assertEqual('foo'.upper(), 'FoO')\nAssertionError: 'FOO' != 'FoO'\n\"\"\"\nptest\n我非常喜欢ptest，感谢Karl大神写了这么一个测试框架。ptest中的断言可读性很好，而且智能提示也很方便你通过IDE轻松完成各种断言语句。\nfrom ptest.decorator import *\nfrom ptest.assertion import *\n\n@TestClass()\nclass TestCases:\n    @Test()\n    def test1(self):\n        actual = 'foo'\n        expected = 'bar'\n        assert_that(expected).is_equal_to(actual)\n\n\"\"\"\nStart to run following 1 tests:\n------------------------------\n...\n[demo.assertion_in_python.TestCases.test1@Test] Failed with following message:\n...\nAssertionError: Unexpectedly that the str <bar> is not equal to str <foo>.\n\"\"\"\n改进方案 #3\n不仅仅是你和我对Python中的断言表示不满足，所以大家都争相发明自己的assert包。在这里我强烈推荐assertpy 这个包，它异常强大而且好评如潮。\npip install assertpy\n看例子:\nfrom assertpy import assert_that\n\ndef test_something():\n    assert_that(1 + 2).is_equal_to(3)\n    assert_that('foobar')\\\n        .is_length(6)\\\n        .starts_with('foo')\\\n        .ends_with('bar')\n    assert_that(['a', 'b', 'c'])\\\n        .contains('a')\\\n        .does_not_contain('x')\n从它的github 主页 文档上你会发现它支持了几乎你能想到的所有测试场景，包括但不限于以下列表。\n\nStrings\nNumbers\nLists\nTuples\nDicts\nSets\nBooleans\nDates\nFiles\nObjects\n\n而且它的断言信息简洁明了，不多不少。\nExpected <foo> to be of length <4>, but was <3>.\nExpected <foo> to be empty string, but was not.\nExpected <False>, but was not.\nExpected <foo> to contain only digits, but did not.\nExpected <123> to contain only alphabetic chars, but did not.\nExpected <foo> to contain only uppercase chars, but did not.\nExpected <FOO> to contain only lowercase chars, but did not.\nExpected <foo> to be equal to <bar>, but was not.\nExpected <foo> to be not equal to <foo>, but was.\nExpected <foo> to be case-insensitive equal to <BAR>, but was not.\n在发现assertpy之前我也想写一个类似的包，尽可能通用一些。但是现在，我为毛要重新去造轮子？完全没必要！\n总结\n断言在软件系统中有非常重要的作用，写的好可以让你的系统更稳定，也可以让你有更多真正面对对象的时间，而不是在调试代码。\nPython中默认的断言语句其实还有一个作用，如果你写了一个类型相关的断言，IDE会把这个对象当成这种类型，这时候智能提示就有如神助。\n要不要把内置的断言语句换成可读性更好功能更强大的第三方断言，完全取决于实际情况。比如你真的需要验证某个东西并且很关心验证结果，那么必须不能用简单的assert；如果你只是担心某个点可能有坑或者让IDE认识某个对象，用内置的assert既简单又方便。\n所以说，项目经验还是蛮重要的。\n\n关于作者：Python技术爱好者，目前从事测试开发相关工作，转载请注明原文出处。\n欢迎关注我的博客 https://betacat.online，你可以到我的公众号中去当吃瓜群众。\n\n\n\n                ", "mainLikeNum": ["5 "], "mainBookmarkNum": "7"}