{"title": "Python进程专题4：进程池Pool - python3 ：公司内部培训专栏 ", "index": "python", "content": "上一篇文章：Python进程专题3：继承Process来创建进程下一篇文章：Python进程专题5：进程间通信\n当我们需要创建大量的进程时，利用multiprocessing模块提供的Pool来创建进程。\n进程初始化时，会指定一个最大进程数量，当有新的请求需要创建进程时，如果此时进程池还没有到达设置的最大进程数，该进程池就会创建新的进程来处理该请求，并把该进程放到进程池中，如果进程池已经达到最大数量，请求就会等待，知道进程池中进程数量减少，才会新建进程来执行请求。\n语法\npool=Pool(numprocess,initializer,initargs)\nnumproxess:需要创建的进程个数，如果忽略将使用cpu_count()的值。即系统上的CPU数量。\ninitializer:每个进程启动时都要调用的对象。\ninitargs:为\ninitalizer传递的参数。\n常用方法\nmultiprocessing.Pool常用函数解析：\napply_async(要调用的方法,参数列表,关键字参数列表)：使用非阻塞方式调用指定方法，并行执行（同时执行）\n\napply(要调用的方法,参数列表,关键字参数列表)：使用阻塞方式调用指定方法，，阻塞方式就是要等上一个进程退出后，下一个进程才开始运行。\n\nclose():关闭进程池，不再接受进的进程请求，但已经接受的进程还是会继续执行。\n\nterminate()：不管程任务是否完成，立即结束。\n\njoin():主进程堵塞（就是不执行join下面的语句），直到子进程结束，注意，该方法必须在close或terminate之后使用。\n\npool.map(func,iterable,chunksize):将可调用对象func应用给iterable的每一项，然后以列表形式返回结果，\n通过将iterable划分为多块，并分配给工作进程，可以并行执行。chunksize指定每块中的项数，\n如果数据量较大，可以增大chunksize的值来提升性能。\n\npool.map_async(func,iterable,chunksize,callback):与map方法不同之处是返回结果是异步的，\n如果callback指定，当结果可用时，结果会调用callback。\n\npool.imap(func,iterable,chunksize):与map()方法的不同之处是返回迭代器而非列表。\n\npool.imap_unordered(func,iterable,chunksize):与imap()不同之处是：结果的顺序是根据从工作进程接收到的时间而定的。\n\npool.get(timeout):如果没有设置timeout，将会一直等待结果，\n如果设置了timeout，超过timeout将引发multiprocessing.TimeoutError异常。\n\npool.ready():如果调用完成，返回True\n\npool.successful():如果调用完成并且没有引发异常，返回True，如果在结果就绪之前调用，jiang引发AssertionError异常。\n\npool.wait(timeout):等待结果变为可用，timeout为等待时间。\n实例1：阻塞与非阻塞对比\n#阻塞与非阻塞对比\nfrom multiprocessing import Pool\nimport os\nimport time\nimport random#用来生成随机数\n\ndef test1(name):\n    print(\"%s运行中，pid=%d，父进程：%d\"%(name,os.getpid(),os.getppid()))\n    t_start=time.time()\n    #random.random()会生成一个0——1的浮点数\n    time.sleep(random.random()*3)\n    t_end=time.time()\n    print(\"%s执行时间：%0.2f秒\"%(name,t_end-t_start))\n\npool=Pool(5)#设置线程池中最大线程数量为5\nfor xx in range(0,7):\n    #非阻塞运行\n    pool.apply_async(test1,(\"mark\"+str(id),))\nprint(\"--start1--\")\npool.close()#关闭线程池，关闭后不再接受进的请求\npool.join()#等待进程池所有进程都执行完毕后，开始执行下面语句\nprint(\"--end1--\")\nprint(\"*\"*30)\npool=Pool(5)#设置线程池中最大线程数量为5\nfor xx in range(0,7):\n    #阻塞运行\n    pool.apply(test1,(\"mark\"+str(id),))\nprint(\"--start2--\")\npool.close()#关闭线程池，关闭后不再接受进的请求\npool.join()#等待进程池所有进程都执行完毕后，开始执行下面语句\nprint(\"--end2--\")\n结果：\n--start1--\nmark<built-in function id>运行中，pid=28631，父进程：28626\nmark<built-in function id>运行中，pid=28632，父进程：28626\nmark<built-in function id>运行中，pid=28633，父进程：28626\nmark<built-in function id>运行中，pid=28634，父进程：28626\nmark<built-in function id>运行中，pid=28636，父进程：28626\nmark<built-in function id>执行时间：0.27秒\nmark<built-in function id>运行中，pid=28633，父进程：28626\nmark<built-in function id>执行时间：0.32秒\nmark<built-in function id>运行中，pid=28634，父进程：28626\nmark<built-in function id>执行时间：0.18秒\nmark<built-in function id>执行时间：0.55秒\nmark<built-in function id>执行时间：1.78秒\nmark<built-in function id>执行时间：1.92秒\nmark<built-in function id>执行时间：2.71秒\n--end1--\n******************************\nmark<built-in function id>运行中，pid=28647，父进程：28626\nmark<built-in function id>执行时间：0.70秒\nmark<built-in function id>运行中，pid=28648，父进程：28626\nmark<built-in function id>执行时间：1.66秒\nmark<built-in function id>运行中，pid=28649，父进程：28626\nmark<built-in function id>执行时间：2.87秒\nmark<built-in function id>运行中，pid=28650，父进程：28626\nmark<built-in function id>执行时间：2.68秒\nmark<built-in function id>运行中，pid=28651，父进程：28626\nmark<built-in function id>执行时间：1.42秒\nmark<built-in function id>运行中，pid=28647，父进程：28626\nmark<built-in function id>执行时间：1.20秒\nmark<built-in function id>运行中，pid=28648，父进程：28626\nmark<built-in function id>执行时间：2.01秒\n--start2--\n--end2--\n实例2：利用进程池遍历目录\n查看下面实例前，先来熟悉一下我们需要用到的一些知识。os.walk(top,topdown=true,onerrorNone,followlinks=false):遍历目录地址，返回一个三元组（root，dirs，files）\ntop:想要遍历的目录\nroot:当前正在遍历的文件夹地址。\ndirs:是一个list：当前文件夹下所有目录的名字（不包括子目录）\nfiles:也是一个list，当前文件夹下所有文件的名字（不包括子目录文件）\ntopdown:默认为True：优先遍历top目录，为false会优先遍历top的子目录。\nonerror:指定一个当方法执行异常时需要调用的方法。\nfollowlinks:默认为True：会遍历目录环境下的快捷方式实际指向目录。\n\n代码：\n#遍历目录文件并求取SHA512的摘要值\nimport os\nimport multiprocessing\nimport hashlib\n\n#定义进程大小\nPOOLSIZE=2 #工作进程的数量\n#可以读取的缓冲区大小\nBUFSIZE=8196\n\ndef mark(filename):\n    try:\n        f=open(filename,\"rb\")\n    except IOError:\n        return None\n    digest=hashlib.sha512()\n    while True:\n        chunk=f.read(BUFSIZE)\n        if not chunk:break\n        digest.update(chunk)\n    f.close()\n    return filename,digest.digest()\n\n\n\ndef build_map(dir):\n    #定义进程\n    pool=multiprocessing.Pool(POOLSIZE)\n\n\n    #os.path.join:拼接文件路径\n    #根据文件目录和名称拼接\n    all_files=(os.path.join(root,name)\n               #循环遍历当前目录\n               for root,dirs,files in os.walk(dir)\n                   #取出当前目录下文件名\n                   for name in files)\n\n    #dict方法用于将结果转化成字典\n    map=dict(pool.imap_unordered(mark,all_files,20))\n    pool.close()\n    return map\n\n\nif __name__==\"__main__\":\n    digest_map=build_map(\"/Users/zhaolixiang/Desktop/python/test1/进程\")\n    for item in  digest_map:\n        print(\"文件目录：\",item)\n        print(\"SHA512摘要值：\",digest_map[item])\n    #个数\n    print(len(digest_map))\n结果\n文件目录： /Users/zhaolixiang/Desktop/python/test1/进程/1、fork创建子线程.pySHA512摘要值： b'x9eYLSxe5xb6xd2xecxd4&xa9xff~m?x87xd2Nxea39Gxe1x8fx9cdx83@x06/Bnxddx1exb5xe0jx10xd1xc9=xfd;y]x8dnR)xbdtxb8xc8xb46rExf8xd7t.xaexbbxe9'文件目录： /Users/zhaolixiang/Desktop/python/test1/进程/8、JoinableQueue的生产者与消费者.pySHA512摘要值： b'xfe4x18xee8xd1x97xe7vx86}xe6qnx13xf9Dxf1Xxe3xabx94xebx96xfbxedWx0bOn$x14d/+rx9bx0bxc1xd4x03xadxcbbxf7x8dxd5Ccx03yxd1xb4x801,?,rIXxa28xd7'文件目录： /Users/zhaolixiang/Desktop/python/test1/进程/10、管道：返回数据.pySHA512摘要值： b'x85xb1Cxe56x80x1dsx84txf6x95xcbx1d[xdaxe4}n)Y<xd5x10=x94x88xd8xafxccr@eCxc4!xc1xb70x9fzxc6xb1xb9xf6xc4xcexd7x02x86<xc8Ux0fx8bqxdax18ydxa3Kx8bxd6'文件目录： /Users/zhaolixiang/Desktop/python/test1/进程/11、进程池.pySHA512摘要值： b'bBxf4lxccxd5xaetrxc1x816xe5xfc;tx85x86xe5xd3x9e~SH]xe6xcbdxc9xfexe9xfbxfcxeb)Axd2ox8cOxbcx1etxe9xe92^xb5x10xe1xf4xc9\\_x0cx8cxa7qxf4(x13Mxbe7'文件目录： /Users/zhaolixiang/Desktop/python/test1/进程/2、multiprocessing.pySHA512摘要值： b\"mxb2xb5x00M1=qx86xb9Gxf9x02xb1x18xfax08xe7,.xefxff5xebt,nx17xbfB-xc6xc2x9dVxf9x88xa7xd8x1ex9b)x86Nxd5xab x89xa0J}xa9xdcxbcx06mx03xa7x87.x17xcb'x93\"文件目录： /Users/zhaolixiang/Desktop/python/test1/进程/6、验证：put方法会阻塞.pySHA512摘要值： b'xa3x80x86xf6xc9xb8x0eOB 5\\xd0\\x949\\xfd\\xc2y\\x9a\\xc7\\xca\\x9d\\xbc%\\xa1\\xe6_xfax84xb6x02$xf7x10xbbxb9Nxfbxdexc8xbe6F xd6x87xacxb2xf5x94x0cxedxe0.xf9Txdax91`;xd7x90x86'文件目录： /Users/zhaolixiang/Desktop/python/test1/进程/7、closse方法、get方法、put方法简单使用.pySHA512摘要值： b'lx98wx8fTx15xdfTx19x91^:xc5xa3x8dxf4x1ex9cx91Exe4xe7xbfxecVx1e\\x1bx19xa0ix96Lxc6xc4r.x9bxecx88xe9rxfeOx8bxdfAx90x7f6?xe7x1d8xa6Nx07xdex8dxb6xe7#x02p'文件目录： /Users/zhaolixiang/Desktop/python/test1/进程/5、进程池.pySHA512摘要值： b'xc2xf75x04xbaxa5Xxccx81x88xffxbazxd81@x0bQJ%xbbx15xf3`Qx9a4}xc0x07xa2&axc0x00x0c%xb4[xd2ex18x04x14ytx0cxb0xacx1dxf5xfbxe0\\xc7xb6$xd2xf1xd9sePx08'文件目录： /Users/zhaolixiang/Desktop/python/test1/进程/3、multiprocessing.pySHA512摘要值： b'x04N4Dxd5xab}xcfx03xe6x0fVx0fx910x91xe4x81,xbb-xdfxb36Ixf9!x84Axdf.xf3HVxfdx86:x0bx81<+ex00xd1x17uxf5hxb34FxfexebFxf5x1bxc3x8d`Axa0Ax02x10'文件目录： /Users/zhaolixiang/Desktop/python/test1/进程/9、管道.pySHA512摘要值： b'`xdbx8dx90Vx04=x0cxf9x9cxf7{x8fxcax9fxccxb8Dx97xecx82(xd4x9ax84xdb<xb8+x16xd7xecx057xe0x07xe9xc3xdccxe3 t#vxecxb5xe3npxc7~x95xd0J-cxb1xefx03.?xx12'文件目录： /Users/zhaolixiang/Desktop/python/test1/进程/4、继承Process创建进程.pySHA512摘要值： b'2xc1xa0x1fxd7xd6xb2x1c}x14xdedx8fxdbxedxd0x91mxc1,xb9xdd?TbXx04#2xfcxb8xbfurxabxfcFcx17x18xc7)sYx82x0exea{5x87xf3x8fcxbaPx91r0xefxabLxa8x1ex15'11\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}