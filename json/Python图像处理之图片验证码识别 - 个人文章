{"title": "Python图像处理之图片验证码识别 - 个人文章 ", "index": "python", "content": "  在上一篇博客Python图像处理之图片文字识别（OCR）中我们介绍了在Python中如何利用Tesseract软件来识别图片中的英文与中文，本文将具体介绍如何在Python中利用Tesseract软件来识别验证码（数字加字母）。  我们在网上浏览网页或注册账号时，会经常遇到验证码（CAPTCHA）,如下图：\n\n本文将具体介绍如何利用Python的图像处理模块pillow和OCR模块pytesseract来识别上述验证码（数字加字母）。  我们识别上述验证码的算法过程如下：\n\n将原图像进行灰度处理，转化为灰度图像；\n获取图片中像素点数量最多的像素（此为图片背景），将该像素作为阈值进行二值化处理，将灰度图像转化为黑白图像（用来提高识别的准确率）；\n去掉黑白图像中的噪声，噪声定义为：以该点为中心的九宫格的黑点的数量小于等于4；\n利用pytesseract模块识别，去掉识别结果中的特殊字符，获得识别结果。\n\n  我们的图片如下（共66张图片）：\n\n  完整的Python代码如下：\nimport os\nimport pytesseract\nfrom PIL import Image\nfrom collections import defaultdict\n\n# tesseract.exe所在的文件路径\npytesseract.pytesseract.tesseract_cmd = 'C://Program Files (x86)/Tesseract-OCR/tesseract.exe'\n\n# 获取图片中像素点数量最多的像素\ndef get_threshold(image):\n    pixel_dict = defaultdict(int)\n\n    # 像素及该像素出现次数的字典\n    rows, cols = image.size\n    for i in range(rows):\n        for j in range(cols):\n            pixel = image.getpixel((i, j))\n            pixel_dict[pixel] += 1\n\n    count_max = max(pixel_dict.values()) # 获取像素出现出多的次数\n    pixel_dict_reverse = {v:k for k,v in pixel_dict.items()}\n    threshold = pixel_dict_reverse[count_max] # 获取出现次数最多的像素点\n\n    return threshold\n\n# 按照阈值进行二值化处理\n# threshold: 像素阈值\ndef get_bin_table(threshold):\n    # 获取灰度转二值的映射table\n    table = []\n    for i in range(256):\n        rate = 0.1 # 在threshold的适当范围内进行处理\n        if threshold*(1-rate)<= i <= threshold*(1+rate):\n            table.append(1)\n        else:\n            table.append(0)\n    return table\n\n# 去掉二值化处理后的图片中的噪声点\ndef cut_noise(image):\n\n    rows, cols = image.size # 图片的宽度和高度\n    change_pos = [] # 记录噪声点位置\n\n    # 遍历图片中的每个点，除掉边缘\n    for i in range(1, rows-1):\n        for j in range(1, cols-1):\n            # pixel_set用来记录该店附近的黑色像素的数量\n            pixel_set = []\n            # 取该点的邻域为以该点为中心的九宫格\n            for m in range(i-1, i+2):\n                for n in range(j-1, j+2):\n                    if image.getpixel((m, n)) != 1: # 1为白色,0位黑色\n                        pixel_set.append(image.getpixel((m, n)))\n\n            # 如果该位置的九宫内的黑色数量小于等于4，则判断为噪声\n            if len(pixel_set) <= 4:\n                change_pos.append((i,j))\n\n    # 对相应位置进行像素修改，将噪声处的像素置为1（白色）\n    for pos in change_pos:\n        image.putpixel(pos, 1)\n\n    return image # 返回修改后的图片\n\n# 识别图片中的数字加字母\n# 传入参数为图片路径，返回结果为：识别结果\ndef OCR_lmj(img_path):\n\n    image = Image.open(img_path) # 打开图片文件\n    imgry = image.convert('L')  # 转化为灰度图\n\n    # 获取图片中的出现次数最多的像素，即为该图片的背景\n    max_pixel = get_threshold(imgry)\n\n    # 将图片进行二值化处理\n    table = get_bin_table(threshold=max_pixel)\n    out = imgry.point(table, '1')\n\n    # 去掉图片中的噪声（孤立点）\n    out = cut_noise(out)\n\n    #保存图片\n    # out.save('E://figures/img_gray.jpg')\n\n    # 仅识别图片中的数字\n    #text = pytesseract.image_to_string(out, config='digits')\n    # 识别图片中的数字和字母\n    text = pytesseract.image_to_string(out)\n\n    # 去掉识别结果中的特殊字符\n    exclude_char_list = ' .:\\\\|\\'\\\"?![],()~@#$%^&*_+-={};<>/¥'\n    text = ''.join([x for x in text if x not in exclude_char_list])\n    #print(text)\n\n    return text\n\ndef main():\n    \n    # 识别指定文件目录下的图片\n    # 图片存放目录figures\n    dir = 'E://figures'\n\n    correct_count = 0  # 图片总数\n    total_count = 0    # 识别正确的图片数量\n\n    # 遍历figures下的png,jpg文件\n    for file in os.listdir(dir):\n        if file.endswith('.png') or file.endswith('.jpg'):\n            # print(file)\n            image_path = '%s/%s'%(dir,file) # 图片路径\n\n            answer = file.split('.')[0]  # 图片名称，即图片中的正确文字\n            recognizition = OCR_lmj(image_path) # 图片识别的文字结果\n\n            print((answer, recognizition))\n            if recognizition == answer: # 如果识别结果正确，则total_count加1\n                correct_count += 1\n\n            total_count += 1\n\n    print('Total count: %d, correct: %d.'%(total_count, correct_count))\n    '''\n    # 单张图片识别\n    image_path = 'E://figures/code (1).jpg'\n    OCR_lmj(image_path)\n    '''\n\nmain()\n运行结果如下：\n('101659', '101659')\n('111073', '111073')\n('114510', '114510')\n('118235', '118235')\n('124677', '124677')\n('147291', '147291')\n('169147', '169147')\n('185302', '185302')\n('23YB', '23YB')\n('262051', '262051')\n('2HED', '2MED')\n('315386', '315386')\n('3D7K', '3D7K')\n('3DYH', '3DYH')\n('3QG8', '30G8')\n('3XNR', 'EXNR')\n('44G5', '44G5')\n('470259', '470259')\n('515413', '515413')\n('522351', '522351')\n('539824', '539824')\n('5CVL', 'SCVL')\n('642689', '642689')\n('671991', '671991')\n('672838', '672838')\n('6F5Y', '6F5Y')\n('6USB', 'GUSB')\n('703167', '703167')\n('765120', '765120')\n('779931', '779931')\n('8UEF', '8SUEF')\n('905857', '905857')\n('9H4H', '9H4H')\n('9SK1', 'OSK1')\n('BDP4', 'BDP4')\n('DXV3', 'DXV3')\n('E78Y', 'E78Y')\n('EAHR', 'EAHR')\n('F585', 'Fss§')\n('FBV8', 'FBV8')\n('FJKK', 'FJKK')\n('GXKQ', 'GXKQ')\n('H7Y9', 'H7Y9')\n('J4LJ', 'J4LJ')\n('J8YH', 'J8YH')\n('JCDL', 'JCDL')\n('JTX2', 'JTX2')\n('JYLH', 'JYLH')\n('KFYA', 'KFYA')\n('L3VZ', 'L3VZ')\n('LCGV', 'LCGV')\n('LKEK', 'LKEK')\n('N3FJ', 'N3FJ')\n('PJZN', 'PJZN')\n('PNDQ', 'PNDQ')\n('Q7HP', 'Q7HP')\n('QSHU', 'QSHU')\n('R1RN', 'RLRN')\n('RPNX', 'RPNX')\n('TUKG', 'TUKG')\n('U9G3', 'U9G3')\n('UZAH', 'UZAH')\n('V6P9', 'very')\n('Y18D', '18D')\n('Y237', 'Y237')\n('ZZT5', '2215')\nTotal count: 66, correct: 54.\n我们可以看到图片识别的正确率为80%以上，其中数字类图片的识别正确率为100%.   我们可以在图片识别方面的算法再加改进，以提高图片识别的正确率。当然，以上算法并不是对所有验证码都适用，不同的验证码需要用不同的图片处理算法。\n注意：本人现已开通两个微信公众号： 因为Python（微信号为：python_math）以及轻松学会Python爬虫（微信号为：easy_web_scrape）， 欢迎大家关注哦~~\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}