{"title": "Flask 下载中文名文件 - 个人文章 ", "index": "编码,下载,flask,python", "content": "在写 flask 后端的时候，特别是在做数据相关的操作的时候，产品往往需要我们做一个导出数据的需求，一般都是导出 excel 格式的文件。\n那在 flask 上，如何实现请求连接即可让浏览器下载呢？有两种思路。\n一：\n文件在本地磁盘，这时候我们只需要发送相应的地址过去即可。\n二：\n通过 io 中的 BytesIO， 把文件以二进制的形式发送过去，这里我们需要使用 flask 自带的 send_file。\n第一种的坏处在于不便于权限控制，拿到下载链接在哪都能下载，第二种方法的缺陷在于只能接收 get 请求，post 请求发送的文件浏览器是不能识别的。\n要实现 send_file, 是很容易的， 代码如下（适用于 python 3）：\nimport xlsxwriter\nfrom io import BytesIO\nfrom flask import Flask, send_file\n\napp = Flask(__name__)\n\n\n@app.route(\"/download\", methods=[\"GET\"])\ndef download():\n    out = BytesIO()\n    workbook = xlsxwriter.Workbook(out)\n    table = workbook.add_worksheet()\n    table.write(0, 0, \"name\")\n    table.write(0, 1, \"age\")\n    workbook.close()\n    out.seek(0)\n    return send_file(out, as_attachment=True, attachment_filename=\"dream.xlsx\")\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True)\n\n这是一个完整的后端程序，能够直接跑起来。\n其中我们用到了 xlsxwriter 这个库，用来生成一个 excel 文件， 直接传给 BytesIO() 成数据流的形式发出去，浏览器接收到这些数据流，回自动进行下载，文件名即是 send_file 参数中的 attachment_filename， 在我们这里便是 dream.xlsx 。\n启动程序，在浏览器中输入 127.0.0.1:5000/download, 即可下载名为 dream.xlsx 的文件。\n\n我们打开看看：\n\n的确是我们生成的一个 excel 表格。\n现在问题来了，这里的文件名是英文的，那我们需要中文怎么办？直接把 attachment_filename 参数改成 attachment_filename=\"测试表格.xlsx\"可以么？\n我们来试试：\nreturn send_file(out, as_attachment=True, attachment_filename=\"测试表格.xlsx\")\n\n其余代码不变，仅有此处发成改变。\n运行代码，浏览器访问下载试试。\n浏览器没有任何反应，代表我们没有把数据流传给它，看程序，也报错了，报错信息：\nUnicodeEncodeError: 'latin-1' codec can't encode characters in position 43-46: ordinal not in range(256)\n\n编码问题。\n解决办法如下：\nimport xlsxwriter\nfrom io import BytesIO\nfrom flask import Flask, send_file\nfrom urllib.parse import quote\n\napp = Flask(__name__)\n\n\n@app.route(\"/download\", methods=[\"GET\"])\ndef download():\n    out = BytesIO()\n    workbook = xlsxwriter.Workbook(out)\n    table = workbook.add_worksheet()\n    table.write(0, 0, \"name\")\n    table.write(0, 1, \"age\")\n    workbook.close()\n    out.seek(0)\n    filename = quote(\"测试表格.xlsx\")\n    rv = send_file(out, as_attachment=True, attachment_filename=filename)\n    rv.headers['Content-Disposition'] += \"; filename*=utf-8''{}\".format(filename)\n    return rv\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True)\n\n我们从 urllib.parse 引入 quote， 首先对文件名进行编码，然后 send_file 中 作为 attachment_filename 的参数，这时候能成功下载文件，但是文件名是编码后的名字，要解码的话，我们需要在 headers 里面声明编码格式，即：\nrv.headers['Content-Disposition'] += \"; filename*=utf-8''{}\".format(filename)\n\n这样的话，对文件名进行 UTF-8 解码，我们的文件名就是中文了。\n如图：\n\n打开文件，也是我们想要的，如图：\n\n大功告成！\n当然实际生产工作中，数据量是是非常大的，生成 excel 文件将会特别耗时，我们当然不希望我们的程序在此堵塞， 这时候我们可以使用 celery 异步任务，返回前端一个任务 ID， 前端去轮询这个任务 ID，当文件生成好了，即可开始下载。\n由于有些时候我们 get 请求无法满足我们的参数传递，比如有多个嵌套对象作为参数传递，我们必须使用 post 请求，这时候同样可以采用 celery 异步任务的方式，返回任务 ID， 轮询任务状态，下载文件。\n之后我会写一篇教程，celery 异步任务。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "3"}