{"title": "使用 exec 函数时需要注意的一些安全问题 - mozillazg 的学习笔记 ", "index": "安全,exec,python", "content": "众所周知，在 python 中可以使用 exec 函数来执行包含 python 源代码的字符串:\n>>> code = '''\n   ...: a = \"hello\"\n   ...: print(a)\n   ...: '''\n>>> exec(code)\nhello\n>>> a\n'hello'\nexec 函数的这个功能很是强大，慎用。如果一定要用的话，那么就需要注意一下下面这些安全相关的问题。\n全局变量和内置函数\n在 exec 执行的代码中，默认可以访问执行 exec 时的局部变量和全局变量， 同样也会修改全局变量。如果 exec 执行的代码是根据用户提交的数据生产的话，这种默认行为就是一个安全隐患。\n如何更改这种默认行为呢？可以通过执行 exec 函数的时候再传两个参数的方式来 修改这种行为（详见 之前 关于 exec 的文章）:\n>>> g = {}\n>>> l = {'b': 'world'}\n>>> exec('hello = \"hello\" + b', g, l)\n>>> l\n{'b': 'world', 'hello': 'helloworld'}\n>>> g\n{'__builtins__': {...}}\n>>> hello\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\n...\nNameError: name 'hello' is not defined\n如果要限制使用内置函数的话，可以在 globals 参数中定义一下 __builtins__ 这个 key:\n>>> g = {}\n>>> l = {}\n>>> exec('a = int(\"1\")', g, l)\n>>> l\n{'a': 1}\n\n>>> g = {'__builtins__': {}}\n>>> exec('a = int(\"1\")', g, l)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"<string>\", line 1, in <module>\nNameError: name 'int' is not defined\n>>>\n现在我们限制了访问和修改全局变量以及使用内置函数，难道这样就万事大吉了吗？ 然而并非如此，还是可以通过其他的方式来获取内置函数甚至 os.system 函数。\n另辟蹊径获取内置函数和 os.system\n通过函数对象:\n>>> def a(): pass\n...\n>>> a.__globals__['__builtins__']\n\n>>> a.__globals__['__builtins__'].open\n<built-in function open>\n通过内置类型对象:\n>>> for cls in {}.__class__.__base__.__subclasses__():\n...     if cls.__name__ == 'WarningMessage':\n...         b = cls.__init__.__globals__['__builtins__']\n...         b['open']\n...\n<built-in function open>\n>>>\n获取 os.system:\n>>> cls = [x for x in [].__class__.__base__.__subclasses__() if x.__name__ == '_wrap_close'][0]\n>>> cls.__init__.__globals__['path'].os\n<module 'os' from '/usr/local/var/pyenv/versions/3.5.1/lib/python3.5/os.py'>\n>>>\n对于这两种办法又如何应对呢？ 一种办法就是禁止访问以 _ 开头的属性：\n\n如果可以控制 code 的生成，那么就在生成 code 的时候判断\n如果不能的话，可以通过 dis 模块分析生成的 code （dist 无法分析嵌套函数的代码）\n使用 tokenize 模块:\n\n    In [68]: from io import BytesIO\n    In [69]: code = '''\n       ....: a = 'b'\n       ....: a.__str__\n       ....: def b():\n       ....:     b.__get__\n       ....: '''\n    In [70]: t = tokenize(BytesIO(code.encode()).readline)\n    In [71]: for x in t:\n       ....:     print(x)\n       ....:\n    TokenInfo(type=59 (ENCODING), string='utf-8', start=(0, 0), end=(0, 0), line='')\n    TokenInfo(type=58 (NL), string='\\n', start=(1, 0), end=(1, 1), line='\\n')\n    TokenInfo(type=1 (NAME), string='a', start=(2, 0), end=(2, 1), line=\"a = 'b'\\n\")\n    TokenInfo(type=53 (OP), string='=', start=(2, 2), end=(2, 3), line=\"a = 'b'\\n\")\n    TokenInfo(type=3 (STRING), string=\"'b'\", start=(2, 4), end=(2, 7), line=\"a = 'b'\\n\")\n    TokenInfo(type=4 (NEWLINE), string='\\n', start=(2, 7), end=(2, 8), line=\"a = 'b'\\n\")\n    TokenInfo(type=1 (NAME), string='a', start=(3, 0), end=(3, 1), line='a.__str__\\n')\n    TokenInfo(type=53 (OP), string='.', start=(3, 1), end=(3, 2), line='a.__str__\\n')\n    TokenInfo(type=1 (NAME), string='__str__', start=(3, 2), end=(3, 9), line='a.__str__\\n')\n    TokenInfo(type=4 (NEWLINE), string='\\n', start=(3, 9), end=(3, 10), line='a.__str__\\n')\n    TokenInfo(type=1 (NAME), string='def', start=(4, 0), end=(4, 3), line='def b():\\n')\n    TokenInfo(type=1 (NAME), string='b', start=(4, 4), end=(4, 5), line='def b():\\n')\n    TokenInfo(type=53 (OP), string='(', start=(4, 5), end=(4, 6), line='def b():\\n')\n    TokenInfo(type=53 (OP), string=')', start=(4, 6), end=(4, 7), line='def b():\\n')\n    TokenInfo(type=53 (OP), string=':', start=(4, 7), end=(4, 8), line='def b():\\n')\n    TokenInfo(type=4 (NEWLINE), string='\\n', start=(4, 8), end=(4, 9), line='def b():\\n')\n    TokenInfo(type=5 (INDENT), string='    ', start=(5, 0), end=(5, 4), line='    b.__get__\\n')\n    TokenInfo(type=1 (NAME), string='b', start=(5, 4), end=(5, 5), line='    b.__get__\\n')\n    TokenInfo(type=53 (OP), string='.', start=(5, 5), end=(5, 6), line='    b.__get__\\n')\n    TokenInfo(type=1 (NAME), string='__get__', start=(5, 6), end=(5, 13), line='    b.__get__\\n')\n    TokenInfo(type=4 (NEWLINE), string='\\n', start=(5, 13), end=(5, 14), line='    b.__get__\\n')\n    TokenInfo(type=6 (DEDENT), string='', start=(6, 0), end=(6, 0), line='')\n    TokenInfo(type=0 (ENDMARKER), string='', start=(6, 0), end=(6, 0), line='')\n从上面的输出我们可以知道当 type 是 OP 并且 string 等于 '.' 时，下一条记录就是点之后的属性名称。所以我们的检查代码可以这样写:\n\n    import io\n    import tokenize\n\n\n    def check_unsafe_attributes(string):\n        g = tokenize.tokenize(io.BytesIO(string.encode('utf-8')).readline)\n        pre_op = ''\n        for toktype, tokval, _, _, _ in g:\n            if toktype == tokenize.NAME and pre_op == '.' and tokval.startswith('_'):\n                attr = tokval\n                msg = \"access to attribute '{0}' is unsafe.\".format(attr)\n                raise AttributeError(msg)\n            elif toktype == tokenize.OP:\n                pre_op = tokval\n我所知道的使用 exec 函数时需要注意的安全问题就是这些了。 如果你还知道其他需要注意的安全问题的话，欢迎留言告知。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "3"}