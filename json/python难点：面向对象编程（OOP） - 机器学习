{"title": "python难点：面向对象编程（OOP） - 机器学习 ", "index": "python", "content": "学习廖雪峰官方网站python教程总结python面向对象编程OOP(Object Oriented Programming)总结，供日后参考1.类和实例\n#类的定义\nclass Student(object):\n    #限制实例只能添加指定的属性\n    __slots__ = ('sex','age')\n    #类属性\n    school = 'QingHua'\n    #初始化值，创建实例必须绑定的属性\n    def __init__(self,name,score):\n        #private变量\n        self.__name = name\n        self.__score = score\n    #设置getter，setter保证类内部数据安全\n    def get_name(self):\n        return self.__name\n    def get_score(self):\n        return self.__score\n    def set_name(self,name):\n        self.__name = name\n    def set_score(self,score):\n        self.__score = score\n    def hello(self,name='world'):\n        print('Hello, %s.' % name)\n#type()创建类，type()实质上是元类(metaclass)，类的定义本质上就是利用type()创建类\ndef fn(self, name='world'): # 先定义函数\n    print('Hello, %s.' % name)\nStudent = type('Student',(object,),dict(hello=fn))\n\n#创建实例\njim = Student('Jim',120)\nprint(jim.school) #QingHua\nprint(jim.name) #Jim\nprint(Student.school) #QingHua\njim.age = 20\njim.height = 170 #报错，不能添加__slots__未指定的属性\n2.@property上例中，为了保护内部数据的安全，我们使用setter，getter方式封装数据，能够防止用户随心所欲地修改数据，但是不够简洁。使用@property装饰器可以帮助我们改造成我们想要的样子\nclass Student(object):\n    def __init__(self,birth):\n        #private变量\n        self.__birth = birth\n    @property \n    def birth(self):\n        return self.__birth\n    @birth.setter\n    def birth(self,value):\n        self.__birth = value\n    @property\n    def age(self):\n        return 2018-self.__birth\n#birth为可读写属性，age是只读属性\ns = Student(1995)\ns.birth #实际转化为s.get_birth  结果：1995\ns.birth = 1996 #实际转化为s.set_birth \ns.age #22\ns.age = 20 #报错，当前age为只读属性\n3.继承和多态\nclass Animal(object):\n    def run(self):\n        print('Animal is running')\nclass Dog(Animal):\n    def run(self):\n        print('Dog is runing')\nclass Cat(Animal):\n    pass\ndog = Dog()\ncat = Cat()\ndog.run() #Dog is running Dog类重写了Animal的run方法\ncat.run() #Animal is running Cat类继承了Animal的run方法\n\n#多态\ndef run_log(obj):\n    obj.run()\nrun_log(Animal()) #Animal is running\nrun_log(Dog()) #Dog is running\n#传说中的file-like object\nclass other(object):\n    def run():\n        print('other is running')\n#传入任何实现run方法的对象都可以，这就是动态语言多分魅力\nrun_log(other) #other is running\n\n4.自定义类\n#__str__让class作用于print()\nclass Student(object):\n    def __init__(self,name):\n        self.name = name\n    def __str__(self):\n        return 'Student name:%s' % self.name\n    #__repr__用于调试服务，__str__用于用户打印\n    __repr__ = __str__\nprint(Student('Tom')) # Student name:Tom\n\n#__iter__\n#将class处理成tuple或list可迭代\nclass Fib(object):\n    def __init__(self):\n        self.a,slef.b = 0,1\n    def __iter__(self):\n        return self\n    def __next__(self):\n        self.a,self.b = self.b,self.a+self.b\n        if self.a>100\n            raise StopIteration()\n        return self.a\nfor n in Fib():\n    print(n)\n#1 1 2 3 5 8 13 21 34 55 89   \n\n#__getitem__()  __getattr__()  __call__()方法，以后用的时候具体了解\n5.枚举类\nfrom enum import Enum\nMonth = Enum('Month',('Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'))\nfor name,member in Month.__members__.items():\n    print(name,'=>',member,',',member.value)\n#value属性自动赋给成员int变量，默认从1开始\n#Enum派生自定义类\n\nfrom enum import Enum,unique\n@unique\nclass Weekday(Enum):\n    Sun = 0\n    Mon = 1\n    Tue = 2\n    Wed = 3\n    Thu = 4\n    Fri = 5\n    Sat = 6\n#@unique装饰器帮助我们检查保证没有重复值\n    \n\n\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "0"}