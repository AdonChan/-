{"title": "6.ORM与SQLAlchemy （2） - 模型关系与引用 - 后端开发——Flask初体验 ", "index": "flask,python", "content": "承接上文，我们的Q&A demo，除了用户表，还需要存储所有问题内容的表questions_info和存储所有评论的表comments_info，并且都和users_info通过外键来关联。我们不排除后续需要更多表的可能性，把所有模型和视图函数写在一起看着也太混乱了！为此，我们新建一个models.py，把三个模型都放在这里。\n\n由于是新建的models.py文件，我们同样要先在开头生成一个名为db的SQLAlchemy对象：\nfrom flask_sqlalchemy import SQLAlchemy\n\ndb = SQLAlchemy()\n前文中我们给SQLAlchemy传入了Flask对象app作为参数，这里是不是也要从视图函数文件HarpQA.py导入那个app并传进去呢？并不可以，因为HarpQA.py也要使用到db(如db.session)，这样就产生了循环引用，所以在这里不能传入app，而是回到HarpQA.py，使用db.init_app(app)将app和db绑定，避免了循环引用。\n\nusers_info表(Users模型)代码如下：\nclass Users(db.Model):\n    __tablename__ = 'users_info'\n    id = db.Column(db.Integer, primary_key=True, autoincrement=True)\n    username = db.Column(db.String(32), nullable=False)\n    password = db.Column(db.String(100), nullable=False)\n    register_time = db.Column(db.DateTime, nullable=False, default=datetime.now())\n    # 我们新增了一个avatar_path字段来存用户头像图片文件的路径\n    avatar_path = db.Column(db.String(256), nullable=False, default='images/doraemon.jpg')    \n\nquestions_info表(Questions模型)代码如下：\nclass Questions(db.Model):\n    __tablename__ = 'questions_info'\n    id = db.Column(db.Integer, primary_key=True, autoincrement=True)\n    title = db.Column(db.String(100), nullable=False)\n    content = db.Column(db.TEXT, nullable=False)\n    author_id = db.Column(db.Integer, db.ForeignKey('users_info.id'))\n    create_time = db.Column(db.DateTime, nullable=False, default=datetime.now())\n\n    author = db.relationship('Users', backref=db.backref('questions', order_by=create_time.desc()))\n这个表存储所有问题的标题、内容、创建时间、作者ID，作者ID通过外键与用户表的ID关联，方式也很简单，在db.Column中用db.ForeignKey('users_info.id')作为参数即可。再看最后一条语句：\nauthor = db.relationship('Users', backref=db.backref('questions', order_by=create_time.desc()))\ndb.relationship会自动找到两个表的外键，建立Questions和Users的关系，此时对于任意一个Questions对象question，通过question.author就可获得这个question的作者对应的Users对象，例如获取id为1的问题的作者姓名：\nquestion = Questions.query.filter(Questions.id == 1).first()\nauthor_name = question.author.username\ndb.relationship的第二个参数backref=db.backref('questions', order_by=create_time.desc())则建立了一个反向引用，这样我们不仅可以使用question.author，还可以使用author.questions获得一个作者所有的问题，并通过order_by=create_time.desc()按创建时间倒序排列(网页的内容按时间倒序排列)，返回的是一个Questions对象的列表，可以遍历它获取每个对象，如获取作者Harp的所有问题的title：\nauthor = Users.query.filter(Users.username == 'Harp').first()\nfor question in author.questions:\n    print(question.title)\n\n同理，comments_info表(Comments模型)代码如下：\nclass Comments(db.Model):\n    __tablename__ = 'comments_info'\n    id = db.Column(db.Integer, primary_key=True, autoincrement=True)\n    content = db.Column(db.TEXT, nullable=False)\n    question_id = db.Column(db.Integer, db.ForeignKey('questions_info.id'))\n    author_id = db.Column(db.Integer, db.ForeignKey('users_info.id'))\n    create_time = db.Column(db.DateTime, nullable=False, default=datetime.now())\n\n    author = db.relationship('Users', backref=db.backref('comments'))\n    question = db.relationship('Questions', backref=db.backref('comments', order_by=create_time.desc()))\n\n在HarpQA.py中，我们要从models.py导入db及所有的模型，注意因为上下文的关系，我们这里用with语句把app推入栈中：\nfrom flask import Flask, render_template\nfrom models import db, Users, Questions, Comments\n\nimport config\n\napp = Flask(__name__)\napp.config.from_object(config)\n\ndb.init_app(app)\n\nwith app.test_request_context():\n    db.drop_all()\n    db.create_all()\n\n\n@app.route('/')\ndef index():\n    return render_template('home.html')\n\n\nif __name__ == '__main__':\n    app.run()\n运行脚本，此时数据库已经把三张表都建立好了：\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}