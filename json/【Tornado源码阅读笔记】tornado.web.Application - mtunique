{"title": "【Tornado源码阅读笔记】tornado.web.Application - mtunique ", "index": "源码学习,源码,python,tornado", "content": "从tornado的 Hello,world 开始分析tornado的源码\n\npythonimport tornado.ioloop\nimport tornado.web\n\nclass MainHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.write(\"Hello, world\")\n\napplication = tornado.web.Application([\n    (r\"/\", MainHandler),\n])\n\nif __name__ == \"__main__\":\n    application.listen(8888)\n    tornado.ioloop.IOLoop.instance().start()\n\n\n很容易可以看出，通过继承RequestHandler类定义自己的处理类，来处理请求。Application类的对象来处理URI的路由（将URIr\"/\"于处理类MainHandler组成tuple，关联起来）。\n\ntornado.web.Application类\n\n一、__init__\n\n\n简化版代码：\n\npythondef __init__(self, handlers=None, default_host=\"\", transforms=None,\n             **settings):\n    if transforms is None:\n        self.transforms = []\n        if settings.get(\"compress_response\") or settings.get(\"gzip\"):\n            self.transforms.append(GZipContentEncoding)\n    else:\n        self.transforms = transforms\n    ......\n    self.ui_modules = {'linkify': _linkify,\n                       'xsrf_form_html': _xsrf_form_html,\n                       'Template': TemplateModule,\n                       }\n    self.ui_methods = {}\n    self._load_ui_modules(settings.get(\"ui_modules\", {}))\n    self._load_ui_methods(settings.get(\"ui_methods\", {}))\n\n    if self.settings.get(\"static_path\"):\n        ......\n    if handlers:\n        self.add_handlers(\".*$\", handlers)\n\n    if self.settings.get('debug'):\n        self.settings.setdefault('autoreload', True)\n        ......\n    # Automatically reload modified modules\n    if self.settings.get('autoreload'):\n        from tornado import autoreload\n        autoreload.start()\n\n\n参数handlers是一个list，list里每个object是一个URLSpec的对象或tuple。tuple可以是二到四个element，分别是URI的正则、handler类、用于初始化URLSpec的kwargs、handler的name。（下面add_handlers详细说明）\n\n参数settings是一个dict，所有settings的具体用法\n\n\n初始化transforms（HTTP传输压缩等，默认GZipContentEncoding 和 ChunkedTransferEncoding 。也可以自己实现，需要实现 transform_first_chunk 和 transform_chunk 接口，RequestHandler 中的 flush 调用，剖析RequestHandler时详细介绍），UI模块\n通过settings的值来初始化静态文件处理Handler，包括：\nstatic_path\nstatic_url_prefix\nstatic_handler_class\nstatic_handler_args\nstatic_hash_cache\n\n\n初始化其他settings\n调用add_handlers方法添加handlers。\n加载自动重新加载模块（当检测到代码被修改后重构启动）\n\n\n二、add_handle\n\n\npythondef add_handlers(self, host_pattern, host_handlers):\n    if not host_pattern.endswith(\"$\"):\n        host_pattern += \"$\"\n    handlers = []\n    if self.handlers and self.handlers[-1][0].pattern == '.*$':\n        self.handlers.insert(-1, (re.compile(host_pattern), handlers))\n    else:\n        self.handlers.append((re.compile(host_pattern), handlers))\n\n    for spec in host_handlers:\n        if isinstance(spec, (tuple, list)):\n            assert len(spec) in (2, 3, 4)\n            spec = URLSpec(*spec)\n        handlers.append(spec)\n        if spec.name:\n            if spec.name in self.named_handlers:\n                app_log.warning(\n                    \"Multiple handlers named %s; replacing previous value\",\n                    spec.name)\n            self.named_handlers[spec.name] = spec\n\n\n将host_pattern和handlers，组成tuple加到self.handlers的末尾但是在匹配所有域名的tuple前。\n\n由spec = URLSpec(*spec)易看出初始化Application的时候的第一个参数存的tuple是用来初始化URLSpec的所以参数顺序应该和URLSpec要求的一样（def __init__(self, pattern, handler, kwargs=None, name=None)）。\n\n用过第四个参数name来构造反响代理，储存在Application的named_handlers（dict）里。\n\nhello world里调用了Application的listen和tornado.ioloop.IOLoop.instance().start()（以后会详细介绍ioloop），来真正启动。\n\n三、listen\n\n\npythondef listen(self, port, address=\"\", **kwargs):\n        from tornado.httpserver import HTTPServer\n        server = HTTPServer(self, **kwargs)\n        server.listen(port, address)\n\n\n实例化一个HTTPServer，将application绑定上去。HTTPServer调用application的start_request来将application和connection绑定在一起初始化一个_RequestDispatcher的对象，由其来处理请求的路由，来利用add_handler建立的规则。\n\n原文连接\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "9"}