{"title": "Making Your Python Codes More Functional - λ and τ ", "index": "函数式编程,data-science,python", "content": "本篇文章是基于Joel Grus: Learning Data Science Using Functional Python视频的笔记。\n常用的函数\ncurrying\n在Python中实现科里化的最佳方案是functools.partial。例如以下例子：\n# 一般版本\ndef add1(x): return add(1, x)\n\n# FP的版本\nadd1_functional = partial(add, 1)\nreduce、map、filter\n这几个是常见的FP中处理列表的函数，在此不做介绍。\n注意：Python这得reduce在functools包中。\niterators（迭代器）\n以下是个迭代器的例子：\nIn [4]: a  = [1,3,4]\n\nIn [5]: b = iter(a)\n\nIn [6]: next(b)\nOut[6]: 1\n\nIn [7]: next(b)\nOut[7]: 3\n\nIn [8]: next(b)\nOut[8]: 4\n\nIn [9]: next(b)\n---------------------------------------------------------------------------\nStopIteration                             Traceback (most recent call last)\n<ipython-input-9-641a931447e8> in <module>()\n----> 1 next(b)\n\nStopIteration:\n\n迭代器的特点主要包括：\n\n一次只用一个\n只有需要时才会产生数据。\n\n这两个特点保证了其惰性的特点，而另一个好处是我们可以构造无穷序列。\ngenerator生成器\n生成器所要生成的结果其实就是迭代器，如下：\ndef lazy_integers(n = 0):\n    while True:\n        yield n\n        n += 1\n\nxs = lazy_integers()\n\n[next(xs) for _ in range(10)]\n# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n[next(xs) for _ in range(10)]\n# [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]\n上面的例子我们可以看出，生成器在此生成了一个无穷长度的序列，由于其惰性我们可以在有限内存之中储存这个无穷序列。但值得注意的是，因为迭代器中的每个值只能使用一次，就会得到同样语句不同结果的例子（见上）。\n一个高阶的用法\nsquares = (x ** 2 for x in lazy_integers())\ndoubles = (x * x for x in lazy_integers())\n\nnext(squares) #0\nnext(squares) #1\nnext(squares) #4\n我们发现使用tuple可以直接改变迭代器中的每个元素，这个特性很方便；但值得注意的是，不能写成列表的形式，不然输出值就不为惰性迭代器，就会引起内存外溢。\n生成器模拟pipeline\n考虑一个文件之中出现某个单词（例如“prime”）的句子个数，采用函数式的方法，显然，如下：\nwith open(\"a.txt\", \"r\") as f:\n    lines = (line for line in f)\n    prime_lines = filter(lambda line: \"prime\" in line.lower(), lines)\n    \n    \nline_count = len(list(prime_lines))\nitertools模块\nitertools模块提供了大量用于操作迭代器的函数。\n\n\n函数名\n参数\n作用\n\n\n\ncount\n[start=0], [step=1]\n输出无穷序列(start, start + step, start + 2 * step...)\n\n\nislice\nseq, [start=0], stop, [step=1]\n输出序列的切片\n\n\ntee\nit, [n=2]\n复制序列，输出为多个相同序列组成的元组\n\n\nrepeat\nelem, [n=forever]\n重复序列n次，输出为一个repeat元素\n\n\ncycle\np\n无限重复cycle里的元素\n\n\nchain\np, q, ...\n迭代p里的元素，然后再迭代q的元素，...\n\n\naccumulate\np, [func=add]\n返回(p[0], func(p[0], p[1]), func(func(p[0], p[1]), p[2])...)\n\n\n\n自定义一些常用的迭代工具\ndef take(n, it):\n    \"\"\"\n    将前n个元素固定转为列表\n    \"\"\"\n    return [x for x in islice(it, n)]\n    \n    \ndef drop(n, it):\n    \"\"\"\n    剔除前n个元素\n    \"\"\"\n    return islice(it, n, None)\n    \n\n# 获取序列的头\nhead = next\n\n# 获取除第一个元素外的尾\ntail = partial(drop, 1) \n此外，很常见的另一个函数是获得一个递推的迭代器函数，即已知x, f，获得(x, f(x), f(f(x)),...)\ndef iterate(f, x):\n    yield x\n    yield from iterate(f, f(x))\n注意，要防止mutation，就是说到底复制的是指针还是指针代表的数，显然下面的写法是有问题的：\ndef iterate(f, x):\n    while True:\n        yield x\n        x = f(x)\n一个简单的避免方法是：\ndef iterate(f, x):\n    return accumulate(repeat(x), lambda fx, _:f(fx))\n使iterate\n\ndef lazy_integers():\n    return iterate(add1, 0)\n\ntake(10, lazy_integers())\n一个例子：斐波那契数列\n基本写法\ndef fib(n):\n    if n == 0: return 1\n    if n == 1: return 1\n    return fib(n - 1) + fib(n - 2)\n\n\n[fib(i) for i in range(10)]\n升级写法——mutable but functional\ndef fibs():\n    a, b = 0, 1\n    while True:\n        yield b\n        a, b = b, a + b\n        \ntake(10, fibs())\nHaskell-Like 写法\ndef fibs():\n    yield 1\n    yield 1\n    yield from map(add, fibs(), tail(fibs()))\n\ntake(10, fibs())\n尾递归的haskell-like版本\ndef fibs():\n    yield 1\n    yield 1\n    fibs1, fibs2 = tee(fibs())\n    yield from map(add, fibs1, tail(fibs2))\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "8"}