{"title": "python高级特性 - 码农日志 ", "index": "python", "content": "python的高级特性\n名词与翻译对照表\n\ngenerator 生成器\niterator 迭代器\ncollection 集合\npack/unpack  打包/解包\ndecorator 装饰器\ncontext manager 上下文管理器\n\n本篇文章重点介绍以下内容\npython语言的一些高阶用法主要有以下几个特性：\n\ngenerators生成器用法\ncollections包常见用法\nitertools包常见用法\npacking/unpacking封包/解包特性\nDecorators装饰器\nContext Managers上下文管理期\n\n以上几个特性我会针对应用场景，使用注意事项，应用举例几个维度分别进行讲解，如果有同学对某个特性特别熟悉则可以直接跳过。\ngenerators生成器用法\ngenerator一般用来产生序列类型的值得对象，一般都可以在for循环中迭代，也可以通过next方法调用，生成器可以通过yield关键字产生。\n生成器的作用：\n\n\n减少内存占用比如：利用迭代器的使用方式打开文件\nwith open(\"/path/to/file\") as f:\n    for line in f:   # 这个地方迭代文件\n        print(line)\n\n提高运行效率\n延迟运行，仅当需要运行的地方才开始执行\n\n如下例子：\ndef fibonacci_generator():\n    a, b = 0, 1\n    while True:\n        yield a\n        a, b = b, a + b\n\n# Print all the numbers of the Fibonacci sequence that are lower than 1000\nfor i in fibonacci_generator():\n    if i > 1000:\n        break\n    print(i)\n输出结果\n0\n1\n1\n2\n3\n5\n8\n13\n21\n34\n55\n89\n144\n233\n377\n610\n987\n在python中可以使用生成器表达式去迭代一个对象，生成器表达式和列表最大的差别就在于是否一次性将结果计算完成，举例如下：\na = (x * x for x in range(100))\n\n# a is a generator object\nprint(type(a))\n\n# Sum all the numbers of the generator\nprint(sum(a))\n\n# There are no elements left in the generator\nprint(sum(a))\n输出结果如下：\n<class 'generator'>\n328350\n0\ncollections包常见用法\ncollections包是标准库的一个模块，主要目的是用来扩展容器相关的数据类型，我们通过dir查看collections包有哪些模块：\n>>> import collections\n>>> dir(collections)\n['Callable', 'Container', 'Counter', 'Hashable', 'ItemsView', 'Iterable', 'Iterator', 'KeysView', 'Mapping', 'MappingView', 'MutableMapping', 'MutableSequence', 'MutableSet', 'OrderedDict', 'Sequence', 'Set', 'Sized', 'ValuesView', '__all__', '__builtins__', '__doc__', '__file__', '__name__', '__package__', '_abcoll', '_chain', '_class_template', '_eq', '_field_template', '_get_ident', '_heapq', '_imap', '_iskeyword', '_itemgetter', '_repeat', '_repr_template', '_starmap', '_sys', 'defaultdict', 'deque', 'namedtuple']\n我们以Counter为例：\nfrom collections import Counter\n\na = Counter('blue')\nb = Counter('yellow')\n\nprint(a)\nprint(b)\nprint((a + b).most_common(3))\n输出结果如下：\nCounter({'u': 1, 'e': 1, 'l': 1, 'b': 1})\nCounter({'l': 2, 'y': 1, 'e': 1, 'o': 1, 'w': 1})\n[('l', 3), ('e', 2), ('y', 1)]\n另外defaultdict也是我常用的一个模块，defaultdict是dict的子类，允许我们通过工厂方法来动态创建不存在的属性，举例如下：\nfrom collections import defaultdict\n\nmy_dict = defaultdict(lambda: 'Default Value')\nmy_dict['a'] = 42\n\nprint(my_dict['a'])\nprint(my_dict['b'])\n运行结果如下：\n42\nDefault Value\n在工作中我经常用defaultdict来构造一颗树形数据结构来满足我的常规需求，实例如下：\nfrom collections import defaultdict\nimport json\n\ndef tree():\n    \"\"\"\n    Factory that creates a defaultdict that also uses this factory\n    \"\"\"\n    return defaultdict(tree)\n\nroot = tree()\nroot['Page']['Python']['defaultdict']['Title'] = 'Using defaultdict'\nroot['Page']['Python']['defaultdict']['Subtitle'] = 'Create a tree'\nroot['Page']['Java'] = None\n\nprint(json.dumps(root, indent=4))\n运行结果如下：\n{\n    \"Page\": {\n        \"Python\": {\n            \"defaultdict\": {\n                \"Subtitle\": \"Create a tree\",\n                \"Title\": \"Using defaultdict\"\n            }\n        },\n        \"Java\": null\n    }\n}\nitertools包常见用法\nitertools包也是标准库的一个模块，他常见的用法是用来扩展迭代器的使用，高效的执行迭代\n我们通过dir方法来查看itertools都有哪些模块\n>>> import itertools\n>>> dir(itertools)\n['__doc__', '__file__', '__name__', '__package__', 'chain', 'combinations', 'combinations_with_replacement', 'compress', 'count', 'cycle', 'dropwhile', 'groupby', 'ifilter', 'ifilterfalse', 'imap', 'islice', 'izip', 'izip_longest', 'permutations', 'product', 'repeat', 'starmap', 'takewhile', 'tee']\n我们以permutations举例如下：\nfrom itertools import permutations\n\nfor p in permutations([1,2,3]):\n    print(p)\n输出结果：\n(1, 2, 3)\n(1, 3, 2)\n(2, 1, 3)\n(2, 3, 1)\n(3, 1, 2)\n(3, 2, 1)\ncombinations示例如下：\nfrom itertools import combinations\n\nfor c in combinations([1, 2, 3, 4], 2):\n    print(c)\n输出结果：\n(1, 2)\n(1, 3)\n(1, 4)\n(2, 3)\n(2, 4)\n(3, 4)\n另外chain模块也是常用模块之一chain使用示例：\nfrom itertools import chain\n\nfor c in chain(range(3), range(12, 15)):\n    print(c)\n输出结果如下：\n0\n1\n2\n12\n13\n14\n另外itertools工具包里还有很多常见的用法，这里不再一一举例，大家可以自行尝试。\npacking/unpacking特性\n在函数参数里使用*args，**kwargs都很常见，但是以下的几种用法你们有试过吗？\na, *b, c = [2, 7, 5, 6, 3, 4, 1]\nprint(a)\nprint(b)\nprint(c)\n以上代码输出：\n2\n[7, 5, 6, 3, 4]\n1\n有同学抱怨说这样运行不对，会报错，呵呵，那是因为你用的python2，python3中已经对pack，unpack特性进行了很好的实现。\n刚才我已经看到了pack的举例，我们接下来再看看unpack\ndef repeat(count, name):\n    for i in range(count):\n        print(name)\n\nprint(\"Call function repeat using a list of arguments:\")\nargs = [4, \"cats\"]\nrepeat(*args)\n\nprint(\"Call function repeat using a dictionary of keyword arguments:\")\nargs2 = {'count': 4, 'name': 'cats'}\nrepeat(**args2)\n运行结果如下：\nCall function repeat using a list of arguments:\ncats\ncats\ncats\ncats\nCall function repeat using a dictionary of keyword arguments:\ncats\ncats\ncats\ncats\n最后我们再回归到函数参数的例子上：\ndef f(*args, **kwargs):\n    print(\"Arguments: \", args)\n    print(\"Keyword arguments: \", kwargs)\n\nf(3, 4, 9, foo=42, bar=7)\n以上代码输出：\nArguments:  (3, 4, 9)\nKeyword arguments:  {'bar': 7, 'foo': 42}\nDecorators装饰器\n装饰器这个语法糖相信使用flask或者bottle的同学应该都不陌生，使用django的也应该经常会遇到，但是大家有没有去想过这个语法糖的应用场景呢？我简单整理了下，大概有以下几种装饰器：\n\n缓存装饰器\n权限验证装饰器\n计时装饰器\n日志装饰器\n路由装饰器\n异常处理装饰器\n错误重试装饰器\n\n我们拿缓存装饰器举例：\ndef cache(function):\n    cached_values = {}  # Contains already computed values\n    def wrapping_function(*args):\n        if args not in cached_values:\n            # Call the function only if we haven't already done it for those parameters\n            cached_values[args] = function(*args)\n        return cached_values[args]\n    return wrapping_function\n\n@cache\ndef fibonacci(n):\n    print('calling fibonacci(%d)' % n)\n    if n < 2:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\nprint([fibonacci(n) for n in range(1, 9)])\n以上代码输出：\ncalling fibonacci(1)\ncalling fibonacci(2)\ncalling fibonacci(0)\ncalling fibonacci(3)\ncalling fibonacci(4)\ncalling fibonacci(5)\ncalling fibonacci(6)\ncalling fibonacci(7)\ncalling fibonacci(8)\n[1, 1, 2, 3, 5, 8, 13, 21]\n在python3中有一个包叫做lrucache，就是用的装饰器的语法糖进行实现。\nlrucache的简单实用如下：\nfrom functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef fibonacci(n):\n    print('calling fibonacci(%d)' % n)\n    if n < 2:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\nprint([fibonacci(n) for n in range(1, 9)])\n运行结果：\ncalling fibonacci(1)\ncalling fibonacci(2)\ncalling fibonacci(0)\ncalling fibonacci(3)\ncalling fibonacci(4)\ncalling fibonacci(5)\ncalling fibonacci(6)\ncalling fibonacci(7)\ncalling fibonacci(8)\n[1, 1, 2, 3, 5, 8, 13, 21]\nContext Managers上下文管理期\n最后我们再看python中的上下文管理器，这个语法糖在资源管理上有很常见的使用场景，比如上文中我用with open(\"file\") as的用法，使用了with后就不用担心文件不会关闭了，在处理socket编程的时候也可以用。这个语法糖其实也不难就是两个魔术方法的实现，__enter__ 和 __exit__，一个控制入口，一个控制出口。\n常规的使用with来统计一段代码运行时间的例子：\nfrom time import time\n\n\nclass Timer():\n    def __init__(self, message):\n        self.message = message\n\n    def __enter__(self):\n        self.start = time()\n        return None  # could return anything, to be used like this: with Timer(\"Message\") as value:\n\n    def __exit__(self, type, value, traceback):\n        elapsed_time = (time() - self.start) * 1000\n        print(self.message.format(elapsed_time))\n\n\nwith Timer(\"Elapsed time to compute some prime numbers: {}ms\"):\n    primes = []\n    for x in range(2, 500):\n        if not any(x % p == 0 for p in primes):\n            primes.append(x)\n    print(\"Primes: {}\".format(primes))\n输出结果：\nPrimes: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499]\nElapsed time to compute some prime numbers: 1.055002212524414ms\n总结\n其实python是一门特别人性化的语言，但凡在工程中经常遇到的问题，处理起来比较棘手的模式基本都有对应的比较优雅的解决方案。有些写Java同学写python代码经常看起来像是写C，没有一点python语言的影子，因此简单整理了下python进阶的一些用法，希望能够帮助一些同学。\nPS:大家如果转载请保留出处和作者PS:如果希望收到本人更多的技术笔记欢迎关注本公共号或者搜索CodingFutuer进行关注\n\n\n                ", "mainLikeNum": ["4 "], "mainBookmarkNum": "18"}