{"title": "flask接收请求并推入栈 - 个人文章 ", "index": "flask,python", "content": "前面两篇讲明了flask怎么支持多线程以及怎么开启多线程的,这篇来讲讲当后端接收到请求后是怎么一步步封装的\nFlask类中的wsgi_app()当应用启动后WSGI Server会通过Flask.__call__()接收http请求,Flask.__call__()中返回的是wsgi_app()方法,\ndef wsgi_app(self, environ, start_response):\n    ctx = self.request_context(environ)\n    ctx.push()\n    error = None\n    try:\n        try:\n            response = self.full_dispatch_request()\n        except Exception as e:\n            error = e\n            response = self.handle_exception(e)\n        except:\n            error = sys.exc_info()[1]\n            raise\n        return response(environ, start_response)\n    finally:\n        if self.should_ignore_error(error):\n            error = None\n        ctx.auto_pop(error)\n\nwsgi_app()主要做了两件事情:第一件事是通过Flask的另一个方法request_context()返回得到了一个封装好的RequsetContext对象,ctx = self.request_context(environ),然后调用RequestContext中的push(),\nclass RequestContext(object):\ndef push(self):\n    app_ctx = _app_ctx_stack.top\n    if app_ctx is None or app_ctx.app != self.app:\n        app_ctx = self.app.app_context()\n        app_ctx.push()\n        self._implicit_app_ctx_stack.append(app_ctx)\n    else:\n        self._implicit_app_ctx_stack.append(None)\n\n    if hasattr(sys, 'exc_clear'):\n        sys.exc_clear()\n\n    _request_ctx_stack.push(self)\n\n    self.session = self.app.open_session(self.request)\n    if self.session is None:\n        self.session = self.app.make_null_session()\n\n在最后调用了_request_ctx_stack.push(self),将请求对象推入请求上下文栈中第二件事是在RequestContext的push()中调用app_ctx = self.app.app_context(),app_ctx.push(),将app推入应用上下文栈,深究下去时可以发现,在RequestContext中有个app属性,它在Flask中的request_context(),也就是在wasi_app()中调用self.request_context(environ)时被赋值,\ndef request_context(self, environ):\n    return RequestContext(self, environ)\n\n可以看到每次都传入了self,也就是Flask对象,它在RequestContext中赋值给了self.app,所以在RequestContext push()中每次推入应用上下文的app都是同一个有两点需要注意:1.在web runtime情况下,请求上下文和应用上下文,同时存在,同时消亡2.创建完应用后不会立即生成应用上下文RequestContext中放了request和sessionAppContext中放了gcurrent_app就是AppContext对象Local()中的__storage__这个字典格式是{thread_id:{'stack':[<RequestContext>,...]}}所以LocalStack中的top方法返回的结果有两个:一个是RequestContext对象,一个是AppContext对象最后抛两个问题,下次写1.明明一个线程只能处理一个请求,那么栈里的元素永远是在栈顶,那为什么需要用栈这个结构?用普通变量不行吗.2._request_ctx_stack和_app_ctx_stack都是线程隔离的,那么为什么要分开?\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}