{"title": "7. Reverse Integer - 卢卡斯 ", "index": "python,leetcode", "content": "题目链接：Reverse Integer\n思路：因为Python中的数字是没有overflow的，即limit取决于电脑的内存。不过题目有额外要求，假设我们只能处理32-bit signed 的数字区间。 所以需要另外加一个判断。另外，Python内置的int()函数可以把 \"001\" 转换成数字 1。\n数字要注意区分正负。负数反转还是负数。对于Python来说，有两种解法：\n\n可以把数字转换成字符串反转然后转换回数字\n可以把反转的数字乘以10加上x % 10，x每次除以10直到0为止\n\n算法复杂度：Pythonic:\n时间：O(x)\n空间：O(n) where n is the length of x\n一般方法：\n时间：O(logx) \n空间：O(n) where n is the length of x\n\n代码：\nPythonic Approach\nclass Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        if x < 0:\n            minus_sign = str(x)[0]\n            abs_x = abs(x)\n            res = minus_sign + str(abs_x)[::-1]\n            if int(res) > 2**31-1 or int(res) < -2**31:\n                return 0\n            else:\n                return int(res)\n        else:\n            if int(str(x)[::-1]) > 2**31-1 or int(str(x)[::-1]) < -2**31:\n                return 0\n            else:\n                return int(str(x)[::-1])\n\n一般方法\nclass Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        sign = 1 if x > 0 else -1\n        x = abs(x)\n        t = 0\n        while x:\n            t = t*10 + x % 10\n            x  //= 10\n        t = t * sign\n        if t > 2**31-1 or t < -2**31:\n            return 0\n        else:\n            return t\n\n\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}