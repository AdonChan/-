{"title": "opencv python 基于SVM的手写体识别 - 个人文章 ", "index": "opencv-python,opencv,python", "content": "OCR of Hand-written Data using SVM \n在kNN中，我们直接使用像素强度作为特征向量。 这次我们将使用方向梯度直方图（HOG）作为特征向量。在计算HOG之前，使用其二阶矩来校正图像：\ndef deskew(img):\n    m = cv2.moments(img)\n    if abs(m['mu02']) < 1e-2:\n        return img.copy()\n    skew = m['mu11']/m['mu02']\n    M = np.float32([[1, skew, -0.5*SZ*skew], [0, 1, 0]])\n    img = cv2.warpAffine(img,M,(SZ, SZ),flags=affine_flags)\n    return img\n\n接下来，我们必须找到每个单元格的HOG描述符，为此，我们在X和Y方向上找到每个单元的Sobel导数，然后在每个像素处找到它们的大小和梯度方向，该梯度量化为16个整数值，将此图像分为四个子方块，对于每个子平方，计算方向的直方图（16个区间），用它们的大小加权，因此每个子方格都会为您提供一个包含16个值的向量，四个这样的矢量（四个子方块）一起给出了包含64个值的特征向量，这是我们用来训练数据的特征向量。\ndef hog(img):\n    gx = cv2.Sobel(img, cv2.CV_32F, 1, 0)\n    gy = cv2.Sobel(img, cv2.CV_32F, 0, 1)\n    mag, ang = cv2.cartToPolar(gx, gy)\n    bins = np.int32(bin_n*ang/(2*np.pi))    # quantizing binvalues in (0...16)\n    bin_cells = bins[:10,:10], bins[10:,:10], bins[:10,10:], bins[10:,10:]\n    mag_cells = mag[:10,:10], mag[10:,:10], mag[:10,10:], mag[10:,10:]\n    hists = [np.bincount(b.ravel(), m.ravel(), bin_n) for b, m in zip(bin_cells, mag_cells)]\n    hist = np.hstack(hists)     # hist is a 64 bit vector\n    return hist\n\n最后，与前一种情况一样，我们首先将大数据集拆分为单个单元格，对于每个数字，保留250个单元用于训练数据，剩余的250个数据保留用于测试。\nimport numpy as np\nimport cv2\nimport matplotlib.pyplot as plt\n\n\nSZ=20\nbin_n = 16 # Number of bins\n\n\naffine_flags = cv2.WARP_INVERSE_MAP|cv2.INTER_LINEAR\n\n\ndef deskew(img):\n    m = cv2.moments(img)\n    if abs(m['mu02']) < 1e-2:\n        return img.copy()\n    skew = m['mu11']/m['mu02']\n    M = np.float32([[1, skew, -0.5*SZ*skew], [0, 1, 0]])\n    img = cv2.warpAffine(img,M,(SZ, SZ),flags=affine_flags)\n    return img\n\n\n\ndef hog(img):\n    gx = cv2.Sobel(img, cv2.CV_32F, 1, 0)\n    gy = cv2.Sobel(img, cv2.CV_32F, 0, 1)\n    mag, ang = cv2.cartToPolar(gx, gy)\n    bins = np.int32(bin_n*ang/(2*np.pi))    # quantizing binvalues in (0...16)\n    bin_cells = bins[:10,:10], bins[10:,:10], bins[:10,10:], bins[10:,10:]\n    mag_cells = mag[:10,:10], mag[10:,:10], mag[:10,10:], mag[10:,10:]\n    hists = [np.bincount(b.ravel(), m.ravel(), bin_n) for b, m in zip(bin_cells, mag_cells)]\n    hist = np.hstack(hists)     # hist is a 64 bit vector\n    return hist\n\n\nimg = cv2.imread('digits.png',0)\nif img is None:\n    raise Exception(\"we need the digits.png image from samples/data here !\")\n\n\ncells = [np.hsplit(row,100) for row in np.vsplit(img,50)]\n\n# First half is trainData, remaining is testData\ntrain_cells = [ i[:50] for i in cells ]\ntest_cells = [ i[50:] for i in cells]\n\n\n\ndeskewed = [list(map(deskew,row)) for row in train_cells]\nhogdata = [list(map(hog,row)) for row in deskewed]\ntrainData = np.float32(hogdata).reshape(-1,64)\nresponses = np.repeat(np.arange(10),250)[:,np.newaxis]\n\nsvm = cv2.ml.SVM_create()\nsvm.setKernel(cv2.ml.SVM_LINEAR)\nsvm.setType(cv2.ml.SVM_C_SVC)\nsvm.setC(2.67)\nsvm.setGamma(5.383)\n\nsvm.train(trainData, cv2.ml.ROW_SAMPLE, responses)\nsvm.save('svm_data.dat')\n\n\n\ndeskewed = [list(map(deskew,row)) for row in test_cells]\nhogdata = [list(map(hog,row)) for row in deskewed]\ntestData = np.float32(hogdata).reshape(-1,bin_n*4)\nresult = svm.predict(testData)[1]\n\n\nmask = result==responses\ncorrect = np.count_nonzero(mask)\nprint(correct*100.0/result.size)\n输出：93.8\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}