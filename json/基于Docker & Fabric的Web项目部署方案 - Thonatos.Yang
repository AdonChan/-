{"title": "基于Docker & Fabric的Web项目部署方案 - Thonatos.Yang ", "index": "python,fabric,docker", "content": "本文描述了Web项目的两种部署方案，石器时代的ssh & pull & restart方式不做太多说明\n1.基于Fabric（Python）的部署方案\nFabric 是一个用于ssh的Python库&命令行工具\nFabric is a Python (2.5-2.7) library and command-line tool for streamlining the use of SSH for application deployment or systems administration tasks.\n1.1结构\n\n\nInterface\n\nflask\ndjango\n...\n\n\n\nScript\n\nfabric\n\nconf (服务器配置列表)\nlib（基础库&二次开发）\n\n\n\n\n1.2示例\n1.2.1.配置文件conf_server.sample.py\n\n#!/usr/bin/env python\n# coding=utf-8\n\nSERVER_DICT = {\n    \"www\": [\n        \"root@0.0.0.0\",\n        \"password\",\n        \"/home/mt/v1\"\n    ],\n    \"v1\": [\n        \"root@0.0.0.0\",\n        \"password\",\n        \"/home/mt/v1\"\n    ],\n    \"v2\": [\n        \"root@0.0.0.0\",\n        \"password\",\n        \"/home/mt/v2\"\n    ],\n    \"v3\": [\n        \"root@0.0.0.0\",\n        \"password\",\n        \"/home/mt/v3\"\n    ]\n}\n1.2.2.更新操作deploy.py\n\n#!/usr/bin/env python\n# coding=utf-8\n\nimport sys\nsys.path.append(\"..\")\nfrom conf.conf_server import *\nfrom fabric.api import env, run, local\n\n    def run_remote(self):\n        print env.host_string\n        _path = self.project[2]\n        _string = 'su mt -c \"cd %s && git pull origin master\"' % _path\n        run(_string)\n1.3说明\n通过不同服务器的配置信息，使用http|socket等方式发送特定的参数如cloud|help来运行上述的命令达到热更新以及修复的功能.对应的接口实现可以通过指定：\n\n基于权限的主动更新(不同身份的管理员人肉发送命令)\n基于项目的自动更新(webhook)\n\n注意：项目代码需要特定的branch（不过这其实也是规范化的代码管理必需）\n示例：\n# 命令行操作\npython deploy.py www\n\n# Http接口\ncurl -X POST -H \"Content-Type: application/x-www-form-urlencoded\" -d 'site=www' \"http://api.thonatos.com/deploy/\"\n2.基于Docker的部署方案\nDocker是一个将程序以及其依赖打包进一个标准单元的服务或者工具集\nDocker allows you to package an application with all of its dependencies into a standardized unit for software development.\n2.1基础\nDocker服务的基础是虚拟机，整个Docker服务包含了虚拟机以及操作虚拟机的一些列命令集合\n这里需要理解Docker的几个基本概念，便于更好的理解这种部署开发&部署方式与常规方案的区别\n\nimage（镜像）\ncontainer（容器）\nserver（服务器）\n\n镜像相当于一个Linux发行版，对比于Linux下的Ubuntu、CentOs等，我们可以按照自己的需求去定义这个发行版的内容以及组件，基础镜像是最小化的Linux运行单元，那么，我们需要做的就是根据程序的需要，安装各种依赖组件，并将APP+DEP进行打包，变成我们的“定制发行版”，以此来部署在真实Server上。于此同时，镜像在初始化的过程中，可以定义一些列操作，比如——安装依赖、拉取代码以及运行程序\n容器是一个实例化以后的虚拟机，容器依赖于镜像，在镜像的基础上做实例化，是初始化以后的虚拟机\n服务器，就是传统的服务器如实体服务器或者云主机等\nDocker对应了一些列的服务端程序，是标准的C/S架构，每一个服务器运行一个或多个容器，一个或多个容器的集合叫做集群，对服务器进行一些列的包装后变成一个控制台，不再去关心服务器的初始化过程，只管理容器本身是目前Docker的优势所在。具体表现为，按照原有方式，我们需要先开通N台服务器，再依次在每一台机器上安装虚拟机；现在需要的是，将所有的服务器进行封装，变成一个通道，在盒子外，我们告诉盒子我们需要多少个容器，它返回给我们对应的服务即可。国内的DaoCloud、阿里云容器服务已经相对完善。（阿里测试中，DaoCloud已经相对成熟）\n2.2环境打包\n2.2.1 镜像示例\nFROM node:argon\n\n# Create app directory\nRUN mkdir -p /usr/src/app  \nWORKDIR /usr/src/app\n\n# Clone code & Install app dependencies\nRUN git clone git@github.com:MT-Libraries/MT-Notes.git ./\nRUN npm install\n\nEXPOSE 8080  \nCMD [ \"npm\", \"start\" ]  \n示例在初始化的过程中会从git拉取代码并安装依赖文件，最终运行在8080端口\n2.2.2 部署简述\n\n在DC（DaoCloud）控制台创建一个集群\n在应用中选择基于镜像m创建n个容器\n等待初始化完成，可以看到当前集群中的节点数量（节点即为容器数量）\n同一个集群中的机器可以跑相同或者不同的服务，当需要负载均衡时，动态的加入或者移除节点即可（通过配置，自动伸缩）\n\n2.2.3 节点管理\n节点管理通过阿里云的Agent服务，相当于为每一个节点创建了一个远程shell，我们通过控制台即可轻松升级&更新程序\n\n批量更新\n动态管理\n负载均衡\n\n批量更新，通过一些设定创建的数量如20台 ，创建完毕后，从原有集群移除所有节点，加入创建的节点，即可完成更新操作，后续删除或者销货旧版本的容器。停机更新即完成。\n动态管理，由于数量可以自定义，我们可以在用户无感知的情况下增加服务器到50或者减少服务器到10，在这个过程中，用户是不会感觉到变化的（注：这里需要设计数据共享机制 Session/Cookie）\n3.两种方案的使用\n这两种方案并不存在互斥性，可以并从，也可以只选择一种，如：\n\n独立Fabric，则以服务器镜像为基础，备份服务器本身（缺点是数据量大，服务器最少20G）\n独立Docker，则每次都是通过销货/初始容器的方式来实现，换言之，如果是一台服务器，则需更换IP\n组合使用，针对热更新使用Fabric，针对大规模、大版本、又或者数量大时，使用该方式更便捷\n\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "8"}