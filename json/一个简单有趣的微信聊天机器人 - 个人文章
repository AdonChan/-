{"title": "一个简单有趣的微信聊天机器人 - 个人文章 ", "index": "python3.x,python,wechatapi", "content": "微信已经成了中国人生活中基本的通讯工具(除了那些自由开源人士以外)，前两天发现微信机器人的项目，其实早就有了。想着自己也做一个吧，顺便加了一些小小的功能。\n释放我的机器人\n微信扫一扫加他，跟他尬聊吧，把他拽到群里调戏他。\n\n具体功能下面会介绍。\n工具\n\n\n手机\n微信登陆必须得有手机端登陆才能使用网页登陆，因为要扫一扫\n\n\nPython 平台\n该项目基于 Python 开发，所以至少得来个嵌入式的开发板，或者电脑，或者...云服务器 ;-)，如果要保证长时间开启与话，最好使用云服务器。\n\n\n\n开发微信机器人\n该项目基于 Github 上的 wxpy，使用文档在 这里。中文版的，所以我就不介绍这个怎么使用了。简单描述一下\n创建机器人\nfrom wxpy import *\nbot = Bot()\n注册消息回复\n机器人对好友、群聊中 at 他的人进行回复，在群聊中同时统计每个人的发言次数和第一次发言的时间，将这些信息实时存储在本地，以防程序错误导致数据丢失。\n消息回复中的机器人使用 图灵机器人, 可免费申请 API，调用他。也可以使用 小 I 机器人。这两个都是深度整合在项目里的。\n@bot.register([Friend, Group])\ndef reply_friend(msg):\n    \"\"\"\n    消息自动回复\n    \"\"\"\n    print(msg)\n    if isinstance(msg.chat, Group):\n        group = msg.chat.name\n        name = msg.member.name\n        if group in stat:\n            if name in stat[group]['count']:\n                stat[group]['count'][name] += 1\n            else:\n                stat[group]['count'][name] = 1\n            flag = True\n            for rank in stat[group]['rank']:\n                if name == rank['name']:\n                    flag = False\n                    break\n            if flag:\n                stat[group]['rank'].append({'name': name, 'time': time.strftime(\"%H:%M:%S\", time.localtime())})\n        else:\n            stat[group] = {\"count\": {name: 1}, 'rank': [{'name': name, 'time': time.strftime(\"%H:%M:%S\", time.localtime())}, ]}\n        if msg.text == \"发言排行榜\":\n            g = bot.groups().search(group)[0]\n            if not stat[g.name]:\n                return\n            msg_text = \"\"\n            index = 1\n            count = stat[g.name]['count']\n            for name in sorted(count, key=lambda x: count[x], reverse=True):\n                # print(\"{}: {} {}\".format(index, rank['name'], rank['time']))\n                msg_text += \"{}: {} 发言了 {} 次\\n\".format(index, name, count[name])\n                index += 1\n            if msg_text:\n                msg_text = \"发言排行榜：\\n\" + msg_text\n                g.send(msg_text)\n        if msg.text == \"起床排行榜\":\n            g = bot.groups().search(group)[0]\n            if not stat[g.name]:\n                return\n            msg_text = \"\"\n            index = 1\n            for rank in stat[g.name]['rank']:\n                # print(\"{}: {} {}\".format(index, rank['name'], rank['time']))\n                msg_text += \"{}: {} {}\\n\".format(index, rank['name'], rank['time'])\n                index += 1\n            if msg_text:\n                msg_text = \"起床排行榜：\\n\" + msg_text\n                g.send(msg_text)\n        with open('stat.json', 'w') as fh:\n            fh.write(json.dumps(stat))\n        if not msg.is_at:\n            return\n    return tuling_auto_reply(msg)\n自动接受好友申请\n@bot.register(msg_types=FRIENDS)\ndef auto_accept_friends(msg):\n    \"\"\"\n    自动接受好友请求\n    \"\"\"\n    # 接受好友请求\n    new_friend = msg.card.accept()\n    # 向新的好友发送消息\n    new_friend.send('哈哈，我们现在是超级好的好朋友了呢～～')\n添加计划任务\n光回复怎么够，还要做一些小小的有趣的功能，我这里添加了两个统计，一个是起床时间统计，另一个是发言统计。\n当天群聊的用户第一次发言作为起床时间，虽然有些不严谨，但毕竟功能是受限制的。\n然后每天的 9 点发布一次起床排行榜， 20 点发布一次发言排行榜。当然其实主动发送 “起床排行榜”、“发言排行榜” 也会回复当前的排行。\n起床排行榜\n\n发言排行榜\n\n实现\nclass ScheduleThread(threading.Thread):\n    \"\"\"\n    计划任务线程\n    \"\"\"\n    def run(self):\n        global schedule_time\n        global bot\n        global stat\n        while 1:\n            time.sleep(300)\n            cur_hour = time.strftime(\"%H\", time.localtime())\n            # print(\"cur:{}\\tschedule:{}\".format(cur_hour, schedule_time))\n            if cur_hour == schedule_time:\n                continue\n            elif cur_hour == '09':\n                for group in bot.groups():\n                    print(group.name)\n                    if not stat[group.name]:\n                        continue\n                    msg_text = \"\"\n                    index = 1\n                    for rank in stat[group.name]['rank']:\n                        # print(\"{}: {} {}\".format(index, rank['name'], rank['time']))\n                        msg_text += \"{}: {} {}\\n\".format(index, rank['name'], rank['time'])\n                        index += 1\n                    if msg_text:\n                        msg_text = \"排行日报\\n起床排行榜：\\n\" + msg_text\n                        group.send(msg_text)\n            elif cur_hour == '20':\n                for group in bot.groups():\n                    print(group.name)\n                    if not stat[group.name]:\n                        continue\n                    msg_text = \"\"\n                    index = 1\n                    count = stat[group.name]['count']\n                    for name in sorted(count, key=lambda x: count[x], reverse=True):\n                        # print(\"{}: {} {}\".format(index, rank['name'], rank['time']))\n                        msg_text += \"{}: {} 发言了 {} 次\\n\".format(index, name, count[name])\n                        index += 1\n                    if msg_text:\n                        msg_text = \"排行日报\\n发言排行榜：\\n\" + msg_text\n                        group.send(msg_text)\n            elif cur_hour == '00':\n                stat = dict()\n                with open('stat.json', 'w') as fh:\n                    fh.write('')\n            schedule_time = cur_hour\n聊聊\n展示两个机器人互相尬聊的情况是怎么样的。\n\n部署\n创建机器人时添加一个 console_qr 参数， True 时表示在终端显示二维码，False 表示用图片程序打开二维码。按情况来，如果在没有界面的云服务器上，那就在终端打开，如果只能连 tty ，那最好的办法就是生成一张图片，放到指定的 FTP 或者云盘目录，然后本地打开扫描，或者建个简单的 HTTP 服务器展示图片，方法很多，根据自己情况来吧。\n原文地址：一个简单有趣的微信聊天机器人我的博客：时空路由器\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "9"}