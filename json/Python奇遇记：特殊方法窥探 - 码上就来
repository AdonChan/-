{"title": "Python奇遇记：特殊方法窥探 - 码上就来 ", "index": "python", "content": "什么是特殊方法？当我们在设计一个类的时候，python中有一个用于初始化的方法$__init__$，类似于java中的构造器，这个就是特殊方法，也叫作魔术方法。简单来说，特殊方法可以给你设计的类加上一些神奇的特性，比如可以进行python原生的切片操作，迭代、连乘操作等。在python中，特殊方法以双下划线开始，以双下划线结束。\n一个大例子\n数学中有一个表示数的概念叫做向量，但是python中的数据类型却没有。我们来设法用python实现它。\n首先考虑，向量跟普通的数据类型不同，传统的数可以直接进行运算，向量则需要对不同的坐标分别运算。来试试。\n首先定义一个类，实现初始化方法。\n# 实现向量类型\nclass Vector:\n    \n    def __init__(self, x=0, y=0):\n        self.x = x\n        self.y = y\n如何实现向量的加法？二维向量中，向量的加法就是每个坐标分别相加得到的结果。在python中有个$__add__$方法，用来进行加法操作。\nclass Vector:\n    \n    def __init__(self, x=0, y=0):\n        self.x = x\n        self.y = y\n\n    # 实现向量加法\n    def __add__(self, other):\n        x = self.x + other.x\n        y = self.y + other.y\n        return Vector(x, y)\n我们对x和y变量分别进行相加，然后返回Vector。在python你可以对字符串直接用加法拼接起来的原理就在此，python实现了针对字符串的add方法。\n实现了加法，乘法的道理一样，分别对每个坐标单独相乘即可。\nclass Vector:\n    \n    def __init__(self, x=0, y=0):\n        self.x = x\n        self.y = y\n\n    # 实现向量加法\n    def __add__(self, other):\n        x = self.x + other.x\n        y = self.y + other.y\n        return Vector(x, y)\n    \n    # 实现向量乘法，例如r*3\n    def __mul__(self, scalar):\n        return Vector(self.x*scalar, self.y*scalar)\n我们在进行向量运算时还有一个常用的操作是求向量的模，我们用$__abs__$特殊方法来实现，abs一般用来求一个数的绝对值，向量用不到，用来求模刚好合适。使用math模块中的hypot方法计算$\\sqrt(x^2+y^2)$。\nclass Vector:\n    \n    def __init__(self, x=0, y=0):\n        self.x = x\n        self.y = y\n    \n    # 真假值，如果向量模为0，返回false\n    def __bool__(self):\n        return bool(abs(self))\n\n    # 实现向量加法\n    def __add__(self, other):\n        x = self.x + other.x\n        y = self.y + other.y\n        return Vector(x, y)\n    \n    # 实现向量乘法，例如r*3\n    def __mul__(self, scalar):\n        return Vector(self.x*scalar, self.y*scalar)\n\n    \n    # 返回向量的模\n    # hypot()返回欧几里德范数 sqrt(x*x + y*y)\n    def __abs__(self):\n        return hypot(self.x, self.y)\n找个例子运行下。\nv = Vector(2, 3)\nprint(v)\nv2 = Vector(4, 5)\nprint(v+v2)\nprint(v+v2*2)\n<__main__.Vector object at 0x000002B4B1843C50>\n<__main__.Vector object at 0x000002B4B1843EF0>\n<__main__.Vector object at 0x000002B4B1843898>\n\n\n可以运行了，貌似是正确的，但是输出的结果很奇怪。怎么办？python中有个$__repr__$特殊方法，可以修改控制台输出的样式。\nclass Vector:\n    \n    def __init__(self, x=0, y=0):\n        self.x = x\n        self.y = y\n    \n    # 真假值，如果向量模为0，返回false\n    def __bool__(self):\n        return bool(abs(self))\n\n    # 实现向量加法\n    def __add__(self, other):\n        x = self.x + other.x\n        y = self.y + other.y\n        return Vector(x, y)\n    \n    # 实现向量乘法，例如r*3\n    def __mul__(self, scalar):\n        return Vector(self.x*scalar, self.y*scalar)\n    \n    # 返回向量的模\n    # hypot()返回欧几里德范数 sqrt(x*x + y*y)\n    def __abs__(self):\n        return hypot(self.x, self.y)\n    \n    # 实现__repr__方法，在控制台打印向量时会输出Vector(1, 2)\n    # 实现__str__，使用str()返回字符串\n    def __repr__(self):\n        return 'Vector(%r, %r)' % (self.x, self.y)\n实现了$__repr__$方法，我们就可以在控制台输出Vecotor（x,y）。与之对应的有个$__str__$方法，使用str（）返回相应的字符串，展示给用户。\n现在来看下之前程序运行的结果。\nv = Vector(2, 3)\nprint(v)\nv2 = Vector(4, 5)\nprint(v+v2)\nprint(v+v2*2)\nprint(abs(v))\nVector(2, 3)\nVector(6, 8)\nVector(10, 13)\n3.605551275463989\n\n\n效果不错。\n通过实现特殊方法，自定义类型可以表现的跟内置类型一样，让我们能够写出更具有python风格的代码。\n除了上面说到的几个特殊方法外，python还有差不多80多个特殊方法，比如$__len__$方法可以用来求长度，$__getitem__$可以使用haha[2]之类的操作进行切片和迭代等，同样的还有$__setitem__$。\n\n本人才疏学浅，上文中难免有些错误，还请各位品评指正。如果觉得写的还行，欢迎关注我的公众号MLGroup,带你走进机器学习的世界。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "2"}