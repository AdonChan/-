{"title": "PHP实现订单的延时处理 - 似水流年 ", "index": "centos,php,python", "content": "真没想到自己的这篇很水的文章还有一些可爱的朋友们去阅读，真的很感谢你们。其实这篇文章是我在元旦假期最后一天无事可做的时候偶然脑子抽搐想到的一个场景，然后试着去实现的，其实订单自动取消功能网上有很多可借鉴的方法，包括评论区的朋友们提到的定时任务和消息队列，我这个只是在一个自己想到的方法（我承认真的真的很水）。感谢评论区的朋友们的热心建议和教导，我也会去借鉴一下你们的指导意见，同时继续学习，再次对你们表示感谢~ღ( ´･ᴗ･` )比心\n\n以下是原文：\n业务需求\n最近在做业务的时候需要实现客户下单之后订单超时未支付自动取消的功能，刚开始确认了几种方法：\n\n客户端到时间请求取消\n服务端定时查询有没有需要取消的订单，然后批量处理\n下单后创建定时器，延时处理\n使用redis或者memcache存储，设置过期时间，自动删除\n\n综合考虑上述方法，第一种最先排除，因为如果客户把APP后台禁止或者网络连接禁止，那么就无法发给服务端请求，订单就会一直是未处理状态；第二种方法使用的比较多，不过存在准确度的问题，还有需要确认定时任务的周期，暂时列为后补方法；第四种方法存在的问题就是订单如果删除就是物理删除，无法统计未处理数据（当然可以存redis时候顺便存在mysql这样的数据库做长久存储然后用方法二定时处理）。最终准备使用方法三。再确认使用方法3的时候，由于使用的PHP这种开发语言，所以想实现定时器功能需要借助Swoole或者workerman。由于Swoole是C开发的扩展框架，性能方面肯定比较好，就选了Swoole。\n前期准备\n\n使用Swoole首先需要在服务器上安装Swoole扩展，安装方法和安装其他扩展大同小异，可以参考这边文章\n\n安装完之后检测下扩展是否正常安装，查看phpinfo或者PHP-m,如果出现Swoole，则说明安装成功\n\nSwoole官方文档有定时器的相关文档\n\n\n开始测试\n我们创建一个swoole_test.php文件和一个log.txt文件（用来测试），swoole_test.php代码如下：\n<?php\nswoole_timer_after(3000, function () {\n    append_log(time());\n    echo \"after 3000ms.\\n\";\n});\n\nfunction append_log($str) {\n    $dir = 'log.txt';\n    $fh = fopen($dir, \"a\");\n    fwrite($fh, $str.\"\\n\");\n    fclose($fh);\n}\n然后在网页访问这个PHP文件，结果如下：\n然后在Linux终端运行PHP：/usr/local/php7/bin/php /home/app/swoole_test.php，结果如下：内心一阵。。。原来定时器只能在cli模式下，那么这个想法怕是要GG了，难道就栽倒这里了吗，难道就没有别的方法了吗？就在我欲哭无泪的时候突然灵光乍现，一个词闪到我的脑海：Python！对，我们不能单单靠着PHP啊，还有Python这种神奇的语言呢，我们知道Python的os模块里的os.system方法是可以执行命令行的，那么不就可以实现在cli模式下运行刚才的swoole_test.php文件了么。内心一阵激动后，觉得测试是否可行我们知道Linux都是自带Python的，但是不同的版本Python版本不同，有的自带的是Python2.6，版本过低了，所以需要装一个高版本的，这里我选择Python3，注意不要覆盖系统自带的Python2 。以下是大致的安装步骤：\n\nwget http://python.org/ftp/python/...\n\ntar xf Python-3.6.0.tar.xz\ncd Python-3.6.0\n./configure --prefix=/usr/local/python3\nmake && make install\nln -s /usr/local/python3/bin/python3 /usr/bin/python3\n\n接下来终端输入：Python3，如果出现\n则安装成功。安装完Python3之后，我们新建一个test.py文件，内容如下：\n#!usr/bin/env python3`\n#-*- coding:utf-8 -*-\n\nimport os\nret = os.system(\"/usr/local/php7/bin/php /home/app/swoole_test.php\") #请使用自己系统的绝对路径\nprint(ret)\n\n然后我们在终端执行：/usr/bin/python3 /home/app/test.py，注意：这里只是执行PHP文件，但是文件里的echo内容是不会在终端输出的，这时候就用到刚才新建的log.txt文件了。执行完Python文件后，我们去log文件检查下，发现内容已经写入，所以使用Python是可以实现PHP的cli模式的。┗|｀O′|┛ 嗷~~\n到这里就会有同学疑惑了，你这使用Python实现了PHP的cli模式，但是怎么通过web远程访问呢？这个时候就用到PHP的exec方法了，我们知道PHP的exec方法和Python的os.system方法一样是可以执行命令行命令的，所以我们可以新建一个test.php文件，内容如下：\n<?php\n$program=\"/usr/bin/python3 /home/app/nongyephp/test.py\"; #注意使用绝对路径\necho \"begin<br>\";\n(exec ($program));\necho \"end<br>\";\ndie;\n然后我们通过网页访问test.php文件。结果如下：\n然后去log文件检查，发现也写入日志了，所以这个方法是可行的！做到这里心里美滋滋的，不过老觉得好像哪里不对，终于终于意识到一个很傻逼的问题：既然PHP可以直接有命令行函数，为啥多此一举借助Python然后在用Python的函数呢？这不是脱了裤子放屁多此一举吗？再大骂自己是傻逼N遍之后，我默默修改了test.php文件内容：\n<?php\necho \"begin<br>\";\n$program=\"/usr/local/php7/bin/php /home/app/nongyephp/swoole_test.php\"; #注意使用绝对路径\n(exec ($program));\necho \"end<br>\";\ndie;\n在直接访问test.php文件，反馈结果和借助Python一样，这样就可以免去Python那一步，直接用PHP的exec函数来执行PHP文件。\n结尾\n测试通过后发现这种方法是可以创建定时器并且通过web远程使用的，不过有个问题，如果用和我上述一样用网页模拟会发现网页刷新是要等test.php执行完才会结束，也就是说如果我们把延时器的时间设成30分钟会要等待30分钟才会有反馈信息，这种方式肯定行不通的，所以需要使用异步访问，比如使用web的ajax技术和其他异步技术，这里不再赘述\n尾巴\n\n以上只是我想到解决问题的想法和实施步骤，到了真正开发可能不会选择这种方式，因为没有经过性能测试，而且对于进程控制和线程控制并没有多深入的了解，所以以后做订单自动取消还是会选择方法2的吧。\n上述方法其实完全可以省掉Python那一步，我没有去掉的原因是把我的实现经历写出来，因为我觉得开发期间可能真的会遇到这种多此一举的方式，总之是要多思考，多看代码，找出能优化的方案，这里感觉自己差得很远，共勉吧\n\n\n                ", "mainLikeNum": ["8 "], "mainBookmarkNum": "58"}