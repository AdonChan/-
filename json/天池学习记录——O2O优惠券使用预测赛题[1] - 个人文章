{"title": "天池学习记录——O2O优惠券使用预测赛题[1] - 个人文章 ", "index": "机器学习,python", "content": "赛题说明\n应用背景：以优惠券盘活老用户或吸引新客户进店消费是O2O（Online to Offline）的一种重要营销方式。然而随机投放的优惠券对多数用户造成无意义的干扰。对商家而言，滥发的优惠券可能降低品牌声誉，同时难以估算营销成本。而个性化投放是提高优惠券核销率的重要技术，它可以让具有一定偏好的消费者得到真正的实惠，同时赋予商家更强的营销能力。\n目标：根据提供的O2O场景相关的丰富数据，通过分析建模，精准预测用户是否会在规定时间内使用相应优惠券。\n\n数据分析\n读取数据：\n我们看到在 offline 训练数据集中有以下 7 类数据：User_idMerchant_idCoupon_idDiscount_rateDistanceDate_receivedDate\n当 Coupon_id 为 null 时表示无优惠券消费，此时Discount_rate和Date_received字段无意义。\n具体字段意义请参考赛题链接。\n根据 Coupon_id 和 Date 是否为 null，可以将数据分为四种类型：\nprint('有优惠券，购买商品条数', dfoff[(dfoff['Coupon_id'] != 'null') & (dfoff['Date'] != 'null')].shape[0])\nprint('无优惠券，购买商品条数', dfoff[(dfoff['Coupon_id'] == 'null') & (dfoff['Date'] != 'null')].shape[0])\nprint('有优惠券，没有购买商品条数', dfoff[(dfoff['Coupon_id'] != 'null') & (dfoff['Date'] == 'null')].shape[0])\nprint('无优惠券，也没有购买商品条数', dfoff[(dfoff['Coupon_id'] == 'null') & (dfoff['Date'] == 'null')].shape[0])\n得到结果：\n其中，75382 表示用优惠券进行了消费的数量，即正样本；977900 表示领取优惠券但没有使用，这部分优惠券就被浪费了，即负样本；701602 表示没有优惠券的普通消费。\n下面我们分别对训练集中的 7 类数据对优惠券使用的影响进行分析。\n1. 优惠券和距离\nprint('Discount_rate 类型:',dfoff['Discount_rate'].unique())\nprint('Distance 类型:', dfoff['Distance'].unique())\n\n我们看到输出的是str类型的数据，需要将它们转换成numeric类型。\n在Discount_rate里有两种折扣方法：x in [0,1] 代表折扣率；x : y 表示满 x 减 y。这里我们还要将满 x 减 y 类型用式子1-y/x转换成折扣率。并建立折扣券相关的特征 discount_rate, discount_man, discount_jian, discount_type。代码如下：\n# convert Discount_rate and Distance\n\ndef getDiscountType(row):\n    if row == 'null':\n        return 'null'\n    elif ':' in row:\n        return 1\n    else:\n        return 0\n\ndef convertRate(row):\n    \"\"\"Convert discount to rate\"\"\"\n    if row == 'null':\n        return 1.0\n    elif ':' in row:\n        rows = row.split(':')\n        return 1.0 - float(rows[1])/float(rows[0])\n    else:\n        return float(row)\n\ndef getDiscountMan(row):\n    if ':' in row:\n        rows = row.split(':')\n        return int(rows[0])\n    else:\n        return 0\n\ndef getDiscountJian(row):\n    if ':' in row:\n        rows = row.split(':')\n        return int(rows[1])\n    else:\n        return 0\n\ndef processData(df):\n    \n    # convert discunt_rate\n    df['discount_rate'] = df['Discount_rate'].apply(convertRate)\n    df['discount_man'] = df['Discount_rate'].apply(getDiscountMan)\n    df['discount_jian'] = df['Discount_rate'].apply(getDiscountJian)\n    df['discount_type'] = df['Discount_rate'].apply(getDiscountType)\n    print(df['discount_rate'].unique())\n    \n    # convert distance\n    df['distance'] = df['Distance'].replace('null', -1).astype(int)\n    print(df['distance'].unique())\n    return df\n\ndfoff = processData(dfoff)\ndftest = processData(dftest)\n\n2. 时间对收到优惠券的日期date_received和消费日期date_buy进行处理：\ndate_received = dfoff['Date_received'].unique()\ndate_received = sorted(date_received[date_received != 'null'])\n\ndate_buy = dfoff['Date'].unique()\ndate_buy = sorted(date_buy[date_buy != 'null'])\n\ndate_buy = sorted(dfoff[dfoff['Date'] != 'null']['Date'])\n并输出结果：\n查看顾客每天收到的优惠券数量：\ncouponbydate = dfoff[dfoff['Date_received'] != 'null'][['Date_received', 'Date']].groupby(['Date_received'], as_index=False).count()\ncouponbydate.columns = ['Date_received','count']\ncouponbydate.head()\n\n查看顾客用这些优惠券进行了消费的数量：\nbuybydate = dfoff[(dfoff['Date'] != 'null') & (dfoff['Date_received'] != 'null')][['Date_received', 'Date']].groupby(['Date_received'], as_index=False).count()\nbuybydate.columns = ['Date_received','count']\nbuybydate.head()\n\n将以上数据可视化：\nplt.figure(figsize = (12,8))\ndate_received_dt = pd.to_datetime(date_received, format='%Y%m%d')\n\nplt.subplot(211)\nplt.bar(date_received_dt, couponbydate['count'], label = 'number of coupon received' )\nplt.bar(date_received_dt, buybydate['count'], label = 'number of coupon used')\nplt.yscale('log')\nplt.ylabel('Count')\nplt.legend()\n\nplt.subplot(212)\nplt.bar(date_received_dt, buybydate['count']/couponbydate['count'])\nplt.ylabel('Ratio(coupon used/coupon received)')\nplt.tight_layout()\n\n提取特征\n上面显示的是单独一天的数据量，我们知道人们一般在星期天上街比较多，使用优惠券的可能性也增大，所以现在我们以星期为依据新建特征。\ndef getWeekday(row):\n    if row == 'null':\n        return row\n    else:\n        return date(int(row[0:4]), int(row[4:6]), int(row[6:8])).weekday() + 1\n\ndfoff['weekday'] = dfoff['Date_received'].astype(str).apply(getWeekday)\ndftest['weekday'] = dftest['Date_received'].astype(str).apply(getWeekday)\n\n# weekday_type :  周六和周日为1，工作日为0\ndfoff['weekday_type'] = dfoff['weekday'].apply(lambda x : 1 if x in [6,7] else 0 )\ndftest['weekday_type'] = dftest['weekday'].apply(lambda x : 1 if x in [6,7] else 0 )\n\n# change weekday to one-hot encoding \nweekdaycols = ['weekday_' + str(i) for i in range(1,8)]\nprint(weekdaycols)\n\ntmpdf = pd.get_dummies(dfoff['weekday'].replace('null', np.nan))\ntmpdf.columns = weekdaycols\ndfoff[weekdaycols] = tmpdf\n\ntmpdf = pd.get_dummies(dftest['weekday'].replace('null', np.nan))\ntmpdf.columns = weekdaycols\ndftest[weekdaycols] = tmpdf\n得到的tmpdf为以下形式：\n对['date_received']数据进行标注，转换成numeric：\ndef label(row):\n    if row['Date_received'] == 'null':\n        return -1\n    if row['Date'] != 'null':\n        td = pd.to_datetime(row['Date'], format='%Y%m%d') -  pd.to_datetime(row['Date_received'], format='%Y%m%d')\n        if td <= pd.Timedelta(15, 'D'):\n            return 1\n    return 0\ndfoff['label'] = dfoff.apply(label, axis = 1)\n若 Date_received == 'null'，则 y = -1；Date != 'null' & Date-Date_received <= 15，则 y = 1；否则，y = 0。\n此时，这些转换后的数据已经以0，1，-1的形式存在了label列中。\n模型训练\n在应用模型前，首先对数据进行划分。在这里，我们将 20160101 到 20160515 的数据用作训练集(train)，20160516 到 20160615 的数据用作验证集(valid)。\ndf = dfoff[dfoff['label'] != -1].copy()\ntrain = df[(df['Date_received'] < '20160516')].copy()\nvalid = df[(df['Date_received'] >= '20160516') & (df['Date_received'] <= '20160615')].copy()\nprint(train['label'].value_counts())\nprint(valid['label'].value_counts())\n\n用线性模型 SGDClassifier 进行预测。\npredictors = original_feature\nprint(predictors)\n\ndef check_model(data, predictors):\n    \n    classifier = lambda: SGDClassifier(\n        loss='log', \n        penalty='elasticnet', \n        fit_intercept=True, \n        max_iter=100, \n        shuffle=True, \n        n_jobs=1,\n        class_weight=None)\n\n    model = Pipeline(steps=[\n        ('ss', StandardScaler()),\n        ('en', classifier())\n    ])\n\n    parameters = {\n        'en__alpha': [ 0.001, 0.01, 0.1],\n        'en__l1_ratio': [ 0.001, 0.01, 0.1]\n    }\n\n    folder = StratifiedKFold(n_splits=3, shuffle=True)\n    \n    grid_search = GridSearchCV(\n        model, \n        parameters, \n        cv=folder, \n        n_jobs=-1, \n        verbose=1)\n    grid_search = grid_search.fit(data[predictors], \n                                  data['label'])\n    \n    return grid_search\n\nif not os.path.isfile('1_model.pkl'):\n    model = check_model(train, predictors)\n    print(model.best_score_)\n    print(model.best_params_)\n    with open('1_model.pkl', 'wb') as f:\n        pickle.dump(model, f)\nelse:\n    with open('1_model.pkl', 'rb') as f:\n        model = pickle.load(f)\n接下来，对每个优惠券预测的结果计算 AUC，再对所有的取平均。计算 AUC 的时候，如果label只有一类，就直接跳过，因为 AUC 无法计算。\n进行预测：\ny_valid_pred = model.predict_proba(valid[predictors])\nvalid1 = valid.copy()\nvalid1['pred_prob'] = y_valid_pred[:, 1]\n计算平均 AUC：\nvg = valid1.groupby(['Coupon_id'])\naucs = []\nfor i in vg:\n    tmpdf = i[1] \n    if len(tmpdf['label'].unique()) != 2:\n        continue\n    fpr, tpr, thresholds = roc_curve(tmpdf['label'], tmpdf['pred_prob'], pos_label=1)\n    aucs.append(auc(fpr, tpr))\nprint(np.average(aucs))\n得到结果0.5348655160896371。\n对测试集进行预测并提交结果：\ny_test_pred = model.predict_proba(dftest[predictors])\ndftest1 = dftest[['User_id','Coupon_id','Date_received']].copy()\ndftest1['label'] = y_test_pred[:,1]\ndftest1.to_csv('submit1.csv', index=False, header=False)\n至此，我们已经得到一个提交结果，在这个过程中用到的特征是优惠券，距离和时间。预测效果较差，还需要进行进一步的特征工程，来得到更好的效果。\n思路解答\n总结以上思路，首先对数据进行分析，通过画图可以更直观的反映出数据的特征；然后根据对数据对分析结果，进行特征提取，用这些特征训练所用的模型。在训练过程中通过划分数据集，分为训练集和验证集两部分，对模型进行训练；最后，将测试集的数据喂给训练好的模型，得到预测结果，并转换为能提交的.csv格式的文件。\n这就是进行一次数据分析的大致思路，就本题来说，在特征工程和模型的选择上还有更多的思考余地，来提高准确率。\n用到的知识点\none-hot encodingAUC\n遇到的问题\n针对博主的学习，在这次的赛题总结中反映出的问题有以下 3 点：\n\n数据可视化的代码部分，不够了解，而画图可能为我们提供很多思路\n对各个模型的参数有哪些需要深入了解，如果不想做调包侠客，就更要掌握调参背后的原理\n特征工程是制胜的关键，需要不断的练习学习\n\n参考链接：https://tianchi.aliyun.com/no...https://tianchi.aliyun.com/no...\n\n不足之处，欢迎指正。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "1"}