{"title": "线性素数筛选（linear sieve for prime number） - Jerrold think it is fun! ", "index": "python,算法", "content": "偶然发现了这个和stackoverflow很像的地方。打算写些专栏，一方面，记录自己学到的东西。另一方面，也把这些分享给大家。无论是内容错误还是解释方式不好，都欢迎各位拍砖。转载到其他平台前也请通知我。\n\n本篇的IDE是Pycharm，使用的是Python 3 的基本interpreter\n问题起源\n这个问题起源于我在想寻找最大素数的时候诞生的。出现这个问题，一开始的想法是通过暴力破解来达成目的，举例的话，就以寻找第20000个素数开始吧\n算法演绎\nimport time\n\ndef func(num):\n    # since once i larger than num//2, num will not be divisible by any i increment\n    for i in range(2, num//2+1):\n        if num % i == 0:\n            return 0\n    return 1\n\ndef find_prime():\n    num = 1\n    count = 0\n    # find the 20000th prime in the world!\n    primeCount = 20000\n    while count < primeCount :\n        num += 1\n        count = func(num)+count\n    return num\n\n# count time\nstart = time.time()\nnum = find_prime()\nend = time.time() -start\nprint(\"find %s in %s seconds\" % (num,end))\n结果是:\nfind 224737 in 151.33826684951782 seconds\n\nProcess finished with exit code 0\n151秒，感觉花了好长时间，显然这不是一个有效率的方法。\n算法分析\n由于我们每次寻找的素数时，都从2开始，逐渐上除，最后到num/2为止，确认是否是素数。那所用的效率就是$$  O(N^2) $$\n查找了一些文献以后，看到了一种方法:线性素数筛选:埃拉托斯特尼筛法（Sieve of Eratosthenes）\n在每次我们确定素数的时候，将其之后的有关合数进行排除，每一次在寻找下个素数时，必然能一次性找到，而不用逐渐去加1来寻找。接着继续排除其有关合数。那这样所用效率就变成了$$O(N*log(log(N)))$$这里第一个N来自于寻找下个素数，而log(log(N)来自于寻找各个素数的合数，而这个算法，也需要一个$$O(N)$$的存储空间，我这里用了5000000的存储空间。而这是一个伪的polynomial算法。wiki中显示了一种优化方法，可以在$$O(N)$$中完成，但相对的需要$$O(n^{1/2}\\log\\log n/\\log n)$$的存储空间。这里给予链接，Paul Pritchard\n算法演绎\ndef fast_find_prime(n,limit =5000000):\n    if limit %2 != 0 :\n        limit+=1\n    # Assume all numbers are prime number\n    primes = [True] *limit\n    # Eliminate 0 and 1\n    primes[0], primes[1] = [None] *2\n    # set count\n    count = 0\n    # enumerate numbers\n    for ind, val in enumerate(primes):\n        if val is True:\n            # set number false when it is not prime\n            # ind will skip not prime numbers\n            primes[ind*2::ind] = [False] * (((limit-1)//ind)-1)\n            count += 1\n        if count == n: return  ind\n    return False\n\n#count time\nstart = time.time()\nnum = fast_find_prime(20000)\nend = time.time() -start\nprint(\"find %s in %s seconds\" % (num,end))\n结果为：\nfind 224737 in 0.427901029586792 seconds\n\nProcess finished with exit code 0\n0.4秒，非常迅速。\n相关算法\n在论坛中提到过一种 Sieve of Atkin 的算法。在速度上有略微提升，但是它的算法是主动忽略2、3、5的相关合数，实际意义并不是很大。有兴趣的同学也可以看一下。\n无关问题\n===============================这里是与主题无关的分割线===============================\n\n初用segment fault感觉还是不太一样，在以前的写博客习惯下，随便试了一些方法，除了tab之外还没有找到特别有趣的特殊格式。特别例如平方号等特殊符号，没能够实验出来。官方是否能出一份文章特殊符号和格式的使用说明呢？\n以上问题，非常感谢高阳sunny的迅速回复，祝segment fault越办越出众！\n\n一栏一槽\n\n===============================这里是与上述都无关的分割线===============================\n\n听说一位同学要去人民大学读研，去寒暄了一下：\n“你要去人大？”\n“恩”\n“什么时候去当常委？dog rich, don't forget!”\n“......”\n于是我回到美帝以后，发现又遭到报应性冷空气了。。。\n\n\n\n14年时初，拜访康村，和cornell的同学冒着雪天，黄昏时分在康村取景拍下的照片\n\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "0"}