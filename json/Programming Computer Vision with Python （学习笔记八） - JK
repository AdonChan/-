{"title": "Programming Computer Vision with Python （学习笔记八） - JK ", "index": "计算机视觉,图像去噪,python", "content": "图像去噪(Image Denoising)的过程就是将噪点从图像中去除的同时尽可能的保留原图像的细节和结构。这里讲的去噪跟前面笔记提过的去噪不一样，这里是指高级去噪技术，前面提过的高斯平滑也能去噪，但高斯平滑去噪的同时也把边缘模糊化了，另外使用形态学的方法去噪是指去除一些粗的椒盐噪声。对于一幅密布噪点的图像，如果使其变得清晰又保留边缘细节，这是高级去噪技术所要解决的问题。\n全变差\n全变差去噪（Total variation denoising）是一种常用的去噪模型。全变差（或叫总变差）大概是指图像梯度的范数(norm）的积分。一幅图像的细节（噪声或是干扰的不必要的）过多，全变差的值越高，所以让全变差最小化，去掉噪声和没用细节的同时，保留边缘等主要细节，正是这种模型的处理思想。用这种去噪技术产生的图像有点接近卡通的感觉。下面要介绍的Chambolle去噪算法就是基于全变差去噪模型实现的。\nchambolle去噪\nscipy.ndimage模块只是提供了基本的图像处理方法，并没有提供Chambolle去噪函数，所以就要借助另一个库——scikit-image。\nscikit-imagescikit-image（简称skimage）库是从scipy.ndimage扩展下来的，提供了更丰富的图像处理函数，去噪函数除了Chambolle还有Bilateral算法，比如边缘检测还有以前简单提过的Canny算子滤波器。它也是由 SciPy 社区所开发的，可以跟NumPy等完美配合。\n安装：\nsudo apt-get install python-skimage\n函数说明：\nskimage.restoration.denoise_tv_chambolle(im, weight=50, eps=0.0002, n_iter_max=200, multichannel=False)\nim: ndarray类型，2维或3维\nweight：越大去噪越多，但图像也会越失真\nmultichannel：对彩色图像而言，true表示对每一通道去噪\n\n返回去噪后的图像，ndarray类型。\n下面我用看具体的例子，将chambolle和高斯平滑进行对比：\nfrom PIL import Image\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.ndimage import filters\nfrom skimage.filter import denoise_tv_chambolle  #for versoin: 0.9.3\n#from skimage.restoration import denoise_tv_chambolle  #for new version\n\nim = np.array(Image.open('noising.jpg').convert('L'))\n\nindex = 221\nplt.subplot(index)\nplt.gray()\nplt.imshow(im)\nplt.axis('off')\nplt.title(\"original\")\n\nchdnim = denoise_tv_chambolle(im, weight=0.2)\nplt.subplot(index+1)\nplt.imshow(chdnim)\nplt.axis('off')\nplt.title(\"chambolle weight=0.2\")\n\ngs2dnim = filters.gaussian_filter(im, sigma=2)\nplt.subplot(index+2)\nplt.imshow(gs2dnim)\nplt.axis('off')\nplt.title(\"gaussion sigma=2\")\n\ngs3dnim = filters.gaussian_filter(im, sigma=3)\n\nplt.subplot(index+3)\nplt.imshow(gs3dnim)\nplt.axis('off')\nplt.title(\"gaussion sigmal=3\")\n\nplt.show()\n效果对比如下：\n明显感觉使用chambolle的效果要比高斯平滑好很多。\nBilateral滤波器Bilateral滤波器跟之前介绍过的高斯模糊运算过程相似，而且它也使用了高斯核，但它的特点是在对图像进行平滑的同时能保留边缘。因为它在平滑滤波时同时考虑了像素间的几何距离和色彩距离。具体点说，如果要处理的像素与邻近像素的欧式距离比较大（即像素值相差比较大）时，那么这些邻近像素的权重就比较小，从而使得对滤波后的新像素值影响较小。另外，每个滤波后像素点的值，受与他色彩相近并且距离较近的像素点的影响较大，这两种权值分配方法起到了保护边缘的作用。\nBilateral去噪函数：\nskimage.restoration.denoise_bilateral(image, win_size=5, sigma_range=None, sigma_spatial=1, bins=10000, mode='constant', cval=0)\n示例：\nfrom PIL import Image\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.ndimage import filters\nfrom skimage.filter import denoise_bilateral  #for versoin: 0.9.3\n#from skimage.restoration import denoise_bilateral  #for new version\n\nim = np.array(Image.open('noising.jpg').convert('L'))\n\nindex = 221\nplt.subplot(index)\nplt.gray()\nplt.imshow(im)\nplt.axis('off')\nplt.title(\"original\")\n\nplt.subplot(index+1)\nplt.imshow(denoise_bilateral(im))\nplt.axis('off')\nplt.title(\"default\")\n\nplt.subplot(index+2)\nplt.imshow(denoise_bilateral(im, sigma_range=0.2, sigma_spatial=10))\nplt.axis('off')\nplt.title(\"0.2/10\")\n\nplt.subplot(index+3)\nplt.imshow(denoise_bilateral(im, sigma_range=0.8, sigma_spatial=10))\nplt.axis('off')\nplt.title(\"0.8/10\")\n\nplt.show()\n效果如图：\n感觉比高斯平滑要好一些，但比Chambolle还是要逊色不少。\n小结\n因全变差的数学原理比较高深，所以暂时没去研究，只大概了解下并使用skimage库的接口进行了一番对比，结论就是使用chambolle去噪效果非常好。\n至此，书中第一章的内容结束了。后面将开始下一章节的内容学习——图像描述。\n你还可以查看我的其它笔记。\n参考资料\nscikit-image.orgscikit denoising exampleBilateral Filtering\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "21"}