{"title": "python的装饰器入门小结 - phenix ", "index": "python", "content": "使用python一年多了，一直知道python有个装饰器，很好用，试图理解过，可能由于资料找的不好，自己的悟性太差，一直没有搞清楚，今天查了一些资料，算是理解了，现在简单记录下。python的装饰器本身的功能是在不改变已有函数本身的情况下给已有的函数添加新的功能，通常在日志记录等方便比较常用，举个简单例子，假如我有个greet函数如下：\ndef greet(name):\n    print 'hello ', name\n现在我需要每次在运行该函数前打印一下开始状态，运行结束后打印一个结束状态，可以通过如下方法实现：\nprint \"greet starting\"\ngreet(name)\nprint \"greet ending\"\n但是如果我要多次调用这个函数，那么每次都需要在其函数的执行前后加上打印状态的代码，代码太多冗余。我们知道python中函数可以作为一个函数的参数，并且可以在函数内部返回一个函数，所以我们可以修改如下：\ndef func_status(func):\n    def wraper(name):\n        print \"greet starting\"\n        func(name)\n        print \"greet ending\"\n    return wraper\n然后通过如下方法调用：\nnew_greet = func_status(greet)\nnew_greet('python')\n\ngreet = func_status(greet)\ngreet('python')\n上述方法中，第一种调用，相当于将greet函数的功能和打印状态的功能结合起来生成一个新的函数，然后直接调用新函数；python中函数名相当于一个引用，第二种调用是将原有函数名作为新函数的引用，那如果要实现多个装饰功能，就需要不断的这样更改引用，这时，python的装饰器为你打开了方便之门，看如下代码：\ndef func_status(func):\n    def wraper(name):\n        print \"greet starting\"\n        func(name)\n        print \"greet ending\"\n    return wraper\n\n@func_status\ndef greet(name):\n    print 'hello ', name\n\ngreet('python')\n\n\"\"\"\n输出如下：\ngreet starting\nhello python\ngreet ending\n\"\"\"\n利用python装饰器，只需要我们在原有函数的定义上方添加一行@func_status即可，其中@为装饰器关键字，func_status为装饰器名称，当我们再调用greet('python')，它会直接输出包含状态打印的结果。如果要再加一个装饰功能呢，也是很方便的，看下方代码：\ndef func_status(func):\n    def wraper(name):\n        print \"greet starting\"\n        func(name)\n        print \"greet ending\"\n    return wraper\n\ndef add_tag(func):\n    def wraper(name):\n        print '--------------'\n        func(name)\n        print '--------------'\n    return wraper\n\n@add_tag\n@func_status\ndef greet(name):\n    print 'hello ', name\n\ngreet('python')\n\"\"\"\n输出如下：\n--------------\ngreet starting\nhello python\ngreet ending\n--------------\n\"\"\"\n从上面代码也可以看出，装饰器的添加顺序是从里向外的，距离原函数最近的装饰功能先添加，依次向外。到这里，差不多对装饰器有个简单的理解了，快去体验体验吧。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "6"}