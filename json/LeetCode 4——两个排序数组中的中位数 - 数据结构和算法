{"title": "LeetCode 4——两个排序数组中的中位数 - 数据结构和算法 ", "index": "c++,python", "content": "1. 题目\n\n2. 解答\n2.1. 方法一\n由于两个数组都是排好序的，因此首先可以想到的思路就是利用归并排序把两个数组合并成一个有序的长数组，然后直接取出中位数即可。\nclass Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        len1 = len(nums1)\n        len2 = len(nums2)\n        nums = []\n        \n        i = 0\n        j = 0\n        \n        while (i < len1 and j < len2):\n            \n            if (nums1[i] <= nums2[j]):\n                nums.append(nums1[i])\n                i += 1\n            \n            else:\n                nums.append(nums2[j])\n                j += 1\n        \n        if (i < len1):\n            while(i < len1):\n                nums.append(nums1[i])\n                i += 1\n            \n        if (j < len2):\n            while(j < len2):\n                nums.append(nums2[j])\n                j += 1\n        \n        odd = (len1 + len2) % 2 # 长度是否为奇数\n        mid = (len1 + len2 - 1) // 2\n        if (odd):\n            return nums[mid]\n        else:\n            return (nums[mid] + nums[mid+1]) / 2\n因为要遍历两个数组，所以时间复杂度为 $O(m+n)$，而题目中要求算法的时间复杂度为 $O(log (m+n))$，因此应该是有更高效的算法，借助于二分查找。\n2.2. 方法二\n所谓中位数，就是将 K 个数据分为长度相等的两组，左边的数据小于等于右边的数据。\n如果我们要在任意位置 $i$ 处将长度为 $m$ 的数组 $A$ 分为两部分，则共有 $m+1$ 种分法，$i=[0, m]$。\n$$  left\\_part \\quad | \\quad right\\_part$$$$ A[0], A[1], ..., A[i-1] \\quad | \\quad A[i], A[i+1], ..., A[m-1]$$\n$i=0$ 说明左半部分没有元素，反之 $i=m$ 说明右半部分没有元素。左半边元素个数为 $i$ ，右半边元素个数为$m-i$。\n同理，我们可以在任意位置 $j$ 处将长度为 $n$ 的数组 $B$ 分为两部分，则共有 $n+1$ 种分法，$j=[0, n]$。\n$$ B[0], B[1], ..., B[j-1] \\quad | \\quad B[j], B[j+1], ..., B[n-1]$$\n针对划分完后的数组 $A$ 和 $B$，如果满足：\n\n左边部分的长度等于右边部分的长度（偶数情况），$i+j = m-i + n-j$；或者等于右边部分的长度加 1（奇数情况） ,$i+j = m-i + n-j+1$。\n左边的最大元素小于等于右边的最小元素，$A[i-1] <= B[j] \\quad and \\quad B[i-1] <= A[j]$。\n\n那我们也就找到了中位数，$median = \\frac{max(left\\_part) + min(right\\_part)}{2}$。\n所以，我们要做的就是在 $i=[0, m]$ 区间搜索一个 $i$ 值，使得上面的条件得到满足。也即\n$$ A[i-1] <= B[j] \\quad and \\quad B[i-1] <= A[j] ，其中 \\quad j = \\frac{m+n+[1]}{2}-i$$\n加不加 1 取决于总的长度是奇数还是偶数，同时，为了保证 $j$  的范围在 $[0, n]$，我们必须要求 $n <= m$。\n接下来，我们就在 $i=[0, m]$ 区间进行二分查找。\n\n如果满足条件，则直接返回求取中位数。\n如果 $i > 0 \\quad and \\quad A[i-1] > B[j]$，则减小 $i$。如果增加 $i$，则 $j$ 减小，左边序列数组 $A$ 的值会更大，右边序列数组 $B$ 的值会更小。\n如果 $i < m \\quad and \\quad B[i-1] > A[j]$，则增加 $i$。如果减小 $i$，则 $j$ 增加，左边序列数组 $A$ 的值会更小，右边序列数组 $B$ 的值会更大。\n\n最后，我们求得左半部分的最大值以及右半部分的最小值，然后就可以求出中位数了。\n因为，要查找的范围为 $i=[0, m]$，而且每次查找缩小区间为原来的一半，因此时间复杂度为 $O(log(min(m, n))$，空间复杂度为  $O(1)$。\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        \n        \n        int m = nums1.size();\n        int n = nums2.size();\n        int len = m + n;\n        int odd = len % 2;\n        \n        int left = 0;\n        int i = 0, j = 0;  \n        vector<int>::iterator A = nums1.begin();\n        vector<int>::iterator B = nums2.begin();\n        \n        // 确保数组 A 的长度小于等于数组 B 的长度\n        if (m > n)\n        {\n            int temp = m;\n            m = n;\n            n = temp;\n            A = nums2.begin();\n            B = nums1.begin();\n        }\n        \n        int right = m;\n                \n        while(left <= right)\n        {\n            i = left + (right - left) / 2;\n            j = (len + odd) / 2 - i;\n                        \n            if (i > 0 && A[i-1] > B[j])\n            {\n                right = i - 1;\n            }\n            else if(i < m && B[j-1] > A[i])\n            {\n                left = i + 1;\n            }\n            else\n            {\n                break;\n            } \n        }\n         \n        int left_max = 0;\n        int right_min = 0;\n        \n        // 左半部分的最大值\n        if (i == 0) left_max = B[j-1];\n        else if (j == 0) left_max = A[i-1];\n        else  left_max = A[i-1] <= B[j-1] ? B[j-1] : A[i-1];\n\n        // 右半部分的最小值\n        if (i == m) right_min = B[j];\n        else if (j == n) right_min = A[i];\n        else    right_min = A[i] <= B[j] ? A[i] : B[j];\n\n        if (odd)\n        {\n            return left_max;\n        }\n        else\n        {\n            return float(left_max + right_min) / 2;\n        }\n    }\n};\n获取更多精彩，请关注「seniusen」! \n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "0"}