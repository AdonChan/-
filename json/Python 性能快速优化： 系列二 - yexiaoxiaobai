{"title": "Python 性能快速优化： 系列二 - yexiaoxiaobai ", "index": "性能优化,optimization,performance,python", "content": "\n  注：本文的原文地址为 Quick Python Performance Optimization: Part II\n\n\n这个是 Python 性能快速优化的第二部分，第一部分请点击这里。\n\n\n使用 Map ，Reduce 和 Filter 代替 for 循环 \n校验 a in b， 字典 或 set 比 列表 或 元组 更好\n当数据量大的时候，尽可能使用不可变数据类型，他们更快 元组 > 列表\n\n在一个列表中插入数据的复杂度为 O(n)\n\n如果你需要操作列表的两端，使用 deque\n\ndel - 删除对象使用如下\n1） python 自己处理它，但确保使用了 gc 模块\n2） 编写 __del__ 函数\n3） 最简单的方式，使用后调用 del\ntime.clock()\nGIL(http://wiki.python.org/moin/GlobalInterpreterLock) - GIL is a daemon\n\nGIL 仅仅允许一个 Python 的原生线程来运行每个进程。阻止 CPU 级别的并行，尝试使用 ctypes 和 原生的 C 库来解决它，当你达到 Python 优化的最后，总是存在一个选项，可以使用原生的 C 重写慢的函数，通过 Python 的 C 绑定使用它，其他的库如 gevent 也是致力于解决这个问题，并且获得了成功。\n\nTL,DR：当你写代码了，过一遍数据结构，迭代结构，内建和为 GIL  创建 C 扩展，如有必要。\n\n更新：multiprocessing  是在 GIL 的范围之外，这意味着你可以使用 multiprocessing 这个标准库来运行多个进程。\n\n看下我的 2013 的印度 PyCon 演讲\n\n\nwww.slideshare.net/atmb4u/faster-python\n\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "21"}