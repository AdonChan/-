{"title": "深入 Flask 源码理解 Context - python 学习 ", "index": "python,flask", "content": "Flask 中的上下文对象\n知乎问题 编程中什么是「Context(上下文)」 已经能够简单地说明什么是 Context，它是一个程序需要的外部对象，类似于一个全局变量。而这个变量的值会根据提供的值而改变。\nFlask 中有分为请求上下文和应用上下文：\n\n\n对象\nContext类型\n说明\n\n\n\ncurrent_app\nAppContext\n当前的应用对象\n\n\ng\nAppContext\n处理请求时用作临时存储的对象\n\n\nrequest\nRequestContext\n请求对象，封装了Http请求的内容\n\n\nsession\nRequestContext\n用于存储请求之间需要记住的值\n\n\n\nFlask 分发请求之前激活程序请求上下文，请求处理完成后再将其删除。\nFlask 中的 Context 是通过栈来实现。\n\nFlask 的 Context 实现\nFlask 的核心功能依赖于 Werkzeug 库。\n_app_ctx_stack & _request_ctx_stack\n这两种栈定义在 flask/global.py 中。\n_request_ctx_stack = LocalStack()\n_app_ctx_stack = LocalStack()\n首先需要了解一下 Werkzeug 中关于 LcoalStack 的相关内容。\nLocal 类\nLocal 是定义了一个 __storage__ 字典，其中的键为 thread 的 id 值。\nclass Local(object):\n    __slots__ = ('__storage__', '__ident_func__')\n    \n    def __init__(self):\n        object.__setattr__(self, '__storage__', {})\n        object.__setattr__(self, '__ident_func__', get_ident)\n        \n    def __setattr__(self, name, value):\n        ident  = self.__ident_func__()\n        storage = self.__storage__\n        try:\n            storage[ident][name] = value\n        except KeyError:\n            raise AttributeError(name)\n    ...\nLocalStack 类\nLocalStack 则内部维护一个 Local 实例。主要的作用是将 Local 维护的 __storage__ 字典中键为  __ident_func__() 对应的值定义为 {\"stack\" : [] }。\nclass LocalStack(object):\n    def __init__(self):\n        self._local = Local()\n        \n    def push(self, obj):\n        rv = getattr(self._local, 'stack', None)\n        if rv is None:\n            self._local.stack = rv = []\n        rv.append(obj)\n        return rv\n        \n    def pop(self, obj):\n        pass\nLocalProxy 类\nLocalProxy类是一个代理类，应用到设计模式当中的代理模式。简单地讲，我们不需要去了解当前的环境，而直接去操作这个 Proxy 类，这个 Proxy 类会将所有的操作反馈给正确的对象。\nclass LocalProxy(object):\n    __slots__ = ('__local', '__dict__', '__name__')\n    def __init__(self, local, name=None):\n        object.__setattr__(self, '_LocalProxy__local', local)\n        object.__setattr__(self, '__name__', name)\n    \n    def _get_current_object(self):\n        # 通过此方法获取被代理的对象\n        if not hasattr(self.__local, '__release_local__')\n            return self.__local\n        try:\n            return gerattr(self.__local,self.__name__)\n        except Attribute:\n            raise RuntimeError('no object bound to %s' % self.__name__)\n    ...\n    # 其他操作\nrequest & RequestContext\nFlask 源码中关于 request 的定义：\ndef _lookup_req_object(name):\n    top = _request_ctx_stack.top\n    if top is None:\n        raise RuntimeError(_request_ctx_err_msg)\n    return getattr(top, name)\n    \nrequest = LocalProxy(partial(_lookup_req_object, 'request'))\n从源码可以看出，request 是 _request_ctx_stack 栈顶元素的一个属性。实际上 _request_ctx_stack 栈中的元素是 ReuqestContext 对象的实例， 而 ReuqestContext 中包含了 request 请求的所有信息,包括 Session 信息。\nclass ReuqestContext(object):\n    def __init__(self, app, environ, request=None):\n        if reuqest is None:\n            request  = Request(environ)\n        self.requst = request\n        self.app = app \n        self.session = None\n        ...\n        # 这个列表包含了与 request 相关联的 Application\n        self._implicit_app_ctx_stack = []\n        self.match_request()\n\n    def push(self, object):\n        \"\"\"\n        这里需要实现的是：当 RequestContext push 到\n        _request_ctx_stack 时， 需要检测是否有对应的\n        AppContext。如果没有，则会将当前 self.app push\n        到 AppContext 中，同时将self.app 加入\n        _implicit_app_ctx_stack 列表中； 否则\n        _implicit_app_ctx_stack 添加 None。\n        \"\"\"\n        pass\n        \n    def pop(self):\n        \"\"\"\n        当 ReuqestContext 弹出 _request_ctx_stack 的\n        方法。注意：request 清理之后的动作。如执行\n        teardown_request。\n        \"\"\"\n        pass\n这里传入的 app，就是 Flask 的程序实例。 RequestContext 实例的创建在 Flask 类方法中。\nclass Flask(_PackageBoundObject):\n    ...\n    request_class = ReuqestContext\n    def wsgi_app(self, environ, start_response):\n        ctx = self.request_class(environ)\n        ctx.push\n        ...\n        \n    def __call__(self, environ, start_response):\n        return self.wsgi_app(environ, start_response)\nFlask 中 Request 对象继承了 Werkzeug 中的 Request 对象。上述代码涉及到 WSGI，它强调 Appication 必须是一个可调用对象。后期的工作之一是了解 WSGI。\nSession\n在 session.py 文件中定义了 有关Session的内容。Flask 中 Session 是构建在 Cookie 上面的。其中定义了关于 Session 的接口。\nclass SessionMixin(object):\n    \"\"\"定义了Session的最小属性\"\"\"\n    \nclass SecureCookieSession(CallDict, SessionMixin):\n    \"\"\" CallDict 是 werkzeug 中的数据结构 \"\"\"\n\nclass NullSession(SecureCookieSession):\n    \"\"\" 定义了空 session 结构 \"\"\"\n    \nclass SessionInterface(object):\n    \"\"\" 定义了 Session接口的属性，依赖于 app.config \n    中的信息。同时，规定了只要是继承SessionInterface\n    必须实现 open_session 和 save_session 方法\n    \"\"\"\nclass SecureCookieSessionInterface(SessionInterface):\n    \"\"\" \n    主要是实现了 open_session 和 save_session 方法\n    \"\"\"\n如下代码则是 session 的应用。\n# flask/app.py\nclass Flask(_PackageBoundObject):\n    session_interface = SecureCookieSessionInterface()\n    def open_session(self, request):\n        return self.session_interface.open_session(self, request)\n        \n    def save_session(self, session, response)\n        return self.session_interface.save_session(\\\n            self, session, response)\n            \n    def process_response(self, response):\n        ctx = _request_ctx_stack.top\n        ...\n        if not self.session_interface.is_null_session(ctx.session):\n            self.save_session(ctx.session, response)\n\n#ReuqestContext\nclass ReuqestContext():\n    def push(self, object):\n        ...\n        self.session = self.app.open_session(self.reuqest)\n        if self.session is None:\n            self.session = self.app.make_null_session()\n        ...\nsession 是 RequestContext 中属性，所以代理说明如下：\nsession = LocalProxy(partial(_lookup_req_object,'session')\ncurrent_app & g\n一般来讲， 在 Flask Web 开发时， Flask的实例是延迟创建的。也就是说 AppContext还没有压入 _app_ctx_stack 中，所以我们在编写代码时，是无法获取完整的 Flask 实例的属性。而当用户访问时，程序的实例已经初始化完成了，因此我们采用 current_app代理获取当前 app。这仅仅是我的个人理解。实际上这是解决 多个 Flask 实例运行的问题。\ncurrent_app是获取 _app_ctx_stack 栈顶 AppContext实例元素的代理.\ndef _find_app():\n    top = _app_ctx_stack.top\n    if top is None:\n        raise RuntimeError(_app_ctx_err_msg)\n    return top.app\ncurrent_app = LocalProxy(_find_app)\nflask.g 是存储一下资源信息的，如数据库连接信息。更多应用的则是体现在 Flask 扩展当中。\ndef _lookup_app_object(name):\n    top = _app_ctx_stack.top\n    if top is None:\n        raise RuntimeError(_app_ctx_err_msg)\n        return getattr(top,name)\ng = LocalProxy(partical(_lookup_app_object, 'g'))\n\n# flask.app.py\nclass Flask(_PackageBoundObject):\n    app_ctx_globals_class = _AppCtxGlobals #实现的是类似字典的功能\n\n# AppContext\nclass AppContext(object):\n    def __init__(self, app):\n        self.g = self.app.app_ctx_globals_class()\n\n#RequestContext\nclass RequestContext(object):\n    #定义与request相关的 g 变量\n    def _get_g(self):\n        return _app_ctx_stack.top.g\n    def _set_g(self, value):\n        _app_ctx_stack.top.g = value\n    g = property(_get_g, _set_g)\n    del _get_g, _set_g   \n上述代码存在一个疑问是 g 对象是基于请求的，每次请求都会重置。那么 g  为什么不是 RequestContext 而是 AppContext ? flask.g API 文档 中说明了 g 变量的改动。\n\n个人博客\n\n                ", "mainLikeNum": ["4 "], "mainBookmarkNum": "50"}