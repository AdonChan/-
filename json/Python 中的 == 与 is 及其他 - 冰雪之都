{"title": "Python 中的 == 与 is 及其他 - 冰雪之都 ", "index": "引用,python", "content": "摘要：Python 中对于对象的比较分为值比较和对象身份比较，文中对于两种比较及引用赋值给出了介绍。\n\n\n比较对象值时使用 == 等逻辑操作符，比较的是对象的值；比较对象身份时使用 is 和 is not 操作符，比较的是对象的本身，即可理解为对象的地址，该地址可以由id()函数获得。\n\n理解过程中可以类比 C 语言中变量的比较，例如对于变量 a 和 b，比较值相当于 a == b，比较身份相当于 &a == &b，即对两个变量分别取地址，之后比较这两个地址。\n\nPython 中使用大量使用引用赋值。通过 b = a 的操作，C 语言中是将 a 的值赋给 b，两个变量的地址不同；Python 中则通过引用赋值，直接使 b 和 a 指向相同的地址，这样就可以复用内存，使得存储更高效。\n不过在使用过程中，对于不可改变类型，或者表述为“标量存储类型”，这个操作对于用户是透明的，即对于用户来说相当于普通复制赋值，如下。使用 b = a 赋值后，可以看到，两个变量的 id 是相同的，即内存中地址相同。改变 b 的值后可以看到，系统自动给 b 分配了新的地址空间，改变 b 并没有引起 a 的改变。\n\npython>>> a = 1\n>>> b = a\n>>> id(a)\n29667592L\n>>> id(b)\n29667592L\n>>> b += 1\n>>> a\n1\n>>> b\n2\n>>> id(a)\n29667592L\n>>> id(b)\n29667568L\n\n\n对于可变类型，Python 真的是使用引用赋值，如下。可以发现对于 list 类型，改变了 b 的值后 a 也随之改变，两个变量的地址是相同的。\n\npython>>> a = [1, 2]\n>>> b = a\n>>> id(a)\n34412232L\n>>> id(b)\n34412232L\n>>> b += [3]\n>>> a\n[1, 2, 3]\n>>> b\n[1, 2, 3]\n>>> id(a)\n34412232L\n>>> id(b)\n34412232L\n\n\n若需要对于 list 类型使用复制赋值，需要使用技巧 b = a[:]，此时系统会为 b 分配新的地址，并赋予之一份 a 的拷贝，如下。\n\npython>>> a = [1, 2]\n>>> b = a[:]\n>>> a\n[1, 2]\n>>> b\n[1, 2]\n>>> id(a)\n34520264L\n>>> id(b)\n34520456L\n>>> b += [3]\n>>> a\n[1, 2]\n>>> b\n[1, 2, 3]\n>>> id(a)\n34520264L\n>>> id(b)\n34520456L\n\n\nPython 中对于内存的管理是自动的，不需要程序猿参与。系统对于每个变量的内存空间添加了一个计数器，没增加一个引用，即有新的指针指向这个地址时，就对计数器加一，反之减一。当计数器的值为 0 时，系统回收这块内存。当使用 del 操作时，直接将该变量所在内存的计数器置为 0，即直接删除之。\n\n这种管理方式在 Linux/Unix 的文件系统中也在使用，*nix 系统采用 inode 格式来管理文件。这种管理方式采用唯一的 id 来标识文件，而文件名只是一个普通属性，因此可以在文件打开过程中修改文件名。每当对于文件创建一个新的硬链接，系统就会将文件的计数器加一，当计数器的值为 0 时，表示文件被删除。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "3"}