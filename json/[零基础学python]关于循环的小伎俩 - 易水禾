{"title": "[零基础学python]关于循环的小伎俩 - 易水禾 ", "index": "零基础,python", "content": "不管是while还是for，所发起的循环，在python编程中是经常被用到的。特别是for，一般认为，它要比while快，而且也容易写（是否容易，可能因人而异，但是，执行时间快，是的确的），因此在实践中，for用的比较多点，不是说while就不用，比如前面所列举而得那个猜数字游戏，在业务逻辑上，用while就更容易理解（当然是限于那个游戏的业务需要而言）。另外，在某些情况下，for也不是简单地把对象中的元素遍历一遍，比如有有隔一个取一个的要求，等等。\n\n在编写代码的实践中，为了对付循环中的某些要求，需要用一些其它的函数，比如前面已经介绍过的range就是一个被看做循环中的计数器的好东西。\n\nrange\n\n在《有容乃大的list(4)》中，专门对range()这个内置函数做了详细介绍，看官可以回到那节教程复习一番。这里重点是复习并展示一下它的for循环中，做为计数器的使用。\n\n还记得曾经在教程中有一个问题：列出100以内被3整除的数。下面引用那个问题的代码和运行结果。\n\n#! /usr/bin/env python\n#coding:utf-8\n\naliquot = []\n\nfor n in range(1,100):\n    if n%3 == 0:\n        aliquot.append(n)\n\nprint aliquot\n\n\n代码运行结果：\n\n[3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 51, 54, 57, 60, 63, 66, 69, 72, 75, 78, 81, 84, 87, 90, 93, 96, 99]\n\n\n这个问题，如果改写一下（也有网友在博客中提出了改写方法）\n\n>>> aliquot = [ x for x in range(1,100) if x%3==0 ] #用list解析，本质上跟上面无太大差异\n>>> aliquot\n[3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 51, 54, 57, 60, 63, 66, 69, 72, 75, 78, 81, 84, 87, 90, 93, 96, 99]\n\n>>> aliquot = range(3,100,3)    #这种方法更简单。这是博客中一网友提供。\n>>> aliquot\n[3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 51, 54, 57, 60, 63, 66, 69, 72, 75, 78, 81, 84, 87, 90, 93, 96, 99]\n\n\n如果有一个由字母组成的字符串，只想隔一个从字符串中取一个字母。可以这样来实现，这是range()的一个重要用途。\n\n>>> one = \"Ilikepython\" \n>>> new_list = [ one[i] for i in range(0,len(one),2) ]\n>>> new_list\n['I', 'i', 'e', 'y', 'h', 'n']\n\n\n当然，间隔的举例，是可以任意指定的。还是前面那个问题，还可以通过下面的方式，选出所有能够被3整除的数。\n\n>>> all_int = range(1,100)\n>>> all_int\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]\n>>> aliquot = [ all_int[i] for i in range(len(all_int)) if all_int[i]%3==0 ]\n>>> aliquot\n[3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 51, 54, 57, 60, 63, 66, 69, 72, 75, 78, 81, 84, 87, 90, 93, 96, 99]\n\n\n通过上述实例，主要是让看官理解range()在for循环中计数器的作用。\n\nzip\n\n在《难以想象的for》中，已经对zip进行了介绍，此处还要提到这个函数，不仅仅是复习，还能深入一下，更主要是它也会常常被用到循环之中。\n\nzip是用于并行遍历的函数。\n\n比如有两个list，元素是由整数组成，如果计算对应位置元素的和。一种方法是通过循环，分别从两个list中取出元素，然后求和。\n\n>>> list1 = range(2,10,2)\n>>> list1\n[2, 4, 6, 8]\n>>> list2 = range(11,20,2)\n>>> list2\n[11, 13, 15, 17, 19]\n>>> result = [ list1[i]+list2[i] for i in range(len(list1)) ]\n>>> result\n[13, 17, 21, 25]\n\n\n正如在《难以想象的for》中讲述的那样，上面的方法不是很完美，在上一讲中有比较完美一点的代码，请看官欣赏。\n\nzip完成上面的任务，是这么做的：\n\n>>> list1\n[2, 4, 6, 8]\n>>> list2\n[11, 13, 15, 17, 19]\n>>> for a,b in zip(list1,list2):\n...     print a+b, \n... \n13 17 21 25\n\n\nzip()的作用就是把list1和list2两个对象中的对应元素放到一个元组(a,b)中，然后对这两个元素进行操作。\n\n>>> list1\n[2, 4, 6, 8]\n>>> list2\n[11, 13, 15, 17, 19]\n>>> zip(list1,list2)\n[(2, 11), (4, 13), (6, 15), (8, 17)]\n\n\n对这个功能，看官可以理解为，将两个list压缩成为(zip)一个list，只不过找不到配对的就丢掉了。\n\n能够压缩，也能够解压缩，用下面的方式就是反过来了。\n\n>>> result = zip(list1,list2)\n>>> result\n[(2, 11), (4, 13), (6, 15), (8, 17)]\n>>> zip(*result)\n[(2, 4, 6, 8), (11, 13, 15, 17)]\n\n\n列位注意观察，解压缩得到的结果，跟前面压缩前的结果相比，第二项就少了一个元素19，因为在压缩的时候就丢掉了。\n\n这似乎跟for没有什么关系呀。别着急，思考一个问题，看看如何求解：\n\n问题描述：有一个dictionary，myinfor = {\"name\":\"qiwsir\",\"site\":\"qiwsir.github.io\",\"lang\":\"python\"},将这个字典变换成：infor = {\"qiwsir\":\"name\",\"qiwsir.github.io\":\"site\",\"python\":\"lang\"}\n\n解法有几个，如果用for循环，可以这样做（当然，看官如果有方法，欢迎贴出来）。\n\n>>> infor = {}\n>>> for k,v in myinfor.items():\n...     infor[v]=k\n... \n>>> infor\n{'python': 'lang', 'qiwsir.github.io': 'site', 'qiwsir': 'name'}\n\n\n下面用zip()来试试：\n\n>>> dict(zip(myinfor.values(),myinfor.keys()))\n{'python': 'lang', 'qiwsir.github.io': 'site', 'qiwsir': 'name'}\n\n\n呜呼，这是什么情况？原来这个zip()还能这样用。是的，本质上是这么回事情。如果将上面这一行分解开来，看官就明白其中的奥妙了。\n\n>>> myinfor.values()    #得到两个list\n['python', 'qiwsir', 'qiwsir.github.io']\n>>> myinfor.keys()\n['lang', 'name', 'site']\n>>> temp = zip(myinfor.values(),myinfor.keys())     #压缩成一个list，每个元素是一个tuple\n>>> temp\n[('python', 'lang'), ('qiwsir', 'name'), ('qiwsir.github.io', 'site')]\n\n>>> dict(temp)                          #这是函数dict()的功能，将上述列表转化为dictionary\n{'python': 'lang', 'qiwsir.github.io': 'site', 'qiwsir': 'name'}\n\n\n至此，是不是明白zip()和循环的关系了呢？有了它可以让某些循环简化。特别是在用python读取数据库的时候（比如mysql），zip()的作用更会显现。\n\nenumerate\n\nenumerate的详细解释，在《再深点，更懂list》中已经有解释，这里姑且复习。\n\n如果要对一个列表，想得到其中每个元素的偏移量（就是那个脚标）和对应的元素，怎么办呢？可以这样：\n\n>>> mylist = [\"qiwsir\",703,\"python\"]\n>>> new_list = []\n>>> for i in range(len(mylist)):\n...     new_list.append((i,mylist[i]))\n... \n>>> new_list\n[(0, 'qiwsir'), (1, 703), (2, 'python')]\n\n\nenumerate的作用就是简化上述操作：\n\n>>> enumerate(mylist)\n<enumerate object at 0xb74a63c4>    #出现这个结果，用list就能显示内容.类似的会在后面课程出现，意味着可迭代。\n>>> list(enumerate(mylist))\n[(0, 'qiwsir'), (1, 703), (2, 'python')]\n\n\n对enumerate()的深刻阐述，还得看这个官方文档：\n\n\n  class enumerate(object)\n  |  enumerate(iterable[, start]) -> iterator for index, value of iterable\n  |\n  |  Return an enumerate object.  iterable must be another object that supports\n  |  iteration.  The enumerate object yields pairs containing a count (from\n  |  start, which defaults to zero) and a value yielded by the iterable argument.\n  |  enumerate is useful for obtaining an indexed list:\n  |      (0, seq[0]), (1, seq[1]), (2, seq[2]), ...\n  |\n  |  Methods defined here:\n  |\n  |  getattribute(...)\n  |      x.getattribute('name') <==> x.name\n  |\n  |  iter(...)\n  |      x.iter() <==> iter(x)\n  |\n  |  next(...)\n  |      x.next() -> the next value, or raise StopIteration\n\n\n\n  \n\n\nData and other attributes defined here:\n  \n\n\n  \n\n\nnew = \n\n  \n\nT.new(S, ...) -> a new object with type S, a subtype of T\n  \n\n\n\n\n对官方文档，有的朋友可能看起来有点迷糊，不要紧，至少浏览一下，看个大概。因为随着个人实践的越来越多，对文档的含义理解会越来越深刻。这就好比令狐冲，刚刚学习了独孤九剑的口诀和招式后，理解不是很深刻，只有在不断的打打杀杀实践中，特别跟东方不败等高手过招之后，才能越来越体会到独孤九剑中的奥妙。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "3"}