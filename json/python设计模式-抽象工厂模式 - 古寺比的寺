{"title": "python设计模式-抽象工厂模式 - 古寺比的寺 ", "index": "工厂模式,抽象工厂模式,设计模式,python", "content": "问题：在上一篇 python设计模式：工厂方法模式我们尝试使用工厂方法创建了披萨店，现在为了保证披萨加盟店也能有良好的声誉，我们需要统一原材料，这个该如何做呢？\n为了确保每家加盟店都是用高质量的原材料，我们打算建造一加原材料工厂，并将原材料运送到各个加盟店。每个加盟店会对原材料有不同的需求，这里我们就可以用上上一篇介绍的工厂方法模式了。\n\n首先，建造原料工厂\n然后建造区域的原料工厂（继承自原料工厂）\n在区域的原料工厂中实现原料的创建方法。\n将原料工厂组合起来，加入到 PizzaStore（上一篇中由工厂方法实现）代码中。\n\n按照这个思路，我们先创建原料工厂\n创建原料工厂\n创建原料工厂的实现代码如下：\n# 原料\nclass FreshClams:\n\n    def __str__(self):\n        return 'Fresh Clams'\n\nclass MarinaraSauce:\n\n    def __str__(self):\n        return \"Marinara Sauce\"\n\nclass ThickCrustDough:\n\n    def __str__(self):\n        return \"Thick Crust Dough\"\n\nclass ReggianoCheese:\n\n    def __str__(self):\n        return \"Reggiano Cheese\"\n\nclass SlicedPepperoni:\n\n    def __str__(self):\n        return \"Sliced Pepperoni\"\n\nclass Garlic:\n\n    def __str__(self):\n        return \"Garlic\"\n\nclass Onion:\n\n    def __str__(self):\n        return \"Onion\"\n\nclass RedPepper:\n\n    def __str__(self):\n        return \"Red Pepper\"\n\n# 披萨店原料工厂\nclass PizzaIngredientFactory:\n\n    '''\n    定义原料工厂\n    '''\n\n    def create_dough(self):\n        raise NotImplementedError()\n\n    def create_sauce(self):\n        raise NotImplementedError()\n\n    def create_cheese(self):\n        raise NotImplementedError()\n\n    def create_pepperoni(self):\n        raise NotImplementedError()\n\n    def create_clam(self):\n        raise NotImplementedError()\n\n    def create_veggies(self):\n        raise NotImplementedError()\n在这个工厂中，每个原料都是一个方法，原料的实现需要在具体的原料工厂中实现。这里每个原料方法没有做任何工作，只是抛出了NotImplementedError 这样做是为了强制子类重新实现相应的方法，如果不重新实现用到时就会抛出 NotImplementedError。\n当然也可以把 PizzaIngredientFactory 的 metaclass 设置成 abc.ABCMeta 这样的话，这个类就是真正的抽象基类。\n创建纽约原料工厂\nclass NYPizzaIngredientFactory(PizzaIngredientFactory):\n    def create_dough(self):\n        print(\"Tossing %s\" % ThickCrustDough())\n        return ThickCrustDough()\n\n    def create_sauce(self):\n        print(\"Adding %s...\" % MarinaraSauce())\n        return MarinaraSauce()\n\n    def create_cheese(self):\n        print(\"Adding %s...\" % ReggianoCheese())\n        return ReggianoCheese()\n\n    def create_pepperoni(self):\n        print(\"Adding %s...\" % SlicedPepperoni())\n        return SlicedPepperoni()\n\n    def create_clam(self):\n        print(\"Adding %s...\" % FreshClams())\n        return FreshClams()\n\n    def create_veggies(self):\n        # 蔬菜可能有多种，这里使用列表\n        veggies = [Garlic(), Onion(), RedPepper()]\n        for veggie in veggies:\n            print(\"  %s\" % veggie)\n        return veggies\n对于原料家族的每一种原料，我们都提供了原料的纽约版本。\n重做 Pizza 类\nclass Pizza:\n    \n    name = None\n    dough = None\n    sauce = None\n    cheese = None\n    veggies = []\n    pepperoni = None\n    clam = None\n\n    def prepare(self):\n        raise NotImplementedError()\n\n    def bake(self):\n        print(\"Bake for 25 minutes at 350\")\n\n    def cut(self):\n        print(\"Cutting the pizza into diagonal slices\")\n\n    def box(self):\n        print(\"Place pizza in official PizzaStore box\")\n\n    def __str__(self):\n        return self.name\n上述代码和工厂方法的代码相比，只是把 prepare() 方法抽象出来，需要相应的 具体的 pizza 类来实现 prepare()。\n实现 芝加哥芝士披萨\nclass NYStyleCheesePizza(Pizza):\n\n    def prepare(self):\n        dough = self.ingredient_factory.create_dough()\n        sauce = self.ingredient_factory.create_sauce()\n        cheese = self.ingredient_factory.create_cheese()\n        clam = self.ingredient_factory.create_clam()\n        veggies = self.ingredient_factory.create_veggies()\n从上述代码可以发现，Pizza 的原料也是从原料工厂直接获取，现在我们控制了原料。\n现在，Pizza 类不需要关心原料，只需要负责制作 pizza 就好。Pizza 和原料被解耦。\n重新实现 PizzaStore\nclass PizzaStore:\n    \n    # 需要声明原料工厂\n    ingredient_factory = None\n\n    def create_pizza(self, pizza_type):\n        # 每个需要子类实现的方法都会抛出NotImplementedError\n        # 我们也可以把 PizzaStore 的 metaclass 设置成 abc.ABCMeta\n        # 这样的话，这个类就是真正的抽象基类\n        raise NotImplementedError()\n\n    def order_pizza(self, pizza_type):  # 现在把 pizza 的类型传入 order_pizza()\n\n        pizza = self.create_pizza(pizza_type)\n\n        #  一旦我们有了一个 pizza，需要做一些准备（擀面皮、加佐料），然后烘烤、切片、装盒\n        pizza.prepare()\n        pizza.bake()\n        pizza.cut()\n        pizza.box()\n        return pizza\n\nclass NYStylePizzStore(PizzaStore):\n    \n    # 将需要用到的原料工厂赋值给变量 ingredient_factory\n    ingredient_factory = NYPizzaIngredientFactory()\n\n    def create_pizza(self, pizza_type):\n        # 根据 pizza 类型，我们实例化正确的具体类，然后将其赋值给 pizza 实例变量\n        if pizza_type == 'cheese':\n            pizza = NYStyleCheesePizza('NY Style Sauce and Cheese Pizza',\n                                       self.ingredient_factory)\n        elif pizza_type == 'clam':\n            pizza = NYStyleClamPizza('NY Style Clam Pizza',\n                                     self.ingredient_factory)\n        return pizza\n通过上述代码可以看到我们做了以下工作：\n\n引入了新类型的工厂（抽象工厂）来创建原料家族\n通过抽象工厂提供的接口，我们创建了原料家族。\n我们的原料代码从实际的 Pizza 工厂中成功解耦，可以应用到不同地方，响应的，我们可以方便的替换原料工厂来生产不同的 pizza。\n\n来看下下单的代码\ndef main():\n    nystore = NYStylePizzStore()\n    pizza = nystore.order_pizza('cheese')\n    print('*' * 10)\n    print(\"goodspeed ordered a %s\" % pizza)\n    print('*' * 10)\n和工厂方法的代码相比，没有任何改变。\n[源码参考python-design-patter-abstract-factory.py](https://gist.github.com/gusibi/5e0797f5458678322486f999ca87a180)\n抽象工厂模式\n抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要指定具体类。\n也就是说，抽象工厂允许客户使用抽象的接口来创建一组相关的产品，而不需要知道实际产出的具体产品是什么，这样依赖，客户就从具体产品中被解耦。\n概括来说就是，抽象工厂是逻辑上的一组工厂方法，每个工厂方法各司其职，负责生产不同种类的对象。\n我们来看下 抽象工厂模式 的类图：\n\n抽象工厂在 django_factory 中应用比较多，有兴趣的可以看下源码。\n抽象工厂模式 和 工厂方法模式 的比较\n抽象工厂模式 和 工厂方法模式 都是负责创建对象，但\n\n工厂方法模式使用的是继承\n抽象工厂模式使用的是对象的组合\n\n这也就意味着利用工厂方法创建对象需要扩展一个类，并覆盖它的工厂方法（负责将客户从具体类中解耦）。抽象工厂提供一个用来创建产品家族的抽象类型，这个类型的子类定义了产品被产生的方法。要想使用这个工厂（NYPizzaIngredientFactory），必须先实例化它（ingredient_factory = NYPizzaIngredientFactory()），然后将它传入一些针对抽象类型所写的代码中（也做到了将客户从具体产品中解耦），同时还把一群相关的产品集合起来。\n工厂方法模式和抽象工厂模式如何选择\n开始的时候，可以选择工厂方法模式，因为他很简单（只需要继承，并实现工厂方法即可）。如果后来发现应用需要用到多个工厂方法，那么是时候使用抽象工厂模式了，它可以把相关的工厂方法组合起来。\n抽象工厂模式优点和缺点\n优点\n\n可以将客户从具体产品中解耦\n抽象工厂可以让对象创建更容易被追踪\n同时将对象创建与使用解耦\n也可以优化内存占用提升应用性能\n\n缺点\n因为抽象工厂是将一组相关的产品集合起来，如果需要扩展这组产品，就需要改变接口，而改变接口则意味着需要改变每个子类的接口\n参考链接\n\npython设计模式：工厂方法模式\npython-design-patter-abstract-factory.py https://gist.github.com/gusibi/5e0797f5458678322486f999ca87a180\n\n\n最后，感谢女朋友支持。\n\n\n欢迎关注(April_Louisa)\n请我喝芬达\n\n\n\n\n\n\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "8"}