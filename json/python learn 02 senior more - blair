{"title": "python learn 02 senior more - blair ", "index": "python", "content": "Content List\n\n\n1.Datastruct\n\n1.1 List\n1.2 Tuple\n1.3 Dict\n1.4 Seq\n\n\n\n2.I/O\n\n2.1 File\n2.2 储存与取储存\n\n\n\n3.Exception\n\n3.1 try...except\n3.2 try...finally\n\n\n\n4.Python more\n\n4.1 list_comprehension\n4.2 function 接收 tuple和list\n4.3 lambda 表达式\n4.4 exec和eval语句\n4.5 assert 语句\n4.6 repr 函数\n\n\n\n1. Datastruct\n1.1 List\n#!/usr/bin/python\n# Filename: using_list.py\n\n# This is my shopping list\nshoplist = ['apple', 'mango', 'carrot', 'banana']\n\nprint 'I have', len(shoplist),' .'\n\nfor item in shoplist:\n  print item,\n\nprint(\"\\n\")\n\nshoplist.append('rice')\nprint 'My shopping list is now', shoplist\n\nshoplist.sort()\nprint 'Sorted shopping list is', shoplist\n\nprint 'The first item I will buy is', shoplist[0]\nolditem = shoplist[0]\ndel shoplist[0]\nprint 'I bought the', olditem\nprint 'My shopping list is now', shoplist\noutput\n➜  code git:(master) ✗ ./using_list.pyI have 4  .apple mango carrot banana\nMy shopping list is now ['apple', 'mango', 'carrot', 'banana', 'rice']Sorted shopping list is ['apple', 'banana', 'carrot', 'mango', 'rice']The first item I will buy is appleI bought the appleMy shopping list is now ['banana', 'carrot', 'mango', 'rice']\n1.2 Tuple\ntuple element polymorphic\n#!/usr/bin/python\n# Filename: using_tuple.py\n\nzoo = ('wolf', 'elephant', 'penguin')\nprint 'Number of animals in the zoo is', len(zoo)\n\nnew_zoo = ('monkey', 'dolphin', zoo)\nprint 'Number of animals in the new zoo is', len(new_zoo)\nprint 'All animals in new zoo are', new_zoo\nprint 'Animals brought from old zoo are', new_zoo[2]\nprint 'Last animal brought from old zoo is', new_zoo[2][2]\noutput\n$ python using_tuple.pyNumber of animals in the zoo is 3Number of animals in the new zoo is 3All animals in new zoo are ('monkey', 'dolphin', ('wolf', 'elephant', 'penguin'))Animals brought from old zoo are ('wolf', 'elephant', 'penguin')Last animal brought from old zoo is penguin\nusing tuple output...\n#!/usr/bin/python\n# Filename: print_tuple.py\n\nage = 22\nname = 'Swaroop'\n\nprint '%s is %d years old' % (name, age)\nprint 'Why is %s playing with that python?' % name\n1.3 Dict\n#!/usr/bin/python\n# Filename: using_dict.py\n\n# 'ab' is short for 'a'ddress'b'ook\n\nab = {       'Swaroop'   : 'swaroopch@byteofpython.info',\n             'Larry'     : 'larry@wall.org',\n             'Matsumoto' : 'matz@ruby-lang.org',\n             'Spammer'   : 'spammer@hotmail.com'\n     }\n\nprint \"Swaroop's address is %s\" % ab['Swaroop']\n\n# Adding a key/value pair\nab['Guido'] = 'guido@python.org'\n\n# Deleting a key/value pair\ndel ab['Spammer']\n\nprint '\\nThere are %d contacts in the address-book\\n' % len(ab)\nfor name, address in ab.items():\n    print 'Contact %s at %s' % (name, address)\n\nif 'Guido' in ab: # OR ab.has_key('Guido')\n    print \"\\nGuido's address is %s\" % ab['Guido']\n1.4 Seq\nList、Tuple、Str 都是 Seq，但是序列是什么，它们为什么如此特别呢？序列的两个主要特点是索引操作符和切片操作符。\n#!/usr/bin/python\n# Filename: seq.py\n\n# Slicing on a string\nname = 'swaroop'\nprint 'characters 1 to 3 is', name[1:3]\nprint 'characters 2 to end is', name[2:]\nprint 'characters 1 to -1 is', name[1:-1]\nprint 'characters start to end is', name[:]\n\n// mystr = name[:] # make a copy by doing a full slice, deep copy\n2. I/O\n2.1 File\n#!/usr/bin/python\n# Filename: using_file.py\n\npoem = '''\\\nProgramming is fun\nWhen the work is done\nif you wanna make your work also fun:\n        use Python!\n'''\n\nf = file('poem.txt', 'w') # open for 'w'riting\nf.write(poem) # write text to file\nf.close() # close the file\n\nf = file('poem.txt')\n# if no mode is specified, 'r'ead mode is assumed by default\nwhile True:\n    line = f.readline()\n    if len(line) == 0: # Zero length indicates EOF\n        break\n    print line,\n    # Notice comma to avoid automatic newline added by Python\nf.close() # close the file\n2.2 储存与取储存\nObject to FIle 的 W/R\n#!/usr/bin/python\n# Filename: pickling.py\n## import..as语法。这是一种便利方法，以便于我们可以使用更短的模块名称\n\nimport cPickle as p\n#import pickle as p\n\nshoplistfile = 'shoplist.data'\n# the name of the file where we will store the object\n\nshoplist = ['apple', 'mango', 'carrot']\n\n# Write to the file\nf = file(shoplistfile, 'w')\np.dump(shoplist, f) # dump the object to a file\nf.close()\n\ndel shoplist # remove the shoplist\n\n# Read back from the storage\nf = file(shoplistfile)\nstoredlist = p.load(f)\nprint storedlist\n输出\n$ python pickling.py['apple', 'mango', 'carrot']\n3. Exception\n3.1 try...except\n#!/usr/bin/python\n# Filename: try_except.py\n\nimport sys\n\ntry:\n    s = raw_input('Enter something --> ')\nexcept EOFError:\n    print '\\nWhy did you do an EOF on me?'\n    sys.exit() # exit the program\nexcept:\n    print '\\nSome error/exception occurred.'\n    # here, we are not exiting the program\n\nprint 'Done'\n3.2 try...finally\n无论异常发生与否的情况下都关闭文件\n#!/usr/bin/python\n# Filename: finally.py\n\nimport time\n\ntry:\n    f = file('poem.txt')\n    while True: # our usual file-reading idiom\n        line = f.readline()\n        if len(line) == 0:\n            break\n        time.sleep(2)\n        print line,\nfinally:\n    f.close()\n    print 'Cleaning up...closed the file'\n3.3 异常总结\n>>> raise Exception(\"hello\") 引发异常 raise 异常类/异常实例  \n>>> import exceptions  \nException 是所有异常的基类  \n\n@学习摘录 301：自定义异常类  \n —— class SomeCustomException(Exception) : pass  \n \n@学习摘录 302：捕获异常  \n try :  \n     x = input(\"x : \")  \n     y = input('y : ')   \n     print x / y  \n except ZeroDivisionError :  \n     print \"The second num can't zero!\"  \n except TypeError :  \n     print \"That wasn't a number.\"  \n@学习摘录 303：用一个块捕捉两个异常  \n try :  \n     x = input(\"x : \")  \n     y = input('y : ')   \n     print x / y  \n except (ZeroDivisionError, TypeError), e :  \n     print e  \n except : 这样子写的话，就是捕捉所有异常了，不推荐！  \n@学习摘录 304：异常上浮-主程序-堆栈跟踪  \n     try  \n     except :  \n     else :  \n     finally : 最后  \n4. Python more\n4.1 list_comprehension\n#!/usr/bin/python\n# Filename: list_comprehension.py\n\nlistone = [2, 3, 4]\nlisttwo = [2*i for i in listone if i > 2]\nprint listtwo\n4.2 function 接收 tuple和list\n#!/usr/bin/python\n# Filename: powersum.py\n\ndef powersum(power, *args):\n    '''Return the sum of each argument raised to specified power.'''\n    total = 0\n    for i in args:\n        total += pow(i, power)\n    return total\n\nprint powersum(2, 3, 4)\nprint\nprint powersum(2, 10)\n由于在args变量前有前缀，所有多余的函数参数都会作为一个元组存储在args中。如果使用的是*前缀，多余的参数则会被认为是一个字典的键/值对。\n4.3 lambda表达式\nlambda 语句被用来创建新的函数对象，并且在运行时返回它们。\n#!/usr/bin/python\n# Filename: lambda.py\n\ndef make_repeater(n):\n    return lambda s: s*n\n\ntwice = make_repeater(2)\n\nprint twice('word')\nprint twice(5)\nwordword10\n4.4 pass,exec,eval语句\nexec语句用来执行储存在字符串或文件中的Python语句。例如，我们可以在运行时生成一个包含Python代码的字符串，然后使用exec语句执行这些语句。下面是一个简单的例子。\n>>> exec 'print \"Hello World\"'\nHello World\neval语句用来计算存储在字符串中的有效Python表达式。下面是一个简单的例子。\n>>> eval('2*3')\n6\n4.5 assert语句\nassert语句用来声明某个条件是真的。例如，如果你非常确信某个你使用的列表中至少有一个元素，而你想要检验这一点，并且在它非真的时候引发一个错误，那么assert语句是应用在这种情形下的理想语句。当assert语句失败的时候，会引发一个AssertionError。\n>>> mylist = ['item']\n>>> assert len(mylist) >= 1\n>>> mylist.pop()\n'item'\n>>> assert len(mylist) >= 1\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in ?\nAssertionError\n4.6 repr函数\nrepr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注意，在大多数时候有eval(repr(object)) == object。\n>>> i = [] // i = list()\n>>> i.append('item')\n>>> i\n['item']\n>>> `i`\n\"['item']\"\n>>> repr(i)\n\"['item']\"\n>>>\n基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的__repr__方法来控制你的对象在被repr函数调用的时候返回的内容。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}