{"title": "[译]使用 Python 编写虚拟机解释器 - OneAPM 官方技术专栏 ", "index": "apm,python", "content": "原文地址：Making a simple VM interpreter in Python\n\n更新：根据大家的评论我对代码做了轻微的改动。感谢 robin-gvx、 bs4h 和 Dagur，具体代码见这里\n\nStack Machine 本身并没有任何的寄存器，它将所需要处理的值全部放入堆栈中而后进行处理。Stack Machine 虽然简单但是却十分强大，这也是为神马 Python，Java，PostScript，Forth 和其他语言都选择它作为自己的虚拟机的原因。\n\n首先，我们先来谈谈堆栈。我们需要一个指令指针栈用于保存返回地址。这样当我们调用了一个子例程（比如调用一个函数）的时候我们就能够返回到我们开始调用的地方了。我们可以使用自修改代码(self-modifying code)来做这件事，恰如 Donald Knuth 发起的 MIX 所做的那样。但是如果这么做的话你不得不自己维护堆栈从而保证递归能正常工作。在这篇文章中，我并不会真正的实现子例程调用，但是要实现它其实并不难（可以考虑把实现它当成练习）。\n\n有了堆栈之后你会省很多事儿。举个例子来说，考虑这样一个表达式(2+3)*4。在 Stack Machine 上与这个表达式等价的代码为 2 3 + 4 *。首先，将 2 和 3 推入堆栈中，接下来的是操作符 +，此时让堆栈弹出这两个数值，再把它两加合之后的结果重新入栈。然后将 4 入堆，而后让堆栈弹出两个数值，再把他们相乘之后的结果重新入栈。多么简单啊！\n\n让我们开始写一个简单的堆栈类吧。让这个类继承 collections.deque：\n\nfrom collections import deque\n\nclass Stack(deque):\npush = deque.append\n\ndef top(self):\n    return self[-1]\n\n\n现在我们有了 push、pop 和 top 这三个方法。top 方法用于查看栈顶元素。\n\n接下来，我们实现虚拟机这个类。在虚拟机中我们需要两个堆栈以及一些内存空间来存储程序本身（译者注：这里的程序请结合下文理解）。得益于 Pyhton 的动态类型我们可以往 list 中放入任何类型。唯一的问题是我们无法区分出哪些是字符串哪些是内置函数。正确的做法是只将真正的 Python 函数放入 list 中。我可能会在将来实现这一点。\n\n我们同时还需要一个指令指针指向程序中下一个要执行的代码。\n\nclass Machine:\ndef __init__(self, code):\n    self.data_stack = Stack()\n    self.return_addr_stack = Stack()\n    self.instruction_pointer = 0\n    self.code = code\n\n\n这时候我们增加一些方便使用的函数省得以后多敲键盘。\n\ndef pop(self):\n    return self.data_stack.pop()\n\ndef push(self, value):\n    self.data_stack.push(value)\n\ndef top(self):\n    return self.data_stack.top()\n\n\n然后我们增加一个 dispatch 函数来完成每一个操作码做的事儿（我们并不是真正的使用操作码，只是动态展开它，你懂的）。首先，增加一个解释器所必须的循环：\n\ndef run(self):\n    while self.instruction_pointer < len(self.code):\n        opcode = self.code[self.instruction_pointer]\n        self.instruction_pointer += 1\n        self.dispatch(opcode)\n\n\n诚如您所见的，这货只好好的做一件事儿，即获取下一条指令，让指令指针执自增，然后根据操作码分别处理。dispatch 函数的代码稍微长了一点。\n\ndef dispatch(self, op):\n    dispatch_map = {\n        \"%\":        self.mod,\n        \"*\":        self.mul,\n        \"+\":        self.plus,\n        \"-\":        self.minus,\n        \"/\":        self.div,\n        \"==\":       self.eq,\n        \"cast_int\": self.cast_int,\n        \"cast_str\": self.cast_str,\n        \"drop\":     self.drop,\n        \"dup\":      self.dup,\n        \"if\":       self.if_stmt,\n        \"jmp\":      self.jmp,\n        \"over\":     self.over,\n        \"print\":    self.print_,\n        \"println\":  self.println,\n        \"read\":     self.read,\n        \"stack\":    self.dump_stack,\n        \"swap\":     self.swap,\n    }\n\n    if op in dispatch_map:\n        dispatch_map[op]()\n    elif isinstance(op, int):\n        # push numbers on the data stack\n        self.push(op)\n    elif isinstance(op, str) and op[0]==op[-1]=='\"':\n        # push quoted strings on the data stack\n        self.push(op[1:-1])\n    else:\n        raise RuntimeError(\"Unknown opcode: '%s'\" % op)\n\n\n基本上，这段代码只是根据操作码查找是都有对应的处理函数，例如 * 对应 self.mul，drop 对应 self.drop，dup对应 self.dup。顺便说一句，你在这里看到的这段代码其实本质上就是简单版的 Forth。而且，Forth 语言还是值得您看看的。\n\n总之捏，它一但发现操作码是 * 的话就直接调用 self.mul 并执行它。就像这样：\n\ndef mul(self):\n    self.push(self.pop() * self.pop())\n\n\n其他的函数也是类似这样的。如果我们在 dispatch_map 中查找不到相应操作函数，我们首先检查他是不是数字类型，如果是的话直接入栈；如果是被引号括起来的字符串的话也是同样处理－－直接入栈。\n\n截止现在，恭喜你，一个虚拟机就完成了。\n\n让我们定义更多的操作，然后使用我们刚完成的虚拟机和 p-code 语言来写程序。\n\n# Allow to use \"print\" as a name for our own method:\nfrom __future__ import print_function\n\n# ...\n\ndef plus(self):\n    self.push(self.pop() + self.pop())\n\ndef minus(self):\n    last = self.pop()\n    self.push(self.pop() - last)\n\ndef mul(self):\n    self.push(self.pop() * self.pop())\n\ndef div(self):\n    last = self.pop()\n    self.push(self.pop() / last)\n\ndef print(self):\n    sys.stdout.write(str(self.pop()))\n    sys.stdout.flush()\n\ndef println(self):\n    sys.stdout.write(\"%s\\n\" % self.pop())\n    sys.stdout.flush()\n\n\n让我们用我们的虚拟机写个与 print((2+3)*4) 等同效果的例子。\n\nMachine([2, 3, \"+\", 4, \"*\", \"println\"]).run()\n\n\n你可以试着运行它。\n\n现在引入一个新的操作 jump, 即 go-to 操作\n\ndef jmp(self):\n    addr = self.pop()\n    if isinstance(addr, int) and 0 <= addr < len(self.code):\n        self.instruction_pointer = addr\n    else:\n        raise RuntimeError(\"JMP address must be a valid integer.\")\n\n\n它只改变指令指针的值。我们再看看分支跳转是怎么做的。\n\ndef if_stmt(self):\n    false_clause = self.pop()\n    true_clause = self.pop()\n    test = self.pop()\n    self.push(true_clause if test else false_clause)\n\n\n这同样也是很直白的。如果你想要添加一个条件跳转，你只要简单的执行 test-value true-value false-value IF JMP 就可以了.（分支处理是很常见的操作，许多虚拟机都提供类似 JNE 这样的操作。JNE 是 jump if not equal 的缩写）。\n\n下面的程序要求使用者输入两个数字，然后打印出他们的和和乘积。\n\nMachine([\n'\"Enter a number: \"', \"print\", \"read\", \"cast_int\",\n'\"Enter another number: \"', \"print\", \"read\", \"cast_int\",\n\"over\", \"over\",\n'\"Their sum is: \"', \"print\", \"+\", \"println\",\n'\"Their product is: \"', \"print\", \"*\", \"println\"\n]).run()\n\n\nover、read 和 cast_int 这三个操作是长这样滴：\n\ndef cast_int(self):\n    self.push(int(self.pop()))\n\ndef over(self):\n    b = self.pop()\n    a = self.pop()\n    self.push(a)\n    self.push(b)\n    self.push(a)\n\ndef read(self):\n    self.push(raw_input())\n\n\n以下这一段程序要求使用者输入一个数字，然后打印出这个数字是奇数还是偶数。\n\nMachine([\n'\"Enter a number: \"', \"print\", \"read\", \"cast_int\",\n'\"The number \"', \"print\", \"dup\", \"print\", '\" is \"', \"print\",\n2, \"%\", 0, \"==\", '\"even.\"', '\"odd.\"', \"if\", \"println\",\n0, \"jmp\" # loop forever!\n]).run()\n\n\n这里有个小练习给你去实现：增加 call 和 return 这两个操作码。call 操作码将会做如下事情 ：将当前地址推入返回堆栈中，然后调用 self.jmp()。return 操作码将会做如下事情：返回堆栈弹栈，将弹栈出来元素的值赋予指令指针（这个值可以让你跳转回去或者从 call 调用中返回）。当你完成这两个命令，那么你的虚拟机就可以调用子例程了。\n\n一个简单的解析器\n\n创造一个模仿上述程序的小型语言。我们将把它编译成我们的机器码。\n\n import tokenize\n from StringIO import StringIO\n\n# ...\n\ndef parse(text):\ntokens =   tokenize.generate_tokens(StringIO(text).readline)\nfor toknum, tokval, _, _, _ in tokens:\n    if toknum == tokenize.NUMBER:\n        yield int(tokval)\n    elif toknum in [tokenize.OP, tokenize.STRING, tokenize.NAME]:\n        yield tokval\n    elif toknum == tokenize.ENDMARKER:\n        break\n    else:\n        raise RuntimeError(\"Unknown token %s: '%s'\" %\n                (tokenize.tok_name[toknum], tokval))\n\n\n一个简单的优化：常量折叠\n\n常量折叠（Constant folding）是窥孔优化（peephole optimization）的一个例子，也即是说再在编译期间可以针对某些明显的代码片段做些预计算的工作。比如，对于涉及到常量的数学表达式例如 2 3 +就可以很轻松的实现这种优化。\n\ndef constant_fold(code):\n\"\"\"Constant-folds simple mathematical expressions like 2 3 + to 5.\"\"\"\nwhile True:\n    # Find two consecutive numbers and an arithmetic operator\n    for i, (a, b, op) in enumerate(zip(code, code[1:], code[2:])):\n        if isinstance(a, int) and isinstance(b, int) \\\n                and op in {\"+\", \"-\", \"*\", \"/\"}:\n            m = Machine((a, b, op))\n            m.run()\n            code[i:i+3] = [m.top()]\n            print(\"Constant-folded %s%s%s to %s\" % (a,op,b,m.top()))\n            break\n    else:\n        break\nreturn code\n\n\n采用常量折叠遇到唯一问题就是我们不得不更新跳转地址，但在很多情况这是很难办到的（例如：test cast_int jmp）。针对这个问题有很多解决方法，其中一个简单的方法就是只允许跳转到程序中的命名标签上，然后在优化之后解析出他们真正的地址。\n\n如果你实现了 Forth words，也即函数，你可以做更多的优化，比如删除可能永远不会被用到的程序代码（dead code elimination）\n\nREPL\n\n我们可以创造一个简单的 PERL，就像这样\n\ndef repl():\nprint('Hit CTRL+D or type \"exit\" to quit.')\n\nwhile True:\n    try:\n        source = raw_input(\"> \")\n        code = list(parse(source))\n        code = constant_fold(code)\n        Machine(code).run()\n    except (RuntimeError, IndexError) as e:\n        print(\"IndexError: %s\" % e)\n    except KeyboardInterrupt:\n        print(\"\\nKeyboardInterrupt\")\n\n\n用一些简单的程序来测试我们的 REPL\n\n> 2 3 + 4 * println\nConstant-folded 2+3 to 5\nConstant-folded 5*4 to 20\n20\n> 12 dup * println\n144\n> \"Hello, world!\" dup println println\nHello, world!\nHello, world!\n你可以看到，常量折叠看起来运转正常。在第一个例子中，它把整个程序优化成这样 20 println。\n\n\n下一步\n\n当你添加完 call 和 return 之后，你便可以让使用者定义自己的函数了。在Forth 中函数被称为 words，他们以冒号开头紧接着是名字然后以分号结束。例如，一个整数平方的 word 是长这样滴\n\n: square dup * ;\n\n\n实际上，你可以试试把这一段放在程序中，比如 Gforth\n\n$ gforth\nGforth 0.7.3, Copyright (C) 1995-2008 Free Software Foundation, Inc.\nGforth comes with ABSOLUTELY NO WARRANTY; for details type `license'\nType `bye' to exit\n: square dup * ;  ok\n12 square . 144  ok\n\n\n你可以在解析器中通过发现 : 来支持这一点。一旦你发现一个冒号，你必须记录下它的名字及其地址（比如：在程序中的位置）然后把他们插入到符号表（symbol table）中。简单起见，你甚至可以把整个函数的代码（包括分号）放在字典中，譬如：\n\nsymbol_table = {\n\"square\": [\"dup\", \"*\"]\n# ...\n    }\n\n\n当你完成了解析的工作，你可以连接你的程序：遍历整个主程序并且在符号表中寻找自定义函数的地方。一旦你找到一个并且它没有在主程序的后面出现，那么你可以把它附加到主程序的后面。然后用 <address> call 替换掉 square，这里的 <address> 是函数插入的地址。\n\n为了保证程序能正常执行，你应该考虑剔除 jmp 操作。否则的话，你不得不解析它们。它确实能执行，但是你得按照用户编写程序的顺序保存它们。举例来说，你想在子例程之间移动，你要格外小心。你可能需要添加 exit 函数用于停止程序（可能需要告诉操作系统返回值），这样主程序就不会继续执行以至于跑到子例程中。\n\n实际上，一个好的程序空间布局很有可能把主程序当成一个名为 main 的子例程。或者由你决定搞成什么样子。\n\n如您所见，这一切都是很有趣的，而且通过这一过程你也学会了很多关于代码生成、链接、程序空间布局相关的知识。\n\n更多能做的事儿\n\n你可以使用 Python 字节码生成库来尝试将虚拟机代码为原生的 Python 字节码。或者用 Java 实现运行在 JVM 上面，这样你就可以自由使用 JITing。\n\n同样的，你也可以尝试下register machine。你可以尝试用栈帧（stack frames）实现调用栈（call stack），并基于此建立调用会话。\n\n最后，如果你不喜欢类似 Forth 这样的语言，你可以创造运行于这个虚拟机之上的自定义语言。譬如，你可以把类似 (2+3)*4 这样的中缀表达式转化成 2 3 + 4 * 然后生成代码。你也可以允许 C 风格的代码块 { ... } 这样的话，语句 if ( test ) { ... } else { ... } 将会被翻译成\n\n<true/false test>\n<address of true block>\n<address of false block>\nif\njmp\n\n<true block>\n<address of end of entire if-statement> jmp\n\n<false block>\n<address of end of entire if-statement> jmp\n\n\n例子，\n\nAddress  Code\n-------  ----\n 0       2 3 >\n 3       7        # Address of true-block\n 4       11       # Address of false-block\n 5       if\n 6       jmp      # Conditional jump based on test\n\n# True-block\n\n7     \"Two is greater than three.\"  \n8       println\n9       15       # Continue main program\n10       jmp\n\n# False-block (\"else { ... }\")\n11       \"Two is less than three.\"\n12       println\n13       15       # Continue main program\n14       jmp\n\n# If-statement finished, main program continues here\n15       ...\n\n\n对了，你还需要添加比较操作符 != < <= > >=。\n\n我已经在我的 C++ stack machine 实现了这些东东，你可以参考下。\n\n我已经把这里呈现出来的代码搞成了个项目 Crianza，它使用了更多的优化和实验性质的模型来吧程序编译成 Python 字节码。\n\n祝好运！\n\n完整的代码\n\n下面是全部的代码，兼容 Python 2 和 Python 3\n\n你可以通过 这里 得到它。\n\n#!/usr/bin/env python\n# coding: utf-8\n\n\"\"\"\nA simple VM interpreter.\n\nCode from the post at http://csl.name/post/vm/\nThis version should work on both Python 2 and 3.\n\"\"\"\n\nfrom __future__ import print_function\nfrom collections import deque\nfrom io import StringIO\nimport sys\nimport tokenize\n\n\ndef get_input(*args, **kw):\n\"\"\"Read a string from standard input.\"\"\"\nif sys.version[0] == \"2\":\n    return raw_input(*args, **kw)\nelse:\n    return input(*args, **kw)\n\n\nclass Stack(deque):\npush = deque.append\n\ndef top(self):\n    return self[-1]\n\n\nclass Machine:\ndef __init__(self, code):\n    self.data_stack = Stack()\n    self.return_stack = Stack()\n    self.instruction_pointer = 0\n    self.code = code\n\ndef pop(self):\n    return self.data_stack.pop()\n\ndef push(self, value):\n    self.data_stack.push(value)\n\ndef top(self):\n    return self.data_stack.top()\n\ndef run(self):\n    while self.instruction_pointer < len(self.code):\n        opcode = self.code[self.instruction_pointer]\n        self.instruction_pointer += 1\n        self.dispatch(opcode)\n\ndef dispatch(self, op):\n    dispatch_map = {\n        \"%\":        self.mod,\n        \"*\":        self.mul,\n        \"+\":        self.plus,\n        \"-\":        self.minus,\n        \"/\":        self.div,\n        \"==\":       self.eq,\n        \"cast_int\": self.cast_int,\n        \"cast_str\": self.cast_str,\n        \"drop\":     self.drop,\n        \"dup\":      self.dup,\n        \"exit\":     self.exit,\n        \"if\":       self.if_stmt,\n        \"jmp\":      self.jmp,\n        \"over\":     self.over,\n        \"print\":    self.print,\n        \"println\":  self.println,\n        \"read\":     self.read,\n        \"stack\":    self.dump_stack,\n        \"swap\":     self.swap,\n    }\n\n    if op in dispatch_map:\n        dispatch_map[op]()\n    elif isinstance(op, int):\n        self.push(op) # push numbers on stack\n    elif isinstance(op, str) and op[0]==op[-1]=='\"':\n        self.push(op[1:-1]) # push quoted strings on stack\n    else:\n        raise RuntimeError(\"Unknown opcode: '%s'\" % op)\n\n# OPERATIONS FOLLOW:\n\ndef plus(self):\n    self.push(self.pop() + self.pop())\n\ndef exit(self):\n    sys.exit(0)\n\ndef minus(self):\n    last = self.pop()\n    self.push(self.pop() - last)\n\ndef mul(self):\n    self.push(self.pop() * self.pop())\n\ndef div(self):\n    last = self.pop()\n    self.push(self.pop() / last)\n\ndef mod(self):\n    last = self.pop()\n    self.push(self.pop() % last)\n\ndef dup(self):\n    self.push(self.top())\n\ndef over(self):\n    b = self.pop()\n    a = self.pop()\n    self.push(a)\n    self.push(b)\n    self.push(a)\n\ndef drop(self):\n    self.pop()\n\ndef swap(self):\n    b = self.pop()\n    a = self.pop()\n    self.push(b)\n    self.push(a)\n\ndef print(self):\n    sys.stdout.write(str(self.pop()))\n    sys.stdout.flush()\n\ndef println(self):\n    sys.stdout.write(\"%s\\n\" % self.pop())\n    sys.stdout.flush()\n\ndef read(self):\n    self.push(get_input())\n\ndef cast_int(self):\n    self.push(int(self.pop()))\n\ndef cast_str(self):\n    self.push(str(self.pop()))\n\ndef eq(self):\n    self.push(self.pop() == self.pop())\n\ndef if_stmt(self):\n    false_clause = self.pop()\n    true_clause = self.pop()\n    test = self.pop()\n    self.push(true_clause if test else false_clause)\n\ndef jmp(self):\n    addr = self.pop()\n    if isinstance(addr, int) and 0 <= addr < len(self.code):\n        self.instruction_pointer = addr\n    else:\n        raise RuntimeError(\"JMP address must be a valid integer.\")\n\ndef dump_stack(self):\n    print(\"Data stack (top first):\")\n\n    for v in reversed(self.data_stack):\n        print(\" - type %s, value '%s'\" % (type(v), v))\n\n\ndef parse(text):\n# Note that the tokenizer module is intended for parsing Python source\n# code, so if you're going to expand on the parser, you may have to use\n# another tokenizer.\n\nif sys.version[0] == \"2\":\n    stream = StringIO(unicode(text))\nelse:\n    stream = StringIO(text)\n\ntokens = tokenize.generate_tokens(stream.readline)\n\nfor toknum, tokval, _, _, _ in tokens:\n    if toknum == tokenize.NUMBER:\n        yield int(tokval)\n    elif toknum in [tokenize.OP, tokenize.STRING, tokenize.NAME]:\n        yield tokval\n    elif toknum == tokenize.ENDMARKER:\n        break\n    else:\n        raise RuntimeError(\"Unknown token %s: '%s'\" %\n                (tokenize.tok_name[toknum], tokval))\n\ndef constant_fold(code):\n\"\"\"Constant-folds simple mathematical expressions like 2 3 + to 5.\"\"\"\nwhile True:\n    # Find two consecutive numbers and an arithmetic operator\n    for i, (a, b, op) in enumerate(zip(code, code[1:], code[2:])):\n        if isinstance(a, int) and isinstance(b, int) \\\n                and op in {\"+\", \"-\", \"*\", \"/\"}:\n            m = Machine((a, b, op))\n            m.run()\n            code[i:i+3] = [m.top()]\n            print(\"Constant-folded %s%s%s to %s\" %  (a,op,b,m.top()))\n            break\n        else:\n            break\n        return code\n\ndef repl():\nprint('Hit CTRL+D or type \"exit\" to quit.')\n\nwhile True:\n    try:\n        source = get_input(\"> \")\n        code = list(parse(source))\n        code = constant_fold(code)\n        Machine(code).run()\n    except (RuntimeError, IndexError) as e:\n        print(\"IndexError: %s\" % e)\n    except KeyboardInterrupt:\n        print(\"\\nKeyboardInterrupt\")\n\ndef test(code = [2, 3, \"+\", 5, \"*\", \"println\"]):\nprint(\"Code before optimization: %s\" % str(code))\noptimized = constant_fold(code)\nprint(\"Code after optimization: %s\" % str(optimized))\n\nprint(\"Stack after running original program:\")\na = Machine(code)\na.run()\na.dump_stack()\n\nprint(\"Stack after running optimized program:\")\nb = Machine(optimized)\nb.run()\nb.dump_stack()\n\nresult = a.data_stack == b.data_stack\nprint(\"Result: %s\" % (\"OK\" if result else \"FAIL\"))\nreturn result\n\ndef examples():\nprint(\"** Program 1: Runs the code for `print((2+3)*4)`\")\nMachine([2, 3, \"+\", 4, \"*\", \"println\"]).run()\n\nprint(\"\\n** Program 2: Ask for numbers, computes sum and product.\")\nMachine([\n    '\"Enter a number: \"', \"print\", \"read\", \"cast_int\",\n    '\"Enter another number: \"', \"print\", \"read\", \"cast_int\",\n    \"over\", \"over\",\n    '\"Their sum is: \"', \"print\", \"+\", \"println\",\n    '\"Their product is: \"', \"print\", \"*\", \"println\"\n]).run()\n\nprint(\"\\n** Program 3: Shows branching and looping (use CTRL+D to exit).\")\nMachine([\n    '\"Enter a number: \"', \"print\", \"read\", \"cast_int\",\n    '\"The number \"', \"print\", \"dup\", \"print\", '\" is \"', \"print\",\n    2, \"%\", 0, \"==\", '\"even.\"', '\"odd.\"', \"if\", \"println\",\n    0, \"jmp\" # loop forever!\n]).run()\n\n\nif __name__ == \"__main__\":\ntry:\n    if len(sys.argv) > 1:\n        cmd = sys.argv[1]\n        if cmd == \"repl\":\n            repl()\n        elif cmd == \"test\":\n            test()\n            examples()\n        else:\n            print(\"Commands: repl, test\")\n    else:\n        repl()\nexcept EOFError:\n    print(\"\")\n\n\n本文系 OneAPM 工程师编译整理。想阅读更多技术文章，请访问 OneAPM 官方技术博客。\n\n                ", "mainLikeNum": ["6 "], "mainBookmarkNum": "31"}