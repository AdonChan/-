{"title": "Java与Python详细对比 - 个人文章 ", "index": "java,python", "content": "常量：\n在Python中常量的使用并不像java等其他编程语言一样有特定的常量实现的关键字，在Python中定义需要用对象的方法来创建。\n\n[代码演示ConstVar.py]\n# coding=utf-8\nimport const\n\n# java中注解使用 //\n# java中使用final关键字\n# final int STATIC_VAR=5\n# java是编译型语言所以IDE可以实现在编写代码时就提醒错误【编译时就会检查错误】\n# 而python是解释型语言，得运行时才会抛出异常\nconst.STATIC_VAR = 5\nprint const.STATIC_VAR\n#const.STATIC_VAR = 6  # 这一行会抛出异常\n\n# 变量声明与java的区别\n# java中声明变量必须声明变量的类型 如 int i=6;\ni = 6\n\n# java中变量的类型不能变化【不能把int赋值给String】而python则可以\ni = \"一二三\"\n\n# 通过序列解包(sequence unpacking)可以将多个值的序列解开，让后一一放置到变量的序列中。\n# 解包的序列中的元素必须和等号左边变量数量一致。\nvalues = \"1\", 2, True#生成的是一个元组【后面会介绍】\n\nprint values  # output: (1, 2, 3)\nprint values[0]\nx, y, z = values  # output: 1 2 3\nbob_Info = {'name': 'Bob', 'email': 'bob@gmail.com'}\nkey, value = bob_Info.popitem()\nprint value  # output: Bob\n# 通过使用链式赋值(chained assignment)可以将一个值同时赋给多个变量\nx = y = z = 1\nprint x, y, z  # output: 1 1 1\n数与字符串：\n数：\nPython中数的类型主要有5种，分为有符号整数型(int)，长整型(long)，浮点型(float)，布尔型(bool)，复数型(complex)。这些类型是不可变的，就是说整数对象一旦创建，其值便不可更改。相反，系统将创建新的简单类型对象并将其赋值给变量。例如： 0、 1、 -1、 1009、 -290这些等等都是int型。例如： 87887l、 -90990l、 234567l这些等等都是long型。例如： 2.7788、 3.277、 8.88这些等等都是float型。bool型只有两个：一个是True、一个是False。例如： 4+2j、 -9+20j、 56+7j这种类型属于复数类型。[代码演示]\n字符串：\nPython字符串与java区别较大，与javascript较为相似。[代码演示IntString.py]\n# coding=utf-8\n# 变量\n# java 中基本类型是值传递，赋值时并不会新建对象\n# java 中 String 和 python String一样时不可变的\ni = 100\nprint id(i)  # 通过Python id 函数可以查看基本PyObject标识的变更方式\nprint i\ni = 101\nprint id(i)\nprint i\n# 复数  java中没有此类型\nnum = -8.222 - 1.34j\nprint num.real  # num.real    该复数的实数部分\nprint num.imag  # num.imag    该复数的虚数部分\nprint num.conjugate()  # num.conjugat()    返回该复数的共轭算数\n# 字符串\n# java中字符串只可使用双引号声明\n# 单引号\nc1 = '2ght'\nprint id(c1)\nprint c1\n# 下面的语句在java中需要使用转义\nc2 = 'It is a \"dog\"!'\nprint c2\n# 双引号\nc1 = \"2ght11\"\nprint id(c1)\nprint c1\nc2 = \"It's a dog!\"\nprint c2\n# java要实现该代码较为复杂且可读性较差\nc1 = '''三引号\n声明的字符串\n会保留换行\n    也会保留缩进'''\nprint c1\nc2 = \"\"\"三引号\n双引号也可以\n声明的字符串\n会保留换行\n    也会保留缩进\"\"\"\nprint c2\n# 字符串拼接\nstr = \"one\" + \"123\" + \"456\"\nprint str\n# str=\"one\"+\"123\"+\n#     \"456\"这种写法是错误的\n# \\用于代码换行时的拼接\n# java中没有编译时会自动将物理行转换为逻辑行所以使用+即可并无此特性\none = \"第一次\" \\\n      \"第二次\"\nprint one\n# 子字符串\n# 索引运算符从0开始索引\n# 切片运算符[a:b]是指从第a下标开始到第b-1下标。同样第一位的下标为0.\nstr = '0123456789'\nprint \"str[7] %s\" % str[7]\nprint \"str[0:3] %s\" % str[0:3]  # 截取第一位到第三位的字符\nprint \"str[:] %s\" % str[:]  # 截取字符串的全部字符 java中不支持默认值，所以没有该对应的方法\nprint \"str[6:] %s\" % str[6:]  # 截取第七个字符到结尾\nprint \"str[:-3] %s\" % str[:-3]  # 截取开始到倒数\nprint \"str[-1] %s\" % str[-1]  # 截取倒数第一个字符\nprint \"str[::-1] %s\" % str[::-1]  # 倒序 java中反转字符需要自行编写方法实现\nprint \"str[-3:-1] %s\" % str[-3:-1]  # 截取倒数第三位与倒数第一位之前的字符\nprint \"str[-3:] %s\" % str[-3:]  # 截取倒数第三位到结尾\nprint \"str[:-5] %s\" % str[:-5]  # 逆序截取\nprint \"str[:-5:-3] %s\" % str[:-5:-3]  # 逆序截取\n# 去空格及特殊符号\n# strip(rm)删除s字符串中开头、结尾处，位于 rm删除序列的字符，默认为空格。\n# lstrip(rm)删除s字符串中开头处，位于 rm删除序列的字符\n# rstrip(rm)删除s字符串中结尾处，位于 rm删除序列的字符\ns = \" 12313 \"\nprint s\nprint s.strip()#对应java.trim()单java中不可传参\ns = \",12313,\"\nprint s\nprint s.lstrip(\",\")#java API没有对应方法\nprint s.rstrip(\",\")#java API没有对应方法\n# str -- 分隔符，默认为空格。\n# num -- 分割次数。\nstr = \"#Line1-abcdef #Line2-abc #Line4-abcd\";\nprint str.split()#java中有对应方法只是没有默认参数\nprint str.split(' ', 1)\n# 字符串的重复\nstr = \"字符串的重复\\n\" * 20#java中不支持此特性需要循环实现\nprint str\n# 转义符\nprint 'It\\'s a dog!'\nprint \"hello boy\\nhello boy\"\n# 自然字符串\nprint \"hello boy\\nhello boy\"\nprint r\"hello boy\\nhello boy\"  # java中则是\\\\n来实现\n# 其他API可以自行查询\n数据类型:\n基本数据类型：\n数以及字符串\n常用的数据类型：\n列表和元组：\n在Python中没有数组的概念， Python中跟数组最接近的概念就是列表和元组。列表就是用来存储一连串元素的容器。列表用[]来表示元组里面的元素也是进行索引计算列表跟元组有什么区别呢？一是列表里面的元素的值可以修改，而元组里面的元素的值不能修改，只能读取。二是列表的符号是[],而元组的符号是（）集合：Python中集合主要有两个功能，一个功能是建立关系，另一个功能是消除重复元素。字典：Python中的字典也叫做关联数组，用大括号{}括起来[代码演示DataType.py]\n# coding=utf-8\n# java中List、数组对应的内容\n# 列表\nstudents = [\"小明\", \"小华\", \"小李\", \"小娟\", \"小云\"]\nprint students[3]\nstudents[3] = \"小月\"\nprint students[3]\n# 元组java中没有内置对应的数据结构\nstudentsArray = (\"小明\", \"小军\", \"小强\", \"小武\", \"小龙\")\nprint studentsArray[1]\n# studentsArray[1] = \"小云\"  # 这行会报错 元组不允许修改\nprint studentsArray[1]\n#java中set接口\na = set(\"abcnmaaaaggsng\")\nb = set(\"cdfm\")\nprint a  # 会自动去重\nprint b\n# 交集\nx = a & b\nprint x\n# 并集\ny = a | b\nprint y\n# 差集\nz = a - b\nprint z\n# 去除重复元素\nnew = set(a)\nprint new\n# 字典\nk = {\"姓名\": \"韦玮\", \"籍贯\": \"桂林\"}\nprint k[\"籍贯\"]\n# 添加字典里面的项目\nk[\"爱好\"] = \"音乐\"\nprint k[\"姓名\"]\nprint k[\"爱好\"]\n标识符:\n在Python中标识符的命名是有规则的。按正确命名规则命名的可以使用的标识符叫做有效标识符，否则不能使用的标识符叫做无效标识符。\n有效标识符命名有以下几点规范：\n标识符第一个字符必须只能是字母或下划线，第一个字符不能出现数字或其他字符；\n标识符除第一个字符外，其他部分可以是字母或者下划线或者数字；\n标识符大小写敏感，比如name跟Name是不同的标识符。\n标识符不能是关键字\n\nPython关键字：\n\n对象：\n在Python中，一切皆为对象。Python的内置的对象类型主要有数字、字符串、列表、元组、字典、集合等等。在Python中如果我们有一些对象需要持久性存储，并且不丢失我们这个对象的类型与数据，我们则需要将这些对象进行序列化，序列化之后，需要使用的时候，我们再恢复为原来的数据。\n序列化的这种过程，我们将其称为pickle（腌制）。pickle中的函数主要有：dumps(object),loads(string),dump(object,file),loads(file)[代码演示pickleTest.py]\n# coding=utf-8\n# pickle腌制\nimport pickle\n\n# dumps(object)将对象序列化\nlista = [\"mingyue\", \"jishi\", \"you\"]\nlistb = pickle.dumps(lista)\n# print listb\n\n# loads(string)将对象原样恢复，并且对象类型也恢复为原来的格式\nlistc = pickle.loads(listb)\n# print listc\n\n# dump(object,file),将对象存储到文件里面序列化\ngroup1 = (\"bajiu\", \"wen\", \"qingtian\")\n# file是python中IO操作的模块 wb 代表写 rb 代表读\nf1 = file('1.pk1', 'wb')\npickle.dump(group1, f1, True)\nf1.close()\n\n# load(object,file)将dump()存储在文件里面的数据恢复\nf2 = file('1.pk1', 'rb')\nt = pickle.load(f2)\nprint t\nf2.close()\n行与缩进:\n逻辑行与物理行：\nPython中逻辑行主要是指一段代码，在意义上它的行数，而物理行，指的是我们实际看到中的行数。\n\n在Python中一个物理行一般可以包含多个逻辑行，在一个物理行中编写多个逻辑行的时候，逻辑行与逻辑行之间用分号隔开。每个逻辑行的后面必须是有一个分号的，但是我们在编写程序的时候，如果一个逻辑行占了一个物理行的最后，这个逻辑行可以省略分号。\n\n缩进：\n\nPython运算符优先级：\n在Python中我们常见的运算符有： +、 -、 *、 /、 **、 <、 >、 !=、 //、 % 、 & 、 |、 ^、~、 >>、 <<、 <=、 >=、 ==、 not、 and、 or。[代码演示 运算符.py]\n优先级：优先级使用实战优先级排行榜第1名——函数调用、寻址、下标优先级排行榜第2名——幂运算**优先级排行榜第3名——翻转运算~优先级排行榜第4名——正负号优先级排行榜第5名——*、/、%优先级排行榜第6名——+、-优先级排行榜第7名——<<、>>优先级排行榜第8名——按位&、^、|，其实这三个中也是有优先级顺序的，但是他们处于同一级别，故而不细分优先级排行榜第9名——比较运算符优先级排行榜第10名——逻辑的not、and、or优先级排行榜第11名——lambda表达式\n函数：\n函数的功能：\n# coding=utf-8\n# 函数的功能\n# 系统自带的函数\n# 1.实现取字符串长度的功能\n'''\na=\"hellomyteacher\"\nprint len(a)\n'''\n# 2.实现字符串的切割\n'''\na=\"student\"\nb=a.split(\"u\")\nprint b\n'''\n\n\n# 自定义的函数\ndef a():\n    print \"hello\";\n    print 777\n    print \"a\"\na()\n函数的定义：\n# coding=utf-8\n# 函数的定义\n# 格式\n'''\ndef 函数名（）：\n    函数内容;函数内容\n    函数内容;函数内容\n'''\n\n\n# 实例\ndef function1():\n    a = 8\n    print a\n函数实参和形参：\n# coding=utf-8\n# 函数形参与实参\n# 参数的概念\n# print len()\n\n'''\na=\"abcdm\"\nprint len(a)\n'''\n# 什么是形参\n'''\ndef function1(a,b):\n    if a>b:\n        print a\n    else:\n        print b\n   '''\n# 什么是实参\n'''\ndef function1(a,b):\n    if a>b:\n        print a\n    else:\n        print b\nfunction1(1,3)#1 3是实参\n'''\n# 参数的传递\n# 第一中，最简单的传递\n'''\ndef function(a,b):\n    if a>b:\n        print \"前面这个数大于后面这个数\"\n    else:\n        print \"后面这个数比较大\"\nfunction(7,8)\n'''\n# 第二种，赋值传递\n'''\ndef function(a,b=8):\n    print a\n    print b\n#function(1)\nfunction(1,2)\n'''\n\n\n# 关键参数\ndef function(a=1, b=6, c=7):\n    print a\n    print b\n    print c\n\n#python中可以指定参数从而无需依循参数的顺序[java无此功能]\n# function(5)\n# function(b=7,a=8)\n# function(5,c=2,b=3)\n# function(b=4,c=2,a=1)\n'''但是要注意，参数不能冲突'''\n# function(b=2, c=3, 2)#这行会报错，因为第三个默认是c参数，前面已经给c参数赋值，所以冲突\n全局变量：\n# coding=utf-8\n# 全局变量与局部变量\n# 作用域\ndef func():\n    i = 8\n# print i\n# print j\nj = 9\n# print j\n# 局部变量\ndef func2(a):\n    i = 7\n    print i\ni = 9\n# func2(i)\n# print i\n# 全局变量\ndef func3():\n    global i\n    i = 7\n    # print i\n# i=9\nfunc3()\ni = 9\nprint i\n函数的使用：\n# coding=utf-8\n# 函数使用与返回值\n# 函数调用\n'''\n函数的调用我们已经接触过了多次，要想调用一个函数，\n在函数定以后，直接输一遍这个函数名即可，如果要传\n递实参到函数里面执行，直接在调用的时候括号里面输\n入实参即可。比如一个函数是def func3()：这样定\n义的,那么我们调用它直接输入func3(参数)即可。其\n中参数可以省略。\n'''\ndef a():\n    i = 1\na()\n# 函数返回值\n'''函数的返回值是通过return语句来实现的'''\n# 一个返回值的情况\ndef test():\n    i = 7\n    return i\n# print test()\n# 多个返回值的情况\ndef test2(i, j):\n    k = i * j\n    return (i, j, k)\n# x=test2(4,5)\n# print x\ny, z, m = test2(4, 5)\nprint y\n文档字符串：\n# coding=utf-8\n# 文档字符串\ndef d(i, j):\n    '''这个函数实现一个乘法运算。\n    函数会返回一个乘法运算的结果。'''\n    k = i * j\n    return k\n\n# print d.__doc__\n\nhelp(d)\n模块：\n函数是可以实现一项或多项功能的一段程序。\n模块是函数功能的扩展，模块是可以实现一项或多项功能的程序块。Python中在一个程序中要使用某个模块，不能直接使用模块里面的功能。在使用模块之前，必须先导入指定模块，只要导入了一个模块，才能使用一个模块。\n字节编译：\n由于计算机只认识二进制的机器语言，所以在执行Python模块的时候，有两种执行方式：\n一种是先将模块里面的内容编译成二进制语言，然后执行这些二进制语言；\n另一种是直接执行对应模块的二进制语言程序。\n第二种方式省略了编译这一步，所以执行速度相对来说要快一些。而把模块编译成二进制语言程序的这个过程叫做字节编译，这个过程会产生一个与编译的模块对应的.pyc文件。\n把模块编译成二进制语言程序的这个过程叫做字节编译。Python中虽然出现了编译这个过程，但是Python中编译的过程是在Python的解释器中发生的。换句话来说，其实每种程序要想让计算机执行，都只能变成二进制的形式，编译型语言是指在软件中就有一个独立的编译模块去将程序编译，而Python中字节编译这部分功能是由解释器完成的，所以Python仍然是解释型语言。[对应java中.class]\n主模块：\nPython函数中，如果一个函数调用其他函数完成一项功能，我们称这个函数为主函数，如果一个函数没有调用其他函数，我们这种函数叫做非主函数。模块也类似，如果一个模块是被直接使用的，而没有被别人调用，我们称这个模块为主模块，如果一个模块被别人调用，我们这种模块叫做非主模块。\n如果一个模块的__name__属性的值是__main__，那么就说明这个模块是主模块，反之亦然。其实我们可以把__name__看作一个变量，这个变量是系统给出的，这个变量的功能是判断一个模块是否是主模块。[modul.py]\n# coding=utf-8\n# 分别直接执行这个模块与导入这个模块，看一下结果\nprint __name__\nif __name__ == \"__main__\":\n    print \"This is main\"\nelse:\n    print \"This is not main\"\n模块：\n函数是可以实现一项或多项功能的一段程序。\n模块是函数功能的扩展，模块是可以实现一项或多项功能的程序块。Python中在一个程序中要使用某个模块，不能直接使用模块里面的功能。在使用模块之前，必须先导入指定模块，只要导入了一个模块，才能使用一个模块。\nGitHub地址：https://github.com/zylianyao/...\n\n我是广告\n本人的直播课程在 7 月份就要开始了，希望小伙伴们支持一下，现在报名有优惠噢\nhttps://segmentfault.com/l/15...\nhttps://segmentfault.com/l/15...\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "3"}