{"title": "python---异常处理 - python学习 ", "index": "python", "content": "异常和错误\n程序中难免出现错误，而错误分成两种\n1.语法错误（这种错误，根本过不了python解释器的语法检测，必须在程序执行前就改正）\n#语法错误示范一\nif\n\n#语法错误示范二\ndef test:\n    pass\n\n#语法错误示范三\nprint(haha\n2.逻辑错误（逻辑错误）\n#用户输入不完整(比如输入为空)或者输入非法(输入不是数字)\nnum=input(\">>: \")\nint(num)\n\n#无法完成计算\nres1=1/0\nres2=1+'str'\n什么是异常\n异常就是程序运行时发生错误的信号，在python中,错误触发的异常如下\n\npython中的异常种类\n在python中不同的异常可以用不同的类型（python中统一了类与类型，类型即类）去标识，不同的类对象标识不同的异常，一个异常标识一种错误1.触发IndexError\nl=['egon','aa']\nl[3]\n2.触发KeyError\ndic={'name':'egon'}\ndic['age']\n3.触发ValueError\ns='hello'\nint(s)\n4.常用异常\nAttributeError 试图访问一个对象没有的树形，比如foo.x，但是foo没有属性x\nIOError 输入/输出异常；基本上是无法打开文件\nImportError 无法引入模块或包；基本上是路径问题或名称错误\nIndentationError 语法错误（的子类） ；代码没有正确对齐\nIndexError 下标索引超出序列边界，比如当x只有三个元素，却试图访问x[5]\nKeyError 试图访问字典里不存在的键\nKeyboardInterrupt Ctrl+C被按下\nNameError 使用一个还未被赋予对象的变量\nSyntaxError Python代码非法，代码不能编译(个人认为这是语法错误，写错了）\nTypeError 传入对象类型与要求的不符合\nUnboundLocalError 试图访问一个还未被设置的局部变量，基本上是由于另有一个同名的全局变量，\n导致你以为正在访问它\nValueError 传入一个调用者不期望的值，即使值的类型是正确的\n5.更多异常\nArithmeticError\nAssertionError\nAttributeError\nBaseException\nBufferError\nBytesWarning\nDeprecationWarning\nEnvironmentError\nEOFError\nException\nFloatingPointError\nFutureWarning\nGeneratorExit\nImportError\nImportWarning\nIndentationError\nIndexError\nIOError\nKeyboardInterrupt\nKeyError\nLookupError\nMemoryError\nNameError\nNotImplementedError\nOSError\nOverflowError\nPendingDeprecationWarning\nReferenceError\nRuntimeError\nRuntimeWarning\nStandardError\nStopIteration\nSyntaxError\nSyntaxWarning\nSystemError\nSystemExit\nTabError\nTypeError\nUnboundLocalError\nUnicodeDecodeError\nUnicodeEncodeError\nUnicodeError\nUnicodeTranslateError\nUnicodeWarning\nUserWarning\nValueError\nWarning\nZeroDivisionError\n异常处理\n使用if判断式\n1.正常的代码\nnum1=input('>>: ') #输入一个字符串试试\nint(num1)\n2.使用if判断进行异常处理\n#_*_coding:utf-8_*_\n\nnum1=input('>>: ') #输入一个字符串试试\nif num1.isdigit():\n    int(num1) #我们的正统程序放到了这里,其余的都属于异常处理范畴\nelif num1.isspace():\n    print('输入的是空格,就执行我这里的逻辑')\nelif len(num1) == 0:\n    print('输入的是空,就执行我这里的逻辑')\nelse:\n    print('其他情情况,执行我这里的逻辑')\n\n'''\n问题一：\n使用if的方式我们只为第一段代码加上了异常处理，但这些if，跟你的代码逻辑并无关系，这样你的代码会因为可读性差而不容易被看懂\n\n问题二：\n这只是我们代码中的一个小逻辑，如果类似的逻辑多，那么每一次都需要判断这些内容，就会倒置我们的代码特别冗长。\n'''\n总结：\n1.if判断式的异常处理只能针对某一段代码，对于不同的代码段的相同类型的错误你需要写重复的if来进行处理。\n2.在你的程序中频繁的写与程序本身无关，与异常处理有关的if，会使得你的代码可读性极其的差\n3.if是可以解决异常的，只是存在1,2的问题，所以，千万不要妄下定论if不能用来异常处理。\ndef test():\n    print('test running')\nchoice_dic={\n    '1':test\n}\nwhile True:\n    choice=input('>>: ').strip()\n    if not choice or choice not in choice_dic:continue #这便是一种异常处理机制啊\n    choice_dic[choice]()\npython为每一种异常定制了一个类型，然后提供了一种特定的语法结构用来进行异常处理\n1.基本语法\ntry:\n     被检测的代码块\nexcept 异常类型：\n     try中一旦检测到异常，就执行这个位置的逻辑\n读文件例1\nf = open('a.txt')\n\ng = (line.strip() for line in f)\nfor line in g:\n    print(line)\nelse:\n    f.close()\n读文件例2\ntry:\n    f = open('a.txt')\n    g = (line.strip() for line in f)\n    print(next(g))\n    print(next(g))\n    print(next(g))\n    print(next(g))\n    print(next(g))\nexcept StopIteration:\n    f.close()\n\nnext(g)会触发迭代f，依次next(g)就可以读取文件的一行行内容，无论文件a.txt有多大，同一时刻内存中只有一行内容。\n提示：g是基于文件句柄f而存在的，因而只能在next(g)抛出异常StopIteration后才可以执行f.close()\n2.异常类只能用来处理指定的异常情况，如果非指定异常则无法处理。\ns1 = 'hello'\ntry:\n    int(s1)\nexcept IndexError as e:\n    print(e)\n3.多分支\ns1 = 'hello'\ntry:\n    int(s1)\nexcept IndexError as e:\n    print(e)\nexcept KeyError as e:\n    print(e)\nexcept ValueError as e:\n    print(e)\n4.万能异常 在python的异常中，有一个万能异常：Exception，他可以捕获任意异常\n\n    s1 = 'hello'\ntry:\n    int(s1)\nexcept Exception as e:\n    print(e)\n\n4.1.如果你想要的效果是，无论出现什么异常，我们统一丢弃，或者使用同一段代码逻辑去处理他们，那么骚年，大胆的去做吧，只有一个Exception就足够了。\ns1 = 'hello'\ntry:\n    int(s1)\nexcept Exception,e:\n    '丢弃或者执行其他逻辑'\n    print(e)\n\n#如果你统一用Exception，没错，是可以捕捉所有异常，但意味着你在处理所有异常时都使用同一个逻辑去处理（这里说的逻辑即当前expect下面跟的代码块）\n4.2如果你想要的效果是，对于不同的异常我们需要定制不同的处理逻辑，那就需要用到多分支了\ns1 = 'hello'\ntry:\n    int(s1)\nexcept IndexError as e:\n    print(e)\nexcept KeyError as e:\n    print(e)\nexcept ValueError as e:\n    print(e)\n4.3多分支加Exception\ns1 = 'hello'\ntry:\n    int(s1)\nexcept IndexError as e:\n    print(e)\nexcept KeyError as e:\n    print(e)\nexcept ValueError as e:\n    print(e)\nexcept Exception as e:\n    print(e)\n3.异常的其他机构\ns1 = 'hello'\ntry:\n    int(s1)\nexcept IndexError as e:\n    print(e)\nexcept KeyError as e:\n    print(e)\nexcept ValueError as e:\n    print(e)\n#except Exception as e:\n#    print(e)\nelse:\n    print('try内代码块没有异常则执行我')\nfinally:\n    print('无论异常与否,都会执行该模块,通常是进行清理工作')\n4.主动触发异常\ntry:\n    raise TypeError('类型错误')\nexcept Exception as e:\n    print(e)\n5.自定义异常\nclass EvaException(BaseException):\n    def __init__(self,msg):\n        self.msg=msg\n    def __str__(self):\n        return self.msg\n\ntry:\n    raise EvaException('类型错误')\nexcept EvaException as e:\n    print(e)\n6.断言\n# assert 条件\n \nassert 1 == 1\n \nassert 1 == 2\n总结：try..except的方式比较if的方式的好处\n1：把错误处理和真正的工作分开来\n2：代码更易组织，更清晰，复杂的工作任务更容易实现；\n3：毫无疑问，更安全了，不至于由于一些小的疏忽而使程序意外崩溃了；\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "0"}