{"title": "python基础知识之函数初阶——参数详解 - python研究室 ", "index": "python", "content": "定义函数\npython中的函数使用关键字 def 定义，格式为:\ndef 函数名(形参):\n    函数语句块\n函数名只能包含字符串、下划线和数字且不能以数字开头。函数的形参分为：位置参数、默认参数（自带默认值的参数）、动态参数return是关键字，作用是返回函数的结果，遇到return时函数立刻结束，不再执行其他语句\n位置参数\ndef func(a,b):\n    return a,b \nprint(func(1,2)) #按照位置传入参数，1赋值给a,2赋值给b\nprint(func(a=2,b=3))#按照关键字传入参数，指定a、b的值\nprint(func(3,b=6))#混合传入，此时注意，位置参数要在前面\n#如果不指定实参会报错，因为函数中由位置参数，则调用函数时必须传入参数\n#print(func())\n输出结果为：\n    (1, 2)\n    (2, 3)\n    (3, 6)\n不写return或者只写return，后面不写其他内容时，函数会返回None return可以返回任意数据类型的值。当return返回多个值时，会被组织成元组，也就是说返回多个值时，类型为元组。可以用多个变量接收结果，但变量的数量要与返回的值数量相同，示例如下：\ndef func():\n    return 1,'asd',(1,'a',['hello','world']),[1,2,3]\nprint('直接打印结果：',func())\na,b,c,d = func() \nprint('a:',a)\nprint('b:',b)\nprint('c:',c)\nprint('d:',d)\n输出：\n直接打印结果： (1, 'asd', (1, 'a', ['hello', 'world']), [1, 2, 3])\na: 1\nb: asd\nc: (1, 'a', ['hello', 'world'])\nd: [1, 2, 3]\n默认参数\n\ndef func(name,age=20):\n    print('{}已经{}岁啦'.format(name,age))\nfunc('刘小姐')#默认参数可以不传，这时age值为默认的20\nfunc('刘小姐',28)#默认参数传值时则覆盖默认值\n刘小姐已经20岁啦\n刘小姐已经28岁啦\n\n\n默认值只被赋值一次。这使得当默认值是可变对象时会有所不同，比如列表、字典或者大多数类的实例。例如，下面的函数在后续调用过程中会累积（前面）传给它的参数:\ndef func(a = []):\n    a.append('x')\n    return a\nfor i in range(6):\n    print(func())\n每次循环调用的时候，虽然没有给a传入参数，但是a并不会被赋值空列表[]，原因是默认值只会被赋值一次，所以输出结果变成了下面的样子：\n    ['x']\n    ['x', 'x']\n    ['x', 'x', 'x']\n    ['x', 'x', 'x', 'x']\n    ['x', 'x', 'x', 'x', 'x']\n    ['x', 'x', 'x', 'x', 'x', 'x']\n如果你不想让默认值在后续调用中累积，你可以像下面一样定义函数:\ndef func(a = None):\n    if a is None: #如果a是None\n        a = []\n    a.append('x')\n    return a\nfor i in range(6):\n    print(func())\n['x']\n['x']\n['x']\n['x']\n['x']\n['x']\n\n\n动态参数\n动态参数分为两种：一种是用*args表示，它会把多余的位置参数统一接收，保存成一个元组的形式另一种是用**kwargs表示，他会把多余的关键字参数统一接收，保存成一个字典的形式 先看一个*args的例子\ndef func(a,b,c,*args):\n    print('*args内容为：',args)\n    sum1 = 0\n    for i in args:\n        sum1 += i\n    sum1 = sum1 + a +b +c\n    return sum1\nprint(func(1,2,3,4,5,6,7,8,9,10))\n虽然形参只有4个，但是我们传入了10个，4—10 都被*args接收形成元组\n    *args内容为： (4, 5, 6, 7, 8, 9, 10)\n    55\n再来看看**kwargs\ndef func(a,b,*args,c=20,**kwargs):\n    print('*args内容为：',args)\n    print(c)\n    print('**kwargs内容为：',kwargs)\n    sum1 = 0\n    for i in args:\n        sum1 += i\n    sum1 = sum1 + a +b +c\n    for k in kwargs:\n        sum1 += kwargs[k]\n    return sum1\nprint(func(1,2,3,4,5,6,7,8,9,10,c=22,x=11,y=33,z=66))\n*args内容为： (3, 4, 5, 6, 7, 8, 9, 10)\n22\n**kwargs内容为： {'x': 11, 'y': 33, 'z': 66}\n187\n从上例可以看出如果各种类型的形参都出现时，它们的顺序应该是：位置参数、动态参数args、默认参数、动态参数*keargs\n因为假设默认参数在 args之前，也就是func(a,b,c=20,args,*kwargs)，那么传入参数时，形参c的值先会被实参3赋值（因为3的位置恰好对应c，默认参数不赋值时值为默认，赋值时则覆盖默认值），此时c=3，但是后面又出现了c=20，这时就会报错，因为形参c被重复赋值了两次，这是不允许的 所以默认参数排在 args后面\n默认参数必须排在kwargs前面，因为如果排在后面，则c=22会被kwargs直接接收，这样默认参数毫无意义，这是不被允许的，会报错\n下面是默认参数排在*args前面的另一种方式，这种方式虽然也得出了相同的结果但是在调用时要特别的小心c的值所在的位置，而且这种方式会造成默认参数变得毫无意义，因为始终用不到默认值20。所以默认参数还是放在*args后面合适。\ndef func(a,b,c=20,*args,**kwargs):\n    print('*args内容为：',args)\n    print(c)\n    print('**kwargs内容为：',kwargs)\n    sum1 = 0\n    for i in args:\n        sum1 += i\n    sum1 = sum1 + a +b +c\n    for k in kwargs:\n        sum1 += kwargs[k]\n    return sum1\nprint(func(1,2,22,3,4,5,6,7,8,9,10,x=11,y=33,z=66))\n*args内容为： (3, 4, 5, 6, 7, 8, 9, 10)\n22\n**kwargs内容为： {'x': 11, 'y': 33, 'z': 66}\n187\n\n\n动态参数的一种快捷传参方式\n对于*args,可以在传入参数时在lis前面加*号 直接传入内容\ndef func(*args):\n    return args\nlis = [1,2,{3,4,5},6,7,[8,9,0,1,23],34,5,(56,67),78,23]\nprint(type(lis))\nprint(func(*lis))\n<class 'list'>\n(1, 2, {3, 4, 5}, 6, 7, [8, 9, 0, 1, 23], 34, 5, (56, 67), 78, 23)\n\n对于**kwargs可以在传入参数时在dic前面加**号 直接传入内容\ndef func(**kwargs):\n    return kwargs\ndic = {'name':'超人','age':'500','job':'装逼'}\nprint(func(**dic))\n{'name': '超人', 'age': '500', 'job': '装逼'}\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}