{"title": "几个有趣的算法题目 - hacker之路 ", "index": "c,python,算法", "content": "本文首发 http://svtter.cn\n最接近的数字\n题目\n一个K位的数N\n$$\n(K\\leq2000，N\\leq10^{20})\n$$\n找出一个比N大且最接近的数，这个数的每位之和与N相同，用代码实现之。\n例如：0050 所求书数字为0104；112 所求数为121；\n算法分析 算法思想\n直接暴力求这个数字是不可以的，数字的量级太大，有K位的数字，不可能直接用int，或者float来表示，使用数组来存储。应该分析这个数字，step1，从右边开始的最小位数开始，分解最后一位数字，分解出1来拿给前面的一位。9和0比较特殊，因此从左往右扫描的开始，遇到0就跳过，遇到第一个非0的数字，就把这个数字-1，然后移到最后面去，然后，step2，开始找第一个非9的数字，如果遇到9，就把9放到最后面去，遇到非9，就+1，结束运算。\n一个般的例子：\n1999000 -> 1990008-> 2000899\n要注意一个问题，就是如果是 999000 这种情况，在数字的最开头补1，结果是1000899\n几个刁蛮的数据：29399 -> 29489\n伪代码\narray = get_array() # number to char array\narray.reverse()\nstep1 = true\nstep2 = false\nzero = 0, cnt = 0;\nfor i : 1 - lengthof(array)\n    if step1:\n        if array[i] is 0:\n            zero ++\n        else:\n            array[i] = array[i] - 1\n            if zero > 0:\n                array[0] = array[i]\n                array[i] = 0\n            step1 = false\n            step2 = true\n    else if step2:\n        if array[i] is 9:\n            if zero == 0:\n                array[cnt+1] = array[cnt]\n                array[cnt] = 9\n                cnt++\n                if (i != cnt):\n                    array[i] = array[i-1]\n            else:\n                array[cnt + 1] = array[cnt]\n                array[cnt] = 9\n                cnt++\n                array[i] = 0\n        else:\n            i = i+1\n            step2 = false\n            break\n            \n            \nif not step2:\n    array[lengthof(array)] = 1\n\narray.reverse()\ndisp(array)\n分析时间复杂度O\n因为reverse操作，2K，加上最后整理最小数到最前面，最坏情况接近K，3K，在循环中的操作看运气，但是最糟糕的情况也只有5K，所以时间复杂度为\n$$\nO(3K) \\approx O(K)\n$$\n源代码\n#include <stdio.h>\n#include <string.h>\n\nconst int MAXN = 3000;\nchar array[MAXN];\nint length_of_number;\nvoid get_array()\n{\n    int i;\n    char null;\n    scanf(\"%d\", &length_of_number);\n    scanf(\"%c\", &null);\n    for (i = 0; i < length_of_number; i++)\n    {\n        scanf(\"%c\", &array[i]);\n    }\n    scanf(\"%c\", &null);\n}\n\nvoid reverse()\n{\n    int i ;\n    char temp;\n    for (i = 0; i < length_of_number/2; i++)\n    {\n        // _swap\n        temp = array[i];\n        array[i] = array[length_of_number - 1 - i];\n        array[length_of_number-1-i] = temp;\n    }\n}\n\nvoid run()\n{\n    reverse();\n    int step1 = 1,\n        step2 = 0,\n        i = 0,\n        zero = 0,\n        cnt = 0;\n    for (i = 0; i < length_of_number; i++)\n    {\n        if (step1)\n        {\n            if (array[i] == '0')\n            {\n                zero++;\n            }\n            else\n            {\n                array[i] = array[i] - 1;\n                if (zero > 0)\n                {\n                    array[cnt] = array[i];\n                    array[i] = '0';\n                }\n                step1 = 0, step2 = 1;\n            }\n        }\n        else if (step2)\n        {\n            if (array[i] == '9')\n            {\n                if (zero == 0)\n                {\n                    array[cnt + 1] = array[cnt];\n                    array[cnt] = '9';\n                    cnt++;\n                    if (i != cnt)\n                    {\n                        array[i] = array[i-1];\n                    }\n                }\n                else\n                {\n                    array[cnt + 1] = array[cnt];\n                    array[cnt] = '9';\n                    cnt++;\n                    array[i] = '0';\n                }\n            }\n            else\n            {\n                array[i] ++;\n                step2 = 0;\n                break;\n            }\n        }\n    }\n    if (step2)\n    {\n        array[length_of_number] = '1';\n        length_of_number ++;\n    }\n}\n\nvoid output()\n{\n    int i;\n    reverse();\n    for(i = 0; i < length_of_number; i++)\n    {\n        printf(\"%c\", array[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main()\n{\n    memset(array, 0, sizeof(array));\n    freopen(\"input\", \"r\", stdin);\n    get_array();\n    run();\n    output();\n    return 0;\n}\n测试结果\n使用python生成测试数据进行测试：\n\"\"\"\n最接近的数字\n\"\"\"\nimport random\nimport os\n\ndef test():\n    \"\"\"\n    sample test\n    \"\"\"\n    num = random.randint(0, 10000000)\n    sum_of_num = 0\n    for i in str(num):\n        sum_of_num += int(i)\n\n    length = len(str(num))\n    temp_num = num + 1\n\n    while(True):\n        sum_temp = 0\n        for i in str(temp_num):\n            sum_temp += int(i)\n        if sum_temp == sum_of_num:\n            break\n        temp_num += 1\n\n    with open('input', 'w') as f:\n        f.write(str(length) + '\\n')\n        f.write(str(num))\n\n    res = os.popen('./ex2').read()\n    if temp_num == int(res):\n        return [True]\n    else:\n        return [False, num, temp_num, int(res)]\n\n\nall = True\nfor i in range(1000):\n    res = test()\n    if res[0] is False:\n        all = False\n        print(res)\n\nif all:\n    print('Pass testing!')\n存在错误的情况：\n\n通过：\n\n后期改善优化的地方\n\nreverse 是为了编程方便进行的处理，但是如果数字太大，速度肯定会受影响，这个时候就不要使用reverse了。\n用链表来做可以简化代码，减少分析的，更加节省时间\n处理移位的时候考虑几个问题\n\n寻找发帖水王\n题目\n如果“水王”没有了，但有三个发帖很多的ID，发帖的数目都超过了帖子做数的1/4，又如何快速找出他们的ID。\n算法分析 算法思想\n从0-n扫描ID数组，记录3个数字的个数，如果出现第四个数字，就把三个数字的个数减少1，如果有一个数字的个数减少到0，那么把新来的数字作为原本三个数字之一进行记录。\n如此一来，扫描完ID数组之后，剩下记录的3个数字的个数便是需要求的三个数字。\n伪代码\narray = get_array()\ncount = empty_set()\nfor i in array:\n    if count.full:\n        if i in count:\n            count.i.num ++\n        else:\n            for j in count:\n                count.j.num--\n    else\n        count.add(i)\ndisp(count)\n分析时间复杂度O\n数列的大小为N，记录数字的数组大小为3，每次判断记录数组count是否存在0，以及找到已存在的数字++，都会花费3个单位时间，因此其时间复杂度为\n$$\nO(3n) \\approx O(n)\n$$\n源代码\n#include <stdio.h>\n#include <string.h>\n\n#define MAXN 5000\nint idarray[MAXN];\n\nint cur[3]; // 记录当前元素\nint pos[3]; // 记录当前元素个数\n\n// 检查是否在数组内，如果不在数组内，添加进入数组\nvoid checkin(int no)\n{\n    int i;\n\n    // 检查是否有空位置\n    for (i = 0; i < 3; i++)\n    {\n        if (pos[i] == 0)\n        {\n            cur[i] = no;\n            pos[i] ++;\n            return;\n        }\n    }\n\n    // 寻找指定数字++\n    for (i = 0; i < 3; i++)\n    {\n        if (cur[i] == no)\n        {\n            pos[i] ++;\n            return;\n        }\n    }\n\n    // 没有找到重复数字，全部--\n    for (i = 0; i < 3; i++)\n        pos[i] --;\n}\n\n// 输出最后结果\nvoid output()\n{\n    printf(\"%d %d %d\\n\", cur[0], cur[1], cur[2]);\n}\n\n// 主程序\nint numberOfArray;\nvoid run()\n{\n    int i;\n    for (i = 0; i < numberOfArray; i++)\n    {\n        checkin(idarray[i]);\n    }\n\n    output();\n}\n\nvoid input()\n{\n    int i;\n    scanf(\"%d\", &numberOfArray);\n    for(i = 0; i < numberOfArray; i++)\n    {\n        scanf(\"%d\", &idarray[i]);\n    }\n\n}\n\nint main()\n{\n    freopen(\"input\", \"r\", stdin);\n    int groupOfTest;\n    scanf(\"%d\", &groupOfTest);\n    while(groupOfTest--)\n    {\n        memset(cur, 0, sizeof(cur));\n        memset(pos, 0, sizeof(pos));\n        memset(idarray, 0, sizeof(idarray));\n        input();\n        puts(\"Test running...\");\n        run();\n    }\n    return 0;\n}\n\n测试结果\n本测试数据采用Python自动生成。\n\"\"\"\n寻找发帖水王\n\"\"\"\n\nimport random\n\nN = 4000\na, b = (int(N/4), int(N/3))\nthree_id = random.sample(range(1, 100), 3)\nthree_id_num = {}\nsum_rand = 0\nfor i in three_id:\n    temp = random.randint(a, b)\n    sum_rand += temp\n    three_id_num[i] = three_id_num.get(i, 0) + temp\n\nid_array = [random.randint(1, 100) for i in range(N-sum_rand)]\nfor i in three_id:\n    id_array = id_array + [i for j in range(three_id_num[i])]\n\nrandom.shuffle(id_array)\n\nprint('Most three id:', three_id)\nprint('Three id num: ', three_id_num)\nprint('Sum of three_id num: ', sum_rand)\nprint('---------------')\n# print(id_array)\n\nwith open('input', 'w') as f:\n    f.write('1\\n')\n    f.write(str(N) + '\\n')\n    for i in id_array:\n        f.write(str(i) + ' ')\n\n\n后期改善优化的地方\n\n对于N比较小的情况可以在内存中进行查找，但是一旦涉及到更大的数据，这个方法可能就没有那么简单了，不能在内部建立数组，需要一部分一部分的从磁盘中读数；\n如果需要查找的id数量变多，那么需要的临时保存的数列可能更大；\n这个实现没有使用STL中的map，如果使用map，还能进一步使得代码见解易懂，map使用hash来做内部实现，可以使得面对数据量更大的数据的时候，加快查找数据的速度。\n\n山西煤老板\n题目\n你是山西的一个煤老板，你在矿区开采了有3000吨煤需要运送到市场上去卖，从你的矿区到市场有1000公里，你手里有一列烧煤的火车，这个火车只能装1000吨煤，且能耗比较大——每一公里需要耗一吨煤。请问，作为一个懂编程的煤老板，你会怎么运送才能运最多的煤到集市？\n算法分析 算法思想\n从动态规划的角度求最优解：假设起始运送货物量为t，终点路程为s，火车容量为c，可以运抵终点的最多货物量为函数 F(t, s)。3种基本情况：（1）t < s：货物量不足以运送到此距离，所以F(t, s) = 0;（2）s < t < c：火车一次就可以装完货物，所以F(t, s) = t - s;（3）2s < c 使得火车一次无法运完，但可以采用往返的方式多次运输，这种情况下最有的方式就是减少总共往返的次数，也就是直接运到终点而不在中间卸货，所以\n$$\nF(t, s) = (t / c - 1) * (c - 2s) + (c - s)\n$$\n可得递归式：\n$$\nF(t, s) = max\\{ F( F(t, i), s - i)\\} (1 <= i < s)\n$$\n分析了一下这个方程是有问题的，比如F(1750, 250)会计算出1125；\n所以正确的结果应该对t/c进行处理，也就是说，起点剩余的燃料不足运输到终点，直接舍弃。第三阶段的方程式应该是\n$$\nF(t, s) = (t // c - 1) * (c - 2s) + (c - s) + (t \\% c - 2 s), if (t\\%c > 2s)\n$$\n伪代码\nbegin:\n    if t < s:\n        f[t][s] = 0\n    elif s < t < c:\n        f[t][s] = t - s\n    elif 2*s < c:\n        f[t][s] = int((t//c-1)*(c-2*s) + (c-s))\n        if t % c > 2*s:\n            f[t][s] += int(t % c-2*s)\n    else:\n        pre = -2\n        for i in range(1, s):\n            pre = int(max(F(F(t, i), s-i), pre))\n        f[t][s] = pre\nend\ndisp(f[3000][1000])\n分析时间复杂度O\n时间复杂度为\n$$\nO(3000*3000)\n$$\n因为每个数字都要计算一遍。\n源代码\n\"\"\"\n山西煤老板\n\"\"\"\nc = 1000\nf = [[-1 for k in range(4000)] for j in range(4000)]\nfor j in range(4000):\n    for k in range(4000):\n        if j < k:\n            f[j][k] = 0\ncount = 1000\ncnt = 0\n\n\ndef F(t, s):\n    \"\"\"\n    dp\n    \"\"\"\n    global count\n    global c\n    global f\n    # count -= 1\n    # if count == 0:\n        # count = int(input())\n\n    t = int(t)\n    s = int(s)\n    if f[t][s] != -1:\n        return f[t][s]\n    if t < s:\n        f[t][s] = 0\n    elif s < t < c:\n        f[t][s] = t - s\n    elif 2*s < c:\n        f[t][s] = int((t//c-1)*(c-2*s) + (c-s))\n        if t % c > 2*s:\n            f[t][s] += int(t % c-2*s)\n    else:\n        pre = -2\n        for i in range(1, s):\n            pre = int(max(F(F(t, i), s-i), pre))\n        f[t][s] = pre\n    print(t, s, f[t][s])\n    return f[t][s]\n\n\nprint(F(3000, 500))\n\n测试结果\n\n后期改善优化的地方\n\n去除了一下数据进行加速\n保存f减少重复运算值\n\n应该有更加简单的方法，类似这种，但是不好解释。\n\n\n$$\n3y=1000\\\\\n5x=1000\\\\\n解得x+y=200+333=533，因此使得最后一辆火车抵达时节省了533吨煤\\\\\n$$\n\nFacebook\n题目\nGiven a list of words, L, that are all the same length, and a string, S, find the starting position of the substring of S that is concatenation of each word in L exactly once and without intervening characters. This substring will occur exactly once in S.\n算法分析 算法思想\n使用hashmap来保存word的hash值，来加快查找速度。（旧）\n直接用hash函数求字符串的hash值，最后求得结果。\n依据公式\n$$\nhash(w_1) + hash(w_2) = hash(w_2) + hash(w_1)\n$$\n伪代码\nhash_word_list = list(map(hash, words))\nhash_sum = reduce(lambda x, y: x + y, hash_word_list)\n\nfor i in range(len(sentence)):\n    wl = word_len\n    wlist = [sentence[i+j*wl:i+j*wl+wl] for j in range(words_len)]\n    temp_sum = 0\n    for k in wlist:\n        temp_sum += hash(k)\n    if temp_sum == hash_sum:\n        print(i)\n        break\n分析时间复杂度O\n就是字符串长度\n$$\nO(lengthOfS)\n$$\n源代码\n#!/usr/bin/env python3\n\"\"\"\nfacebook\n\n\"\"\"\nfrom functools import reduce\n\nwhile True:\n    words = input()\n    # words = \"fooo barr wing ding wing\"\n    words = words.split(' ')\n    word_len = len(words[0])\n    words_len = len(words)\n\n    hash_word_list = list(map(hash, words))\n    hash_sum = reduce(lambda x, y: x + y, hash_word_list)\n\n    sentence = input()\n    # sentence = \"\"\"lingmindraboofooowingdin\\\n    # gbarrwingfooomonkeypoundcakewingdingbarrwingfooowing\"\"\"\n\n    # print(words, words_len, word_len, sentence)\n\n    for i in range(len(sentence)):\n        wl = word_len\n        wlist = [sentence[i+j*wl:i+j*wl+wl] for j in range(words_len)]\n        # print(wlist)\n        temp_sum = 0\n        for k in wlist:\n            temp_sum += hash(k)\n        if temp_sum == hash_sum:\n            print(i)\n            break\n测试结果\n测试数据生成意义不是很大，\n\n后期改善优化的地方\nhash尽管在速度上非常优秀，但是在准确度方面，如果出现hash冲突，那么值可能不准确。此时可以利用hashmap来解决这个问题，不过会多出重置hashmap的相关时间。\nFor n -m - problems\nProblemset\nAssume we have a sequence that contains N numbers of type long. And we know for sure that among this sequence each number does occur exactly n times except for the one number that occurs exactly m times (0 < m < n). How do we find that number with O(N) operations and O(1) additional memory?\nAlgorithm\n^ is the add operation without carry.默认one,two都是0, 即任何数字都不存在数字a第一次来的时候, one标记a存在, two不变数字a第二次来的时候, one标记a不存在, two标记a存在数字a第三次来的时候, one不变, two标记a不存在\n构造这样一种运算，通过异或将数据保存在one和two里面。\nPseudocode\ndef solve2(array):\n    one = 0, two = 0\n  for i in range(array):\n      one = (one ^ array[i]) & ~two\n    two = (two ^ array[i]) & ~one\n  return one, two\n\narray = input()\n_, res = solve2(array)\n### Source code\n#!/usr/bin/env python\n\ndef solve(array):\n   one, two = 0, 0\n   for i in array:\n       one = (one ^ i) & ~two\n       two = (two ^ i) & ~one\n   return one, two\n\n\nif __name__ == '__main__':\n   array = input()\n   array = array.split(' ')\n   array = list(map(lambda x: int(x), array))\n   # print(array)\n   _, res = solve(array)\n   print(res)\nTest\n#!/usr/bin/env python3\nimport random\n\ndef test():\n    \"\"\"\n    测试\n    \"\"\"\n    array = []\n    n, m = 3, 2\n    numberofNum = random.randint(100, 1000)\n\n    record = {}\n    for _ in range(numberofNum):\n        temp = random.randint(10, 10000)\n        while temp in record:\n            temp = random.randint(10, 10000)\n        record[temp] = 1\n        for _ in range(3):\n            array.append(temp)\n\n    temp = random.randint(10, 1000)\n    while temp in record:\n        temp = random.randint(10, 1000)\n\n    array.append(temp)\n    array.append(temp)\n\n    from run import solve\n    _, res = solve(array)\n    if res != temp:\n        print('ERROR')\n        print(array, temp)\n        input()\n    else:\n        print('Pass: res: ', res, 'temp:', temp)\n\nfor i in range(50):\n    test()\n\n\nUse python generate data to test.\n\nDiscussion and improve\n如果n不是3，那么需要构造更多的临时变量。\n很长的数组\n题目\n一个很长很长的short型数组A，将它分成m个长为L的子数组B1，B2，…，Bm，其中每个数组排序后都是递增的等差数列，求最大的L值。\n$$\n例如，A = \\{-1, 3, 6, 1, 8, 10\\} 可以分成B_1 = \\{-1, 1, 3\\},  B_2 = \\{6, 8, 10\\},\\; L = 3 即为所求。\n$$\n算法分析\n首先进行排序，然后开始分三步走。\n\n统计元素个数 O(n)\n\n排序 O(nlog(n))\n​\n\n\n第一步用来枚举L和m的大小，由题目可知，L * m = 数组的长度。从m为1开始枚举，保证得到的L为最大值。\n第二步搜索为深搜，确定当前子数组的起点和初始步长，使用pos记录当前数组选定的元素。\n第三步枚举，根据起点给定的初始步长，开始枚举步长，如果枚举的步长可以在数组中找到足够的元素，即数字为L，那么记录这种分法，开始枚举下一个起点。如果枚举的步长和起点无法满足条件，回溯到上一个节点，把上一个节点记录的步长+1再一次搜索。当枚举的起点数达到m，即满足要求输出。\n大白话来讲，就是从头开始分原始数组到m个数组中去，排序过后，在前面的每一个节点未被分配的元素，都是子数组起点。如果使用广度优先搜索，即每次都给一个子数组分配一个满足子数组步长要求的数，会导致在最后才发现分配的元素数不满足要求，从而浪费大量时间。\n\n其中，深度优先搜索还有几个剪枝的技巧：\n\n当前步长*(L-1)如果超过了数组的最大元素，可以不继续搜索\n\n如果在给定步长的情况下， 下一个数字的大小超过之前的数字+步长，那么可以不必继续搜索。\n因为数组已经排好序。\n\n还有其他的剪枝技巧，体现在代码中了。\n\n时间复杂度\nn为数组长度，排序的时间为 O(nlogn)，枚举m时间为n，枚举step时间为65536【short跨度】，枚举全部元素时间为n，因此算法的时间上界为\n$$\nO(65536n^2)\n$$\n实际情况下，由于剪枝等操作的存在，应优于这个时间。\n伪代码\nleng = len(Array)\nfor m=1 to n:\n    if n % m != 0:\n        continue\n    L = n // m\n    # deep search\n    res, record = findArray(L, m)\n\ndef findArray(L, m):\n    group = 0\n    pos = np.ones(leng)\n    record = []\n    record_start = []\n    while group != m:\n        step = 0\n        start = getStart(pos)\n        res, step = 寻找合适的步长(start, step, pos, record, L)\n        if res:\n            找到了计数\n        while res is False:\n            没找到弹出栈，往回找\n        if 弹出栈为空:\n            不用找了找不到了\n   return False, None\n源代码\n#!/usr/bin/env python3\n# coding: utf-8\n\"\"\"\narrays\n\"\"\"\n\nfrom __future__ import print_function\nimport numpy as np\n\narray = [-1, 3, 6, 1, 8, 10]\n# array = [1, 5, 9, 2, 6, 10]\n# array = [1, 2, 4, 5, 8, 9, 13, 14]\n# array = [1, 2, 4, 7, 11]\narray = sorted(array)\nprint(array)\nleng = len(array)\nmaxn = array[leng-1]\nenable = 1\ndisable = 0\n\n\ndef findJ(j, step, pos, record, L):\n    \"\"\"\n    寻找以J为开始，以步长step为开始的数列\n    \"\"\"\n    class StepError(Exception):\n        pass\n\n    class MaxException(Exception):\n        pass\n\n    if pos[j] == disable:\n        return False\n    start = array[j]\n    pre = start\n    record_temp = []\n\n    # remember zero\n    try:\n        for step in range(step, 40000):\n            # 把第一个数字记录\n            record_temp.append(j)\n            pos[j] = disable\n            pre = start\n\n            if start + step * (L - 1) > maxn:\n                raise MaxException\n\n            try:\n                cnt = 1\n                if cnt == L:\n                    record.append(record_temp)\n                    return True, step\n\n                for k in range(j, leng):\n\n                    if pos[k] == disable:\n                        continue\n                    elif pos[k] == enable and array[k] == pre + step:\n                        record_temp.append(k)\n                        pre = array[k]\n                        cnt += 1\n                        pos[k] = disable\n                    elif pos[k] == enable and array[k] > pre + step:\n                        raise StepError\n\n                    if cnt == L:\n                        record.append(record_temp)\n                        return True, step\n\n            except StepError:\n                # 重置标记\n                for r in record_temp:\n                    pos[r] = enable\n                record_temp = []\n\n    except MaxException:\n        # 没有合适的step\n        return False, None\n\n\ndef findArray(L, m):\n    \"\"\"\n    寻找数组\n    \"\"\"\n\n    pos = np.ones(leng)\n    record = []\n    record_start = []\n    group = 0\n\n    while group != m:\n        start = 0\n        while pos[start] == disable:\n            start += 1\n\n        step = 0\n        res, step = findJ(start, step, pos, record, L)\n        if res:\n            group += 1\n            record_start.append((start, step))\n        while res is False:\n            try:\n                start, step = record_start.pop()\n                for r in record.pop():\n                    pos[r] = enable\n                group -= 1\n                res, step = findJ(start, step+1, pos, record, L)\n            except IndexError:\n                return False, None\n    return True, record\n\n\ndef divideArray():\n    \"\"\"\n    分离数组\n    m 是分离的数组的个数\n    L 是分离的数组的长度\n    \"\"\"\n    for m in range(1, leng+1):\n        if leng % m != 0:\n            continue\n\n        L = leng // m\n        res, record = findArray(L, m)\n\n        def trans(x):\n            return array[x]\n\n        if res:\n            print('lenth: ', L)\n            for r in record:\n                temp = map(trans, r)\n                print(list(temp))\n            return\n\n    print('No result.')\n\n\nif __name__ == '__main__':\n    divideArray()\n测试\n测试样例生成结果未必准确，找了部分的测试样例，可以通过修改代码中array来提现。\n\n讨论\n在记录了起点和步长，应该可以利用这两点推出当前使用了哪些元素，如果空间大小不够使用，可以不适用record记录，如果下一层不满足条件回溯的时候，可以利用起点和步长回推已经使用的元素。\n\n                ", "mainLikeNum": ["7 "], "mainBookmarkNum": "28"}