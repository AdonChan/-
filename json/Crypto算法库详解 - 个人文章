{"title": "Crypto算法库详解 - 个人文章 ", "index": "密码学,crypto,python", "content": "安装与使用\nCrypto 算法库在 python 中最初叫 pycrypto，这个作者有点懒，好几年没有更新，后来就有大佬写了个替代库 pycryptodome。这个库目前只支持 python3，安装也很简单pip install pycryptodome就行了！详细的用法可以看看 官方文档\n常见对称密码在 Crypto.Cipher 库下，主要有：DES 3DES AES RC4 Salsa20非对称密码在 Crypto.PublicKey 库下，主要有：RSA ECC DSA哈希密码在 Crypto.Hash 库下，常用的有：MD5 SHA-1 SHA-128 SHA-256随机数在 Crypto.Random 库下实用小工具在 Crypto.Util 库下数字签名在 Crypto.Signature 库下\n对称密码AES\n注意：python3 和 python2 在字符串方面有个明显的区别 - python3 中有字节串 b'byte'，python2 中没有字节。由于这个库是在 python3 下的，所以加解密用的都是字节！\n使用这个库来加解密特别简单，记住这四步：\n导入所需库\nfrom Crypto.Cipher import AES\n初始化 key\nkey = b'this_is_a_key'\n实例化加解密对象\naes = AES.new(key,AES.MODE_ECB)\n使用实例加解密\ntext_enc = aes.encrypt(b'helloworld')\nfrom Crypto.Cipher import AES\nimport base64\n\nkey = bytes('this_is_a_key'.ljust(16,' '),encoding='utf8')\naes = AES.new(key,AES.MODE_ECB)\n\n# encrypt\nplain_text = bytes('this_is_a_plain'.ljust(16,' '),encoding='utf8')\ntext_enc = aes.encrypt(plain_text)\ntext_enc_b64 = base64.b64encode(text_enc)\nprint(text_enc_b64.decode(encoding='utf8'))\n\n# decrypt\nmsg_enc = base64.b64decode(text_enc_b64)\nmsg = aes.decrypt(msg_enc)\nprint(msg.decode(encoding='utf8'))\n注意：key和明文是需要填充到指定位数的，可以使用ljust或者zfill之类的填充，也可以用Util中的pad()函数填充！\n对称密码DES\nfrom Crypto.Cipher import DES\nimport base64\n\nkey = bytes('test_key'.ljust(8,' '),encoding='utf8')\ndes = DES.new(key,DES.MODE_ECB)\n\n# encrypt\nplain_text = bytes('this_is_a_plain'.ljust(16,' '),encoding='utf8')\ntext_enc = des.encrypt(plain_text)\ntext_enc_b64 = base64.b64encode(text_enc)\nprint(text_enc_b64.decode(encoding='utf8'))\n\n# decrypt\nmsg_enc = base64.b64decode(text_enc_b64)\nmsg = des.decrypt(msg_enc)\nprint(msg.decode(encoding='utf8'))\n非对称密码RSA\n这个库的 RSA 主要是用来生成公钥文件/私钥文件或者读取公钥文件/私钥文件生成公/私钥文件：\nfrom Crypto.PublicKey import RSA\n\nrsa = RSA.generate(2048) # 返回的是密钥对象\n\npublic_pem = rsa.publickey().exportKey('PEM') # 生成公钥字节流\nprivate_pem = rsa.exportKey('PEM') # 生成私钥字节流\n\nf = open('public.pem','wb')\nf.write(public_pem) # 将字节流写入文件\nf.close()\nf = open('private.pem','wb')\nf.write(private_pem) # 将字节流写入文件\nf.close()\n#\n-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArreg3IX19DbszqSdBKhR\n9cm495XAk9PBQJwHiwjKv6S1Tk5h7xL9/fPZIITy1M1k8LwuoSJPac/zcK6rYgMb\nDT9tmVLbi6CdWNl5agvUE2WgsB/eifEcfnZ9KiT9xTrpmj5BJql9H+znseA1AzlP\niTukrH1frD3SzZIVnq/pBly3QbsT13UdUhbmIgeqTo8wL9V0Sj+sMFOIZY+xHscK\nIeDOv4/JIxw0q2TMTsE3HRgAX9CXvk6u9zJCH3EEzl0w9EQr8TT7ql3GJg2hJ9SD\nbiebjImLuUii7Nv20qLOpIJ8qR6O531kmQ1gykiSfqj6AHqxkufxTHklCsHj9B8F\n8QIDAQAB\n-----END PUBLIC KEY-----\n\n-----BEGIN RSA PRIVATE KEY-----\nMIIEowIBAAKCAQEArreg3IX19DbszqSdBKhR9cm495XAk9PBQJwHiwjKv6S1Tk5h\n7xL9/fPZIITy1M1k8LwuoSJPac/zcK6rYgMbDT9tmVLbi6CdWNl5agvUE2WgsB/e\nifEcfnZ9KiT9xTrpmj5BJql9H+znseA1AzlPiTukrH1frD3SzZIVnq/pBly3QbsT\n13UdUhbmIgeqTo8wL9V0Sj+sMFOIZY+xHscKIeDOv4/JIxw0q2TMTsE3HRgAX9CX\nvk6u9zJCH3EEzl0w9EQr8TT7ql3GJg2hJ9SDbiebjImLuUii7Nv20qLOpIJ8qR6O\n531kmQ1gykiSfqj6AHqxkufxTHklCsHj9B8F8QIDAQABAoI...\n-----END RSA PRIVATE KEY-----\n读取公/私钥文件加解密：\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Cipher import PKCS1_v1_5\nimport base64\n\ndef rsa_encrypt(plain):\n    with open('public.pem','rb') as f:\n        data = f.read()\n        key = RSA.importKey(data)\n        rsa = PKCS1_v1_5.new(key)\n        cipher = rsa.encrypt(plain)\n        return base64.b64encode(cipher)\n\ndef rsa_decrypt(cipher):\n    with open('private.pem','rb') as f:\n        data = f.read()\n        key = RSA.importKey(data)\n        rsa = PKCS1_v1_5.new(key)\n        plain = rsa.decrypt(base64.b64decode(cipher),'ERROR') # 'ERROR'必需\n        return plain\n\nif __name__ == '__main__':\n    plain_text = b'This_is_a_test_string!'\n    cipher = rsa_encrypt(plain_text)\n    print(cipher)\n    plain = rsa_decrypt(cipher)\n    print(plain)\n注意：RSA 有两种填充方式，一种是 PKCS1_v1_5，另一种是 PKCS1_OAEP\nHash算法\n和 hashlib 库的用法类似，先实例化某个 Hash 算法，再用 update() 调用就可以了！\n具体栗子：\nfrom Crypto.Hash import SHA1,MD5\n\nsha1 = SHA1.new()\nsha1.update(b'sha1_test')\nprint(sha1.digest()) # 返回字节串\nprint(sha1.hexdigest()) # 返回16进制字符串\nmd5 = MD5.new()\nmd5.update(b'md5_test')\nprint(md5.hexdigest())\n数字签名\n发送发用私钥签名，验证方用公钥验证\nfrom Crypto.Signature import pkcs1_15\nfrom Crypto.Hash import SHA256\nfrom Crypto.PublicKey import RSA\n\n# 签名\nmessage = 'To be signed'\nkey = RSA.import_key(open('private_key.der').read())\nh = SHA256.new(message)\nsignature = pkcs1_15.new(key).sign(h)\n\n# 验证\nkey = RSA.import_key(open('public_key.der').read())\nh = SHA.new(message)\ntry:\n    pkcs1_15.new(key).verify(h, signature):\n    print \"The signature is valid.\"\n    except (ValueError, TypeError):\n        print \"The signature is not valid.\"\n随机数\n和 random 库类似。第一个函数很常用\nimport Crypto.Random\nimport Crypto.Random.random\n\nprint(Crypto.Random.get_random_bytes(4)) # 得到n字节的随机字节串\nprint(Crypto.Random.random.randrange(1,10,1)) # x到y之间的整数，可以给定step\nprint(Crypto.Random.random.randint(1,10)) # x到y之间的整数\nprint(Crypto.Random.random.getrandbits(16)) # 返回一个最大为N bit的随机整数\n其它功能\n常用到 Util 中的pad()函数来填充密钥\nfrom Crypto.Util.number import *\nfrom Crypto.Util.Padding import *\n\n# 按照规定的几种类型 pad，自定义 pad可以用 ljust()或者 zfill()\nstr1 = b'helloworld'\npad_str1 = pad(str1,16,'pkcs7') # 填充类型默认为'pkcs7'，还有'iso7816'和'x923'\nprint(unpad(pad_str1,16))\n# number\nprint(GCD(11,143)) # 最大公约数\nprint(bytes_to_long(b'hello')) # 字节转整数\nprint(long_to_bytes(0x41424344)) # 整数转字节\nprint(getPrime(16)) # 返回一个最大为 N bit 的随机素数\nprint(getStrongPrime(512)) # 返回强素数\nprint(inverse(10,5)) # 求逆元\nprint(isPrime(1227)) # 判断是不是素数\nEND\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}