{"title": "Python函数式编程进阶 - ziwenxie ", "index": "python", "content": "引言\nfunctools, itertools, operator是Python标准库为我们提供的支持函数式编程的三大模块，合理的使用这三个模块，我们可以写出更加简洁可读的Pythonic代码，接下来我们通过一些example来了解三大模块的使用。\nfunctools的使用\nfunctools是Python中很重要的模块，它提供了一些非常有用的高阶函数。高阶函数就是说一个可以接受函数作为参数或者以函数作为返回值的函数，因为Python中函数也是对象，因此很容易支持这样的函数式特性。\npartial\n>>> from functools import partial\n\n>>> basetwo = partial(int, base=2)\n\n>>> basetwo('10010')\n18\nbasetwo('10010')实际上等价于调用int('10010', base=2)，当函数的参数个数太多的时候，可以通过使用functools.partial来创建一个新的函数来简化逻辑从而增强代码的可读性，而partial内部实际上就是通过一个简单的闭包来实现的。\ndef partial(func, *args, **keywords):\n    def newfunc(*fargs, **fkeywords):\n        newkeywords = keywords.copy()\n        newkeywords.update(fkeywords)\n        return func(*args, *fargs, **newkeywords)\n    newfunc.func = func\n    newfunc.args = args\n    newfunc.keywords = keywords\n    return newfunc\npartialmethod\npartialmethod和partial类似，但是对于绑定一个非对象自身的方法的时候，这个时候就只能使用partialmethod了，我们通过下面这个例子来看一下两者的差异。\nfrom functools import partial, partialmethod\n\n\ndef standalone(self, a=1, b=2):\n    \"Standalone function\"\n    print('  called standalone with:', (self, a, b))\n    if self is not None:\n        print('  self.attr =', self.attr)\n\n\nclass MyClass:\n    \"Demonstration class for functools\"\n    def __init__(self):\n        self.attr = 'instance attribute'\n    method1 = functools.partialmethod(standalone)  # 使用partialmethod\n    method2 = functools.partial(standalone)  # 使用partial\n>>> o = MyClass()\n\n>>> o.method1()\n  called standalone with: (<__main__.MyClass object at 0x7f46d40cc550>, 1, 2)\n  self.attr = instance attribute\n\n# 不能使用partial\n>>> o.method2()\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: standalone() missing 1 required positional argument: 'self'\n\nsingledispatch\n虽然Python不支持同名方法允许有不同的参数类型，但是我们可以借用singledispatch来动态指定相应的方法所接收的参数类型，而不用把参数判断放到方法内部去判断从而降低代码的可读性。\nfrom functools import singledispatch\n\n\nclass TestClass(object):\n    @singledispatch\n    def test_method(arg, verbose=False):\n        if verbose:\n            print(\"Let me just say,\", end=\" \")\n        print(arg)\n\n    @test_method.register(int)\n    def _(arg):\n        print(\"Strength in numbers, eh?\", end=\" \")\n        print(arg)\n\n    @test_method.register(list)\n    def _(arg):\n        print(\"Enumerate this:\")\n\n        for i, elem in enumerate(arg):\n            print(i, elem)\n下面通过@test_method.register(int)和@test_method.register(list)指定当test_method的第一个参数为int或者list的时候，分别调用不同的方法来进行处理。\n>>> TestClass.test_method(55555)  # call @test_method.register(int)\nStrength in numbers, eh? 55555\n\n>>> TestClass.test_method([33, 22, 11])   # call @test_method.register(list)\nEnumerate this:\n0 33\n1 22\n2 11\n\n>>> TestClass.test_method('hello world', verbose=True)  # call default\nLet me just say, hello world\nwraps\n装饰器会遗失被装饰函数的__name__和__doc__等属性，可以使用@wraps来恢复。\nfrom functools import wraps\n\n\ndef my_decorator(f):\n    @wraps(f)\n    def wrapper():\n        \"\"\"wrapper_doc\"\"\"\n        print('Calling decorated function')\n        return f()\n    return wrapper\n\n\n@my_decorator\ndef example():\n    \"\"\"example_doc\"\"\"\n    print('Called example function')\n>>> example.__name__\n'example'\n>>> example.__doc__\n'example_doc'\n\n# 尝试去掉@wraps(f)来看一下运行结果，example自身的__name__和__doc__都已经丧失了\n>>> example.__name__\n'wrapper'\n>>> example.__doc__\n'wrapper_doc'\n我们也可以使用update_wrapper来改写\nfrom itertools import update_wrapper\n\n\ndef g():\n    ...\ng = update_wrapper(g, f)\n\n\n# equal to\n@wraps(f)\ndef g():\n    ...\n@wraps内部实际上就是基于update_wrapper来实现的。\ndef wraps(wrapped, assigned=WRAPPER_ASSIGNMENTS, updated=WRAPPER_UPDATES):\n    def decorator(wrapper):\n        return update_wrapper(wrapper, wrapped=wrapped...)\n    return decorator\nlru_cache\nlru_cache和singledispatch是开发中应用非常广泛的黑魔法，接下来我们来看一下lru_cache。对于重复的计算性任务，使用缓存加速是非常重要的，下面我们通过一个fibonacci的例子来看一下使用lru_cache与不使用lru_cache在速度上的差异。\n# clockdeco.py\n\nimport time\nimport functools\n\n\ndef clock(func):\n    @functools.wraps(func)\n    def clocked(*args, **kwargs):\n        t0 = time.time()\n        result = func(*args, **kwargs)\n        elapsed = time.time() - t0\n        name = func.__name__\n        arg_lst = []\n        if args:\n            arg_lst.append(', '.join(repr(arg) for arg in args))\n        if kwargs:\n            pairs = ['%s=%r' % (k, w) for k, w in sorted(kwargs.items())]\n            arg_lst.append(', '.join(pairs))\n        arg_str = ', '.join(arg_lst)\n        print('[%0.8fs] %s(%s) -> %r ' % (elapsed, name, arg_str, result))\n        return result\n    return clocked\n不使用lru_cache\nfrom clockdeco import clock\n\n\n@clock\ndef fibonacci(n):\n    if n < 2:\n        return n\n    return fibonacci(n-2) + fibonacci(n-1)\n\n\nif __name__=='__main__':\n    print(fibonacci(6))\n下面是运行结果，从运行结果可以看出fibonacci(n)会在递归的时候被重复计算，这是非常耗时消费资源的。\n[0.00000119s] fibonacci(0) -> 0 \n[0.00000143s] fibonacci(1) -> 1 \n[0.00021172s] fibonacci(2) -> 1 \n[0.00000072s] fibonacci(1) -> 1 \n[0.00000095s] fibonacci(0) -> 0 \n[0.00000095s] fibonacci(1) -> 1 \n[0.00011444s] fibonacci(2) -> 1 \n[0.00022793s] fibonacci(3) -> 2 \n[0.00055265s] fibonacci(4) -> 3 \n[0.00000072s] fibonacci(1) -> 1 \n[0.00000072s] fibonacci(0) -> 0 \n[0.00000095s] fibonacci(1) -> 1 \n[0.00011158s] fibonacci(2) -> 1 \n[0.00022268s] fibonacci(3) -> 2 \n[0.00000095s] fibonacci(0) -> 0 \n[0.00000095s] fibonacci(1) -> 1 \n[0.00011349s] fibonacci(2) -> 1 \n[0.00000072s] fibonacci(1) -> 1 \n[0.00000095s] fibonacci(0) -> 0 \n[0.00000095s] fibonacci(1) -> 1 \n[0.00010705s] fibonacci(2) -> 1 \n[0.00021267s] fibonacci(3) -> 2 \n[0.00043225s] fibonacci(4) -> 3 \n[0.00076509s] fibonacci(5) -> 5 \n[0.00142813s] fibonacci(6) -> 8 \n8\n使用lru_cache\nimport functools\nfrom clockdeco import clock\n\n\n@functools.lru_cache() # 1\n@clock # 2\ndef fibonacci(n):\n    if n < 2:\n       return n\n    return fibonacci(n-2) + fibonacci(n-1)\n\nif __name__=='__main__':\n    print(fibonacci(6))\n下面是运行结果，对于已经计算出来的结果将其放入缓存。\n[0.00000095s] fibonacci(0) -> 0 \n[0.00005770s] fibonacci(1) -> 1 \n[0.00015855s] fibonacci(2) -> 1 \n[0.00000286s] fibonacci(3) -> 2 \n[0.00021124s] fibonacci(4) -> 3 \n[0.00000191s] fibonacci(5) -> 5 \n[0.00024652s] fibonacci(6) -> 8 \n8\n上面我们选用的数字还不够大，感兴趣的朋友不妨自己选择一个较大的数字比较一下两者在速度上的差异\ntotal_ordering\nPython2中可以通过自定义__cmp__的返回值0/-1/1来比较对象的大小，在Python3中废弃了__cmp__，但是我们可以通过total_ordering然后修改 __lt__() , __le__() , __gt__(), __ge__(), __eq__(), __ne__() 等魔术方法来自定义类的比较规则。p.s: 如果使用必须在类里面定义 __lt__() , __le__() , __gt__(), __ge__()中的一个，以及给类添加一个__eq__() 方法。\nimport functools\n\n\n@functools.total_ordering\nclass MyObject:\n    def __init__(self, val):\n        self.val = val\n\n    def __eq__(self, other):\n        print('  testing __eq__({}, {})'.format(\n            self.val, other.val))\n        return self.val == other.val\n\n    def __gt__(self, other):\n        print('  testing __gt__({}, {})'.format(\n            self.val, other.val))\n        return self.val > other.val\n\n\na = MyObject(1)\nb = MyObject(2)\n\nfor expr in ['a < b', 'a <= b', 'a == b', 'a >= b', 'a > b']:\n    print('\\n{:<6}:'.format(expr))\n    result = eval(expr)\n    print('  result of {}: {}'.format(expr, result))\n下面是运行结果：\na < b :\n  testing __gt__(1, 2)\n  testing __eq__(1, 2)\n  result of a < b: True\n\na <= b:\n  testing __gt__(1, 2)\n  result of a <= b: True\n\na == b:\n  testing __eq__(1, 2)\n  result of a == b: False\n\na >= b:\n  testing __gt__(1, 2)\n  testing __eq__(1, 2)\n  result of a >= b: False\n\na > b :\n  testing __gt__(1, 2)\n  result of a > b: False\nitertools的使用\nitertools为我们提供了非常有用的用于操作迭代对象的函数。\n无限迭代器\ncount\ncount(start=0, step=1) 会返回一个无限的整数iterator，每次增加1。可以选择提供起始编号，默认为0。\n>>> from itertools import count\n\n>>> for i in zip(count(1), ['a', 'b', 'c']):\n...     print(i, end=' ')\n...\n(1, 'a') (2, 'b') (3, 'c')\ncycle\ncycle(iterable) 会把传入的一个序列无限重复下去，不过可以提供第二个参数就可以制定重复次数。\n>>> from itertools import cycle\n\n>>> for i in zip(range(6), cycle(['a', 'b', 'c'])):\n...     print(i, end=' ')\n...\n(0, 'a') (1, 'b') (2, 'c') (3, 'a') (4, 'b') (5, 'c')\nrepeat\nrepeat(object[, times]) 返回一个元素无限重复下去的iterator，可以提供第二个参数就可以限定重复次数。\n>>> from itertools import repeat\n\n>>> for i, s in zip(count(1), repeat('over-and-over', 5)):\n...     print(i, s)\n...\n1 over-and-over\n2 over-and-over\n3 over-and-over\n4 over-and-over\n5 over-and-over\nIterators terminating on the shortest input sequence\naccumulate\naccumulate(iterable[, func])\n>>> from itertools import accumulate\n>>> import operator\n\n>>> list(accumulate([1, 2, 3, 4, 5], operator.add))\n[1, 3, 6, 10, 15]\n\n>>> list(accumulate([1, 2, 3, 4, 5], operator.mul))\n[1, 2, 6, 24, 120]\nchain\nitertools.chain(*iterables)可以将多个iterable组合成一个iterator\n>>> from itertools import chain\n\n>>> list(chain([1, 2, 3], ['a', 'b', 'c']))\n[1, 2, 3, 'a', 'b', 'c']\nchain的实现原理如下\ndef chain(*iterables):\n    # chain('ABC', 'DEF') --> A B C D E F\n    for it in iterables:\n        for element in it:\n            yield element\nchain.from_iterable\nchain.from_iterable(iterable)和chain类似，但是只是接收单个iterable，然后将这个iterable中的元素组合成一个iterator。\n>>> from itertools import chain\n\n>>> list(chain.from_iterable(['ABC', 'DEF']))\n['A', 'B', 'C', 'D', 'E', 'F']\n实现原理也和chain类似\ndef from_iterable(iterables):\n    # chain.from_iterable(['ABC', 'DEF']) --> A B C D E F\n    for it in iterables:\n        for element in it:\n            yield element\ncompress\ncompress(data, selectors)接收两个iterable作为参数，只返回selectors中对应的元素为True的data，当data/selectors之一用尽时停止。\n>>> list(compress([1, 2, 3, 4, 5], [True, True, False, False, True]))\n[1, 2, 5]\nzip_longest\nzip_longest(*iterables, fillvalue=None)和zip类似，但是zip的缺陷是iterable中的某一个元素被遍历完，整个遍历都会停止，具体差异请看下面这个例子\nfrom itertools import zip_longest\n\nr1 = range(3)\nr2 = range(2)\n\nprint('zip stops early:')\nprint(list(zip(r1, r2)))\n\nr1 = range(3)\nr2 = range(2)\n\nprint('\\nzip_longest processes all of the values:')\nprint(list(zip_longest(r1, r2)))\n下面是输出结果\nzip stops early:\n[(0, 0), (1, 1)]\n\nzip_longest processes all of the values:\n[(0, 0), (1, 1), (2, None)]\nislice\nislice(iterable, stop) or islice(iterable, start, stop[, step]) 与Python的字符串和列表切片有一些类似，只是不能对start、start和step使用负值。\n>>> from itertools import islice\n\n>>> for i in islice(range(100), 0, 100, 10):\n...     print(i, end=' ')\n...\n0 10 20 30 40 50 60 70 80 90\n\ntee\ntee(iterable, n=2) 返回n个独立的iterator，n默认为2。\nfrom itertools import islice, tee\n\nr = islice(count(), 5)\ni1, i2 = tee(r)\n\nprint('i1:', list(i1))\nprint('i2:', list(i2))\n\nfor i in r:\n    print(i, end=' ')\n    if i > 1:\n        break\n下面是输出结果，注意tee(r)后，r作为iterator已经失效，所以for循环没有输出值。\ni1: [0, 1, 2, 3, 4]\ni2: [0, 1, 2, 3, 4]\nstarmap\nstarmap(func, iterable)假设iterable将返回一个元组流，并使用这些元组作为参数调用func：\n>>> from itertools import starmap\n>>> import os\n\n>>> iterator = starmap(os.path.join,\n...                    [('/bin', 'python'), ('/usr', 'bin', 'java'),\n...                    ('/usr', 'bin', 'perl'), ('/usr', 'bin', 'ruby')])\n\n>>> list(iterator)\n['/bin/python', '/usr/bin/java', '/usr/bin/perl', '/usr/bin/ruby']\nfilterfalse\nfilterfalse(predicate, iterable) 与filter()相反，返回所有predicate返回False的元素。\nitertools.filterfalse(is_even, itertools.count()) =>\n1, 3, 5, 7, 9, 11, 13, 15, ...\ntakewhile\ntakewhile(predicate, iterable) 只要predicate返回True，不停地返回iterable中的元素。一旦predicate返回False，iteration将结束。\ndef less_than_10(x):\n    return x < 10\n\nitertools.takewhile(less_than_10, itertools.count())\n=> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n\nitertools.takewhile(is_even, itertools.count())\n=> 0\ndropwhile\ndropwhile(predicate, iterable) 在predicate返回True时舍弃元素，然后返回其余迭代结果。\nitertools.dropwhile(less_than_10, itertools.count())\n=> 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, ...\n\nitertools.dropwhile(is_even, itertools.count())\n=> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...\ngroupby\ngroupby(iterable, key=None) 把iterator中相邻的重复元素挑出来放在一起。p.s: The input sequence needs to be sorted on the key value in order for the groupings to work out as expected.\n\n[k for k, g in groupby('AAAABBBCCDAABBB')] --> A B C D A B\n[list(g) for k, g in groupby('AAAABBBCCD')] --> AAAA BBB CC D\n\n>>> import itertools\n\n>>> for key, group in itertools.groupby('AAAABBBCCDAABBB'):\n...     print(key, list(group))\n...\nA ['A', 'A', 'A', 'A']\nB ['B', 'B', 'B']\nC ['C', 'C']\nD ['D']\nA ['A', 'A']\nB ['B', 'B', 'B']\ncity_list = [('Decatur', 'AL'), ('Huntsville', 'AL'), ('Selma', 'AL'),\n             ('Anchorage', 'AK'), ('Nome', 'AK'),\n             ('Flagstaff', 'AZ'), ('Phoenix', 'AZ'), ('Tucson', 'AZ'),\n             ...\n            ]\n\ndef get_state(city_state):\n    return city_state[1]\n\nitertools.groupby(city_list, get_state) =>\n  ('AL', iterator-1),\n  ('AK', iterator-2),\n  ('AZ', iterator-3), ...\n\niterator-1 =>  ('Decatur', 'AL'), ('Huntsville', 'AL'), ('Selma', 'AL')\niterator-2 => ('Anchorage', 'AK'), ('Nome', 'AK')\niterator-3 => ('Flagstaff', 'AZ'), ('Phoenix', 'AZ'), ('Tucson', 'AZ')\nCombinatoric generators\nproduct\nproduct(*iterables, repeat=1)\n\nproduct(A, B) returns the same as ((x,y) for x in A for y in B)\nproduct(A, repeat=4) means the same as product(A, A, A, A)\n\nfrom itertools import product\n\n\ndef show(iterable):\n    for i, item in enumerate(iterable, 1):\n        print(item, end=' ')\n        if (i % 3) == 0:\n            print()\n    print()\n\n\nprint('Repeat 2:\\n')\nshow(product(range(3), repeat=2))\n\nprint('Repeat 3:\\n')\nshow(product(range(3), repeat=3))\nRepeat 2:\n\n(0, 0) (0, 1) (0, 2)\n(1, 0) (1, 1) (1, 2)\n(2, 0) (2, 1) (2, 2)\n\nRepeat 3:\n\n(0, 0, 0) (0, 0, 1) (0, 0, 2)\n(0, 1, 0) (0, 1, 1) (0, 1, 2)\n(0, 2, 0) (0, 2, 1) (0, 2, 2)\n(1, 0, 0) (1, 0, 1) (1, 0, 2)\n(1, 1, 0) (1, 1, 1) (1, 1, 2)\n(1, 2, 0) (1, 2, 1) (1, 2, 2)\n(2, 0, 0) (2, 0, 1) (2, 0, 2)\n(2, 1, 0) (2, 1, 1) (2, 1, 2)\n(2, 2, 0) (2, 2, 1) (2, 2, 2)\npermutations\npermutations(iterable, r=None)返回长度为r的所有可能的组合。\nfrom itertools import permutations\n\n\ndef show(iterable):\n    first = None\n    for i, item in enumerate(iterable, 1):\n        if first != item[0]:\n            if first is not None:\n                print()\n            first = item[0]\n        print(''.join(item), end=' ')\n    print()\n\n\nprint('All permutations:\\n')\nshow(permutations('abcd'))\n\nprint('\\nPairs:\\n')\nshow(permutations('abcd', r=2))\n下面是输出结果\nAll permutations:\n\nabcd abdc acbd acdb adbc adcb\nbacd badc bcad bcda bdac bdca\ncabd cadb cbad cbda cdab cdba\ndabc dacb dbac dbca dcab dcba\n\nPairs:\n\nab ac ad\nba bc bd\nca cb cd\nda db dc\ncombinations\ncombinations(iterable, r) 返回一个iterator，提供iterable中所有元素可能组合的r元组。每个元组中的元素保持与iterable返回的顺序相同。下面的实例中，不同于上面的permutations，a总是在bcd之前，b总是在cd之前，c总是在d之前。\nfrom itertools import combinations\n\n\ndef show(iterable):\n    first = None\n    for i, item in enumerate(iterable, 1):\n        if first != item[0]:\n            if first is not None:\n                print()\n            first = item[0]\n        print(''.join(item), end=' ')\n    print()\n\n\nprint('Unique pairs:\\n')\nshow(combinations('abcd', r=2))\n下面是输出结果\nUnique pairs:\n\nab ac ad\nbc bd\ncd\ncombinations_with_replacement\ncombinations_with_replacement(iterable, r)函数放宽了一个不同的约束：元素可以在单个元组中重复，即可以出现aa/bb/cc/dd等组合。\nfrom itertools import combinations_with_replacement\n\n\ndef show(iterable):\n    first = None\n    for i, item in enumerate(iterable, 1):\n        if first != item[0]:\n            if first is not None:\n                print()\n            first = item[0]\n        print(''.join(item), end=' ')\n    print()\n\n\nprint('Unique pairs:\\n')\nshow(combinations_with_replacement('abcd', r=2))\n下面是输出结果\naa ab ac ad\nbb bc bd\ncc cd\ndd\noperator的使用\nattrgetter\noperator.attrgetter(attr)和operator.attrgetter(*attrs)\n\nAfter f = attrgetter('name'), the call f(b) returns b.name.\nAfter f = attrgetter('name', 'date'), the call f(b) returns (b.name, b.date).\nAfter f = attrgetter('name.first', 'name.last'), the call f(b) returns (b.name.first, b.name.last).\n\n我们通过下面这个例子来了解一下itergetter的用法。\n>>> class Student:\n...     def __init__(self, name, grade, age):\n...         self.name = name\n...         self.grade = grade\n...         self.age = age\n...     def __repr__(self):\n...         return repr((self.name, self.grade, self.age))\n\n>>> student_objects = [\n...     Student('john', 'A', 15),\n...     Student('jane', 'B', 12),\n...     Student('dave', 'B', 10),\n... ]\n\n>>> sorted(student_objects, key=lambda student: student.age)   # 传统的lambda做法\n[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]\n\n>>> from operator import itemgetter, attrgetter\n\n>>> sorted(student_objects, key=attrgetter('age'))\n[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]\n\n# 但是如果像下面这样接受双重比较，Python脆弱的lambda就不适用了\n>>> sorted(student_objects, key=attrgetter('grade', 'age'))\n[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]\nattrgetter的实现原理：\ndef attrgetter(*items):\n    if any(not isinstance(item, str) for item in items):\n        raise TypeError('attribute name must be a string')\n    if len(items) == 1:\n        attr = items[0]\n        def g(obj):\n            return resolve_attr(obj, attr)\n    else:\n        def g(obj):\n            return tuple(resolve_attr(obj, attr) for attr in items)\n    return g\n\ndef resolve_attr(obj, attr):\n    for name in attr.split(\".\"):\n        obj = getattr(obj, name)\n    return obj\nitemgetter\noperator.itemgetter(item)和operator.itemgetter(*items)\n\nAfter f = itemgetter(2), the call f(r) returns r[2].\nAfter g = itemgetter(2, 5, 3), the call g(r) returns (r[2], r[5], r[3]).\n\n我们通过下面这个例子来了解一下itergetter的用法\n>>> student_tuples = [\n...     ('john', 'A', 15),\n...     ('jane', 'B', 12),\n...     ('dave', 'B', 10),\n... ]\n\n>>> sorted(student_tuples, key=lambda student: student[2])   # 传统的lambda做法\n[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]\n\n>>> from operator import attrgetter\n\n>>> sorted(student_tuples, key=itemgetter(2))\n[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]\n\n# 但是如果像下面这样接受双重比较，Python脆弱的lambda就不适用了\n>>> sorted(student_tuples, key=itemgetter(1,2))\n[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]\nitemgetter的实现原理\ndef itemgetter(*items):\n    if len(items) == 1:\n        item = items[0]\n        def g(obj):\n            return obj[item]\n    else:\n        def g(obj):\n            return tuple(obj[item] for item in items)\n    return g\nmethodcaller\noperator.methodcaller(name[, args...])\n\nAfter f = methodcaller('name'), the call f(b) returns b.name().\nAfter f = methodcaller('name', 'foo', bar=1), the call f(b) returns b.name('foo', bar=1).\n\nmethodcaller的实现原理\ndef methodcaller(name, *args, **kwargs):\n    def caller(obj):\n        return getattr(obj, name)(*args, **kwargs)\n    return caller\nReferences\nDOCUMENTATION-FUNCTOOLSDOCUMENTATION-ITERTOOLSDOCUMENTATION-OPERATORHWOTO-FUNCTIONALHWOTO-SORTINGPYMOTWFLENT-PYTHON\nContact\nGitHub: https://github.com/ziwenxieBlog: https://www.ziwenxie.site\n本文为作者原创，转载请于文章开头明显处声明博客出处:)\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "17"}