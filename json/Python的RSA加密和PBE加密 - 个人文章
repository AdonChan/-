{"title": "Python的RSA加密和PBE加密 - 个人文章 ", "index": "rsa,des,python", "content": "最近在写接口的时候，遇到了需要使用RSA加密和PBE加密的情况，对方公司提供的DEMO都是JAVA的，我需要用python来实现。在网上搜了一下，python的RSA加密这块写的还是比较多的，但是PBE较少。所以我就讲讲我在RSA加密上面遇到的坑，大家权当一乐。PBE加密里面的盐、密钥。\nRSA\n什么是RSA加密呢？\n其实RSA是一种非对称加密，那什么是非对称加密呢？非对称加密又叫做公开密钥加密，就是说我有一对密钥，分为公钥和私钥。私钥我悄悄的留着，不给别人看。然后把公钥给别人（无论是谁）。当别人用公钥加密了数据之后，这串加密后的数据只有我（拥有私钥的人）用私钥才能解开，其余谁都不能解开。这就是非对称加密。\n这只是单向的，只是我解开数据 —— 我获取信息。\n那么我怎么向别人传递信息呢？别人怎么保证我传递的信息就是我发出的呢？这时候就需要私钥来加密了，又叫做数字签名。我把数据签名之后数据和未签名的数据一齐发给别人，别人通过公钥来解密加密的数据，然后把解密后的数据和未签名的数据进行对比，相同的话就代表数据来源正确。\n可能说的有点乱，我上次看到一个非常清晰明了的例子，我凭着记忆大致讲出来：\n\n老板派员工小明去外地考察商机。\n小明任务做的很棒，很快就发现了商机。这时候他要想老板汇报，但是网络是不安全的，很有可能一给老板发情报邮件，邮件就被竞争对手得到了。这次考察也就失败了。\n于是，小明通过事先老板给他的公钥来加密情报。\n这样，老板能够通过私钥来解密得到情报，而竞争对手只能对一堆乱码发呆。\n这次情报让老板很满意，老板决定让小明继续深入考察。\n但是这个继续深入考察的命令在网络中传输是不安全的，竞争对手虽然得不到情报，但是可以通过黑客来篡改命令啊，假如让小明回公司，那么这就不划算了，也浪费了时间。\n这时候，老板就用私钥对自己下达的命令进行签名，把签名后的数据和明文的命令一齐发出去，小明收到邮件之后，对签名后的数据和命令用公钥进行验证，如果一致，就代表没有被篡改，可以放心大胆的事实老板的命令。\n\n……………………………………………………分割线………………………………………………\n那么我写的接口呢，是这样的。\n我司要通过接口获取对方公司的数据，获取数据就要传递参数过去，对方根据参数然后返回相应的数据。\n对方公司生成私钥和公钥，我司生成私钥和公钥，双方交换公钥。\n1、使用对方公司的公钥对所有的参数进行加密，加密之后进行base64编码。\n2、使用我司私钥对加密后的数据进行签名，签名之后进行base64编码。\n3、然后把加密后的数据和签名后的数据一齐发送给对方。\n坑1：RSA最长只支持117为的数据进行加密，所以需要进行分段加密，而且需要先拼接再进行base64编码，排错之前一直写的是先base64编码再拼接。\n坑2：分段加密之后要进行相应的签名，是需要进行MD5转码的。\ntalk is more， show your code。\nJava：\n加密：\nprivate static final int MAX_ENCRYPT_BLOCK = 117;\npublic static final String KEY_ALGORITHM = \"RSA\"\n\n/** *//**\n     * <p>\n     * 公钥加密\n     * </p>\n     *\n     * @param data 源数据\n     * @param publicKey 公钥(BASE64编码)\n     * @return\n     * @throws Exception\n     */\n    public static byte[] encryptByPublicKey(byte[] data, String publicKey)\n            throws Exception {\n        byte[] keyBytes = Base64.decode(publicKey);\n        X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(keyBytes);\n        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);\n        Key publicK = keyFactory.generatePublic(x509KeySpec);\n        // 对数据加密\n        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());\n        cipher.init(Cipher.ENCRYPT_MODE, publicK);\n        int inputLen = data.length;\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        int offSet = 0;\n        byte[] cache;\n        int i = 0;\n        // 对数据分段加密\n        while (inputLen - offSet > 0) {\n            if (inputLen - offSet > MAX_ENCRYPT_BLOCK) {\n                cache = cipher.doFinal(data, offSet, MAX_ENCRYPT_BLOCK);\n            } else {\n                cache = cipher.doFinal(data, offSet, inputLen - offSet);\n            }\n            out.write(cache, 0, cache.length);\n            i++;\n            offSet = i * MAX_ENCRYPT_BLOCK;\n        }\n        byte[] encryptedData = out.toByteArray();\n        out.close();\n        return encryptedData;\n    }\n\n通过这段代码，我们注意到：\n1、分段加密，最后直接将加密好的密文合并（out.write(cache, 0, cache.length);）\n2、直接return数据（在另一端程序里面进行base64）\n签名：\npublic static final String SIGNATURE_ALGORITHM = \"MD5withRSA\";    \n/** *//**\n     * <p>\n     * 用私钥对信息生成数字签名\n     * </p>\n     *\n     * @param data 已加密数据\n     * @param privateKey 私钥(BASE64编码)\n     *\n     * @return\n     * @throws Exception\n     */\n    public static String sign(byte[] data, String privateKey) throws Exception {\n        byte[] keyBytes = Base64.decode(privateKey);\n        PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes);\n        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);\n        PrivateKey privateK = keyFactory.generatePrivate(pkcs8KeySpec);\n        Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM);\n        signature.initSign(privateK);\n        signature.update(data);\n        return Base64.encode(signature.sign());\n    }\n\n通过这段代码，我们知道了直接对封装好的密文进行签名，不需要进行分段签名的原因是加密后的密文长度小于117位。我们注意到，他的加密方法是：SIGNATURE_ALGORITHM = \"MD5withRSA\"，所以我们的python签名也是需要进行MD5的。\n那么我们的python代码：\nimport base64\nfrom Crypto.Hash import MD5\nfrom Crypto.Cipher import PKCS1_v1_5 as Cipher_pkcs1_v1_5\nfrom Crypto.Signature import PKCS1_v1_5 as Signature_pkcs1_v1_5\nfrom Crypto.PublicKey import RSA\n\n\ndef get_encrypt_data(params):\n    \"\"\"分段加密\"\"\"\n    params = json.dumps(params)\n    params = params.encode(\"utf-8\")\n    length = len(params)\n    default_length = 117\n    if length < default_length:\n        return encrypt_data(params)\n    offset = 0\n    params_lst = []\n    while length - offset > 0:\n        if length - offset > default_length:\n            params_lst.append(encrypt_data(params[offset:offset+default_length]))                               \n        else:           \n            params_lst.append(encrypt_data(params[offset:]))\n        offset += default_length\n    res = \"\".join(params_lst)\n    return res, base64.b64encode(res)\n\n\ndef encrypt_data(params):\n    \"\"\"使用公钥对数据加密\"\"\"\n    key = public_key\n    rsakey = RSA.importKey(base64.b64decode(key))\n    cipher = Cipher_pkcs1_v1_5.new(rsakey)\n    text = cipher.encrypt(params)\n    return text\n\n\ndef sign_data(params):\n    \"\"\"对数据签名\"\"\"\n    key = private_key\n    rsakey = RSA.importKey(base64.b64decode(key))\n    signer = Signature_pkcs1_v1_5.new(rsakey)\n    digest = MD5.new(params)\n    sign = signer.sign(digest)\n    return base64.b64encode(sign)\n\n对参数进行json化，然后进行utf-8编码，每117位长度遍进行一次加密，最后把加密密文连接起来，进行base64编码。注意我们用了digest = MD5.new(params)，表明我们的签名算法也是MD5。\nPBE\nPBE算法再Java里面是通过MD5和DES算法构建的，是一种对称加密。也就是说加密解密使用一套密钥来进行的。\n我们来看代码：\nJava：\nimport java.security.spec.AlgorithmParameterSpec;\nimport java.security.spec.KeySpec;\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.PBEParameterSpec;\nimport org.apache.commons.codec.binary.Base64;\n\npublic class DesEncrypter {\n    Cipher ecipher;\n    Cipher dcipher;\n    byte[] salt = { (byte) 0xA9, (byte) 0x9B, (byte) 0xC8, (byte) 0x32,\n            (byte) 0x56, (byte) 0x35, (byte) 0xE3, (byte) 0x03 };\n\n    /**\n     * 构造方法\n     * \n     * @param passPhrase\n     *            apikey作为密钥传入\n     * @throws Exception\n     */\n    public DesEncrypter(String passPhrase) throws Exception {\n        int iterationCount = 2;\n        KeySpec keySpec = new PBEKeySpec(passPhrase.toCharArray(), salt,\n                iterationCount);\n        SecretKey key = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\")\n                .generateSecret(keySpec);\n        ecipher = Cipher.getInstance(key.getAlgorithm());\n        dcipher = Cipher.getInstance(key.getAlgorithm());\n        AlgorithmParameterSpec paramSpec = new PBEParameterSpec(salt,\n                iterationCount);\n        ecipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);\n        dcipher.init(Cipher.DECRYPT_MODE, key, paramSpec);\n    }\n\n    /**\n     * 加密\n     * \n     * @param str\n     *            要加密的字符串\n     * @return\n     * @throws Exception\n     */\n    public String encrypt(String str) throws Exception {\n        str = new String(str.getBytes(), \"UTF-8\");\n        return Base64.encodeBase64String(ecipher.doFinal(str.getBytes()));\n}\n\n我们注意到。有一个盐：对应的python盐为：\"\\xA9\\x9B\\xC8\\x32\\x56\\x35\\xE3\\x03\"对应的python2.7代码：\nfrom Crypto.Hash import MD5\nfrom Crypto.Cipher import DES\n\n\ndef get_encrypt_param(params):\n    \"\"\"对参数进行加密封装\"\"\"    \n    _salt = \"\\xA9\\x9B\\xC8\\x32\\x56\\x35\\xE3\\x03\"\n    _iterations = 2\n    data = []\n    \n    # 依次对字典中的value进行utf-8编码\n    for i in params:\n        data.append(\"{}={}\".format(i, params[i].encode(\"utf-8\")))\n    str_param = \"&\".join(data)\n    padding = 8 - len(str_param) % 8\n    str_param += chr(padding) * padding\n\n    hasher = MD5.new()\n    hasher.update(apikey)\n    hasher.update(_salt)\n    result = hasher.digest()\n\n    # 进行hash的次数， 由java中的iterationCount决定\n    for i in range(1, _iterations):\n        hasher = MD5.new()\n        hasher.update(result)\n        result = hasher.digest()\n\n    encoder = DES.new(result[:8], DES.MODE_CBC, result[8:16])\n    encrypted = encoder.encrypt(str_param)\n    return encrypted.encode(\"base64\")\n\n我们将传入的参数进行utf-8编码，然后进行hash，最后进行加密。\n注意：java代码中的iterationCount是多少，我们就要进行循环hash多少次。\n在python3的代码中，str是不能直接进行hash的，所以要抓换成utf-8进行加密，而且最后的encrypted没有encode方法，只能手动进行Base64编码。\npython3 代码如下：\nimport base64\nfrom Crypto.Hash import MD5\nfrom Crypto.Cipher import DES\n\n\ndef get_encrypt_param(params):\n\"\"\"对参数进行加密封装\"\"\"\n\n    # 定义_salt的时候，直接定义成bytes\n    _salt = b\"\\xA9\\x9B\\xC8\\x32\\x56\\x35\\xE3\\x03\"\n    _iterations = 2\n    data = []\nfor i in params:\n        data.append(\"{}={}\".format(i, params[i]))\n    str_param = \"&\".join(data)\n    padding = 8 - len(str_param) % 8\n    str_param += chr(padding) * padding\n\n    hasher = MD5.new()\n\n    # 对apikey进行utf-8编码\n    hasher.update(apikey.encode())\n    hasher.update(_salt)\n    result = hasher.digest()\nfor i in range(1, _iterations):\n        hasher = MD5.new()\n        hasher.update(result)\n        result = hasher.digest()\n    encoder = DES.new(result[:8], DES.MODE_CBC, result[8:16])\n    encrypted = encoder.encrypt(str_param)\n    # 进行base64编码\n    return base64.b64encode(encrypted)\n\n但是有一个bug，当参数中有中文的时候，他会 报错：\nValueError: Input strings must be a multiple of 8 in length\n\n经过检查代码发现是没有对参数进行utf-8编码。\n但是经过我们编码之后：\nfor i in params:\n    data.append(\"{}={}\".format(i, params[i].encode(\"utf-8\")))\n\n由于python3的机制，编码之后中文便成了bytes，对方解码之后无法识别，于是我们只有另辟蹊径。\n经过一番研究，决定使用另一个库，pyDes\n代码如下：\nimport pyDes\n\n\ndef get_encrypt_param(params):\n    \"\"\"对参数进行加密封装\"\"\"\n    _salt = b\"\\xA9\\x9B\\xC8\\x32\\x56\\x35\\xE3\\x03\"\n    _iterations = 2\n    data = []\n    for i in params:\n        data.append(\"{}={}\".format(i, params[i]))\n    str_param = \"&\".join(data)\n\n    hasher = MD5.new()\n    hasher.update(apikey.encode())\n    hasher.update(_salt)\n    result = hasher.digest()\n    for i in range(1, _iterations):\n        hasher = MD5.new()\n        hasher.update(result)\n        result = hasher.digest()\n\n    despy = pyDes.des(result[:8], pyDes.CBC, padmode=pyDes.PAD_PKCS5, IV=result[8:16])\n    encrypt_data = despy.encrypt(str_param.encode())\n    return base64.b64encode(encrypt_data）\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "2"}