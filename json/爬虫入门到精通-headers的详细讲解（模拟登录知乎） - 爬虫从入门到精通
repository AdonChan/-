{"title": "爬虫入门到精通-headers的详细讲解（模拟登录知乎） - 爬虫从入门到精通 ", "index": "网页爬虫,python爬虫,python", "content": "本文章属于爬虫入门到精通系统教程第七讲\n直接开始案例吧。\n本次我们实现如何模拟登陆知乎。\n1.抓包\n首先打开知乎登录页 知乎 - 与世界分享你的知识、经验和见解\n注意打开开发者工具后点击“preserve log”，密码记得故意输入错误，然后点击登录\n\n我们很简单的就找到了 我们需要的请求\n\n\n_xsrf:81aa4a69cd410c3454ce515187f2d4c9\npassword:***\nemail:admin@wuaics.cn\n\n可以看到请求一共有三个参数\nemail 和password就是我们需要登录的账号及密码\n那么_xsrf是什么？我们在哪能找到？\n像“_xsrf”这种参数，一般叫做页面校检码，是来检查你是否是从正常的登录页面过来的。\n那我们复制这个值，在登录页面找找看。\n//input[@name=\"_xsrf\"]/@value  \n\n所以，本次登录我们需要得到的数据已经都得到了\n步骤如下：\n\n打开知乎登录页面，获取_xsrf\n把_xsrf和自己的账号及密码一起发送（模拟登录）\n\n2.模拟登录\nimport requests\n\nurl = 'https://www.zhihu.com/#signin'\nz = requests.get(url)\nprint z.status_code\n\n我们会看到 http状态码为500...\n至于为什么会返回500状态码呢？是因为我们用程序来访问知乎被发现了...\n我们伪装成浏览器，添加一行\n\n可以看到返回正常了，http状态码为200(这就是headers的作用)\n那我们现在获取_xsrf\nfrom lxml import etree\nsel = etree.HTML(z1.content)\n# 这个xsrf怎么获取 我们上面有讲到\n_xsrf = sel.xpath('//input[@name=\"_xsrf\"]/@value')[0]\n\n然后模拟登录\nloginurl = 'https://www.zhihu.com/login/email'\n# 这里的_xsrf就是我们刚刚上面得到的\nformdata = {\n    'email':'admin@wuaics.cn',\n    'password':'你的密码',\n    '_xsrf':_xsrf\n}\nz2 = requests.post(url=loginurl,data=formdata,headers=headers)\nprint z2.status_code\n #200\nprint z2.content\n# '{\"r\":0,\\n \"msg\": \"\\\\u767b\\\\u5f55\\\\u6210\\\\u529f\"\\n}'\nprint z2.json()['msg']\n# 登陆成功\n\n可以看到已经模拟登录并成功了。\n那我们来打开知乎 - 与世界分享你的知识、经验和见解来检查下 是否有登录成功\n# 为什么用这个页面呢？\n# 因为这个页面只有登录后才能看得到，如果没有登录的话 会自动跳转让你登录的\nmylog = 'https://www.zhihu.com/people/pa-chong-21/logs'\nz3 = requests.get(url=mylog,headers=headers)\nprint z3.status_code\n#200\nprint z3.url\n# u'https://www.zhihu.com/?next=%2Fpeople%2Fpa-chong-21%2Flogs'\n\n发现页面url是 (https://www.zhihu.com/?next=%...\n并不是 我前面输入的 (https://www.zhihu.com/people/...\n说明知乎判断我们没有登录，然后把我们跳转到登录页面了.\n如果感兴趣的话，可以把z3.text 的返回值存为123.html，然后打开看看，是不是跳转到登录页面了..\n那么为什么会跳到登录页面呢？刚刚不是已经登录成功了么？\n这是因为，我们这几个模拟请求，相互间都是独立的，所以z2登录成功了，和z3并没有什么关系。\n那如果我现在想要z3不用再模拟登录一次，也能登录的话，怎么办呢？\n我们可以把z2登录成功后得到的cookie给z3,这样，z3也就能登录成功了.\n用程序实现\n\n再次判断下是否登录成功。\nz3 = requests.get(url=mylog,headers=headers)\nprint z3.url\n# u'https://www.zhihu.com/people/pa-chong-21/logs'\n\n我们可以看到已经正常访问了。说明我们登录成功了\n所以，以后只要你带着这个cookie，就可以访问登录后的页面了.(这就是cookie的作用..)\n最后附上一个小技巧.\n当你需要登录，或者说你需要在一段会话中操作（也就是我们上面的操作）\n\n会话对象高级用法 - Requests 2.10.0 文档\n\n会话对象让你能够跨请求保持某些参数。它也会在同一个 Session 实例发出的所有请求之间保持 cookie， 期间使用 urllib3 的 connection pooling 功能。所以如果你向同一主机发送多个请求，底层的 TCP 连接将会被重用，从而带来显著的性能提升。 (参见 HTTP persistent connection).\n\n使用会话后，我们上面的代码可以改成这样\n\n可以看到我们没有把cookie传过去，但是还是登录成功了，这是因为session会自动帮你处理这些，会自动帮你管理cookie\n我们可以打印看下我们请求的headers\n\n可以看到headers里面自动加上了cookie\n最后所有的代码都在kimg1234/pachong\n最后再次总结一下\n看完本篇文章后，你应该要\n\n能理解User-Agent,cookie的作用\n了解requests中的session用法\n了解如何模拟登录一个网页\n\n如果你对requests这个库不太熟悉的话，你可以在快速上手 - Requests 2.10.0 文档浏览。\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "12"}