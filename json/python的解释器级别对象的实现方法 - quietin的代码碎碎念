{"title": "python的解释器级别对象的实现方法 - quietin的代码碎碎念 ", "index": "python", "content": "最近在重构项目代码, 有个需求是需要声明一个变量, 然后任何import了这个变量的模块, 当这个变量在其它地方更改了值以后, 这个变化都能反映出来, 乍看好像有点麻烦, 其实很简单.\n就通常的想法来讲, 你用Dict, list或一个类实例都能实现. 因为在使用它们时, 本质上还是一种引用的方式, 而不是像其它变量是值复制, 所以它们的修改或变化是肯定能反映出来的\n比如tornado的options, 没记错的话, 文档里写的什么解释器级别变量, 很高端的样子, 其实实现不难, 直接跳到代码\noptions = OptionParser()\n\"\"\"Global options object.\n\nAll defined options are available as attributes on this object.\n\"\"\"\nGlobal的对象, 因为OptionParser的实例就一个options, 每次使用是怎么使用的呢\nfrom tornado.options import options\n每次都import的是这个实例, 而包括define在内的函数, 其实都是在对这个唯一的实例在进行操作而已, 代码中有这段\ndef define(name, default=None, type=None, help=None, metavar=None,\n           multiple=False, group=None, callback=None):\n    \"\"\"Defines an option in the global namespace.\n\n    See `OptionParser.define`.\n    \"\"\"\n    return options.define(name, default=default, type=type, help=help,\n                          metavar=metavar, multiple=multiple, group=group,\n                          callback=callback)\n另外一个令人容易想到的解释器级别的东西就是logger, logging.getLogger()也是声明解释器级别的对象, 而且还是线程安全的. 我们只需要在某个模块中声明一个logger, 然后在其它模块里\nimport logging\n\nlogger = logging.getLogger('xxname')\n就行了\n直接看代码\ndef getLogger(self, name):\n        \"\"\"\n        Get a logger with the specified name (channel name), creating it\n        if it doesn't yet exist. This name is a dot-separated hierarchical\n        name, such as \"a\", \"a.b\", \"a.b.c\" or similar.\n\n        If a PlaceHolder existed for the specified name [i.e. the logger\n        didn't exist but a child of it did], replace it with the created\n        logger and fix up the parent/child references which pointed to the\n        placeholder to now point to the logger.\n        \"\"\"\n        rv = None\n        if not isinstance(name, basestring):\n            raise TypeError('A logger name must be string or Unicode')\n        if isinstance(name, unicode):\n            name = name.encode('utf-8')\n        _acquireLock()\n        try:\n            if name in self.loggerDict:\n                rv = self.loggerDict[name]\n                if isinstance(rv, PlaceHolder):\n                    ph = rv\n                    rv = (self.loggerClass or _loggerClass)(name)\n                    rv.manager = self\n                    self.loggerDict[name] = rv\n                    self._fixupChildren(ph, rv)\n                    self._fixupParents(rv)\n            else:\n                rv = (self.loggerClass or _loggerClass)(name)\n                rv.manager = self\n                self.loggerDict[name] = rv\n                self._fixupParents(rv)\n        finally:\n            _releaseLock()\n        return rv\n这个getLogger函数最终调用的是Manager类的实例函数getLogger, 当你用的这个name不存在时, 通常是日志初始化时, 会声明一个Logger对象, 然后放到Manager的loggerDict中进行管理.\n当你在别的地方也声明了这个name的logger时, Manager会发现loggerDict中已经有了, 直接拿出来用就行了. 其中还包括一些日志层级, hierarchy那些东西的处理, 不过这不是本文重点.\n至于线程安全, 很简单, 代码里给加了线程锁. 这样打日志就不会东一块西一块了, 可惜多进程的日志标准库没有给进程安全的实现, 当然自己统一上传用socket处理或者用个process queue处理都是可以的.\n如果想在允许多次实例化的情况下, 实现这种解释器级别变量呢?那就是单例模式了, 在实例已经存在时调用一个函数对自己进行重载或更新即可\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "4"}