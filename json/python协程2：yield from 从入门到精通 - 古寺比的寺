{"title": "python协程2：yield from 从入门到精通 - 古寺比的寺 ", "index": "协程,python", "content": "上一篇python协程1：yield的使用介绍了：\n\n生成器作为协程使用时的行为和状态\n使用装饰器预激协程\n调用方如何使用生成器对象的 .throw(...) 和 .close() 方法控制协程\n\n这一篇将介绍：\n\n协程终止时如何返回值\nyield新句法的用途和语义\n\n同时会用几个协程的示例展示协程用法。\n让协程返回值\n先看一个例子：这段代码会返回最终均值的结果，每次激活协程时不会产出移动平均值，而是最后一次返回。\n#! -*- coding: utf-8 -*-\n\nfrom collections import namedtuple\n\nResult = namedtuple('Result', 'count average')\n\n\ndef averager():\n    total = 0.0\n    count = 0\n    average = None\n    while True:\n        term = yield\n        if term is None:\n            break  # 为了返回值，协程必须正常终止；这里是退出条件\n        total += term\n        count += 1\n        average = total/count\n    # 返回一个namedtuple，包含count和average两个字段。在python3.3前，如果生成器返回值，会报错\n    return Result(count, average)\n我们调用这段代码，结果如下\n>>> coro_avg = averager()\n>>> next(coro_avg)\n>>> coro_avg.send(20) # 并没有返回值\n>>> coro_avg.send(30)\n>>> coro_avg.send(40)\n>>> coro_avg.send(None) # 发送None终止循环，导致协程结束。生成器对象会抛出StopIteration异常。异常对象的value属性保存着返回值。\nTraceback (most recent call last):\n   ...\nStopIteration: Result(count=3, average=30)\nreturn 表达式的值会传给调用方，赋值给StopIteration 异常的一个属性。这样做虽然看着别扭，但为了保留生成器对象耗尽时抛出StopIteration异常的行为，也可以理解。\n如果我们想获取协程的返回值，可以这么操作：\n>>> coro_avg = averager()\n>>> next(coro_avg)\n>>> coro_avg.send(20) # 并没有返回值\n>>> coro_avg.send(30)\n>>> coro_avg.send(40)\n>>> try:\n...     coro_avg.send(None)\n... except StopIteration as exc:\n...     result = exc.value\n...\n>>> result\nResult(count=3, average=30)\n\n看到这我们会说，这是什么鬼，为什么获取返回值要绕这么一大圈，就没有简单的方法吗？\n有的，那就是 yield from\nyield from 结果会在内部自动捕获StopIteration 异常。这种处理方式与 for 循环处理StopIteration异常的方式一样。对于yield from 结构来说，解释器不仅会捕获StopIteration异常，还会把value属性的值变成yield from 表达式的值。\n在函数外部不能使用yield from（yield也不行）。\n既然我们提到了 yield from 那yield from 是什么呢？\nyield from\nyield from 是 Python3.3 后新加的语言结构。和其他语言的await关键字类似，它表示：*在生成器 gen 中使用 yield from subgen()时，subgen 会获得控制权，把产出的值传个gen的调用方，即调用方可以直接控制subgen。于此同时，gen会阻塞，等待subgen终止。\nyield from 可用于简化for循环中的yield表达式。\n例如：\ndef gen():\n    for c in 'AB':\n        yield c\n    for i in range(1, 3):\n        yield i\n\nlist(gen())\n['A', 'B', '1', '2']\n可以改写为：\ndef gen():\n    yield from 'AB'\n    yield from range(1, 3)\n    \n\nlist(gen())\n['A', 'B', '1', '2']\n下面来看一个复杂点的例子：(来自Python cookbook 3 ，github源码地址 https://github.com/dabeaz/python-cookbook/blob/master/src/4/how_to_flatten_a_nested_sequence/example.py)\n# Example of flattening a nested sequence using subgenerators\n\nfrom collections import Iterable\n\ndef flatten(items, ignore_types=(str, bytes)):\n    for x in items:\n        if isinstance(x, Iterable) and not isinstance(x, ignore_types):\n            yield from flatten(x) # 这里递归调用，如果x是可迭代对象，继续分解\n        else:\n            yield x\n\nitems = [1, 2, [3, 4, [5, 6], 7], 8]\n\n# Produces 1 2 3 4 5 6 7 8\nfor x in flatten(items):\n    print(x)\n\nitems = ['Dave', 'Paula', ['Thomas', 'Lewis']]\nfor x in flatten(items):\n    print(x)\nyield from x 表达式对x对象做的第一件事是，调用 iter(x)，获取迭代器。所以要求x是可迭代对象。\nPEP380 的标题是 ”syntax for delegating to subgenerator“(把指责委托给子生成器的句法)。由此我们可以知道，yield from是可以实现嵌套生成器的使用。\nyield from 的主要功能是打开双向通道，把最外层的调用方与最内层的子生成器连接起来，使两者可以直接发送和产出值，还可以直接传入异常，而不用在中间的协程添加异常处理的代码。\nyield from 包含几个概念：\n委派生成器\n包含yield from <iterable> 表达式的生成器函数\n子生成器\n从yield from <iterable> 部分获取的生成器。\n调用方\n调用委派生成器的客户端（调用方）代码\n这个示意图是 对yield from 的调用过程\n\n委派生成器在 yield from 表达式处暂停时，调用方可以直接把数据发给字生成器，子生成器再把产出的值发送给调用方。子生成器返回之后，解释器会抛出StopIteration异常，并把返回值附加到异常对象上，只是委派生成器恢复。\n这个图来自于Paul\nSokolovsky 的 How Python 3.3 \"yield from\" construct works\n下边这个例子是对yield from 的一个应用：\n #! -*- coding: utf-8 -*-\n\nfrom collections import namedtuple\n\n\nResult = namedtuple('Result', 'count average')\n\n\n# 子生成器\n# 这个例子和上边示例中的 averager 协程一样，只不过这里是作为字生成器使用\ndef averager():\n    total = 0.0\n    count = 0\n    average = None\n    while True:\n        # main 函数发送数据到这里 \n        term = yield\n        if term is None: # 终止条件\n            break\n        total += term\n        count += 1\n        average = total/count\n    return Result(count, average) # 返回的Result 会成为grouper函数中yield from表达式的值\n\n\n# 委派生成器\ndef grouper(results, key):\n     # 这个循环每次都会新建一个averager 实例，每个实例都是作为协程使用的生成器对象\n    while True:\n        # grouper 发送的每个值都会经由yield from 处理，通过管道传给averager 实例。grouper会在yield from表达式处暂停，等待averager实例处理客户端发来的值。averager实例运行完毕后，返回的值绑定到results[key] 上。while 循环会不断创建averager实例，处理更多的值。\n        results[key] = yield from averager()\n\n\n# 调用方\ndef main(data):\n    results = {}\n    for key, values in data.items():\n        # group 是调用grouper函数得到的生成器对象，传给grouper 函数的第一个参数是results，用于收集结果；第二个是某个键\n        group = grouper(results, key)\n        next(group)\n        for value in values:\n            # 把各个value传给grouper 传入的值最终到达averager函数中；\n            # grouper并不知道传入的是什么，同时grouper实例在yield from处暂停\n            group.send(value)\n        # 把None传入groupper，传入的值最终到达averager函数中，导致当前实例终止。然后继续创建下一个实例。\n        # 如果没有group.send(None)，那么averager子生成器永远不会终止，委派生成器也永远不会在此激活，也就不会为result[key]赋值\n        group.send(None)\n    report(results)\n\n\n# 输出报告\ndef report(results):\n    for key, result in sorted(results.items()):\n        group, unit = key.split(';')\n        print('{:2} {:5} averaging {:.2f}{}'.format(result.count, group, result.average, unit))\n\n\ndata = {\n    'girls;kg':[40, 41, 42, 43, 44, 54],\n    'girls;m': [1.5, 1.6, 1.8, 1.5, 1.45, 1.6],\n    'boys;kg':[50, 51, 62, 53, 54, 54],\n    'boys;m': [1.6, 1.8, 1.8, 1.7, 1.55, 1.6],\n}\n\nif __name__ == '__main__':\n    main(data)\n这段代码从一个字典中读取男生和女生的身高和体重。然后把数据传给之前定义的 averager 协程，最后生成一个报告。\n执行结果为\n6 boys  averaging 54.00kg\n6 boys  averaging 1.68m\n6 girls averaging 44.00kg\n6 girls averaging 1.58m\n这断代码展示了yield from 结构最简单的用法。委派生成器相当于管道，所以可以把任意数量的委派生成器连接在一起---一个委派生成器使用yield from 调用一个子生成器，而那个子生成器本身也是委派生成器，使用yield from调用另一个生成器。最终以一个只是用yield表达式的生成器（或者任意可迭代对象）结束。\nyield from 的意义\nPEP380 分6点说明了yield from 的行为。\n\n子生成器产出的值都直接传给委派生成器的调用方（客户端代码）\n使用send() 方法发给委派生成器的值都直接传给子生成器。如果发送的值是None，那么会调用子生成器的 __next__()方法。如果发送的值不是None，那么会调用子生成器的send()方法。如果调用的方法抛出StopIteration异常，那么委派生成器恢复运行。任何其他异常都会向上冒泡，传给委派生成器。\n生成器退出时，生成器（或子生成器）中的return expr 表达式会触发 StopIteration(expr) 异常抛出。\nyield from表达式的值是子生成器终止时传给StopIteration异常的第一个参数。\n传入委派生成器的异常，除了 GeneratorExit 之外都传给子生成器的throw()方法。如果调用throw()方法时抛出 StopIteration 异常，委派生成器恢复运行。StopIteration之外的异常会向上冒泡。传给委派生成器。\n如果把 GeneratorExit 异常传入委派生成器，或者在委派生成器上调用close() 方法，那么在子生成器上调用close() 方法，如果他有的话。如果调用close() 方法导致异常抛出，那么异常会向上冒泡，传给委派生成器；否则，委派生成器抛出 GeneratorExit 异常。\n\nyield from的具体语义很难理解，不过我们可以看下Greg Ewing 的伪代码，通过伪代码分析一下：\nRESULT = yield from EXPR\n\n# is semantically equivalent to\n# EXPR 可以是任何可迭代对象，因为获取迭代器_i 使用的是iter()函数。\n_i = iter(EXPR)\ntry:\n    _y = next(_i) # 2 预激字生成器，结果保存在_y 中，作为第一个产出的值\nexcept StopIteration as _e:\n    # 3 如果调用的方法抛出StopIteration异常，获取异常对象的value属性，赋值给_r\n    _r = _e.value\nelse:\n    while 1: # 4 运行这个循环时，委派生成器会阻塞，只能作为调用方和子生成器直接的通道\n        try:\n            _s = yield _y # 5 产出子生成器当前产出的元素；等待调用方发送_s中保存的值。\n        except GeneratorExit as _e:\n            # 6 这一部分是用于关闭委派生成器和子生成器，因为子生成器可以是任意可迭代对象，所以可能没有close() 方法。\n            try:\n                _m = _i.close\n            except AttributeError:\n                pass\n            else:\n                _m()\n            # 如果调用close() 方法导致异常抛出，那么异常会向上冒泡，传给委派生成器；否则，委派生成器抛出 GeneratorExit 异常。\n            raise _e\n        except BaseException as _e: # 7 这一部分处理调用方通过.throw() 方法传入的异常。如果子生成器是迭代器，没有throw()方法，这种情况会导致委派生成器抛出异常\n            _x = sys.exc_info()\n            try:\n                # 传入委派生成器的异常，除了 GeneratorExit 之外都传给子生成器的throw()方法。\n                _m = _i.throw\n            except AttributeError:\n                # 子生成器一迭代器，没有throw()方法， 调用throw()方法时抛出AttributeError异常传给委派生成器\n                raise _e\n            else: # 8\n                try:\n                    _y = _m(*_x)\n                except StopIteration as _e:\n                     # 如果调用throw()方法时抛出 StopIteration 异常，委派生成器恢复运行。\n                     # StopIteration之外的异常会向上冒泡。传给委派生成器。\n                    _r = _e.value\n                    break\n        else: # 9 如果产出值时没有异常\n            try: # 10 尝试让子生成器向前执行\n                if _s is None: \n                    # 11. 如果发送的值是None，那么会调用子生成器的 __next__()方法。\n                    _y = next(_i)\n                else:\n                    # 11. 如果发送的值不是None，那么会调用子生成器的send()方法。\n                    _y = _i.send(_s)\n            except StopIteration as _e: # 12\n                # 2. 如果调用的方法抛出StopIteration异常，获取异常对象的value属性，赋值给_r, 退出循环，委派生成器恢复运行。任何其他异常都会向上冒泡，传给委派生成器。\n                _r = _e.value \n                break\nRESULT = _r #13 返回的结果是 _r 即整个yield from表达式的值\n上段代码变量说明:\n\n_i 迭代器（子生成器）\n_y 产出的值 （子生成器产出的值）\n_r 结果 （最终的结果  即整个yield from表达式的值）\n_s 发送的值 （调用方发给委派生成器的值，这个只会传给子生成器）\n_e 异常 （异常对象）\n\n我们可以看到在代码的第一个 try 部分 使用 _y = next(_i) 预激了子生成器。这可以看出，上一篇我们使用的用于自动预激的装饰器与yield from 语句不兼容。\n除了这段伪代码之外，PEP380 还有个说明：\nIn a generator, the statement\n\nreturn value\n\nis semantically equivalent to\n\nraise StopIteration(value)\n\nexcept that, as currently, the exception cannot be caught by except clauses within the returning generator.\n这也就是为什么 yield from 可以使用return 来返回值而 yield 只能使用 try ... except StopIteration ... 来捕获异常的value 值。\n>>> try:\n...     coro_avg.send(None)\n... except StopIteration as exc:\n...     result = exc.value\n...\n>>> result\n到这里，我们已经了解了 yield from 的具体细节。下一篇，会分析一个使用协程的经典案例： 仿真编程。这个案例说明了如何使用协程在单线程中管理并发活动。\n参考文档\n\n流畅的python 第16章（这是读书笔记，这是读书笔记）\nPEP 380-- Syntax for Delegating to a Subgenerator\nHow Python 3.3 \"yield from\" construct works\n\n最后，感谢女朋友支持。\n\n\n>欢迎关注\n>请我喝芬达\n\n\n\n\n\n\n\n                ", "mainLikeNum": ["6 "], "mainBookmarkNum": "13"}