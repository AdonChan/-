{"title": "Python 2.x 与 Python 3.x 的区别 - Python 学习之路 ", "index": "python", "content": "前言\n如果你是刚接触 Python 的初学者，那你可能是直接学习 Python 3.x 版本。对于 Python 2.x 的版本是不会有所接触。官方也宣布在 2020 停止对 Python 2.x 的维护。我也建议初学者直接去学 Python 3.x 版本。但我们还是要去了解下 Python 3.x 与 Python 2.x 之间都有哪些改变，通过对比能让你对 Python 有更加深刻的理解。并且在很多面试过程中，面试官都会问：Python 2.x 与 Python 3.x 的区别。今天就给大家列举 Python 3.0 主要改变的几个方面。\nPy3K\nPython 的 3.0 版本，常被称为 Python 3000，或简称 Py3K。\n为了照顾现有程式，Python 2.6 作为一个过度版本，基本使用了 Python 2.x 得语法和库，同时考虑了向 Pythn 3.0 得迁移，允许使用部分 Python 3.0 的语法与函数。\nPython 3.0 的变化主要在以下几个方面：\n1 print 函数\nprint 语句没有了，取而代之的是 print() 函数。Python 2.6 与 Python 2.7 部分地支持这种形式的 print 语法。在 Python 2.6 与 Python 2.7 里面，以下三种形式是等价的：\nprint \"fish\"\nprint (\"fish\") # 注意 print 后面有个空格\nprint(\"fish\") # print() 不能带有任何其它参数 \n然后，Python 2.6 实际已经支持新得 print() 语法：\nfrom __future__ import print_function\nprint(\"fish\", \"panda\", sep=\", \") \n2 Unicode\nPython 2 有 ASCII str() 类型，unicode() 是单独的，不是 byte 类型。\n现在，在 Python 3 ，我们最终有了 Unicode(utf-8) 字符串，以及一个字节类：byte 和 bytearrays。\n由于 Python 3.x 源码文件默认使用 uft-8 编码，这就使得以下代码是合法的：\n>>> 中国 = 'china'\n>>> print(中国)\nchina \nPython 2.x\n>>> str = '我爱北京天安门'\n>>> str\n'\\xe6\\x88\\x91\\xe7\\x88\\xb1\\xe5\\x8c\\x97\\xe4\\xba\\xac\\xe5\\xa4\\xa9\\xe5\\xae\\x89\\xe9\\x97\\xa8'\n>>> str = u'我爱北京天安门'\n>>> str \nPython 3.x\n>>> str = \"我爱北京天安门\"\n>>> str\n'我爱北京天安门' \n3 除法运算\nPython 中的除法较其它语言显得非常高端，有套很复杂的规则。Python 中的除法有两个运算符，/ 和 // 首先来说下 / 除法：\n在 python 2.x 中 / 除法就跟我们熟悉的大多数语言，比如 Java、C 差不多，整数相除的结果是一个整数，把小数部分完全忽略掉，浮点数除法会保留小数点的部分得到一个浮点数的结果。\n在 python3.x 中 / 除法不再这么做了，对于整数之间的相除，结果也会是浮点数。\nPython 2.x\n>>> 1 / 2\n0\n>>> 1.0 / 2.0\n0.5 \nPython 3.x\n>>> 1/2\n0.5 \n而对于 // 除法，这种除法叫做 floor 除法，会对除法的结果自动进行一个 floor 操作，在 python 2.x 和 python 3.x 中是一致的。\n而 floor 除法指的是返回数字的下舍整数，在 Python 中有个 floor 函数，它不能直接访问，需要导入 math 模块，通过静态对象调用该方法。举个例子：\nimport math   # This will import math module\nprint \"math.floor(-45.17) : \", math.floor(-45.17) \n输出结果：\nmath.floor(-45.17) :  -46.0 \npython 2.x:\n>>> -1 // 2\n-1 \n注意的是并不是舍弃小数部分，而是执行 floor 操作，如果要截取小数部分，那么需要使用 math 模块的 trunc 函数\npython 3.x\n>>> import math\n>>> math.trunc(1 / 2)\n0\n>>> math.trunc(-1 / 2)\n0 \n4 异常\n在 Python 3 中处理异常也轻微的改变了，在 Python 3 中我们现在使用 as 作为关键词。\n捕获异常的语法由 except exc, var 改为 except exc as var。\n使用语法 except (exc1, exc2) as var 可以同时捕获多种类别的异常。 Python 2.6 已经支持这两种语法。\n\n1. 在 2.x 时代，所有类型的对象都是可以被直接抛出的，在 3.x 时代，只有继承自 BaseException 的对象才可以被抛出。\n2. 2.x raise 语句使用逗号将抛出对象类型和参数分开，3.x 取消了这种奇葩的写法，直接调用构造函数抛出对象即可。\n\n在 2.x 时代，异常在代码中除了表示程序错误，还经常做一些普通控制结构应该做的事情，在 3.x 中可以看出，设计者让异常变的更加专一，只有在错误发生的情况才能去用异常捕获语句来处理。\n5 xrange\n在 Python 2 中 xrange() 创建迭代对象的用法是非常流行的。比如： for 循环或者是列表/集合/字典推导式。\n这个表现十分像生成器（比如。\"惰性求值\"）。但是这个 xrange-iterable 是无穷的，意味着你可以无限遍历。\n由于它的惰性求值，如果你不得仅仅不遍历它一次，xrange() 函数 比 range() 更快（比如 for 循环）。尽管如此，对比迭代一次，不建议你重复迭代多次，因为生成器每次都从头开始。\n惰性求值：惰性求值，也就是延迟求值，表达式不会在它被绑定到变量之后就立即求值，而是等用到时再求值。\n作用：这个特性可以解决一些巨大甚至无限的集合列表，延迟求值的一个好处是能够建立可计算的无限列表，而没有妨碍计算的无限循环或大小问题。\nPython 中的很多方法没有直接返回列表，而是返回了一个可迭代的 generator (生成器)对象，这便是 python 的惰性求值。\n在 Python 3 中，range() 是像 xrange() 那样实现以至于一个专门的 xrange() 函数都不再存在（在 Python 3 中 xrange() 会抛出命名异常）。\nimport timeit\nn = 10000\ndef test_range(n):\n    return for i in range(n):\n        pass\ndef test_xrange(n):\n    for i in xrange(n):\n        pass \nPython 2\nprint 'Python', python_version()\nprint '\\ntiming range()' \n%timeit test_range(n)\nprint '\\n\\ntiming xrange()' \n%timeit test_xrange(n)\nPython 2.7.6\ntiming range()\n1000 loops, best of 3: 433 µs per loop\ntiming xrange()\n1000 loops, best of 3: 350 µs per loop \nPython 3\nprint('Python', python_version())\nprint('\\ntiming range()')\n%timeit test_range(n)\nPython 3.4.1\ntiming range()\n1000 loops, best of 3: 520 µs per loop \nprint(xrange(10))\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\n<ipython-input-5-5d8f9b79ea70> in <module>()\n----> 1 print(xrange(10))\nNameError: name 'xrange' is not defined \n6 八进制字面量表示\n八进制数必须写成 0o777，原来的形式 0777 不能用了；二进制必须写成 0b111。\n新增了一个 bin() 函数用于将一个整数转换成二进制字串。 Python 2.6 已经支持这两种语法。\n在 Python 3.x 中，表示八进制字面量的方式只有一种，就是 0o1000。\npyhon 2.x\n>>> 0o1000\n512\n>>> 01000\n512 \npython 3.x\n>>> 01000\n  File \"<stdin>\", line 1\n    01000\n        ^\nSyntaxError: invalid token\n>>> 0o1000\n512 \n7 不等运算符\nPython 2.x 中不等于有两种写法 != 和 <>\nPython 3.x 中去掉了 <>，只有 != 一种写法。\n8 去掉了 repr 表达式 ``\nPython 2.x 中反引号 `` 相当于 repr 函数的作用\nPython 3.x 中去掉了 `` 这种写法，只允许使用 repr 函数。\nrepr 是什么：repr() 函数将对象转化为供解释器读取的形式，返回一个对象的 string 格式。\n9 多个模块被改名（根据 PEP8）\n\nhttplib, BaseHTTPServer, CGIHTTPServer, SimpleHTTPServer, Cookie, cookielib 被合并到 http 包内。StringIO 模块现在被合并到新的 io 模组内。 new, md5, gopherlib 等模块被删除。 Python 2.6 已经支援新的 io 模组。\n取消了 exec 语句，只剩下 exec() 函数。 Python 2.6 已经支援 exec() 函数。\n10 数据类型\n1）Py3.X 去除了 long 类型，现在只有一种整型——int，但它的行为就像 2.X 版本的 long。\n2）新增了 bytes 类型，对应于 2.x 版本的八位串，定义一个 bytes 字面量的方法如下：\n>>> b = b'china' \n>>> type(b) \n<type 'bytes'> \nstr 对象和 bytes 对象可以使用 .encode() (str -> bytes) or .decode() (bytes -> str) 方法相互转化。\n>>> s = b.decode() \n>>> s \n'china' \n>>> b1 = s.encode() \n>>> b1 \nb'china' \n3）dict 的 .keys()、.items 和 .values() 方法返回迭代器，而之前的 iterkeys() 等函数都被废弃。同时去掉的还有 dict.has_key()，用 in 替代它。\n11 打开文件\n原先有两种打开方式：\nfile( ..... )\n或 \nopen(.....) \n现在改成只能用\nopen(......) \n12 从键盘录入一个字符串\nraw_input(\"提示信息\") \n现在：\ninput(\"提示信息\") \n在 python2.x 中 raw_input() 和 input( )，两个函数都存在，其中区别为：\n\nraw_input()：将所有输入作为字符串看待，返回字符串类型\ninput()：只能接收\"数字\"的输入，在对待纯数字输入时具有自己的特性，它返回所输入的数字的类型（int, float ）\n\n在 python3.x 中 raw_input() 和 input( ) 进行了整合，去除了 raw_input()，仅保留了 input() 函数，其接收任意任性输入，将所有输入默认为字符串处理，并返回字符串类型。\n本文首发于公众号「痴海」，后台回复「1024」，领取最新 Python 教程。\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}