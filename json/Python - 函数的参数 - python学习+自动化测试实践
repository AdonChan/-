{"title": "Python - 函数的参数 - python学习+自动化测试实践 ", "index": "python", "content": "\n题外话：因为时间关系，没能保持一定的更新频率。但还是会一直坚持的~\n之前介绍了Python函数的定义，今天分享一下Python函数的参数吧！内容会有点多~\nPython的函数定义比较简单，借助于关键字def进行实现，但是参数的灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数、可变参数、关键字参数、命名关键字参数以及参数组合，这使得函数定义出来的接口，不仅能处理复杂的参数，还能简化调用者的代码。\n\n一、位置参数\n在函数定义的时候，指定参数的位置顺序。位置参数必须在被调用函数定义中的准确顺序来进行传递。\n例如：计算x的n次方\ndef powern(x,n):\n    s = 1\n    while n >0:\n        s = s * x\n        n = n -1\n    return s\nx与n这两个参数都是位置参数。调用函数时，必须传入且传入的两个值按照位置顺序依次赋给参数x和n，若缺省，则会报错。例如：\n>>> powern(5)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: powern() missing 1 required positional argument: 'n'\n二、默认参数\n\n 在函数定义中，为参数预先定义默认值。当在函数调用时，若没有为参数提供指定值，则使用默认值。  例如：仍旧是求x的n次方，但是默认为x的3次方。\ndef powern( x,n = 3):\n    s = 1\n    while n >0:\n        s = s * x\n        n = n -1\n    return s\n执行：powern(2),相当于调用powern(2,3)如果要求2的四次方，则需要执行：powern(2,4)\n设置默认参数的好处？默认参数可以简化函数的调用，降低调用函数的难度。无论是简单调用还是复杂调用，函数只需定义一个。例如上述powern()的例子，当传入n的其他值时，则可以实现x的其他n次方。\n但是在使用默认参数的时候，如果使用不当，也会有坑。先来了解一下可变参数和不可变参数作为函数参数时的不同：\n不可变参数作为函数参数\n>>> a = 1\n>>> def func(a):\n...     print('func_id:',id(a))\n...     a = 2\n...     print('after_func_id:',id(a),'id(2):',id(2))\n...\n>>> print('out_of_func_id:',id(a),'id(1):',id(1))\nout_of_func_id: 501962480  id(1): 501962480   # 全局变量a的id\n>>> func(a)            # 将全局参数a传入函数\nfunc_id: 501962480    # a=1 的id\nafter_func_id: 501962496  id(2): 501962496  \n>>> print(a)            # 退出函数，a的值仍为1\n1\n当把全局a传递给函数后，函数自动复制一份引用。执行完a=2之后，id(a)的内存地址发生变化。但是跟外层的a没有关系。\n可变对象作为函数参数\n>>> a = []\n>>> def func2(a):\n...     print('func2_id:',id(a))\n...     a.append(1)\n...\n>>> print('out_of_func2_id',id(a))\nout_of_func2_id 59694296\n>>> func2(a)\nfunc2_id: 59694296\n>>> print(a)\n[1]\n变量a的类型为list，是可变对象。函数的引用指向的是可变对象，地址没有发生变化，所以函数操作后，a的内容发生了改变。所以当再次操作func2(a)函数时，产生跟预期不一样的结果：\n>>> func2(a)\nfunc2_id: 59694296    # a地址不变\n>>> print(a)\n[1, 1]        # 因为第一次执行func2(a)时，已经修改了a=[1]，再次调用时，在[1]里新增\n\n使用可变对象作为默认参数  例如：\ndef add_end( L=[] ):  # 设置为一个list变量L（对象可变）\n    L.append('end')\n    return L\n>>> add_end( )\n['end']\n>>> add_end()  \n['end', 'end']\n当连续重复使用默认参数调用时，结果出现错误。Python函数在定义的时候，默认参数L的值就被计算出来了，即[]。L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。可以改为：\ndef add_end( L=None ):  # L为不变对象  \n    if L is None:          \n    L = []            \n    L.append('end')   \n    return L      \n则无论调用多少次，都不会出现问题。所以，定义默认参数要牢记一点：默认参数必须指向不变对象！因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁。\n\n设置默认参数时，有几点需要注意  一．必选参数在前，默认参数在后，否则Python的解释器会报错。  二．如何设置默认参数？当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。  三．不要使用可变对象作为默认参数。\n三、可变参数*args \n可变参数，即传入的参数个数是可变的，0至任意个。因为参数个数不确定，则可以使用一个list 或者tuple传进来。之后在函数调用时会自动组装为一个tuple。例如：\ndef calc(numbers):  # 变量        \n    sum = 0               \n    for n in numbers:       \n        sum = sum + n * n   \n    return sum            \n>>> calc( [1,2,3] )   # 传入的是一个list\n14\n利用可变参数 *args：\ndef calc( *numbers ):  \n    sum = 0        \n    for n in numbers:    # 在函数内部，numbers组装成一个tuple\n    sum = sum + n * n\n    return sum\n>>> calc( )            # 0个参数  \n0\n>>> calc( 1,3,5,7 )    # 多个参数 \n84\n>>> num = [1,2,3]      # list\n>>> calc( *num )       # *list –> tuple\n14   \n>>> t = (1,3,5)\n>>> calc( t )          # tuple(错误)  \nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"<stdin>\", line 4, in calc\nTypeError: can't multiply sequence by non-int of type 'tuple'\n>>> calc( *t )                  \n35\n函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数。\n四、关键字参数**kw \n关键字参数**kw允许传入0个至任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。例如：\ndef person(name , age , **kw ):\n    print('name:',name,'age:',age,'other:',kw)\n>>> person('xiong',18)\nname: xiong age: 18 other: {}\n>>> person('xiong',18,city = 'SH')          # city是原本没有的参数，但是因为有**kw\nname: xiong age: 18 other: {'city': 'SH'}\n关键参数有什么用？可以扩展函数的功能。比如在person()函数里面，可以保证接收到name和age这两个参数。但是如果提供更多参数，也能收到。当然也可以先组装一个dict，再把该dict转换为关键字参数传递进去：\n>>> extra ={'city':'shanghai','job':'SET'}                     # dict的定义\n>>> person('xiong',18,city = extra['city'],job=extra['job'])   # dict的使用\nname: xiong age: 18 other: {'city': 'shanghai', 'job': 'SET'}  # dict的内容\n>>> person('xiong',18,**extra)\nname: xiong age: 18 other: {'city': 'shanghai', 'job': 'SET'}\n【总结】**extra表示把extra这个dict的所有key-value用关键字参数传入到函数的**kw参数，kw将获得一个dict，注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。\n五、命名关键字参数\n如果要限制关键字参数的名字，就可以用命名关键字参数。需要一个特殊分隔符“”，“”后面的参数被视为命名关键字参数。如果缺少“*”，Python解释器则无法识别位置参数和命名关键字参数。在调用时，必须指定参数名字与参数值。例如，只接收city和job作为关键字参数，可以使用如下定义：\ndef person( name ,age,*,city,job):\n    print(name , age , city , job )\n>>> person('xiong', 18, city='shanghai', job='tester')\nxiong 18 shanghai tester\n如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：\n>>> def person( name,age,*args,city,job ):     # 此处city和job也是命名关键字参数\n...   print(name, age, city, job)\n命名关键字参数必须传入参数名，如果没有传入参数名，调用将会报错：\n>>> person('xlp',18,'shanghai','tester')          # 错误调用 \nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: person() missing 2 required keyword-only arguments: 'city' and 'job'\n>>> person('xlp',18,city='shanghai',job='tester')  # 正确调用 \nxlp 18 shanghai tester\n命名关键字参数可以有缺省值，从而简化调用：\n>>> def person1(name,age,*,city='shanghai',job):\n...   print(name,age,city,job)\n...\n>>> person1('xlp',18,job='engineer')\nxlp 18 shanghai engineer\n六、参数组合\n在Python中定义函数，可以用位置参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是要注意，参数定义的顺序必须是：位置参数、默认参数、可变参数、命名关键字参数和关键字参数。\n【总结】\n（1）定义可变参数和关键字参数的语法：*args是可变参数，args接收的是一个list、tuple;**kw是关键字参数，kw接收的是一个dict；（2）调用函数时如何传入可变参数和关键字参数的语法：可变参数直接传入：func(1,2,3)可变参数间接传入：先组装成list或tuple，l=(1,2,3)，再通过args传入，func(l)关键字参数直接传入：func(a=1,b=2)关键字参数间接传入：先组装成dict，d={‘a’:1,’b’:2}，再通过kw传入，func(d)（3）命名关键字参数 是为了限制调用者可以传入的参数名，同时可以提供默认值。（4）定义命名的关键字参数在没有可变参数的情况下，不要忘记写分隔符*，否则定义的将是位置参数。\n\n❤ thanks for watching, keep on updating...\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "0"}