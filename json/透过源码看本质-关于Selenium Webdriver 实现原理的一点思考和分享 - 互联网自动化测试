{"title": "透过源码看本质-关于Selenium Webdriver 实现原理的一点思考和分享 - 互联网自动化测试 ", "index": "自动化测试,selenium,python", "content": "作为一名使用Selenium开发UI自动化多年的工程师，一直都对Selenium Webdriver的实现原理感觉不是很清楚。怎么就通过脚本控制浏览器进行各种操作了呢？相信很多Selenium的使用者也会有类似的疑惑。最近针对这个问题看了不少了文章和书籍，在加上一点自己的思考和整理，与大家一起分享，一起学习。文章中如果有不准确的地方，希望大家给予指正。\n结构\n想要使用Selenium实现自动化测试，主要需要三个东西。\n\n测试代码\nWebdriver\n浏览器\n\n测试代码\n测试代码就是程序员利用不同的语言和相应的selenium API库完成的代码。本文将以python为例进行说明。\nWebdriver\nWebdriver是针对不同的浏览器开发的，不同的浏览器有不同的webdriver。例如针对Chrome使用的chromedriver。\n浏览器\n浏览器和相应的Webdriver对应。\n首先我们来看一下这三个部分的关系。对于三个部分的关系模型，可以用一个日常生活中常见的例子来类比。\n对于打的这个行为来说，乘客和出租车司机进行交互，告诉出租车想去的目的地，出租车司机驾驶汽车把乘客送到目的地，这样乘客就乘坐出租车到达了自己想去的地方。这和Webdriver的实现原理是类似的，测试代码中包含了各种期望的对浏览器界面的操作，例如点击。测试代码通过给Webdriver发送指令，让Webdriver知道想要做的操作，而Webdriver根据这些操作在浏览器界面上进行控制，由此测试代码达到了在浏览器界面上操作的目的。理清了Selenium自动化测试三个重要组成之间的关系，接下来我们来具体分析其中一个最重要的关系。\n测试代码与Webdriver的交互\n接下来我会以获取界面元素这个基本的操作为例来分析两者之间的关系。在测试代码中，我们第一步要做的是新建一个webdriver类的对象：\nfrom selenium import webdriver\ndriver = webdriver.Chrome()\n这里新建的driver对象是一个webdriver.Chrome()类的对象，而webdriver.Chrome()类的本质是\nfrom .chrome.webdriver import WebDriver as Chrome\n也就是一个来自chrome的WebDriver类。这个.chrome.webdriver.WebDriver是继承了selenium.webdriver.remote.webdriver.WebDriver\nfrom selenium.webdriver.remote.webdriver import WebDriver as RemoteWebDriver\n...\nclass WebDriver(RemoteWebDriver):\n    \"\"\"\n    Controls the ChromeDriver and allows you to drive the browser.\n\n    You will need to download the ChromeDriver executable from\n    http://chromedriver.storage.googleapis.com/index.html\n    \"\"\"\n\n    def __init__(self, executable_path=\"chromedriver\", port=0,\n                 chrome_options=None, service_args=None,\n                 desired_capabilities=None, service_log_path=None):\n...\n以python为例，在selenium库中，通过ID获取界面元素的方法是这样的：\nfrom selenium import webdriver\ndriver = webdriver.Chrome()\ndriver.find_element_by_id(id)\nfind_elements_by_id是selenium.webdriver.remote.webdriver.WebDriver类的实例方法。在代码中，我们直接使用的其实不是selenium.webdriver.remote.webdriver.WebDriver这个类，而是针对各个浏览器的webdriver类，例如webdriver.Chrome()。所以说在测试代码中执行各种浏览器操作的方法其实都是selenium.webdriver.remote.webdriver.WebDriver类的实例方法。接下来我们再深入selenium.webdriver.remote.webdriver.WebDriver类来看看具体是如何实现例如find_element_by_id()的实例方法的。通过Source code可以看到：\n    def find_element(self, by=By.ID, value=None):\n        \"\"\"\n        'Private' method used by the find_element_by_* methods.\n\n        :Usage:\n            Use the corresponding find_element_by_* instead of this.\n\n        :rtype: WebElement\n        \"\"\"\n        if self.w3c:\n      ...\n        return self.execute(Command.FIND_ELEMENT, {\n            'using': by,\n            'value': value})['value']\n这个方法最后call了一个execute方法，方法的定义如下：\n    def execute(self, driver_command, params=None):\n        \"\"\"\n        Sends a command to be executed by a command.CommandExecutor.\n\n        :Args:\n         - driver_command: The name of the command to execute as a string.\n         - params: A dictionary of named parameters to send with the command.\n\n        :Returns:\n          The command's JSON response loaded into a dictionary object.\n        \"\"\"\n        if self.session_id is not None:\n            if not params:\n                params = {'sessionId': self.session_id}\n            elif 'sessionId' not in params:\n                params['sessionId'] = self.session_id\n\n        params = self._wrap_value(params)\n        response = self.command_executor.execute(driver_command, params)\n        if response:\n            self.error_handler.check_response(response)\n            response['value'] = self._unwrap_value(\n                response.get('value', None))\n            return response\n        # If the server doesn't send a response, assume the command was\n        # a success\n        return {'success': 0, 'value': None, 'sessionId': self.session_id}\n正如注释中提到的一样，其中的关键在于\nresponse = self.command_executor.execute(driver_command, params)\n一个名为command_executor的对象执行了execute方法。名为command_executor的对象是RemoteConnection类的对象，并且这个对象是在新建selenium.webdriver.remote.webdriver.WebDriver类对象的时候就完成赋值的self.command_executor = RemoteConnection(command_executor, keep_alive=keep_alive)。结合selenium.webdriver.remote.webdriver.WebDriver类的类注释来看：\nclass WebDriver(object):\n    \"\"\"\n    Controls a browser by sending commands to a remote server.\n    This server is expected to be running the WebDriver wire protocol\n    as defined at\n    https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol\n\n    :Attributes:\n     - session_id - String ID of the browser session started and controlled by this WebDriver.\n     - capabilities - Dictionaty of effective capabilities of this browser session as returned\n         by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities\n     - command_executor - remote_connection.RemoteConnection object used to execute commands.\n     - error_handler - errorhandler.ErrorHandler object used to handle errors.\n    \"\"\"\n\n    _web_element_cls = WebElement\n\n    def __init__(self, command_executor='http://127.0.0.1:4444/wd/hub',\n                 desired_capabilities=None, browser_profile=None, proxy=None,\n                 keep_alive=False, file_detector=None):\nWebDriver类的功能是通过给一个remote server发送指令来控制浏览器。而这个remote server是一个运行WebDriver wire protocol的server。而RemoteConnection类就是负责与Remote WebDriver server的连接的类。可以注意到有这么一个新建WebDriver类的对象时候的参数command_executor，默认值＝'http://127.0.0.1:4444/wd/hub'。这个值表示的是访问remote server的URL。因此这个值作为了RemoteConnection类的构造方法的参数，因为要连接remote server，URL是必须的。现在再来看RemoteConnection类的实例方法execute。\n    def execute(self, command, params):\n        \"\"\"\n        Send a command to the remote server.\n\n        Any path subtitutions required for the URL mapped to the command should be\n        included in the command parameters.\n\n        :Args:\n         - command - A string specifying the command to execute.\n         - params - A dictionary of named parameters to send with the command as\n           its JSON payload.\n        \"\"\"\n        command_info = self._commands[command]\n        assert command_info is not None, 'Unrecognised command %s' % command\n        data = utils.dump_json(params)\n        path = string.Template(command_info[1]).substitute(params)\n        url = '%s%s' % (self._url, path)\n        return self._request(command_info[0], url, body=data)\n这个方法有两个参数：\n\ncommand\nparams\n\ncommand表示期望执行的指令的名字。通过观察self._commands这个dict可以看到，self._commands存储了selenium.webdriver.remote.command.Command类里的常量指令和WebDriver wire protocol中定义的指令的对应关系。\nself._commands = {\n            Command.STATUS: ('GET', '/status'),\n            Command.NEW_SESSION: ('POST', '/session'),\n            Command.GET_ALL_SESSIONS: ('GET', '/sessions'),\n            Command.QUIT: ('DELETE', '/session/$sessionId'),\n...\n            Command.FIND_ELEMENT: ('POST', '/session/$sessionId/element'),\n以FIND_ELEMENT为例可以看到，指令的URL部分包含了几个组成部分：\n\nHTTP请求方法。WebDriver wire protocol中定义的指令是符合RESTful规范的，通过不同请求方法对应不同的指令操作。\n\nsessionId。Session的概念是这么定义的：\nThe server should maintain one browser per session. Commands sent to a session will be directed to the corresponding browser.\n也就是说sessionId表示了remote server和浏览器的一个会话，指令通过这个会话变成对于浏览器的一个操作。\n\n\nelement。这一部分用来表示具体的指令。\n\n而selenium.webdriver.remote.command.Command类里的常量指令又在各个具体的类似find_elements的实例方法中作为execute方法的参数来使用，这样就实现了selenium.webdriver.remote.webdriver.WebDriver类中实现各种操作的实例方法与WebDriver wire protocol中定义的指令的一一对应。而selenium.webdriver.remote.webelement.WebElement中各种在WebElement上的操作也是用类似的原理实现的。\n实例方法execute的另一个参数params则是用来保存指令的参数的，这个参数将转化为JSON格式，作为HTTP请求的body发送到remote server。remote server在执行完对浏览器的操作后得到的数据将作为HTTP Response的body返回给测试代码，测试代码经过解析处理后得到想要的数据。\nWebdriver与浏览器的关系\n这一部分属于各个浏览器开发者和Webdriver开发者的范畴，所以我们不需要太关注，我们所关心的主要还是测试代码和Webdriver的关系，就好像出租车驾驶员如何驾驶汽车我们不需要关心一样。\n总结\n最后通过这个关系图来简单的描述Selenium三个组成部分的关系。通过对python selenium库的分析，希望能够帮助大家对selenium和webdriver的实现原理有更进一步的了解，在日常的自动化脚本开发中更加快捷的定位问题和解决问题。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}