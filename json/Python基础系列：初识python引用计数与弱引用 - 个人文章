{"title": "Python基础系列：初识python引用计数与弱引用 - 个人文章 ", "index": "python", "content": "写在前边：\n之前的socket系列就告一段落，主要是对自己所学做一个总结与记录。\n接下来我打算基于libevent写一个支持并发的HTTP服务器。因为之前学习群里大神早就开发过一个同时支持HTTP与WebSocket的服务器，我看了之后感觉很有兴趣，所以才买了本网络编程的书来看。我打算参考他的来写一个精简版，\n只支持HTTP。等写完了可以分享给大家，虽然不能运用到生产环境，但是我相信学习完源码之后对于自己也是一个极大的提升。\n接下来进入主题：\n先放上实例代码：\n\n我们创建一个用于测试的x对象，包括一个构造函数和一个析构函数。\n第一次初始化x对象，并且用变量a来引用，所以这里的引用计数就为1。之后通过 getrefcount 来获取引用数量，这里变为了2，因为调用函数 getrefcount 本身也是对a的一次引用。\n接下来通过 weakref.ref() 创建一个弱引用，通过 getrefcount 打印引用计数后，发现计数并没有改变。\nw() is a 这句的意思是判断这两个实例是不是完全相同，也就是占用的内存地址是否相同。\n然后我们通过 del a 来解除a对x对象的引用，注意这里del并不是直接回收x对象，而是解除了引用，我们知道一旦一个变量的引用为0的时候就会被回收。所以调用del之后x对象被回收。\n通过之前的代码我们看到，调用弱引用的方式为类函数的方式。不过可以使用proxy来改为使用变量名的方式调用。\n\n到这里我相信对于弱引用的使用方式肯定都掌握了。但是弱引用到底有什么作用呢？\n与很多其它的高级语言一样，Python也有垃圾回收机制。每个对象都有一个引用计数，当这个计数为0的时候才能够安全地销毁这个对象。\n由于一次仅能有一个对象被回收，引用计数无法回收循环引用的对象。一组相互引用的对象若没有被其它对象直接引用，并且不可访问，则会永久存活下来。\n一个应用程序如果持续地产生这种不可访问的对象群组，就会发生内存泄漏。\n所以弱引用很适合处理这种循环引用的场景。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}