{"title": " eventlet 之 monkeypatch 带来的若干兼容性问题实例分析 - 心随风扬 ", "index": "python,eventlet", "content": "概述\n最近需要在一个基于nameko/eventlet的服务中集成grpc client, 遇到了一个monkeypatch带来的兼容性问题, 测试代码如下:\nimport eventlet\n\neventlet.monkey_patch(thread=True)\n\nimport threading\n\nfrom grpc._cython import cygrpc\n\n\nclass TestThread(threading.Thread):\n    def __init__(self):\n        threading.Thread.__init__(self)\n\n    def run(self):\n        completion_queue = cygrpc.CompletionQueue()\n        while True:\n            _ = completion_queue.poll()\n\n\nthreading._VERBOSE = True\nt = TestThread()\nt.start()\n\nprint('if thread is not patched, this message will be printed')\n\n当对thread模块patch之后, 进程卡在了t.start(), 只有按ctrl+c中断该线程之后, 程序才继续运行. 但如果不对thread进行patch, 线程start之后, 程序继续运行. 这是为什么呢?\n分析\n使用pdb进行调试, 分为两种情况:\n1. 对thread进行patch\n程序在switch之后切换到TestThread运行, 似乎就切换不回到主线程了!按下ctrl+c后TestThread才中断, 并在主线程继续运行.\n2. 不对thread进行patch\n在TestThread进入start之后, self.__started.wait()直接返回, 值得注意的是, 在start内部调用_start_new_thread就直接启动子线程, 并且直接返回了!\n结论\n可见monkeypatch修改了threading标准库中的_start_new_thread方法, Condition类等. 当patch之后,_start_new_thread方法并不直接启动线程, 而是返回一个greenlet, 在这个问题当中, grpc调用的是一个c extension中的threading pool, monkeypatch无法对这个extension进行patch, 导致了后来switch到这个greenlet中时其实是进入到另一个线程中. 因为greenlet无法在不同的线程中切换, 导致程序无法从TestThread切回来, 只有主动去中断TestThread, 才能被恢复.自从遇到了这个问题, 以后做项目的并发模型就更加慎重了:). 如果不清楚monkeypatch到底做了些什么, 在选择协程做python的底层并发模式时, 请三思.\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}