{"title": "线程锁 - python学习 ", "index": "python", "content": "线程锁\n线程中有两种锁\n\nLock\nRLock\n\n区别.\n这两种琐的主要区别是：RLock允许在同一线程中被多次acquire。而Lock却不允许这种情况。注意：如果使用RLock，那么acquire和release必须成对出现，即调用了n次acquire，必须调用n次的release才能真正释放所占用的琐。\n代码实例\nUsers in mainland China, if the Math option doesn't work for you, try if you can visit MathJax without VPN connected. If you can't, maybe it's blocked by the Great Firewall of China. Try connect to a VPN, climb over the wall, then the Math rendering should work.\n    # -*- coding:utf-8 -*-\n\"\"\" Created by FizLin on 2017/07/24/-下午6:32\n    mail: https://github.com/Fiz1994\n\n    线程thread lock\n    使用例子\n\n    线程中有两种锁\n    这两种琐的主要区别是：RLock允许在同一线程中被多次acquire。而Lock却不允许这种情况。注意：\n    如果使用RLock，那么acquire和release必须成对出现，即调用了n次acquire，必须调用n次的release才能真正释放所占用的琐。\n\"\"\"\nimport threading\nimport time\nimport logging\nimport random\n\nlogging.basicConfig(level=logging.DEBUG,\n                    format='(%(threadName)-9s) %(message)s', )\n\n\nclass Counter(object):\n    def __init__(self, start=0):\n        self.lock = threading.Lock()\n        self.value = start\n\n    def increment(self):\n        logging.debug('Waiting for a lock')\n        self.lock.acquire()\n        try:\n            logging.debug('Acquired a lock')\n            self.value = self.value + 1\n        finally:\n            logging.debug('Released a lock')\n            self.lock.release()\n\n\ndef worker(c):\n    for i in range(2):\n        r = random.random()\n        logging.debug('Sleeping %0.02f', r)\n        time.sleep(r)\n        c.increment()\n    logging.debug('Done')\n\n\nif __name__ == '__main__':\n    counter = Counter()\n    for i in range(2):\n        t = threading.Thread(target=worker, args=(counter,))\n        t.start()\n\n    logging.debug('Waiting for worker threads')\n    main_thread = threading.currentThread()\n    for t in threading.enumerate():\n        if t is not main_thread:\n            t.join()\n    logging.debug('Counter: %d', counter.value)\n\n\"\"\"\nRlock 的用处  多次使用锁， 例如递归，\n这里使用的是 with statments\n\nclass X:\n    def __init__(self):\n        self.a = 1\n        self.b = 2\n        self.lock = threading.RLock()\n\n    def changeA(self):\n        with self.lock:\n            self.a = self.a + 1\n\n    def changeB(self):\n        with self.lock:\n            self.b = self.b + self.a\n\n    def changeAandB(self):\n        # you can use chanceA and changeB threadsave!\n        with self.lock:\n            self.changeA() # a usual lock would block in here\n            self.changeB()\n            \n            \n            \n\"\"\"\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "2"}