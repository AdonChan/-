{"title": "tcp通信易错点罗列_续更 - python_易错点统计（续更） ", "index": "python", "content": "\n需求：\n编写C/S架构的程序，实现远程执行命令，思路如下        1、客户端接收用户输入的命令，然后发送给服务端，2、服务端根据传来的数据调用subprocess模块执行系统命令，然后将结果返回给客户端，在客户端打印\n\n错误实例（续更）\n错误归纳,续更,(正确示例请挪步下翻至底)：\n1、在客户端接受到服务端发送的报头，遗漏读取报头长度的错误：\nheader_bytes = client.recv(header_size)\n2、如下图，strcut解包时，得到结果为元组，应当使用索引取值。\n\nheader_size = struct.unpack('i',client.recv(4))[0]\n\n正确示例（不断完善中）\nclient.py\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# @Time    : 2018/04/20 14:51\n# @Author  : MJay_Lee\n# @File    : client.py\n# @Contact : limengjiejj@hotmail.com\n\nimport socket\nimport struct\nimport json\n\nclient = socket.socket(socket.AF_INET,socket.SOCK_STREAM)\nclient.connect(('127.0.0.1',8080))\n\nwhile True:\n    cmd = input('请输入通信内容>>:').strip()\n    client.send(cmd.encode('utf-8'))\n\n\n    header_size = struct.unpack('i',client.recv(4))[0]\n    header_bytes = client.recv(header_size)\n    header_json = header_bytes.decode('utf-8')\n    header_dic = json.loads(header_json)\n\n    total_size = header_dic['header_len']\n    recv_size = 0\n    res = b''\n\n    while recv_size < total_size:\n        recv_data = client.recv(1024)\n        res += recv_data\n        recv_size += len(recv_data)\n\n    print(res.decode('gbk'))\n\n# print('来自服务器的消息：',msg.decode('gbk'))\n\nclient.close()\nserver.py\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# @Time    : 2018/04/20 14:51\n# @Author  : MJay_Lee\n# @File    : Sever.py\n# @Contact : limengjiejj@hotmail.com\n\nimport socket\nimport subprocess\nimport json\nimport struct\n\nserver = socket.socket(socket.AF_INET,socket.SOCK_STREAM)\nserver.bind(('127.0.0.1',8080))\nserver.listen(5)\nprint('start...')\n\n# 循环连接\nwhile True:\n    conn,client_addr = server.accept()\n    print(client_addr,'接入服务器')\n    while True:\n        try:\n            msg = conn.recv(1024)\n            print('来自客户端的消息：', msg.decode('utf-8'))\n            obj = subprocess.Popen(msg.decode('utf-8'),\n                                   shell=True,\n                                   stdout=subprocess.PIPE,\n                                   stderr=subprocess.PIPE,\n                                   )\n            obj_stdout = obj.stdout.read()\n            obj_stderr = obj.stderr.read()\n            obj_len = len(obj_stdout) + len(obj_stderr)\n\n\n            header_dic = {\n                'header_len':obj_len\n            }\n\n            header_json = json.dumps(header_dic)\n            header_bytes = header_json.encode('utf-8')\n\n            # 先发送报头长度\n            header_size = len(header_bytes)\n            conn.send(struct.pack('i',header_size))\n\n            # 发送报头\n            conn.send(header_bytes)\n\n            conn.send(obj_stdout)\n            conn.send(obj_stderr)\n\n            # conn.send(msg+b'_accept')\n\n        except ConnectionResetError:\n            print(client_addr,'客户端中止链接')\n            break\n    conn.close()\nserver.close()\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}