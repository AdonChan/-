{"title": "一次使用 SQLAlchemy 实现分类以及计数的业务过程 - 个人文章 ", "index": "count,orm,sqlalchemy,mysql,python", "content": "在编写业务逻辑代码的时候, 我不幸遇到下面的表结构(已经将主要逻辑抽离出来了):\nclass Category(Model):\n    __tablename__ = 'category'\n    # 分类ID\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    # 分类名称\n    name = Column(String(length=255))\n    \nclass Product(Model):\n    __tablename__ = 'product'\n    # 产品 ID\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    # 产品名称\n    name = Column(String(length=255))\n    # 分类 ID\n    category_id = Column(Integer)\n现在需要实现的业务是返回分类的列表结果：\n[\n    {\n        \"id\": 1,\n        \"name\": \"分类1\",\n        \"product_count\": 1\n    },\n    ...\n]\n这是一个一对多的模型.一般的笨拙思路就是:\ndata = []\ncategorys = Category.query.all()\nfor category in categorys:\n    product_count = len(Product.query.filter(Product.category_id == category.id).all())\n    data.append({\n        'id': category.id,\n        'name': category.name,\n        'product_count': product_count\n    })\n明眼人一看就知道可以把len(Product.query.filter(Product.category_id == category.id).all())换成:\nproduct_count = Product.query.filter(Product.category_id == category.id).count()\n但是, 根据这篇文章:[Why is SQLAlchemy count() much slower than the raw query?](https://stackoverflow.com/que... 似乎这样写会有更好的性能:\nfrom sqlalchemy import func\nsession.query(func.count(Product.id)).filter(Product.category_id == category.id).scalar()\n但是, 稍微有点经验的人就会对上面的写法嗤之以鼻, 因为product_count是放在for category in categorys:里面的, 这意味着如果categorys有成千上万个, 就要发出成千上万个session.query(), 而数据库请求是在网络上的消耗, 请求时间相对较长, 有的数据库没有处理好连接池, 建立连接和断开连接又是一笔巨大的开销, 所以 query 的请求应该越少越好. 像上面这样把 query 放到 for 循环中显然是不明智的选择.于是有了下面一个请求的版本：\nresult = db.session.query(Product, Category) \\\n    .filter(Product.category_id == Category.id)\\\n    .order_by(Category.id).all()\nid_list = []\ndata = []\nfor product, category in result:\n    if category and product:\n        if category.id not in id_list:\n            id_list.append(category.id)\n            data.append({\n                'id': category.id,\n                'name': category.name,\n                'product_count': 0\n            })\n        idx = id_list.index(category.id)\n        data[idx]['product_count'] += 1  \n这样的写法十分难看, 而且同样没有合理利用 SQLAlchemy 的 count 函数. 于是改成:\nproduct_count = func.count(Product.id).label('count')\nresults = session.query(Category, product_count) \\\n    .join(Product, Product.category_id == Category.id) \\\n    .group_by(Category).all()\ndata = [\n    {\n        'id': category.id,\n        'name': category.name,\n        'product_count': porduct_count\n    } for category, product_count in results]\n不过这里还有一个问题, 就是如果先添加一个Category, 而属于这个Category下没有Product, 那么这个Category就不会出现在data里面, 所以join必须改成outerjoin. 即:\nresults = session.query(Category, product_count) \\\n    .outerjoin(Product, Product.category_id == Category.id) \\\n    .group_by(Category).all()\n需求又来了!!!现在考虑设计Product为伪删除模式, 即添加一个is_deleted属性判断Product是否被删除.那么count函数就不能简单地count(Product.id), 而是要同时判断Product.is_deleted是否为真和Product是否为None, 经过悉心研究, 发现使用func.nullif可以实现这个需求,即用下面的写法:\nproduct_count = func.count(func.nullif(Product.is_deleted.is_(False), False)).label('count')\nresults = session.query(Category, product_count) \\\n    .join(Product, Product.category_id == Category.id) \\\n    .group_by(Category).all()\ndata = [\n    {\n        'id': category.id,\n        'name': category.name,\n        'product_count': porduct_count\n    } for category, product_count in results]\n可见使用 ORM 有的时候还是需要考虑很多东西.\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "0"}