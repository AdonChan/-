{"title": "Python 学习笔记  关于协程 - 个人文章 ", "index": "python3.x,python", "content": "协程\n定义：协程是指一个过程，这个过程与调用方协作，产出由调用方提供的值。（协程中必定含有一条yield语句）\n协程与生成器类似，都是定义体内包含yield关键字的函数。不过，在协程中，yield通常出现在表达式的右边（例如，data = yield），可以产出值，也可以不产出。\n\n生成器不可以返回值，如果生成器中给return语句提供值，会抛出SyntaxError异常；\npython新引入yield from 语句，可以把复杂的生成器重构成小型的嵌套生成器，省去了大量样板代码。\n\n三个方法：\n\n. send() 方法，可以让调用方给协程发送数据，发送的数据会成为协程函数中 yield 表达式的值。\n.throw() 方法，可以让调用方抛出异常\n.close() 方法，可以让调用方终止协程\n\n四个状态：\n\n'GEN_CREATED'   等待开始执行\n'GEN_RUNNING'    解释器正在执行\n'GEN_SUSPENDED'    在yield表达式处暂停\n'GEN_CLOASED'     执行结束\n\n协程只能处于这四个状态中的一个，当前状态可以由 inspect.getgeneratorstate(...)函数获取\n因为send() 方法的参数会成为暂停的yield表达式的值，所以，仅当协程处于暂停状态时才能调用send()方法\n协程需要被预激，预激是通过next()函数进行\n给协程添加预激装饰器 functools.wraps()，可以省去协程的预激过程。\nyield from\n在生成器gen中使用yield from subgen()时，subgen()会得到当前的控制权，把产出的值传给gen的调用方，即调用方可以直接跳过gen控制subgen。当subgen得到控制权时，gen会阻塞，同时等待subgen终止。\n一个小例子：\ndef chain(*iters):\n    for iter in iters:\n        yield from iter\n\nlst_1 = 'abc'\nlst_2 = '987'\nprint(list(chain(lst_1, lst_2)))\n\n运行结果：\n['a', 'b', 'c', '9', '8', '7']\n\n这个例子还可以改写为：\ndef chain():\n    yield from 'abc'\n    yield from '987'\n\n输出结果是一样的。\nyield from 的主要功能是打开双向通道，把最外层的调用方与最内层的子生成器连接起来，这样，二者可以直接发送和产生值，甚至可以直接传入异常。\n一个复杂的例子，计算中学生的平均身高和体重：\nfrom collections import namedtuple\n\nResult = namedtuple('Result', 'count average')\n\n\n# 子生成器\ndef averager():  # <1>\n    total = 0.0\n    count = 0\n    average = None\n    while True:\n        term = yield  # <2>\n        if term is None:  # <3>\n            break\n        total += term\n        count += 1\n        average = total/count\n    return Result(count, average)  # <4>\n\n\n# 委派生成器\ndef grouper(results, key):  # <5>\n    while True:  # <6>\n        results[key] = yield from averager()  # <7>\n\n\n# 客户端代码，即调用端\ndef main(data):  # <8>\n    results = {}\n    for key, values in data.items():\n        group = grouper(results, key)  # <9>\n        next(group)  # <10>\n        for value in values:\n            group.send(value)  # <11>\n        group.send(None)  # important! <12>\n\n    # print(results)  # uncomment to debug\n    report(results)\n\n\n# 输出报告\ndef report(results):\n    for key, result in sorted(results.items()):\n        group, unit = key.split(';')\n        print('{:2} {:5} averaging {:.2f}{}'.format(\n              result.count, group, result.average, unit))\n\n\ndata = {\n    'girls;kg':\n        [40.9, 38.5, 44.3, 42.2, 45.2, 41.7, 44.5, 38.0, 40.6, 44.5],\n    'girls;m':\n        [1.6, 1.51, 1.4, 1.3, 1.41, 1.39, 1.33, 1.46, 1.45, 1.43],\n    'boys;kg':\n        [39.0, 40.8, 43.2, 40.8, 43.1, 38.6, 41.4, 40.6, 36.3],\n    'boys;m':\n        [1.38, 1.5, 1.32, 1.25, 1.37, 1.48, 1.25, 1.49, 1.46],\n}\n\n\nif __name__ == '__main__':\n    main(data)\n\n运行结果：\n 9 boys  averaging 40.42kg\n 9 boys  averaging 1.39m\n10 girls averaging 42.04kg\n10 girls averaging 1.43m\n\n委派生成器grouper()只是起到一个传输数据的作用，没有进行任何的数据处理。\n生成器中都有一个无限循环   while True:   这个无限循环表明，只要调用方不断把值发送给这个协程，它就会一直接收值，然后生成结果。该循环结束条件：\n\n调用方在协程上显式调用 .close() 方法，\n或者没有对协程的引用，而被垃圾回收程序回收时，这个协程才会终止。\n\n终止协程的方法\ngenerator.close()\n该方法致使生成器在暂停的 yield 表达式处抛出 GeneratorExit 异常。\n\n如果生成器处理了这个异常，生成器一定不能产生值，否则解释器会抛出RuntimeError异常。\n如果生成器没有处理这个异常，或者抛出StopIteration异常，即生成器已经运行到最后，调用方也不会报错。\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}