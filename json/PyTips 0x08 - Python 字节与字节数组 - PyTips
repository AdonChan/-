{"title": "PyTips 0x08 - Python 字节与字节数组 - PyTips ", "index": "pytips,python3.5,python", "content": "项目地址：https://git.io/pytips\n0x07 中介绍了 Python 中的字符串类型，字符串类型是对人类友好的符号，但计算机只认识一种符号，那就是二进制（binary）数，或者说是数字：\n\n上面这张图片来自 OpenCV，非常直观地解释了计算机处理的信息与我们看到的图像之间的关系。回到 Python 对字节和字节数组的定义：\nThe core built-in types for manipulating binary data are bytes and bytearray.\n1Byte of ASCII\n为了用计算机可以理解的数字描述人类使用的字符，我们需要一张数字与字符对应的表。我们都知道在计算机中 1 byte = 8bits，可以存储 0~255 共256个值，也就是说 1byte 最多可以表示 256 个字符，在最初的计算机世界中，256 足以容纳所有大小写英文字母和 0~9 阿拉伯数字以及一些常用的符号，于是就有了 ASCII 编码：\n\n在 Python 中创建字节与字符串类似，只不过需要在引号外面加一个前缀b：\nprint(b\"Python\")\npython = (b'P' b'y' b\"t\" b'o' b'n')\nprint(python)\nb'Python'\nb'Pyton'\n\nBytes 代表的是（二进制）数字的序列，只不过在是通过 ASCII 编码之后才是我们看到的字符形式，如果我们单独取出一个字节，它仍然是一个数字：\nprint(b\"Python\"[0])\n80\n\n我们可以用 b\"*\" 的形式创建一个字节类型，前提条件是这里的 * 必须是 ASCII 中可用的字符，否则将会超出限制：\nprint(b\"雨\")\n  File \"<ipython-input-3-1f95d71c6553>\", line 1\n    print(b\"雨\")\n         ^\nSyntaxError: bytes can only contain ASCII literal characters.\n\n错误提示说明：字节类型只能允许 ASCII 字符。\n0~127~255\n那么问题来了，我们发现上面的 ASCII 表里面所有的字符只占据了 [31, 127]，那对于这一范围之外的数字我们要怎么才能表示为字节类型？答案就是用特殊的转义符号\\x+十六进制数字 ：\nprint(b'\\xff'[0])\nprint(b'\\x24')\n255\nb'$'\n\n反过来我们也可以将数字（0~255）转变成转义后的字节类型：\nprint(bytes([24]))\nprint(bytes([36,36,36])) # 记住字节类型是一个序列\nb'\\x18'\nb'$$$'\n\n或者直接从十六进制得来：\nprint(bytes.fromhex(\"7b 7d\"))\n\n# 逆运算\nprint(b'{ }'.hex())\n\nint(b' '.hex(), base=16)\nb'{}'\n7b207d\n\n32\n\nencode\n字符串有 decode 方法，而字节有 encode 方法，我们这里先简单看一下 encode('ascii') 。对于给定的字符我们可以通过编码得到它在编码表里面的坐标（即码位），因此对字符进行encode('ascii')操作是找到其在 ASCII 中的位置：\nprint(\"$\".encode('ascii'))\nprint(\"$\".encode('ascii')[0])\nb'$'\n36\n\n也就是说字符 \"$\" （0x07中已经介绍过这是一个 Unicode 编码的字符）在 ASCII 中的位置就是 $（或者说36）。\n可是如果我们对一些奇怪的字符进行 ASCII 编码，就会发生：\nsnake = '?'\ntry:\n    snake.encode('ascii')\nexcept UnicodeEncodeError as err:\n    print(err)\n\n# 正确的做法应该是用 UTF-8 进行编码，因为字符串都是 UTF-8 的\nprint(snake.encode()) # utf-8 by default\n'ascii' codec can't encode character '\\U0001f40d' in position 0: ordinal not in range(128)\nb'\\xf0\\x9f\\x90\\x8d'\n\n于是就得到了我们最熟悉的错误：ordinal not in range(128)，至于为什么是 128，现在应该很好理解了吧！\n字节数组\n和字符串一样，字节类型也是不可变序列，而字节数组就是可变版本的字节，它们的关系就相当于list与tuple。\nba = bytearray(b'hello')\nba[0:1] = b'w'\nprint(ba)\nbytearray(b'wello')\n\n由于和字符串一样是序列类型，字节和字节数组可用的方法也类似，这里就不一一列举了。\n总结\n\n字节（字节数组）是二进制数据组成的序列，其中每个元素由8bit二进制即1byte亦即2位十六进制数亦亦即0~255组成；\n字节是计算机的语言，字符串是人类语言，它们之间通过编码表形成一一对应的关系；\n最小的 ASCII 编码表只需要一位字节，且只占用了其中 [31,127] 的码位；\n\n关于字节与字符串之间的关系，将在下一期[0x08]()详细介绍。\n参考\nPragmatic Unicode\n\n欢迎关注公众号 PyHub！\n\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "8"}