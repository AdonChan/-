{"title": "python高阶函数中一个容易犯的错 - 南山南 ", "index": "python3.x,python", "content": "问题\npython对函数式编程有一定的支持，具体表现在高级函数,map,reduce,filter,partial function等几个方面。在应用函数式编程中，需要关注函数式编程中的变量不变性，惰性计算等原则，否则容易踩到坑。\ndef f():\n   def num_gen():\n       x = 2\n       while True:\n           yield x\n           x+=1\n   l=num_gen()\n   while True:\n       n = next(l)\n       yield n\n       l = filter(lambda x:x%n!=0,l)\nprimes = f()\nfor i in primes:\n    print(i)\n这段代码本意在于返回一个素数列表，但实际在运行中返回的并不是想要的。究其原因，在于filter的惰性计算以及lambda匿名函数的闭包特性。上面的代码中，n是一个变量，lambda匿名函数只有在next(f())时才会真正调用，而此时，n的值已经是当前n的值，而不是之前的值了，比如9，应当是3的倍数，但此时n的值并不是3，导致9%n>0成立。\n要修改这段代码，一个方法是利用lambda的闭包，避开n变量，生成一个和n无关的函数。\ndef f():\n   def g(n):\n       return lambda x:x%n!=0\n   def num_gen():\n       x = 2\n       while True:\n           yield x\n           x+=1\n   l = num_gen()\n   while True:\n       n = next(l)\n       yield n\n       l = filter(g(n),l)\nprimes = f()\nfor i in primes:\n    print(i)\n这样修改后，g(n)是实时调用的，返回一个和n无关的函数，这样在next惰性调用时，就不会出错。\n总结\n类似的错误在返回函数的高阶函数中也容易出错，如果返回的函数和一个变量绑定了，就会出现问题，解决的方法都是一样，增加一个闭包函数，使得返回函数和变量无关。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "4"}