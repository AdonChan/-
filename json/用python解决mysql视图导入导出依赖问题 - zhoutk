{"title": "用python解决mysql视图导入导出依赖问题 - zhoutk ", "index": "navicat,视图,view,mysql,python", "content": "navicat是mysql可视化工具中最棒的，但是，在处理视图的导入导出方面，它是按照视图名称的字母顺序来处理的，若视图存在依赖，在导入过程中就会报错。这个问题一直困绕我，一度因为我使用docker来部署mysql而绕过了这个问题。最近不得不直面这个问题，因此，写了一个小工具来解决它。\n整体思路\n在mysql很容易查出所有视图和其定义，因此可以写一个视图导出工具，存储时对各视图的保存位置进行调整，处理好它们之间的依赖关系，被依赖的放前面，这样就解决了导入时的依赖问题。\n获取视图信息\n运行以下查询语句，就能获得该数据库中所有视图的信息。\nselect * from  information_schema.VIEWS where TABLE_SCHEMA = DatabaseName \n查询结果字段说明：\n\nTABLE_NAME ： 数所库中视图名称\nVIEW_DEFINITION ： 视图的定义代码，只有查询语句部分\nDEFINER ： 视图定义（建立）者名称\nSECURITY ： 安全级别\n\n总之，所有视图的信息都在这个表中保存，我要完成任务，只需要TABLE_NAME和VIEW_DEFINITION就可以了。\n算法描述\n\n将查询结果放到dict中，视图名称为key；视图定义为value；\n\n编写处理依赖关系的函数process_rely，输入参数中的rely_old为保存所有视图名称的数组；返回参数为按依赖关系调整顺序后的视图名称数组。之所以这样做，是一开始考虑到，依赖关系复杂时，可能一次迭代处理不好，需要递归调用或多次调用。\nprocess_rely函数算法描述：\n\n\n第一层循环，从rely_old中取一个视图名称\n\n\n第二层循环，从dict中取出一个键值\n\n若键值被第一层元素的定义所依赖\n\n\n若键值还不在结果数组中\n\n\n若第一层元素不在结果数组中\n追加键值到结果数组中\n\n\n第一层元素在结果数组中\n将键值插入到第一层元素前\n\n\n\n\n键值在结果数组中\n\n第一层元素在结果数组中\n\n查找各自在结果数组中的位置\n\n若第一层元素在键值的后\n将键值移动到第一层元素前\n\n\n\n\n\n\n\n\n第二层循环结束时，若第一层元素还不在结果集中\n将第一层元素追加到结果集中\n\n\n\n返回结果集\n\n\n\n上面的说明，是按python代码模式给出的。很幸运，算法一次就能将复杂的依赖关系处理好了。我在编写的过程中，刚开始依赖算法不完善时，通过多次迭代也能处理好复杂的依赖关系。因此，坚定了必胜的信心，完成了这个任务。\n完整代码\nimport pymysql\nconn = pymysql.connect(host='172.17.0.1', port=3306, user='root',\n                       passwd='123456', db='database', charset='utf8mb4')\n\n\ndef process_rely(parmas={}, rely_old=[]):\n    _rely = []\n    _keys = list(parmas.keys())\n    for k in rely_old:\n        for bl in _keys:\n            if str(parmas[k]).find(bl) > -1:\n                if bl not in _rely:\n                    if k not in _rely:\n                        _rely.append(bl)\n                    else:\n                        i = _rely.index(k)\n                        _rely.insert(i, bl)\n                else:\n                    if k in _rely:\n                        i = _rely.index(k)\n                        j = _rely.index(bl)\n                        if i < j:\n                            del _rely[j]\n                            _rely.insert(i, bl)\n        if k not in _rely:\n            _rely.append(k)\n    return _rely\n\n\ncur = conn.cursor()\ncur.execute('select TABLE_NAME, VIEW_DEFINITION from  information_schema.VIEWS where TABLE_SCHEMA = %s ', 'database')\nrs = cur.fetchall()\ncur.close()\nconn.close()\n\nps = {}\nfor al in rs:\n    ps['`' + al[0] + '`'] = al[1]\n\nrely = process_rely(ps, list(ps.keys()))\n# rely = process_rely(ps, rely1)\n\nfile_object = open('view.sql', 'w')\nfor al in rely:\n    file_object.write('DROP VIEW IF EXISTS ' + al + ';\\n')\n    file_object.write('CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`%` SQL SECURITY DEFINER VIEW ' + al +\n                      ' AS ' + ps[al] + ';\\n\\n')\n\nfile_object.close()\n小结\n思路要清晰，代码要一步步的向最终目标靠近，积跬步以至千里。在做这个工具时，一开始觉得很麻烦，依赖关系若是深层次的，可能一次处理不好，正因为采用的迭代的思想，最后才完成了一次迭代解决问题的完美结局。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "2"}