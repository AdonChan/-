{"title": "python面试题之“该死的for循环系列”（一） ", "index": "python 迭代器 生成器 面试题", "content": "这是一道魔性面试题，难倒了无数英雄好汉……\ndef add(n,i):\n    return n+i\n\ndef test():\n    for i in range(4):\n        yield i\n\ng=test()\nfor n in [1,10]:\n    g=(add(n,i) for i in g)\nprint(n)\nprint(list(g))\n10\n[20, 21, 22, 23]\n\n上面代码的执行顺序是这样的：从上到下：\n第一个函数add就是实现了一个简单的加法运算\n第二个函数test是一个生成器函数，如果调用它会返回一个生成器\ng=test(),这一行调用了生成器函数，所以此刻g就是一个生成器(它的本质还是迭代器)\n然后执行for循环，这里迷惑人的就是这个for循环，为了减少它的魔性，我们把for循环拆开来看：\n    当n = 1时：\n    执行了：g=(add(n,i) for i in g)\n    当n = 10时：\n    执行了：g=(add(n,i) for i in g)\n    \n乍一看这两行代码还是有点迷糊，但是我们要知道，生成器有个最大的特性就是惰性，当你不进行迭代时它就不进行运算，想要对生成器进行迭代有以下几种方法：   第一种：for循环，for循环的本质就是调用了iter和next方法进行了迭代   第二种：调用next方法   第三种：调用send方法   第四种：数据类型强制转换，比如使用list()强制转换。   只要没有以上四种方法进行迭代，那么生成器就没有进行运算，所以在上面的for循环中无论是n=1时还是n=10时，生成器 g 都没有参与运算，\n当n = 1时，g=(add(n,i) for i in g)，这个表达式的结果g 就是一个表达式，没有进行运算，g的值就是一个表达式(add(n,i) for i in g)，括号里面的g实际上是test()，所以g = (add(n,i) for i in test())，仅此而已        当n = 10时，g=(add(n,i) for i in g)，把n=1时的g的结果带入进去就是g=(add(n,i) for i in (add(n,i) for i in test()))\n当整段代码执行到print(list(g))语句之前，g的值就是一段代码，或者你可以称之为算法，没有进行任何运算，里面的n就是n,g就是g不过此时因为代码是按照流程执行的，并且for循环已经执行完毕，所以n的值等于10\n当执行print(list(g))语句时，生成器才开始输出数据，此时执行最后一个g的赋值语句:g=(add(n,i) for i in (add(n,i) for i in test()))这时 n 的值等于10（因为代码是按照流程执行的，for循环已经执行完了，n的最终结果就是10），其中后面的(add(n,i) for i in test())这段代码的结果依然是个生成器，迭代后应为[10,11,12,13]，所以最终的结果可以理解成：(add(n,i) for i in [10,11,12,13])，所以最终结果为：20,21,22,23\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "2"}