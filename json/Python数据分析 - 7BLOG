{"title": "Python数据分析 - 7BLOG ", "index": "python", "content": "前面\nPython作为一种弱类型语言，虽身带高效开发的BUFF，但同时也有着不出众的运行性能。由于数据类型的判断是在解释器内部进行，所以对于每一个变量操作后都要重新判断数据类型，这势必增加解释器的负担。为了解决这一矛盾，同时扩充Python数据类型，numpy（以下简称np）就应运而生了。np不仅提供了诸如整数数组，线性方程、矩阵的相关数据类型，还可以进行一系列的操作运算，同时由于底层代码用C编写的，所以运行起来性能也不错。在数据分析、大数据、机器学习，神经网络方面都可以看到np的身影。在学习np之前，先来补充python的其它常用数据技巧：\n数组解压\n>>>list1 = [1,2,3,4,['a','b','c']]\n>>>var1, var2, var3, var4, vars1 = list1\n1 2 3 4 ['a', 'b', 'c', 'd']\n通过上面这种方法可以使用多个变量去接收一个list（或者tuple）结构。当然，我们知道Python可以使用星号+变量名来将多出的元素保存到一个元组中：\n>>>*vars1, var1 = list\n>>>vars1, var1\n([1, 2, 3, 4], ['a', 'b', 'c', 'd'])\n可以看出使用星号后，只会为list最后几个元素保留，其它元素都归星号的元素接收，以下写法更加明显：\n>>>var1,*vars1 = list1\n>>>var1,*vars1\n(1, 2, 3, 4, ['a', 'b', 'c', 'd'])\n继续多分配几个数组：\n>>>var1,var2,var3,*vars1 = list1\n>>>var1,var2,var3,vars1\n(1, 2, 3, [4, ['a', 'b', 'c', 'd']])\n可以看出星号所包含的变量总会在最后被分配。这个方法有什么实用意义呢，比如有以下字符串：\n'By777:20:Python:Linux:Web'\n可以使用上面的方式来提取有用的信息：\n>>>str = 'By777:20:Python:Linux:Web'\n>>>name, age, *tools = str.split(':')\n定长列表\n定长列表常常用来处理消息队列，作用类似于栈，我们可以使用下面方式来很方便的使用消息队列：\n>>>from collections import deque\ndeque可以看作list的加强版本，可以设置最大长度：\n>>>d = deque(maxlen=10)\n>>>for i in range(12):d.append(i)\n>>>d\ndeque([2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n可以看出第11个元素将第一个元素1压了出去。当然我们还可以使用appendleft方法逆向压入构建逆序。\n元素查找\n有以下列表：\n>>>list2 =list(range(5))\n>>>list2\n[0, 1, 2, 3, 4]\n我们可以使用heapq库进行信息提取：\n>>>import heapq\n>>>heapq.nlargest(3,list2)\n[4, 3, 2]\n除此之外，我们还可以定义一个函数：\n>>>def myfun(c):\n>>>if c>50:\n>>>    return c**0.5\n>>>return c\n>>>heapq.nlargest(2,list2,key=myfun)\n[4, 3]\n这样，将会使用list中的数以key的返回值作为判断依据。\n多值映射\n>>>from collections import defaultdict\n>>>d = defaultdict(list)\n>>>d\ndefaultdir(list,{})\n这样我们就构建了一个默认的key对应values默认为list类型的字典  那么我们就可以继续进行赋值操作：\n >>>d['a'].append(1)\n >>>d\ndefaultdict(list, {'a': [1]})\n……\n>>>d\ndefaultdict(list, {'a': [1, 1, 2]})\n同样，也可以定义为set类型：\n>>>d_set = defaultdict(set, {})\n>>>d_set['a'].add(1)\n >>>d_set\n defaultdict(set, {'a': {1}})\n有序字典\n>>>from collections import OrderedDict\n使用有序字典的好处是的键值的顺序是按照添加的顺序进行的：\n>>>od = OrderedDict()\n>>>od['a'] = 1\n>>>od['c'] = 3\n>>>od['d'] = 2\n>>>od\nOrderedDict([('a', 1), ('c', 3), ('d', 2)])    \n如果使用默认字典对比明显：\n>>>d = {}\n >>>d['a'] = 1\n >>>d['c'] = 2\n >>>d['b'] = 3\n >>>d\n{'a': 1, 'b': 3, 'c': 2}\n字典运算\nPython原生字典是可以进行诸如+、-、&、min、zip等运算的：但是原生字典和OrderedDict不能直接运算：\n>>>d_cm -od\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n<ipython-input-81-3c5177967520> in <module>()\n----> 1 d_cm -od\nTypeError: unsupported operand type(s) for -: 'dict' and 'collections.OrderedDict'\n我们要使用items方法：\n>>>d_cm.items() - od.items()#只存在与d_cm不存在与od的元素\n{('bar', 2), ('foo', 1), ('script', 3), ('test', 4)}\n>>>d_cm.keys() & od.keys()\n此外，还有一下操作：\n>>>d_cm = {'bar':2,'foo':1,'script':3}\n>>>min(d_cm,key=lambda k:d_cm[k])#需要通过函数\n'foo'\n>>>sorted (d_cm,key=lambda k\n['foo', 'bar', 'script']\n>>>min(zip(d_cm.values(),d_cm.keys()))\n(1, 'foo')\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "3"}