{"title": "Python3标准库built-in、itertools、functools中的生成器 - 个人文章 ", "index": "python3.5,python", "content": "介绍\nPython3中实现了很多生成器函数，本篇主要介绍built-in、itertools、functools模块中的生成器。\n过滤器生成器\n本类生成器函数将iterable对象作为参数，在不改变该iterable对象的条件下，返回iterable子集的生成器对象。\nfilter(predicate,  iterable)\niterable的每一个元素会传入predicate函数中判断是否为True，该生成器会返回所有返回为True的元素组成的生成器对象。\ndef is_vowel(c):\n    return c.lower() in 'aeiou'\n    \nword = 'abcdefghijk'\nprint(list(filter(is_vowel, word)))\n## output: ['a', 'e', 'i']\nfilter会过滤掉word中所有非元音字母，返回符合元素组成的生成器对象。注意：通过list(generator)可以将生成器对象转换为列表，但如果是无限生成器list将会产生大量元素导致出错。filter函数等同于下面的生成器表达式用法。\n(item for item in iterable if function(item))\n如果filter的第一个参数为None，则不过滤返回全部，等同于下面的生成器表达式用法。\n(item for item in iterable if item)\nitertools.filterfalse(predicate, iterable)\n该函数和filter类似，区别是过滤掉predicate返回True的元素。\nprint(list(itertools.filterfalse(is_vowel, word)))\n## output: ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k']\nitertools.takewhile(predicate, iterable)\n该函数连续迭代iterable对象中的元素，并用predicate函数判断，若predicate返回为True，将不断产出该元素，直到predicate返回False，过滤了iterable后面不符合的元素。\nprint(list(itertools.takewhile(is_vowel, word)))\n## output: ['a']\nitertools.dropwhile(predicate, iterable)\n该函数与itertools.takewhile相反，过滤了iterable对象前面符合predicate返回True的元素，保留后面的子集。\nprint(list(itertools.dropwhile(is_vowel, word)))\n## output: ['b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k']\nitertools.compress(iterable, selectors)\n该函数中的selectors也是一个迭代对象，compress根绝selectors中的值(0/1或是True/False)判断是否过滤iterable中的元素。\nprint(list(itertools.compress(word, [1, 0, 1, 0])))\n## output: ['a', 'c']\n如果selectors长度不够，则iterable后面的对象全部被过滤掉。\nitertools.islice(iterable, stop)\n根据传入参数的个数不同，该函数另一种写法是itertools.islice(iterable, start, stop[, step])，islice函数类似python中的分片操作：list[start:stop:step]。\nprint(list(itertools.islice(word, 4)))\n## output: ['a', 'b', 'c', 'd']\nprint(list(itertools.islice(word, 4, 8)))\n## output: ['e', 'f', 'g', 'h']\nprint(list(itertools.islice(word, 4, 8, 2)))\n## output: ['e', 'g']\n映射生成器\n该类生成器主要对于传入的一个或多个迭代对象中的每一个元素进行操作，返回映射后的生成器对象。\nmap(func, *iterables, timeout=None, chunksize=1)\nmap是Python中常用的原生生成器，将迭代对象中的每一个元素传入func进行映射返回新的迭代对象。如果有n个iterable对象，则func的参数则为n个，后面的timeout和chunksize参数涉及到异步，本篇将不阐述。\nprint(list(map(lambda x: x.upper(), word)))\nprint([x.upper() for x in word])\n## output: ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K']\n上面第一行中的map将word中的每个元素转换为大写，和第二行中的列表生成式用法相似。\nprint(list(map(lambda x, y: (x, y), word, word)))\nprint(list(zip(word, word)))\n## output: [('a', 'a'), ('b', 'b'), ('c', 'c') ... ('k', 'k')]\n当有两个iterable传入时，func将需要处理传入的两个参数，第一行的用法和zip函数的作用相似。\nitertools.starmap(function, iterable)\n当iterable中的元素也是个迭代对象时，如果使用map函数，需要在函数内部实现解压操作获取到单个元素，而startmap将iterable中的元素按function(*item)方式传入，我们可以在定义function的参数时完成解压操作。举例，如果想输入序列[(2,5), (3,2), (10,3)]来得到一个每个元组元素的和的序列[7, 5, 13], 若使用map方法，fun函数将会复杂，而使用startmap则只需要传递一个add函数作为startmap参数，元组解压后的两个值将传入add函数作为参数。\nfrom operator import add\nprint(list(map(lambda x: add(x[0], x[1]), [(2, 5), (3, 2), (10, 3)])))\nprint(list(itertools.starmap(add, [(2, 5), (3, 2), (10, 3)])))\n## output: [7, 5, 13]\nenumerate(iterable, start=0)\nenumerate函数也是常见的生成器函数，它的主要用法是提供for-in循环中的索引。若设置start参数，索引将从start值开始逐1增加。\nfor i, c in enumerate(word, 2):\n    print(i, c)\nitertools.accumulate(iterable[, func])\naccumulate函数将通过func函数完成逐步累加操作，默认func为operator.add。下面用例子进行说明。\nsample = [1, 2, 3, 4, 5]\nprint(list(itertools.accumulate(sample)))\n## output: [1, 3, 6, 10, 15]\nprint(list(itertools.accumulate(sample, mul)))\n## output: [1, 2, 6, 24, 120]\nprint(list(itertools.accumulate(sample, mul)))\n## output: [1, 2, 6, 24, 120]\nprint(list(itertools.accumulate(sample, min)))\n## output: [1, 1, 1, 1, 1]\nprint(list(itertools.accumulate(sample, max)))\n## output: [1, 2, 3, 4, 5]\nprint(list(itertools.starmap(lambda x, y: y/x, \n                             enumerate(itertools.accumulate(sample), 1))))\n## output: [1.0, 1.5, 2.0, 2.5, 3.0]\n合并生成器\n合并生成器接收多个可迭代对象参数，将他们组合后返回新的生成器对象。\nitertools.chain(*iterables)\nchain生成器函数接收多个可迭代对象参数，将他们按顺序组合成新的生成器对象返回。\nprint(list(itertools.chain(range(3), range(3, 7))))\n## output: [0, 1, 2, 3, 4, 5, 6]\nitertools.chain.from_iterable(iterable)\nchain.from_iterable函数接收一个元素为可迭对象的可迭代对象，将该所有可迭代的元素拆开，重新按顺序组合成一个新的生成器，新的生成器产出的元素为iterable参数某个元素的解压，chain.from_iterable功能更像是逐层解压迭代对象。\na, b = [1,2], [3,4]\niterable= [[a,b],[a,b]]\nprint(iterable)\nnew_iterable = list(itertools.chain.from_iterable(iterable))\nprint(new_iterable)\nprint(list(itertools.chain.from_iterable(new_iterable)))\n## output:\n## [[[1, 2], [3, 4]], [[1, 2], [3, 4]]]\n## [[1, 2], [3, 4], [1, 2], [3, 4]]\n## [1, 2, 3, 4, 1, 2, 3, 4]\nzip(*iterables)\nzip函数接收多个iterable参数，并提取每个iterable元素组成元组，返回这些元组组成的生成器对象。\niterable1 = 'abcd'\niterable2 = [1, 2, 3]\niterable3 = [10, 20, 30, 40]\nprint(list(zip(iterable1, iterable2, iterable3)))\n## output:\n## [('a', 1, 10), ('b', 2, 20), ('c', 3, 30)]\n如果多个iterable元素个数不一致，zip会在最短的iterable耗尽后停止。我们可以通过zip函数生成一个字典对象\nkeys = 'abc'\nvalues = [1, 2, 3]\nprint(dict(zip(keys, values)))\n## output: {'a': 1, 'b': 2, 'c': 3}\nitertools.zip_longest(*iterables, fillvalue=None)\nzip_longes函数作用和zip类似，在zip中如果某个iterable对象耗尽，生成器将就此停止，而zip_longest函数将为耗尽的iterable补充fillvalue值。\niterable1 = 'abcd'\niterable2 = [1, 2, 3]\niterable3 = [10, 20, 30, 40]\nprint(list(itertools.zip_longest(iterable1, iterable2, iterable3, fillvalue=0)))\n## output: [('a', 1, 10), ('b', 2, 20), ('c', 3, 30), ('d', 0, 40)]\nitertools.product(*iterables, repeat=1)\nproduct函数计算所有iterable的笛卡尔积，它像是生成器表达式中处理嵌套循环的步骤，product(a, b)可以等同于((x, y) for x in a for y in b)。repeat相当于扩展了iterables, product(a, b, repeat=2)相当于product(a, b, a, b)\na = (0, 1)\nb = (2, 3)\nprint(list(itertools.product(a, b)))\nprint(list(itertools.product(a, repeat=2)))\n\n## output:\n## [(0, 2), (0, 3), (1, 2), (1, 3)]\n## [(0, 0), (0, 1), (1, 0), (1, 1)]\n扩展生成器\n扩展生成器将传进的单一对象进行扩展，生成更多元素组成的生成器对象。\nitertools.repeat(object[, times])\nrepeat函数可以接收一个对象(可以不是可迭代对象), 根据非必选参数times，生成元素个数为times的生成器，如果不提供times参数，将生成无限生成器。\nprint(list(itertools.repeat(1, 3)))\nprint(list(itertools.repeat((1, 2), 3)))\nprint(list(zip(range(1, 4), itertools.repeat('a'))))\nprint([1, 2] * 3)\n\n\"\"\"output:\n[1, 1, 1]\n[(1, 2), (1, 2), (1, 2)]\n[(1, 'a'), (2, 'a'), (3, 'a')]\n[1, 2, 1, 2, 1, 2]\n\"\"\"\n注意repeat()和列表乘法的区别，通过上文提到的itertools.chain.from_iterable函数结合repeat函数可以实现列表乘法。\nlst = [1, 2, 3]\ng = itertools.repeat(lst, 3)\nprint(list(itertools.chain.from_iterable(g)))\nprint(lst * 3)\n\"\"\"output\n[1, 2, 3, 1, 2, 3, 1, 2, 3]\n[1, 2, 3, 1, 2, 3, 1, 2, 3]\n\"\"\"\nitertools.cycle(iterable)\ncycle函数将传进的iterable可迭代对象首尾相连形成循环，生成无限生成器。\n# cycle('ABCD') --> A B C D A B C D A B C D ...\nitertools.count(start=0, step=1)\n计数器函数，start和step参数可以为小数，直接看例子。\ng = itertools.count(1.2, 2.5)\nprint(next(g))\nprint(next(g))\nprint(next(g))\n\"\"\"output:\n1.2\n3.7\n6.2\n\"\"\"\n上文提到的enumerate生成器函数可以通过map和count来实现。\nfor i, v in map(lambda x, y: (x, y), itertools.count(), range(3, 10)):\n    print(i, v)\n我们可以通过调整count函数让索引i的值更加灵活。Python中的range(start, stop[, step])函数可以生成一个序列，但是要求输入参数必须为整数，可以通过count函数实现一个可以接收小数的新range。\ndef range_new(start, stop, step):\n    for i in itertools.count(start, step):\n        if i >= stop:\n            break\n        yield i\n\nprint(list(range_new(1, 5.5, 1.5)))\n## output: [1, 2.5, 4.0]\n排列组合生成器\n以下三个函数可以实现迭代对象的排列组合itertools.combinations(iterable, r) 非重复组合\nprint(list(itertools.combinations('ABC', 1)))\nprint(list(itertools.combinations('ABC', 2)))\nprint(list(itertools.combinations('ABC', 3)))\n\"\"\"output:\n[('A',), ('B',), ('C',)]\n[('A', 'B'), ('A', 'C'), ('B', 'C')]\n[('A', 'B', 'C')]\n\"\"\"\nitertools.combinations_with_replacement(iterable, r)重复组合\nprint(list(itertools.combinations_with_replacement('ABC', 1)))\nprint(list(itertools.combinations_with_replacement('ABC', 2)))\nprint(list(itertools.combinations_with_replacement('ABC', 3)))\n\"\"\"output:\n[('A',), ('B',), ('C',)]\n[('A', 'A'), ('A', 'B'), ('A', 'C'), ('B', 'B'), ('B', 'C'), ('C', 'C')]\n[('A', 'A', 'A'), ('A', 'A', 'B'), ('A', 'A', 'C'), ('A', 'B', 'B'), ('A', 'B', 'C'), ('A', 'C', 'C'), ('B', 'B', 'B'), ('B', 'B', 'C'), ('B', 'C', 'C'), ('C', 'C', 'C')]\n\"\"\"\nitertools.permutations(iterable, r=None)全排列\nprint(list(itertools.permutations('ABC', 1)))\nprint(list(itertools.permutations('ABC', 2)))\nprint(list(itertools.permutations('ABC', 3)))\n\"\"\"output:\n[('A',), ('B',), ('C',)]\n[('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'C'), ('C', 'A'), ('C', 'B')]\n[('A', 'B', 'C'), ('A', 'C', 'B'), ('B', 'A', 'C'), ('B', 'C', 'A'), ('C', 'A', 'B'), ('C', 'B', 'A')]\n\"\"\"\n对比itertools.product(*iterables, repeat=1)函数\nprint(list(itertools.product('ABC', repeat=1)))\nprint(list(itertools.product('ABC', repeat=2)))\n\"\"\"output:\n[('A',), ('B',), ('C',)]\n[('A', 'A'), ('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'B'), ('B', 'C'), ('C', 'A'), ('C', 'B'), ('C', 'C')]\n\"\"\"\n整理生成器\n此类生成器将传入的可迭代对象经过整理后，以生成器的形式全部返回。\nitertools.groupby(iterable, key=None)\ngroupby生成器可以根据key，将iterable分组，返回的生成器的元素为(key, iterable)的元组形式。扫描整个序列并且查找连续相同值（或者根据指定 key 函数返回值相同）的元素序列。 在每次迭代的时候，它会返回一个值和一个迭代器对象， 这个迭代器对象可以生成元素值全部等于上面那个值的组中所有对象。\ng = itertools.groupby('LLLLAAGGG')\nfor char, group in g:\n    print(char, '->', list(group))\n\n\"\"\"output:\nL -> ['L', 'L', 'L', 'L']\nA -> ['A', 'A']\nG -> ['G', 'G', 'G']\n\"\"\"\n\nrows = [\n    {'address': '5412 N CLARK', 'date': '07/01/2012'},\n    {'address': '5148 N CLARK', 'date': '07/04/2012'},\n    {'address': '5800 E 58TH', 'date': '07/02/2012'},\n    {'address': '2122 N CLARK', 'date': '07/03/2012'},\n    {'address': '5645 N RAVENSWOOD', 'date': '07/02/2012'},\n    {'address': '1060 W ADDISON', 'date': '07/02/2012'},\n    {'address': '4801 N BROADWAY', 'date': '07/01/2012'},\n    {'address': '1039 W GRANVILLE', 'date': '07/04/2012'},\n]\n\nrows.sort(key=itemgetter('date'))\ng = itertools.groupby(rows, itemgetter('date'))\nfor char, group in g:\n    print(char, '->', list(group))\n\"\"\"output:\n07/01/2012 -> [{'address': '5412 N CLARK', 'date': '07/01/2012'}, {'address': '4801 N BROADWAY', 'date': '07/01/2012'}]\n07/02/2012 -> [{'address': '5800 E 58TH', 'date': '07/02/2012'}, {'address': '5645 N RAVENSWOOD', 'date': '07/02/2012'}, {'address': '1060 W ADDISON', 'date': '07/02/2012'}]\n07/03/2012 -> [{'address': '2122 N CLARK', 'date': '07/03/2012'}]\n07/04/2012 -> [{'address': '5148 N CLARK', 'date': '07/04/2012'}, {'address': '1039 W GRANVILLE', 'date': '07/04/2012'}]\n\"\"\"\ngroupby() 仅仅检查连续的元素，因此在调用之前需要根据指定的字段将数据排序。\nreversed(seq)\nreversed函数接收一个序列（实现sequence相关协议，已知长度）\nprint(list(reversed(range(5))))\n## output: [4, 3, 2, 1, 0]\nitertools.tee(iterable, n=2)\ntee函数返回单个iterable对象的n个独立迭代器\ng1, g2 = itertools.tee('ABC')\nprint(next(g1), next(g2))\nprint(next(g1), next(g2))\nprint(list(zip(*itertools.tee('ABC'))))\n\"\"\"output\nA A\nB B\n[('A', 'A'), ('B', 'B'), ('C', 'C')]\n\"\"\"\n\n缩减生成器\n接收一个迭代对象，处理只返回一个单一值。\nfunctools.reduce(function, iterable，initializer=None)\nfunction参数是一个接收两个参数的函数function(x, y)，reduce函数将上一次function得到的返回值作为参数x，将iterable的下一次迭代值作为参数y传进function计算，初始时x的值为initializer值(若initializer为None，初始值则为iterable的第一个元素值)。循环直到iterable耗尽返回最终值。reduce的基本实现大概为一下代码:\ndef reduce(function, iterable, initializer=None):\n    it = iter(iterable)\n    if initializer is None:\n        value = next(it)\n    else:\n        value = initializer\n    for element in it:\n        value = function(value, element)\n    return value\nprint(functools.reduce(add, [1, 2, 3, 4, 5]))\n## output: 15\n常用的min和max函数都可以用reduce实现\ndef min_reduce(iterable):\n    return functools.reduce(lambda x, y: x if x < y else y, iterable)\n\ndef max_reduce(iterable):\n    return functools.reduce(lambda x, y: x if x > y else y, iterable)\n\nprint(min_reduce([4, 6, 6, 78]))\nprint(max_reduce([4, 6, 6, 78]))\n\"\"\"output\n4\n78\n\"\"\"\n除此之外any和all函数原理也是类似，不再阐述。\n总结\n本篇按照分类介绍了python库中的一些常用的生成器，可以通过不同场景选择不同的生成器工具，将它们组合灵活运用。\n相关链接\nPython3中的迭代器和生成器\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}