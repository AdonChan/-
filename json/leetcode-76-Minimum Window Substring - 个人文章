{"title": "leetcode-76-Minimum Window Substring - 个人文章 ", "index": "python", "content": "吃透题目：\n任何问题的解决在于理解题目，挖掘本质。 \n这道题目，从一个string中找包含char的最小子序列，O(n)，要求只能遍历一遍。\n每次移动一个index，都尝试找子序列，通过对目标子序列统计数目，与当前的char的数目进行合并，然后子循环while的时候，通过减法操作，达到==0的条件时候，就可以知道这是最短的子序列的边界，同理for循环向后迭代。\n相似： kmp算法，保持状态，省略不必要的遍历，从上次移动到的位置i，继续向后移动。\n  逐步逼近法，类似于牛顿迭代法。重点是找到规律，然后将规律加以表示。\n  动态规划，相邻两个位置之间的关系。\n应用：\n学会记录状态，没有必要再次重复的位置，通过记录加以过滤。\n字符串的叠加，可以增加共性，通过相减可以得到边界位置处符合规律的要求。\n学会将问题转化为可求的边界问题。\n\nimport collections\n\nclass Solution:\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        missing=len(t)\n        need=collections.Counter(t)\n        i=I=J=0\n        # J=len(s)\n        for j,c in enumerate(s,1):\n            missing-=need[c]>0\n            need[c]-=1\n            if not missing:\n                # tmp1=s[i]\n                # tmp3=need[s[i]]\n                # tmp2=need[s[i]] < 0\n                while (i<j and need[s[i]]<0):\n                    need[s[i]]+=1\n                    i+=1\n                if (need[s[i]]>=0 and j-i<=J-I) or J==0:\n                    I=i\n                    J=j\n        # print('I,J==>',I,J)\n        return s[I:J]\n\nif __name__=='__main__':\n    S = \"ADOBEBCBODEBBANNNNACB\"\n    T = \"ABC\"\n    S='ab'\n    T='a'\n    # S='a'\n    # T='aa'\n    st=Solution()\n    out=st.minWindow(S,T)\n    print('out==>',out)\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}