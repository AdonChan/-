{"title": "Python 多进程实践 - Yi_Zhi_Yu的世界 ", "index": "通信,多进程,python2.7,python", "content": "多进程的方式可以增加脚本的并发处理能力， python 支持这种多进程的编程方式\n在类unix系统中， python的os 模块内置了fork 函数用以创建子进程\n\nfork 方式创建子进程\n\nimport os\n\nprint \"Process %s start ...\" %(os.getpid())\n\npid = os.fork()\n\nif pid == 0:\n    print \"This is child process and my pid is %d, my father process is %d\" %(os.getpid(), os.getppid())\nelse:\n    print \"This is Fater process, And Its child pid is %d\" %(pid)\n\n\n执行结果\n\nProcess 4276 start ...\nThis is Fater process, And Its child pid is 4277\nThis is child process and my pid is 4277, my father process is 4276\n\n\n从结果可以看到， 从pid = os.fork() 开始， 下面的部分代码运行了两次， 第一次是父进程运行， 第二次是子进程运行， 且子进程的fork的结果总是0， 所以这个也可以用来作为区分父进程或是子进程标志\n\n那么变量在多个进程之间是否相互影响呢\n    import os\n\nprint \"Process %s start ...\" %(os.getpid())\n\npid = os.fork()\n\nsource = 10\n\nif pid == 0:\n    print \"This is child process and my pid is %d, my father process is %d\" %(os.getpid(), os.getppid())\n    source = source - 6\n    print \"child process source value is \"+str(source)\nelse:\n    print \"This is Fater process, And Its child pid is %d\" %(pid)\n    source = source - 1\n    print \"father process source value is \"+str(source)\nprint \"source value is \"+str(source)\n\n\n执行的结果如下：\n\nProcess 4662 start ...\nThis is Fater process, And Its child pid is 4663\nThis is child process and my pid is 4663, my father process is 4662\nfather process source value is 9\nchild process source value is 4\nsource value is 9\nsource value is 4\n\n\n很明显， 初始值为10的source 在父进程中值 减少了 1, 为9， 而子进程明显source的初始值 是10, 也就是说多进程之间并没有什么相互影响\n\nmultiprocessing 方式创建子进程\n\nfork 方式是仅在linux 下才有的接口， 在windows下并没有， 那么在windows下如何实现多进程呢， 这就用到了multiprocessing\n\nmultiprocessing 模块的Process 对象表示的是一个进程对象， 可以创建子进程并执行制定的函数\n\nfrom multiprocessing import Process\nimport os\n\ndef pro_do(name, func):\n    print \"This is child process %d from parent process %d, and name is  %s which is used for %s\" %(os.getpid(), os.getppid(), name, func)\n\nif __name__ == \"__main__\":\n    print \"Parent process id %d\" %(os.getpid())\n    #process 对象指定子进程将要执行的操作方法(pro_do), 以及该函数的对象列表args(必须是tuple格式， 且元素与pro_do的参数一一对应)\n    pro = Process(target=pro_do, args=(\"test\", \"dev\"))\n    print \"start child process\"\n    #启动子进程\n    pro.start()\n    #是否阻塞方式执行， 如果有， 则阻塞方式， 否则非阻塞\n    pro.join() #if has this, it's synchronous operation or asynchronous operation\n    print \"Process end\"\n\n\n执行结果\n\nParent process id 4878\nstart child process\nThis is child process 4879 from parent process 4878, and name is  test which is used for dev\nProcess end\n\n\n如果没有pro.join()， 则表示非阻塞方式运行， 那么最终的Process end的输出位置就有可能出现在pro_do 方法执行之前了\n\nParent process id 4903\nstart child process\nProcess end\nThis is child process 4904 from parent process 4903, and name is  test which is used for dev\n\n\n通过multiprocessing 的process对象创建多进程， 还可以从主进程中向子进程传递参数， 例如上面例子中的pro_do的参数\n\nPool 进程池\n\nfrom multiprocessing import Pool\nimport os, time\n\ndef pro_do(process_num):\n    print \"child process id is %d\" %(os.getpid())\n    time.sleep(6 - process_num)\n    print \"this is process %d\" %(process_num)\n\nif __name__ == \"__main__\":\n    print \"Current process is %d\" %(os.getpid())\n    p = Pool()\n    for i in range(5):\n        p.apply_async(pro_do, (i,))  #增加新的进程\n    p.close() # 禁止在增加新的进程\n    p.join()\n    print \"pool process done\"\n\n\n输出：\n\nCurrent process is 19138\nchild process id is 19139\nchild process id is 19140\nthis is process 1\nchild process id is 19140\nthis is process 0\nchild process id is 19139\nthis is process 2\nchild process id is 19140\nthis is process 3\nthis is process 4\npool process done\n\n\n其中\n\n   child process id is 19139\n   child process id is 19140\n\n\n是立即输出的， 后面的依次在等待了sleep的时间后输出 ， 之所以立即输出了上面两个是因为诶Pool 进程池默认是按照cpu的数量开启子进程的， 我是在虚拟机中运行， 只分配了两核， 所以先立即启动两个子进程， 剩下的进程要等到前面的进程执行完成后才能启动。\n不过也可以在p=Poo() 中使用Pool(5)来指定启动的子进程数量， 这样输出就是下面的了：\n\nCurrent process is 19184\nchild process id is 19185\nchild process id is 19186\nchild process id is 19188\nchild process id is 19189\nchild process id is 19187\nthis is process 4\nthis is process 3\nthis is process 2\nthis is process 1\nthis is process 0\npool process done\n\n\n且\n\nCurrent process is 19184\nchild process id is 19185\nchild process id is 19186\nchild process id is 19188\nchild process id is 19189\nchild process id is 19187\n\n\n都是立即输出的\n\n进程间的通信\n\n父进程可以指定子进程执行的方法及其参数， 达到父进程向子进程传递消息的单向通信的目的， 那子进程之间或子进程怎么向父进程通信呢\n\nQueue\n\nQueue 是一种方式\n\nfrom multiprocessing import Process, Queue\nimport os, time\n\ndef write_queue(q):\n    for name in [\"Yi_Zhi_Yu\", \"Tony\" ,\"San\"]:\n        print \"put name %s to queue\" %(name)\n        q.put(name)\n        time.sleep(2)\n    print \"write data finished\"\n\ndef read_queue(q):\n    print \"begin to read data\"\n    while True:\n        name = q.get()\n        print \"get name %s from queue\" %(name)\n\nif __name__ == \"__main__\":\n    q = Queue()\n    pw = Process(target=write_queue, args=(q,))\n    pr = Process(target=read_queue,args=(q,))\n\n    pw.start()\n    pr.start()\n    pw.join() #这个表示是否阻塞方式启动进程， 如果要立即读取的话， 两个进程的启动就应该是非阻塞式的， 所以pw在start后不能立即使用pw.join(), 要等pr start后方可\n    pr.terminate() #服务进程，强制停止\n\n\n结果\n\nput name Yi_Zhi_Yu to queue\nbegin to read data\nget name Yi_Zhi_Yu from queue\nput name Tony to queue\nget name Tony from queue\nput name San to queue\nget name San from queue\nwrite data finished\n\n\nPipe\n\n另外还有Pipe\n 其原理参见http://ju.outofmemory.cn/entry/106041， 其只能作为两个进程之间的通信\n\n#!/usr/bin/env python\n#encoding=utf-8\n\nfrom multiprocessing import Process,Pipe\nimport os,time,sys\n\ndef send_pipe(p):\n    names = [\"Yi_Zhi_Yu\", \"Tony\", \"San\"]\n    for name in names:\n        print \"put name %s to Pipe\" %(name)\n        p.send(name)\n        time.sleep(1)\ndef recv_pipe(p):\n    print \"Try to read data in pipe\"\n    while True:\n            name = p.recv()\n            print \"get name %s from pipe\" %(name)\n\nif __name__ == \"__main__\":\n   #pipe, one for send, one for read\n   ps_pipe, pr_pipe = Pipe()\n   #process\n   ps = Process(target=send_pipe, args=(ps_pipe,))\n   pr = Process(target=recv_pipe, args=(pr_pipe,))\n   pr.start()\n   ps.start()\n   ps.join()\n   pr.terminate()\n\n\n在实例化Pipe的时候， 会产生两个ps_pipe(read-write Connection, handle 5)， pr_pipe(read-write Connection, handle 5) , 都可以作为发送或者接受方， 一旦一个确认为攻， 另一个自然就是受了(之所以Pipe只能作为两个进程之间的通信方式， 原因也许就是这个)，产生的结果如下\n\nTry to read data in pipe\nput name Yi_Zhi_Yu to Pipe\nget name Yi_Zhi_Yu from pipe\nput name Tony to Pipe\nget name Tony from pipe\nput name San to Pipe\nget name San from pipe\n\n\n还有一种Array, Value 的形式， 暂且不表， 有时间在折腾\n\n以上均为python 学习笔记和练习， 如有错误， 欢迎指出\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "44"}