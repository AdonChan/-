{"title": "基于X11-ARIMA模型的时间序列分析 - 时序分析 ", "index": "python", "content": "**对时间序列模型进行优化1.首先将时序数据分解为趋势分量，季节周期分量和随机分量2.对趋势分量使用ARIMA模型进行拟合3.季节周期分量则使用历史同期分量4.随机分量则是使用历史同类的平均值进行预测5.使用面向对象的方式，构造模型的类，自动选取最优的模型参数**\nimport numpy as np\nimport pandas as pd\nfrom datetime import datetime\nimport matplotlib.pylab  as plt\nfrom statsmodels.tsa.stattools import adfuller\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom statsmodels.graphics.tsaplots import plot_acf,plot_pacf \nimport sys\nfrom dateutil.relativedelta import relativedelta\nfrom  copy import deepcopy\nfrom statsmodels.tsa.arima_model import ARMA\nimport warnings\nwarnings.filterwarnings(\"ignore\")```\n\n定义ARIMA的类\nclass arima_model:\ndef __init__(self,ts,maxLag = 9):\n    self.data_ts = ts\n    self.resid_ts = None\n    self.predict_ts = None\n    self.forecast_ts = None\n    self.maxLag = maxLag\n    self.p = maxLag\n    self.q = maxLag\n    self.properModel = None\n    self.bic = sys.maxsize\n\n#计算最优的ARIMA模型，将相关结果赋给相应的属性\ndef get_proper_model(self):\n    self._proper_model()\n    self.predict_ts = deepcopy(self.properModel.predict())\n    self.resid_ts = deepcopy(self.properModel.resid)\n    self.forecast_ts = deepcopy(self.properModel.forecast())\n\n#对于给定范围内的p,q计算拟合得最好的arima模型，这里是对差分好的数据进行拟合，故差分恒为0\ndef _proper_model(self):\n    for p in np.arange(self.maxLag):\n        for q in np.arange(self.maxLag):\n            model = ARMA(self.data_ts, order = (p,q))\n            try:\n                results_ARMA = model.fit(disp = -1, method = \"css\")\n            except:\n                continue\n            bic = results_ARMA.bic\n            \n            if  bic < self.bic:\n                self.p = p\n                self.q = q\n                self.properModel = results_ARMA\n                self.bic = bic\n                self.resid_ts = deepcopy(self.properModel.resid)\n                self.predict_ts = self.properModel.predict()\n\n#参数确定模型\ndef certain_model(self,p,q):\n    model = ARMA(self.data_ts,order = (p,q))\n    try:\n        self.properModel = model.fit(disp = -1,method = \"css\")\n        self.p = p\n        self.q = q\n        self.bic = self.properModel.bic\n        self.predict_ts = self.properModel.predict()\n        self.resid_ts = deepcopy(self.properModel.resid)\n        self.forecast_ts = self.properModel.forecast()\n    except:\n        print (\"You can not fit the model with this parameter p,q\")```\n        \ndateparse = lambda dates:pd.datetime.strptime(dates,'%Y-%m')\n#paese_dates指定日期在哪列 index_dates将年月日的哪个作为索引，date_parser将字符串转为日期\nf = open(\"D:\\福建\\AirPassengers.csv\")\ndata = pd.read_csv(f, parse_dates=[\"Month\"],index_col=\"Month\",date_parser=dateparse)\nts = data[\"#Passengers\"]\ndef draw_ts(timeSeries,title):\n    f = plt.figure(facecolor = \"white\")\n    timeSeries.plot(color = \"blue\")\n    plt.title(title)\n    plt.show()\n\ndef seasonal_decompose(ts):\n    from statsmodels.tsa.seasonal import seasonal_decompose\n    decomposition = seasonal_decompose(ts, model = \"multiplicative\")\n    trend = decomposition.trend\n    seasonal = decomposition.seasonal\n    residual = decomposition.resid\n    draw_ts(ts,'origin')\n    draw_ts(trend,'trend')\n    draw_ts(seasonal,'seasonal')\n    draw_ts(residual,'residual')\n    return trend,seasonal,residual\ndef testStationarity(ts):\n    dftest = adfuller(ts)\n    # 对上述函数求得的值进行语义描述\n    dfoutput = pd.Series(dftest[0:4], index=['Test Statistic','p-value','#Lags Used','Number of Observations Used'])\n    for key,value in dftest[4].items():\n        dfoutput['Critical Value (%s)'%key] = value\n#     print (\"dfoutput\",dfoutput)        \n    return dfoutput\nts_log = np.log(ts)\ntrend,seasonal,residual = seasonal_decompose(ts_log)\nseasonal_arr = seasonal\nresidual = residual.dropna()\nresidual_mean = np.mean(residual.values)\ntrend = trend.dropna()\n代码运行如下：\n#将原始数据分解为趋势分量，季节周期和随机分量\n#对trend进行平稳定检验\ntestStationarity(trend)\n\n#对序列进行平稳定处理\ntrend_diff_1 = trend.diff(1)\ntrend_diff_1 = trend_diff_1.dropna()\ndraw_ts(trend_diff_1,'trend_diff_1')\ntestStationarity(trend_diff_1)\ntrend_diff_2 = trend_diff_1.diff(1)\ntrend_diff_2 = trend_diff_2.dropna()\ndraw_ts(trend_diff_2,'trend_diff_2')\ntestStationarity(trend_diff_2)\n#使用模型拟合趋势分量\n#使用模型参数的自动识别\nmodel = arima_model(trend_diff_2)\nmodel.get_proper_model()\npredict_ts = model.properModel.predict()\n\n#还原数据,因为使用的是乘法模型，将趋势分量还原之后需要乘以对应的季节周期分量和随机分量\ndiff_shift_ts = trend_diff_1.shift(1)\ndiff_recover_1 = predict_ts.add(diff_shift_ts)\nrol_shift_ts = trend.shift(1)\ndiff_recover = diff_recover_1.add(rol_shift_ts)\nrecover = diff_recover['1950-1':'1960-6'] * seasonal_arr['1950-1':'1960-6'] * residual_mean\nlog_recover = np.exp(recover)\ndraw_ts(log_recover,'log_recover')\n\n#模型评价\nts_quantum = ts['1950-1':'1960-6']\nplt.figure(facecolor = \"white\")\nlog_recover.plot(color = \"blue\",label = \"Predict\")\nts_quantum.plot(color = \"red\", label = \"Original\")\nplt.legend(loc = \"best\")\nplt.title(\"RMSE %.4f\" % np.sqrt(sum((ts_quantum - log_recover) ** 2) / ts_quantum.size))\nplt.show()\n\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "0"}