{"title": "Flask Web 开发实战笔记 - About Data ", "index": "笔记,web开发,flask,python", "content": "\n几天前和同事一起喝酒，大家谈到为什么开始读书这件事。这里所说的读书不是专业的书籍，而是一些闲书。结果发现原来我们开始读书的原因很功利。都是因为生活中遇到了困惑，希望在书中找到答案。\n人就是这样，即便在书中找不到答案。在看书的过程中发现，这个世界上居然有很多人是和我一样的。我解决不了的问题居然困扰了很多人。当从内而外，推己及人，发现这是一个外部世界普遍的问题，而不是自己本身的能力、性格和承受能力的问题，这时就会相对轻松，至少为自己的偷懒找到了借口。按照罗胖曾经说过的“其实人大多数时候没有自己的观点，在人生某一个阶段的观点，不过是对现状的解释罢了”\n当然说到这里，我自然已经过了那个功利的阶段。因为随着你读书越多、思考越多、对世界的了解越多，会发现你所面对的未知领域越来越大，而且没有边界。转而因为兴趣读书，似乎才能带来愉快的体验。\n\nFlask Web 开发实战笔记\n安装和使用虚拟环境\n\n虚拟环境是Python解释器的一个私有副本，在这个环境中你可以安装私有的包，而且不会影响系统中安装的全局的解释器。另外一个好处是，不需要管理员权限。\n\n虚拟环境使用第三方实用工具virtualenv创建\n安装方式略。使用virtualenv创建虚拟环境，虚拟名称一般为env，当然你可以选择不同的名字\n\n#创建虚拟环境\nvirtualenv env\n#创建完成后，env目录下出现如下目录\nInclude/  \nLib/  \nScripts/  \npip-selfcheck.json  \ntcl/\n激活虚拟环境(windows下)\nvenv\\Scripts\\activate\n激活后，提示符变成(venv)$\n#激活后就可以直接执行语句，并通过浏览器http://127.0.0.1访问\n(venv)$ python hello.py\n一个完整程序的结构\n\n#初始化\nfrom flask import Flask\napp = Flask(__name__)\n\n#路由和视图函数\n@app.route('/')\ndef index():\n    return '<h1>Hello World!</h1>'\n\n#启动服务器\n#debug=True 启动调试模式\n#如果我们想要其他人访问，可以使用app.run(host=0.0.0.0.0,debug=True)\nif __name__ == '__main__':\n    app.run(debug=True)\n    \n\nflask类的构造只有一个必须指定的参数，即程序主模块或包的名字。在大多数程序中，Python的__name__变量就是所需的值。\n处理URL和函数之间关系的程序称为路由。\n在Flask程序中定义路由最简便的方式，是使用程序实例提供的app.route修饰器。\n紧随修饰器之后的函数，我们称之为视图函数[index()]。\n\n程序和请求上下文\n\nFlask从客户端收到请求时，要让视图函数能够访问一些对象，这样才能处理请求。那么要想让视图函数能够访问对象，一个显而易见的方法是将其作为参数传入视图函数。如你所想，这样会导致每个视图函数都要增加一个参数。并且考虑到，如果视图函数还需要访问其他对象，那么情况可能更糟。所以，Flask使用上下文临时的把某些对象变为全局可访问。\nfrom flask import request\n\n@app.route('/')\ndef index():\n    user_agent= request.headers.get('User-Agent')\n    return '<p>Your browser is  %s</p>' % user-agent\nFlask上下文分为程序上下文和请求上下文\n\n\nFlask在分发请求之前激活程序和请求上下文，请求处理结束后再将其删除。\n程序上下文被推送之后，就可以在线程中使用current_app 和 g 变量\n请求上下文被推送后，就额可以使用request和session变量。\n\n请求钩子\n有时在处理请求之前或之后执行代码会很有用。例如在请求开始时，我们需要创建数据库连接或认证发起请求的用户。为了避免在每个视图中都使用重复的代码，Flask提供了注册通用函数的功能。\n请求钩子使用修饰器实现。Flask支持以下4中钩子\n\nbefore_first_request: 注册是一个函数，在处理第一个请求之前运行\nbefore_request : 注册一个函数，在每次请求之前运行\nafter_request: 注册一个函数，如果没有未处理的异常抛出，在每次请求之后运行。\nteardown_request:注册一个函数，即使有未被处理的异常抛出，也在每次请求之后运行。\n\n在请求钩子函数和视图函数之间共享数据一般使用上下文全局变量g例如，before_request处理程序可以从数据库中加载已登录用户，并将其保存到g.user中。随后调用视图函数时，视图函数在使用g.user获取用户。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}