{"title": "浅谈Python多线程 - 个人文章 ", "index": "多线程,python", "content": "浅谈Python多线程\n作者简介:\n姓名:黄志成(小黄)博客: 博客\n\n线程\n一.什么是线程?\n操作系统原理相关的书，基本都会提到一句很经典的话： \"进程是资源分配的最小单位，线程则是CPU调度的最小单位\"。\n线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务\n好处 ：\n1.易于调度。\n\n2.提高并发性。通过线程可方便有效地实现并发性。进程可创建多个线程来执行同一程序的不同部分。\n\n3.开销少。创建线程比创建进程要快，所需开销很少。\n\n4.利于充分发挥多处理器的功能。通过创建多线程进程，每个线程在一个处理器上运行，从而实现应用程序的并发性，使每个处理器都得到充分运行。\n\n在解释python多线程的时候. 先和大家分享一下 python 的GIL 机制。\n二.GIL（Global Interpreter Lock）全局解释器锁\nPython代码的执行由Python 虚拟机(也叫解释器主循环，CPython版本)来控制，Python 在设计之初就考虑到要在解释器的主循环中，同时只有一个线程在执行，即在任意时刻，只有一个线程在解释器中运行。对Python 虚拟机的访问由全局解释器锁（GIL）来控制，正是这个锁能保证同一时刻只有一个线程在运行。\n在多线程环境中，Python 虚拟机按以下方式执行：\n\n设置GIL\n切换到一个线程去运行\n运行：a. 指定数量的字节码指令，或者b. 线程主动让出控制（可以调用time.sleep(0)）\n把线程设置为睡眠状态\n解锁GIL\n再次重复以上所有步骤\n\n首先需要明确的一点是GIL并不是Python的特性，它是在实现Python解析器(CPython)时所引入的一个概念。Python同样一段代码可以通过CPython，PyPy，Psyco等不同的Python执行环境来执行。像其中的JPython就没有GIL。然而因为CPython是大部分环境下默认的Python执行环境。所以在很多人的概念里CPython就是Python，也就想当然的把GIL归结为Python语言的缺陷。所以这里要先明确一点：GIL并不是Python的特性，Python完全可以不依赖于GIL\n还有，就是在做I/O操作时，GIL总是会被释放。对所有面向I/O 的(会调用内建的操作系统C 代码的)程序来说，GIL 会在这个I/O 调用之前被释放，以允许其它的线程在这个线程等待I/O 的时候运行。如果是纯计算的程序，没有 I/O 操作，解释器会每隔 100 次操作就释放这把锁，让别的线程有机会执行（这个次数可以通过 sys.setcheckinterval 来调整）如果某线程并未使用很多I/O 操作，它会在自己的时间片内一直占用处理器（和GIL）。也就是说，I/O 密集型的Python 程序比计算密集型的程序更能充分利用多线程环境的好处。\n三.线程的生命周期\n\n各个状态说明：\n\n\nNew新建 ：新创建的线程经过初始化后，进入Runnable状态。\n\nRunnable就绪：等待线程调度。调度后进入运行状态。\n\nRunning运行：线程正常运行\n\nBlocked阻塞：暂停运行，解除阻塞后进入Runnable状态重新等待调度。\n\nDead消亡：线程方法执行完毕返回或者异常终止。\n\n可能有3种情况从Running进入Blocked：\n\n\n同步：线程中获取同步锁，但是资源已经被其他线程锁定时，进入Locked状态，直到该资源可获取（获取的顺序由Lock队列控制）\n\n睡眠：线程运行sleep()或join()方法后，线程进入Sleeping状态。区别在于sleep等待固定的时间，而join是等待子线程执行完。sleep()确保先运行其他线程中的方法。当然join也可以指定一个“超时时间”。从语义上来说，如果两个线程a,b, 在a中调用b.join()，相当于合并(join)成一个线程。将会使主调线程(即a)堵塞(暂停运行, 不占用CPU资源), 直到被调用线程运行结束或超时, 参数timeout是一个数值类型，表示超时时间，如果未提供该参数，那么主调线程将一直堵塞到被调线程结束。最常见的情况是在主线程中join所有的子线程。\n\n等待：线程中执行wait()方法后，线程进入Waiting状态，等待其他线程的通知(notify）。wait方法释放内部所占用的琐，同时线程被挂起，直至接收到通知被唤醒或超时（如果提供了timeout参数的话）。当线程被唤醒并重新占有琐的时候，程序才会继续执行下去。\n\nthreading.Lock()不允许同一线程多次acquire(), 而RLock允许, 即多次出现acquire和release\n四.Python threading模块\n上面介绍了这么多理论.下面我们用python提供的threading模块来实现一个多线程的程序\nthreading 提供了两种调用方式:\n直接调用\nimport threading\n\ndef func(n): # 定义每个线程要运行的函数\n    while n > 0:\n        print(\"当前线程数:\", threading.activeCount())\n        n -= 1\n        \nfor x in range(5):\n    t = threading.Thread(target=func, args=(2,))  # 生成一个线程实例,生成实例后 并不会启动,需要使用start命令\n    t.start() #启动线程\n\n继承式调用\nclass MyThread(threading.Thread): # 继承threading的Thread类\n    def __init__(self, num):\n        threading.Thread.__init__(self) # 必须执行父类的构造方法\n        self.num = num # 传入参数 num\n\n    def run(self):  # 定义每个线程要运行的函数\n        while self.num > 0:\n            print(\"当前线程数:\", threading.activeCount())\n            self.num -= 1\n\nfor x in range(5):\n    t = MyThread(2) # 生成实例,传入参数\n    t.start() #启动线程\n\n两种方式都可以调用我们的多线程方法。\n五.子线程阻塞\n运行下面的代码,看看结果.\nimport threading\ndef func(n):\n    while n > 0:\n        print(\"当前线程数:\", threading.activeCount())\n        n -= 1\nfor x in range(5):\n    t = threading.Thread(target=func, args=(2,))\n    t.start()\n\nprint(\"主线程：\", threading.current_thread().name)\n\n运行结果：\n当前线程数: 2\n当前线程数: 2\n当前线程数: 2\n当前线程数: 2\n当前线程数: 2\n当前线程数: 3\n当前线程数: 3\n当前线程数: 3\n主线程： MainThread\n当前线程数: 3\n当前线程数: 3\n\n那我们如何阻塞子线程让他们运行完,在继续后面的操作呢.这个时候join()方法就派上用途了. 我们改写代码:\nimport threading\n\ndef func(n):\n    while n > 0:\n        print(\"当前线程数:\", threading.activeCount())\n        n -= 1\n\nthreads = [] #运行的线程列表\nfor x in range(5):\n    t = threading.Thread(target=func, args=(2,))\n    threads.append(t) # 将子线程追加到列表\n    t.start()\n\nfor t in threads:\n    t.join()\n\nprint(\"主线程：\", threading.current_thread().name)\n\n\njoin的原理就是依次检验线程池中的线程是否结束，没有结束就阻塞直到线程结束，如果结束则跳转执行下一个线程的join函数。\n先看看这个：\n\n阻塞主进程，专注于执行多线程中的程序。\n多线程多join的情况下，依次执行各线程的join方法，前头一个结束了才能执行后面一个。\n无参数，则等待到该线程结束，才开始执行下一个线程的join。\n参数timeout为线程的阻塞时间，如 timeout=2 就是罩着这个线程2s 以后，就不管他了，继续执行下面的代码。\n\n六.线程锁（互斥锁）\n一个进程可以开启多个线程,那么多么多个进程操作相同数据,势必会出现冲突.那如何避免这种问题呢?\nimport threading,time\n\nnum = 10 #共享变量\n\ndef func():\n    global num\n    lock.acquire() # 加锁\n    num = num - 1\n    lock.release() # 解锁\n    print(num)\n\nthreads = []\nlock = threading.Lock() #生成全局锁\nfor x in range(10):\n    t = threading.Thread(target=func)\n    threads.append(t)\n    t.start()\n\nfor t in threads:\n    t.join()\n\n通过 threading.Lock() 我们可以申请一个锁。然后 acquire 方法进入临界区.操作完共享数据 使用 release 方法退出.\n临界区的概念： 百度百科\n在这里补充一下:Python的Queue模块是线程安全的.可以不对它加锁操作.\n聪明的同学 会发现一个问题? 咱们不是有 GIL 吗 为什么还要加锁？\n这个问题问的好！我们下一节,将对这个问题进行探讨.\n七.LOCK 和 GIL\nGIL的锁是对于一个解释器，只能有一个thread在执行bytecode。所以每时每刻只有一条bytecode在被执行一个thread。GIL保证了bytecode 这层面上是线程是安全的.\n但是如果你有个操作一个共享 x += 1，这个操作需要多个bytecodes操作，在执行这个操作的多条bytecodes期间的时候可能中途就换thread了，这样就出现了线程不安全的情况了。\n总结：同一时刻CPU上只有单个执行流不代表线程安全。\n八.信号量\n互斥锁 同时只允许一个线程更改数据，而Semaphore是同时允许一定数量的线程更改数据 ，比如厕所有3个坑，那最多只允许3个人上厕所，后面的人只能等里面有人出来了才能再进去。\nimport threading,time\n\nnum = 10\n\ndef func():\n    global num\n    lock.acquire()\n    time.sleep(2)\n    num = num - 1\n    lock.release()\n    print(num)\n\nthreads = []\nlock = threading.BoundedSemaphore(5) #最多允许5个线程同时运行\nfor x in range(10):\n    t = threading.Thread(target=func)\n    threads.append(t)\n    t.start()\n\nfor t in threads:\n    t.join()\n\nprint(\"主线程：\", threading.current_thread().name)\n\n\n运行一下上面的代码.你会很明显的发现 每次只执行五个线程。\n参考文献\n浅谈多进程多线程的选择： 文章链接python-多线程(原理篇):  文章链接\nPython有GIL为什么还需要线程同步？:  文章链接\n\n\n                ", "mainLikeNum": ["4 "], "mainBookmarkNum": "9"}