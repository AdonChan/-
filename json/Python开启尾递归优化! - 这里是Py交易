{"title": "Python开启尾递归优化! - 这里是Py交易 ", "index": "python", "content": "Python尾递归优化\n一般递归与尾递归\n一般递归:\ndef normal_recursion(n):\n    if n == 1:\n        return 1\n    else:\n        return n + normal_recursion(n-1)\n执行：\nnormal_recursion(5)\n5 + normal_recursion(4)\n5 + 4 + normal_recursion(3)\n5 + 4 + 3 + normal_recursion(2)\n5 + 4 + 3 + 2 + normal_recursion(1)\n5 + 4 + 3 + 3\n5 + 4 + 6\n5 + 10\n15\n可以看到, 一般递归, 每一级递归都产生了新的局部变量, 必须创建新的调用栈, 随着递归深度的增加, 创建的栈越来越多, 造成爆栈?\n尾递归\n尾递归基于函数的尾调用, 每一级调用直接返回递归函数更新调用栈, 没有新局部变量的产生, 类似迭代的实现:\ndef tail_recursion(n, total=0):\n    if n == 0:\n        return total\n    else:\n        return tail_recursion(n-1, total+n)\n执行：\ntail_recursion(5, 0)\ntail_recursion(4, 5)\ntail_recursion(3, 9)\ntail_recursion(2, 12)\ntail_recursion(1, 14)\ntail_recursion(0, 15)\n15\n可以看到, 尾递归每一级递归函数的调用变成\"线性\"的形式. 这时, 我们可以思考, 虽然尾递归调用也会创建新的栈, 但是我们可以优化使得尾递归的每一级调用共用一个栈!, 如此便可解决爆栈和递归深度限制的问题!\nC中尾递归的优化\ngcc使用-O2参数开启尾递归优化:\nint tail_recursion(int n, int total) {\n    if (n == 0) {\n        return total;\n    }\n    else {\n        return tail_recursion(n-1, total+n);\n    }\n}\n\nint main(void) {\n    int total = 0, n = 4;\n    tail_recursion(n, total);\n    return 0;\n}\n反汇编\n$ gcc -S tail_recursion.c -o normal_recursion.S\n$ gcc -S -O2 tail_recursion.c -o tail_recursion.S gcc开启尾递归优化\n对比反汇编代码如下(AT&T语法, 左图为优化后) \n\n可以看到, 开启尾递归优化前, 使用call调用函数, 创建了新的调用栈(LBB0_3); 而开启尾递归优化后, 就没有新的调用栈生成了, 而是直接pop bp指向的_tail_recursion函数的地址(pushq %rbp)然后返回,  仍旧用的是同一个调用栈!\nPython开启尾递归优化\ncpython本身不支持尾递归优化, 但是一个牛人想出的解决办法：实现一个 tail_call_optimized 装饰器\n#!/usr/bin/env python2.4\n# This program shows off a python decorator(\n# which implements tail call optimization. It\n# does this by throwing an exception if it is\n# it's own grandparent, and catching such\n# exceptions to recall the stack.\n\nimport sys\n\nclass TailRecurseException:\n    def __init__(self, args, kwargs):\n        self.args = args\n        self.kwargs = kwargs\n\ndef tail_call_optimized(g):\n    \"\"\"\n    This function decorates a function with tail call\n    optimization. It does this by throwing an exception\n    if it is it's own grandparent, and catching such\n    exceptions to fake the tail call optimization.\n\n    This function fails if the decorated\n    function recurses in a non-tail context.\n    \"\"\"\n    def func(*args, **kwargs):\n        f = sys._getframe()\n        if f.f_back and f.f_back.f_back \\\n            and f.f_back.f_back.f_code == f.f_code:\n            # 抛出异常\n            raise TailRecurseException(args, kwargs)\n        else:\n            while 1:\n                try:\n                    return g(*args, **kwargs)\n                except TailRecurseException, e:\n                    args = e.args\n                    kwargs = e.kwargs\n    func.__doc__ = g.__doc__\n    return func\n\n@tail_call_optimized\ndef factorial(n, acc=1):\n    \"calculate a factorial\"\n    if n == 0:\n        return acc\n    return factorial(n-1, n*acc)\n\nprint factorial(10000) \n这里解释一下sys._getframe()函数:\nsys._getframe([depth]):Return a frame object from the call stack.If optional integer depth is given, return the frame object that many calls below the top of the stack.If that is deeper than the call stack, ValueEfror is raised. The default for depth is zero,returning the frame at the top of the call stack.\n即返回depth深度调用的栈帧对象.\nimport sys\n\ndef get_cur_info():\n    print sys._getframe().f_code.co_filename  # 当前文件名\n    print sys._getframe().f_code.co_name  # 当前函数名\n    print sys._getframe().f_lineno # 当前行号\n    print sys._getframe().f_back # 调用者的帧\n更多关于sys._getframe的使用请看Frame Hacks说一下tail_call_optimized实现尾递归优化的原理: 当递归函数被该装饰器修饰后, 递归调用在装饰器while循环内部进行, 每当产生新的递归调用栈帧时: f.f_back.f_back.f_code == f.f_code:, 就捕获当前尾调用函数的参数, 并抛出异常, 从而销毁递归栈并使用捕获的参数手动调用递归函数. 所以递归的过程中始终只存在一个栈帧对象, 达到优化的目的.为了更清晰的展示开启尾递归优化前、后调用栈的变化和tail_call_optimized装饰器抛异常退出递归调用栈的作用, 我这里利用pudb调试工具做了动图: \n开启尾递归优化前的调用栈 \n开启尾递归优化后(tail_call_optimized装饰器)的调用栈 \n通过pudb右边栏的stack, 可以很清晰的看到调用栈的变化.因为实现了尾递归优化, 所以factorial(10000)都不害怕递归深度限制报错啦!\n\n                ", "mainLikeNum": ["7 "], "mainBookmarkNum": "15"}