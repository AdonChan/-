{"title": "一种国际化Qt应用程序的方法 - 个人文章 ", "index": "c++,c#,python,qt", "content": "Qt 是一个很方便的 C++ 应用开发框架(或许现在要加上 Qt Quick 开发框架?)，不仅仅是程序编写方便面，它提供了很多方便的类库，而且它也提供了很方便的国际化方案（也就是翻译成各国语言的方案）。\n基本流程\n编写代码阶段\n我们先来说说在 Qt 中实现多国语言翻译需要使用的基本流程。首先我们需要在编写代码的时候就要使用 Qt 提供的翻译相关的函数来\"包裹\"住所有的需要翻译的字符串。\n你说哪些才是需要翻译的字符串呢？就是任何会在用户界面上显示的字符串，如果不会显示自然就不需要翻译了。\n如果你使用的是 C++ 代码，那么翻译用的函数就是QObject::tr函数。大多数时候，我们看到用到这个函数的时候可能都只是一个tr，因为都是在一个继承自 QObject 的类中，所以可以直接调用父类的成员函数了。如果是在自由函数中想使用的话就要把完整的函数名QObject::tr写全了。\n如果你写的是 Qt Quick 的程序，这个函数就变成了 qsTr 或者是 qsTranslate 、qsTranslateNoOp ...\n代码写完之后，需要在工程文件 (.pro 文件) 中添加需要翻译的源代码文件。\nSOURCES += \\\n    main.cpp \\\n    mainwindow.cpp\n\nTRANSLATIONS = \\\n    English.ts \\\n    Japanese.ts\n使用 lupdate 检索源代码生成翻译源文件\n在工程目录下运行以下命令\nlupdate project.pro\n\n\n执行完后，目录下会出现 English.ts 和 Japanese.ts 两个文件，这两个文件就是由上文中工程文件中制定的文件名。\n使用 linguist 进行翻译\n然后就可以使用 Qt 提供的 lingust 工具打开上文生成的 .ts 文件，将对应的词条翻译成目标语言就好了。\n使用 lrelease 生成最终程序使用的翻译文件\n当 linguist 翻译完所有的词条之后，就需要生成最终给应用程序使用的二进制翻译文件了。使用如下命令即可生成。\nlrelease English.ts\n\n\n执行完毕，目录下会多出一个 English.qm 文件，这个文件就是最终需要放在应用程序中分发给用户的。\n问题\n使用上面的流程就完成了一次基本的程序国际化的流程。一般来说程序的翻译工作和编码工作是由不同人来完成的，可能实际完成翻译的人不熟悉或者不愿去熟悉使用 linguist 的使用方法，他们提供给程序员的词条翻译可能就是一个 Excel 文件，这个 Excel 文件通常一列是待翻译的词条，另一列是相应的译文。\n解决方法\n于是我们可能需要一个将 Qt 的翻译文件与 Excel 文件互相转换的小工具，这样我们可以把 Qt 翻译文件转换成 Excel 文件交给翻译人员，然后将翻译人员翻译好的 Excel 文件再转换为 Qt 的翻译文件。\n要做文件格式转换，那么我们首先得了解一下两种文件格式有什么特点。\nQt TS 文件格式分析\nQt 的 TS 翻译文件其实就是一个 XML 文件。我们先来看一个翻译文件的例子。\n<!DOCTYPE TS>\n<TS>\n    <context>\n        <name>QPushButton</name>\n        <message>\n            <source>Hello world!</source>\n            <translation type=\"unfinished\"></translation>\n        </message>\n    </context>\n</TS>\n\n\n这是一个还未翻译的文件，词条原文是\"Hello world!\"。在 ts 文件中，每个需要翻译的词条都是一个 message，message 包含需要翻译的原文和已翻译的译文。\n翻译完成后需要去除 translation 的 type=\"unfinished\" 属性。\nExcel 文件格式分析\nExcel 的文件格式是 Microsoft ® 的私有格式，Excel 2007 之前的格式是二进制格式, Excel 2007 之后的是 OOXML 格式。\n在这里我们不用太细的追究它的内部细节，因为它的内部细节非常复杂，不像 ts 文件就是一个简单的文本文件。现在有许多的可以用来读写 Excel 文件的库，我们只需调用这些库的读写函数就能完成我们所需的功能了。在本文中，我将使用 C# 语言以及 NPOI 库来读写 Excel 文件。\nTS 文件转 Excel 文件\nprivate void convertQtFile2ExcelFile(string qtFileName, string excelFileName)\n{\n    XmlDocument xmlDoc = new XmlDocument();\n    XmlReaderSettings settings = new XmlReaderSettings();\n    settings.IgnoreComments = true;\n    settings.DtdProcessing = DtdProcessing.Ignore;\n\n    IWorkbook workbook = new XSSFWorkbook();\n    ISheet sheet = workbook.CreateSheet(\"worksheet\");\n\n    int rowCnt = 0;\n    IRow headRow = sheet.CreateRow(rowCnt);\n    rowCnt++;\n\n    ICell chCell = headRow.CreateCell(0);\n    chCell.SetCellValue(\"源语言\");\n    ICell enCell = headRow.CreateCell(1);\n    enCell.SetCellValue(\"目标语言\");\n\n    XmlReader reader = XmlReader.Create(qtFileName, settings);\n    xmlDoc.Load(reader);\n\n    XmlNode rootNode = xmlDoc.SelectSingleNode(\"TS\");\n    XmlNodeList xnl = rootNode.ChildNodes;\n\n    foreach (XmlNode node in xnl)\n    {\n        XmlNodeList nodeList = node.ChildNodes;\n        string src = \"\";\n        string dst = \"\";\n        foreach (XmlNode n in nodeList)\n        {\n            foreach (XmlNode cn in n.ChildNodes)\n            {\n                if (cn.Name == \"source\")\n                {\n                    src = cn.InnerText;\n                }\n                if (cn.Name == \"translation\")\n                {\n                    dst = cn.InnerText;\n                    IRow row = sheet.CreateRow(rowCnt);\n                    rowCnt++;\n                    ICell firstCell = row.CreateCell(0);\n                    firstCell.SetCellValue(src);\n                    ICell secondCell = row.CreateCell(1);\n                    secondCell.SetCellValue(dst);\n                    //Console.WriteLine (\"Src = \" + src + \" dst = \" + dst);\n                }\n            }\n        }\n    }\n\n    reader.Close();\n\n    using (FileStream fs = File.Create(excelFileName))\n    {\n        workbook.Write(fs);\n    }\n}\n\n\nExcel 转 TS 文件\nprivate bool convertExcelFile2QtFile(string excelFileName, string qtFileName)\n{\n    try\n    {\n        using (var fs = File.OpenRead(excelFileName))\n        {\n            var workBook = new XSSFWorkbook(fs);\n            var sheet = workBook.GetSheetAt(0);\n            var translateMap = new Dictionary<string, string>();\n\n            for (int i = 1; i < sheet.LastRowNum; i++)\n            {\n                IRow row = sheet.GetRow(i);\n\n                if (row == null)\n                {\n                    continue;\n                }\n\n                var srcCell = row.GetCell(0);\n                var dstCell = row.GetCell(1);\n\n                if (srcCell == null)\n                {\n                    continue;\n                }\n                if (dstCell == null)\n                {\n                    continue;\n                }\n\n                string src = srcCell.ToString();\n                string translated = dstCell.ToString();\n\n                if (translateMap.ContainsKey(src) == false)\n                {\n                    translateMap.Add(src, translated);\n                }\n            }\n\n            var document = new XmlDocument();\n            document.Load(qtFileName);\n\n            XmlNodeList xnl = document.SelectNodes(\"/TS/context\");\n\n            if (xnl != null)\n            {\n                foreach (XmlNode ctxNode in xnl)\n                {\n                    var msgList = ctxNode.SelectNodes(\"message\");\n                    foreach (XmlNode msg in msgList)\n                    {\n                        string src = \"\";\n\n                        foreach (XmlNode cn in msg.ChildNodes)\n                        {\n                            if (cn.Name == \"source\")\n                            {\n                                src = cn.InnerText;\n                            }\n                            else if (cn.Name == \"translation\")\n                            {\n                                if (translateMap.ContainsKey(src))\n                                {\n                                    cn.InnerText = translateMap[src];\n                                    var attrs = cn.Attributes;\n                                    attrs.Remove(attrs[\"type\"]);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            document.Save(qtFileName);\n        }\n        return true;\n    }\n    catch (Exception e)\n    {\n        MessageBox.Show(\"Exception:\" + e.Message);\n        return false;\n    }\n}\n\n     \n自动翻译词条\n其实了解了 TS 文件的结构之后，我们还能做一件事，那就是直接调用网上的翻译接口，自动将所有的词条翻译成对应的语言，下面就是一个简单的例子。\nimport xml.etree.ElementTree as ET\nimport os\n\nimport httplib\nimport md5\nimport urllib\nimport random\nimport json\nimport threading\n\nimport requests\nfrom PyQt4.QtCore import *\nfrom PyQt4.QtGui import *\n\nimport sys\nreload(sys)\nsys.setdefaultencoding('utf-8')\n\n\n## 下面填写你自己的百度翻译 API 的 appid 和 secretKey\nappid = ''\nsecretKey = ''\n\nmyurl = '/api/trans/vip/translate'\n\ndef translate(string, targetLanguage):\n    if string is None:\n        return \"\"\n    salt = random.randint(32768, 65536)\n    sign = appid + string + str(salt) + secretKey\n    m1 = md5.new()\n    m1.update(sign)\n    sign = m1.hexdigest()\n    encoded_str = urllib.quote(str(string))\n    localurl = myurl + '?appid=' + appid + '&q=' + \\\n        encoded_str + '&from=auto&to=' + \\\n        targetLanguage + '&salt=' + str(salt) + '&sign=' + sign\n\n    try:\n        r = requests.get('http://api.fanyi.baidu.com/' + localurl)\n\n        if r.status_code == 200:\n            response = r.text\n            objResponse = json.loads(response)\n            return objResponse[\"trans_result\"][0][\"dst\"]\n    except Exception, e:\n        print e\n    \n    return string\n\n\nclass MainWidget(QWidget):\n    def __init__(self, parent=None):\n        super(QWidget, self).__init__(parent)\n        self.setWindowTitle(u\"UI Auto Translator\")\n        self.labelTargetLanguage = QLabel(u\"目标语言:\")\n        self.comboTargetLanguage = QComboBox()\n        self.comboTargetLanguage.addItem(u\"中文\", u\"zh\")\n        self.comboTargetLanguage.addItem(u\"英语\", u\"en\")\n        self.comboTargetLanguage.addItem(u\"粤语\", u\"yue\")\n        self.comboTargetLanguage.addItem(u\"文言文\", u\"wyw\")\n        self.comboTargetLanguage.addItem(u\"日语\", u\"jp\")\n        self.comboTargetLanguage.addItem(u\"韩语\", u\"kor\")\n        self.comboTargetLanguage.addItem(u\"法语\", u\"fra\")\n        self.comboTargetLanguage.addItem(u\"西班牙语\", u\"spa\")\n        self.comboTargetLanguage.addItem(u\"泰语\", u\"th\")\n        self.comboTargetLanguage.addItem(u\"阿拉伯语\", u\"ara\")\n        self.comboTargetLanguage.addItem(u\"俄语\", u\"ru\")\n        self.comboTargetLanguage.addItem(u\"葡萄牙语\", u\"pt\")\n        self.comboTargetLanguage.addItem(u\"德语\", u\"de\")\n        self.comboTargetLanguage.addItem(u\"意大利语\", u\"it\")\n        self.comboTargetLanguage.addItem(u\"希腊语\", u\"el\")\n        self.comboTargetLanguage.addItem(u\"荷兰语\", u\"nl\")\n        self.comboTargetLanguage.addItem(u\"波兰语\", u\"pl\")\n        self.comboTargetLanguage.addItem(u\"保加利亚语\", u\"bul\")\n        self.comboTargetLanguage.addItem(u\"爱沙尼亚语\", u\"est\")\n        self.comboTargetLanguage.addItem(u\"丹麦语\", u\"dan\")\n        self.comboTargetLanguage.addItem(u\"芬兰语\", u\"fin\")\n        self.comboTargetLanguage.addItem(u\"捷克语\", u\"cs\")\n        self.comboTargetLanguage.addItem(u\"罗马尼亚语\", u\"rom\")\n        self.comboTargetLanguage.addItem(u\"斯洛文尼亚语\", u\"slo\")\n        self.comboTargetLanguage.addItem(u\"瑞典语\", u\"swe\")\n        self.comboTargetLanguage.addItem(u\"匈牙利语\", u\"hu\")\n        self.comboTargetLanguage.addItem(u\"繁体中文\", u\"cht\")\n        self.comboTargetLanguage.addItem(u\"越南语\", u\"vie\")\n\n        self.labelSrcFile = QLabel(u\"源文件\")\n        self.inputSrcFile = QLineEdit()\n        self.inputSrcBtn = QPushButton(u\"打开文件\")\n\n        self.connect(self.inputSrcBtn, SIGNAL(\n            \"clicked()\"), self.onInputSrcBtnClicked)\n\n        self.labelTargetFile = QLabel(u\"保存文件\")\n        self.inputTargetFile = QLineEdit()\n        self.inputTargetBtn = QPushButton(u\"选择文件名\")\n        self.connect(self.inputTargetBtn, SIGNAL(\n            \"clicked()\"), self.onInputTargetBtnClicked)\n\n        self.cvtBtn = QPushButton(u\"开始翻译\")\n        self.connect(self.cvtBtn, SIGNAL(\"clicked()\"), self.onCvtBtnClicked)\n\n        self.gridLayout = QGridLayout()\n\n        self.gridLayout.addWidget(self.labelTargetLanguage, 0, 0)\n        self.gridLayout.addWidget(self.comboTargetLanguage, 0, 1)\n\n        self.gridLayout.addWidget(self.labelSrcFile, 1, 0)\n        self.gridLayout.addWidget(self.inputSrcFile, 1, 1)\n        self.gridLayout.addWidget(self.inputSrcBtn, 1, 2)\n\n        self.gridLayout.addWidget(self.labelTargetFile, 2, 0)\n        self.gridLayout.addWidget(self.inputTargetFile, 2, 1)\n        self.gridLayout.addWidget(self.inputTargetBtn, 2, 2)\n\n        self.vLayout = QVBoxLayout()\n        self.vLayout.addLayout(self.gridLayout)\n        self.vLayout.addWidget(self.cvtBtn)\n        self.setLayout(self.vLayout)\n\n    @pyqtSlot()\n    def onInputSrcBtnClicked(self):\n        fileName = QFileDialog.getOpenFileName(\n            self, u\"打开要翻译的文件\", u\".\", u\"*.ts\")\n        if fileName.isEmpty():\n            QMessageBox.warning(self, u\"警告\", u\"未选择要翻译的文件\", QMessageBox.Ok)\n            return\n\n        self.inputSrcFile.setText(fileName)\n\n    @pyqtSlot()\n    def onInputTargetBtnClicked(self):\n        fileName = QFileDialog.getSaveFileName(\n            self, u\"选择另存为的文件名\", u\".\", u\"*.ts\")\n        if fileName.isEmpty():\n            QMessageBox.warning(self, u\"警告\", u\"未选择要保存为的文明名\", QMessageBox.Ok)\n            return\n\n        self.inputTargetFile.setText(fileName)\n\n        \n    def process_file(self, src, dst, lang):\n        self.cvtBtn.setText(u\"正在翻译中...\")\n        tree = ET.parse(src)\n\n        root = tree.getroot()\n        source = \"\"\n\n        for ctx in root:\n            for msg in ctx:\n                if msg.tag == 'message':\n                    for tag in msg:\n                        if tag.tag == 'source':\n                            source = tag.text\n                        if tag.tag == 'translation':\n                            tag.text = translate(source, lang)\n                            print(\"source = {0}, translate = {1}\".format(source, tag.text))\n                            tag.set('type', '')\n        tree.write(dst)\n\n        self.cvtBtn.setText(u\"开始翻译\")\n\n    @pyqtSlot()\n    def onCvtBtnClicked(self):\n        targetLang = self.comboTargetLanguage.itemData(\n            self.comboTargetLanguage.currentIndex()).toString()\n        srcFileName = self.inputSrcFile.text()\n        if srcFileName.isEmpty():\n            QMessageBox.warning(self, u\"警告\", u\"未选择要翻译的文件\", QMessageBox.Ok)\n            return\n\n        targetFileName = self.inputTargetFile.text()\n        if targetFileName.isEmpty():\n            QMessageBox.warning(self, u\"警告\", u\"未选择要保存为的文明名\", QMessageBox.Ok)\n            return\n\n        t = threading.Thread(target=self.process_file, args=(srcFileName, targetFileName, str(targetLang)))\n\n        t.setDaemon(True)\n        t.start()\n\nif __name__ == \"__main__\":\n    app = QApplication(sys.argv)\n\n    widget = MainWidget()\n    widget.show()\n    \n    app.exec_()\n    \nhttps://huzhenyu.me/qt/2018/0...\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "0"}