{"title": "Tensorflow Python API 翻译（math_ops）（第二部分） - 个人文章 ", "index": "python", "content": "作者：chen_h微信号 & QQ：862251340微信公众号：coderpai简书地址：https://www.jianshu.com/p/4da...\n\n计划现将 tensorflow 中的 Python API 做一个学习，这样方便以后的学习。原文链接\n\n该章介绍有关数学符号操作的API\n\n\n第一部分\n第二部分\n\n\n减少元素操作\nTensorFlow提供了一些操作，你可以用它来执行常见的数学运算，以此减少张量的维度。\n\ntf.reduce_sum(input_tensor, reduction_indices=None, keep_dims=False, name=None)\n解释：这个函数的作用是计算指定维度的元素总和。\n沿着给定的reduction_indices维度，累加input_tensor中该维度的元素，最后返回累加的值。如果keep_dims = False，沿着reduction_indices维度进行累加，最后返回一个秩为1的tensor。如果keep_dims = True，那么每一维度的累加值返回一个秩为1的tensor。\n如果reduction_indices没有给定，那么我们将input_tensor中的元素全部进行累加，最后返回一个标量。\n比如：\n# 'x' is [[1, 1, 1]]\n#         [1, 1, 1]]\ntf.reduce_sum(x) ==> 6\ntf.reduce_sum(x, 0) ==> [2, 2, 2]\ntf.reduce_sum(x, 1) ==> [3, 3]\ntf.reduce_sum(x, 1, keep_dims=True) ==> [[3], [3]]\ntf.reduce_sum(x, [0, 1]) ==> 6\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np\n\na = tf.constant(np.random.rand(3,4))\nc = tf.reduce_sum(a, 1, keep_dims = True)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\ninput_tensor: 一个累加的Tensor，它应该是数字类型。\n\nreduction_indices: 指定累加的维度。如果是None，那么累加所有的元素。\n\nkeep_dims: 如果是True，那么指定维度中的元素累加返回一个秩为1的Tensor。如果是False，那么返回一个累加的标量。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个累加的Tensor。\n\ntf.reduce_prod(input_tensor, reduction_indices=None, keep_dims=False, name=None)\n解释：这个函数的作用是计算指定维度的元素相乘的总和。\n沿着给定的reduction_indices维度，累乘input_tensor中该维度的元素，最后返回累乘的值。如果keep_dims = False，沿着reduction_indices维度进行累乘，最后返回一个秩为1的tensor。如果keep_dims = True，那么每一维度的累乘值返回一个秩为1的tensor。\n如果reduction_indices没有给定，那么我们将input_tensor中的元素全部进行累乘，最后返回一个标量。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np\n\na = tf.constant([[2,3,1],[4,5,1]])\nc = tf.reduce_prod(a, 0)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\ninput_tensor: 一个累乘的Tensor，它应该是数字类型。\n\nreduction_indices: 指定累乘的维度。如果是None，那么累乘所有的元素。\n\nkeep_dims: 如果是True，那么指定维度中的元素累乘返回一个秩为1的Tensor。如果是False，那么返回一个累乘的标量。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个累乘的Tensor。\n\ntf.reduce_min(input_tensor, reduction_indices=None, keep_dims=False, name=None)\n解释：这个函数的作用是计算指定维度的元素中的最小值。\n沿着给定的reduction_indices维度，找到input_tensor中该维度的元素的最小值，最后返回这个最小值。如果keep_dims = False，沿着reduction_indices维度寻找最小值，最后返回一个秩为1的tensor。如果keep_dims = True，那么每一维度的最小值返回一个秩为1的tensor。\n如果reduction_indices没有给定，那么我们取input_tensor中的最小元素，最后返回一个标量。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np\n\na = tf.constant([[2,3,2],[4,5,1]])\nc = tf.reduce_min(a, 0)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\ninput_tensor: 一个需要处理的Tensor，它应该是数字类型。\n\nreduction_indices: 指定需要查找最小值的维度。如果是None，那么从所有的元素中找最小值。\n\nkeep_dims: 如果是True，那么指定维度中的最小值返回一个秩为1的Tensor。如果是False，那么返回一个最小值的标量。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个处理之后的Tensor。\n\ntf.reduce_max(input_tensor, reduction_indices=None, keep_dims=False, name=None)\n解释：这个函数的作用是计算指定维度的元素中的最大值。\n沿着给定的reduction_indices维度，找到input_tensor中该维度的元素的最大值，最后返回这个最大值。如果keep_dims = False，沿着reduction_indices维度寻找最大值，最后返回一个秩为1的tensor。如果keep_dims = True，那么每一维度的最大值返回一个秩为1的tensor。\n如果reduction_indices没有给定，那么我们取input_tensor中的最大元素，最后返回一个标量。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np\n\na = tf.constant([[2,3,2],[4,5,1]])\nc = tf.reduce_max(a, 0)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\ninput_tensor: 一个需要处理的Tensor，它应该是数字类型。\n\nreduction_indices: 指定需要查找最大值的维度。如果是None，那么从所有的元素中找最大值。\n\nkeep_dims: 如果是True，那么指定维度中的最大值返回一个秩为1的Tensor。如果是False，那么返回一个最大值的标量。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个处理之后的Tensor。\n\ntf.reduce_mean(input_tensor, reduction_indices=None, keep_dims=False, name=None)\n解释：这个函数的作用是计算指定维度中的元素的平均值。\n沿着给定的reduction_indices维度，找到input_tensor中该维度的元素的平均值，最后返回这个平均值。如果keep_dims = False，沿着reduction_indices维度寻找平均值，最后返回一个秩为1的tensor。如果keep_dims = True，那么每一维度的平均值返回一个秩为1的tensor。\n如果reduction_indices没有给定，那么我们取input_tensor中的平均值，最后返回一个标量。\n比如：\n# 'x' is [[1., 1. ]]\n#         [2., 2.]]\ntf.reduce_mean(x) ==> 1.5\ntf.reduce_mean(x, 0) ==> [1.5, 1.5]\ntf.reduce_mean(x, 1) ==> [1.,  2.]\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np\n\na = tf.constant([[2,3,2],[4,5,1]], tf.float32)\nc = tf.reduce_mean(a, 0)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\ninput_tensor: 一个需要处理的Tensor，它应该是数字类型。\n\nreduction_indices: 指定需要查找平均值的维度。如果是None，那么从所有的元素中找平均值。\n\nkeep_dims: 如果是True，那么指定维度中的平均值返回一个秩为1的Tensor。如果是False，那么返回一个平均值的标量。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个处理之后的Tensor。\n\ntf.reduce_all(input_tensor, reduction_indices=None, keep_dims=False, name=None)\n解释：这个函数的作用是计算指定维度中的元素的逻辑与。\n沿着给定的reduction_indices维度，找到input_tensor中该维度的元素的逻辑与，最后返回这个逻辑与值。如果keep_dims = False，沿着reduction_indices维度寻找逻辑与值，最后返回一个秩为1的tensor。如果keep_dims = True，那么每一维度的逻辑与值返回一个秩为1的tensor。\n如果reduction_indices没有给定，那么我们取input_tensor中的逻辑与值，最后返回一个标量。\n比如：\n# 'x' is [[True,  True]]\n#         [False, False]]\ntf.reduce_all(x) ==> False\ntf.reduce_all(x, 0) ==> [False, False]\ntf.reduce_all(x, 1) ==> [True, False]\n\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np\n\na = tf.constant([[False, False,True],[False,True,True]])\nc = tf.reduce_all(a, 0)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\ninput_tensor: 一个需要处理的Tensor，它应该是数字类型。\n\nreduction_indices: 指定需要查找逻辑与值的维度。如果是None，那么从所有的元素中找逻辑与值。\n\nkeep_dims: 如果是True，那么指定维度中的逻辑与值返回一个秩为1的Tensor。如果是False，那么返回一个逻辑与值的标量。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个处理之后的Tensor。\n\ntf.reduce_any(input_tensor, reduction_indices=None, keep_dims=False, name=None)\n解释：这个函数的作用是计算指定维度中的元素的逻辑或。\n沿着给定的reduction_indices维度，找到input_tensor中该维度的元素的逻辑或，最后返回这个逻辑或值。如果keep_dims = False，沿着reduction_indices维度寻找逻辑或值，最后返回一个秩为1的tensor。如果keep_dims = True，那么每一维度的逻辑或值返回一个秩为1的tensor。\n如果reduction_indices没有给定，那么我们取input_tensor中的逻辑或值，最后返回一个标量。\n比如：\n# 'x' is [[True,  True]]\n#         [False, False]]\ntf.reduce_all(x) ==> False\ntf.reduce_all(x, 0) ==> [True, True]\ntf.reduce_all(x, 1) ==> [True, False]\n\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np\n\na = tf.constant([[False, False,True],[False,True,True]])\nc = tf.reduce_any(a, 0)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\ninput_tensor: 一个需要处理的Tensor，它应该是数字类型。\n\nreduction_indices: 指定需要查找逻辑或值的维度。如果是None，那么从所有的元素中找逻辑或值。\n\nkeep_dims: 如果是True，那么指定维度中的逻辑或值返回一个秩为1的Tensor。如果是False，那么返回一个逻辑或值的标量。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个处理之后的Tensor。\n\ntf.accumulate_n(inputs, shape=None, tensor_dtype=None, name=None)\n解释：这个函数的作用是计算张量列表中每个对应的元素的累加和。\n其中，shape和tensor_dtype是可选项，主要是为了验证最后返回的累加值的数据维度和数据类型是否和猜测的一样，如果不一样，将会报错。\n比如：\n# tensor 'a' is [[1, 2], [3, 4]\n# tensor `b` is [[5, 0], [0, 6]]\ntf.accumulate_n([a, b, a]) ==> [[7, 4], [6, 14]]\n\n# Explicitly pass shape and type\ntf.accumulate_n([a, b, a], shape=[2, 2], tensor_dtype=tf.int32)\n  ==> [[7, 4], [6, 14]]\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np\n\na = tf.constant([[1, 2], [3, 4]])\nb = tf.constant([[5, 0], [0, 6]])\nc = tf.accumulate_n([a,b,a], shape = [2,2])\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\ninputs: 一个需要处理的Tensor列表，其中每一个tensor都必须拥有相同的数据维度和数据类型。\n\nshape: inputs的数据维度。\n\ntensor_dtype: inputs的数据类型。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据维度和数据类型都和inputs相同。\n异常：\n如果inputs中每一个tensor的数据维度不一样，或者推测的数据维度或数据类型不正确，那么都会抛出异常。\n\n分割操作\nTensorFlow提供了一些操作，你可以使用基本的算术运算来分割输入的tensor。这里的分割操作是沿着第一个维度的一个分区，等价于这里定义了一个从第一个维度到第segment_ids维度的一个映射。segment_ids张量的长度必须和需要分割的tensor的第一维度的尺寸d0一样，其中segment_ids中的编号从0到k，并且k < d0。举个例子，如果我们需要分割的tensor是一个矩阵，那么segment_ids的映射就指向矩阵的每一行。\n比如：\nc = tf.constant([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8]])\ntf.segment_sum(c, tf.constant([0, 0, 1]))\n  ==>  [[0 0 0 0]\n        [5 6 7 8]]\n\ntf.segment_sum(data, segment_ids, name=None)\n解释：这个函数的作用是沿着segment_ids指定的维度，分割张量data中的值，并且返回累加值。\n计算公式为:\n\n其中，segment_ids[j] == i。\n\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np\n\na = tf.constant([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8], [-1,-2,-3,-4]])\nc = tf.segment_sum(a, tf.constant([0, 0, 1, 2]))\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\ndata: 一个Tensor，数据类型必须是以下之一：float32，float64，int32，int64，uint8，int16，int8。\n\nsegment_ids: 一个tensor，数据类型必须是int32或者int64，数据维度是一维的，并且长度和data第一维度的长度相同。里面的值是从0到k的有序排列，但是可以重复。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和data相同，数据的第一维度是k，其余维度和data相同。\n\ntf.segment_prod(data, segment_ids, name=None)\n解释：这个函数的作用是沿着segment_ids指定的维度，分割张量data中的值，并且返回累乘值。\n计算公式为:\n\n其中，segment_ids[j] == i。\n\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np\n\na = tf.constant([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8], [-1,-2,-3,-4]])\nc = tf.segment_prod(a, tf.constant([0, 0, 1, 2]))\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\ndata: 一个Tensor，数据类型必须是以下之一：float32，float64，int32，int64，uint8，int16，int8。\n\nsegment_ids: 一个tensor，数据类型必须是int32或者int64，数据维度是一维的，并且长度和data第一维度的长度相同。里面的值是从0到k的有序排列，但是可以重复。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和data相同，数据的第一维度是k，其余维度和data相同。\n\ntf.segment_min(data, segment_ids, name=None)\n解释：这个函数的作用是沿着segment_ids指定的维度，分割张量data中的值，并且返回最小值。\n计算公式为:\n\n其中，segment_ids[j] == i。\n\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np\n\na = tf.constant([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8], [-1,-2,-3,-4]])\nc = tf.segment_min(a, tf.constant([0, 0, 1, 2]))\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\ndata: 一个Tensor，数据类型必须是以下之一：float32，float64，int32，int64，uint8，int16，int8。\n\nsegment_ids: 一个tensor，数据类型必须是int32或者int64，数据维度是一维的，并且长度和data第一维度的长度相同。里面的值是从0到k的有序排列，但是可以重复。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和data相同，数据的第一维度是k，其余维度和data相同。\n\ntf.segment_max(data, segment_ids, name=None)\n解释：这个函数的作用是沿着segment_ids指定的维度，分割张量data中的值，并且返回最大值。\n计算公式为:\n\n其中，segment_ids[j] == i。\n\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np\n\na = tf.constant([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8], [-1,-2,-3,-4]])\nc = tf.segment_max(a, tf.constant([0, 0, 1, 2]))\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\ndata: 一个Tensor，数据类型必须是以下之一：float32，float64，int32，int64，uint8，int16，int8。\n\nsegment_ids: 一个tensor，数据类型必须是int32或者int64，数据维度是一维的，并且长度和data第一维度的长度相同。里面的值是从0到k的有序排列，但是可以重复。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和data相同，数据的第一维度是k，其余维度和data相同。\n\ntf.segment_mean(data, segment_ids, name=None)\n解释：这个函数的作用是沿着segment_ids指定的维度，分割张量data中的值，并且返回平均值。\n计算公式为:\n\n其中，segment_ids[j] == i。\n\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np\n\na = tf.constant([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8], [-1,-2,-3,-4]])\nc = tf.segment_mean(a, tf.constant([0, 0, 1, 2]))\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\ndata: 一个Tensor，数据类型必须是以下之一：float32，float64，int32，int64，uint8，int16，int8。\n\nsegment_ids: 一个tensor，数据类型必须是int32或者int64，数据维度是一维的，并且长度和data第一维度的长度相同。里面的值是从0到k的有序排列，但是可以重复。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和data相同，数据的第一维度是k，其余维度和data相同。\n\ntf.unsorted_segment_sum(data, segment_ids, num_segments, name=None)\n解释：这个函数的作用是沿着segment_ids指定的维度，分割张量data中的值，并且返回累加值。\n计算公式为:\n\n其中，segment_ids[j] == i。这个API和SegmentSum最大的区别是，这个API不需要从0到k有序排列，可以乱序排列，并且该API不需要包含从0到k。\n如果对于给定的分割区间ID i，output[i] = 0。那么，num_segmetns应该等于不同的段ID的数量。\n\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np\n\na = tf.constant([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8], [-1,-2,-3,-4]])\nc = tf.unsorted_segment_sum(a, tf.constant([0, 0, 1, 1]), 2)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\ndata: 一个Tensor，数据类型必须是以下之一：float32，float64，int32，int64，uint8，int16，int8。\n\nsegment_ids: 一个tensor，数据类型必须是int32或者int64，数据维度是一维的，并且长度和data第一维度的长度相同。\n\nnum_segments: 一个tensor，数据类型是int32。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和data相同，数据的第一维度是num_segments，其余维度和data相同。\n\ntf.sparse_segment_sum(data, indices, segment_ids, name=None)\n解释：这个函数的作用是沿着segment_ids指定的维度，分割张量data中的值，并且返回累加值。\n该API和SegmentSum差不多，但是该API的segment_ids的长度可以小于data的第一维度的长度，而是从indices中选择出需要切分的分割索引。\n比如：\nc = tf.constant([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8]])\n\n# Select two rows, one segment.\ntf.sparse_segment_sum(c, tf.constant([0, 1]), tf.constant([0, 0]))\n  ==> [[0 0 0 0]]\n\n# Select two rows, two segment.\ntf.sparse_segment_sum(c, tf.constant([0, 1]), tf.constant([0, 1]))\n  ==> [[ 1  2  3  4]\n       [-1 -2 -3 -4]]\n\n# Select all rows, two segments.\ntf.sparse_segment_sum(c, tf.constant([0, 1, 2]), tf.constant([0, 0, 1]))\n  ==> [[0 0 0 0]\n       [5 6 7 8]]\n\n# Which is equivalent to:\ntf.segment_sum(c, tf.constant([0, 0, 1]))\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np\n\na = tf.constant([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8], [-1,-2,-3,-4]])\nc = tf.sparse_segment_sum(a, tf.constant([0, 1, 1, 2]), tf.constant([0, 0, 1, 2]))\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\ndata: 一个Tensor，数据类型必须是以下之一：float32，float64，int32，int64，uint8，int16，int8。\n\nindices: 一个tensor，数据类型是int32，数据维度是一维的，长度和segment_ids相同。\n\nsegment_ids: 一个tensor，数据类型必须是int32，数据维度是一维的。里面的值是有序排列的，但是可以重复。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和data相同，数据的第一维度是k，其余维度和data相同。\n\ntf.sparse_segment_mean(data, indices, segment_ids, name=None)\n解释：这个函数的作用是沿着segment_ids指定的维度，分割张量data中的值，并且返回累加值。\n该API和SegmentSum差不多，但是该API的segment_ids的长度可以小于data的第一维度的长度，而是从indices中选择出需要切分的分割索引。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np\n\na = tf.constant([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8], [-1,-2,-3,-4]], tf.float32)\nc = tf.sparse_segment_mean(a, tf.constant([0, 1, 1, 2]), tf.constant([0, 0, 1, 2]))\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\ndata: 一个Tensor，数据类型必须是以下之一：float32，float64。\n\nindices: 一个tensor，数据类型是int32，数据维度是一维的，长度和segment_ids相同。\n\nsegment_ids: 一个tensor，数据类型必须是int32，数据维度是一维的。里面的值是有序排列的，但是可以重复。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和data相同，数据的第一维度是k，其余维度和data相同。\n\n序列比较和索引函数\nTensorFlow提供了一些操作，你可以使用这些函数去处理序列比较和索引提取，并且添加到你的图中。你可以使用这些函数去确定一些序列之间的差异，以及确定tensor中一些特定的值的索引。\n\ntf.argmin(input, dimension, name=None)\n解释：这个函数的作用是返回指定维度中的最小值的索引。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np\n\na = tf.constant([[11,22,3,4], [2,6,3,1]])\nc = tf.argmin(a, 1)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\ninput: 一个Tensor，数据类型必须是以下之一：float32，float64，int64，int32，uint8，uint16，int8，complex64，qint8，qint32。\n\ndimension: 一个tensor，数据类型是int32，0 <= dimension < rank(input)。这个参数选定了需要合并处理的哪个维度。如果输入input是一个向量，那么我们取dimension = 0。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型是int64。\n\ntf.argmax(input, dimension, name=None)\n解释：这个函数的作用是返回指定维度中的最大值的索引。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np\n\na = tf.constant([[11,22,3,4], [2,6,3,1]])\nc = tf.argmax(a, 1)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\ninput: 一个Tensor，数据类型必须是以下之一：float32，float64，int64，int32，uint8，uint16，int8，complex64，qint8，qint32。\n\ndimension: 一个tensor，数据类型是int32，0 <= dimension < rank(input)。这个参数选定了需要合并处理的哪个维度。如果输入input是一个向量，那么我们取dimension = 0。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型是int64。\n\ntf.listdiff(x, y, name=None)\n解释：这个函数的作用是计算两个列表中元素的不同值。\n给定一个列表x和列表y，这个操作返回一个列表out，列表中的元素是存在于x中，但不存在于y 中。列表out中的元素是按照原来x中的顺序是一样的。这个操作也返回一个索引列表idx，表示out中的值在原来x中的索引位置，即：\nout[i] = x[idx[i]] for i in [0, 1, ..., len(out) - 1]\n比如：\n输入数据为：\nx = [1, 2, 3, 4, 5, 6]\ny = [1, 3, 5]\n输出数据为：\nout ==> [2, 4, 6]\nidx ==> [1, 3, 5]\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np\n\na = tf.constant([2,6,3,1])\nb = tf.constant([11,22,3,4, 8])\nc = tf.listdiff(a, b)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\nx: 一个一维的Tensor，里面的值是需要保留的。\n\ny: 一个一维的tensor，数据类型和x相同，里面的值是需要去除的。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个tensor元祖，里面的元素为(out, idx)。\n\n\nout: 一个tensor，数据类型和x相同，数据维度是一维的，里面的元素存在于x中，但不存在与y中。\n\nidx: 一个tensor，数据类型是int32，数据维度是一维的，里面的元素表示out中的值在原来x中的索引位置。\n\n\ntf.where(input, name=None)\n解释：这个函数的作用是返回input中元素是true的位置。\n这个操作是返回input中值为true的坐标。坐标是保存在一个二维的tensor中，其中第一维度表示true元素的个数，第二维度表示true元素的坐标。记住，输出tensor的维度依赖于input中true的个数。并且里面的坐标排序按照input中的排序。\n比如：\n# 'input' tensor is [[True, False]\n#                    [True, False]]\n# 'input' has two true values, so output has two coordinates.\n# 'input' has rank of 2, so coordinates have two indices.\nwhere(input) ==> [[0, 0],\n                  [1, 0]]\n\n# `input` tensor is [[[True, False]\n#                     [True, False]]\n#                    [[False, True]\n#                     [False, True]]\n#                    [[False, False]\n#                     [False, True]]]\n# 'input' has 5 true values, so output has 5 coordinates.\n# 'input' has rank of 3, so coordinates have three indices.\nwhere(input) ==> [[0, 0, 0],\n                  [0, 1, 0],\n                  [1, 0, 1],\n                  [1, 1, 1],\n                  [2, 1, 1]]\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np\n\na = tf.constant([[True, False],[False, True]])\nc = tf.where(a)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\ninput: 一个Tensor，数据类型是布尔类型bool。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个tensor，数据类型是int64。\n\ntf.unique(x, name=None)\n解释：这个函数的作用是找到x中的唯一元素。\n这个操作是返回一个张量y，里面的元素都是x中唯一的值，并且按照原来x中的顺序进行排序。这个操作还会返回一个位置张量idx，这个张量的数据维度和x相同，表示的含义是x中的元素在y中的索引位置，即：\ny[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]\n比如：\n# tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]\ny, idx = unique(x)\ny ==> [1, 2, 4, 7, 8]\nidx ==> [0, 0, 1, 2, 2, 2, 3, 4, 4]\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np\n\na = tf.constant([1, 1, 24, 4, 4, 4, 7, 8, 8])\nc, d = tf.unique(a)\nsess = tf.Session()\nprint sess.run(c)\nprint sess.run(d)\nsess.close()\n输入参数：\n\n\nx: 一个Tensor，数据维度是一维的。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个tensor元祖，里面的元素为(y, idx)。\n\n\ny: 一个tensor，数据类型和x相同，数据维度是一维的。\n\nidx: 一个tensor，数据类型是int32，数据维度是一维的。\n\n\ntf.edit_distance(hypothesis, truth, normalize=True, name='edit_distance')\n解释：这个函数的作用是计算两个序列之间的编辑距离，即Levenshtein距离。\n这个操作输入的是两个可变长度序列hypothesis和truth，每个序列都是SparseTensor，之后计算编辑距离。如果你将normalize设置为true，那么最后结果将根据truth的长度进行归一化。\n比如：\n输入数据：\n# 'hypothesis' is a tensor of shape `[2, 1]` with variable-length values:\n#   (0,0) = [\"a\"]\n#   (1,0) = [\"b\"]\nhypothesis = tf.SparseTensor(\n    [[0, 0, 0],\n     [1, 0, 0]],\n    [\"a\", \"b\"]\n    (2, 1, 1))\n\n# 'truth' is a tensor of shape `[2, 2]` with variable-length values:\n#   (0,0) = []\n#   (0,1) = [\"a\"]\n#   (1,0) = [\"b\", \"c\"]\n#   (1,1) = [\"a\"]\ntruth = tf.SparseTensor(\n    [[0, 1, 0],\n     [1, 0, 0],\n     [1, 0, 1],\n     [1, 1, 0]]\n    [\"a\", \"b\", \"c\", \"a\"],\n    (2, 2, 2))\n\nnormalize = True\n输出数据：\n# 'output' is a tensor of shape `[2, 2]` with edit distances normalized\n# by 'truth' lengths.\noutput ==> [[inf, 1.0],  # (0,0): no truth, (0,1): no hypothesis\n           [0.5, 1.0]]  # (1,0): addition, (1,1): no hypothesis\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np\n\n\nhypothesis = tf.SparseTensor(\n    [[0, 0, 0],\n     [1, 0, 0]],\n    [\"a\", \"b\"],\n    (2, 1, 1))\n\ntruth = tf.SparseTensor(\n    [[0, 1, 0],\n     [1, 0, 0],\n     [1, 0, 1],\n     [1, 1, 0]],\n    [\"a\", \"b\", \"c\", \"a\"],\n    (2, 2, 2))\n\nc = tf.edit_distance(hypothesis, truth)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\nhypothesis: 一个SparseTensor，表示猜测的数据序列。\n\ntruth: 一个SparseTensor，表示真实的数据序列。\n\nnormalize: 一个布尔类型，如果设置为true，那么最后结果将根据truth的长度进行归一化。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个密集tensor，其秩为R-1。其中，R是输入hypothesis和truth的秩。\n异常:\n\n类型异常: 如果hypothesis和truth不是SparseTensor类型的，那么就会抛出这个异常。\n\ntf.invert_permutation(x, name=None)\n解释：这个函数的作用是计算张量x的逆置换。\n这个操作是计算张量x的逆置换。输入参数x是一个一维的整型tensor，它表示一个从0开始的数组的索引，并且交换其索引位置的每个值，得到的结果就是输出y。 输出结果y的具体计算公式如下：\ny[x[i]] = i for i in [0, 1, ..., len(x) - 1]\n该参数x必须包含0，并且不能有重复数据和负数。\n比如：\n# tensor `x` is [3, 4, 0, 2, 1]\ninvert_permutation(x) ==> [2, 4, 3, 0, 1]\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np\n\n\na = tf.constant([3, 4, 0, 2, 1])\nc = tf.invert_permutation(a)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\nx: 一个Tensor，数据类型是int32，数据维度是一维的。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个tensor，数据类型是int32，数据维度是一维的。\n\n作者：chen_h微信号 & QQ：862251340简书地址：https://www.jianshu.com/p/4da...\nCoderPai 是一个专注于算法实战的平台，从基础的算法到人工智能算法都有设计。如果你对算法实战感兴趣，请快快关注我们吧。加入AI实战微信群，AI实战QQ群，ACM算法微信群，ACM算法QQ群。长按或者扫描如下二维码，关注 “CoderPai” 微信号（coderpai）\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}