{"title": "python开发时几种安全验证的实现 - 个人文章 ", "index": "flask,python", "content": "额,一个突然的交流让我想起来我耽搁许久各种验证的实现迟迟没做过趁着这个机会就搞了一下分为三部分:邮箱验证,短信验证,图片验证码\n邮箱验证\n这个部分是主要参考的经典书籍-狗书思路就是根据用户某些信息通过JSON Web签名生成token,然后再发送邮件验证,经典思路生成和验证函数都加载在模型中完整代码itsdangerous中文文档这里介绍了几种签名方式\ntoken生成和验证TimedJSONWebSignatureSerializer,看这个表面词的意思可以看出这里序列化加入了当前时间这也是实现设置过期时间的依据吧查看itsdangerous源码可以看到具体的加密方式\nfrom itsdangerous import (TimedJSONWebSignatureSerializer as Serializer, BadSignature, SignatureExpired)\n...\nclass User(db.Model):\n    __tablename__ = 'user'\n    id = db.Column(db.Integer,primary_key=True)\n    name=db.Column(db.String(64),unique=True,index=True)\n\n    def genter_auth_token(self,expiration=300): #设置有效期\n        s=Serializer(current_app.config['SECRET_KEY'],expires_in=expiration)\n        return s.dumps({'code':self.name}) #将用户名当作签名对象\n\n    @staticmethod\n    def verify_auth_token(token):\n        s=Serializer(current_app.config['SECRET_KEY'])\n        try:\n            data=s.loads(token) #加载数据\n        except BadSignature:\n            return None\n        except SignatureExpired:\n            return None\n        return data\n\n同时这里itdangerous类的签名方式都可以接收一个salt文档中这样描述了salt的作用:\nitsdangerous中的盐，是为了一个截然不同的目的而产生的。你可以将它视为成命名空间假设你想签名两个链接。你的系统有个激活链接，用来激活一个用户账户，并且你有一个升级链接，可以让一个用户账户升级为付费用户，这两个链接使用email发送。在这两种情况下，如果你签名的都是用户ID，那么该用户可以在激活账户和升级账户时，复用URL的可变部分。现在你可以在你签名的地方加上更多信息（如升级或激活的意图），但是你也可以用不同的盐\n即只有使用相同盐的序列化器才能成功把值加载出来\ndef genter_auth_token(self,expiration=300):\n    s=Serializer(current_app.config['SECRET_KEY'],salt='activate-salt',expires_in=expiration)\n    return s.dumps({'code':self.name})\n\n@staticmethod\ndef verify_auth_token(token):\n    s=Serializer(current_app.config['SECRET_KEY'],salt='activate-salt')\n图片验证码\n这个验证码可以直接调用一些平台的智能验证,也可以用另一种另一个也许是比较传统的思路,就是自己生成的图片水印,保存验证码python和php里都有相应的图片操作方法,这里就写下python的\n流程就是生成任意的数字,保存,添加图片水印\n这里肯定要用的python强大的图片处理库PIL,其中用到了加线条,滤镜等增加干扰下面是完整代码,该做注释的地方我已经加了注释看代码之前,最好先好好看下PIL官方文档,和一些基本概念部分我参考的博文也贴在了文末\n#!/usr/bin/env python \n#coding=utf-8\nimport os\nimport random\nfrom flask import Flask,send_from_directory\nfrom PIL import Image,ImageFont,ImageDraw,ImageFilter\n\napp=Flask(__name__)\napp.debug=True\n\nclass picture:\n    def __init__(self):\n        self.size = (240,60)\n        self.mode=\"RGB\"\n        self.color=\"white\"\n        self.font = ImageFont.truetype(\"C:\\Windows\\Fonts\\Arial.ttf\", 36) #设置字体大小\n\n    def randChar(self):\n        basic='23456789abcdefghijklmnpqrstwxyzABCDEFGHIJKLMNPQRSTWXYZ'\n        return basic[random.randint(0,len(basic)-1)] #随机字符\n\n    def randBdColor(self):\n        return (random.randint(64,255),random.randint(64,255),random.randint(64,255)) #背景\n\n    def randTextColor(self):\n        return (random.randint(32, 127), random.randint(32, 127), random.randint(32, 127)) #随机颜色\n\n    def proPicture(self):\n        new_image=Image.new(self.mode,self.size,self.color) #创建新图像有三个默认参数:尺寸,颜色,模式\n        drawObject=ImageDraw.Draw(new_image) #创建一个可以对image操作的对象\n        line_num = random.randint(4,6) # 干扰线条数\n        for i in range(line_num):\n            #size=(240,60)\n            begin = (random.randint(0, self.size[0]), random.randint(0, self.size[1]))\n            end = (random.randint(0, self.size[0]), random.randint(0, self.size[1]))\n            drawObject.line([begin, end], self.randTextColor())\n\n        for x in range(240):\n            for y in range(60):\n                tmp = random.randint(0,50)\n                if tmp>30: #调整干扰点数量\n                    drawObject.point((x,y),self.randBdColor())\n\n        randchar=''  \n        for i in range(5):\n            rand=self.randChar()\n            randchar+=rand\n            drawObject.text([50*i+10,10],rand,self.randTextColor(),font=self.font) #写入字符\n\n        new_image = new_image.filter(ImageFilter.SHARPEN) # 滤镜    \n\n        return new_image,randchar\n@app.route('/<filename>')\ndef get_file(filename):\n    return send_from_directory(os.getcwd(),filename)\n\n@app.route('/')\ndef index():\n    test=picture()\n    image,code=test.proPicture()\n    image.save('new.jpg')\n    url=\"http://127.0.0.1:5000/new.jpg\"\n    return '<img src='+url+' /><br/>'+\"图中的code为：\"+code \n    #这里有缓存,需要CTRL+F5才会有效果\n\nif __name__==\"__main__\":\n    app.run()\n另外,有的前辈会再加入了扭曲图像增加分辨难度\n# 图形扭曲参数 \nparams = [1 - float(random.randint(1, 2)) / 100, \n              0, \n              0, \n              0, \n              1 - float(random.randint(1, 10)) / 100, \n              float(random.randint(1, 2)) / 500, \n              0.001, \n              float(random.randint(1, 2)) / 500 \n              ] \nimg = img.transform(size, Image.PERSPECTIVE, params) # 创建扭曲\n这里有篇文章详细的介绍了下:\n对当前图像进行透视变换，产生给定尺寸的新图像。变量data是一个8元组(a,b,c,d,e,f,g,h)，包括一个透视变换的系数。对于输出图像中的每个像素点，新的值来自于输入图像的位置的(a x + b y + c)/(g x + h y + 1), (d x+ e y + f)/(g x + h y + 1)像素，使用最接近的像素进行近似\n这个的源定义就牵涉到了一个仿射变换,涉及一些数学的计算看得我有点懵逼,就没加到我的代码中,先留坑\n这个地方现在很多网站会使用另一种回答问题的方式,这个方法的实现我个人感觉也是应该也是相同的手段,只是将随机的字符串改为问题,将验证方式改为答案不过这里或许要把问题和答案存进数据库,更方便点,也才能实现\n\n短信验证\n有时候想自己是不是出生太晚了。。。。。想写的东西,都能搜到很好的博文,如下:flask开发restful api系列(5)-短信验证码这里云通讯是文中所用平台的开发文档,不过平台可以自由选择,结果都是一样这里就简化一下前辈的代码,把关于验证码处理的重点代码撸了出来,用到了Redis,我也趁机学了一波,的确挺好用的\nimport redis\nimport random\n\nphonenumber=188888888\n#这里可以利用正则过滤一下电话号码,比如：\n#/^(13[0-9]|14[5-9]|15[0-9]|16[6]|17[0-8]|18[0-9]|19[8-9])\\d{8}$/\n\nconn=redis.StrictRedis(host='127.0.0.1',port=6379)\n\ndef producCode():\n    verifyCode=str(random.randint(100000,999999))\n\n    pipe=conn.pipeline() #添加管道,可以一次连接执行多次命令\n    pipe.set(\"phone%s\"%phonenumber,verifyCode)\n    pipe.expire(\"phone%s\"%phonenumber,60) #设置过期时间一分钟\n    pipe.execute()\n\ndef checkCode():\n    pipe=conn.pipeline() #添加管道,可以一次连接执行多次命令\n    pipe.set('postNum%s'%phonenumber,'0')\n    validate_number = request.get_json().get('validate_number')\n    pipe.incr('postNum%s'%phonenumber) #记录提交次数防止爆破\n    if conn.get('postNum%s'%phonenumber)>3:\n        pass\n    ...\n    if validate_number != validate_number_in_redis:\n        return jsonify({'code': 0, 'message': '验证没有通过'})\n    pipe.set('is_validate:%s' % phone_number, '1') #通过验证码设置value为1\n    pipe.expire('is_validate:%s' % phone_number, 120)\n    pipe.execute()\n\n    return jsonify({'code': 1, 'message': '验证通过'})\ndef postMessage():\n    result=conn.get(\"phone%s\"%phonenumber)\n    #此时如果通过验证码,result为1,否则为0\n    ...\n    #剩下的其他操作\n这里提到了泄露接口导致验证码爆破的情况,我也添加了一些代码另外就是在某些功能模块,也易出现漏洞,比如修改资料处,验证码不仅仅要与phone一致也要检查用户名的一致性,要不然如果只是通过验证码,用户修改为自己的号码,验证码手机号都通过验证(感觉一般人不会出现这种错误)\n而你的代码又是直接传入用户名进行修改操作,这将可能导致任意用户重置密码或者你的代码直接将phone作为索引进行修改\nGithub完整代码地址\n参考文章: 狗书authentication杂项之图像处理pillowPIL一些基本概念PIL中的Image模块Python PIL ImageDraw和ImageFont模块学习Python图像处理库PIL的ImageFilter模块介绍Redis中文文档redis-py\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "3"}