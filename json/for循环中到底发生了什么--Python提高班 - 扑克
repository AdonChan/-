{"title": "for循环中到底发生了什么--Python提高班 - 扑克 ", "index": "python", "content": "我们都知道for in在代码中出现的次数相当的频繁, 那么你知道for in循环中到底发生了什么吗?\n\n答: 当我们调用一个for x in dataContainer的时候, 实际上是先调用了dataContainer的__iter__()方法来获得它的iterator(迭代器), 然后不断的调用next()方法, Python3.x里面是__next__(), 直到迭代器抛出StopIteration的异常, 停止\n\n什么是iterable和iterator\n\n上一篇如何理解yield中已经对interable已经略有介绍, 我们可以简单的认为可以使用for in的都是iterable的, 但是这只是从使用场景来说的, 下面就从它内部来说下\n\n\n\niterable: 如果一个数据容器定义了一个__iter__()方法, 那么它就是可迭代的\n\niterator: 如果一个object支持迭代协议, 也就是: 1. 定义一个__iter__返回它自身 2. 定义一个next()方法, 每次被调用的时候返回下一个值\n\n很明显list dict是iterable的, 但它不是iterator\n\n>>> a = [1,2,3]\n>>> a.__iter__\n<method-wrapper '__iter__' of list object at 0x2ad2cf8>\n>>> a.next()\nTraceback (most recent call last):\n  File \"<console>\", line 1, in <module>\nAttributeError: 'list' object has no attribute 'next'\n\n\n但是通过__iter__获得的就是它们的iterator迭代器\n\n>>> ai = a.__iter__()\n>>> ai\n<listiterator object at 0x2dfe310>\n>>> ai.next()\n1\n>>> ai.__iter__() is ai\nTrue\n\n\n如何构建iterable的容器\n\nclass MyList(list):\n    def __iter__(self):\n        return MyListIter(self)\n\nclass MyListIter(object):\n    \"\"\"一个实现List的Iterator的 Demo Class\"\"\"\n    def __init__(self, lst):\n        self.lst = lst\n        self.i = -1\n    def __iter__(self):\n        return self\n    def next(self):\n        if self.i<len(self.lst)-1:\n            self.i += 1         \n            return self.lst[self.i]\n        else:\n            raise StopIteration\n\nif __name__ == '__main__':\n    a = MyList([1, 2, 3, 4])\n    ia = iter(a)\n    print 'type(a): %r, type(ia): %r' %(type(a), type(ia))\n    for i in a: \n        print i,\n\n\n上面的一段代码中 MyListIter 就实现了 MyList的迭代器, 运行结果应该是\n\ntype(a): <class '__main__.MyList'>, type(ia): <class '__main__.MyListIter'>\n1 2 3 4\n\n\n如何把我们的变量iterable\n\n比如我们有一个需求, 需要返回所有0~4中数字和a~e中字母组合情况, 一般我们可能会这样写\n\nclass Combinations:\n    def __init__(self):\n        self.combs = []\n        for x in range(5):\n            for y in ['a', 'b', 'c', 'd', 'e']:\n                self.combs.append(\"%s%s\" % (x, y))\n\nfor c in Combinations().combs: print c\n\n\n这样的话, 我们每次都要调用Combinations的'combs'才能拿到所有的组合情况, 显然每次暴露combs出来非常的不优雅, 为什么不能for c in Combinations()这样呢?\n\n当然可以, 定义一个__iter__方法返回combs的迭代器就可以了\n\nclass Combinations:\n    def __init__(self):\n        self.combs = []\n        for x in range(5):\n            for y in ['a', 'b', 'c', 'd', 'e']:\n                self.combs.append(\"%s%s\" % (x, y))\n    def __iter__(self):\n        return iter(self.combs)\n\nfor c in Combinations(): print c\n\n\n参考: Understanding Python Iterables and Iterators\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "10"}