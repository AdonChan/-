{"title": "【tulip】 - IOCP - taowen ", "index": "iocp,python", "content": "为了让I/O阻塞的时候，程序还可以去干别的。除了使用线程模型，让操作系统的内核去调度多个线程，Windows提供了IOCP机制。简单来说就是一个操作系统提供的回调机制。分成四个步骤\n\n\n生成key，并建立映射关系：向操作系统创建一个key，程序内部把这个key和一个回调函数对应起来\n调用：执行阻塞的I/O操作，并指定key来对应这个I/O操作\n轮询，返回key：程序轮询操作系统询问是否有新的I/O操作完成，如果有完成的会返回对应的key\n用key查找，并回调：因为创建key的时候内部已经和一个回调函数对应起来了，所以这个时候之前映射好的函数会被回调\n\n前面的例子太复杂了，我们把accept后面的操作全部忽略掉。单独看一个服务器接收客户端连接的代码：\n\nimport socket\nfrom asyncio import _overlapped\nimport struct\n\nlisten_sock = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM, proto=socket.IPPROTO_IP)\nlisten_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\nlisten_sock.bind(('0.0.0.0', 9090))\nlisten_sock.listen(0)\nNULL = 0\nconcurrency=0xffffffff\n_iocp = _overlapped.CreateIoCompletionPort(_overlapped.INVALID_HANDLE_VALUE, NULL, 0, concurrency)\n_overlapped.CreateIoCompletionPort(listen_sock.fileno(), _iocp, 0, 0)\nconn_sock = socket.socket(listen_sock.family)\nconn_sock.settimeout(0)\nov = _overlapped.Overlapped(NULL)\nov.AcceptEx(listen_sock.fileno(), conn_sock.fileno())\ndef on_accepted():\n    buf = struct.pack('@P', listen_sock.fileno())\n    conn_sock.setsockopt(socket.SOL_SOCKET, _overlapped.SO_UPDATE_ACCEPT_CONTEXT, buf)\n    conn_sock.settimeout(listen_sock.gettimeout())\n    print('connected from %s:%s' % conn_sock.getpeername())\n    return conn_sock, conn_sock.getpeername()\ncallback_map = {}\nif ov.pending:\n    callback_map[ov.address] = on_accepted\nelse:\n    on_accepted()\nwhile True:\n    # wait maximum 1 second\n    status = _overlapped.GetQueuedCompletionStatus(_iocp, 1000)\n    if status is None:\n        continue # try again\n    err, transferred, key, address = status\n    callback = callback_map[address]\n    callback()\n    break\n\n\n这段代码使用了Python 3.4。其中 _overlapped.Overlapped(NULL) 这一步是创建key，ov.AcceptEx(listen_sock.fileno(), conn_sock.fileno()) 是做一个I/O调用，后面的 _overlapped.GetQueuedCompletionStatus(_iocp, 1000) 是轮询，callback_map[address] 这一步是根据返回的key查找对应的回调函数回调。\n这种实现方式与前面基于线程的方式显著不同：\n\n\n程序内状态的上下文的保存不再由操作系统负责，而是通过callback_map由程序代码自己来负责的\n操作系统只负责维护阻塞I/O操作与对应的key（也就是overlapped.address这个东西）的关系。程序内的多个并发流程（本例子里只有一个客户端）需要由程序自身通过key和callback_map来自己做调度。\n\n这样状态从多个线程的多个栈上，变成了只有一个线程，但是在线程内部有一个callback_map来维护单线程内多个并发流程的状态。某种程度上来说，相对于多线程是把一些操作系统的上下文保存和调度职责从操作系统内核移到了网络程序里。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "3"}