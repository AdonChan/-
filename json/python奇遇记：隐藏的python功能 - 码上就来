{"title": "python奇遇记：隐藏的python功能 - 码上就来 ", "index": "python", "content": "先不讲数据结构了，这次来说说python中一些不被注意的功能。\n在python的设计哲学中，有这么一条内容：“Simple is better than complex”，简单的代码比复杂的要好，这也是为什么python被推荐为初学者必学的语言。很多人初学python，往往会受到其他语言的影响，比如之前学过java的，把python代码写的像java一样。举个例子，在java中设计一个类时，我们常常会为内部变量定义get和set方法，这是保证封装性的重要手段，但是在python中却不建议这样做，python中的内部变量使用单下划线表示（比如self.__name），不过这样定义了还是可以访问到私有变量。怎么说？python中使用约定，我不会强制说这个变量你不能访问，但是你最好不要这样做。如果需要对变量进行其他操作，使用@parameter装饰器进行get和set封装，这样直接访问内部变量会出错。讲偏了，关于类和对象这方面的内容以后再说。\n你如果打开python交互环境，输入import this可以看到以下内容：\n\nThe Zen of Python, by Tim Peters\nBeautiful is better than ugly.       优美胜于丑陋\nExplicit is better than implicit.    明了胜于晦涩\nSimple is better than complex.       简单胜过复杂\nComplex is better than complicated.  复杂胜过凌乱\nFlat is better than nested.　　扁平胜于嵌套\nSparse is better than dense. 　间隔胜于紧凑\n......\n\n这些是python的设计哲学，后面还有一些没列出来，在写python代码时最好遵从这些设计哲学。\n第一个功能。\n如果让你写一段代码表示a大于2且小于10，大多数人都会用a > 2 && a < 10对吧，在python中你可以直接使用2 < a < 10。\na = 5\n# 可以这样\nprint(2 < a < 10)\n\n#  也可以这样\nprint(10 > a <= 9)\nTrue\nTrue\n\n\n还有一个很多人可能都知道的技巧，就地交换值，而不需要中间变量。\na = 2\nb = 3\nprint(a, b)\n# 直接交换\na, b = b, a\nprint(a, b)\n2 3\n3 2\n\n\n第二个功能。\n我们常常会需要用for循环来遍历序列中的值，然后进行某些操作。在其他语言中你可能这么写：\na = ['a', 'b', 'c', 'd', 'e']\n\nfor(int i = 0; i < len(a); i++):\n    print(a[i])\n在python中很多人会这么写，对a的长度使用range生成一个序列，然后遍历。\na = ['a', 'b', 'c', 'd', 'e']\n# 对a的长度使用range生成一个序列，然后遍历\nfor i in range(len(a)):\n   print(a[i])\na\nb\nc\nd\ne\n\n\n其实你可以这样写，直接使用enumerate方法，它会返回序列的下标和值。\na = ['a', 'b', 'c', 'd', 'e']\n# 对a的长度使用range生成一个序列，然后遍历\nfor i in enumerate(a):\n   print(i)\n\n# 或者这样\nfor index, value in enumerate(a):\n    print(index, value)\n(0, 'a')\n(1, 'b')\n(2, 'c')\n(3, 'd')\n(4, 'e')\n0 a\n1 b\n2 c\n3 d\n4 e\n\n\n第三个功能。\n一般情况下，循环语句和条件判断语句是互不相干的，if后面就是else，for之后是in。其实循环语句后面也可以跟着else。for之后跟着else的意思是，运行这个循环，然后执行else中的语句。\nfor i in foo:\n    if i == 0:\n        break\nelse:\n    print(\"i was never 0\")\n除了for循环后面可以跟着else，while和try/except之后也可以跟着else。\n第四个功能。\n用过字典的都知道，如果我们需要字典中某个键的值，可以使用d['key']来获取，如果key不存在的话会抛出异常，这样肯定不好了，如果使用d.get('key')，在key值不存在时会默认返回None，这样就不用关心是否会有异常发生。其实还可以这样，d.get('key'， 0)，第二个参数指定key不存在时用来代替的值。\n第五个功能。\n正则表达式是个很让人头疼的东西，如果能加上注释该多好，这样我就知道自己写的是什么了。在Python中你可以这样。\n# 对每一个规则使用引号括起来\npattern = (\n  \"^\"                 # beginning of string\n\"M{0,4}\"            # thousands - 0 to 4 M's\n\"(CM|CD|D?C{0,3})\"  # hundreds - 900 (CM), 400 (CD), 0-300 (0 to 3 C's),\n                    #            or 500-800 (D, followed by 0 to 3 C's)\n\"(XC|XL|L?X{0,3})\"  # tens - 90 (XC), 40 (XL), 0-30 (0 to 3 X's),\n                    #        or 50-80 (L, followed by 0 to 3 X's)\n\"(IX|IV|V?I{0,3})\"  # ones - 9 (IX), 4 (IV), 0-3 (0 to 3 I's),\n                    #        or 5-8 (V, followed by 0 to 3 I's)\n\"$\"                 # end of string\n )\nprint(pattern)\n\n# 然后bapattern放入对应的re匹配方法中。\n^M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$\n\n\n第六个功能。\n在上一篇迭代器和生成器中说过，iter()函数可以生成一个迭代器，之后你就能使用循环或者next方法来产出值。其实iter还接受第二个参数，它的作用是在迭代的过程中如果碰到第二个参数则停止。看个例子：\ndef seek_next_line(f):\n    for c in iter(lambda: f.read(1),'\\n'):\n        pass\n上面的代码中，从f中循环读入，如果碰到\\n则结束读取。\n其他的技巧像使用生成器表达式，利用拆包方法等等，之前都有说过，这里不再赘述。\n\n本人才疏学浅，上文中难免有些错误，还请各位品评指正。如果觉得写的还行，欢迎关注我的公众号MLGroup,带你走进机器学习的世界。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "4"}