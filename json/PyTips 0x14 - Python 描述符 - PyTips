{"title": "PyTips 0x14 - Python 描述符 - PyTips ", "index": "pytips,python3.5,python", "content": "项目地址：https://git.io/pytips\n本篇主要关于三个常用内置方法：property()，staticmethod()，classmethod()\n在 Python 语言的设计中，通常的语法操作最终都会转化为方法调用，例如：\na = 1\nb = 2\nprint(\"a + b = {}\".format(a+b))\n\n# 相当于\nprint(\"a.__add__(b) = {}\".format(a.__add__(b)))\na + b = 3\na.__add__(b) = 3\n\nPython 中的描述符（Descriptor）就是将对象属性的获取、赋值以及删除等行为转换为方法调用的协议：\ndescr.__get__(self, obj, type=None) --> value\n\ndescr.__set__(self, obj, value) --> None\n\ndescr.__delete__(self, obj) --> None\n例如我们要获取一个对象的属性，可以通过o.x的方式取得：\nclass Int:\n    ctype = \"Class::Int\"\n    def __init__(self, val):\n        self._val = val\n        \na = Int(1)\nprint(a.ctype)\nClass::Int\n\n而通过.的方式寻找属性的值实际上调用了object.__getattribute__(self, name)方法：\nclass Int:\n    ctype = \"Class::Int\"\n    def __init__(self, val):\n        self._val = val\n    def __getattribute__(self, name):\n        print(\"? doesn't want to give `{}' to you!\".format(name))\n        return \"?\"\na = Int(2)\nprint(a.ctype)\n? doesn't want to give `ctype' to you!\n?\n\n而这里的__getattribute__(self, name)方法实际上就是将.的属性获取方法转化为描述符协议定义的descr.__get__(self, key)：\nclass Str:\n    def __init__(self, val):\n        self._val = val\n    def __get__(self, name, ctype=None):\n        print(\"You can __get__ anything from here!\")\n        return self._val\nclass Int:\n    ctype = Str(\"Class::Int\")\n    def __init__(self, val):\n        self._val = val\n    def __getattribute__(self, name):\n        return type(self).__dict__[name].__get__(None, type(self))\na = Int(2)\nprint(a.ctype)\nYou can __get__ anything from here!\nClass::Int\n\n这里的 a.ctype = (Int.__dict__['ctype']).__get__(None, Int)，即通过描述符的方式获取了 ctype 属性的值。同样的道理，你也可以通过 descr.__set__(self, obj, val) 设置属性的值：\nclass Str:\n    def __init__(self, val):\n        self._val = val\n    def __get__(self, name, ctype=None):\n        print(\"You can __get__ anything from here!\")\n        return self._val\n    def __set__(self, name, val):\n        print(\"You can __set__ anything to me!\")\n        self._val = val\nclass Int:\n    ctype = Str(\"Class::Int\")\n    def __init__(self, val):\n        self._val = val\na = Int(3)\nprint(a.ctype)\na.ctype = \"Class::Float\"\nprint(a.ctype)\nYou can __get__ anything from here!\nClass::Int\nYou can __set__ anything to me!\nYou can __get__ anything from here!\nClass::Float\n\n将这些取值、赋值的操作转换为方法调用让我们有办法在做这些操作的过程中插入一些小动作，这么好用的东西自然是已加入豪华内置函数阵容，正是我们常见的\n\nproperty()\nclassmethod()\nstaticmethod()\n\nproperty\nproperty(fget=None, fset=None, fdel=None, doc=None) 方法简化了上面的操作：\nclass Int:\n    def __init__(self, val):\n        self._val = val\n        self._ctype = None\n        \n    def get_ctype(self):\n        print(\"INFO: You can get `ctype`\")\n        return self._ctype\n    def set_ctype(self, val):\n        print(\"INFO: You're setting `ctype` =\", val)\n        self._ctype=val\n    ctype = property(fget=get_ctype, fset=set_ctype, doc=\"Property `ctype`\")\n    \na = Int(4)\nprint(a.ctype)\na.ctype = \"Class::Int\"\nprint(a.ctype)\nINFO: You can get `ctype`\nNone\nINFO: You're setting `ctype` = Class::Int\nINFO: You can get `ctype`\nClass::Int\n\n显然，更方便一些的用法是将 property 当做修饰器：\nclass Int:\n    _ctype = None\n    def __init__(self, val):\n        self._val = val\n    @property\n    def ctype(self):\n        print(\"INFO: You can get `ctype` from me!\")\n        return self._ctype\n    @ctype.setter\n    def ctype(self, val):\n        print(\"INFO: You're setting `ctype` =\", val)\n        self._ctype = val\na = Int(5)\nprint(a.ctype)\na.ctype = \"Class::Int\"\nprint(a.ctype)\nINFO: You can get `ctype` from me!\nNone\nINFO: You're setting `ctype` = Class::Int\nINFO: You can get `ctype` from me!\nClass::Int\n\nstaticmethod & classmethod\n顾名思义，property 是关于属性的全部操作，如果是要获取类中的方法，则需要用到 staticmethod 和 classmethod。顾名思义，staticmethod 将方法变成静态方法，即类和实例都可以访问，如果不用 staticmethod 我们可以用下面这种别扭的方法实现：\nclass Int:\n    def __init__(self, val):\n        self._val = val\n    def _get_ctype(self=None):\n        print(\"INFO: You can get `ctype` from here!\")\n        return \"Class::Int\"\n    \n    @staticmethod\n    def get_ctype():\n        print(\"INFO: You can get `ctype` from here!\")\n        return \"Class::StaticInt\"       \n    \na = Int(6)\nprint(a._get_ctype())\nprint(Int._get_ctype())\n\nprint(a.get_ctype())\nprint(Int.get_ctype())\nINFO: You can get `ctype` from here!\nClass::Int\nINFO: You can get `ctype` from here!\nClass::Int\nINFO: You can get `ctype` from here!\nClass::StaticInt\nINFO: You can get `ctype` from here!\nClass::StaticInt\n\n可以看到，静态方法与类和实例无关，也就不再（不能）需要 self 关键词；与之相反，当我们需要在方法中保留类（而非实例）的引用时，则需要用 classmethod：\nclass Int:\n    _ctype = \"\"\n    def __init__(self, val):\n        self._val = val\n        \n    @classmethod\n    def set_ctype(klass, t):\n        klass._ctype = t\n        return \"{}.ctype = {}\".format(klass.__name__, t)\na = Int(7)\nprint(a.set_ctype(\"Class::Int\"))\nprint(Int.set_ctype(\"Class::Float\"))\nb = Int(8)\nprint(b._ctype)\nInt.ctype = Class::Int\nInt.ctype = Class::Float\nClass::Float\n\n总结\nPython 的描述符给出一种通过方法调用来实现属性（方法）获取、赋值等操作的规则，通过这一规则可以方便我们深入程序内部并实施操控，因此 property/staticmethod/classmethod 在 Python 是通过底层（如 CPython 中的 C）实现的，如果想要进一步深入了解其实现原理，可以访问参考链接的教程，其中包括了这三个内置方法的 Python 实现版本，我也把它们 copy 过来方便查看。\n\n欢迎关注公众号 PyHub 每日推送\n\n参考\nDescriptor HowTo Guide\nclass Property(object):\n    \"Emulate PyProperty_Type() in Objects/descrobject.c\"\n\n    def __init__(self, fget=None, fset=None, fdel=None, doc=None):\n        self.fget = fget\n        self.fset = fset\n        self.fdel = fdel\n        if doc is None and fget is not None:\n            doc = fget.__doc__\n        self.__doc__ = doc\n\n    def __get__(self, obj, objtype=None):\n        if obj is None:\n            return self\n        if self.fget is None:\n            raise AttributeError(\"unreadable attribute\")\n        return self.fget(obj)\n\n    def __set__(self, obj, value):\n        if self.fset is None:\n            raise AttributeError(\"can't set attribute\")\n        self.fset(obj, value)\n\n    def __delete__(self, obj):\n        if self.fdel is None:\n            raise AttributeError(\"can't delete attribute\")\n        self.fdel(obj)\n\n    def getter(self, fget):\n        return type(self)(fget, self.fset, self.fdel, self.__doc__)\n\n    def setter(self, fset):\n        return type(self)(self.fget, fset, self.fdel, self.__doc__)\n\n    def deleter(self, fdel):\n        return type(self)(self.fget, self.fset, fdel, self.__doc__)\n\nclass StaticMethod(object):\n    \"Emulate PyStaticMethod_Type() in Objects/funcobject.c\"\n\n    def __init__(self, f):\n        self.f = f\n        \n    def __get__(self, obj, objtype=None):\n        return self.f\n\nclass ClassMethod(object):\n    \"Emulate PyClassMethod_Type() in Objects/funcobject.c\"\n    \n    def __init__(self, f):\n        self.f = f\n\n    def __get__(self, obj, klass=None):\n        if klass is None:\n            klass = type(obj)\n        def newfunc(*args):\n            return self.f(klass, *args)\n        return newfunc\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "3"}