{"title": "python 数据类型 - tuple - python学习+自动化测试实践 ", "index": "python", "content": "tuple 元组\n今天跟大家分享一下Python里面tuple数据类型的学习ps：list数据类型，之前是写在了jianshu上，暂时我也还没有搬过来，所以贴上链接吧 \nPython数据类型 - list : https://www.jianshu.com/p/5fe...\n\n概念\ntuple，即元组。是Python内置的一种有序列表。跟list相比，tuple有比较特别的地方。\n\ntuple不可变，一旦初始化定义后就不能修改。所以在定义的时候，元素值最好就确定下来。\ntuple获取元素的方法与list一致。但是它没有append()、insert()等方法。\n\n那tuple有什么好处呢？因为不可变，所以代码更加安全。如果可以，尽量用tuple代替list。\n\n一、tuple定义\n1、 定义一个空tuple\n    t = ()\n    t  # 调用\n    输出:()\n2、 定义一个只有一个元素的tuple\n如下示例，注意比较“t”与“s”的区别，通过type()函数也可以清楚的看到。\n>>> t = ('xyz')\n>>> t\n'xyz'\n>>> type(t)\n<class 'str'>\n>>>\n>>> s = ('abc',)\n>>> s\n('abc',)\n>>> type(s)\n<class 'tuple'>\n>>>\nps：本来贴的图片，发现不方便看 -_-\n注意哦，必须要添加一个逗号“,”，来消除歧义。\n3、定义一个多个元素的tuple\n    t = (1,2,'abc')\n    t # 调用\n    输出:(1,2,'abc')\n\n二、“可变的”tuple\n刚才说tuple不可变，现在为何说“可变”呢？试想tuple里的元素是list类型时。\n>>> t = ('a','b',['c','d'])       # tuple里包含可变的list\n>>> t [2][0]\n'c'\n>>> t[0][1]\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nIndexError: string index out of range\n>>> t [2][0] = 'C'                # 修改tuple中的list类型值\n>>> t\n('a', 'b', ['C', 'd'])\n>>> t[0][0] = 'e'\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: 'str' object does not support item assignment\n块一中修改tuple中list的元素，tuple没有变，变的是list的元素。tuple一开始指向的list并没有改变成别的list，id(list)没有变化。所以，tuple所谓的“不变”，是说tuple的每个元素指向永远不变，但是指向的list内容是可变的。\n另一种方法改变tuple\n>>> h = ('a','b','c')\n>>> h1 = ('A',) + h[1:]  # 用slice方法取得列表的一部分，其实是重新给对象赋值\n>>> h1\n('A', 'b', 'c')\n\n三、序列赋值\n（1）Python中，tuple类型为默认的集合类型\nPython中，赋值可以采用序列赋值的方式，如下\n>>>a,b = 1,2\n>>>a,b\n>>>(1,2)\n\n（2）tuple序列作为函数默认的返回值类型，所有不包括符号封装的函数返回值都是元组类型\npython函数返回值是一个tuple类型的值。返回值为一个时，括号省略；返回值为多个时，为同一个tuple接收，并把位置赋给相应的值。若要返回一个list类型，则显示用“[]”进行修改。\ndef swap(x,y):\n    return y,x        # return [y,x] 或者 return(y,x)\n>>> swap(2,3)\n(3, 2)\n\n四、tuple的函数操作\n（1） 两个元组的合并操作\n\n两个tuple连接操作：tuple_a + tuple_b\ntuple乘操作：tuple_a * int_number\n\n实际效果如下图：\n（2） in操作符\n判断元素i是否在tuple_a中，返回True or False。\nif i in tuple_a :\n    <action>\n（3） 访问元组元素\n通过切片来访问元组的元素，它的切片操作跟列表list是一样，也是通过“切片操作符[]”+索引index来访问。\n（4） 一些内建函数\n\nlen()：\nmax()：\nmin()：\nstr()：类型转换为string\nlist()：类型转换为list\noperator模块：可以调用里面的比较操作函数、逻辑操作函数、数学操作函数等，感兴趣的可以去看看operator.py文件源码，或者官网教程哦~\n\n（5） 比较操作符\n元组还可以进行一些比较操作符的操作，比如“>”、“<”、“==”等，跟数学里一样，对应元素值跟对应元素值进行比较，返回True或者False。“大于”和“小于”只能比较同类型的tuple，如下示例：\n>>> a = (1,2)\n>>> b = ('a','b')\n>>> c = (1,2,3)\n>>> a > b\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: '>' not supported between instances of 'int' and 'str'\n>>>\n>>> a == c\nFalse\n大家可以随意去操作一下，就能清楚了，不算是重点。\n\n有小伙伴能告诉我，专栏里的文章如何改变排序吗？ \n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "0"}