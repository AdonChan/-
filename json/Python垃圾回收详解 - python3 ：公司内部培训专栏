{"title": "Python垃圾回收详解 - python3 ：公司内部培训专栏 ", "index": "python", "content": "上一篇文章：私有化规则与属性Property下一篇文章：Python进程专题总览篇\n\n高级语言一般都有垃圾回收机制，其中c、c++使用的是用户自己管维护内存的方式，这种方式比较自由，但如果回收不当也会引起垃内存泄露等问题。而python采用的是引用计数机制为主，标记-清理和分代收集两种机制为辅的策略。\n1、引用计数\npython中一切皆对象，所以python底层计数结构地就可以抽象为：\n引用计数结构体{\n引用计数;\n引用的对象\n}\n是不是简单明了。现在我们先去考虑一下，什么情况下引用计数+1，什么情况下-1，当引用次数为0时，肯定就是需要进行回收的时刻。\n引用计数+1的情况\n1、对象被创建时，例如 mark=\"帅哥\"\n2、对象被copy引用时，例如 mark2=mark，此时mark引用计数+1\n3、对象被作为参数，传入到一个函数中时\n4、对象作为一个子元素，存储到容器中时，例如 list=[mark,mark2]\n引用计数-1的情况\n1、对象别名被显示销毁，例如 del mark\n2、对象引用被赋予新的对象，例如mark2=mark3，此时mark引用计数-1（对照引用计数+1的情况下的第二点来看）\n3、一个函数离开他的作用域，例如函数执行完成，它的引用参数的引用计数-1\n4、对象所在容器被销毁，或者从容器中删除。\n产看引用计数\n实例：\nimport sys\na = \"mark 帅哥\"\nprint(sys.getrefcount(a))\n结果：\n4\n备注：如果实际结果与上面不符，跟使用的编辑器有很大关系，重点是理解计数引用原理，不要太在意为啥不是1.\n想理解原因可以转看：https://stackoverflow.com/questions/45021901/why-does-a-newly-created-variable-in-python-have-a-ref-count-of-four\n引用计数机制优点\n1、简单、直观\n2、实时性，只要没有了引用就释放资源。\n引用计数机制缺点\n1、维护引用计数需要消耗一定的资源\n2、循环应用时，无法回收。也正是因为这个原因，才需要通过标记-清理和分代收集机制来辅助引用计数机制。\n2、标记-清理\n由上面内容我们可以知道，引用计数机制有两个缺点，缺点1还可以勉强让人接受，缺点2如果不解决，肯定会引起内存泄露，为了解决这个问题，引入了标记删除。\n我们先来看个实例，从实例中领会标记删除：\na=[1,2]#假设此时a的引用为1\nb=[3,4]#假设此时b的引用为1\n#循环引用\na.append(b)#b的引用+1=2\nb.append(a)//a的引用+1=2\n\n假如现在需要删除a,应该如何回收呢？\n\n\nc=[5,6]#假设此时c的引用为1\nd=[7,8]#假设此时d的引用为1\n#循环引用\nc.append(d)#c的引用+1=2\nd.append(c)#d的引用+1=2\n\n假如现在需要同时删除c、d，应该如何回收呢？\n首先我们应该已经知道，不管上面两种情况的哪一个都无法只通过计数来完成回收，因为随便删除一个变量，它的引用只会-1，变成1，还是大于0，不会回收，为了解决这个问题，开始看标记删除来大展神威吧。\nputhon标记删除时通过l两个容器来完成的：死亡容器、存活容器。\n\n首先，我们先来分析情况2，删除c、d\n删除后，c的引用为1，d的引用为1，根据引用计数，还无法删除\n\n标记删除第一步：对执行删除操作后的每个引用-1，此时c的引用为0，d的引用为0，把他们都放到死亡容器内。把那些引用仍然大于0的放到存活容器内。\n\n标记删除第二步：遍历存活容器，查看是否有的存活容器引用了死亡容器内的对象，如果有就把该对象从死亡容器内取出，放到存活容器内。\n由于c、d都没有对象引用他们了，所以经过这一步骤，他们还是在死亡组。\n\n标记删除第三部：将死亡组所有对象删除。\n这样就完成了对从c、d的删除。\n同样道理，我们来分析：只删除a的过程：\n标记删除第一步：对执行删除（-1）后的每个引用-1，那么a的引用就是0，b的引用为1，将a放到死亡容器，将b放到存活容器。\n标记删除第二步：循环存活容器，发现b引用a，复活a：将a放到存活容器内。\n标记删除第三步：删除死亡容器内的所有对象。\n综上所说，发现对于循环引用，必须将循环引用的双发对象都删除，才可以被回收。\n标记-清理就是这么简单，😀。\n3、分代收集\n经过上面的【标记-清理】方法，已经可以保证对垃圾的回收了，但还有一个问题，【标记-清理】什么时候执行比较好呢，是对所有对象都同时执行吗？\n同时执行很显然不合理，我们知道，存活越久的对象，说明他的引用更持久（好像是个屁话，引用不持久就被删除了），为了更合理的进行【标记-删除】，就需要对对象进行分代处理，思路很简单：\n1、新创建的对象做为0代\n2、没执行一个【标记-删除】，存活的对象代数就+1\n3、代数越高的对象（存活越持久的对象），进行【标记-删除】的时间间隔就越长。这个间隔，江湖人称阀值。\n是不是很简单呢。\n4、三种情况触发垃圾回收\n1、调用gc.collect()\n2、GC达到阀值时\n3、程序退出时\n5、小整数对象池与intern机制\n由于整数使用广泛，为了避免为整数频繁销毁、申请内存空间，引入了小整数对象池。[-5,257)是提前定义好的，不会销毁，单个字母也是。\n那对于其他整数，或者其他字符串的不可变类型，如果存在重复的多个，例如：\na1=\"mark\"\na2=\"mark\"\na3=\"mark\"\na4=\"mark\"\n....\na1000=\"mark\"\n如果每次声明都开辟出一段空间，很显然不合理，这个时候python就会使用intern机制，靠引用计数来维护。\n总计：\n1、小整数[-5，257)：共用对象，常驻内存\n2、单个字符：共用对象，常驻内存\n3、单个单词等不可变类型，默认开启intern机制，共用对象，引用计数为0时销毁。\n备注：利用gc模块python也可以实现GC控制，，有兴趣可以研究一下。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}