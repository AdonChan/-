{"title": "Python 技巧总结 - 流水账 ", "index": "python", "content": "内置函数\nenumerate\nenumerate(list[,start=0])：遍历list，并索引\nmy_list = ['apple', 'banana', 'grapes', 'pear']\nfor i, value in enumerate(my_list, 1):\n    print(i, value)\n输出：\n(1, 'apple')\n(2, 'banana')\n(3, 'grapes')\n(4, 'pear')\ndivmod(x,y)\n如果 x 为 int，返回x÷y的商和余数组成的元组，(x//y, x%y)。如果 x 为 float，则返回 (math.floor(x / y), x%y)。\n可以以此很方便的形成二维数组：\n>>>[divmod(i, 3) for i in range(9)]\n[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]\n短路求值\n三元运算\n利用 python 逻辑运算的短路求值特性，我们可以实现python不支持的三元运算符 bool ? a : b ：\nbool and a or b     # 其中要求 a, b 为真\n当然有更pythonic 的实现方法：\na if bool else b\nand 与 or 优先级\nTrue or True and False    #=> True\n造成结果为True的原因是因为短路求值，不是因为存在臆想中的优先级问题--True or (True and False)，or 和 and` 一起使用，遵循自左向右计算原则。\n参见：短路求值\n装饰器\n示例1：\ntable = [i * i for i in range(5)]\n或：\ndef call(*argv, **kwargs):\n    def call_fn(fn):\n        return fn(*argv, **kwargs)\n    return call_fn\n@call(5)\ndef table(n):\n    value = []\n    for i in range(n):\n        value.append(i*i)\n    return value\n或：\n@list\n@call(5)\ndef table(n):\n    for i in range(n):\n        yield i * i\n结果：\nlen(table), table[3]    #=> (5, 9)\n数组(List)\n转置矩阵\nm = [[1,2],[3,4]]\nzip(*m)\n碾平list\na = [1, 2, [3, 4], [[5, 6], [7, 8]]]\nflatten = lambda x: [y for l in x for y in flatten(l)] \\\n    if type(x) is list else [x]\nflatten(a)\n# [1,2,3,4,5,6,7,8]\nlist分组\na=[3, 8, 9, 4, 1, 10, 6, 7, 2, 5]\nprint([a[i:i+3] for i in range(0,len(a),3)])\n# [[3, 8, 9], [4, 1, 10], [6, 7, 2], [5]]\n字典(Dict)\nkey，value互换\nm = {'a': 1, 'b': 2, 'c': 3, 'd': 4}\n{v: k for k, v in m.items()}\n# {1: 'a', 2: 'b', 3: 'c', 4: 'd'}\nDict.get()\ndict.get(key[, default=None]): 如果key存在，返回dict[key]，否则返回default，default默认值为None。相比较，dict['key'] 只能获取 dict 中存在的key的值，如果不存在则触发 KeyError。利用此方法，在对字典进行某些运算时会更优雅：\nif key not in dct:\n    dct[key] = 0\ndct[key] = dct[key] + 1\ndct[key] = dct.get(key, 0) + 1\nd = {\n    'a': 1,\n    'b': 2,\n}\nd.get('c', 3)   #=> 3\nDict.setdefault()\nDict.setdefault(key, default)：如果存在，返回 dct[key]，不存在则把 dct[key] 设为 default 并返回它。当一个默认的值是一个你可以修改的对象的时候这是很有用的。\ndct = {}\nfor key, value in data:\n    if key in dct:\n        dct[key].append(value)\n    else:\n        dct[key] = [value]\ndct = {}\nfor (key, value) in data:\n    group = dct.setdefault(key, []) # key might exist already\n    group.append(value)\n参见：Python:字典的剧本\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}