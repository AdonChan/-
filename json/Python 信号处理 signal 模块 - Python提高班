{"title": "Python 信号处理 signal 模块 - Python提高班 ", "index": "python", "content": "signal模块简介\n\n最近在看Linux signal 相关内容，signal可以被用来进程间通信和异步处理。Python标准库提供了signal包可以用来处理信号相关。这里讨论的是Unix系统中Python的signal模块。\nsignal简单示例\n\n官方文档上有这样的示例:\nimport signal, os\n\n# 定义一个信号处理函数，该函数打印收到的信号，然后raise IOError\ndef handler(signum, frame):\n    print 'Signal handler called with signal', signum\n    raise IOError(\"Couldn't open device!\")\n\n# 对SIGALRM(终止)设置处理的handler, 然后设置定时器，5秒后触发SIGALRM信号\nsignal.signal(signal.SIGALRM, handler)\nsignal.alarm(5)\n\n# This open() may hang indefinitely\nfd = os.open('/dev/ttyS0', os.O_RDWR)\n\nsignal.alarm(0)          # 关闭定时器\n\n该示例实现的功能是，为了防止打开一个文件出错或者其他异常一直处于等待的状态，设定一个定时器，5秒后触发IOError。如果5s内正常打开文件，则清除定时器。\nsignal说明\n\n基本的信号名\n\nimport signal\n\nsignal.SIGABORT\nsignal.SIGHUP  # 连接挂断\nsignal.SIGILL  # 非法指令\nsignal.SIGINT  # 连接中断\nsignal.SIGKILL # 终止进程（此信号不能被捕获或忽略）\nsignal.SIGQUIT # 终端退出\nsignal.SIGTERM # 终止\nsignal.SIGALRM  # 超时警告\nsignal.SIGCONT  # 继续执行暂停进程\n\n等等...\n\n常用信号处理函数\n\n\n\nsignal.signal(signalnum, handler)\n设置信号处理的函数\n\n\nsignal.alarm(time)\n设置发送SIGALRM信号的定时器\n\n\nos.kill\n这个不属于signal模块，但其可以使用给某一进程发送信号\n\n\n\nsignal使用示例\n\n示例1\n\n# From project httpscreenshot-master, under directory , in source file httpscreenshot.py.\ndef timeoutFn(func, args=(), kwargs={}, timeout_duration=1, default=None):\n    import signal\n\n    class TimeoutError(Exception):\n        pass\n\n    def handler(signum, frame):\n        raise TimeoutError()\n\n    # set the timeout handler\n    signal.signal(signal.SIGALRM, handler)\n    signal.alarm(timeout_duration)\n    try:\n        result = func(*args, **kwargs)\n    except TimeoutError as exc:\n        result = default\n    finally:\n        signal.alarm(0)\n        signal.signal(signal.SIGALRM, signal.SIG_DFL)\n\n    return result\n\n上面这个示例实现了设置函数执行超时返回默认结果的功能。先是设置了一个超时处理函数，在函数中抛出自定义的抛出异常。在执行函数前设置了 signal.alarm ，当超出时间后触发抛出异常 SIGALRM, 然后捕获这个异常设置默认值，最后做下清理工作将定时器取消，并且将对 SIGALRM 的处理设为默认。\n示例2\n\n这个示例来源于这里。 需求是动态加载python导入的模块，也就是说，当导入的模块代码更新时，希望可以立即更新引用的代码。示例如下：\n# lib.py\ndef scrape_me_bro():\n        print \"Scraping is fun\"\n\n\n\n#scrape.py\nimport time\nimport signal\nimport lib\n\ndef scrape():\n        # Assume we are hitting Streaming API\n        # and doing something buzzwordy with it\n        while True:\n                lib.scrape_me_bro()\n                time.sleep(2)\n\ndef reload_libs(signum, frame):\n        print \"Received Signal: %s at frame: %s\" % (signum, frame)\n        print \"Excuting a Lib Reload\"\n        reload(lib)\n\n# Register reload_libs to be called on restart\nsignal.signal(signal.SIGHUP, reload_libs)\n\n# Main\nscrape()\n\n当运行scrape.py时，程序会每个两秒调用一次lib.py中的 scrape_me_bro() 方法，这时候如果lib.py里的方法变化了，向运行scrape.py的进程发送 SIGHUP 信号，那么它会重新加载lib.py,这样会接着循环执行修改后的 scrape_me_bro() 方法。\n参考资料\n\n\n《Beginning Linux Programming》\nhttps://docs.python.org/2/lib...\nhttp://engineerwithoutacause....\nhttp://www.cnblogs.com/vamei/...\nhttp://www.programcreek.com/p...\n\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "5"}