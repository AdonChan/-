{"title": "8-django——发送邮件和缓存 - Python全栈玩起来 ", "index": "python,django", "content": "发送邮件\n概述：Django中内置了邮件发送功能，发送邮件需要使用SMTP服务，常用的免费服务器有：163、126、QQ\n\n注册并登陆163邮箱\n打开POP3/SMTP服务与IMAP/SMTP服务\n重置授权密码\n\n配置\n#邮件发送\nEMAIL_BACKEND='django.core.mail.backends.smtp.EmailBackend'\nEMAIL_HOST='smtp.163.com'\nEMAIL_PORT=25\n#发送邮件的邮箱\nEMAIL_HOST_USER='clement@163.com'\n#邮箱的授权密码\nEMAIL_HOST_PASSWORD='a12345678'\n#收件人看到的发件人\nEMAIL_FROM='DAI<clement@163.com>'\n发送\nsend_mail(subject, message, from_email, recipient_list)\nfrom django.conf import settings\nfrom django.core.mail import send_mail\ndef sendMail(request):\n    msg = '<a href=\"http://127.0.0.1:8000/index/\">点击激活</a>'\n    send_mail(\"注册激活\",\"\",settings.EMAIL_FROM,[\"clement@163.com\"],html_message=msg)\n    return HttpResponse(\"邮件已发送\")\n缓存\n概述：对于中等流量的网站来说，尽可能的减少开销是非常必要的。缓存数据就是为了保存那些需要很多计算资源的结果，这样的话就不必在下次重复消耗计算资源。获取数据的数据的时候就是去缓存中拿，拿到了直接返回，没拿到就去数据库中查询，筛选，然后缓存到数据库， 然后返回给模板。\nDjango自带了一个健壮的缓存系统来保存动态页面，避免每次请求都重新计算。\nDjango提供了不同级别的缓存策略，可以缓存特定的视图的输出、可以仅仅缓存那些很难计算出来的部分、或者缓存整个网站\n目的：优化数据结构；优化了对数据的查询；筛选，过滤；减少了对磁盘的IO\n官方文档：https://docs.djangoproject.co...\n设置缓存\n通过设置决定把数据缓存在哪里，是数据库中、文件系统中还是内存中\n默认缓存（内存）\nCACHES={\n    'default':{\n        'BACKEND':'django.core.cache.backends.locmem.LocMemCache',\n        'LOCATION': 'unique-snowflake',\n        'TIMEOUT':60\n    }\n}\n参数TIMEOUT:缓存的默认过期时间，以秒为单位\n\n默认为300秒\n设置为None,表示永不过期\n设置为0造成缓存立即失效\n\n文件缓存\nCACHES = {\n    'default': {\n        'BACKEND': 'django.core.cache.backends.filebased.FileBasedCache',\n        'LOCATION': 'c:/foo/bar',\n        'TIMEOUT':300,\n    }\n}\n数据库缓存\nCACHES = {\n    'default': {\n        'BACKEND': 'django.core.cache.backends.db.DatabaseCache',\n        'LOCATION': 'my_cache_table',\n        'TIMEOUT': '60',\n        'KEY_PREFIX': 'bbs',\n        'VERSION': '1',\n        'OPTIONS': {\n            'MAX_ENTRIES': '300'\n        }\n    }\n}\n创建缓存表:  python manage.py createcachetable\nredis缓存\n官网： http://django-redis-chs.readt...\nredis操作文档：http://redisdoc.com\n默认使用redis中的1数据库，但可以指定使用哪个db\n安装pip  install  django-redis\n配置\n# ---配置Session和Cache---\nCACHES={\n    'default':{\n        'BACKEND': 'django_redis.cache.RedisCache',\n        'LOCATION':'127.0.0.1:6379/12', # 指定db12\n        'TIMEOUT':60,\n        'OPTIONS': {\n            'CLIENT_CLASS': 'django_redis.client.DefaultClient',  # 指定连接Redis的客户端类\n            # 'PASSWORD': 'mysecret',\n             # \"SOCKET_CONNECT_TIMEOUT\": 5,  # in seconds\n             # \"SOCKET_TIMEOUT\": 5,  # in seconds\n             # \"CONNECTION_POOL_KWARGS\": {\"max_connections\": 100},\n             # \"CONNECTION_POOL_CLASS\": \"myproj.mypool.MyOwnPool\",\n        }\n    }\n}\nSESSION_ENGINE = 'django.contrib.sessions.backends.cache'\n\n# --结束Session和Cache配置\n\n\n参数\n解释\n\n\n\nSOCKET_CONNECT_TIMEOUT\nsocket 建立连接超时设置\n\n\nSOCKET_TIMEOUT\n连接建立后的读写操作超时设置\n\n\nCONNECTION_POOL_KWARGS\n设置连接池的最大连接数量\n\n\nCONNECTION_POOL_CLASS\n自己的连接池子类\n\n\n\n连接池\ndjango-redis 使用 redis-py 的连接池接口, 并提供了简单的配置方式. 除此之外, 你可以为 backend 定制化连接池的产生。redis-py 默认不会关闭连接, 尽可能重用连接。\n连接池概念\n\n为什么使用连接池？首先Redis也是一种数据库，它基于C/S模式，因此如果需要使用必须建立连接，稍微熟悉网络的人应该都清楚地知道为什么需要建立连接，C/S模式本身就是一种远程通信的交互模式，因此Redis服务器可以单独作为一个数据库服务器来独立存在。假设Redis服务器与客户端分处在异地，虽然基于内存的Redis数据库有着超高的性能，但是底层的网络通信却占用了一次数据请求的大量时间，因为每次数据交互都需要先建立连接，假设一次数据交互总共用时30ms，超高性能的Redis数据库处理数据所花的时间可能不到1ms，也即是说前期的连接占用了29ms，连接池则可以实现在客户端建立多个链接并且不释放，当需要使用连接的时候通过一定的算法获取已经建立的连接，使用完了以后则还给连接池，这就免去了数据库连接所占用的时间。\n\n配置默认连接池\n配置默认连接池很简单, 你只需要在 CACHES 中使用 CONNECTION_POOL_KWARGS 设置连接池的最大连接数量即可\n你可以得知连接池已经打开多少连接:\nfrom django.core.cache import get_cache\nfrom django_redis import get_redis_connection\n\nr = get_redis_connection(\"default\")  # Use the name you have defined for Redis in settings.CACHES\nconnection_pool = r.connection_pool\nprint(\"Created connections so far: %d\" % connection_pool._created_connections)\n使用自己的连接池子类\n有时你想使用自己的连接池子类. django-redis 提供了 CONNECTION_POOL_CLASS 来配置连接池子类 \nmyproj/mypool.py\nfrom redis.connection import ConnectionPool\n\nclass MyOwnPool(ConnectionPool):\n    # Just doing nothing, only for example purpose\n    pass\n缓存的用法\n单个view缓存\ndjango.views.decorators.cache.cache_page装饰器用于对视图的输出进行缓存\nfrom django.views.decorators.cache import cache_page\n\n@cache_page(60 * 2)\ndef index(request):\n    # return HttpResponse(\"sunck is a good man\")\n    return HttpResponse(\"sunck is a nice man\")\n参数：\ntimeout : 有效时长  # we've written it as 60 * 15 for the purpose of readability\ncache: 缓存到哪一个库中;很少使用;针对于系统配置了多个缓存\n       如： @cache_page(timeout=60, cache='filecache')\nkey_prefix： 前缀      \n模板片段缓存\ncache标签: 参数\n\n缓存时间，以秒为单位\n给缓存片段起名字\n\n{#{% load static from staticfiles %}#}\n{% load static %}\n{% load cache %}\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>主页</title>\n\n{#    <link rel=\"stylesheet\" type=\"text/css\" href=\"/static/css/index.css\">#}\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"{% static 'css/index.css' %}\">\n</head>\n<body>\n    <h1>sunck is a nice man</h1>\n    {% cache 120 sunck %}\n        <h1>nice man</h1>\n        <!--<h1>good man</h1>-->\n    {% endcache %}\n</body>\n</html>\n原生cache\nfrom django.core.cache import cache\n查看所有缓存的key： cache.keys('*')\n设置：cache.set(键, 值, 有效时间)\n获取：cache.get(键)\n删除：cache.delete(键)\n清空：cache.clear()\n>>> cache.set_many({'a': 1, 'b': 2, 'c': 3})\n>>> cache.getmany(['a','b','c'])\n{'a': 1, 'b': 2, 'c': 3}\ncache.delete_pattern(\"foo_*\") # 全局通配符\n\n                ", "mainLikeNum": ["10 "], "mainBookmarkNum": "5"}