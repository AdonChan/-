{"title": "leetcode-139-Word Break - 个人文章 ", "index": "python", "content": "题目简介：\n1.完全按照dict中的word进行切分匹配，一个char都不差\n2.由于是连续匹配，所以是首尾相接，所以涉及到动态规划思想,需要保留上一个动态\n3.广度递归非常耗时，不知道什么原因。\n4.边界点注意区分清楚，连贯起来。\n应用：思想应用，涉及到前后需要保持状态的匹配计算，要保留并利用中间状态。相似问题： 动态规划，利用前面的状态。\nclass Solution:\n\n    def wordBreak(self, s, wordDict):\n        ok_list=[True]\n        for i in range(1,len(s)+1):\n            # ok_list.append(any(ok_list[j-1] and s[j:i] in wordDict for j in range(i)))\n            iter_bools=list()\n            for j in range(i):\n                s_cur=s[j:i]\n                bool_elem=s_cur in wordDict\n                iter_bools.append(ok_list[j] and bool_elem)\n            ok_list.append(any(iter_bools))\n        return ok_list[-1]\n\nif __name__=='__main__':\n    s = \"applepenapple\"\n    s = \"catsandog\"\n    s='leetcode'\n    wordDict = [\"apple\", \"pen\"]\n    wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]\n    wordDict=[\"leet\",\"code\"]\n    st=Solution()\n    out=st.wordBreak(s,wordDict)\n    print([out])\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}