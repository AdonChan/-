{"title": "Python Switch Case 最佳实践 - 个人文章 ", "index": "python", "content": "优美胜于丑陋import this\n\n博客地址：Specific-Dispatch\n\n前言\n表驱动法是一种编辑模式（Scheme）——从表里面查找信息而不使用逻辑语句（if 和 case）。事实上，凡是能通过逻辑语句来选择的事物，都可以通过查表来选择。\n对简单的情况而言，使用逻辑语句更为容易和直白。但随着逻辑链的越来越复杂，查表法也就愈发显得更具吸引力。\nPython的switch case\n\n由于Python中没有switch case关键词，所以对于每一种情况的逻辑语句只能用if,elif,else来实现，显得很不Pythonic.\ndef handle_case(case):\n    if case == 1:\n        print('case 1')\n    elif case == 2:\n        print('case 2')\n    else:\n        print('default case')\n而受到PEP-443: Single-dispatch generic functions的启发，很容易就能实现如下装饰器：\nfrom functools import update_wrapper\nfrom types import MappingProxyType\nfrom typing import Hashable, Callable, Union\n\n\ndef specificdispatch(key: Union[int, str] = 0) -> Callable:\n    \"\"\"specific-dispatch generic function decorator.\n\n    Transforms a function into a generic function, which can have different\n    behaviours depending upon the value of its key of arguments or key of keyword arguments.\n    The decorated function acts as the default implementation, and additional\n    implementations can be registered using the register() attribute of the\n    generic function.\n    \"\"\"\n\n    def decorate(func: Callable) -> Callable:\n        registry = {}\n\n        def dispatch(key: Hashable) -> Callable:\n            \"\"\"\n            Runs the dispatch algorithm to return the best available implementation\n            for the given *key* registered on *generic_func*.\n            \"\"\"\n            try:\n                impl = registry[key]\n            except KeyError:\n                impl = registry[object]\n            return impl\n\n        def register(key: Hashable, func: Callable=None) -> Callable:\n            \"\"\"\n            Registers a new implementation for the given *key* on a *generic_func*.\n            \"\"\"\n            if func is None:\n                return lambda f: register(key, f)\n\n            registry[key] = func\n            return func\n\n        def wrapper_index(*args, **kw):\n            return dispatch(args[key])(*args, **kw)\n\n        def wrapper_keyword(*args, **kw):\n            return dispatch(kw[key])(*args, **kw)\n\n        registry[object] = func\n        if isinstance(key, int):\n            wrapper = wrapper_index\n        elif isinstance(key, str):\n            wrapper = wrapper_keyword\n        else:\n            raise KeyError('The key must be int or str')\n        wrapper.register = register\n        wrapper.dispatch = dispatch\n        wrapper.registry = MappingProxyType(registry)\n        update_wrapper(wrapper, func)\n\n        return wrapper\n\n    return decorate\n而之前的代码就能很优美的重构成这样：\n@specificdispatch(key=0)\ndef handle_case(case):\n    print('default case')\n\n@handle_case.register(1)\ndef _(case):\n    print('case 1')\n\n@handle_case.register(2)\ndef _(case):\n    print('case 2')\n\nhandle_case(1) # case 1\nhandle_case(0) # default case\n而对于这样的架构，即易于扩展也利于维护。\n更多实例\nclass Test:\n    @specificdispatch(key=1)\n    def test_dispatch(self, message, *args, **kw):\n        print(f'default: {message} args:{args} kw:{kw}')\n\n    @test_dispatch.register('test')\n    def _(self, message, *args, **kw):\n        print(f'test: {message} args:{args} kw:{kw}')\n\ntest = Test()\n# default: default args:(1,) kw:{'test': True}\ntest.test_dispatch('default', 1, test=True)\n# test: test args:(1,) kw:{'test': True}\ntest.test_dispatch('test', 1, test=True)\n\n@specificdispatch(key='case')\ndef handle_case(case):\n    print('default case')\n\n@handle_case.register(1)\ndef _(case):\n    print('case 1')\n\n@handle_case.register(2)\ndef _(case):\n    print('case 2')\n\nhandle_case(case=1)  # case 1\nhandle_case(case=0)  # default case\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}