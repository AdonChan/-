{"title": "用Python实现读写锁 - 编程进阶之路 ", "index": "python", "content": "起步\nPython 提供的多线程模型中并没有提供读写锁，读写锁相对于单纯的互斥锁，适用性更高，可以多个线程同时占用读模式的读写锁，但是只能一个线程占用写模式的读写锁。\n通俗点说就是当没有写锁时，就可以加读锁且任意线程可以同时加；而写锁只能有一个线程，且必须在没有读锁时才能加上。\n简单的实现\nimport threading\n\nclass RWlock(object):\n    def __init__(self):\n        self._lock = threading.Lock()\n        self._extra = threading.Lock()\n        self.read_num = 0\n\n    def read_acquire(self):\n        with self._extra:\n            self.read_num += 1\n            if self.read_num == 1:\n                self._lock.acquire()\n\n    def read_release(self):\n        with self._extra:\n            self.read_num -= 1\n            if self.read_num == 0:\n                self._lock.release()\n\n    def write_acquire(self):\n        self._lock.acquire()\n\n    def write_release(self):\n        self._lock.release()\n这是读写锁的一个简单的实现，self.read_num 用来保存获得读锁的线程数，这个属性属于临界区，对其操作也要加锁，所以这里需要一个保护内部数据的额外的锁 self._extra 。\n但是这个锁是不公平的。理想情况下，线程获得所的机会应该是一样的，不管线程是读操作还是写操作。而从上述代码可以看到，读请求都会立即设置 self.read_num += 1，不管有没有获得锁，而写请求想要获得锁还得等待 read_num 为 0 。\n所以这个就造成了只有锁没有被占用或者没有读请求时，可以获得写权限。我们应该想办法避免读模式锁长期占用。\n读写锁的优先级\n读写锁也有分 读优先 和 写优先。上面的代码就属于读优先。\n如果要改成写优先，那就换成去记录写线程的引用计数，读和写在同时竞争时，可以让写线程增加写的计数，这样可使读线程的读锁一直获取不到, 因为读线程要先判断写的引用计数，若不为0，则等待其为 0，然后进行读。这部分代码不罗列了。\n但这样显然不够灵活。我们不需要两个相似的读写锁类。我们希望重构我们代码，使它更强大。\n改进\n为了能够满足自定义优先级的读写锁，要记录等待的读写线程数，并且需要两个条件 threading.Condition 用来处理哪方优先的通知。计数引用可以扩大语义：正数：表示正在读操作的线程数，负数：表示正在写操作的线程数（最多-1）\n在获取读操作时，先然后判断时候有等待的写线程，没有，进行读操作，有，则等待读的计数加 1 后等待 Condition 通知；等待读的计数减 1，计数引用加 1，继续读操作，若条件不成立，循环等待；\n在获取写操作时，若锁没有被占用，引用计数减 1，若被占用，等待写线程数加 1，等待写条件 Condition 的通知。\n读模式和写模式的释放都是一样，需要根据判断去通知对应的 Condition：\nclass RWLock(object):\n    def __init__(self):\n        self.lock = threading.Lock()\n        self.rcond = threading.Condition(self.lock)\n        self.wcond = threading.Condition(self.lock)\n        self.read_waiter = 0    # 等待获取读锁的线程数\n        self.write_waiter = 0   # 等待获取写锁的线程数\n        self.state = 0          # 正数：表示正在读操作的线程数   负数：表示正在写操作的线程数（最多-1）\n        self.owners = []        # 正在操作的线程id集合\n        self.write_first = True # 默认写优先，False表示读优先\n\n    def write_acquire(self, blocking=True):\n        # 获取写锁只有当\n        me = threading.get_ident()\n        with self.lock:\n            while not self._write_acquire(me):\n                if not blocking:\n                    return False\n                self.write_waiter += 1\n                self.wcond.wait()\n                self.write_waiter -= 1\n        return True\n\n    def _write_acquire(self, me):\n        # 获取写锁只有当锁没人占用，或者当前线程已经占用\n        if self.state == 0 or (self.state < 0 and me in self.owners):\n            self.state -= 1\n            self.owners.append(me)\n            return True\n        if self.state > 0 and me in self.owners:\n            raise RuntimeError('cannot recursively wrlock a rdlocked lock')\n        return False\n\n    def read_acquire(self, blocking=True):\n        me = threading.get_ident()\n        with self.lock:\n            while not self._read_acquire(me):\n                if not blocking:\n                    return False\n                self.read_waiter += 1\n                self.rcond.wait()\n                self.read_waiter -= 1\n        return True\n\n    def _read_acquire(self, me):\n        if self.state < 0:\n            # 如果锁被写锁占用\n            return False\n\n        if not self.write_waiter:\n            ok = True\n        else:\n            ok = me in self.owners\n        if ok or not self.write_first:\n            self.state += 1\n            self.owners.append(me)\n            return True\n        return False\n\n    def unlock(self):\n        me = threading.get_ident()\n        with self.lock:\n            try:\n                self.owners.remove(me)\n            except ValueError:\n                raise RuntimeError('cannot release un-acquired lock')\n\n            if self.state > 0:\n                self.state -= 1\n            else:\n                self.state += 1\n            if not self.state:\n                if self.write_waiter and self.write_first:   # 如果有写操作在等待（默认写优先）\n                    self.wcond.notify()\n                elif self.read_waiter:\n                    self.rcond.notify_all()\n                elif self.write_waiter:\n                    self.wcond.notify()\n\n    read_release = unlock\n    write_release = unlock\n\n                ", "mainLikeNum": ["6 "], "mainBookmarkNum": "2"}