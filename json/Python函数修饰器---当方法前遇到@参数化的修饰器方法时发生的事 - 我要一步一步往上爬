{"title": "Python函数修饰器---当方法前遇到@参数化的修饰器方法时发生的事 - 我要一步一步往上爬 ", "index": "装饰器,python", "content": "一、前提概念\n　　Python中的函数是对象。也因此，函数可以被当做变量使用。\n二、代码模型\n以下代码片段来自于: http://www.sharejs.com/codes/python/8361\n    # -*- coding: utf-8 -*-\n    from threading import Thread\n    import time\n    \n    class TimeoutException(Exception):\n        pass\n    \n    ThreadStop = Thread._Thread__stop#获取私有函数\n    \n    def timelimited(timeout):\n        def decorator(function):\n            def decorator2(*args,**kwargs):\n                class TimeLimited(Thread):\n                    def __init__(self,_error= None,):\n                        Thread.__init__(self)\n                        self._error =  _error\n                        \n                    def run(self):\n                        try:\n                            self.result = function(*args,**kwargs)\n                        except Exception,e:\n                            self._error =e\n    \n                    def _stop(self):\n                        if self.isAlive():\n                            ThreadStop(self)\n    \n                t = TimeLimited()\n                t.start()\n                t.join(timeout)\n         \n                if isinstance(t._error,TimeoutException):\n                    t._stop()\n                    raise TimeoutException('timeout for %s' % (repr(function)))\n    \n                if t.isAlive():\n                    t._stop()\n                    raise TimeoutException('timeout for %s' % (repr(function)))\n    \n                if t._error is None:\n                    return t.result\n    \n            return decorator2\n        return decorator\n    \n    @timelimited(2)\n    def fn_1(secs):\n        time.sleep(secs)\n        return 'Finished'\n        \n    if __name__ == \"__main__\":\n        print fn_1(4)\n三、分析代码片段\n    @timelimited(2)\n    def fn_1(secs):\n        time.sleep(secs)\n        return 'Finished'\n解析@timelimited(2)过程：\n执行timelimited(2)\n      def timelimited(timeout):\n        def decorator(function):\n            def decorator2(*args,**kwargs):\n                .......\n                t.join(timeout)\n         \n                if isinstance(t._error,TimeoutException):\n                    t._stop()\n                    raise TimeoutException('timeout for %s' % (repr(function)))\n    \n                if t.isAlive():\n                    t._stop()\n                    raise TimeoutException('timeout for %s' % (repr(function)))\n    \n                if t._error is None:\n                    return t.result\n    \n            return decorator2\n        return decorator\n通过函数timelimited(2),可以看到最后返回了decorator函数，其内部参数timeout即为2.此时@timelimited(2)可以看成是@decorator\n@decorator\n        @decorator\n        def somefunction(secs):\npython解析器遇到@，且后面跟着函数时，会把函数somefunction当做参数传递给decorator函数并执行，即decorator(somefunction)，本例中执行 decorator(fn_1)\n         def decorator(function):\n            def decorator2(*args,**kwargs):\n                .......\n                t.join(timeout)\n         \n                if isinstance(t._error,TimeoutException):\n                    t._stop()\n                    raise TimeoutException('timeout for %s' % (repr(function)))\n    \n                if t.isAlive():\n                    t._stop()\n                    raise TimeoutException('timeout for %s' % (repr(function)))\n    \n                if t._error is None:\n                    return t.result\n    \n            return decorator2\n此例中，执行 decorator(fn_1)后返回的是decorator2，decorator2中function参数为fn_1对象，\n最后用返回的decorator2函数替换somefunction，本例中是用decorator2替换了原来的fn_1\n因此，后面直接调用fn_1(4)时，就是调用了decorator2(4)，再在decorator2执行过程中，把参数传给function函数变量执行，最后返回想要的结果。\n吐槽一下：感觉示例代码中的decorator2命名为wrapper会更合适一点\n昨晚看Python in Practice看的兴奋了，睡不着，觉得今天得记录下，所以写了这篇文章，不足或错误之处，请大家指正，谢谢！\n参考文章\n\nHow can I make a chain of function decorators in Python\nPython in Practice\nhttp://www.sharejs.com/codes/python/8361\n\n疑问：\n如果一个作者，在一个网站上发表了文章，如果需要在另一个网站上再发表，需不需要声明成转载或是需要其他什么的说明，麻烦解答一下。\n附：本人简书地址\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}