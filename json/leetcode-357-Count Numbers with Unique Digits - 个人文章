{"title": "leetcode-357-Count Numbers with Unique Digits - 个人文章 ", "index": "python", "content": "此题的总结：    求解 最大爆破值， 是一个 倒序 二分法问题，最终的原子结构是连续的三个数。连续的三个数，可以 往上递推 间隔一个数的三个数，间隔n个数的三个数特点在于：每一次递推，都有可能改变当前槽位值，因为，i，j不变，由于间隔变化，变得是取得间隔点。局部最优公式：  dpi=max(dpi,nums[i]nums[center]nums[j]+dpi+dpcenter)应用:  推理，后面的依赖于前面的，可以用二分法。  三个变量的dp，需要考虑迭代自身位置的值，只用两个索引。\n    此模型的特殊性： 相邻的三个值可以得到一个爆破值， 相邻的两个值相当于没有值，赋予0.\n类比：二分法求极值。 通过二分确定具体的位置。 此处 二分确定确定之前的最大爆破值。\n    二分法求极值的两个值想等。  边界值：长度不满足要求，说明不在计量范围内，可以赋予0.\n    编辑距离：从前到后，遍历，依次求最小的移动距离。   此处 二分法到极值是三个连续的数，从相邻三个数的固定值，逐次放宽范围，确定越来越宽的爆破值。\n总结：dp的应用，相邻作为局部，跳跃位置作为局部\n\nclass Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        assert isinstance(nums,list)\n        nums.insert(0,1)\n        nums.append(1)\n        # row=[0]*len(nums)\n        length=len(nums)\n        max_coins=[[0]*length for _ in range(length)]\n        # print(nums)\n        # print(max_coins)\n        for k in range(2,length):\n            for index_i,i in enumerate(nums[:length-k]):\n                index_j=index_i+k\n                # print(index_i,index_j)\n                for i in range(index_i+1,index_j):\n                    elem1=max_coins[index_i][index_j]\n                    print(index_i,i,index_j)\n                    elem2=max_coins[index_i][i]+max_coins[i][index_j]+nums[index_i]*nums[i]*nums[index_j]\n                    max_coins[index_i][index_j]=max(elem1,elem2)\n        # print(max_coins)\n        return max_coins[0][-1]\n\n\nif __name__=='__main__':\n    st=Solution()\n    input_list=[3, 1, 5, 8]\n    out=st.maxCoins(input_list)\n    print(out)\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}