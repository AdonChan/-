{"title": "Zulip聊天机器人Python开发 - 互联网业务风险控制 ", "index": "python", "content": "Zulip是什么\nZulip是移动和桌面办公聊天解决方案开发商 一个强大的群组聊天软件 目前已被Dropbox收购并完全开源（github:https://github.com/zulip/zulip）\n就Zulip而言，该公司对消息的处理专注于会话，而不仅仅是基本的“聊天”。因此，消息流中包含主题和线程式回复，每个主题可以包含多个细分主题。\n例如，在Zulip网站的一张截图中，“工程”消息流中可以包含“文档”、“新招聘”和“WebKit漏洞”等细分主题。\n示例如下：\n\nZulip表示，这一功能将帮助用户更好地找到对他们有意义的会话。\n其他功能还包括：\n强大而快速的搜索，以及能吸引开发者兴趣的“极客”功能。如键盘快捷键、代码高亮、应用程序接口(API)，以及与Trac、Nagios、GitHub和Jenkins的整合等。\n并且，Zulip还提供了标准的消息/聊天应用功能集合，其中包括拖动上传文件、粘贴图片、群聊、声音通知、未收到消息的电子邮件通知，以及虚拟表情等。\n最重要的一点，zulip还提供了聊天机器人接口。\n一、我们用Zulip来做什么\n在日常工作中，对于一些非技术的小伙伴们，由于需要查询某业务数据结果之类，只有通过攻城狮临时生成一大串数据，或者攻城狮提供调用某个API接口URL链接，直接在网页浏览器中查看数据结果。如此一来，攻城狮还要花时间教小白如何看数据。\n而且，如果API接口URL中涉及用户授权认证，就容易暴露内部授权码，得不偿失了。\n所以我们希望可以通过聊天机器人的开发，把这些非技术人员需要查询的需求集成进去，然后智能解析他们发送的消息，并以友好方式自动答复数据结果。\n举个栗子。\n如果我们需要使用岂安Red.Q（业务风险情报系统）服务查询一些手机号码或者IP地址是否有风险，并给机器人发送消息（我们约定多个数据以逗号隔离）\n消息如下：\n211.97.131.210，58.243.254.109，13136482589， 20160909 \n\n查询结果：\n13136482589：87.4，临时号码、收码平台、异常状态\n211.97.131.210：50.6，组织出口、爬虫\n58.243.254.109：81.9，vps服务器、组织出口、爬虫\n其他： \n20160909：无效内容（不符合有效ip和手机号码基本格式）\n\n二、如何实现\nZulip安装步骤这里略。安装好并登陆zulip系统，我们先在帐号设置里添加一个机器人redq-bot@bigsec.com，系统会生成对应的API Key。\n打开zulip系统url（https://zulip.local/api），系统提供了相关API的使用说明，python说明如下：\nPython API\n#!/usr/bin/env python\nimport zulip\nimport sys\n# Keyword arguments 'email' and 'api_key' are not required if you are using ~/.zuliprc\nclient = zulip.Client(email=\"*********************\",\n                      api_key=\"********************\",\n                      site=https://zulip.local/api )\n# Send a stream message\nclient.send_message({\n    \"type\": \"stream\",\n    \"to\": \"Denmark\",\n    \"subject\": \"Castle\",\n    \"content\": \"Something is rotten in the state of Denmark.\"\n})\n# Send a private message\nclient.send_message({\n    \"type\": \"private\",\n    \"to\": \"hamlet@example.com\",\n    \"content\": \"I come not, friends, to steal away your hearts.\"\n})\n# Print each message the user receives\n# This is a blocking call that will run forever\nclient.call_on_each_message(lambda msg: sys.stdout.write(str(msg) + \"\\n\"))\n# Print every event relevant to the user\n# This is a blocking call that will run forever\n# This will never be reached unless you comment out the previous line\nclient.call_on_each_event(lambda msg: sys.stdout.write(str(msg) + \"\\n\"))\n\nRed.Q案例里：\n通过消息事件回调函数client.call_on_each_message(redq)解析用户发送给机器人的消息内容返回每个匹配内容的Red.Q服务API结果：\nmsgsend\ndef msgsend(sender, msg):\n      client.send_message({\n                  \"type\": \"private\",\n                  \"to\": sender,\n                  \"content\": msg\n                   })\n\n当脚本编写完毕后，需要单独去运行在某台服务器上，该服务器需要与zulip服务器的api接口通信，一般为443或者80端口，交互流程如下：\n 此时，在zulip的Web界面找到此机器人并发送相关消息就可以愉快地进行聊天啦。\n\n反爬虫文章来源：http://bigsec.com/\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "5"}