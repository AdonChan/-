{"title": "轨迹数据压缩算法 - 个人文章 ", "index": "python", "content": "数据\nP0,107.605,137.329\nP1,122.274,169.126\nP2,132.559,179.311\nP3,153.324,184.276\nP4,171.884,174.654\nP5,186.408,168.634\nP6,196.566,145.204\nP7,200.549,127.877\nP8,211.391,118.179\nP9,216.318,116.547\nP10,225.197,122.796\nP11,231.064,135.459\nP12,240.835,143.398\nP13,254.630,144.933\nP14,265.055,158.761\nP15,271.004,159.660\nP16,274.474,173.979\n问题\n\n解\nimport math\n\n# 压缩结果\nCompressed = list()\n\n\nclass Point(object):\n    def __init__(self, id, x, y):\n        self.id = id\n        self.x = x\n        self.y = y\n\n\ndef read_m(path):\n    m = []\n    with open(path, 'r') as f:\n        for i in f.readlines():\n            aa = i.replace('\\n', '').split(\",\")\n            p = Point(aa[0], eval(aa[1]), eval(aa[2]))\n            m.append(p)\n\n    return m\n\n\ndef calc_height(point1, point2, point):\n    \"\"\"\n    计算高\n    :param point1: Point\n    :param point2: Point\n    :param point: Point\n    :return:\n    \"\"\"\n    area = abs(0.5 * (point1.x * point2.y + point2.x *\n                      point.y + point.x * point1.y - point2.x * point1.y - point.x *\n                      point2.y - point1.x * point.y))\n\n    bottom = math.sqrt(\n        math.pow(point1.x - point2.x, 2) + math.pow(point1.y - point2.y, 2)\n    )\n\n    height = area / bottom * 2\n    return height\n\n\ndef DPmain(pointList, tolerance):\n    \"\"\"\n    主要运行结果\n    :param pointList: Point 列表\n    :param tolerance: 容差\n    :return:\n    \"\"\"\n    if pointList == None or pointList.__len__() < 3:\n        return pointList\n\n    firspoint = 0\n    lastPoint = len(pointList) - 1\n\n    Compressed.append(pointList[firspoint])\n    Compressed.append(pointList[lastPoint])\n\n    while (pointList[firspoint] == pointList[lastPoint]):\n        lastPoint -= 1\n    DouglasPeucker(pointList, firspoint, lastPoint, tolerance)\n\n\n\ndef DouglasPeucker(pointList, firsPoint, lastPoint, tolerance):\n    \"\"\"\n    计算通过的内容\n    DP算法\n    :param pointList: 点列表\n    :param firsPoint: 第一个点\n    :param lastPoint: 最后一个点\n    :param tolerance: 容差\n    :return:\n    \"\"\"\n    maxDistance = 0.0\n    indexFarthest = 0\n    for i in range(firsPoint, lastPoint):\n        distance = calc_height(pointList[firsPoint], pointList[lastPoint], pointList[i])\n        if (distance > maxDistance):\n            maxDistance = distance\n            indexFarthest = i\n\n    if maxDistance > tolerance and indexFarthest != 0:\n        Compressed.append(pointList[indexFarthest])\n        DouglasPeucker(pointList, firsPoint, indexFarthest, tolerance)\n        DouglasPeucker(pointList, indexFarthest, lastPoint, tolerance)\n\n\nif __name__ == '__main__':\n    a = read_m(\"轨迹.txt\")\n    print(a.__len__())\n    # for item in a:\n    #     print(item.id, item.x, item.y)\n    DPmain(a, 8)\n    for i in Compressed:\n        print(\"{},{},{}\".format(i.id, i.x, i.y))\n\n结果\nP0,107.605,137.329\nP16,274.474,173.979\nP9,216.318,116.547\nP3,153.324,184.276\nP1,122.274,169.126\nP5,186.408,168.634\nP7,200.549,127.877\n原始图压缩图\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}