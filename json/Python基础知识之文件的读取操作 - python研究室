{"title": "Python基础知识之文件的读取操作 - python研究室 ", "index": "python", "content": "读取文件的操作步骤\n有一道脑筋急转弯，问把大象装进冰箱的步骤，答案很简单，打开冰箱、把大象推进去、关闭冰箱。这就是一个处理问题的思路，我们对文件的操作和这个一样，第一步：打开文件；第二部：处理文件（读取或者写入）；第三部关闭文件，怎么样？其实很简单吧，下面我们就来详细说说文件的操作。\n打开文件\nopen(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)\n打开文件要使用open()函数，()内涉及的参数在初期阶段我们只需要知道三个参数即可,那就是file、mode、和encoding\nfile\n首先是文件名，类型是字符串，要包含路径，如果要打开的文件和当前文件在同一个目录下则可以省略路径（相对路径）.\nmode\n然后是打开文件的模式，格式是：mode='模式', 这里的\"mode=\"可以省略，直接写模式即可，如果不指定模式则默认为r，具体的模式如下:这里引入一个伪名词——指针，想象一下当你在word中编辑文本时有个光标吧？你可以把指针想象成那个光标，光标在哪里你对文件的所有操作就从哪里开始。\nr \n只读。文件的初始指针在文件的开头。这是默认模式。\nrb\n只读的二进制格式。文件的初始指针在文件的开头。\nr+\n读写。文件的初始指针在文件的开头。\nrb+\n读写的二进制格式。文件的初始指针在文件的开头。\nw\n只写。如果该文件已存在则打开文件，清空文件内容。如果该文件不存在，则创建新文件。\nwb\n只写的二进制格式。如果该文件已存在则打开文件，清空文件内容。如果该文件不存在，创建新文件。\nw+\n写读。如果该文件已存在则打开文件，清空文件内容。如果该文件不存在，创建新文件。\nwb+\n写读的二进制格式。如果该文件已存在则打开文件，清空文件内容。如果该文件不存在，创建新文件。\na\n追加写。如果该文件存在，文件的初始指针在文件的结尾。新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。\nab\n追加写的二进制格式。如果该文件存在，文件的初始指针在文件的结尾。新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。\na+\n追加写读。如果该文件已存在，文件的初始指针在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。\nab+\n追加写读的二进制格式。如果该文件已存在，文件的初始指针在文件的结尾。如果该文件不存在，创建新文件用于读写。\nencoding\n第三个参数是文件的编码（非二进制格式时使用），编码的设置必须与要打开的文件的编码一致，否则会报错，也就是说源文件是用什么编码写入的，你打开时就得用什么编码打开。\n处理文件\n\n我们来举一个出错的例子，要实现的操作是打开文件名为“test”的文件，原文件编码为utf-8，而我们打开时使用了gbk编码。文件中只有一句话：十步杀一人，千里不留行。代码如下：\nfile = open('test','r',encoding='gbk')\ncontent = file.read()\nprint(content)\nfile.close()\n这里说明以下，open函数返回的结果是一个文件对象，所以要用一个变量接收一下（file),这样我们就可以方便地使用这个对象的方法了，比如file.read(),file.write，file.flush()等等read()是文件对象的一个方法，作用是读取指定的字符数，如果未指定则默认读取所有内容但是上面的代码执行后会报错，下面是报错信息，大意是gbk编码无法解码(文件打开的过程实际就是解码的过程)\n    ---------------------------------------------------------------------------\n\n    UnicodeDecodeError                        Traceback (most recent call last)\n\n    <ipython-input-78-bb879f008680> in <module>()\n          4 #这里说明以下，open函数返回的结果是一个文件对象，所以要用一个变量接收一下（file),这样我们就可以方便地使用这个\n          5 #对象的方法了，比如file.read(),file.write，file.flush()等等\n    ----> 6 content = file.read()#read()是文件对象的一个方法，作用是读取指定的字符数，如果未指定则默认读取所有内容\n          7 print(content)\n          8 file.close()\n\n    UnicodeDecodeError: 'gbk' codec can't decode byte 0xad in position 4: illegal multibyte sequence\n解决的办法很简单，把编码方式改为utf-8即可,因为linux系统默认是utf-8编码，所以编码也可以省略不写，又因为我们只是要读取下文件，所以模式为r，而默认模式为r,也可以省略不写。所以代码就变成了下面的样子：\nfile = open('test')\ncontent = file.read()\nprint(content)\nfile.close()\n输出为：\n十步杀一人，千里不留行\n方法read()中也可以添加数字参数，作用是指定读取的字符数，不管是汉字还是字母一个字符对应一个字母或者汉字，这里一定要和字节区分开，例子如下：\nfile = open('test')\ncontent = file.read(3)\nprint(content)\nfile.close()\n输出为：\n十步杀\n我们之前使用的打开文件的方式比较麻烦，因为必须要在结束时写关闭文件的语句，这里介绍一种简便的方法,格式是：\nwith open() as file_name:\n    操作代码......\n使用这种方法的好处是不用写关闭文件的语句，with 和as是关键字，记住格式即可.接下来我们创建一个二进制格式的文件\nwith open('二进制','wb') as file: \n    file.write('十步杀一人，千里不留行'.encode('utf8'))\n因为我们打开文件的方式是以二进制格式打开的，那么在写入文件时就要写入二进制格式的字符串，但是对于”十步杀一人，千里不留行“这个字符串的二进制格式是什么呢？我们并不知道，所以我们使用.encode(utf8)来把这个字符串转换成二进制格式。实际上我们通过另外一段代码是可以知道这个字符串对应的二进制格式的，代码如下：\nprint('十步杀一人，千里不留行'.encode('utf8'))\n输出的二进制格式(表现形式为16进制，为什么？因为二进制太长了啊！！！)为：\nb'\\xe5\\x8d\\x81\\xe6\\xad\\xa5\\xe6\\x9d\\x80\\xe4\\xb8\\x80\\xe4\\xba\\xba\\xef\\xbc\\x8c\\xe5\\x8d\\x83\\xe9\\x87\\x8c\\xe4\\xb8\\x8d\\xe7\\x95\\x99\\xe8\\xa1\\x8c'\n在实际中我们当然不可能写这么长的东西，所以我们使用.encode('utf8')来转化。转化时我们使用了utf-8的编码方式。在这里说明一下为什么要编码，想弄清楚这件事就要明白计算机的存储原理。简单地讲，文件在计算机中都是以二进制格式存储的，对于计算机来讲只有两个数字有意义，那就是0和1，也就是二进制，而不同的0和1的组合代表不同的含义（编码不同），比如在gbk编码下一个汉字由两个字节表示，也就是16位二进制数（16个0和1的组合），而在utf-8编码下一个汉字由3个字节表示，也就是24位二进制数（24个0和1的组合），而我们现在要给计算机存储的就是0和1的组合，那么在读取文件或者转化字符串时，如果你不告诉计算机你使用的是哪种编码的话，计算机怎么可能知道这些0和1的组合代表什么含义呢？所以从计算机取出数据或者把普通字符串转化成二进制格式时你必须告诉计算机你使用的是什么编码方式。在本例中使用utf-8编码，所以在字符串后面加上.encode(utf8)\n那么为什么平时可以直接写入普通字符串呢？那是因为在用open（）函数打开文件的时候就已经指定了编码方式。形象地解释:open函数相当于打开了一种通道，平时打开时都是用某种编码的方式打开的，所以我们在写入内容时不必管它以什么编码进入通道的（因为在open函数里面就已经指定了编码方式)而当open函数使用二进制格式打开时（就是带b的模式),这个通道就没有指定编码方式，通道里面只有二进制，所以此时往通道里面放入非二进制格式内容的话就需要指定一种编码方式。除非你直接在file.write()函数中直接写二进制，但是人类是不可能记住那么多二进制组合所代表的含义的。\n然后我们来读取一下上面创建的名字为“二进制”的这个文件\nwith open('二进制','rb') as file:\n    print('不指定解码方式时的结果：',file.read())\n如果我们在读取时不指定解码方式，那么输出的结果就是下面这种人类无法理解的奇怪的东西（实际上它是用16进制表示的二进制）\n不指定解码方式时的结果： b'\\xe5\\x8d\\x81\\xe6\\xad\\xa5\\xe6\\x9d\\x80\\xe4\\xb8\\x80\\xe4\\xba\\xba\\xef\\xbc\\x8c\\xe5\\x8d\\x83\\xe9\\x87\\x8c\\xe4\\xb8\\x8d\\xe7\\x95\\x99\\xe8\\xa1\\x8c'\n所以我们在读取时也要指定编码：\nwith open('二进制','rb') as file:\n    content = file.read()\n    print('指定解码方式后的结果：',content.decode('utf-8'))\n\n指定解码方式后的结果： 十步杀一人，千里不留行\n其他的在读取时可能用到的方法：\nreadline()读取一行，如果里面添加了参数n，则会读取n个字符（我觉得这是个bug，貌似没什么卵用)\nreadlines()读取所有内容，结果返回一个列表，元素由每一行组成。\ntell()会输出当前指针的位置，注意，该位置是以字节来计算的，不是字符\nseek()重新指定指针位置。\n使用readlines()并不是一个好方法，因为是一次性将文件都读取到内存中，如果文件较大时则造成内存溢出，实际中使用下面的方法，系统会自动生成一个迭代器，用迭代的方法把需要的数据取出来。\nwith open('libai') as f:\n    for i in f: #这里的i实际就是迭代后的每一行，用for循环的方式从文件对象中取出来，取一行读一行，节省内存\n        print(i)\n赵客缦胡缨，吴钩霜雪明。银鞍照白马，飒沓如流星。\n\n十步杀一人，千里不留行。事了拂衣去，深藏身与名。\n\n闲过信陵饮，脱剑膝前横。将炙啖朱亥，持觞劝侯嬴。\n\n三杯吐然诺，五岳倒为轻。眼花耳热后，意气素霓生。\n\n救赵挥金锤，邯郸先震惊。千秋二壮士，烜赫大梁城。  \n\n纵死侠骨香，不惭世上英。谁能书阁下，白首太玄经。\n\n关闭文件\n\n如果用with open() 来打开文件的话就不用管关闭文件的操作了，因为Python已经帮你完成了这一步，否则必须在处理文件之后加上关闭文件的操作：file_name.close()\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}