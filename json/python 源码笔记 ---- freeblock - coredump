{"title": "python 源码笔记 ---- freeblock - coredump ", "index": "python,c", "content": "1 引言\n在python内存管理中，有一个block的概念。它比较类似于SGI次级空间配置器。\n  首先申请一块大的空间(4KB)，然后把它切割成一小份（8， 16 一直到512）。\n  当有内存申请的请求时候，简单的流程是：根据大小找到对应的block，然后在freeblock 上给它一份。\n  \n  2 问题\n\n\n整个过程是一种比较自然的slab分配方式。但当我读到这段代码时，却感到疑惑：\n\nstatic void* _PyObject_Malloc(void* ctx, size_t nbytes)\n{\n        ...\n    pool->freeblock = (block*)pool +  pool->nextoffset;\n\n        pool->nextoffset += INDEX2SIZE(size);\n        *(block **)(pool->freeblock) = NULL; // [1]\n        ...\n}\n\n\nfreeblock指向空闲的链表，为它赋值很好理解。但是为什么要加上代码1处那一句！\n对C比较熟悉的童鞋很容易能看出它的作用，它在为*freeblock赋值为NULL。\n\n但是为什么要这么做？\n直到看到内存回收的代码：\n\nstatic void _PyObject_Free(void* ctx, void*p)\n{\n    ...\n    *(block**)p = lastfree = pool->freeblock;\n    pool->freeblock = (block*)p;\n    ...\n}\n\n\n回想一下SGI次级空间配置，它需要一个链表，指向block中可用的小块。因为这些快，是离散的，只有用指针才能索引它。\n在SGI次级空间配置中，是用一个union，达到了节省空间的目的：有数据时，它存储着真正的数据；没有数据时，它就变成指向下一块可用内存的指针：\n\nunion __Obj {\n    union __Obj* free_list_link;\n    char client_data[];\n};\n\n\n这样一想，问题就变得很明显了。freeblock指向一个链表，链表的next域就由它自己来索引。\n在_PyObject_Free中，内存p是要被回收的，它应该插在freeblock的链表头，freeblock被更新指向它。同时，p指向原来freeblock指向的内容，这是一个很简单的链表插入操作。\n这样在遍历的时候，我们就可以用freeblock = * freeblock的方式来工作了。\n如下图所示:\n\n\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "2"}