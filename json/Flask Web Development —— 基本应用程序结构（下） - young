{"title": "Flask Web Development —— 基本应用程序结构（下） - young ", "index": "python,flask", "content": "5、请求-响应循环\n\n现在你已经玩过一个基本的Flask应用程序，你也许想要知道更多关于Flask如何施展魔力。下面章节描述了一些框架设计方面的特点。\n\n5.1、应用程序Context和请求Context\n\n当Flask从客户端收到一个请求，它需要提供几个可用对象给视图函数处理。request对象是个不错的例子，它封装了客户端发送的HTTP请求。\n\nFlask视图函数访问request对象的最好方式，就是作为一个参数发送它，但这需要每个单一视图函数在应用程序中有一个额外的参数。考虑一下，如果request对象不是唯一一个视图函数需要访问完成请求的对象，事情将会变得更加复杂。\n\n为了避免弄乱视图函数那些可能需要或不需要的参数，Flask使用context来临时确定可访问的全局对象。也多亏了context，视图函数可以写成下面这样：\n\nfrom flask import request\n\n@app.route('/')\ndef index():\n    user_agent = request.headers.get('User-Agent')\n    return '\n\n<p>Your browser is %s</p>\n\n' % user_agent\n\n\n注意，在这个视图函数中，request是如何被作为一个全局变量来使用的。现实中，request是不能作为全局变量的，如果是多线程服务器，同一时间线程作用于不同客户端的不同请求，所以每一个线程需要看到request中的不同对象。contexts使得Flask确定可访问的全局变量而不干扰其他线程。\n\n\n  注：线程是可以独立管理的最小指令序列。一个进程中有多个活动的线程是非常常见的，有时分享内存或文件句柄资源。多线程web服务器会启动一个线程池并从池中选择一个线程来处理每个传入的请求。\n\n\nFlask有两类context：应用级context 和 请求级context。表2-1展示了这些context提供的变量。\n\n表2-1. Flask全局context\n\n\n\nFlask激活（或压栈）应用级context和请求级context在调度请求之前，然后删除他们当请求被处理后。当应用程序context被压入栈，线程中current_app和g变量变得可用；同样的，当请求级context被压入栈，request和session变量也同样变得可用。如果这些变量中的任何一个不是由激活的应用级或请求级context访问，会产生错误。在后面的章节会详细讨论四个context变量，所以不要担心你不理解它们的用处。\n\n下面的Python shell会话演示了应用级context是如何工作的：\n\n>>> from hello import app\n>>> from flask import current_app\n>>> current_app.name\nTraceback (most recent call last):\n...\nRuntimeError: working outside of the application context\n>>> app_ctx = app.app_context()\n>>> app_ctx.push()\n>>> current_app.name\n'hello'\n>>> app_ctx.pop()\n\n\n在这个示例中，当应用级context没有激活，但是却作为有效的context被压入栈中，current_app.name报错。注意在应用程序实例中一个应用级context是如何通过调用app.app_context()来获得的。\n\n5.2、请求调度\n\n当一个应用程序收到客户端的请求，它需要找到响应的视图函数为之服务。对于这个任务，Flask会在应用程序的URL映射中查找请求的URL，该映射包含URLs和操作它们的视图函数。Flask通过app.route装饰器或非装饰器版本app.add_url_rule()来建立这个映射。\n\n看一下Flask应用程序中URL映射是怎样的，你可以在Python shell中检查hello.py创建的映射。测试中，请确保你的虚拟环境是激活状态：\n\n(venv) % python\n>>> from hello import app\n>>> app.url_map\nMap([<Rule '/' (HEAD, OPTIONS, GET) -> index>,\n  <Rule '/static/<filename>' (HEAD, OPTIONS, GET) -> static>,\n  <Rule '/user/<name>' (HEAD, OPTIONS, GET) -> user>])\n\n\n/和/user/<name>路由是由应用程序中的app.route所定义。/static/<filename>路由是由Flask添加，用于访问静态文件的一个特殊路由。你将在第三章学习更多关于静态文件的内容。\n\nURL映射中所示的HEAD、OPTIONS、GET元素为request方法，由路由处理。Flask连接方法到每个路由，这样不同的请求方法发送到相同的URL可以被不同的视图函数处理。HEAD和OPTIONS方法由Flask自动管理，所以实际上可以说，在这个应用程序中URL映射的三个路由都连接到GET方法了。在第四章你将学习为路由指定不同的请求方法。\n\n5.3、请求Hooks\n\n有些时候在每个请求处理之前或之后执行代码是非常有用的。例如，在开始每一个请求前可能有必要创建数据库连接，或对用户请求进行验证。为了避免复制处理这些操作的代码到每一个视图函数中，Flask给你选择注册相同函数来调用，在请求被分配给视图函数之前或之后。\n\n请求hooks由装饰器实现。下面是四个Flask支持的hooks：\n\n\n\nbefore_first_request：在第一个请求被处理前注册一个函数运行。\n\nbefore_request：在每一个请求前注册一个函数运行。\n\nafter_request：如果没有未处理的异常发生，在每一个请求后注册一个函数运行。\n\nteardown_request：即使未处理的异常发生，在每一个请求后注册一个函数运行。\n\n在请求hook函数和视图函数之间共享数据的惯用方法就是使用g全局context。例如，before_request处理程序可以从数据库加载已登录的用户并保存在g.user中。之后，当视图函数被调用，可以从那访问用户。\n\n请求hooks的示例会在未来的章节中展示给大家，所以不用担心，\n\n5.4、响应\n\n当Flask调用一个视图函数，并期望它的返回值去响应该请求。大多数的响应是将简单字符串构成的HTML页面发回给客户端。\n\n但是HTTP协议需要比字符串更多的信息作为请求的响应。一个HTTP响应中非常重要的部分是状态码，Flask默认设置200来指示请求已经成功处理。\n\n当视图函数需要用不同的状态码响应，可以在响应文本后添加数字码作为第二个返回值。例如，下面的视图函数返回400错误状态码的请求：\n\n@app.route('/')\ndef index():\n    return '<h1>Bad Request</h1>', 400\n\n\n视图函数返回的响应还可以携带第三个参数，添加一个头部字典给HTTP响应。通常很少用到，但是你可以在第十四章看到示例。\n\n除了返回一个、两个或三个值的元组，Flask视图函数可以选择返回response对象。make_response()函数可携带一个、两个或三个参数，和视图函数返回的值一样，并返回一个response对象。有时候在视图函数中执行这个转换是非常有用的，然后使用response对象中的方法进一步配置响应。下面的示例创建response对象并设置cookie：\n\nfrom flask import make_response\n\n@app.route('/')\ndef index():\n    response = make_response('\n\n<h1>This document carries a cookie!</h1>\n\n')\n    response.set_cookie('answer', '42')\n    return response\n\n\n有一类特殊的响应称作重定向。这类响应不包含页面文档；只是给浏览器一个新的URL去加载新的页面。重定向通常和web表单一起使用，你将在第四章学习。\n\n重定向通常由302响应状态码注明并且重定向的URL由头部的Location给出。重定向响应可以使用三个值的返回生成，也可通过响应对象生成，但是鉴于它频繁的使用，Flask提供redirect()函数来创建这样的响应：\n\nfrom flask import redirect\n\n@app.route('/')\ndef index():\n    return redirect('http://www.example.com')\n\n\n另一个具有中断功能的特殊响应用来错误处理。下面的示例，当URL给出的id动态参数不是一个合法的用户时返回状态码404：\n\nfrom flask import abort\n\n@app.route('/user/<id>')\ndef get_user(id):\n    user = load_user(id)\n    if not user:\n        abort(404)\n    return '\n\n<h1>Hello, %s</h1>\n\n' % user.name\n\n\n注意终止不是指将控制权返回给调用它的函数，而是指通过抛出异常将控制权返回给web服务。\n\n6、Flask扩展\n\nFlask是可扩展的。它故意腾出地给重要的功能，例如数据库和用户授权，给你自由去选择最适合你的应用程序的包，或写一个自己想要的。\n\n社区开发了非常多的扩展用于各种用途，如果这还不够，可以使用任何Python标准包和库。为了让你了解一个扩展是如何并入一个应用程序的，下面的章节给hello.py添加一个扩展，增加应用程序的命令行参数。\n\n6.1、Flask-Script命令行选项\n\nFlask开发，其web服务器支持一系列的启动配置选项，但是配置它们的唯一方式只有在脚本中传递参数给app.run()并调用。这不是非常的方便，理想方法是通过命令行参数传递配置选项。\n\nFlask-Script是给你的Flask应用程序添加命令行解释的扩展。它打包了一组通用的选项，还支持自定义命令。\n\n使用pip安装扩展：\n\n(venv) $ pip install flask-script\n\n\n示例2-3展示了在 hello.py 应用程序中添加命令行解释的变化。\n\n示例2-3. hello.py：使用Flask-Script\n\nfrom flask.ext.script import Manager\n\nmanager = Manager(app)\n\n# ...\n\nif __name__ == '__main__':\n    manager.run()\n\n\n专为Flask开发的扩展暴露在flask.ext命名空间下。Flask-Script从flask.ext.script中导出一个名为Manager的类。\n\n初始化这个扩展的方法和其他许多扩展一样：主类实例的初始化是通过将应用程序实例作为参数传递给构造函数实现的。创建的对象适当的用于每一个扩展。在这个示例中，服务器启动通过manager.run()来路由，且命令行在这被解析。\n\n\n  建议：如果你有克隆在GitHub上的应用程序，你现在可以运行git checkout 2c来切换到这个版本的应用程序。\n\n\n因为这些变化，应用程序获得一组基本的命令行选项。运行hello.py显示可用信息：\n\n$ python hello.py\nusage: hello.py [-h] {shell, runserver} ...\n\npositional arguments:\n  {shell, runserver}\n    shell           在Flask应用程序上下文的内部运行一个Python Shell。\n    runserver       运行Flask开发服务器，例如：app.run()\n\noptional arguments:\n  -h, --help        显示这个帮助信息并退出\n\n\nshell命令用于在应用程序上下文中启动一个Python shell会话。你可以使用这个会话去运行维护任务，或测试，或调试错误。\n\nrunserver命令，就像它的名称一样，启动web服务。运行python hello.py runserver在调试模式下启动web服务，还有更多的选项：\n\n(venv) $ python hello.py runserver --help\nusage: hello.py runserver [-h] [-t HOST] [-p PORT] [--threaded]\n                          [--processes PROCESSES] [--passthrough-errors] [-d]\n                          [-r]\n\n运行Flask开发服务器，例如：app.run()\n\noptional arguments:\n  -h, --help             显示这个帮助信息并退出\n  -t HOST, --host HOST\n  -p PORT, --port PORT\n  --threaded\n  --processes PROCESSES\n  --passthrough-errors\n  -d, --no-debug\n  -r, --no-reload \n\n\n--host参数是一个非常有用的选项，因为它能告诉web服务器监听哪个网络接口的客户端连接。默认，Flask开发的web服务器监听localhost的连接，所以只有来自内部计算机运行的服务器可以接收。下面的命令使得web服务器监听公网接口，其他网络上的计算机可以连接：\n\n(venv) $ python hello.py runserver --host 0.0.0.0\n * Running on http://0.0.0.0:5000/\n * Restarting with reload\n\n\n现在web服务器应该可以从网络中的任何一台计算机访问 http://a.b.c.d:5000 ，“a.b.c.d”是运行服务的计算机的外部IP地址。\n\n这一章介绍了请求响应的概念，但说的更多的是响应。Flask使用模板为生成响应提供非常好的支持，这是非常重要的话题，下一章会重点讲它。\n\n                ", "mainLikeNum": ["4 "], "mainBookmarkNum": "22"}