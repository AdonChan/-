{"title": "python综合学习五之Pandas - Corwien ", "index": "pandas,python", "content": "这一节，主要深入学习Pandas的用法。\n一、筛选\n先建立一个 6X4 的矩阵数据。\ndates = pd.date_range('20180830', periods=6)\ndf = pd.DataFrame(np.arange(24).reshape((6,4)),index=dates, columns=['A','B','C','D'])\nprint(df)\n\n打印：\n             A   B   C   D\n2018-08-30   0   1   2   3\n2018-08-31   4   5   6   7\n2018-09-01   8   9  10  11\n2018-09-02  12  13  14  15\n2018-09-03  16  17  18  19\n2018-09-04  20  21  22  23\n\n简单的筛选\n如果我们想选取 DataFrame 中的数据，下面描述了两种途径, 他们都能达到同一个目的：\nprint(df['A'])\nprint(df.A)\n\n\"\"\"\n2018-08-30     0\n2018-08-31     4\n2018-09-01     8\n2018-09-02    12\n2018-09-03    16\n2018-09-04    20\nFreq: D, Name: A, dtype: int64\n\"\"\"\n让选择跨越多行或多列:\nprint(df[0:3])\n \n\"\"\"\n            A  B   C   D\n2018-08-30  0  1   2   3\n2018-08-31  4  5   6   7\n2018-09-01  8  9  10  11\n\"\"\"\n\nprint(df['20180830':'20180901'])\n\n\"\"\"\n            A  B   C   D\n2018-08-30  0  1   2   3\n2018-08-31  4  5   6   7\n2018-09-01  8  9  10  11\n\"\"\"\n如果df[3:3]将会是一个空对象。后者选择20180830到20180901标签之间的数据，并且包括这两个标签。\n根据标签loc\n同样我们可以使用标签来选择数据 loc, 本例子主要通过标签名字选择某一行数据， 或者通过选择某行或者所有行（:代表所有行）然后选其中某一列或几列数据。:\nprint(df.loc['20130102'])\n\"\"\"\nA    4\nB    5\nC    6\nD    7\nName: 2013-01-02 00:00:00, dtype: int64\n\"\"\"\n\nprint(df.loc[:,['A','B']]) \n\"\"\"\n             A   B\n2013-01-01   0   1\n2013-01-02   4   5\n2013-01-03   8   9\n2013-01-04  12  13\n2013-01-05  16  17\n2013-01-06  20  21\n\"\"\"\n\nprint(df.loc['20130102',['A','B']])\n\"\"\"\nA    4\nB    5\nName: 2013-01-02 00:00:00, dtype: int64\n\"\"\"\n根据序列iloc\n另外我们可以采用位置进行选择 iloc, 在这里我们可以通过位置选择在不同情况下所需要的数据例如选某一个，连续选或者跨行选等操作。\nprint(df.iloc[3,1])\n# 13\n\nprint(df.iloc[3:5,1:3])\n\"\"\"\n             B   C\n2013-01-04  13  14\n2013-01-05  17  18\n\"\"\"\n\nprint(df.iloc[[1,3,5],1:3])\n\"\"\"\n             B   C\n2013-01-02   5   6\n2013-01-04  13  14\n2013-01-06  21  22\n\n\"\"\"\n在这里我们可以通过位置选择在不同情况下所需要的数据, 例如选某一个，连续选或者跨行选等操作。\n根据混合的这两种 ix\n当然我们可以采用混合选择 ix, 其中选择’A’和’C’的两列，并选择前三行的数据。\nprint(df.ix[:3,['A','C']])\n\"\"\"\n            A   C\n2013-01-01  0   2\n2013-01-02  4   6\n2013-01-03  8  10\n\"\"\"\n二、设置值\n我们可以根据自己的需求, 用 pandas 进行更改数据里面的值, 或者加上一些空的,或者有数值的列.\n首先建立了一个 6X4 的矩阵数据。\n# -*- coding:utf-8 -*-\n\n\"\"\"\n@author: Corwien\n@file: pd_value.py\n@time: 18/8/31 00:59\n\"\"\"\n\nimport pandas as pd\nimport numpy as np\n\ndates = pd.date_range('20180101', periods=6)\ndf = pd.DataFrame(np.arange(24).reshape((6,4)),index=dates, columns=['A','B','C','D'])\n\nprint(df)\n\n\"\"\"\n             A   B   C   D\n2018-01-01   0   1   2   3\n2018-01-02   4   5   6   7\n2018-01-03   8   9  10  11\n2018-01-04  12  13  14  15\n2018-01-05  16  17  18  19\n2018-01-06  20  21  22  23\n\"\"\"\n   \n根据位置设置loc和iloc\n我们可以利用索引或者标签确定需要修改值的位置。\ndf.iloc[2,3] = 1111\ndf.loc['20180103', 'B'] = 2222\n\nprint(df)\n打印：\n             A     B   C     D\n2018-01-01   0     1   2     3\n2018-01-02   4     5   6     7\n2018-01-03   8  2222  10  1111\n2018-01-04  12    13  14    15\n2018-01-05  16    17  18    19\n2018-01-06  20    21  22    23\n根据条件设置\n如果现在的判断条件是这样, 我们想要更改B中的数, 而更改的位置是取决于 A 的. 对于A大于4的位置. 更改B在相应位置上的数为0.\ndf.B[df.A>4] = 0\nprint(df)\n原数据：\n             A     B   C     D\n2018-01-01   0     1   2     3\n2018-01-02   4     5   6     7\n2018-01-03   8  2222  10  1111\n2018-01-04  12    13  14    15\n2018-01-05  16    17  18    19\n2018-01-06  20    21  22    23\ndf.B[df.A>4] = 0更改后的数据：\n    A  B   C     D\n2018-01-01   0  1   2     3\n2018-01-02   4  5   6     7\n2018-01-03   8  0  10  1111\n2018-01-04  12  0  14    15\n2018-01-05  16  0  18    19\n2018-01-06  20  0  22    23\n按行或列设置\n如果对整列做批处理, 加上一列 ‘F’, 并将 F 列全改为 NaN, 如下:\ndf['F'] = np.nan\n\"\"\"\n          A  B   C     D   F\n2018-01-01   0  1   2     3 NaN\n2018-01-02   4  5   6     7 NaN\n2018-01-03   8  0  10  1111 NaN\n2018-01-04  12  0  14    15 NaN\n2018-01-05  16  0  18    19 NaN\n2018-01-06  20  0  22    23 NaN\n\"\"\"\n添加数据\n用上面的方法也可以加上 Series 序列（但是长度必须对齐）。\n        A  B   C     D   F  E\n2018-01-01   0  1   2     3 NaN  1\n2018-01-02   4  5   6     7 NaN  2\n2018-01-03   8  0  10  1111 NaN  3\n2018-01-04  12  0  14    15 NaN  4\n2018-01-05  16  0  18    19 NaN  5\n2018-01-06  20  0  22    23 NaN  6\n通过上边的学习，我们学会了如何对 DataFrame 中在自己想要的地方赋值或者增加数据。\n三、处理丢失数据\n创建含 NaN 的矩阵\n有时候我们导入或处理数据, 会产生一些空的或者是 NaN 数据,如何删除或者是填补这些 NaN 数据就是我们今天所要提到的内容.\n建立了一个6X4的矩阵数据并且把两个位置置为空.\ndates = pd.date_range('20130101', periods=6)\ndf = pd.DataFrame(np.arange(24).reshape((6,4)),index=dates, columns=['A','B','C','D'])\ndf.iloc[0,1] = np.nan\ndf.iloc[1,2] = np.nan\n\"\"\"\n             A     B     C   D\n2013-01-01   0   NaN   2.0   3\n2013-01-02   4   5.0   NaN   7\n2013-01-03   8   9.0  10.0  11\n2013-01-04  12  13.0  14.0  15\n2013-01-05  16  17.0  18.0  19\n2013-01-06  20  21.0  22.0  23\n\"\"\"\npd.dropna()\n如果想直接去掉有 NaN 的行或列, 可以使用 dropna\ndf.dropna(\n    axis=0,     # 0: 对行进行操作; 1: 对列进行操作\n    how='any'   # 'any': 只要存在 NaN 就 drop 掉; 'all': 必须全部是 NaN 才 drop \n    ) \n\"\"\"\n             A     B     C   D\n2013-01-03   8   9.0  10.0  11\n2013-01-04  12  13.0  14.0  15\n2013-01-05  16  17.0  18.0  19\n2013-01-06  20  21.0  22.0  23\n\"\"\"\npd.fillna()\n如果是将 NaN 的值用其他值代替, 比如代替成 0:\ndf.fillna(value=0)\n\"\"\"\n             A     B     C   D\n2013-01-01   0   0.0   2.0   3\n2013-01-02   4   5.0   0.0   7\n2013-01-03   8   9.0  10.0  11\n2013-01-04  12  13.0  14.0  15\n2013-01-05  16  17.0  18.0  19\n2013-01-06  20  21.0  22.0  23\n\"\"\"\npd.isnull()\n判断是否有缺失数据 NaN, 为 True 表示缺失数据:\ndf.isnull() \n\"\"\"\n                A      B      C      D\n2013-01-01  False   True  False  False\n2013-01-02  False  False   True  False\n2013-01-03  False  False  False  False\n2013-01-04  False  False  False  False\n2013-01-05  False  False  False  False\n2013-01-06  False  False  False  False\n\"\"\"\n检测在数据中是否存在 NaN, 如果存在就返回 True:\nnp.any(df.isnull()) == True  \n# True\n四、导入导出\n说明\npandas可以读取与存取的资料格式有很多种，像csv、excel、json、html与pickle等…， 详细请看官方说明文件\n读取csv\nimport pandas as pd #加载模块\n\n#读取csv\ndata = pd.read_csv('student.csv')\n\n#打印出data\nprint(data)\n打印结果：\n/Users/kaiyiwang/anaconda2/bin/python /Users/kaiyiwang/Code/python/baseLearn/pandas/pd_csv.py\n    Student ID  name   age  gender\n0         1100  Kelly   22  Female\n1         1101    Clo   21  Female\n2         1102  Tilly   22  Female\n3         1103   Tony   24    Male\n4         1104  David   20    Male\n5         1105  Catty   22  Female\n6         1106      M    3  Female\n7         1107      N   43    Male\n8         1108      A   13    Male\n9         1109      S   12    Male\n10        1110  David   33    Male\n11        1111     Dw    3  Female\n12        1112      Q   23    Male\n13        1113      W   21  Female\n将资料存取成pickle\ndata.to_pickle('student.pickle')\n五、合并concat\npandas处理多组数据的时候往往会要用到数据的合并处理,使用 concat 是一种基本的合并方式.而且concat中有很多参数可以调整,合并成你想要的数据形式.\naxis(合并方向)\naxis=0是预设值，因此未设定任何参数时，函数默认axis=0。\n# -*- coding:utf-8 -*-\n\n\"\"\"\n@author: Corwien\n@file: pd_concat.py\n@time: 18/9/1 10:28\n\"\"\"\n   \nimport pandas as pd #加载模块\nimport numpy as np\n\n#定义资料集\ndf1 = pd.DataFrame(np.ones((3,4))*0, columns=['a','b','c','d'])\ndf2 = pd.DataFrame(np.ones((3,4))*1, columns=['a','b','c','d'])\ndf3 = pd.DataFrame(np.ones((3,4))*2, columns=['a','b','c','d'])\n\n# print df1\n\n#concat纵向合并\nres = pd.concat([df1, df2, df3], axis=0)\n\nprint(res)\n\n结果打印：\n a    b    c    d\n0  0.0  0.0  0.0  0.0\n1  0.0  0.0  0.0  0.0\n2  0.0  0.0  0.0  0.0\n0  1.0  1.0  1.0  1.0\n1  1.0  1.0  1.0  1.0\n2  1.0  1.0  1.0  1.0\n0  2.0  2.0  2.0  2.0\n1  2.0  2.0  2.0  2.0\n2  2.0  2.0  2.0  2.0\n仔细观察会发现结果的index是0, 1, 2, 0, 1, 2, 0, 1, 2，若要将index重置，请看例子二。\nignore_index (重置 index)\n#承上一个例子，并将index_ignore设定为True\nres = pd.concat([df1, df2, df3], axis=0, ignore_index=True)\n\n#打印结果\nprint(res)\n#     a    b    c    d\n# 0  0.0  0.0  0.0  0.0\n# 1  0.0  0.0  0.0  0.0\n# 2  0.0  0.0  0.0  0.0\n# 3  1.0  1.0  1.0  1.0\n# 4  1.0  1.0  1.0  1.0\n# 5  1.0  1.0  1.0  1.0\n# 6  2.0  2.0  2.0  2.0\n# 7  2.0  2.0  2.0  2.0\n# 8  2.0  2.0  2.0  2.0\n结果的index变0, 1, 2, 3, 4, 5, 6, 7, 8。\njoin (合并方式)\njoin='outer'为预设值，因此未设定任何参数时，函数默认join='outer'。此方式是依照column来做纵向合并，有相同的column上下合并在一起，其他独自的column个自成列，原本没有值的位置皆以NaN填充。\n#定义资料集\ndf1 = pd.DataFrame(np.ones((3,4))*0, columns=['a','b','c','d'], index=[1,2,3])\ndf2 = pd.DataFrame(np.ones((3,4))*1, columns=['b','c','d','e'], index=[2,3,4])\n\nprint(df1)\nprint(\"======\\n\")\n\nprint(df2)\nprint(\"======\\n\")\n\n#纵向\"外\"合并df1与df2\nres = pd.concat([df1, df2], axis=0, join='outer')\n\nprint(res)\n结果打印：\n    a    b    c    d\n1  0.0  0.0  0.0  0.0\n2  0.0  0.0  0.0  0.0\n3  0.0  0.0  0.0  0.0\n======\n\n     b    c    d    e\n2  1.0  1.0  1.0  1.0\n3  1.0  1.0  1.0  1.0\n4  1.0  1.0  1.0  1.0\n======\n\n     a    b    c    d    e\n1  0.0  0.0  0.0  0.0  NaN\n2  0.0  0.0  0.0  0.0  NaN\n3  0.0  0.0  0.0  0.0  NaN\n2  NaN  1.0  1.0  1.0  1.0\n3  NaN  1.0  1.0  1.0  1.0\n4  NaN  1.0  1.0  1.0  1.0\n原理同上个例子的说明，但只有相同的column合并在一起，其他的会被抛弃。\n#承上一个例子\n\n#纵向\"内\"合并df1与df2\nres = pd.concat([df1, df2], axis=0, join='inner')\n\n#打印结果\nprint(res)\n#     b    c    d\n# 1  0.0  0.0  0.0\n# 2  0.0  0.0  0.0\n# 3  0.0  0.0  0.0\n# 2  1.0  1.0  1.0\n# 3  1.0  1.0  1.0\n# 4  1.0  1.0  1.0\n\n#重置index并打印结果\nres = pd.concat([df1, df2], axis=0, join='inner', ignore_index=True)\nprint(res)\n#     b    c    d\n# 0  0.0  0.0  0.0\n# 1  0.0  0.0  0.0\n# 2  0.0  0.0  0.0\n# 3  1.0  1.0  1.0\n# 4  1.0  1.0  1.0\n# 5  1.0  1.0  1.0\njoin_axes (依照axes合并)\n#定义资料集\ndf1 = pd.DataFrame(np.ones((3,4))*0, columns=['a','b','c','d'], index=[1,2,3])\ndf2 = pd.DataFrame(np.ones((3,4))*1, columns=['b','c','d','e'], index=[2,3,4])\n\n#依照`df1.index`进行横向合并\nres = pd.concat([df1, df2], axis=1, join_axes=[df1.index])\n\n#打印结果\nprint(res)\n#     a    b    c    d    b    c    d    e\n# 1  0.0  0.0  0.0  0.0  NaN  NaN  NaN  NaN\n# 2  0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0\n# 3  0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0\n\n#移除join_axes，并打印结果\nres = pd.concat([df1, df2], axis=1)\nprint(res)\n#     a    b    c    d    b    c    d    e\n# 1  0.0  0.0  0.0  0.0  NaN  NaN  NaN  NaN\n# 2  0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0\n# 3  0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0\n# 4  NaN  NaN  NaN  NaN  1.0  1.0  1.0  1.0\nappend (添加数据)\nappend只有纵向合并，没有横向合并。\nimport pandas as pd\nimport numpy as np\n\n#定义资料集\ndf1 = pd.DataFrame(np.ones((3,4))*0, columns=['a','b','c','d'])\ndf2 = pd.DataFrame(np.ones((3,4))*1, columns=['a','b','c','d'])\ndf3 = pd.DataFrame(np.ones((3,4))*1, columns=['a','b','c','d'])\ns1 = pd.Series([1,2,3,4], index=['a','b','c','d'])\n\n#将df2合并到df1的下面，以及重置index，并打印出结果\nres = df1.append(df2, ignore_index=True)\nprint(res)\n#     a    b    c    d\n# 0  0.0  0.0  0.0  0.0\n# 1  0.0  0.0  0.0  0.0\n# 2  0.0  0.0  0.0  0.0\n# 3  1.0  1.0  1.0  1.0\n# 4  1.0  1.0  1.0  1.0\n# 5  1.0  1.0  1.0  1.0\n\n#合并多个df，将df2与df3合并至df1的下面，以及重置index，并打印出结果\nres = df1.append([df2, df3], ignore_index=True)\nprint(res)\n#     a    b    c    d\n# 0  0.0  0.0  0.0  0.0\n# 1  0.0  0.0  0.0  0.0\n# 2  0.0  0.0  0.0  0.0\n# 3  1.0  1.0  1.0  1.0\n# 4  1.0  1.0  1.0  1.0\n# 5  1.0  1.0  1.0  1.0\n# 6  1.0  1.0  1.0  1.0\n# 7  1.0  1.0  1.0  1.0\n# 8  1.0  1.0  1.0  1.0\n\n#合并series，将s1合并至df1，以及重置index，并打印出结果\nres = df1.append(s1, ignore_index=True)\nprint(res)\n#     a    b    c    d\n# 0  0.0  0.0  0.0  0.0\n# 1  0.0  0.0  0.0  0.0\n# 2  0.0  0.0  0.0  0.0\n# 3  1.0  2.0  3.0  4.0\n六、合并merge\npandas中的merge和concat类似,但主要是用于两组有key column的数据,统一索引的数据. 通常也被用在Database的处理当中.\n依据一组key合并\nimport pandas as pd\n\n#定义资料集并打印出\nleft = pd.DataFrame({'key': ['K0', 'K1', 'K2', 'K3'],\n                             'A': ['A0', 'A1', 'A2', 'A3'],\n                             'B': ['B0', 'B1', 'B2', 'B3']})\nright = pd.DataFrame({'key': ['K0', 'K1', 'K2', 'K3'],\n                              'C': ['C0', 'C1', 'C2', 'C3'],\n                              'D': ['D0', 'D1', 'D2', 'D3']})\n\nprint(left)\n#    A   B key\n# 0  A0  B0  K0\n# 1  A1  B1  K1\n# 2  A2  B2  K2\n# 3  A3  B3  K3\n\nprint(right)\n#    C   D key\n# 0  C0  D0  K0\n# 1  C1  D1  K1\n# 2  C2  D2  K2\n# 3  C3  D3  K3\n\n#依据key column合并，并打印出\nres = pd.merge(left, right, on='key')\n\nprint(res)\n     A   B key   C   D\n# 0  A0  B0  K0  C0  D0\n# 1  A1  B1  K1  C1  D1\n# 2  A2  B2  K2  C2  D2\n# 3  A3  B3  K3  C3  D3\n依据两组key合并\n合并时有4种方法how = ['left', 'right', 'outer', 'inner']，预设值how='inner'。\nimport pandas as pd\n\n#定义资料集并打印出\nleft = pd.DataFrame({'key1': ['K0', 'K0', 'K1', 'K2'],\n                      'key2': ['K0', 'K1', 'K0', 'K1'],\n                      'A': ['A0', 'A1', 'A2', 'A3'],\n                      'B': ['B0', 'B1', 'B2', 'B3']})\nright = pd.DataFrame({'key1': ['K0', 'K1', 'K1', 'K2'],\n                       'key2': ['K0', 'K0', 'K0', 'K0'],\n                       'C': ['C0', 'C1', 'C2', 'C3'],\n                       'D': ['D0', 'D1', 'D2', 'D3']})\n\nprint(left)\n#    A   B key1 key2\n# 0  A0  B0   K0   K0\n# 1  A1  B1   K0   K1\n# 2  A2  B2   K1   K0\n# 3  A3  B3   K2   K1\n\nprint(right)\n#    C   D key1 key2\n# 0  C0  D0   K0   K0\n# 1  C1  D1   K1   K0\n# 2  C2  D2   K1   K0\n# 3  C3  D3   K2   K0\n\n#依据key1与key2 columns进行合并，并打印出四种结果['left', 'right', 'outer', 'inner']\nres = pd.merge(left, right, on=['key1', 'key2'], how='inner')\nprint(res)\n#    A   B key1 key2   C   D\n# 0  A0  B0   K0   K0  C0  D0\n# 1  A2  B2   K1   K0  C1  D1\n# 2  A2  B2   K1   K0  C2  D2\n\nres = pd.merge(left, right, on=['key1', 'key2'], how='outer')\nprint(res)\n#     A    B key1 key2    C    D\n# 0   A0   B0   K0   K0   C0   D0\n# 1   A1   B1   K0   K1  NaN  NaN\n# 2   A2   B2   K1   K0   C1   D1\n# 3   A2   B2   K1   K0   C2   D2\n# 4   A3   B3   K2   K1  NaN  NaN\n# 5  NaN  NaN   K2   K0   C3   D3\n\nres = pd.merge(left, right, on=['key1', 'key2'], how='left')\nprint(res)\n#    A   B key1 key2    C    D\n# 0  A0  B0   K0   K0   C0   D0\n# 1  A1  B1   K0   K1  NaN  NaN\n# 2  A2  B2   K1   K0   C1   D1\n# 3  A2  B2   K1   K0   C2   D2\n# 4  A3  B3   K2   K1  NaN  NaN\n\nres = pd.merge(left, right, on=['key1', 'key2'], how='right')\nprint(res)\n#     A    B key1 key2   C   D\n# 0   A0   B0   K0   K0  C0  D0\n# 1   A2   B2   K1   K0  C1  D1\n# 2   A2   B2   K1   K0  C2  D2\n# 3  NaN  NaN   K2   K0  C3  D3\nIndicator\nindicator=True会将合并的记录放在新的一列。\nimport pandas as pd\n\n#定义资料集并打印出\ndf1 = pd.DataFrame({'col1':[0,1], 'col_left':['a','b']})\ndf2 = pd.DataFrame({'col1':[1,2,2],'col_right':[2,2,2]})\n\nprint(df1)\n#   col1 col_left\n# 0     0        a\n# 1     1        b\n\nprint(df2)\n#   col1  col_right\n# 0     1          2\n# 1     2          2\n# 2     2          2\n\n# 依据col1进行合并，并启用indicator=True，最后打印出\nres = pd.merge(df1, df2, on='col1', how='outer', indicator=True)\nprint(res)\n#   col1 col_left  col_right      _merge\n# 0   0.0        a        NaN   left_only\n# 1   1.0        b        2.0        both\n# 2   2.0      NaN        2.0  right_only\n# 3   2.0      NaN        2.0  right_only\n\n# 自定indicator column的名称，并打印出\nres = pd.merge(df1, df2, on='col1', how='outer', indicator='indicator_column')\nprint(res)\n#   col1 col_left  col_right indicator_column\n# 0   0.0        a        NaN        left_only\n# 1   1.0        b        2.0             both\n# 2   2.0      NaN        2.0       right_only\n# 3   2.0      NaN        2.0       right_only\n依据index合并\nimport pandas as pd\n\n#定义资料集并打印出\nleft = pd.DataFrame({'A': ['A0', 'A1', 'A2'],\n                     'B': ['B0', 'B1', 'B2']},\n                     index=['K0', 'K1', 'K2'])\nright = pd.DataFrame({'C': ['C0', 'C2', 'C3'],\n                      'D': ['D0', 'D2', 'D3']},\n                     index=['K0', 'K2', 'K3'])\n\nprint(left)\n#     A   B\n# K0  A0  B0\n# K1  A1  B1\n# K2  A2  B2\n\nprint(right)\n#     C   D\n# K0  C0  D0\n# K2  C2  D2\n# K3  C3  D3\n\n#依据左右资料集的index进行合并，how='outer',并打印出\nres = pd.merge(left, right, left_index=True, right_index=True, how='outer')\nprint(res)\n#      A    B    C    D\n# K0   A0   B0   C0   D0\n# K1   A1   B1  NaN  NaN\n# K2   A2   B2   C2   D2\n# K3  NaN  NaN   C3   D3\n\n#依据左右资料集的index进行合并，how='inner',并打印出\nres = pd.merge(left, right, left_index=True, right_index=True, how='inner')\nprint(res)\n#     A   B   C   D\n# K0  A0  B0  C0  D0\n# K2  A2  B2  C2  D2\n解决overlapping的问题\nimport pandas as pd\n\n#定义资料集\nboys = pd.DataFrame({'k': ['K0', 'K1', 'K2'], 'age': [1, 2, 3]})\ngirls = pd.DataFrame({'k': ['K0', 'K0', 'K3'], 'age': [4, 5, 6]})\n\n#使用suffixes解决overlapping的问题\nres = pd.merge(boys, girls, on='k', suffixes=['_boy', '_girl'], how='inner')\nprint(res)\n#    age_boy   k  age_girl\n# 0        1  K0         4\n# 1        1  K0         5\n七、plot出图\n这次来学习如何将数据可视化. 首先import我们需要用到的模块，除了 pandas，我们也需要使用 numpy 生成一些数据，这节里使用的 matplotlib 仅仅是用来 show 图片的, 即 plt.show()。\n创建一个Series\n这是一个线性的数据，我们随机生成1000个数据，Series 默认的 index 就是从0开始的整数，但是这里我显式赋值以便让大家看的更清楚\n# -*- coding:utf-8 -*-\n\n\"\"\"\n@author: Corwien\n@file: pd_plot.py\n@time: 18/9/1 10:59\n\"\"\"\n   \nimport pandas as pd #加载模块\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# 随机生成1000个数据\ndata = pd.Series(np.random.randn(1000), index=np.arange(1000))\n\n# print(data)\n# 为了方便观看效果, 我们累加这个数据\ndata.cumsum()\n\n# print \"\\n=======\\n\"\n# print(data)\n\n# pandas 数据可以直接观看其可视化形式\ndata.plot()\n\nplt.show()\n\n数据打印：\n0      1.055920\n1      2.151946\n2      0.376157\n3     -1.279114\n4      0.584658\n5      1.178072\n6      0.873750\n7     -1.039058\n8     -0.892274\n9     -0.532982\n10     0.040962\n\n         ...   \n\n990    0.663714\n991    0.013612\n992   -1.993561\n993    0.238042\n994    0.696388\n995    1.275367\n996   -1.660392\n997   -0.795660\n998    1.062841\n999    0.200333\nLength: 1000, dtype: float64\n\nDataframe 可视化\n我们生成一个1000*4 的DataFrame，并对他们累加\ndata = pd.DataFrame(\n    np.random.randn(1000,4),\n    index=np.arange(1000),\n    columns=list(\"ABCD\")\n    )\ndata.cumsum()\ndata.plot()\nplt.show()\n结果打印：\n            A         B         C         D\n0   -0.240516  1.689101  2.195897 -1.011582\n1   -1.067106  1.908657 -0.534270  0.016602\n2   -0.239367  0.033567 -0.782701  0.746416\n3   -0.104149 -0.756916 -0.984102  0.126436\n4   -3.228259 -0.380957 -0.129879  0.738176\n5    0.454551 -0.213664  0.200234  0.920599\n6   -0.931042  0.731300 -1.424736  0.185456\n7    1.823043  0.333958 -0.375364  0.371867\n8   -1.407975  0.209401 -1.387218 -0.236411\n9   -0.286918 -0.599334 -1.266337 -0.707990\n10  -0.205903 -0.942891  1.650707  0.467071\n\n..        ...       ...       ...       ...\n\n994 -1.143698  1.159974 -0.433339 -0.705888\n995  0.507159 -0.295003  0.534483 -0.925546\n996  1.470531 -0.484951  0.087811 -1.393423\n997 -0.225130  0.717332 -0.117851 -0.849506\n998 -1.078925 -0.688264 -0.133773 -0.803970\n999 -0.589185  0.649868  1.436989 -0.553600\n\n[1000 rows x 4 columns]\n\n这个就是我们刚刚生成的4个column`的数据，因为有4组数据，所以4组数据会分别plot出来。plot 可以指定很多参数，具体的用法大家可以自己查一下这里\n除了plot，我经常会用到还有scatter，这个会显示散点图，首先给大家说一下在 pandas 中有多少种方法\n\nbar\nhist\nbox\node\narea\nscatter\nhexbin\n\n但是我们今天不会一一介绍，主要说一下 plot 和 scatter. 因为scatter只有x，y两个属性，我们我们就可以分别给x, y指定数据\nax = data.plot.scatter(x='A',y='B',color='DarkBlue',label='Class1')\n然后我们在可以再画一个在同一个ax上面，选择不一样的数据列，不同的 color 和 label\n# 将之下这个 data 画在上一个 ax 上面\ndata.plot.scatter(x='A',y='C',color='LightGreen',label='Class2',ax=ax)\nplt.show()\n下面就是我plot出来的图片\n\n这就是我们今天讲的两种呈现方式，一种是线性的方式，一种是散点图。\n\n                ", "mainLikeNum": ["9 "], "mainBookmarkNum": "7"}