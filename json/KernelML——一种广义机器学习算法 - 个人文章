{"title": "KernelML——一种广义机器学习算法 - 个人文章 ", "index": "机器学习,python", "content": "摘要： 通过阅读本文，我们可以了解一个名为KernelML的Python软件包，该软件包旨在为分析师和数据科学家提供针对于复杂损失函数和非线性系数的广义机器学习算法。\n最近，我创造了一个自定义的“粒子优化算法”，并制作了一个叫做KernelML的Python包。创造这种算法是为了给数据分析师和数据科学家提供一个针对复杂损失函数和非线性系数的广义机器学习算法。优化算法通过简单机器学习和概率模拟的组合，使用损失函数、输入和输出矩阵以及随机采样器（可选）来寻找最优参数。目前，我在研究更多功能，希望项目最终能够开源。\n**\n使用示例：\n**\n以经纬度坐标的聚类问题作为范例，K均值的聚类方法使用欧氏距离来区别观测值。但是，经纬度坐标间的欧氏距离并不能直接映射为Haversine距离。这意味着，如果将0和1之间的坐标进行归一化，则距离无法精确的在聚类模型中得以表示。最好的解决方案就是找到坐标投影，使该点质心的Haversine距离等于欧式空间中的投影距离。\n\n以上坐标变换在聚类解决方案中的缩放和使用，将相对于中心的Haversine距离转化为欧式距离。\n另一个更简单的问题是找到非线性系数的最优值，即最小二乘线性模型中的幂变换。这样做的原因很简单，整数的幂变换不容易得到最佳拟合变换。通过将幂变换转换成为任意实数，准确性大大提升，模型也能更好地验证数据。\n为了更好地解释幂变换的含义，上图提供了该模型的公式。\n算法：\nKernelML的核心思想很简单。在模型中使用参数更新历史记录来决定如何更新下一个参数集。在末端使用模型导致偏差变化问题，具体地说，参数偏差在每次迭代更新中变大。这个问题可以在每次迭代后解决，需要在最佳参数集周围进行蒙特卡洛模拟。\n收敛问题：\n该模型在每次迭代后保存最佳参数和用户定义的损失，同时还记录了所有参数的历史更新记录。但问题是如何使用这些数据来定义收敛。一个可能的解决方案的代码如下\nconvergence = (best_parameter-np.mean(param_by_iter[-10:,:],axis=0))/(np.std(param_by_iter[-10:,:],axis=0))\nif np.all(np.abs(convergence)<1):\nprint('converged')\nbreak\n\n该公式使用最后10个参数和最佳参数创建Z分数。如果所有参数的Z分数小于1，那么该算法可以说已经收敛。当存在理论上最好的参数集时，这种收敛解决方案效果非常好。下面的例子是在使用该算法进行聚类时所遇到的问题\n\n图1：使用KernelML，2-D多变量正态分布（蓝色），聚类解决方案（其他颜色）\n我们不会深究聚类方案的质量，因为显然它不代表数据。聚类解决方案使多维直方图与6个正态分布的平均概率之间的差异达到最小，每个轴都是3。在这里，分布可以很容易地“交换”坐标点，这可能会增加收敛时间。也许有人会问，为什么不采用3-多元正态分布？模拟分布参数存在问题，因为一些参数具有约束条件。协方差矩阵需要是正的、半确定的，并且需要存在逆矩阵。正态分布中的标准差必须为正。该模型中使用的解决方案通过对每个单独参数进行自定义模拟来整合对参数的约束。\n为什么采用KernelML而不是最大期望？\n非正态分布（如泊松）可能不适合多元正态聚类解决方案中的其他维度。另外，随着维数的增加，一个聚类是具有非零值特征的唯一聚类的概率也增加。这对EM算法提出了一个问题，因为它试图更新协方差矩阵。唯一特征和其他维度之间的协方差将为零，或者另一个聚类接受具有此非零值的观察值的概率为零。\n概率优化算法的优点：\n参数的概率模拟与完全参数化的模型相比具有一些很大的好处。首先，正则化包含在先前的随机模拟中。例如，如果先前对参数的随机模拟在-1和1之间，则可以推论参数将以同样重要的方式更新。此外，在算法收敛的同时，每次迭代都会产生一组参数，以全局或局部最小损耗为样本进行采样。这有两个主要的好处：1）可以为每个参数建立置信区间；2）每个参数集的预测输出可以是统一模型中的有用特征。\n本文由阿里云云栖社区组织翻译。\n文章原标题《Kernel Machine Learning (KernelML) - Generalized Machine Learning Algorithm》，译者：Anchor C.，审校：虎说八道。\n原文链接\n本文为云栖社区原创内容，未经允许不得转载。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "1"}