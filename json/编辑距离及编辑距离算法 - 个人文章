{"title": "编辑距离及编辑距离算法 - 个人文章 ", "index": "java,python", "content": "无意间看到了有人问编辑距离算法，当时对这个概念很陌生，也就去学习了下，做下总结，记录下，好记性不如烂笔头。\n编辑距离（Edit Distance）：又称Levenshtein距离，是指两个字串之间，由一个转成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符，用数据库的说法就是改、增、删；一般来说就是字符串编辑距离离越小，两个串的相似度越大。\n举个例子：S1=“eeba”  S2=\"abac\"  我们可以按照这样的步骤转变：\n(1) 将S1中的第一个e变成a;\n(2) 删除S1中的第二个e;\n(3)在S1中最后添加一个c; 那么S1到S2的编辑路径就等于3。\n当然，这种变换并不是唯一的，但如果3是所有变换中最小值的话。那么我们就可以说S1和S2的编辑距离等于3了。\n听说这个概念是由俄罗斯科学家Vladimir Levenshtein在1965年提出这个概念\n概念的东西，说多了也只是理论，还是上代码吧！\n先来份java的吧，这是我工作时用的第一个编程语言：\npublicclassStringSimilar{\n\n//编辑距离求串相似度\n\npublicdoublegetStringSimilar(Strings1,Strings2){\n\ndouble d[][];//matrix\n\nint n;//lengthofs\n\nint m;//lengthoft\n\nint i;//iteratesthroughs\n\nint j;//iteratesthrought\n\nchar s_i;//ithcharacterofs\n\nchar t_j;//jthcharacteroft\n\ndouble cost;//cost\n\n//第1步\n\nn=s1.length();\n\nm=s2.length();\n\nif(n==0){\n\nreturn m;\n\n}\n\nif(m==0){\n\nreturn n;\n\n}\n\nd=new double[n+1][m+1];\n\n//第2步\n\nfor(i=0;i<=n;i++){\n\nd[i][0]=i;\n\n}\n\nfor(j=0;j<=m;j++){\n\nd[0][j]=j;\n\n}\n\n//第3步\n\nfor(i=1;i<=n;i++){\n\ns_i=s1.charAt(i-1);\n\n//第4步\n\nfor(j=1;j<=m;j++){\n\nt_j=s2.charAt(j-1);\n\n//第5步\n\nif(s_i==t_j){cost=0;}else{cost=1;}\n\n//第6步\n\nd[i][j]=Minimum(d[i-1][j]+1,d[i][j-1]+1,d[i-1][j-1]+cost);\n\n}\n\n}\n\n//第7步\n\nreturn d[n][m];\n\n}\n\n//求最小值\n\nprivatedoubleMinimum(doublea,doubleb,doublec){\n\n        double mi;\n\n         mi=a;\n\n        if(b<mi){mi=b;}\n\n        if(c<mi){mi=c;}\n\n return mi;}\n\n}\n\n\n在来一份我最近学习的Python的\n#!/user/bin/env python\n\n# -*- coding: utf-8 -*-\n\nclass arithmetic():\n\n    def __init__(self):\n\n        pass\n\n        def levenshtein(self,first,second):\n\n        if len(first) > len(second):\n\n                first,second = second,first\n\n        if len(first) == 0:\n\n                return len(second)\n\n        if len(second) == 0:\n\n                return len(first)\n\n        first_length = len(first) + 1\n\n        second_length = len(second) + 1\n\n        distance_matrix = [range(second_length) for x in range(first_length)]\n\n        for i in range(1,first_length):\n\n            for j in range(1,second_length):\n\n                 deletion = distance_matrix[i-1][j] + 1\n\n                 insertion = distance_matrix[i][j-1] + 1\n\n                 substitution = distance_matrix[i-1][j-1]\n\n                 if first[i-1] != second[j-1]:\n\n                     substitution += 1\n\n                  distance_matrix[i][j] = min(insertion,deletion,substitution)\n\n         print distance_matrix\n\n         return distance_matrix[first_length-1][second_length-1]\n\nif __name__ == \"__main__\":\n\n    arith = arithmetic()\n\n    print arith.levenshtein( 'latino','larou'  )\n吐槽下：Python语法缩进真是蛋疼，用4个空格缩进来确定。累的很啊\n我的本行iOS的我就不上代码了，代码风格太菜同行到笑话就不好了。可以看出是动态规划解决编辑距离，明白算法原理写出算法函数方法还是不难的；大概的公式也就是：例S1=“eeba”  S2=\"abac\"\n如果i=0且j=0        edit(0, 0)=1\n\n如果i=0且j>0        edit(0, j )=edit(0, j-1)+1\n\n如果i>0且j=0        edit( i, 0 )=edit(i-1, 0)+1\n\n如果i>0且j>0        edit(i, j)=min(edit(i-1, j)+1, edit(i,j-1)+1, edit(i-1,j-1)+f(i , j) )\n这就是将长字符串间的编辑距离问题一步一步转换成短字符串间的编辑距离问题，直至只有1个字符的串间编辑距离为1\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}