{"title": "Python爬虫利器：Beautiful Soup的使用（二） - 个人文章 ", "index": "网页爬虫,python", "content": "上一篇文章介绍了 BeautifulSoup 的安装以及基本对象类型。\n本次介绍使用 bs4 对 HTML 文档树的遍历。\n先把本文用到的例子贴上：\nstr = \"\"\"\n<!DOCTYPE html>\n<html>\n<head><title>bs4 test</title></head>\n<body>\n    <h1>bs4 test</h1>\n    <div>\n        <ul>\n            <li><a>PHP</a></li>\n            <li><a>Python</a></li>\n            <li><a>Golang</a></li>\n        </ul>\n    </div>\n    <p><span>a</span><i>b</i><em></em></p>\n</body>\n</html>\n\"\"\"\n\n\n文档树的遍历：\n文档树的遍历包括以下四部分：\n\n子节点\n父节点\n兄弟节点\n回退和前进\n\n一、子节点\n一个标签可能包含多个字符串或者其他标签，这些标签都属于子节点。要获取子节点,首先需要得到一个 Tag 对象:\n获取一个 Tag 对象最简单的方式是用 bs4 对象点上要获取的标签的名字,同时支持链式调用。\nbs4 = BeautifulSoup(str, \"lxml\")\ndiv_tag = bs4.div\nul_tag = bs4.div.ul\n\n.contents ：\ntag 对象的 .contents 属性可以将 tag 的子节点以列表的方式输出,不包含孙节点:\nul_tag.contents\n# ['\\n', <li><a>PHP</a></li>, '\\n', <li><a>Python</a></li>, '\\n', <li><a>Golang</a></li>, '\\n']\n\n字符串没有 .contents 属性,因为字符串没有子节点。\n.children：\n.children 生成器，可以对 tag 的直接子节点进行循环:\nfor child in ul_tag.children:\n    print(child)\n# <li><a>PHP</a></li> <li><a>Python</a></li> <li><a>Golang</a></li>\n\n.descendants：\n.descendants 属性可以对所有 tag 的子孙节点进行递归循环:\nfor child in ul_tag.descendants:\n    print(child)\n\n.string：\n如果 tag 只有一个 NavigableString 类型子节点,那么这个 tag 可以使用 .string 得到子节点。\ntitle_tag = bs4.title \nprint(title_tag.string)  # bs4 test\n\n如果一个 tag 仅有一个子节点,那么这个 tag 也可以使用 .string 方法,输出结果与当前唯一子节点（也就是 title 节点）的 .string 结果相同。\nhead_tag = bs4.head\nprint(head_tag.string)  # bs4 test\n\n如果 tag 包含了多个子节点,tag 就无法确定 .string 方法应该调用哪个子节点的内容,所以输出结果是 None：\nprint(div_tag.string) # None\n\n.strings 和 stripped_strings：\n对于上边 tag 包含了多个子节点的问题，可以使用 .strings 来循环获取：\nfor str in div_tag.strings:\n    print(str)\n# PHP   Python   Golang\n\n.stripped_strings 可以去除多余空白内容。\n二、父节点 \n.parent：\n.parent 属性来获取某个标签或字符串的父节点，比如：\nprint(title_tag.parent) # <head><title>bs4 test</title></head>\nh1_tag = bs4.h1\nprint(h1_tag.string.parent) # <h1>bs4 test</h1>\n\n.parents：\n.parents 属性可以递归得到元素的所有父辈节点。\nfor p in h1_tag.parents:\n    print(p.name)\n# body   html   [document]\n\n三、兄弟节点\n首先先看一下例子中的这一行：\n#<p><span>a</span><i>b</i><em>c</em></p>\n\np_tag = bs4.p\nprint(p_tag.prettify())\n#<p>\n# <span>\n#  a\n# </span>\n# <i>\n#  b\n# </i>\n# <em>\n#  c\n# </em>\n#</p>\n\n\n<span><i><em>都是<p>的子节点，所以这三个可以被称为兄弟节点。\n\n\n.next_sibling 和 .previous_sibling：\n通过以上两个属性可以查询兄弟节点。\nprint(p_tag.i.next_sibling) # <em>c</em>\nprint(p_tag.i.previous_sibling) # <span>a</span>\n\n要注意的点：\n在这里<span>没有 previous_sibling 属性，因为它是同级节点中的第一个。相反，<em>没有 next_sibling 属性。\n字符串“a,b,c”不是兄弟节点,因为它们的父节点不同。\n由于我们上边的例子是写的一行，在实际中 .next_sibling 和 .previous_sibling 属性通常是字符串或空白。\n如果示例是如下方式则 .next_sibling 和 .previous_sibling 获取到的是空白。\n<p>\n    <span>a</span>\n    <i>b</i>\n    <em>c</em>\n</p>\n\n\n.next_siblings 和 .previous_siblings：\n.next_siblings 和 .previous_siblings 属性可以对当前节点的兄弟节点迭代输出。\nfor sibling in p_tag.span.next_siblings:\n    print(repr(sibling))\n#'\\n'\n#<i>b</i>\n#'\\n'\n#<em>c</em>\n#'\\n'\n\nfor prev in p_tag.em.previous_siblings:\n    print(repr(prev))\n#'\\n'\n#<i>b</i>\n#'\\n'\n#<span>a</span>\n#'\\n'\n\n\n四、回退和前进\nHTML解析器把文档字符串转换成一连串的事件: 打开<html>标签 -> 打开<head>标签 -> 打开<title>标签 -> 添加一段字符串 -> 关闭<title>标签 ...Beautiful Soup提供了重现解析器初始化过程的方法。\n.next_element 和 .previous_element：\n.next_element 属性指向解析过程中下一个被解析的对象(字符串或tag)。\nprint(h1_tag.next_element) # bs4 test因为这个结果是在<h1>标签被解析之后的解析内容，所以输出字符串。\nprint(h1_tag.next_element.previous_element) # <h1>bs4 test</h1>\n\nh1_tag.next_element 输出的是“bs4 test”字符串，因为 .previous_element 指向当前被解析的对象的前一个解析对象，所以这里输出<h1>bs4 test</h1>。\n.next_elements 和 .previous_elements：\n通过 .next_elements 和 .previous_elements 的迭代器可以向前或向后访问文档的解析内容。\nstr2 = \"<p><span>a</span><i>b</i><em>c</em></p>\"\nbs42 = BeautifulSoup(str2, \"lxml\")\nfor element in bs42.p.next_elements:\n    print(element)\n# <span>a</span>\n# a\n# <i>b</i>\n# b\n# <em>c</em>\n# c\n\n\n以上就是本文总结的使用 Beautiful Soup 对文档遍历的相关内容。\n有问题欢迎指出。关注我解锁更多 Python 干货哦！\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "0"}