{"title": "如何理解yield--Python提高班 - 扑克 ", "index": "python", "content": "要想理解yield, 需要先理解generators(生成器), 要想理解generators, 需要先理解iterables(迭代器)\n\niterables\n\n先看这段代码:\n\n>>> mylist = [1, 2, 3]\n>>> for i in mylist:\n...    print(i)\n1\n2\n3\n>>> mylist2 = [x for x in range(3)]\n>>> for i in mylist2:\n...     print i\n...\n0\n1\n2\n\n\n这段代码的意思是list(列表)在python中是可以迭代的, 如果你需要一个接一个的访问一个数据集合, 大多数的时候使用一个for xx in yy这种方式, 那么这里的yy就是一个可以迭代访问的数据集合, 很明显, list, tuple, string, file这些都是迭代器\n\niterables是保存在内存中的, 你可以随便访问他们, 比如上面的mylist,mylist2\n\ngenerators\n\n再看这一段\n\n>>> mygenerator = (x*x for x in range(3))\n>>> for i in mygenerator:\n...    print(i)\n0\n1\n4\n>>> mygenerator\n<generator object <genexpr> at 0x10d35eaa0>\n\n\n这段代码中mygenerator就是一个迭代器,  跟上文的mylist2生成方式有点点区别, []改成了(), 从使用上来说, generators和iterables都是类似for in的这种方式\n\n但是 : generators不是保存在内存中的, 而是惰性加载的, 也就是你用到它的时候, 它才临时去计算, 只能使用一次for in, 比如上面的mygenerator, 计算0*0并返回之后就不在保留了, 继续计算1*1\n\n适用场景: 当需要迭代访问一组量非常大的数据集的时候, generator是非常有用的, 因为它计算完了前面的数据然后就计算后面, 并不在内存里保留所有的数据, 这样就不至于内存爆掉\n\nyield\n\n理解了generator之后, 再来看yield就非常好理解了, 可以把yield当成return看待\n\n>>> def createGenerator():\n...    mylist = range(3)\n...    for i in mylist:\n...        yield i*i\n...\n>>> mygenerator = createGenerator() # 创建一个生成器, 这里createGenerator内的代码并没有运行\n>>> print(mygenerator) # 生成器就是一个object\n<generator object createGenerator at 0xb7555c34>\n>>>\n>>> for i in mygenerator: # 这里createGenerator内的代码才开始运行\n...     print(i)\n0\n1\n4\n\n\n上面的代码中当调用createGenerator()的时候, 其实方法内的代码并没有运行, 而在for in循环访问的时候, 才开始从头计算, 当运行到yield的时候返回第一个值, 然后就停下来, 当再次请求数据的时候继续运算直到再次碰到yield... 直到没有值可以返回\n\n参考: The Python yield keyword explained\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "10"}