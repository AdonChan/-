{"title": "通读Python官方文档之Threading - 通读Python官方文档 ", "index": "thread,python", "content": "Python的threading模块松散地基于Java的threading模块。但现在线程没有优先级，没有线程组，不能被销毁、停止、暂停、开始和打断。 Java Thread类的静态方法，被移植成了模块方法。\nmain thread: 运行python程序的线程\ndaemon thread 守护线程，如果守护线程之外的线程都结束了。守护线程也会结束，并强行终止整个程序。不要在守护进程中进行资源相关操作。会导致资源不能正确的释放。在非守护进程中使用Event。\nThread 类\n(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None)\ngroup: 为以后的ThreadGroup类预留\ntarget: 被执行的对象，由run()方法执行\nargs: target对象使用的参数\ndaemon: 是否为守护进程\n\nstart()\n\n每个thread 对象都只能被调用1次start()\n\nrun()\n\n如果创建Thread的子类，重写该方法。负责执行target参数传来的可执行对象。\n\njoin()\n\n阻塞线程直到结束。\n\nGIL\n在CPython中，由于GIL的存在，Python每次只能执行一个线程。如果要充分利用多核机器的计算资源需要使用multiprocessing或者是concurrent.futures.ProcessPollExecutor。 但，但如果你想要很多I/O相关的并发操作，threding仍然是一个很好的选择 。？因为系统自动实现了线程的上下文切换。\nfrom threading import Thread\nimport requests\n\nurl = 'http://www.baidu.com'\n\nurls = [url]*20\nthreads = []\n\nfor url in urls:\n    t = Thread(target=requests.get, args=(url, ))\n    t.start()\n    threads.append(t)\n\nfor t in threads:\n    t.join()\n锁(Lock)对象\n原始锁（primitive lock），当它锁住的时候，它是一种不属于任何一个线程的同步原语（synchronization primitive）。 在Python中，他是目前可用的最底层的同步原语，由_thread模块提供。\n一个原始锁有两个状态：locked 和unlocked。锁创建时，处于unlocked状态。 锁由两个基本方法：acquire()和release()。\n当处于unlocked状态时，acquire(()方法可以将状态变为locked，并立即返回。当处于locked状态时，acquire()会阻塞直至另一个线程调用了release()使改锁解锁，然后acquire()将锁上锁，并返回。\nrelease()方法只能在锁locked时别调用，并释放锁。否则会抛出RuntimeError错误。\n如果有多个 acquire()在等待解锁，则不确定哪一个哪一个会被触发。\nclass threading.Lock\n如果一个线程acquire了一个锁，那么后续获取它的线程都会被阻塞，直至锁被释放。任何线程都可以释放锁。\nLock是一个工厂函数，返回当前平台下最高效的concrete Lock类的实例。\nLock支持上下文管理方法（context management protocol），也就是with 语句。在存在竞态条件（race condition）的时候，要使用锁。比如多线程共同操作某个数据。\n# 摘自python Cookbook\nimport threading\n\nclass SharedCounter:\n\n    def __init__(self, init_value=0):\n        self._value  = init_value\n        self._value_lock = threading.Lock()\n    \n    def incr(self, delta=1):\n        # 在这里使用了with 语句，创建一个锁，增加值，释放锁。\n        with self._value_lock:\n            self._value += 1\n\nRLock对象\n可重入锁（reentrant lock）。感觉是一个锁中锁，就是可以递归的锁。等见到具体的应用例子再写。\nCondition对象\ncondition变量总是与某种锁相关，锁可以是传过来的，也可以通过默认设置创建。如果有多个  condition对象需要共享一个锁时，传递一个锁是非常有用的。锁是condition对象的一部分，你不用刻意的跟踪它。\nTimer对象\nTimer是Thread的子类，所以也要接受function参数，也可以被start()。 它的run()函数被重写为先event.wait(interval)，再启动function。\nBarrier对象\n实现某些服务的共进退。\nthreading.Barrier(parties, action=None, timeout=None)\n设置n=parties个线程，当n个barrier.wait()被调用后，所有这些调用的阻塞被同时解除，执行action\n感觉Barrier可以实现很多复杂的功能。\n\n参考资料：\nPython threading\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}