{"title": "python 多继承 - 个人文章 ", "index": "python", "content": "读django类视图代码时，遇到这样一个问题：\nclass A(object):\n    def __init__(self):\n        pass\n\n    def get_data(self, **kwargs):\n        print \"enter A\"\n        if \"A\" not in kwargs:\n            kwargs['A'] = \"value A\"\n        print \"leave A\"\n        return kwargs\n\n\nclass B(A):\n    def get_data(self, **kwargs):\n        print \"enter B\"\n        if \"B\" not in kwargs:\n            kwargs['B'] = \"value B\"\n        print \"leave B\"\n        return super(B, self).get_data(**kwargs)\n\n\nclass C(A):\n    def get_data(self, **kwargs):\n        print \"enter C\"\n        if \"C\" not in kwargs:\n            kwargs['C'] = \"value C\"\n        print \"leave C\"\n        return super(C, self).get_data(**kwargs)\n\n\nclass D(C, B):\n    def use_data(self):\n        print \"enter D\"\n        data = self.get_data(D=\"value D\")\n        print \"data value:\",data\n        print \"leave D\"\n        return\n\nif __name__ ==\"__main__\":\n    d = D()\n    d.use_data()\n这套程序中，D的use_data函数中的data的值应该是什么，这里的运行结果是：\nenter D\nenter C\nleave C\nenter B\nleave B\nenter A\nleave A\ndata value: {'A': 'value A', 'C': 'value C', 'B': 'value B', 'D': 'value D'}\nleave D\n需要注意的是：这里的A必须继承object，如果A不继承object，程序变成这样：\nclass A():\n    def __init__(self):\n        pass\n\n    def get_data(self, **kwargs):\n        print \"enter A\"\n        if \"A\" not in kwargs:\n            kwargs['A'] = \"value A\"\n        print \"leave A\"\n        return kwargs\n\n\nclass B(A):\n    def get_data(self, **kwargs):\n        print \"enter B\"\n        if \"B\" not in kwargs:\n            kwargs['B'] = \"value B\"\n        print \"leave B\"\n        return super(B, self).get_data(**kwargs)\n\n\nclass C(A):\n    def get_data(self, **kwargs):\n        print \"enter C\"\n        if \"C\" not in kwargs:\n            kwargs['C'] = \"value C\"\n        print \"leave C\"\n        return super(C, self).get_data(**kwargs)\n\n\nclass D(C, B):\n    def use_data(self):\n        print \"enter D\"\n        data = self.get_data(D=\"value D\")\n        print \"data value:\", data\n        print \"leave D\"\n        return\n\nif __name__ ==\"__main__\":\n    d = D()\n    d.use_data()\n运行结果会报错：\n/System/Library/Frameworks/Python.framework/Versions/2.7/bin/python2.7 /Users/apple/mygit/kd/demo/class_inheritance_example.py\nTraceback (most recent call last):\nenter D\n  File \"/Users/apple/mygit/kd/demo/class_inheritance_example.py\", line 41, in <module>\nenter C\n    d.use_data()\nleave C\n  File \"/Users/apple/mygit/kd/demo/class_inheritance_example.py\", line 34, in use_data\n    data = self.get_data(D=\"value D\")\n  File \"/Users/apple/mygit/kd/demo/class_inheritance_example.py\", line 28, in get_data\n    return super(C, self).get_data(**kwargs)\nTypeError: must be type, not classobj\n这是python继承问题，通过问度娘，找到好多文章，这里按自己的方式记录整理，以备后续使用。\npython实现继承的方法\npython可以采用两种方法实现继承。\n方法1：使用父类名，例：\n class A:\n  def __init__(self):\n   print \"enter A\"\n   print \"leave A\"\n\n class B(A):\n  def __init__(self):\n   print \"enter B\"\n   A.__init__(self)\n   print \"leave B\"\n方法2，使用super，例：\n class A:\n  def __init__(self):\n   print \"enter A\"\n   print \"leave A\"\n\n class B(A):\n  def __init__(self):\n   print \"enter B\"\n   super(C,self).__init__()\n   print \"leave B\"\n方法1是python2.2之前的版本实现继承采用的方法。该方法的问题在于如果有多个继承，当父类更改名字时，所有的子类都要进行相应修改。因此，python2.2之后的版本使用方法2实现继承。\nsuper\nsuper是MRO中的一个类。MRO全称Method Resolution Order，代表类的继承顺序。\n关于super，需要注意的一点是它是一个访问排序器，而不是父类。\n计划2017年8月底之前翻译完成对super讲解最透彻的一篇文章是Raymond Hettinger的一篇文章https://rhettinger.wordpress....。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}