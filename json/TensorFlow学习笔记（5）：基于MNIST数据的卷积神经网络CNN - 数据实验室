{"title": "TensorFlow学习笔记（5）：基于MNIST数据的卷积神经网络CNN - 数据实验室 ", "index": "tensorflow,python,深度学习", "content": "前言\n本文基于TensorFlow官网的Tutorial写成。输入数据是MNIST，全称是Modified National Institute of Standards and Technology，是一组由这个机构搜集的手写数字扫描文件和每个文件对应标签的数据集，经过一定的修改使其适合机器学习算法读取。这个数据集可以从牛的不行的Yann LeCun教授的网站获取。\n本系列文章的这一篇对这份数据集使用了softmax regression，在测试集上取得了接近92%的准确率。本文将使用卷积神经网络以获得更高的准确率。关于CNN的理论知识，可以参考这篇文章\n代码\n#!/usr/bin/env python\n# -*- coding=utf-8 -*-\n# @author: 陈水平\n# @date: 2017-02-04\n# @description: implement a CNN model upon MNIST handwritten digits\n# @ref: http://yann.lecun.com/exdb/mnist/\n\nimport gzip\nimport struct\nimport numpy as np\nfrom sklearn import preprocessing\nimport tensorflow as tf\n\n# MNIST data is stored in binary format, \n# and we transform them into numpy ndarray objects by the following two utility functions\ndef read_image(file_name):\n    with gzip.open(file_name, 'rb') as f:\n        buf = f.read()\n        index = 0\n        magic, images, rows, columns = struct.unpack_from('>IIII' , buf , index)\n        index += struct.calcsize('>IIII')\n\n        image_size = '>' + str(images*rows*columns) + 'B'\n        ims = struct.unpack_from(image_size, buf, index)\n        \n        im_array = np.array(ims).reshape(images, rows, columns)\n        return im_array\n\ndef read_label(file_name):\n    with gzip.open(file_name, 'rb') as f:\n        buf = f.read()\n        index = 0\n        magic, labels = struct.unpack_from('>II', buf, index)\n        index += struct.calcsize('>II')\n        \n        label_size = '>' + str(labels) + 'B'\n        labels = struct.unpack_from(label_size, buf, index)\n\n        label_array = np.array(labels)\n        return label_array\n\nprint \"Start processing MNIST handwritten digits data...\"\ntrain_x_data = read_image(\"MNIST_data/train-images-idx3-ubyte.gz\")  # shape: 60000x28x28\ntrain_x_data = train_x_data.reshape(train_x_data.shape[0], train_x_data.shape[1], train_x_data.shape[2], 1).astype(np.float32)\ntrain_y_data = read_label(\"MNIST_data/train-labels-idx1-ubyte.gz\")  \ntest_x_data = read_image(\"MNIST_data/t10k-images-idx3-ubyte.gz\")  # shape: 10000x28x28\ntest_x_data = test_x_data.reshape(test_x_data.shape[0], test_x_data.shape[1], test_x_data.shape[2], 1).astype(np.float32)\ntest_y_data = read_label(\"MNIST_data/t10k-labels-idx1-ubyte.gz\")\n\ntrain_x_minmax = train_x_data / 255.0\ntest_x_minmax = test_x_data / 255.0\n\n# Of course you can also use the utility function to read in MNIST provided by tensorflow\n# from tensorflow.examples.tutorials.mnist import input_data\n# mnist = input_data.read_data_sets(\"MNIST_data/\", one_hot=False)\n# train_x_minmax = mnist.train.images\n# train_y_data = mnist.train.labels\n# test_x_minmax = mnist.test.images\n# test_y_data = mnist.test.labels\n\n# Reformat y into one-hot encoding style\nlb = preprocessing.LabelBinarizer()\nlb.fit(train_y_data)\ntrain_y_data_trans = lb.transform(train_y_data)\ntest_y_data_trans = lb.transform(test_y_data)\n\nprint \"Start evaluating CNN model by tensorflow...\"\n\n# Model input\nx = tf.placeholder(tf.float32, shape=[None, 28, 28, 1])\ny_ = tf.placeholder(tf.float32, [None, 10])\n\n# Weight initialization\ndef weight_variable(shape):\n    initial = tf.truncated_normal(shape, stddev=0.1)\n    return tf.Variable(initial)\n\ndef bias_variable(shape):\n    initial = tf.constant(0.1, shape=shape)\n    return tf.Variable(initial)\n\n# Convolution and Pooling\ndef conv2d(x, W):\n    # `tf.nn.conv2d()` computes a 2-D convolution given 4-D `input` and `filter` tensors\n    # input tensor shape `[batch, in_height, in_width, in_channels]`, batch is number of observation \n    # filter tensor shape `[filter_height, filter_width, in_channels, out_channels]`\n    # strides: the stride of the sliding window for each dimension of input.\n    # padding: 'SAME' or 'VALID', determine the type of padding algorithm to use\n    return tf.nn.conv2d(x, W, strides=[1, 1, 1, 1], padding='SAME')\n\ndef max_pool_2x2(x):\n    # `tf.nn.max_pool` performs the max pooling on the input\n    #  ksize: the size of the window for each dimension of the input tensor.\n    return tf.nn.max_pool(x, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding='SAME')\n\n\n# First convolutional layer\n# Convolution: compute 32 features for each 5x5 patch\n# Max pooling: reduce image size to 14x14.\nW_conv1 = weight_variable([5, 5, 1, 32])\nb_conv1 = bias_variable([32])\n\nh_conv1 = tf.nn.relu(conv2d(x,  W_conv1) + b_conv1)\nh_pool1 = max_pool_2x2(h_conv1)\n\n# Second convolutional layer\n# Convolution: compute 64 features for each 5x5 patch\n# Max pooling: reduce image size to 7x7\nW_conv2 = weight_variable([5, 5, 32, 64])\nb_conv2 = bias_variable([64])\n\nh_conv2 = tf.nn.relu(conv2d(h_pool1, W_conv2) + b_conv2)\nh_pool2 = max_pool_2x2(h_conv2)\n\n# Densely connected layer\n# Fully-conected layer with 1024 neurons\nW_fc1 = weight_variable([7 * 7 * 64, 1024])\nb_fc1 = bias_variable([1024])\n\nh_pool2_flat = tf.reshape(h_pool2, [-1, 7*7*64])\nh_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1)\n\n# Dropout\n# To reduce overfitting, we apply dropout before the readout layer.\nkeep_prob = tf.placeholder(tf.float32)\nh_fc1_drop = tf.nn.dropout(h_fc1, keep_prob)\n\n# Readout layer\nW_fc2 = weight_variable([1024, 10])\nb_fc2 = bias_variable([10])\n\ny_conv = tf.matmul(h_fc1_drop, W_fc2) + b_fc2\n\n# Train and evaluate\nloss = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(y_conv, y_))\n# y = tf.nn.softmax(y_conv)\n# loss = tf.reduce_mean(-tf.reduce_sum(y_ * tf.log(y), reduction_indices=[1]))\noptimizer = tf.train.AdamOptimizer(1e-4)\n# optimizer = tf.train.GradientDescentOptimizer(1e-4)\ntrain = optimizer.minimize(loss)\n\ncorrect_prediction = tf.equal(tf.argmax(y_conv, 1), tf.argmax(y_, 1))\naccuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))\n\ninit = tf.initialize_all_variables()\nsess = tf.Session()\nsess.run(init)\n\nfor step in range(20000):\n    sample_index = np.random.choice(train_x_minmax.shape[0], 50)\n    batch_xs = train_x_minmax[sample_index, :]\n    batch_ys = train_y_data_trans[sample_index, :]\n    if step % 100 == 0:\n        train_accuracy = sess.run(accuracy, feed_dict={\n            x: batch_xs, y_: batch_ys, keep_prob: 1.0})\n        print \"step %d, training accuracy %g\" % (step, train_accuracy)\n    sess.run(train, feed_dict={x: batch_xs, y_: batch_ys, keep_prob: 0.5})\n\nprint \"test accuracy %g\" % sess.run(accuracy, feed_dict={\n    x: test_x_minmax, y_: test_y_data_trans, keep_prob: 1.0})\n输出如下：\nStart processing MNIST handwritten digits data...\nStart evaluating CNN model by tensorflow...\nstep 0, training accuracy 0.1\nstep 100, training accuracy 0.82\nstep 200, training accuracy 0.92\nstep 300, training accuracy 0.96\nstep 400, training accuracy 0.92\nstep 500, training accuracy 0.92\nstep 600, training accuracy 1\nstep 700, training accuracy 0.94\nstep 800, training accuracy 0.96\nstep 900, training accuracy 0.96\nstep 1000, training accuracy 0.94\nstep 1100, training accuracy 0.98\nstep 1200, training accuracy 0.94\nstep 1300, training accuracy 0.98\nstep 1400, training accuracy 0.96\nstep 1500, training accuracy 1\n...\nstep 15700, training accuracy 1\nstep 15800, training accuracy 0.98\nstep 15900, training accuracy 1\nstep 16000, training accuracy 1\nstep 16100, training accuracy 1\nstep 16200, training accuracy 1\nstep 16300, training accuracy 1\nstep 16400, training accuracy 1\nstep 16500, training accuracy 1\nstep 16600, training accuracy 1\nstep 16700, training accuracy 1\nstep 16800, training accuracy 1\nstep 16900, training accuracy 1\nstep 17000, training accuracy 1\nstep 17100, training accuracy 1\nstep 17200, training accuracy 1\nstep 17300, training accuracy 1\nstep 17400, training accuracy 1\nstep 17500, training accuracy 1\nstep 17600, training accuracy 1\nstep 17700, training accuracy 1\nstep 17800, training accuracy 1\nstep 17900, training accuracy 1\nstep 18000, training accuracy 1\nstep 18100, training accuracy 1\nstep 18200, training accuracy 1\nstep 18300, training accuracy 1\nstep 18400, training accuracy 1\nstep 18500, training accuracy 1\nstep 18600, training accuracy 1\nstep 18700, training accuracy 1\nstep 18800, training accuracy 1\nstep 18900, training accuracy 1\nstep 19000, training accuracy 1\nstep 19100, training accuracy 1\nstep 19200, training accuracy 1\nstep 19300, training accuracy 1\nstep 19400, training accuracy 1\nstep 19500, training accuracy 1\nstep 19600, training accuracy 1\nstep 19700, training accuracy 1\nstep 19800, training accuracy 1\nstep 19900, training accuracy 1\ntest accuracy 0.9929\n思考\n\n参数数量：第一个卷积层5x5x1x32=800个参数，第二个卷积层5x5x32x64=51200个参数，第三个全连接层7x7x64x1024=3211264个参数，第四个输出层1024x10=10240个参数，总量级为330万个参数，单机训练时间约为30分钟。\n\n关于优化算法：随机梯度下降法的learning rate需要逐渐变小，因为随机抽取样本引入了噪音，使得我们在最小点处的随机梯度仍然不为0。对于batch gradient descent不存在这个问题，在最小点损失函数的梯度变为0，因此batch gradient descent可以使用固定的learning rate。为了让learning rate逐渐变小，有以下几种变种算法。\n\nMomentum algorithm accumulates an exponentially decaying moving average of past gradients and continues to move in their direction.\nAdaGrad adapts the learning rates of all model parameters by scaling them inversely proportional to the square root of the sum of all their historical squared values. But the accumulation of squared gradients from the beginning of training can result in a premature and excessive decrease in the effective learning rate.\nRMSProp： AdaGrad is designed to converge rapidly when applied to a convex function. When applied to a non-convex function to train a neural network, the learning trajectory may pass through many different structures and eventually arrive at a region that is a locally convex bowl. AdaGrad shrinks the learning rate according to the entire history of the squared gradient and may have made the learning rate too small before arriving at such a convex structure.RMSProp uses an exponentially decaying average to discard history from the extreme past so that it can converge rapidly after finding a convex bowl, as if it were an instance of the AdaGrad algorithm initialized within that bowl.\nAdam：The name “Adam” derives from the phrase “adaptive moments.” It is a variant on the combination of RMSProp and momentum with a few important distinctions. Adam is generally regarded as being fairly robust to the choice of hyperparameters, though the learning rate sometimes needs to be changed from the suggested default.\n如果将MNIST数据集的AdamOptimizer换成GradientDescentOptimizer，测试集的准确率为0.9296.\n\n\n\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "4"}