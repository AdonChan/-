{"title": "IP 段范围区间或者掩码网段地址解析成实际单个 IP - 个人文章 ", "index": "安全,脚本语言,网络,python", "content": "概述\n两种情况，一种给的是IP 范围，给了一个区间例如参考：http://www.cnblogs.com/amaoxi...\n64.233.196.0-64.233.196.25#将这个范围内的IP 全部解析出来\n另一种情况就是给了一个掩码地址，例如\n192.168.1.0/24\n或者192.168.1.0 255.255.255.0\n#将这个掩码范围内的所有 IP 地址解析输出出来\n第一种情况范围\n#coding:utf-8\n\ndef ip2num(ip):\n    ips = [int(x) for x in ip.split('.')]\n    return ips[0]<< 24 | ips[1]<< 16 | ips[2] << 8 | ips[3]\n\ndef num2ip (num):\n    return '%s.%s.%s.%s' % ((num >> 24) & 0xff, (num >> 16) & 0xff, (num >> 8) & 0xff, (num & 0xff))\n    #return '%s.%s.%s.%s' % ((num & 0xff000000)>>24,(num & 0x00ff0000)>>16,(num & 0x00000ff00)>>8,num & 0x000000ff)\n\n\ndef gen_ip(ip):\n    start ,end = [ip2num(x) for x in ip.split('-')]\n    return [num2ip(num) for num in range(start,end+1) if num & 0xff]\nprint gen_ip(64.233.196.0-64.233.196.25)\n\n输入结果为：\n['64.233.196.22', '64.233.196.23', '64.233.196.24', '64.233.196.25', '64.233.196.26', '64.233.196.27', '64.233.196.28', '64.233.196.29']\n\n利用0xff 把多生成的ip屏蔽掉\n最后一句中 if num & 0xff 作用是过滤掉 最后一段为 0 的IP\n第二种情况掩码\n利用 IPy 这个 python 自带的模块\nimport IPy\nip = IP('192.168.0.0/24') \nprint ip.len() \nfor x in ip: \nprint(x) \n\n反向解析名称、IP类型、IP转换等\n\n>>> ip = IP('192.168.1.20')\n>>> ip.reverseNames()               #反向解析地址格式\n['20.1.168.192.in-addr.arpa.']\n>>> ip.iptype()                     #私网类型\n'PRIVATE'\n>>> IP('8.8.8.8').iptype()          #公网类型\n'PUBLIC'\n>>> IP('8.8.8.8').int()             #转换为整型格式\n134744072\n>>> IP('8.8.8.8').strHex()          #转换为十六进制格式\n'0x8080808'\n>>> IP('8.8.8.8').strBin()          #转换成二进制格式\n'00001000000010000000100000001000'\n>>> print IP('0x8080808')           #十六进制转换为IP格式\n8.8.8.8\n>>> print IP(134744072)             #整型格式转换为IP格式\n8.8.8.8\nIP方法也支持网络地址的转换，例如根据IP和掩码产生网段格式\n\n>>> print (IP('192.168.1.0').make_net('255.255.255.0'))\n192.168.1.0/24\n>>> print (IP('192.168.1.0/255.255.255.0',make_net=True))\n192.168.1.0/24\n>>> print (IP('192.168.1.0-192.168.1.255',make_net=True))\n192.168.1.0/24\n通过strNormal方法指定不同wantprefixlen参数值以定制不同输出类型的网段，输出类型为字符串\n\n>>> IP('192.168.1.0/24').strNormal(0)   #无返回\n'192.168.1.0'\n>>> IP('192.168.1.0/24').strNormal(1)   #prefix格式\n'192.168.1.0/24'\n>>> IP('192.168.1.0/24').strNormal(2)   #decimalnetmask格式\n'192.168.1.0/255.255.255.0'\n>>> IP('192.168.1.0/24').strNormal(3)   #lastIP格式\n'192.168.1.0-192.168.1.255'\n\nps：\n使用python将IP段范围转换成CIDR\n因为最近在整理用于某些工具使用的IP段，像一些IP范围如：64.233.56.37-64.233.56.215，某些软件不支持，只支持像：64.233.56.37/26这样的CIDR格式，于是就在网上找了一下转换的方法，还真找到了不过是外语，这里简单记录下需要的工具。\n首先要准备一个python环境，安装netaddr插件，本人用的是提取的轻量级python环境，所以直接下载官网的源码，解压后找到netaddr文件夹复制到python环境目录的lib文件夹里即可。\n使用方法：\n\n# 首先引入netaddr\nimport netaddr\n\n# 确定起始和结尾IP，无论多复杂都可以转换\nstartip = '64.233.56.37'\nendip = '64.233.56.215'\ncidrs = netaddr.iprange_to_cidrs(startip, endip)\nfor k, v in enumerate(cidrs):\n    iplist = v\n    print iplist\n运行后输出结果：\n\n64.233.56.37/32\n64.233.56.38/31\n64.233.56.40/29\n64.233.56.48/28\n64.233.56.64/26\n64.233.56.128/26\n64.233.56.192/28\n64.233.56.208/29\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "1"}