{"title": "流畅的python - 个人文章 ", "index": "python", "content": "流畅的python中有很多奇技淫巧，整本书都在强调如何最大限度地利用Python 标准库。介绍了很多python的不常用的数据类型、操作、库等，对于入门python后想要提升对python的认识应该有帮助。目前读一遍记录了一些有共鸣的操作:\nPython内置序列类型的主要分类:\n按可存放的元素类型分为：容器序列和扁平序列\n容器序列，就是什么都能作为元素往里放，包括另一个序列。需要注意的是，如果元素是序列类型，那么存放的往往是引用，需要小心。\n常见的容器序列包括：list，tuple，array.array，collections.deque等。\n扁平序列，存放的都是原子级元素，此时存放的是值而不会是引用。\n常见的扁平序列包括：str，bytes，bytearray, memoryview, array.array等。\n按序列能否被修改分为：可变序列与不可变序列\n\n可变序列：可以进行增、删、改等操作的序列，包括list, bytearray, array.array, collections.deque, memoryview等。\n不可变序列：不可进行上述操作的序列，包括tuple, str, bytes等。\n\n字典的变种\n标准库里collections模块中提供了很多与字典类型相似的变种。\nOrderDict： 这个类型在添加键的时候，会保存顺序，因此键的迭代顺序总是一致的\nChainMap： 该类型可以容纳数个不同的映射对像，在进行键的查找时，这些对象会被当做一个整体逐个查找，直到键被找到为止\nCounter： 这个映射类型会给键准备一个整数技术器，每次更行一个键的时候都会增加这个计数器，所以这个类型可以用来给散列表对象计数，或者当成多重集来用。\nUserDict： 这个类其实就是把标准的dict用Python又写了一遍。一般用来给程序员想要通过继承dict创建自己的dict时，代替dict使用的。主要是因为直接继承原生dict会出现bug。\ndefaultdict：处理找不到的键的一个选择当某个键不在映射里, 我们也希望也能得到一个默认值. 这就是 defaultdict , 它是 dict 的子类, 并实现了 missing 方法.\ndict的实现以及导致的结果\n键必须是可散列的:\n一个可散列的对象必须满足以下要求。\n    (1) 支持 hash() 函数，并且通过 __hash__() 方法所得到的散列值是不变的。\n    (2) 支持通过 __eq__() 方法来检测相等性。\n    (3) 若 a == b 为真，则 hash(a) == hash(b) 也为真。\n    所有由用户自定义的对象默认都是可散列的，因为它们的散列值由 id() 来获取，而\n    且它们都是不相等的。\n字典在内存上开销很大（用内存换效率）。\n    元组取代字典就能节省空间的原因有两个：\n    (1) 避免了散列表所耗费的空间，\n    (2) 无需把记录中字段的名字在每个元素里都存一遍。\n键的查询很快\n键的次序取决于添加顺序\n往字典里添加新键可能会改变已有键的顺序\n\nset的实现以及导致的结果\n结合的元素必须是可散列的\n集合和消耗内存\n可以很高效的判断元素是否存在于某个集合\n元素的次序取决于被添加到集合里的顺序\n往集合里添加元素，可能会改变集合里已有的元素次序\n\ncollections.namedtuple 可以用来构建一个带字段名的元组和一个有名字的类\n创建一个具名元组需要两个参数，一个是类名，另一个是类的各个字段的名字。后者可以是由数个字符串组成的可迭代对象，或者是由空格分隔开的字段名组成的字符串。\n>>> from collections import namedtuple\n>>> City = namedtuple('City', 'name country population coordinates')\n>>> tokyo = City('Tokyo', 'JP', 36.933, (35.689722, 139.691667)) \n>>> tokyo\nCity(name='Tokyo', country='JP', population=36.933, coordinates=(35.689722,\n139.691667))\n>>> tokyo.population \n36.933\n>>> tokyo.coordinates\n(35.689722, 139.691667)\n>>> tokyo[1]\n'JP'\n\n>>> City = namedtuple('City_Name', 'name country population coordinates')\n>>> tokyo = City('Tokyo', 'JP', 36.933, (35.689722, 139.691667))\n>>> tokyo\nCity_Name(name='Tokyo', country='JP', population=36.933, coordinates=(35.689722, 139.691667))\n当列表不是首选时\n如果我们需要一个只包含数字的列表，那么 array.array 比 list 更高效。数组支持所\n有跟可变序列有关的操作，包括 .pop、.insert 和 .extend。另外，数组还提供从文件读取和存入文件的更快的方法，如 .frombytes 和 .tofile。\n\nset 专为检查元素是否存在做过优化\nmemoryview 是一个内置类，它能让用户在不复制内容的情况下操作同一个数组的不同切\n\n片。\n\n使用NumPy和SciPy提供的高阶数组和矩阵操作\n使用双向队列和其他形式的队列(collections.deque 双向队列类、queue类中的 Queue、LifoQueue和PriorityQueue、multiprocessing. Queue、heapq可以把可变序列当作堆队列或者优先队列来使用)\n\nPython 格式化输出\n在进行格式化输出时，%r 与 %s 的区别就好比 repr() 函数处理对象与 str() 函数处理对象的差别。\n\n%s -> str()，比较智能；\n%r -> repr()，处理较为简单和直接； 处理一些简单对象时，二者几乎没有差别.\n\n本文重点列举一些二者的差异化用法：\n处理字符串时\n>> s = 'world'\n\n>> print('hello %s'%s)\nhello world\n>> print('hello %r'%s)\nhello 'world'\n\n>> str(s)\n'world'\n>> repr(s)\n\"'world'\"\n2. datetime 库中的 datetime 对象\n>> from datetime import datetime \n>> timeinfo = datetime.today()\n\n>> timeinfo\ndatetime.datetime(2016, 6, 7, 21, 17, 34, 925488)\n>> type(timeinfo)\ndatetime.datetime\n\n>> repr(timeinfo)\n'datetime.datetime(2016, 6, 7, 21, 17, 34, 925488)'\n>> str(timeinfo)\n'2016-06-07 21:17:34.925488'\n反汇编函数 python opcode\nPython dis 模块支持对Python代码进行反汇编， 生成字节码指令。\nIn[1]: def test():\n...         x = 1\n...         if x < 3:\n...             return \"yes\"\n...         else:\n...             return \"no\"\n\nIn[2]: dis.dis(test)\n  2           0 LOAD_CONST               1 (1)\n              3 STORE_FAST               0 (x)\n \n  3           6 LOAD_FAST                0 (x)\n              9 LOAD_CONST               2 (3)\n             12 COMPARE_OP               0 (<)\n             15 POP_JUMP_IF_FALSE       22\n \n  4          18 LOAD_CONST               3 ('yes')\n             21 RETURN_VALUE        \n \n  6     >>   22 LOAD_CONST               4 ('no')\n             25 RETURN_VALUE        \n             26 LOAD_CONST               0 (None)\n             29 RETURN_VALUE        \n\n>>> def add(a, b = 0):\n...     return a + b\n... \n>>> \n\n>>> dis.dis(add)\n  2           0 LOAD_FAST                0 (a)\n              2 LOAD_FAST                1 (b)\n              4 BINARY_ADD\n              6 RETURN_VALUE\n>>>\n\n\nclass memoryview(obj)是python的内置类，如果要用memoryview 去引用一个object, 那么这个object 必须支持buffer protocol, python3 中原生（built-in) 支持buffer protocol的obj有bytes和bytearray，memoryview可以使用不同的方式读取和操作同一块内存，并且原有的内存字节不会随意移动。类似于C中的强转，好处是不会有内存拷贝。\n例如，使用memoryview修改一个短整型有符号整数数组的数据。\nfrom array import array\nfrom random import random\n\nnumbers = array('h', [-2, -1, 0, 1, 2]) #signed short\nmemv = memoryview(numbers)      #5个短整型有符号整数的数组创建一个memoryview\nprint (len(memv))               #打印长度\nprint (memv.tolist())           #转换成列表形式\n\nmemv_oct = memv.cast('B')       #内存共享 转换成无符号字符类型\nprint (memv_oct.tolist())\n\nmemv_oct[5] = 4                 #把位置5的字节赋值成4\nprint (numbers)                 #因为我们把占 2 个字节的整数的高位字节改成了 4，所以这个有符号整数的值就变成了 1024\n\n输出如下：\n\n5                       #数组长度\n[-2, -1, 0, 1, 2]       #列表形式显示\n[254, 255, 255, 255, 0, 0, 1, 0, 2, 0]#长度扩大一倍 转换为无符号字符类型\narray('h', [-2, -1, 1024, 1, 2])   #原来的数组被修改\n\nbytearray是可变(mutable)的字节序列，相对于Python2中的str，但str是不可变(immutable)的。在Python3中由于str默认是unicode编码，所以只有通过bytearray才能按字节访问。下面两种行为的对比：简单点就是，str和bytearray的切片操作会产生新的切片str和bytearry并拷贝数据，使用memoryview之后不会。\npython2中的例子\n不使用memoryview\n>> a = 'aaaaaa'\n>> b = a[:2]    # 会产生新的字符串\n\n>> a = bytearray('aaaaaa')\n>> b = a[:2]    # 会产生新的bytearray\n>> b[:2] = 'bb' # 对b的改动不影响a\n>> a\nbytearray(b'aaaaaa')\n>> b\nbytearray(b'bb')\n使用memoryview\n>> a = 'aaaaaa'\n>> ma = memoryview(a)\n>> ma.readonly  # 只读的memoryview\nTrue\n>> mb = ma[:2]  # 不会产生新的字符串\n\n>> a = bytearray('aaaaaa')\n>> ma = memoryview(a)\n>> ma.readonly  # 可写的memoryview\nFalse\n>> mb = ma[:2]      # 不会会产生新的bytearray\n>> mb[:2] = 'bb'    # 对mb的改动就是对ma的改动\n>> mb.tobytes()\n'bb'\n>> ma.tobytes()\n'bbaaaa'\nPython 中有各种各样可调用的类型，因此判断置的 callable() 函数：\n>>> abs, str, 13\n(<built-in function abs>, <class 'str'>, 13)\n>>> [callable(obj) for obj in (abs, str, 13)]\n[True, True, False]\nrandom.shuffle 打乱序列\n>>> import random\n>>> a=range(10)\n>>> random.shuffle(a)\n>>> a\n[1, 0, 8, 5, 6, 7, 9, 3, 2, 4]\n>>> random.shuffle(a)\n>>> a\n[7, 5, 6, 2, 1, 8, 9, 0, 3, 4]\nvim常用快捷\n\n0 → 数字零，到行头\n$ → 到本行行尾\na → 在光标后插入\no → 在当前行后插入一个新行\nO → 在当前行前插入一个新行\ncw → 替换从光标所在位置后到一个单词结尾的字符\n.  → (小数点) 可以重复上一次的命令\n\n\nNG → 到第 N 行 （注意命令中的G是大写的，另我一般使用 : N 到第N行，如 :137 到第137行）\ngg → 到第一行。（相当于1G，或 :1）\nG → 到最后一行。\n在 Insert 模式下，你可以输入一个词的开头，然后按<Ctrl-p>或是<Ctrl-n>，自动补齐功能就出现了…\n\n内置函数\nMath\nFunction    Description\nabs()    Returns absolute value of a number\ndivmod()    Returns quotient and remainder of integer division\nmax()    Returns the largest of the given arguments or items in an iterable\nmin()    Returns the smallest of the given arguments or items in an iterable\npow()    Raises a number to a power\nround()    Rounds a floating-point value\nsum()    Sums the items of an iterable\n\nType Conversion\nFunction    Description\nascii()    Returns a string containing a printable representation of an object\nbin()    Converts an integer to a binary string\nbool()    Converts an argument to a Boolean value\nchr()    Returns string representation of character given by integer argument\ncomplex()    Returns a complex number constructed from arguments\nfloat()    Returns a floating-point object constructed from a number or string\nhex()    Converts an integer to a hexadecimal string\nint()    Returns an integer object constructed from a number or string\noct()    Converts an integer to an octal string\nord()    Returns integer representation of a character\nrepr()    Returns a string containing a printable representation of an object\nstr()    Returns a string version of an object\ntype()    Returns the type of an object or creates a new type object\n\nIterables and Iterators\nFunction    Description\nall()    Returns True if all elements of an iterable are true\nany()    Returns True if any elements of an iterable are true\nenumerate()    Returns a list of tuples containing indices and values from an iterable\nfilter()    Filters elements from an iterable\niter()    Returns an iterator object\nlen()    Returns the length of an object\nmap()    Applies a function to every item of an iterable\nnext()    Retrieves the next item from an iterator\nrange()    Generates a range of integer values\nreversed()    Returns a reverse iterator\nslice()    Returns a slice object\nsorted()    Returns a sorted list from an iterable\nzip()    Creates an iterator that aggregates elements from iterables\n\nComposite Data Type\nFunction    Description\nbytearray()    Creates and returns an object of the bytearray class\nbytes()    Creates and returns a bytes object (similar to bytearray, but immutable)\ndict()    Creates a dict object\nfrozenset()    Creates a frozenset object\nlist()    Constructs a list object\nobject()    Returns a new featureless object\nset()    Creates a set object\ntuple()    Creates a tuple object\n\nClasses, Attributes, and Inheritance\nFunction    Description\nclassmethod()    Returns a class method for a function\ndelattr()    Deletes an attribute from an object\ngetattr()    Returns the value of a named attribute of an object\nhasattr()    Returns True if an object has a given attribute\nisinstance()    Determines whether an object is an instance of a given class\nissubclass()    Determines whether a class is a subclass of a given class\nproperty()    Returns a property value of a class\nsetattr()    Sets the value of a named attribute of an object\nsuper()    Returns a proxy object that delegates method calls to a parent or sibling class\n\nInput/Output\nFunction    Description\nformat()    Converts a value to a formatted representation\ninput()    Reads input from the console\nopen()    Opens a file and returns a file object\nprint()    Prints to a text stream or the console\n\nVariables, References, and Scope\nFunction    Description\ndir()    Returns a list of names in current local scope or a list of object attributes\nglobals()    Returns a dictionary representing the current global symbol table\nid()    Returns the identity of an object\nlocals()    Updates and returns a dictionary representing current local symbol table\nvars()    Returns __dict__ attribute for a module, class, or object\n\nMiscellaneous\nFunction    Description\ncallable()    Returns True if object appears callable\ncompile()    Compiles source into a code or AST object\neval()    Evaluates a Python expression\nexec()    Implements dynamic execution of Python code\nhash()    Returns the hash value of an object\nhelp()    Invokes the built-in help system\nmemoryview()    Returns a memory view object\nstaticmethod()    Returns a static method for a function\n__import__()    Invoked by the import statement\n\n\n跟运算符无关的特殊方法\n类别 方法名\n字符串 / 字节序列表示形式 __repr__、__str__、__format__、__bytes__\n数值转换 __abs__、__bool__、__complex__、__int__、__float__、__hash__、__index__\n集合模拟 __len__、__getitem__、__setitem__、__delitem__、__contains__\n迭代枚举 __iter__、__reversed__、__next__\n可调用模拟 __call__\n上下文管理 __enter__、__exit__\n实例创建和销毁 __new__、__init__、__del__\n属性管理 __getattr__、__getattribute__、__setattr__、__delattr__、__dir__\n属性描述符 __get__、__set__、__delete__\n跟类相关的服务 __prepare__、__instancecheck__、__subclasscheck__\n\nBisect模块管理有序的序列\nbisect.bisect_left(a,x, lo=0, hi=len(a)) :\n查找在有序列表 a 中插入 x 的index。lo 和 hi 用于指定列表的区间，默认是使用整个列表。如果 x 已经存在，在其左边插入。返回值为 index。\nbisect.bisect_right(a,x, lo=0, hi=len(a))\nbisect.bisect(a, x,lo=0, hi=len(a)) ：\n这2个函数和 bisect_left 类似，但如果 x 已经存在，在其右边插入。\nbisect.insort_left(a,x, lo=0, hi=len(a)) ：\n在有序列表 a 中插入 x。和 a.insert(bisect.bisect_left(a,x, lo, hi), x) 的效果相同。\nbisect.insort_right(a,x, lo=0, hi=len(a))\nbisect.insort(a, x,lo=0, hi=len(a)) :\n和 insort_left 类似，但如果 x 已经存在，在其右边插入。\nBisect 模块提供的函数可以分两类： bisect* 只用于查找 index， 不进行实际的插入；而 insort* 则用于实际插入。\n\n当list不是最优选择时，dict是python的核心类型，但它是以空间换时间的结果，比较占内存，tuple是dict结构比较好的替代，set用来做是否包含和去重很合适。\nfrom array import array  \nfrom random import random\nfloats = array('d', (random() for i in range(10**7)))  \nfp = open('floats.bin', 'wb')\nfloats.tofile(fp)  \nfp.close()\nfloats2 = array('d')  \nfp = open('floats.bin', 'rb')\nfloats2.fromfile(fp, 10**7)  \nfp.close()\nfloats2 == floats\n\nPython_内置四种队列\nfrom queue import Queue #LILO队列\nq = Queue() #创建队列对象\nq.put(0)    #在队列尾部插入元素\nq.put(1)\nq.put(2)\nprint('LILO队列',q.queue)  #查看队列中的所有元素\nprint(q.get())  #返回并删除队列头部元素\nprint(q.queue)\n\nfrom queue import LifoQueue #LIFO队列\nlifoQueue = LifoQueue()\nlifoQueue.put(1)\nlifoQueue.put(2)\nlifoQueue.put(3)\nprint('LIFO队列',lifoQueue.queue)\nlifoQueue.get() #返回并删除队列尾部元素\nlifoQueue.get()\nprint(lifoQueue.queue)\n\nfrom queue import PriorityQueue #优先队列\npriorityQueue = PriorityQueue() #创建优先队列对象\npriorityQueue.put(3)    #插入元素\npriorityQueue.put(78)   #插入元素\npriorityQueue.put(100)  #插入元素\nprint(priorityQueue.queue)  #查看优先级队列中的所有元素\npriorityQueue.put(1)    #插入元素\npriorityQueue.put(2)    #插入元素\nprint('优先级队列:',priorityQueue.queue)  #查看优先级队列中的所有元素\npriorityQueue.get() #返回并删除优先级最低的元素\nprint('删除后剩余元素',priorityQueue.queue)\npriorityQueue.get() #返回并删除优先级最低的元素\nprint('删除后剩余元素',priorityQueue.queue)  #删除后剩余元素\npriorityQueue.get() #返回并删除优先级最低的元素\nprint('删除后剩余元素',priorityQueue.queue)  #删除后剩余元素\npriorityQueue.get() #返回并删除优先级最低的元素\nprint('删除后剩余元素',priorityQueue.queue)  #删除后剩余元素\npriorityQueue.get() #返回并删除优先级最低的元素\nprint('全部被删除后:',priorityQueue.queue)  #查看优先级队列中的所有元素\n\nfrom collections import deque   #双端队列\ndequeQueue = deque(['Eric','John','Smith'])\nprint(dequeQueue)\ndequeQueue.append('Tom')    #在右侧插入新元素\ndequeQueue.appendleft('Terry')  #在左侧插入新元素\nprint(dequeQueue)\ndequeQueue.rotate(2)    #循环右移2次\nprint('循环右移2次后的队列',dequeQueue)\ndequeQueue.popleft()    #返回并删除队列最左端元素\nprint('删除最左端元素后的队列：',dequeQueue)\ndequeQueue.pop()    #返回并删除队列最右端元素\nprint('删除最右端元素后的队列：',dequeQueue)\n\n\n以上队列在多线程中可以使用的且线程安全，但在多进程中都不能用于通信。在多进程中，需要这样使用：\nfrom multiprocessing import Process, Queue\nmyqueue = Queue(100)\n\n\n## 参考\n\nhttps://blog.csdn.net/sinat_38682860/article/details/80392493 \nhttps://www.cnblogs.com/cmnz/p/6936181.html\n\n关键字\nfrom keyword import kwlist\nprint(kwlist)\n\nbuiltins模块\nimport builtins\ndir(builtins)\n\n\n\nPython locals() 的陷阱\nhttps://segmentfault.com/a/1190000012724861\n\ndef test():\n    globals()['a2'] = 4\ntest()\nprint a2   # 输出 4\n\n\ndef aaaa():\n    print locals()\n    for i in ['a', 'b', 'c']:\n        locals()[i] = 1\n    print locals()\n    print a # 错误：NameError: global name 'a' is not defined\naaaa()\n动态地进行变量赋值时，locals() 看到的, 的确是函数的局部命名空间的内容, 但是它本身不能代表局部命名空间, 这就好像一个代理, 它收集了A, B, C的东西, 展示给我看, 但是我却不能简单的通过改变这个代理, 来改变A, B, C真正拥有的东西!这也就是为什么, 当我们通过locals()[i] = 1的方式去动态赋值时, print a却触发了NameError异常, 而相反的, globals()确实真正的全局命名空间, 所以一般会说locals() 只读, globals() 可读可写。\nx += y vs x = x + y\n对于一般不可变类型的变量来说这两个方法没啥区别，但对于可变类型如list（列表），dict(字典)就有区别了，x += y 就地改变了list的值，而x = x + y创建了一个新的list并重新将x绑定上去，通过id(x)就可以看出。\nl = l + [3, 4, 5]　　　 这种背后就是BINARY_ADD\nl += [3, 4, 5]　　　　　这种背后就是INPLACE_ADD\n\n+=实际上应该能算是一个加强版的+, 因为它比+多了一个写回本身的功能.不过是否能够写回本身, 还是得看对象自身是否支持, 也就是说是否具备Py_NotImplemented标识, 是否支持sq_inplace_concat, 如果具备, 才能实现, 否则, 也就是和 + 效果一样而已.\n不仅仅是这些，当混合使用可变类型和不可变类型的时候，你会有更加惊奇的发现：\n>>> t = ([],)\n>>> t[0] += [2, 3]\nTraceback (most recent call last):\n  File \"<input>\", line 1, in ?\nTypeError: object doesn't support item assignment\n>>> t\n([2, 3],)\n明显的，元组不支持对其中元素的赋值——但是在对他使用+=后，元组里的list确实改变了！原因依然是+=就地改变list的值。但是元组的赋值不被允许，当异发生时，元组中的list已经被就地改变了。这就是一个我个人觉得非常致命的陷阱。解决方法：干脆避免使用+=，或者仅仅在整数时使用它。\n使用()创建tuple\n>>> a=(1) # 错误姿势\n>>> type(a)\n<type 'int'>\n\n>>> a=(1,) # 正确姿势\n>>> type(a)\n<type 'tuple'>\nPython的list循环遍历中，删除数据的正确方法\n通用的解决方案：\nnum_list = [1, 2, 3, 4, 5, 2, 2, 4]\n\n1. 倒序循环遍历\n\nfor i in range(len(num_list) - 1, -1, -1):  # 讲究\n    if num_list[i] == 2:\n        num_list.pop(i)\nprint(num_list)\n\n2. 遍历拷贝的list，操作原始的list。对于过大的list，拷贝后可能很占内存，可以用倒序遍历的方法来实现。\n\nfor item in num_list[:]:    # 保证可以把num_list从头遍历到尾\n    if item == 2:\n        num_list.remove(item) # 从头删除遇到的第一个item\nprint(num_list)\n\n\n3. 对原来的列表做过滤，生成一个新的列表(假设determine(x)为判断条件的函数)：\n\nlist = [x for x in list if not determine(x)]\n\n4. 在原来列表上做切片，仅保留需要的元素\n\nlist[:] = [x for x in list if not determine(x)]\n\n5. python2.x ifilterfalse()方法\n\nfrom itertools import ifilterfalse()\nlist[:] = ifilterfalse(determine, list)\n\n6. Python3 filterfalse()方法\n\nfrom itertools import filterfalse\nlist[:] = filterfalse(determine, list)\n\n方法5，6对列表的修改会反应到其他对此列表的引用上。\n作用域解析是基于LEGB规则，分别是Local、Enclosing、Global、Built-in\n函数内定义的局部变量必须global申明才能使用全局变量\ndef local_var_err():\n    b += [3]  # UnboundLocalError: local variable 'b' referenced before assignment\n    b = b + [2]  # UnboundLocalError: local variable 'b' referenced before assignment\n\n\n不遍历情况下迭代器与生成器的性能比较\nIn [109]: %timeit -n100 a = (i for i in range(100000))\n100 loops, best of 3: 659 µs per loop\n\nIn [110]: %timeit -n100 b = [i for i in range(100000)]\n100 loops, best of 3: 2.68 ms per loop\n\n遍历情况下迭代器与生成器的性能比较\nIn [112]: %timeit -n100 for x in (i for i in range(100000)):pass\n100 loops, best of 3: 4.23 ms per loop\n\nIn [113]: %timeit -n100 for x in [i for i in range(100000)]:pass\n100 loops, best of 3: 3.49 ms per loop\n\n空间换时间\n尽量使用局部变量\n# -*- coding:utf-8 -*-\nimport timeit\n\ntest_dict = {}\n\nclass dome(object):\n    def test_class(self):\n        num = 100\n        self.test_dict = {}        # 为了公平，每次执行都同样初始化新的 {}\n        for i in range(num):\n            self.test_dict[i] = i\n\n    def test_local(self):\n        num = 100\n        test_dict = {}             # 为了公平，每次执行都同样初始化新的 {}\n        for i in range(num):\n            test_dict[i] = i\n        self.test_dict = test_dict\n\n    def test_global(self):\n        num = 100\n        global test_dict\n        test_dict = {}              # 为了公平，每次执行都同样初始化新的 {}\n        for i in range(num):\n            test_dict[i] = i\n\ns = dome()\n\nprint(timeit.timeit(stmt=s.test_class))    # 9.75976037823\nprint(timeit.timeit(stmt=s.test_local))    # 7.17526431985\nprint(timeit.timeit(stmt=s.test_global))   # 7.57540534177\n\n\"\"\"\n1. 访问局部变量速度要快很多\n2. 循环之外能做的事不要放在循环内\n在一些会频繁操作 类/实例属性 的情况下，应该是先把 属性 取出来存到 局部变量，然后用 局部变量 来完成操作。最后视情况把变动更新到 属性 上。\n\"\"\"\n拼接字符串列表时使用join\na=list(str(range(1000)))\n\nIn [126]: %%timeit\ns=\"\"\nfor x in a:\n    s+=x\n   .....: \n1000 loops, best of 3: 304 µs per loop\n\nIn [127]: %%timeit\n   .....: s=\"\".join(a)\n   .....: \n10000 loops, best of 3: 59.3 µs per loop\n\n参考博客 https://blog.csdn.net/xdhstc/article/details/51719892\nif is True 对比 if == True，列表推导。\n# -*- coding:utf-8 -*-\nimport timeit\n\ndef test_1():\n    a = [True] * 100\n    s = []\n    for i in a:\n        if i == True:\n            s.append(i)\n    return s\n\n\ndef test_2():\n    a = [True] * 100\n    return [i for i in a if i is True]\n\n\ndef test_3():\n    a = [True] * 100\n    return [i for i in a if i == True]\n\n\ndef test_4():\n    a = [True] * 100\n    return [i for i in a if i]\n\n\nprint(timeit.timeit(stmt=test_1))  # 11.5888194259\nprint(timeit.timeit(stmt=test_2))  # 6.00562291202\nprint(timeit.timeit(stmt=test_3))  # 7.15504198257\nprint(timeit.timeit(stmt=test_4))  # 4.29275713242\n使用**而不是pow\nIn [145]: %timeit -n100000 c = pow(2,20)\n100000 loops, best of 3: 89.3 ns per loop\n\nIn [146]: %timeit -n100000 c = 2**20\n100000 loops, best of 3: 22.2 ns per loop\n\n\n带有条件判断的嵌套for循环时尽量分析条件减少循环次数\n# -*- coding:utf-8 -*-\nimport timeit\n\n\ndef test1():\n    s = []\n    for z in range(10):\n        for y in range(100):\n            for x in range(1000):\n                if x > 100 and y > 50 and z > 5:\n                    return s\n                s.append((x, y, z))\n\n\n\ndef test2():\n    s = []\n    for x in range(1000):\n        for y in range(100):\n            for z in range(10):\n                if x > 100 and y > 50 and z > 5:\n                    return s\n                s.append((x, y, z))\n\n\n\nprint(timeit.timeit(stmt=test1, number=100))    # 14.1777687741\nprint(timeit.timeit(stmt=test2, number=100))    # 2.03417086749\nprint(sorted(test1()) == sorted(test2()))       # False\nprint(len(test1()))                             # 651101\nprint(len(test2()))                             # 101516\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "1"}