{"title": "微信公号DIY：一小时搭建微信聊天机器人 - 古寺比的寺 ", "index": "聊天机器人,微信,python", "content": "最近借用了女朋友的公号，感觉如果只是用来发文章，太浪费微信给提供的这些功能了。想了想，先从最简单的开始，做一个聊天机器人吧。\n使用Python实现聊天机器人的方案有多种：AIML、chatterBot以及图灵聊天机器人和微软小冰等。\n考虑到以后可能会做一些定制化的需求，这里我选择了chatterBot（github 项目地址：https://github.com/gunthercox/ChatterBot)。\nchatterbot是一款python接口的，基于一系列规则和机器学习算法完成的聊天机器人。具有结构清晰，可扩展性好，简单实用的特点。\nchatterBot 的工作流程如图：\n\n\n输入模块（input adapter）从终端或者API等输入源获取数据\n输入源会被指定的逻辑处理模块（logic Adapter）分别处理，逻辑处理模块会匹配训练集中已知的最接近输入数据句子A，然后根据句子A去找到相关度最高的结果B，如果有多个逻辑处理模块返回了不同的结果，会返回一个相关度最高的结果。\n输出模块（output adapter）将匹配到的结果返回给终端或者API。\n\n值得一说的是chatterBot 是一个模块化的项目，分为 input Adapter、logic Adapter、storage Adapter、output Adapter以及Trainer 模块。\nlogic Adapter是一个插件式设计，主进程在启动时会将用户定义的所有逻辑处理插件添加到logic context中，然后交MultiLogicAdapter 进行处理，MultiLogicAdapter 依次调用每个 logic Adapter，logic Adapter 被调用时先执行can_process 方式判断输入是否可以命中这个逻辑处理插件。比如”今天天气怎么样“这样的问题显然需要命中天气逻辑处理插件，这时时间逻辑处理插件的can_process 则会返回False。在命中后logic Adapter 负责计算出对应的回答（Statement对象）以及可信度（confidence），MultiLogicAdapter会取可信度最高的回答，并进入下一步。\n下面我们来看下 chatterBot 如何使用\nchatterBot 安装&使用\n安装\nchatterBot 是使用Python编写的，可以使用 pip 安装：\npip install chatterbot\nchatterBot 的中文对话要求Python3 以上版本，建议在Python3.x 环境下开发\n测试\n打开iPython，输入测试一下\nIn [1]: from chatterbot import ChatBot  # import ChatBot\n\nIn [2]: momo = ChatBot('Momo', trainer='chatterbot.trainers.ChatterBotCorpusTrainer')\n/Users/gs/.virtualenvs/py3/lib/python3.6/site-packages/chatterbot/storage/jsonfile.py:26: UnsuitableForProductionWarning: The JsonFileStorageAdapter is not recommended for production environments.\n  self.UnsuitableForProductionWarning  # 这里storage adapter 默认使用的是 json 格式存储数据的，如果想在服务端部署，应该避免使用这种格式，因为实在是太慢了\n\nIn [3]: momo.train(\"chatterbot.corpus.chinese\")  # 指定训练集，这里我们使用中文\n\n# 下边是对话结果\nIn [4]: momo.get_response('你好')\nOut[4]: <Statement text:你好>\n\nIn [5]: momo.get_response('怎么了')\nOut[5]: <Statement text:没什么.>\n\nIn [6]: momo.get_response('你知道它的所有内容吗?')\nOut[6]: <Statement text:优美胜于丑陋.>\n\nIn [7]: momo.get_response('你是一个程序员吗?')\nOut[7]: <Statement text:我是个程序员>\n\nIn [8]: momo.get_response('你使用什么语言呢？')\nOut[8]: <Statement text:我经常使用 Python, Java 和 C++ .>\n这时你已经可以和机器人对话了，不过现在由于训练数据太少，机器人只能返回简单的对话。\n这里是默认的中文对话训练数据 中文训练数据地址：https://github.com/gunthercox/chatterbot-corpus/tree/master/chatterbot_corpus/data/chinese。\n那么我们怎么添加训练数据呢？\n训练机器人\nchatterBot 内置了training class，自带的方法有两种，一种是使用通过输入list 来训练，比如 [\"你好\", \"我不好\"]，后者是前者的回答，另一种是通过导入Corpus 格式的文件来训练。也支持自定义的训练模块，不过最终都是转为上述两种类型。\nchatterBot 通过调用 train() 函数训练，不过在这之前要先用 set_trainer() 来进行设置。例如：\nIn [12]: from chatterbot.trainers import ListTrainer  # 导入训练模块的 ListTrainer 类\n\nIn [13]: momo.get_response('你叫什么?')  # 现在是答非所问，因为在这之前我们并没有训练过\nOut[13]: <Statement text:我在烤蛋糕.>\n\nIn [14]: momo.set_trainer(ListTrainer)  # 指定训练方式\n\nIn [15]: momo.train(['你叫什么?', '我叫魔魔！'])  # 训练\n\nIn [16]: momo.get_response('你叫什么?')  # 现在机器人已经可以回答了\nOut[16]: <Statement text:我叫魔魔！>\n训练好的数据默认存在 ./database.db，这里使用的是 jsondb。\n对 chatterBot 的介绍先到这里，具体用法可以参考文档：ChatterBot Tutorial：http://chatterbot.readthedocs.io/en/stable/tutorial.html\n接下来，介绍如何在项目中使用 chatterBot。\n使用 Sanic 创建项目\nSanic 是一个和类Flask 的基于Python3.5+的web框架，它编写的代码速度特别快。\n除了像Flask 以外，Sanic 还支持以异步请求的方式处理请求。这意味着你可以使用新的 async/await 语法，编写非阻塞的快速的代码。\n对 Sanic 不了解的可以参考我之前的一篇文章： python web 框架 Sanci 快速入门，可以在公号输入 【sanic】获取文章地址。\n这里之所以使用 Sanic 是因为他和Flask 非常像，之前我一直使用Flask，并且它也是专门为Python3.5 写的，使用到了协程。\n首先建个项目，这里项目我已经建好了，项目结构如下：\n.\n├── LICENSE\n├── README.md\n├── manage.py   # 运行文件 启动项目 使用 python manage.py 命令\n├── momo\n│   ├── __init__.py\n│   ├── app.py          # 创建app 模块\n│   ├── helper.py  \n│   ├── settings.py     # 应用配置\n│   └── views\n│       ├── __init__.py\n│       ├── hello.py    # 测试模块\n│       └── mweixin.py  # 微信消息处理模块\n├── requirements.txt\n└── supervisord.conf\n源码我已经上传到github，有兴趣的可以看一下，也可以直接拉下来测试。项目代码地址\n我们先重点看下 hello.py 文件 和 helper.py 。\n# hello.py\n# -*- coding: utf-8 -*-\n\nfrom sanic import Sanic, Blueprint\nfrom sanic.views import HTTPMethodView\nfrom sanic.response import text\n\nfrom momo.helper import get_momo_answer  # 导入获取机器人回答获取函数\n\n\nblueprint = Blueprint('index', url_prefix='/')\n\n\nclass ChatBot(HTTPMethodView):\n    # 聊天机器人 http 请求处理逻辑\n    async def get(self, request):\n        ask = request.args.get('ask')\n        # 先获取url 参数值 如果没有值，返回 '你说啥'\n        if ask:\n            answer = get_momo_answer(ask)\n            return text(answer)\n        return text('你说啥?')\n\n\nblueprint.add_route(ChatBot.as_view(), '/momo')\n# helper.py\nfrom chatterbot import ChatBot\n\nmomo_chat = ChatBot(\n    'Momo',\n    # 指定存储方式 使用mongodb 存储数据\n    storage_adapter='chatterbot.storage.MongoDatabaseAdapter',\n    # 指定 logic adpater 这里我们指定三个\n    logic_adapters=[\n        \"chatterbot.logic.BestMatch\", \n        \"chatterbot.logic.MathematicalEvaluation\",  # 数学模块\n        \"chatterbot.logic.TimeLogicAdapter\",   # 时间模块\n    ],\n    input_adapter='chatterbot.input.VariableInputTypeAdapter',\n    output_adapter='chatterbot.output.OutputAdapter',\n    database='chatterbot',\n    read_only=True\n)\n\n\ndef get_momo_answer(content):\n    # 获取机器人返回结果函数\n    response = momo_chat.get_response(content)\n    if isinstance(response, str):\n        return response\n    return response.text\n\n运行命令 python manage.py 启动项目。\n在浏览器访问url： http://0.0.0.0:8000/momo?ask=你是程序员吗\n\n到这里，我们已经启动了一个web 项目，可以通过访问url 的方式和机器人对话，是时候接入微信公号了！\n接入微信公众号\n前提\n\n拥有一个可以使用的微信公众号（订阅号服务号都可以，如果没有，可以使用微信提供的测试账号）\n拥有一个外网可以访问的服务器（vps 或公有云都可以 aws 新用户免费使用一年，可以试试）\n服务器配置了python3 环境，（建议使用 virtualenvwrapper 配置虚拟环境）\n\n微信设置\n登录微信公众号： https://mp.weixin.qq.com\n打开：开发>基本配置\n查看公号开发信息：\n\n开启服务器配置：\n设置请求url，这里是你配置的url（需要外网可访问，只能是80或443端口）\n填写token和EncodingAESKey，这里我选择的是兼容模式，既有明文方便调试，又有信息加密。\n\n详细配置可以参考官方文档：接入指南\n如果你的 服务器地址 已经配置完成，现在点击提交应该就成功了。如果没有成功我们接下来看怎么配置服务器地址。\n代码示例\n先看下 微信请求的视图代码：\n# -*- coding: utf-8 -*-\nfrom __future__ import unicode_literals\n\nfrom six import StringIO\n\nimport re\nimport xmltodict\nfrom chatterbot.trainers import ListTrainer\n\nfrom sanic import Blueprint\nfrom sanic.views import HTTPMethodView\nfrom sanic.response import text\nfrom sanic.exceptions import ServerError\n\nfrom weixin import WeixinMpAPI\nfrom weixin.lib.WXBizMsgCrypt import WXBizMsgCrypt\n\nfrom momo.settings import Config\n\nblueprint = Blueprint('weixin', url_prefix='/weixin')\n\n\nclass WXRequestView(HTTPMethodView):\n\n    def _get_args(self, request):\n        # 获取微信请求参数，加上token  拼接为完整的请求参数\n        params = request.raw_args\n        if not params:\n            raise ServerError(\"invalid params\", status_code=400)\n        args = {\n            'mp_token': Config.WEIXINMP_TOKEN,\n            'signature': params.get('signature'),\n            'timestamp': params.get('timestamp'),\n            'echostr': params.get('echostr'),\n            'nonce': params.get('nonce'),\n        }\n        return args\n\n    def get(self, request):\n        # 微信验证服务器这一步是get  请求，参数可以使用 request.raw_args 获取\n        args = self._get_args(request)\n        weixin = WeixinMpAPI(**args) # 这里我使用了 第三方包 python-weixin 可以直接实例化一个WeixinMpAPI对象\n        if weixin.validate_signature(): # 验证参数合法性\n            # 如果参数争取，我们将微信发过来的echostr参数再返回给微信，否则返回 fail\n            return text(args.get('echostr') or 'fail')\n        return text('fail')\n        \nblueprint.add_route(WXRequestView.as_view(), '/request')\n这里处理微信请求我使用的是 我用python 写的 微信SDK python-weixin，可以使用 pip 安装：\npip install python-weixin\n这个包最新版本对Python3 加密解密有点问题，可以直接从github 安装:\npip install git+https://github.com/zongxiao/python-weixin.git@py3\n然后更新 app.py 文件：\n# -*- coding: utf-8 -*-\nfrom sanic import Sanic\nfrom momo.settings import Config\n\n\ndef create_app(register_bp=True, test=False):\n    # 创建app    \n    app = Sanic(__name__)\n    if test:\n        app.config['TESTING'] = True\n    # 从object 导入配置\n    app.config.from_object(Config)\n    register_blueprints(app)\n    return app\n\n\ndef register_blueprints(app):\n    from momo.views.hello import blueprint as hello_bp\n    from momo.views.mweixin import blueprint as wx_bp\n    app.register_blueprint(hello_bp)\n    # 注册 wx_bp \n    app.register_blueprint(wx_bp)\n详细代码参考github: 微信聊天机器人 momo\n接入聊天机器人\n现在我们公号已经接入了自己的服务，是时候接入微信聊天机器人。\n微信聊天机器人的工作流程如下：\n\n看我们消息逻辑处理代码：\n# -*- coding: utf-8 -*-\nfrom __future__ import unicode_literals\n\nfrom six import StringIO\n\nimport re\nimport xmltodict\nfrom chatterbot.trainers import ListTrainer\n\nfrom sanic import Blueprint\nfrom sanic.views import HTTPMethodView\nfrom sanic.response import text\nfrom sanic.exceptions import ServerError\n\nfrom weixin import WeixinMpAPI\nfrom weixin.reply import TextReply\nfrom weixin.response import WXResponse as _WXResponse\nfrom weixin.lib.WXBizMsgCrypt import WXBizMsgCrypt\n\nfrom momo.settings import Config\nfrom momo.helper import validate_xml, smart_str, get_momo_answer\nfrom momo.media import media_fetch\n\n\nblueprint = Blueprint('weixin', url_prefix='/weixin')\n\nappid = smart_str(Config.WEIXINMP_APPID)\ntoken = smart_str(Config.WEIXINMP_TOKEN)\nencoding_aeskey = smart_str(Config.WEIXINMP_ENCODINGAESKEY)\n\n# 关注后自动返回的文案\nAUTO_REPLY_CONTENT = \"\"\"\nHi，朋友！\n这是我妈四月的公号，我是魔魔，我可以陪你聊天呦！\n我还能\"记账\"，输入\"记账\"会有惊喜呦！\n<a href=\"https://mp.weixin.qq.com/mp/profile_ext?action=home&__biz=MzAwNjI5MjAzNw==&scene=124#wechat_redirect\">历史记录</a>\n\"\"\"\n\n\nclass ReplyContent(object):\n\n    _source = 'value'\n\n    def __init__(self, event, keyword, content=None, momo=True):\n        self.momo = momo\n        self.event = event\n        self.content = content\n        self.keyword = keyword\n        if self.event == 'scan':\n            pass\n\n    @property\n    def value(self):\n        if self.momo:\n            answer = get_momo_answer(self.content)\n            return answer\n        return ''\n\n\nclass WXResponse(_WXResponse):\n\n    auto_reply_content = AUTO_REPLY_CONTENT\n\n    def _subscribe_event_handler(self):\n        # 关注公号后的处理逻辑\n        self.reply_params['content'] = self.auto_reply_content\n        self.reply = TextReply(**self.reply_params).render()\n\n    def _unsubscribe_event_handler(self):\n        # 取关后的处理逻辑，取关我估计会哭吧\n        pass\n\n    def _text_msg_handler(self):\n        # 文字消息处理逻辑 聊天机器人的主要逻辑\n        event_key = 'text'\n        content = self.data.get('Content')\n        reply_content = ReplyContent('text', event_key, content)\n        self.reply_params['content'] = reply_content.value\n        self.reply = TextReply(**self.reply_params).render()\n\n\nclass WXRequestView(HTTPMethodView):\n\n    def _get_args(self, request):\n        params = request.raw_args\n        if not params:\n            raise ServerError(\"invalid params\", status_code=400)\n        args = {\n            'mp_token': Config.WEIXINMP_TOKEN,\n            'signature': params.get('signature'),\n            'timestamp': params.get('timestamp'),\n            'echostr': params.get('echostr'),\n            'nonce': params.get('nonce'),\n        }\n        return args\n\n    def get(self, request):\n        args = self._get_args(request)\n        weixin = WeixinMpAPI(**args)\n        if weixin.validate_signature():\n            return text(args.get('echostr') or 'fail')\n        return text('fail')\n\n    def _get_xml(self, data):\n        post_str = smart_str(data)\n        # 验证xml 格式是否正确\n        validate_xml(StringIO(post_str))\n        return post_str\n\n    def _decrypt_xml(self, params, crypt, xml_str):\n        # 解密消息\n        nonce = params.get('nonce')\n        msg_sign = params.get('msg_signature')\n        timestamp = params.get('timestamp')\n        ret, decryp_xml = crypt.DecryptMsg(xml_str, msg_sign,\n                                           timestamp, nonce)\n        return decryp_xml, nonce\n\n    def _encryp_xml(self, crypt, to_xml, nonce):\n        # 加密消息\n        to_xml = smart_str(to_xml)\n        ret, encrypt_xml = crypt.EncryptMsg(to_xml, nonce)\n        return encrypt_xml\n\n    def post(self, request):\n        # 获取微信服务器发送的请求参数\n        args = self._get_args(request)\n        weixin = WeixinMpAPI(**args)\n        if not weixin.validate_signature(): # 验证参数合法性\n            raise AttributeError(\"Invalid weixin signature\")\n        xml_str = self._get_xml(request.body)  # 获取form data\n        crypt = WXBizMsgCrypt(token, encoding_aeskey, appid) \n        decryp_xml, nonce = self._decrypt_xml(request.raw_args, crypt, xml_str) # 解密\n        xml_dict = xmltodict.parse(decryp_xml)\n        xml = WXResponse(xml_dict)() or 'success' # 使用WXResponse 根据消息获取机器人返回值\n        encryp_xml = self._encryp_xml(crypt, xml, nonce) # 加密消息\n        return text(encryp_xml or xml) # 回应微信请求\n\n\nblueprint.add_route(WXRequestView.as_view(), '/request')\n\n可以看到，我处理微信请求返回结果比较简单，也是使用的 python-weixin 包封装的接口，主要的处理逻辑是 WXResponse。\n这里需要注意的是，如果服务器在5秒内没有响应微信服务器会重试。为了加快响应速度，不要在服务器 将 chatterBot 的 storage adapter 设置为使用 jsondb。\n上边这些就是，微信聊天机器人的主要处理逻辑，我们运行服务，示例如下：\n\n可以看到这里聊天机器人也可以做简单的数学运算和报时，是因为我在上边指定处理逻辑的时候添加了数学模块和时间模块：\nmomo_chat = ChatBot(\n    'Momo',\n    # 指定存储方式 使用mongodb 存储数据\n    storage_adapter='chatterbot.storage.MongoDatabaseAdapter',\n    # 指定 logic adpater 这里我们指定三个\n    logic_adapters=[\n        \"chatterbot.logic.BestMatch\", \n        \"chatterbot.logic.MathematicalEvaluation\",  # 数学模块\n        \"chatterbot.logic.TimeLogicAdapter\",   # 时间模块\n    ],\n    input_adapter='chatterbot.input.VariableInputTypeAdapter',\n    output_adapter='chatterbot.output.OutputAdapter',\n    database='chatterbot',\n    read_only=True\n)\n到这里，微信机器人的搭建就完成了，详细代码已经长传到了 github: https://github.com/gusibi/momo/tree/chatterbot，感兴趣的可以参考一下。\n参考链接\n\nChatterBot 项目地址：https://github.com/gunthercox/ChatterBot\nChatterBot Tutorial：http://chatterbot.readthedocs.io/en/stable/tutorial.html\n用Python快速实现一个聊天机器人：http://www.jianshu.com/p/d1333fde266f\n基于Python-ChatterBot搭建不同adapter的聊天机器人：https://ask.hellobi.com/blog/guodongwei1991/7626\n擁有自動學習的 Python 機器人 - ChatterBot：https://kantai235.github.io/2017/03/16/ChatterBotTeaching/\n使用 ChatterBot构建聊天机器人：https://www.biaodianfu.com/chatterbot.html\npython-weixin sdk: https://github.com/gusibi/python-weixin\n\n预告\n这里，聊天机器人还是比较简单的只能回复简单的对话，下一篇将要结束如何在公号训练机器人以及一个更实用的功能，如何让公号变成一个博客写作助手。\n\n最后，感谢女朋友支持。\n\n\n欢迎关注(April_Louisa)\n请我喝芬达\n\n\n\n\n\n\n\n                ", "mainLikeNum": ["13 "], "mainBookmarkNum": "81"}