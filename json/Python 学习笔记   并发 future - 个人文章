{"title": "Python 学习笔记   并发 future - 个人文章 ", "index": "python3.x,python", "content": "concurrent.futures模块\n该模块主要特色在于ThreadPoolExecutor 和 ProcessPoolExecutor 类，这两个类都继承自concurrent.futures._base.Executor类，它们实现的接口能分别在不同的线程或进程中执行可调用的对象，它们都在内部维护着一个工作线程或者进程池。\nThreadPoolExecutor 和 ProcessPoolExecutor 类是高级类，大部分情况下只要学会使用即可，无需关注其实现细节。\n####ProcessPoolExecutor 类\n>class ThreadPoolExecutor(concurrent.futures._base.Executor)\n\n>|  This is an abstract base class for concrete asynchronous executors.\n\n>|  Method resolution order:\n\n>|      ThreadPoolExecutor\n\n |      concurrent.futures._base.Executor\n\n |      builtins.object\n\n |\n\n |  Methods defined here:\n\n |\n\n |  init(self, max_workers=None, thread_name_prefix='')\n\n |      Initializes a new ThreadPoolExecutor instance.\n\n |\n\n |      Args:\n\n |          max_workers: The maximum number of threads that can be used to\n\n |              execute the given calls.\n\n |          thread_name_prefix: An optional name prefix to give our threads.\n\n |\n\n |  shutdown(self, wait=True)\n\n |      Clean-up the resources associated with the Executor.\n\n |\n\n |      It is safe to call this method several times. Otherwise, no other\n\n |      methods can be called after this one.\n\n |\n\n |      Args:\n\n |          wait: If True then shutdown will not return until all running\n\n |              futures have finished executing and the resources used by the\n\n |              executor have been reclaimed.\n\n |\n\n |  submit(self, fn, *args, **kwargs)\n\n |      Submits a callable to be executed with the given arguments.\n\n |\n\n |      Schedules the callable to be executed as fn(*args, **kwargs) and returns\n\n |      a Future instance representing the execution of the callable.\n\n |\n\n |      Returns:\n\n |          A Future representing the given call.\n\n |\n\n |  ----------------------------------------------------------------------\n\n |  Methods inherited from concurrent.futures._base.Executor:\n\n |\n\n |  enter(self)\n\n |\n\n |  exit(self, exc_type, exc_val, exc_tb)\n\n |\n\n |  map(self, fn, *iterables, timeout=None, chunksize=1)\n\n |      Returns an iterator equivalent to map(fn, iter).\n\n |\n\n |      Args:\n\n |          fn: A callable that will take as many arguments as there are\n\n |              passed iterables.\n\n |          timeout: The maximum number of seconds to wait. If None, then there\n\n |              is no limit on the wait time.\n\n |          chunksize: The size of the chunks the iterable will be broken into\n\n |              before being passed to a child process. This argument is only\n\n |              used by ProcessPoolExecutor; it is ignored by\n\n |              ThreadPoolExecutor.\n\n |\n\n |      Returns:\n\n |          An iterator equivalent to: map(func, *iterables) but the calls may\n\n |          be evaluated out-of-order.\n\n |\n\n |      Raises:\n\n |          TimeoutError: If the entire result iterator could not be generated\n\n |              before the given timeout.\n\n |          Exception: If fn(*args) raises for any values.\n\n\n\n\n初始化可以指定一个最大进程数作为其参数 max_workers 的值，该值一般无需指定，默认为当前运行机器的核心数，可以由os.cpu_count()获取；类中含有方法：\nmap()方法，与python内置方法map() 功能类似，也就是映射，参数为：\n\n一个可调用函数 fn\n一个迭代器 iterables\n超时时长 timeout\n块数chuncksize 如果大于1, 迭代器会被分块处理\n\n---->> 该函数有一个特性：其返回结果与调用开始的顺序是一致的；在调用过程中不会产生阻塞，也就是说可能前者被调用执行结束之前，后者被调用已经执行结束了。\n如果一定要获取到所有结果后再处理，可以选择采用submit()方法和futures.as_completed函数结合使用。\n\nshutdown()方法，清理所有与当前执行器（executor)相关的资源\nsubmit() 方法，提交一个可调用对象给fn使用\n从concurrent.futures._base.Executor继承了__enter__() 和 __exit__()方法，这意味着ProcessPoolExecutor 对象可以用于with 语句。\n\nfrom concurrent import futures\nwith futures.ProcessPoolExecutor(max_works=3) as executor:\n     executor.map()\n\n\nThreadPoolExecutor类\nclass ThreadPoolExecutor(concurrent.futures._base.Executor)\n\n |  This is an abstract base class for concrete asynchronous executors.\n\n |\n\n |  Method resolution order:\n\n |      ThreadPoolExecutor\n\n |      concurrent.futures._base.Executor\n\n |      builtins.object\n\n |\n\n |  Methods defined here:\n\n |\n\n |  init(self, max_workers=None, thread_name_prefix='')\n\n |      Initializes a new ThreadPoolExecutor instance.\n\n |\n\n |      Args:\n\n |          max_workers: The maximum number of threads that can be used to\n\n |              execute the given calls.\n\n |          thread_name_prefix: An optional name prefix to give our threads.\n\n |\n\n |  shutdown(self, wait=True)\n\n |      Clean-up the resources associated with the Executor.\n\n |\n\n |      It is safe to call this method several times. Otherwise, no other\n\n |      methods can be called after this one.\n\n |\n\n |      Args:\n\n |          wait: If True then shutdown will not return until all running\n\n |              futures have finished executing and the resources used by the\n\n |              executor have been reclaimed.\n\n |\n\n |  submit(self, fn, *args, **kwargs)\n\n |      Submits a callable to be executed with the given arguments.\n\n |\n\n |      Schedules the callable to be executed as fn(*args, **kwargs) and returns\n\n |      a Future instance representing the execution of the callable.\n\n |\n\n |      Returns:\n\n |          A Future representing the given call.\n\n |\n\n |  ----------------------------------------------------------------------\n\n |  Methods inherited from concurrent.futures._base.Executor:\n\n |\n\n |  enter(self)\n\n |\n\n |  exit(self, exc_type, exc_val, exc_tb)\n\n |\n\n |  map(self, fn, *iterables, timeout=None, chunksize=1)\n\n |      Returns an iterator equivalent to map(fn, iter).\n\n |\n\n |      Args:\n\n |          fn: A callable that will take as many arguments as there are\n\n |              passed iterables.\n\n |          timeout: The maximum number of seconds to wait. If None, then there\n\n |              is no limit on the wait time.\n\n |          chunksize: The size of the chunks the iterable will be broken into\n\n |              before being passed to a child process. This argument is only\n\n |              used by ProcessPoolExecutor; it is ignored by\n\n |              ThreadPoolExecutor.\n\n |\n\n |      Returns:\n\n |          An iterator equivalent to: map(func, *iterables) but the calls may\n\n |          be evaluated out-of-order.\n\n |\n\n |      Raises:\n\n |          TimeoutError: If the entire result iterator could not be generated\n\n |              before the given timeout.\n\n |          Exception: If fn(*args) raises for any values.\n\n与ProcessPoolExecutor 类十分相似，只不过一个是处理进程，一个是处理线程，可根据实际需要选择。\n示例\nfrom time import sleep, strftime\nfrom concurrent import futures\n\n\ndef display(*args):\n    print(strftime('[%H:%M:%S]'), end=\"\")\n    print(*args)\n\n\ndef loiter(n):\n    msg = '{}loiter({}): doing nothing for {}s'\n    display(msg.format('\\t'*n, n, n))\n    sleep(n)\n    msg = '{}loiter({}): done.'\n    display(msg.format('\\t'*n, n))\n    return n*10\n\n\ndef main():\n    display('Script starting')\n    executor = futures.ThreadPoolExecutor(max_workers=3)\n    results = executor.map(loiter, range(5))\n    display('results:', results)\n    display('Waiting for individual results:')\n    for i, result in enumerate(results):\n        display('result {} : {}'.format(i, result))\n\n\nif __name__ == '__main__':\n    main()\n\n\n运行结果：\n[20:32:12]Script starting\n[20:32:12]loiter(0): doing nothing for 0s\n[20:32:12]loiter(0): done.\n[20:32:12]      loiter(1): doing nothing for 1s\n[20:32:12]              loiter(2): doing nothing for 2s\n[20:32:12]results: <generator object Executor.map.<locals>.result_iterator at 0x00000246DB21BC50>\n[20:32:12]Waiting for individual results:\n[20:32:12]                      loiter(3): doing nothing for 3s\n[20:32:12]result 0 : 0\n[20:32:13]      loiter(1): done.\n[20:32:13]                              loiter(4): doing nothing for 4s\n[20:32:13]result 1 : 10\n[20:32:14]              loiter(2): done.\n[20:32:14]result 2 : 20\n[20:32:15]                      loiter(3): done.\n[20:32:15]result 3 : 30\n[20:32:17]                              loiter(4): done.\n[20:32:17]result 4 : 40\n\n不同机器运行结果可能不同。\n示例中设置max_workers=3，所以代码一开始运行，则有三个对象（0,1,2）被执行loiter() 操作; 三秒后，对象0运行结束，得到结果result 0之后，对象3才开始被执行，同理，对象4的执行时间在对象1执行结果result 1打印结束之后。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}