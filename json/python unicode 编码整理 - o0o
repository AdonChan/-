{"title": "python unicode 编码整理 - o0o ", "index": "unicode,python", "content": "unicode 与 utf-8 的关系\nunicode 是 character set\n\ncharacter set 是把每个字符对应成数字的集合，比如unicode中 A对应0041，汉字『我』对应 '6211'\nunicode 是个很大的集合，几乎覆盖世界上所有的字符，现在的规模已经可以容纳100万个字符。\n\nutf-8 是对 unicode 存储的实现方式\nunicode 只定义字符对应的数字，但没有规定这些数字如何存储起来，比如像中文的『我』字存储时需要两个字节来表示，而英文字母A却只需要一个字节，有些其他的字符可能需要3-4个字节。\n\n如果统一规定每个字符用3个或者4个字节来存储，那么每个英文字符都必然需要额外2到3个0，这对存储是很大的浪费。\n如果每个字符按照实际需要的字节数来存储，计算机就分不清三个字节是表示三个字符还是一个字符。\n\nutf-8 是对 unicode 编码存储的一种实现方式，同样的还有 utf-16, utf-32。\nutf-8 是使用最广泛的编码方式，采用变长的编码方式，可以使用1-4个字节来表示一个字符； utf-16 用2个或4个字节，utf-32 用4个字节表示。编码规则如下：\n\n对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母， UTF-8编码和ASCII码是相同的。\n对于n字节的符号（n>1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。\n\npython2 中的 str 和 unicode\npython2 中有字符串类型有两种：byte string (str)和 unicode string (unicode)。\n>>> s = '美的'\n>>> s\n'\\xe7\\xbe\\x8e\\xe7\\x9a\\x84'\n>>> s = u'美的'\n>>> s\nu'\\u7f8e\\u7684'\n>>> s = '美的'\n>>> s.decode('utf-8')\nu'\\u7f8e\\u7684'\n上面的输出中，第一个s的类型是 str，打印出来的内容是 utf-8 编码过的内容。第二个s的类型是 unicode，打印出来的两个双字节的数字分别表示了两个汉字『美的』。\nencode和decode提供 str 和 unicode 这两种的类型的互相转化。\n\nencode 把 unicode 转化成 str(byte string)\ndecode 把 str(byte string) 转化成 unicode\n\n本质上，str是存放的字节序，有可能是 ascii, gbk, utf-8 等等中的任意一种，通过调用 decode 可以把他们转化成 unicode ，默认的 decode 编码是 ascii 。str中到底是用的哪一种编码，取决于它所在的场景，跟 locale ，文件编码等等都有关系。\n文本文件、编辑器的处理\n#!/usr/bin/env python\n# -*- coding: GBK -*-\n\ns = u'中文'\nprint repr(s)\nprint repr(s.encode('GBK'))\n比如上面的文件enc.py，保存的时候选择文件编码是GBK，程序文件本质上也是文件，当我们使用某个外部的应用  打开它时（编辑器或者python解释器等），外部应用是不知道该文件的编码格式的，  \n这个时候有三种情况：\n\n应用使用其默认的编码方式去解析，比如UTF-8或者ASCII；python解释器默认是ASCII，编辑器可以自己设置；\n应用根据文件中的字节内容，自动检测编码方式；\n文本文件告诉应用使用什么编码方式去解码；比如# -*- coding: GBK -*-告知解释器使用GBK来解码；\n\n试验一下，把# -*- coding: GBK -*-删除后，执行python enc.py，输出：\n   File \"enc.py\", line 4\n SyntaxError: Non-ASCII character '\\xd6' in file enc.py on line 4, but no encoding declared;\n试着用vim打开该文件时，『中文』两个字就会显示成乱码，因为vim默认的文件编码方式被设置成UTF-8了。\n#!/usr/bin/env python\n# -*- coding: GBK -*-\n\ns1 = u'中文'\n\nprint repr(s1)\nprint repr(s1.encode('GBK'))\n\ns2 = '中文'\n\nprint repr(s2)\nprint repr(s2.decode('GBK'))\n输出结果：\nu'\\u4e2d\\u6587'\n'\\xd6\\xd0\\xce\\xc4'\n'\\xd6\\xd0\\xce\\xc4'\nu'\\u4e2d\\u6587'\n从这里可以看出来， s2中存放的是byte格式的从文件中读到的GBK编码的内容。\n再看下面的这段代码，程序文件utf8_enc.py，保存成UTF-8编码的。\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\ns1 = u'中文'\n\nprint repr(s1)\nprint repr(s1.encode('GBK'))\n\ns2 = '中文'\n\nprint repr(s2)\nprint repr(s2.decode('GBK'))\n输出：\nu'\\u4e2d\\u6587'\n'\\xd6\\xd0\\xce\\xc4'\n'\\xe4\\xb8\\xad\\xe6\\x96\\x87'\nTraceback (most recent call last):\n  File \"unicode_enc.py\", line 12, in <module>\n    print repr(s2.decode('GBK'))\nUnicodeDecodeError: 'gbk' codec can't decode bytes in position 2-3: illegal multibyte sequence\n这里同样可以知道，s2中存放的是文件保存的编码UTF-8的byte码。\nReferences\nhttp://www.rrn.dk/the-differe...http://www.ruanyifeng.com/blo...https://docs.python.org/2/how...http://yergler.net/2012/bytes...\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "3"}