{"title": "python--面向对象进阶 - python学习 ", "index": "python", "content": "isinstance和issubclass\n1.isinstance(obj,cls)检查是否obj是否是类 cls 的对象\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\nclass Foo:\n    pass\nobj = Foo()\nprint(isinstance(obj,Foo))\n2.issubclass(cls,cls)检查Bar是否是Foo的派生类\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\nclass Foo(object):\n    pass\nclass Bar(Foo):\n    pass\n\nprint(issubclass(Bar,Foo))\n反射\n1.反射：反射的概念是由Smith在1982年首次提出的，主要是指程序可以访问、检测和修改它本身状态或行为的一种能力（自省）。这一概念的提出很快引发了计算机科学领域关于应用反射性的研究。它首先被程序语言的设计领域所采用,并在Lisp和面向对象方面取得了成绩。2.python面向对象中的反射：通过字符串的形式操作对象相关的属性。python中的一切事物都是对象（都可以使用反射）四个可以实现反射的函数：\ndef hasattr(*args, **kwargs): # real signature unknown\n    \"\"\"\n    Return whether the object has an attribute with the given name.\n    \n    This is done by calling getattr(obj, name) and catching AttributeError.\n    \"\"\"\n    pass\n\nhasattr\ndef setattr(x, y, v): # real signature unknown; restored from __doc__\n    \"\"\"\n    Sets the named attribute on the given object to the specified value.\n    \n    setattr(x, 'y', v) is equivalent to ``x.y = v''\n    \"\"\"\n    pass\n\nsetattr\ndef delattr(x, y): # real signature unknown; restored from __doc__\n    \"\"\"\n    Deletes the named attribute from the given object.\n    \n    delattr(x, 'y') is equivalent to ``del x.y''\n    \"\"\"\n    pass\n\ndelattr\n应用：\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\nclass Foo:\n    f = '类的静态变量'\n    def __init__(self,name,age):\n        self.name=name\n        self.age=age\n\n    def say_hi(self):\n        print('hi,%s'%self.name)\n\nobj=Foo('egon',73)\n#1.检查是否含有某属性\nprint(hasattr(obj,\"name\")) #有该属性返回True\nprint(hasattr(obj,\"six\"))  #无该属性返回False\n#2.获取该属性\nn = getattr(obj,\"name\")\nprint(n)\nfunc = getattr(obj,\"say_hi\")\nfunc()\n#3.设置属性\nsetattr(obj,'sb',True)\nsetattr(obj,'show_name',lambda self:self.name+'sb')\nprint(obj.__dict__) #{'name': 'egon', 'age': 73, 'sb': True, 'show_name': <function <lambda> at 0x0020C660>}\nprint(obj.show_name(obj)) #egonsb\n#4.删除属性\ndelattr(obj,'age')\ndelattr(obj,'show_name')\ndelattr(obj,'show_name111')#不存在,则报错\nprint(obj.__dict__)\n类也是一种属性\nclass Foo(object):\n    staticField = \"old boy\"\n\n    def __init__(self):\n        self.name = 'wupeiqi'\n\n    def func(self):\n        return 'func'\n\n    @staticmethod\n    def bar():\n        return 'bar'\n\nprint(getattr(Foo,\"staticField\"))\nprint(getattr(Foo,\"func\"))\nprint(getattr(Foo,\"bar\"))\n模块：\nimport sys\ndef s1():\n    print(\"s1\")\ndef s2():\n    print(\"s2\")\nthis_module = sys.modules[__name__]\n\nprint(hasattr(this_module, 's1')) #True\nprint(getattr(this_module, 's2')) #<function s2 at 0x02793780>\n__str__和,__repr__\n改变对象的字符串显示__str__,__repr__自定制格式化字符串__format__\nformat_dict={\n    'nat':'{obj.name}-{obj.addr}-{obj.type}',#学校名-学校地址-学校类型\n    'tna':'{obj.type}:{obj.name}:{obj.addr}',#学校类型:学校名:学校地址\n    'tan':'{obj.type}/{obj.addr}/{obj.name}',#学校类型/学校地址/学校名\n}\nclass School:\n    def __init__(self,name,addr,type):\n        self.name=name\n        self.addr=addr\n        self.type=type\n\n    def __repr__(self):\n        return 'School(%s,%s)' %(self.name,self.addr)\n    def __str__(self):\n        return '(%s,%s)' %(self.name,self.addr)\n\n    def __format__(self, format_spec):\n        # if format_spec\n        if not format_spec or format_spec not in format_dict:\n            format_spec='nat'\n        fmt=format_dict[format_spec]\n        return fmt.format(obj=self)\n\ns1=School('oldboy1','北京','私立')\nprint('from repr: ',repr(s1))\nprint('from str: ',str(s1))\nprint(s1)\n\n'''\nstr函数或者print函数--->obj.__str__()\nrepr或者交互式解释器--->obj.__repr__()\n如果__str__没有被定义,那么就会使用__repr__来代替输出\n注意:这俩方法的返回值必须是字符串,否则抛出异常\n'''\nprint(format(s1,'nat'))\nprint(format(s1,'tna'))\nprint(format(s1,'tan'))\nprint(format(s1,'asfdasdffd'))\n打印结果：\nfrom repr:  School(oldboy1,北京)\nfrom str:  (oldboy1,北京)\n(oldboy1,北京)\noldboy1-北京-私立\n私立:oldboy1:北京\n私立/北京/oldboy1\noldboy1-北京-私立\n%s和%r的区别\nclass B:\n\n    def __str__(self):\n        return 'str : class B'\n\n    def __repr__(self):\n        return 'repr : class B'\nb = B()\nprint('%s' % b)\nprint('%r' % b)\n#打印结果为：\nstr : class B\nrepr : class B\nitem\n__getitem__\\__setitem__\\__delitem__\nclass Foo:\n    def __init__(self,name):\n        self.name=name\n\n    def __getitem__(self, item):\n        print(self.__dict__[item])\n\n    def __setitem__(self, key, value):\n        self.__dict__[key]=value\n    def __delitem__(self, key):\n        print('del obj[key]时,我执行')\n        self.__dict__.pop(key)\n    def __delattr__(self, item):\n        print('del obj.key时,我执行')\n        self.__dict__.pop(item)\n\nf1=Foo('sb')\nf1['age']=18\nf1['age1']=19\ndel f1.age1\ndel f1['age']\nf1['name']='alex'\nprint(f1.__dict__)\n__new__\nclass A:\n    def __init__(self):\n        self.x = 1\n        print('in init function')\n    def __new__(cls, *args, **kwargs):\n        print('in new function')\n        return object.__new__(A, *args, **kwargs)\n\na = A()\nprint(a.x)\nclass Singleton:\n    def __new__(cls, *args, **kw):\n        if not hasattr(cls, '_instance'):\n            cls._instance = object.__new__(cls, *args, **kw)\n        return cls._instance\n\none = Singleton()\ntwo = Singleton()\n\ntwo.a = 3\nprint(one.a)\n# 3\n# one和two完全相同,可以用id(), ==, is检测\nprint(id(one))\n# 29097904\nprint(id(two))\n# 29097904\nprint(one == two)\n# True\nprint(one is two)\n\n单例模式\n__call__\n对象后面加括号，触发执行。注：构造方法的执行是由创建对象触发的，即：对象 = 类名() ；而对于 call 方法的执行是由对象后加括号触发的，即：对象() 或者 类()()\nclass Foo:\n\n    def __init__(self):\n        pass\n    \n    def __call__(self, *args, **kwargs):\n\n        print('__call__')\n\n\nobj = Foo() # 执行 __init__\nobj()       # 执行 __call__\n__len__\nclass A:\n    def __init__(self):\n        self.a = 1\n        self.b = 2\n\n    def __len__(self):\n        return len(self.__dict__)\na = A()\nprint(len(a))\n__hash__\nclass A:\n    def __init__(self):\n        self.a = 1\n        self.b = 2\n\n    def __hash__(self):\n        return hash(str(self.a)+str(self.b))\na = A()\nprint(hash(a))\n__eq__\nclass A:\n    def __init__(self):\n        self.a = 1\n        self.b = 2\n\n    def __eq__(self,obj):\n        if  self.a == obj.a and self.b == obj.b:\n            return True\na = A()\nb = A()\nprint(a == b)\n逻辑题：\nclass Person:\n    def __init__(self,name,age,sex):\n        self.name = name\n        self.age = age\n        self.sex = sex\n\n    def __hash__(self):\n        return hash(self.name+self.sex)\n\n    def __eq__(self, other):\n        if self.name == other.name and self.sex == other.sex:return True\n\n\np_lst = []\nfor i in range(84):\n    p_lst.append(Person('egon',i,'male'))\n#\n# print(p_lst)\nobj = list(set(p_lst))[0]\nprint(obj.name,obj.age,obj.sex)\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}