{"title": "14.问题详情页面以及添加评论 - 后端开发——Flask初体验 ", "index": "python,flask", "content": "现在在首页我们已经可以看到展示的问题了，我们再设计一个问题的详情页，通过点击问题的标题进去，可以给问题添加评论或者回答。\n\n问题的详情页都使用一个名为'details.html'的模板，其网址我们设计成'/details/<question_id>/'的形式，这时候我们可以用到一开始提到过的url传参，编写对应的视图函数如下：\n@app.route('/details/<question_id>/')\ndef details(question_id):\n    question_obj = Questions.query.filter(Questions.id == question_id).first()\n    return render_template('details.html', question=question_obj)\n这部分代码也很简单，将url的参数question_id传递给函数，函数用question_id返回一个question模型的对象，并将其传递给模板，在模板中处理quesiton对象，包括解析其title/content/author以及对应的comments（在模型部分我们已经建立了Questions和Comments的关系和引用）。为首页问题的title添加链接：\n<p class=\"question-title\"><a href=\"{{ url_for('details',question_id=question.id) }}\">{{ question.title }}</a></p>\n\ndetails.html核心代码（其余部分继承base.html）如下：\n{% block body_part %}\n    <h3 class=\"question-title\">{{ question.title }}</h3>\n    <p class=\"question-info\">\n        <span>作者：{{ question.author.username }}</span>\n        <span>时间：{{ question.create_time }}</span>\n    </p>\n    <hr>\n    <p class=\"question-content\">\n        {{ question.content }}\n    </p>\n    <hr/>\n    <div class=\"comments-list-container\">\n        <ul>\n            <!-- 在模板中排序 -->\n            {# {% for comment in question.comments | sort(attribute='create_time',reverse=true) %}  #}\n\n            <!-- 模型相互关联时排序好 -->\n            {% for comment in question.comments %}\n                <li>\n                    <div class=\"comments-content\">\n                        {{ comment.content }}\n                    </div>\n                    <div class=\"comments-info\" style=\"text-align: right\">\n                        <span>{{ comment.author.username }}</span>\n                        <span>{{ comment.create_time }}</span>\n                    </div>\n                </li>\n                <hr/>\n            {% endfor %}\n        </ul>\n    </div>\n{% endblock %}\n此时还没有添加评论功能，我手动往数据库写了一条评论，来查看html的效果，如下：\n\n我们再添加评论（或者说回答）的功能，其实就是加个POST表单，和注册的逻辑是一样的，为html增加下面的代码，放在问题和评论之间：\n<h4>评论({{ question.comments | length }}):</h4>\n<form method=\"POST\" action=\"\">\n    <div class=\"form-group\">\n        <textarea class=\"form-control\" rows=\"2\" placeholder=\"评论详情\" name=\"comment_desc\"></textarea>\n    </div>\n    <div class=\"form-group\" style=\"text-align: right;\">\n        <button type=\"submit\" class=\"btn btn-primary\">提交</button>\n    </div>\n</form>\n这里用了一个length过滤器来获取comments的数量。修改detail视图函数，为其增加POST方法如下：\n@app.route('/question/', methods=['GET', 'POST'])\ndef question():\n    if request.method == 'GET':\n        return render_template('question.html')\n    else:\n        if hasattr(g, 'user'):\n            question_title = request.form.get('question_title')\n            question_desc = request.form.get('question_desc')\n            author_id = g.user.id\n            new_question = Questions(title=question_title, content=question_desc, author_id=author_id)\n            db.session.add(new_question)\n            db.session.commit()\n            return redirect(url_for('home'))\n        else:\n            flash('请先登录')\n            return redirect(url_for('login'))\n这部分与前面的文章中发布问答的视图函数也是很像的，无需重复讲解，经测试发布评论功能以及可以使用了。最后美化界面如下：\n\n\n补充：由于在前文中我们的Comments模型通过以下代码和Users/Questions都建立了关系：\nauthor = db.relationship('Users', backref=db.backref('comments'))\nquestion = db.relationship('Questions', backref=db.backref('comments', order_by=create_time.desc()))\n我们在新增comment的时候，这条代码：\ncomment = Comments(content=content, question_id=question_id, author_id=g.user.id)\n就可以改成：\ncomment = Comments(content=content)\ncomment.author = g.user\ncomment.question = Questions.query.filter(Questions.id == question_id).first()\n虽然看上去长了，但可能更容易看出模型之间的关系了，anyway，两种方式都是OK的。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}