{"title": "Python Decorator的来龙 - _Zhao ", "index": "设计模式,python", "content": "引言\n本文主要梳理了Python decorator的实现思路，解释了为什么Python decorator是现在这个样子。\n关于代理模式、装饰模式\n设计模式中经常提到的代理模式、装饰模式，这两种叫法实际上是说的同一件事，只是侧重点有所不同而已。\n这两者都是通过在原有对象的基础上封装一层对象，通过调用封装后的对象而不是原来的对象来实现代理/装饰的目的。\n例如：（以Java为例）\npublic class CountProxy implements Count {\n    private CountImpl countImpl;\n\n    public CountProxy(CountImpl countImpl) {\n        this.countImpl = countImpl;\n    }\n\n    @Override\n    public void queryCount() {  \n        System.out.println(\"事务处理之前\");\n        // 调用委托类的方法;\n        countImpl.queryCount();\n        System.out.println(\"事务处理之后\");\n    }\n\n    @Override\n    public void updateCount() {\n        System.out.println(\"事务处理之前\");\n        // 调用委托类的方法;\n        countImpl.updateCount();\n        System.out.println(\"事务处理之后\");\n\n    }\n\n}\n在这个例子中CountProxy是对CountImpl的封装。使用者通过CountProxy.queryCount方法来调用CountImpl.queryCount方法，这被称为代理，即CountProxy是代理类，CountImpl是被代理类。在CountProxy.queryCount方法中，可以在CountImpl.queryCount方法调用之前和之后添加一些额外的操作，被称为装饰，即CountProxy是装饰类，CountImpl是被装饰类。\n如果强调通过CountProxy 对CountImpl进行代理的作用，则称为代理模式；如果强调通过CountProxy 对CountImpl增加额外的操作，则称为装饰模式；\n不论是哪种称呼，其本质都在于对原有对象的封装。其封装的目的在于增强所封装对象的功能或管理所封装的对象。\n从上面的例子也可以发现，代理/封装所围绕的核心是可调用对象（比如函数）。\nPython中的代理/装饰\nPython中的可调用对象包括函数、方法、实现了__call__方法的类。Python中的函数也是对象，可以作为高阶函数的参数传入或返回值返回。因此，当代理/装饰的对象是函数时，可以使用高阶函数来对某个函数进行封装。例如：\ndef query_count_proxy(fun, name, age):\n    print('do something before')\n    rv = fun(name, age)\n    print('do something after')\n    return rv\n\n\ndef query_count(name, age):\n    print('name is %s, age is %d' % (name, age))\n\n\nquery_count_proxy(query_count, 'Lee', 20)\n但是，这个例子中，query_count函数作为参数传入query_count_proxy函数中，并在query_count_proxy函数中被调用，其结果作为返回值返回。这就完成了代理的功能，同时，在调用query_count函数的前后，我们还增加了装饰代码。但是，query_count_proxy的函数参数与query_count不一样了，理想的代理应该保持接口一致才对。\n为了保持一致，我们可以利用高阶函数可以返回函数的特点来完成：\ndef query_count_proxy(fun):\n\n    def wrapper(name, age):\n        print('do something before')\n        rv = fun(name, age)\n        print('do something after')\n        return rv\n\n    return wrapper\n\n\ndef query_count(name, age):\n    print('name is %s, age is %d' % (name, age))\n\n\nquery_count_proxy(query_count)('Lee', 20)\n修改后的例子，query_count_proxy仅负责接受被代理的函数query_count作为参数，同时，返回一个函数对象wrapper作为返回值，真正的封装动作在wrapper这个函数中完成。\n此时，如果调用query_count_proxy(query_count)就得到了wrapper函数对象，则，执行query_count_proxy(query_count)('Lee', 20)就相当于执行了wrapper('Lee', 20)。\n但是可以看到，query_count_proxy(query_count)('Lee', 20)这种使用方法，仍然不能保证一致。\n为了保持一致，我们需要利用Python中对象与其名称可以动态绑定的特点。不使用query_count_proxy(quer_count)('Lee', 20)来调用代理函数，而是使用下面两句：\nquery_count = query_count_proxy(query_count)\nquery_count('Lee', 20)\n执行query_count_proxy(query_count)生成wrapper函数对象，将这个对象通过query_count = query_count_proxy(query_count)绑定到query_count这个名字上来，这样执行query_count('Lee', 20)时，其实执行的是wrapper('Lee', 20)。\n这么做的结果就是：使用代理时调用query_count('Lee', 20)与不使用代理时调用query_count('Lee', 20)对使用者而言保持不变，不用改变代码，但是在真正执行时，使用的是代理/装饰后的函数。\n这里，基本利用Python的高阶函数及名称绑定完成了代理/装饰的功能。还有什么不理想的地方呢？对，就是query_count = query_count_proxy(query_count)，因为这句既不简洁，又属于重复工作。Python为我们提供了语法糖来完成这类的tedious work。方法就是：\n@query_count_proxy\ndef query_count(name, age):\n    return 'name is %s, age is %d' % (name, age)\nquery_count = query_count_proxy(query_count)就等同于在定义query_count函数的时候，在其前面加上@query_count_proxy。\nPython看到这样的语法，就会自动的执行query_count = query_count_proxy(query_count)进行name rebinding\n补充\n以上就是Python实现可调用对象装饰的核心。可调用对象包括函数、方法、实现了__call__方法的类，上述内容只是针对函数来解释，对于方法、实现了__call__方法的类，其基本原理相同，具体实现略有差别。\n本文系作者原创，如有转载请注明出处。由于水平精力有限，如有错误欢迎指正。\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "17"}