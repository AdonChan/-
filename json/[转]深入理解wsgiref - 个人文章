{"title": "[转]深入理解wsgiref - 个人文章 ", "index": "python,wsgi", "content": "原地址：http://cizixs.com/2014/11/09/...\n\n1. 介绍\n要很好地理解下面的代码，最好有一定的 socket 编程基础，了解 socket 的基本概念和流程。\nwsgiref 是 PEP 333 定义的 wsgi 规范的范例实现，里面的功能包括了：\n\n操作 wsgi 的环境变量\n应答头部的处理\n实现简单的 HTTP server\n简单的对程序端和服务器端校验函数\n\n我们先看一个简单的代码实例，然后跟着例子去理解源码：\n1.1 app.py\n# pep333 定义的程序端可调用对象\n\ndef hello_world_app(environ, start_response):\n    status = '200 OK' # HTTP Status\n    headers = [('Content-type', 'text/plain')] # HTTP Headers\n    start_response(status, headers)\n\n    # The returned object is going to be printed\n    return [\"Hello World\"]\n1.2 server.py\nfrom app import hello_world_app\nfrom wsgiref.simple_server import make_server\n\nhttpd = make_server('', 8000, hello_world_app)\nprint \"Serving on port 8000...\"\n\n# Serve until process is killed\nhttpd.serve_forever()\n\n然后执行 python server.py 启动 sever，用 curl 发送一个请求 curl -i http://localhost:8000/，会有以下输出：\nHTTP/1.0 200 OK\nDate: Sat, 08 Nov 2014 09:08:05 GMT\nServer: WSGIServer/0.1 Python/2.7.3\nContent-type: text/plain\nContent-Length: 12\n\nHello World\n\nserver 的终端会有一条记录：\nServing on port 8000...\nlocalhost - - [08/Nov/2014 09:08:05] \"GET / HTTP/1.1\" 200 12\n\n2. 源码分析\n你可以使用 python -c 'import wsgiref; help(wsgiref)' 查看 wsgiref 库的路径和简介等信息，wsgiref 文件夹的结构如下：\nwsgiref\n    |-- handlers.py            # 核心代码，负责 wsgi 程序的处理\n    |-- headers.py             # 头部处理的代码\n    |-- __init__.py            # \n    |-- simple_server.py       # 简单的 wsgi HTTP 服务器实现\n    |-- util.py                # 帮助函数\n    `-- validate.py            # wsgi 格式检查和校验\n\n主要的代码结构如下图所示：\n2.1 simple_server.py\n我们先看一下 make_server 是怎么启动一个 wsgi 服务器的：\ndef make_server(host, port, app, server_class=WSGIServer, handler_class=WSGIRequestHandler):\n    server = server_class((host, port), handler_class)\n    server.set_app(app)\n    return server\n这个函数做的事情就是：监听在本地的端口上，接受来自客户端的请求，通过 WSGIServer 和 WSGIRequestHandler 处理后，把请求交给程序的的可调用对象 app，然后返回 app 的结果给客户端。\n这里有两个重要的类：WSGIServer 和 WSGIRequestHandler。下面分别看一下它们的代码和执行的功能。\n2.2 WSGIServer\nclass WSGIServer(HTTPServer):\n\n    \"\"\"BaseHTTPServer that implements the Python WSGI protocol\"\"\"\n\n    application = None\n\n    def server_bind(self):\n        \"\"\"Override server_bind to store the server name.\"\"\"\n        HTTPServer.server_bind(self)\n        self.setup_environ()\n\n    def setup_environ(self):\n        # Set up base environment\n        env = self.base_environ = {}\n        env['SERVER_NAME'] = self.server_name\n        env['GATEWAY_INTERFACE'] = 'CGI/1.1'\n        env['SERVER_PORT'] = str(self.server_port)\n        env['REMOTE_HOST']=''\n        env['CONTENT_LENGTH']=''\n        env['SCRIPT_NAME'] = ''\n\n    def get_app(self):\n        return self.application\n\n    def set_app(self,application):\n        self.application = application\nWSGIServer 在原来的 HTTPServer 上面封装了一层，在原来的 HTTPServer 的基础上又额外做了下面的事情：\n\n覆写原来的 server_bind 函数，添加初始化 environ 变量的动作\n添加了处理满足 wsgi 的 app 函数：set_app 和 get_app\n\n2.3 WSGIRequestHandler\nclass WSGIRequestHandler(BaseHTTPRequestHandler):\n\n    server_version = \"WSGIServer/\" + __version__\n\n    def get_environ(self):\n        env = self.server.base_environ.copy()\n        env['SERVER_PROTOCOL'] = self.request_version\n        env['REQUEST_METHOD'] = self.command\n        if '?' in self.path:\n            path,query = self.path.split('?',1)\n        else:\n            path,query = self.path,''\n\n        env['PATH_INFO'] = urllib.unquote(path)\n        env['QUERY_STRING'] = query\n\n        host = self.address_string()\n        if host != self.client_address[0]:\n            env['REMOTE_HOST'] = host\n        env['REMOTE_ADDR'] = self.client_address[0]\n\n        if self.headers.typeheader is None:\n            env['CONTENT_TYPE'] = self.headers.type\n        else:\n            env['CONTENT_TYPE'] = self.headers.typeheader\n\n        length = self.headers.getheader('content-length')\n        if length:\n            env['CONTENT_LENGTH'] = length\n\n        for h in self.headers.headers:\n            k,v = h.split(':',1)\n            k=k.replace('-','_').upper(); v=v.strip()\n            if k in env:\n                continue                    # skip content length, type,etc.\n            if 'HTTP_'+k in env:\n                env['HTTP_'+k] += ','+v     # comma-separate multiple headers\n            else:\n                env['HTTP_'+k] = v\n        return env\n\n    def get_stderr(self):\n        return sys.stderr\n\n    def handle(self):\n        \"\"\"Handle a single HTTP request\"\"\"\n\n        self.raw_requestline = self.rfile.readline()\n        if not self.parse_request(): # An error code has been sent, just exit\n            return\n\n        handler = ServerHandler(\n            self.rfile, self.wfile, self.get_stderr(), self.get_environ()\n        )\n        handler.request_handler = self      # backpointer for logging\n        handler.run(self.server.get_app())\n这个类从名字就能知道它的功能——处理客户端的 HTTP 请求，它也是在原来处理 http 请求的BaseHTTPRequestHandler 类上添加了 wsgi 规范相关的内容。\n\nget_environ： 解析 environ 变量\nhandle： 处理请求，把封装的环境变量交给 ServerHandler，然后由 ServerHandler 调用 wsgi app，ServerHandler 类会在下面介绍。\n\n2.4 handler.py\n这个文件主要是 wsgi server 的处理过程，定义 start_response、调用 wsgi app 、处理 content-length 等等。\n2.5 UML类图\n\n3. 一条 HTTP 请求的过程\n服务器端启动服务，等到客户端输入 curl -i http://localhost:8000/ 命令，摁下回车键，看到终端上的输出，整个过程中，wsgi 的服务器端发生了什么呢？\n\n服务器程序创建 socket，并监听在特定的端口，等待客户端的连接\n客户端发送 http 请求\nsocket server 读取请求的数据，交给 http server\nhttp server 根据 http 的规范解析请求，然后把请求交给 WSGIServer\nWSGIServer 把客户端的信息存放在 environ 变量里，然后交给绑定的 handler 处理请求\nHTTPHandler 解析请求，把 method、path 等放在 environ，然后 WSGIRequestHandler 把服务器端的信息也放到 environ 里\nWSGIRequestHandler 调用绑定的 wsgi ServerHandler，把上面包含了服务器信息，客户端信息，本次请求信息得 environ 传递过去\nwsgi ServerHandler 调用注册的 wsgi app，把 environ 和 start_response 传递过去\nwsgi app 将reponse header、status、body 回传给 wsgi handler\n然后 handler 逐层传递，最后把这些信息通过 socket 发送到客户端\n客户端的程序接到应答，解析应答，并把结果打印出来。\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}