{"title": "关于WEB前后端分离的要点总结（上） - 个人文章 ", "index": "python", "content": "前言\n对于前后端分离大家可能在网上可以找到很多的文章。但是，我们今天分享的文章的英文我们的老师对于前后端的分离问题的多年工作经验的总结。今天，我们把这些经验总结知识点分享给大家，希望可以帮助到大家。\n内容要点\n\n接口格式\n增，删，改，查及分页\n跨域\nACL访问控制\n令牌认证\n\n接口格式\n路由格式：\n/ API / <模块> /\n示例：\n/ API /资产/\n/ API / DNS /\n/ API /监视器/\n返回格式：\n0表示请求成功，非0表示请求异常\n{u'message': u'ERROR_PROXY_AUTH_FAILED', u'code': -97}\n{u'message': u'SUCCESS', u'code': 0}\n增，删，改，查及分页\n采用django-rest-framework框架提供后端接口服务;\n示例：\n# -*- coding: UTF-8 -*-\n\nclass StandardResultsSetPagination(pagination.PageNumberPagination):\n    # 覆盖 settings 中的默认分页\n    page_size = 10\n    # page_size_query_param = 'page'\n\n    # 限制最大分页大小\n    max_page_size = 10\nclass BaseManageView(generics.ListAPIView):\n    serializer_class = TbRecordsSerializer\n    model = TbRecords\n    queryset = TbRecords.objects.all()\n    pagination_class = StandardResultsSetPagination\n\n    parser_classes = (JSONParser,)\n\n    def get_object(self, pk):\n        try:\n            return TbRecords.objects.get(pk=pk)\n        except TbRecords.DoesNotExist:\n            raise Http404\n\n    def get(self, request, *args, **kwargs):\n        # 分页\n        return super(DnsManageView, self).get(request, *args, **kwargs)\n\n    def get_queryset(self):\n        # 条件搜索\n        queryset = super(DnsManageView, self).get_queryset()\n        queryset = self.get_queryset_search(queryset)\n        return queryset\n\n    def get_queryset_search(self, queryset):\n        queryset = queryset.objects.filter(update_time=F('update_time') + 8)\n        return queryset\n\n    def post(self, request):\n        # 添加\n        data = self._parseRequest(request.body)\n\n        pass\n\n        return apiSucess(\"SUCCESS\", 200)\n\n    def put(self, request):\n        # 修改\n        data = self._parseRequest(request.body)\n\n        pass\n\n        return apiSucess(\"SUCCESS\", 200)\n\n    def delete(self, request, pk):\n        # 删除\n        obj = self.get_object(pk)\n        obj.delete()\n        return apiSucess(\"SUCCESS\", 204)\n\n    def options(self, request):\n        # 非分页\n        data = TbRecords.objects.values()\n        return apiSucess(data, 200)\n\n    def _parseRequest(self, querydict_obj):\n        # 解析已提交的数据\n        params = QueryDict(querydict_obj).dict()\n        if isinstance(params, dict):\n            if len(params) == 1:\n                data = json.loads(params.keys()[0])\n            else:\n                data = params\n        elif isinstance(params, list):\n            pass\n        else:\n            pass\n\n        return data\n跨域\n1，通过NGINX的方式\n通过在NGINX代理添加标题的方式\nserver {\n    add_header Access-Control-Allow-Origin *;  \n    add_header Access-Control-Allow-Headers X-Requested-With;  \n    add_header Access-Control-Allow-Methods GET,POST,OPTIONS;    \n}\n2，通过后端服务方式\n修改project_name / settings.py文件。\n（1）添加。\nINSTALLED_APPS添加corsheaders\n（2）开启黑白名单，任选其一。\nCORS_ORIGIN_ALLOW_ALL = True\nCORS_ORIGIN_WHITELIST = (\n     '*',\n     'localhost:8000',\n     '127.0.0.1:9000',\n)\nACL访问控制\n针对主机的权限控制\n示例：\n# -*- coding: UTF-8 -*-\n\nimport functools\nfrom rest_framework import status\nfrom rest_framework.response import Response\n\n# 允许的白名单IP地址\nALLECT_ADDR_POOL = (\n                   '127.0.0.1', \n                   ) \n\ndef AclHost(func):\n    def wrapper(request, *args, **kwargs):\n        username = request.request.user\n        method = request.request.method\n        if request.request.META.has_key('HTTP_X_FORWARDED_FOR'):\n            remote_addr = request.request.META['HTTP_X_FORWARDED_FOR']  \n        else:\n            remote_addr = request.request.META['REMOTE_ADDR']\n\n    # 有多层代理\n        if remote_addr.count(',') >=1:\n            remote_addr = remote_addr.split(',')[-1].strip()\n        if remote_addr not in ALLECT_ADDR_POOL:\n            data = {'result' : {'username' : username, 'method' : method, 'remote_addr' : remote_addr}, \"errmsg\" : 'FORBIDDEN'}\n            return Response(data, status=status.HTTP_403_FORBIDDEN) \n        return func(request, *args, **kwargs)\n    return functools.wraps(func)(wrapper)\n令牌认证\n针对Token的权限控制\n创建用户自动生成Token，基于Token的路由的访问。\n示例：\n（1）djuser / models.py\n# -*- coding: UTF-8 -*-\nfrom django.conf import settings\nfrom django.db.models.signals import post_save\nfrom django.dispatch import receiver\nfrom rest_framework.authtoken.models import Token\nfrom django.contrib.auth.models import User\n\n# 针对新创建的用户生成token\n@receiver(post_save, sender=User)\ndef create_auth_token(sender, instance=None, created=False, **kwargs):\n    if created:\n        Token.objects.create(user=instance)\n\n（2）djuser / views.py\nfrom rest_framework.authentication import SessionAuthentication, BasicAuthentication, TokenAuthentication \nfrom rest_framework.permissions import IsAuthenticated\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\n\nclass UserManager(APIView):\n\n    # Token验证\n    authentication_classes = (SessionAuthentication, TokenAuthentication)\n    permission_classes = (IsAuthenticated,)\n\n    def get(self, request, format=None):\n        content = {\n            'user': unicode(request.user),  # `django.contrib.auth.User` instance.\n            'auth': unicode(request.auth),  # None\n        }\n        return Response(content)\n原文链接\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}