{"title": "scrapy 实战练习 - 太不白的学习频道 ", "index": "爬虫图片,网络爬虫,scrapy,python", "content": "前一篇文章介绍了很多关于scrapy的进阶知识，不过说归说，只有在实际应用中才能真正用到这些知识。所以这篇文章就来尝试利用scrapy爬取各种网站的数据。\n爬取百思不得姐\n首先一步一步来，我们先从爬最简单的文本开始。这里爬取的就是百思不得姐的的段子，都是文本。\n首先打开段子页面，用F12工具查看元素。然后用下面的命令打开scrapy  shell。\nscrapy shell http://www.budejie.com/text/\n稍加分析即可得到我们要获取的数据，在介绍scrapy的第一篇文章中我就写过一次了。这次就给上次那个爬虫加上一个翻页功能。\n要获取的是用户名和对应的段子，所以在items.py中新建一个类。\nclass BudejieItem(scrapy.Item):\n    username = scrapy.Field()\n    content = scrapy.Field()\n爬虫本体就这样写，唯一需要注意的就是段子可能分为好几行，这里我们要统一合并成一个大字符串。选择器的extract()方法默认会返回一个列表，哪怕数据只有一个也是这样。所以如果数据是单个的，使用extract_first()方法。\nimport scrapy\nfrom scrapy_sample.items import BudejieItem\n\n\nclass BudejieSpider(scrapy.Spider):\n    \"\"\"百思不得姐段子的爬虫\"\"\"\n    name = 'budejie'\n    start_urls = ['http://www.budejie.com/text/']\n    total_page = 1\n\n    def parse(self, response):\n        current_page = int(response.css('a.z-crt::text').extract_first())\n        lies = response.css('div.j-r-list >ul >li')\n        for li in lies:\n            username = li.css('a.u-user-name::text').extract_first()\n            content = '\\n'.join(li.css('div.j-r-list-c-desc a::text').extract())\n            yield BudejieItem(username=username, content=content)\n        if current_page < self.total_page:\n            yield scrapy.Request(self.start_urls[0] + f'{current_page+1}')\n导出到文件\n利用scrapy内置的Feed功能，我们可以非常方便的将爬虫数据导出为XML、JSON和CSV等格式的文件。要做的只需要在运行scrapy的时候用-o参数指定导出文件名即可。\nscrapy crawl budejie -o f.json\nscrapy crawl budejie -o f.csv\nscrapy crawl budejie -o f.xml\n如果出现导出汉字变成Unicode编码的话，需要在配置中设置导出编码。\nFEED_EXPORT_ENCODING = 'utf-8'\n保存到MongoDB\n有时候爬出来的数据并不想放到文件中，而是存在数据库中。这时候就需要编写管道来处理数据了。一般情况下，爬虫只管爬取数据，数据是否重复是否有效都不是爬虫要关心的事情。清洗数据、验证数据、保存数据这些活，都应该交给管道来处理。当然爬个段子的话，肯定是用不到清洗数据这些步骤的。这里用的是pymongo，所以首先需要安装它。\npip install pymongo\n代码其实很简单，用scrapy官方文档的例子稍微改一下就行了。由于MongoDB的特性，所以这部分代码几乎是无缝迁移的，如果希望保存其他数据，只需要改一下配置就可以了，其余代码部分几乎不需要更改。\nimport pymongo\n\n\nclass BudejieMongoPipeline(object):\n    \"将百思不得姐段子保存到MongoDB中\"\n    collection_name = 'jokes'\n\n    def __init__(self, mongo_uri, mongo_db):\n        self.mongo_uri = mongo_uri\n        self.mongo_db = mongo_db\n\n    @classmethod\n    def from_crawler(cls, crawler):\n        return cls(\n            mongo_uri=crawler.settings.get('MONGO_URI'),\n            mongo_db=crawler.settings.get('MONGO_DATABASE', 'budejie')\n        )\n\n    def open_spider(self, spider):\n        self.client = pymongo.MongoClient(self.mongo_uri)\n        self.db = self.client[self.mongo_db]\n\n    def close_spider(self, spider):\n        self.client.close()\n\n    def process_item(self, item, spider):\n        self.db[self.collection_name].insert_one(dict(item))\n        return item\n这个管道需要从配置文件中读取数据库信息，所以还需要在settings.py中增加以下几行。别忘了在ITEM_PIPELINES中吧我们的管道加进去。\nMONGO_URI = 'mongodb://localhost:27017/'\nMONGO_DATABASE = 'budejie'\n\nITEM_PIPELINES = {\n    'scrapy.pipelines.images.ImagesPipeline': 1,\n    'scrapy_sample.pipelines.BudejieMongoPipeline': 2\n}\n最后运行一下爬虫，应该就可以看到MongoDB中保存好的数据了。这里我用的MongoDB客户端是Studio 3T，我个人觉得比较好用的一个客户端。\nscrapy crawl budejie\n\n保存到SQL数据库\n原来我基本都是用MySQL数据库，不过重装系统之后，我选择了另一个非常流行的开源数据库PostgreSQL。这里就将数据保存到PostgreSQL中。不过说起来，SQL数据库确实更加麻烦一些。MongoDB基本上毫无配置可言，一个数据库、数据集合不需要定义就能直接用，如果没有就自动创建。而SQL的表需要我们手动创建才行。\n首先需要安装PostgreSQL的Python驱动程序。\npip install Psycopg2\n然后建立一个数据库test和数据表joke。在PostgreSQL中自增主键使用SERIAL来设置。\nCREATE TABLE joke (\n  id      SERIAL PRIMARY KEY,\n  author  VARCHAR(128),\n  content TEXT\n);\n管道基本上一样，只不过将插入数据换成了SQL形式的。由于默认情况下需要手动调用commit()函数才能提交数据，于是我索性打开了自动提交。\nimport psycopg2\n\n\nclass BudejiePostgrePipeline(object):\n    \"将百思不得姐段子保存到PostgreSQL中\"\n\n    def __init__(self):\n        self.connection = psycopg2.connect(\"dbname='test' user='postgres' password='12345678'\")\n        self.connection.autocommit = True\n\n    def open_spider(self, spider):\n        self.cursor = self.connection.cursor()\n\n    def close_spider(self, spider):\n        self.cursor.close()\n        self.connection.close()\n\n    def process_item(self, item, spider):\n        self.cursor.execute('insert into joke(author,content) values(%s,%s)', (item['username'], item['content']))\n        return item\n别忘了将管道加到配置文件中。\nITEM_PIPELINES = {\n    'scrapy.pipelines.images.ImagesPipeline': 1,\n    'scrapy_sample.pipelines.BudejiePostgrePipeline': 2\n}\n再次运行爬虫，就可以看到数据成功的放到PostgreSQL数据库中了。\n以上就是抽取文本数据的例子了。虽然我只是简单的爬了百思不得姐，不过这些方法可以应用到其他方面，爬取更多更有用的数据。这就需要大家探索了。\n爬美女图片\n爬妹子图网站\n说完了抽取文本，下面来看看如何下载图片。这里以妹子图为例说明一下。\n首先定义一个图片Item。scrapy要求图片Item必须有image_urls和images两个属性。另外需要注意这两个属性类型都必须是列表，我就因为没有将image_urls设置为列表而卡了好几个小时。\nclass ImageItem(scrapy.Item):\n    image_urls = scrapy.Field()\n    images = scrapy.Field()\n然后照例对网站用F12和scrapy shell这两样工具进行测试，找出爬取图片的方式。这里我只是简单的爬取一个页面的上的图片，不过只要熟悉了scrapy可以很快的修改成跨越多页爬取图片。再次提醒，爬虫中生成Item的时候切记image_urls属性是一个列表，就算只有一个URL也得是列表。\nimport scrapy\nfrom scrapy_sample.items import ImageItem\n\n\nclass MeizituSpider(scrapy.Spider):\n    name = 'meizitu'\n    start_urls = ['http://www.meizitu.com/a/5501.html']\n\n    def parse(self, response):\n        yield ImageItem(image_urls=response.css('div#picture img::attr(src)').extract())\n然后在配置文件中添加图片管道的设置，还需要设置图片保存位置，不然scrapy仍然会禁用图片管道。\nITEM_PIPELINES = {\n    'scrapy.pipelines.images.ImagesPipeline': 1,\n}\nIMAGES_STORE = 'images'\n然后运行爬虫，就可以看到图片已经成功保存到本地了。\nscrapy crawl meizitu\n\n重写图片管道\n从上面的图中我们可以看到文件名是一堆乱码字符，因为默认的图片管道会将图片地址做SHA1哈希之后作为文件名。如果我们希望自定义文件名，就需要自己继承图片管道并重写file_path方法。\n先将默认的file_path方法贴出来。\n    def file_path(self, request, response=None, info=None):\n\n        # check if called from image_key or file_key with url as first argument\n        if not isinstance(request, Request):\n            url = request\n        else:\n            url = request.url\n\n        image_guid = hashlib.sha1(to_bytes(url)).hexdigest()  # change to request.url after deprecation\n        return 'full/%s.jpg' % (image_guid)\n下面是我们的自定义图片管道，这里获取图片URL的最后一部分作为图片文件名，例如对于/123.JPG，就获取123.jpg作为文件名。\nimport scrapy.pipelines.images\nfrom scrapy.http import Request\n\n\nclass RawFilenameImagePipeline(scrapy.pipelines.images.ImagesPipeline):\n    def file_path(self, request, response=None, info=None):\n        if not isinstance(request, Request):\n            url = request\n        else:\n            url = request.url\n        beg = url.rfind('/') + 1\n        end = url.rfind('.')\n        if end == -1:\n            return f'full/{url[beg:]}.jpg'\n        else:\n            return f'full/{url[beg:end]}.jpg'\n如果文件名生成规则更加复杂，可以参考znns项目中的pipeline编写。他这里要根据路径生成多级文件夹保存图片，所以他的图片Item需要额外几个属性设置图片分类等。这时候就需要重写get_media_requests方法，从image_urls获取图片地址请求的时候用Request的meta属性将对应的图片Item也传进去，这样在生成文件名的时候就可以读取meta属性来确定图片的分类等信息了。\nclass ZnnsPipeline(ImagesPipeline):\n    def get_media_requests(self, item, info):\n        for image_url in item['image_urls']:\n            yield Request(image_url, meta={'item': item}, headers=headers)\n            # 这里把item传过去，因为后面需要用item里面的书名和章节作为文件名\n\n    def item_completed(self, results, item, info):\n        image_paths = [x['path'] for ok, x in results if ok]\n        if not image_paths:\n            raise DropItem(\"Item contains no images\")\n        return item\n\n    def file_path(self, request, response=None, info=None):\n        item = request.meta['item']\n        image_guid = request.url.split('/')[-1]\n        filename = u'full/{0[name]}/{0[albumname]}/{1}'.format(item, image_guid)\n        return filename\n最后要说一点，如果不需要使用图片管道的几个功能，完全可以改为使用文件管道。因为图片管道会尝试将所有图片都转换成JPG格式的，你看源代码的话也会发现图片管道中文件名类型直接写死为JPG的。所以如果想要保存原始类型的图片，就应该使用文件管道。\n爬取mm131网站\nmm131是另一个图片网站，为什么我要说这个网站呢？因为这个网站使用了防盗链技术。对于妹子图网站来说，由于它没有防盗链功能，所以我们从HTML中获取的图片地址就是实际的图片地址。但是对于有反盗链的网站来说，当你顺着图片URL去下载图片的时候，会被重定向到一个无关的图片。因为这个原因，另外浏览器有缓存机制导致我直接访问图片地址的时候会先返回缓存的图片，导致我浪费好几个小时。最后我刷新浏览器的时候才发现原来被重定向了。\n对于这种情况，需要我们研究怎样才能访问到图片。使用Scrapy框架时 普通反爬虫机制的应对策略这篇文章列举了一些常见的策略。我们要做的就是根据这些策略进行尝试。现在我用的是火狐浏览器，它的F12工具很好用，其中有一个编辑和重发功能可以方便的帮助我们定位问题。\n\n\n\n在上面几张图中，我们可以看到直接尝试访问图片会得到302，然后被重定向到一个腾讯logo上。但是在添加了Referer之后，成功获得了图片。所以问题就是Referer了。这里简单介绍一下Referer，它其实是Referrer的误拼写。当我们从一个页面点击进入另一个页面时，后者的Referer就是前者。所以有些网站就利用Referer做判断，如果检测是由另一个网页进来的，那么正常访问，如果直接访问图片等资源没有Referer，就判断为爬虫，拒绝请求。这种情况下的解决办法也很简单，既然网站要Referer，我们手动加上不就行了吗。\n首先，对于图片Item，新增一个referer字段，用于保存该图片的Referer。\nclass ImageItem(scrapy.Item):\n    image_urls = scrapy.Field()\n    images = scrapy.Field()\n    referer = scrapy.Field()\n然后在爬虫里面，抓取图片实际地址的时候，同时设置当前网页作为Referer。\nimport scrapy\nfrom scrapy_sample.items import ImageItem\n\n\nclass Mm131Spider(scrapy.Spider):\n    name = 'mm131'\n\n    start_urls = ['http://www.mm131.com/xinggan/3473.html',\n                  'http://www.mm131.com/xinggan/2746.html',\n                  'http://www.mm131.com/xinggan/3331.html']\n\n    def parse(self, response):\n        total_page = int(response.css('span.page-ch::text').extract_first()[1:-1])\n        current_page = int(response.css('span.page_now::text').extract_first())\n        item = ImageItem()\n        item['image_urls'] = response.css('div.content-pic img::attr(src)').extract()\n        item['referer'] = response.url\n        yield item\n        if response.url.rfind('_') == -1:\n            head, sep, tail = response.url.rpartition('.')\n        else:\n            head, sep, tail = response.url.rpartition('_')\n        if current_page < total_page:\n            yield scrapy.Request(head + f'_{current_page+1}.html')\n最后还需要重写图片管道的get_media_requests方法。我们先来看看图片管道基类中是怎么写的。self.images_urls_field在这几行前面设置的，scrapy会尝试先从配置文件中读取自定义的图片URL属性，获取不到就使用默认的。然后在用图片URL属性从item中获取url，然后传递给Request构造函数组装为一个Request列表，后续下载器就会用这些请求来下载图片。\n    def get_media_requests(self, item, info):\n        return [Request(x) for x in item.get(self.images_urls_field, [])]\n恰好我们要做的事情很简单，就是遍历一遍这个Request列表，在每个Request上加上Referer请求头就行了。所以实际上代码超级简单。我们调用基类的实现，也就是上面这个，然后遍历一边再返回即可。\nclass RefererImagePipeline(ImagesPipeline):\n    def get_media_requests(self, item, info):\n        requests = super().get_media_requests(item, info)\n        for req in requests:\n            req.headers.appendlist(\"referer\", item['referer'])\n        return requests\n最后启用这个管道。\nITEM_PIPELINES = {\n    # 'scrapy.pipelines.images.ImagesPipeline': 1,\n    'scrapy_sample.pipelines.RefererImagePipeline': 2\n}\n运行一下爬虫，这次可以看到，成功下载到了一堆图片。\nscrapy crawl mm131\n当然你也可以关掉这个管道，然后运行看看，会发现终端里一堆重定向错误，无法下载图片。\n\n这仅仅是一个例子，实际上很多网站可能综合使用多种技术来检测爬虫，这样我们的爬虫也需要多种办法结合来反爬虫。这个网站恰好只使用了Referer，所以我们只用Referer就能解决。\n备份CSDN上所有文章\n最后一个例子就来爬取CSDN上所有文章，其实在我的scrapy练习中很早就有一个简单的例子，不过那个是在未登录的情况下获取所有文章的名字和链接。这里我要做的是登录CSDN账号，然后把所有文章爬下来保存成文件，也就是演示一下如何用scrapy模拟登录过程。\n为什么要选择CSDN呢？其实也很简单，因为现在POST明文用户名和密码还不需要验证码就能登录的网站真的不多了啊！当然用CSDN的同学也不用怕，虽然CSDN传递的是明文密码，但是由于使用了HTTPS，所以安全性还是可以的。\n翻了翻以前写的文章，发现我确实写过模拟CSDN登录的文章Python登录并获取CSDN博客所有文章列表，不过运行了一下我发现CSDN页面经过改版，有些地方变了，所以还是需要重新研究一下。需要注意HTTPS传输是不会出现在浏览器F12工具中的，只有HTTP传输才能在工具中捕获。所以这时候需要用Fiddler来研究。\n不过实际上我又研究了半天，发现其实CSDN登录过程没变化，我只要把原来写的一个多余的验证函数删了马上又可以正常运行了……这里是我原来的CSDN模拟登录代码，用BeautifulSoup4和requests写的。\n又耗费了几个小时终于把这个爬虫写完了，其实编码过程真的没费多少时间。主要是由于我对Python语言还是属于速成的，很多细节没掌握。比方说scrapy如何用回调方法来分别解析不同页面、回调方法如何传递数据、写文件的时候没有检查目录是否存在、文件应该用什么模式写入、如何以UTF-8编码写文件、目录分隔符如何处理等等，其实都是一些小问题，不过一个一个解决真的废了我不少事情。\n首先，照例定义一个Item，因为我只准备简单下载文章，所以只需要标题和内容两个属性即可，标题会作为文件名来使用。\nclass CsdnBlogItem(scrapy.Item):\n    title = scrapy.Field()\n    content = scrapy.Field()\n然后是爬虫本体，这是我目前写过的最复杂的一个爬虫，确实费了不少时间。这个爬虫跨越了多个页面，还要针对不同页面解析不同的数据。不过虽然看着复杂，其实倒是也很简单。首先是初始方法，从命令行获取CSDN登录用户名和密码，然后存起来备用。由于需要用户登录，所以parse方法的作用就从解析页面变成了用户登录。具体登录过程在我原来那篇文章中详细解释过了。这里就是简单的利用FormRequest.from_response方法将用户名、密码以及页面中的隐藏表单域一起提交。需要注意的就是callback参数，它表示页面返回的请求会有另一个方法来处理。\n然后是redirect_to_articles方法，本来浏览器登录成功的话，会返回一个重定向页面，浏览器会执行其中的JS代码重定向到CSDN页面。不过我们这是爬虫，完全没有执行JS代码的功能。实际上我们也完全不用在意这个重定向过程，既然登陆成功，有了Cookie，我们想访问什么页面都可以。所以这里同样直接生成一个新请求访问文章页面，然后用callback参数指定get_all_articles作为回调。\n从get_all_articles方法开始，我们就开始解析页面了。这个方法首先查询总共有多少页，而且由于csdn服务器是REST形式的，所以我们可以直接将文章页面基地址和文章页数拼起来生成所有的页面。在这些页面中，每一页上都有一些文章链接，我们点进去就能访问实际文章了。生成所有页面的链接之后，我们同样设置回调，将这些页面交给parse_article_links方法处理。\nimport scrapy\nfrom scrapy import FormRequest\nfrom scrapy import Request\nfrom scrapy_sample.items import CsdnBlogItem\n\n\nclass CsdnBlogBackupSpider(scrapy.Spider):\n    name = 'csdn_backup'\n    start_urls = ['https://passport.csdn.net/account/login']\n    base_url = 'http://write.blog.csdn.net/postlist/'\n    get_article_url = 'http://write.blog.csdn.net/mdeditor/getArticle?id='\n\n    def __init__(self, name=None, username=None, password=None, **kwargs):\n        super(CsdnBlogBackupSpider, self).__init__(name=name, **kwargs)\n        if username is None or password is None:\n            raise Exception('没有用户名和密码')\n        self.username = username\n        self.password = password\n\n    def parse(self, response):\n        lt = response.css('form#fm1 input[name=\"lt\"]::attr(value)').extract_first()\n        execution = response.css('form#fm1 input[name=\"execution\"]::attr(value)').extract_first()\n        eventid = response.css('form#fm1 input[name=\"_eventId\"]::attr(value)').extract_first()\n        return FormRequest.from_response(\n            response,\n            formdata={\n                'username': self.username,\n                'password': self.password,\n                'lt': lt,\n                'execution': execution,\n                '_eventId': eventid\n            },\n            callback=self.redirect_to_articles\n        )\n\n    def redirect_to_articles(self, response):\n        return Request(CsdnBlogBackupSpider.base_url, callback=self.get_all_articles)\n\n    def get_all_articles(self, response):\n        import re\n        text = response.css('div.page_nav span::text').extract_first()\n        total_page = int(re.findall(r'共(\\d+)页', text)[0])\n        for i in range(1, total_page + 1):\n            yield Request(CsdnBlogBackupSpider.base_url + f'0/0/enabled/{i}', callback=self.parse_article_links)\n\n    def parse_article_links(self, response):\n        article_links = response.xpath('//table[@id=\"lstBox\"]/tr[position()>1]/td[1]/a[1]/@href').extract()\n        last_index_of = lambda x: x.rfind('/')\n        article_ids = [link[last_index_of(link) + 1:] for link in article_links]\n        for id in article_ids:\n            yield Request(CsdnBlogBackupSpider.get_article_url + id, callback=self.parse_article_content)\n\n    def parse_article_content(self, response):\n        import json\n        obj = json.loads(response.body, encoding='UTF8')\n        yield CsdnBlogItem(title=obj['data']['title'], content=obj['data']['markdowncontent'])\n在parse_article_links方法中，我们获取每一页上的所有文章，将文章ID抽出来，然后和这个地址'http://write.blog.csdn.net/mdeditor/getArticle?id='拼起来。这是我编辑CSDN文章的时候从浏览器中抓出来的一个地址，它会返回一个JSON字符串，包含文章标题、内容、Markdown文本等各种信息。同样地，我们用parse_article_content回调函数来处理这个新请求。\n下面就是最后一步了，在parse_article_content方法中做的事情很简单，将JSON字符串转换成Python对象，然后把我们需要的属性拿出来。需要交给管道处理的Item对象，也是在这最后一步生成。当然除了用这么多回调函数来处理，我们还可以在一个函数中手动生成请求并处理响应。\n这种通过多个回调函数来处理请求的方式，在编写复杂的爬虫中是很常见的。例如我们要爬一个美女图片网站，这个网站中每个美女都有好几个图集，每个图集有好几页，每页好几张图。如果我们希望按照分类和图集来生成目录并保存，那么不仅需要多个回调函数来爬取，还需要将图集、分类等信息跨越多个回调函数传递给最终生成Item的函数。这时候需要利用Request构造函数中的meta属性，这里是一个例子，具体代码大家自己看就行了。\n最后就是文章保存管道了。这里没什么技术难点，不过让我这个以前没弄过这玩意的人来写，确实费了不少功夫。首先检测目录是否存在，如果不存在则创建之。假如目录不存在的话，open函数就会失败。然后就是用UTF8编码保存文章。\nclass CsdnBlogBackupPipeline(object):\n    def process_item(self, item, spider):\n        dirname = 'blogs'\n        import os\n        import codecs\n        if not os.path.exists(dirname):\n            os.mkdir(dirname)\n        with codecs.open(f'{dirname}{os.sep}{item[\"title\"]}.md', 'w', encoding='utf-8') as f:\n            f.write(item['content'])\n            f.close()\n        return item\n最后别忘了在配置文件中启用管道。\nITEM_PIPELINES = {\n    # 'scrapy.pipelines.images.ImagesPipeline': 1,\n    'scrapy_sample.pipelines.CsdnBlogBackupPipeline': 2\n}\n然后运行一下爬虫，注意这个爬虫需要接受额外的用户名和密码参数，我们使用-a参数来指定。\nscrapy crawl csdn_backup -a username=\"用户名\" -a password=\"密码\"\n\n这里说一下，我现在改为使用简书来编写文章，一来是由于简书的体验确实相比来说非常好，在编辑器中可以直接粘贴并自动上传剪贴板中的图片；二来因为简书图片没有外链限制，所以Markdown文本可以直接复制到其他网站中，同时维护多个博客非常容易，如果有同时关注我CSDN和简书的同学也会发现，很多文章我的提交时间基本只差了十几秒，这就是复制粘贴所用的时间。包括刚刚爬下来的文章，只要在Markdown编辑器中打开，图片都可以正常访问。\n以上就是我备份CSDN上文章的一个简单例子，说它简单因为真的没干什么事情，单纯的把文章内容爬下来而已，其中的图片存储仍然依赖于简书和其他网站来保存。有兴趣的同学可以尝试做更完善的备份功能，将每篇文章按目录保存，文章中的图片按照各自的目录下载到本地，并将Markdown文本中对应图片的地址由服务器替换为本地路径。把这些功能全做完，就是一个真正的文章备份工具了。由于水平所限，我就不做了。\n这篇文章到这里也该结束了，虽然只有4个例子，但是我尝试涵盖爬虫的所有应用场景、爬取图片、爬取文本、保存到数据库和文件、自定义管道等等。希望这篇文章对大家能有所帮助！这些代码全在我的Github上，欢迎关注。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "6"}