{"title": "mysql 大表中count() 使用方法以及性能优化. - pythoner 程序员成长之路 ", "index": "python,mysql", "content": "笔者现在遇到这么一个场景,\n一个单表中包含有6000w+的数据,然而你又不能拆分.需要分别统计表中有多少数据,A产品有多少,B产品有多少这几个数据.\n在为优化之前.表结构如下,为了隐藏内容我将相应字段做了模糊化处理.\nCREATE TABLE `xxxx` (\n  `link` varchar(200) DEFAULT NULL,\n  `test0` varchar(500) DEFAULT NULL,\n  `test1` varchar(50) DEFAULT NULL,\n  `test2` int(11) DEFAULT NULL,\n  `test3` varchar(20) DEFAULT NULL,\n  `test4` varchar(50) DEFAULT NULL,\n  `test5` varchar(50) NOT NULL,\n  `inserttime` datetime DEFAULT NULL,\n  `test6` bit(1) NOT NULL DEFAULT b'0',\n  `A` bit(1) NOT NULL DEFAULT b'0',\n  `B` bit(1) NOT NULL DEFAULT b'0' ,\n  PRIMARY KEY (`test5`),\n  KEY `test6` (`test6`) USING BTREE,\n  KEY `A` (`A`) USING BTREE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n这个一个常规的InnoDB的表格,所以它的count(*)比起MyISAM的效率慢很多,InnoDB所显示的row的行数不很准确,所以在这这里我需要统计一下.有这么几个策略.共计61500000数据\n\n\ncount(*) 耗时 1539.499s\n\ncount(1) 耗时 907.581s\n\ncount(A) 对索引进行count.\n\ncount(test6) 对主键进行count.\n\n无一例外,由于这个表没有优化好上面无论哪一种都需要几千秒的时间,这个是我们无法忍受的.\n下面我们开始着手分析处理这个问题.\n预期整个表的count(*)应该在200s以内为正常,100以内为良好,50以内为优秀.\n首先我将里面test6抽取了出来,单独形成了一个表.对其进行操作.共计61500000数据\n\n\ncount(*) 耗时10.238s\n\ncount(1) 耗时8.710s\n\ncount(test6) 对主键进行count.耗时12.957s\n\n其中count(1)的效率最高,比最慢count(pk)速度提升了52.0%.\n将你能确定的字段改为最优值,例如:\n\n\nvarchar更为char.虽然varchar可以自动分配存储空间的大小但是.varchar需要使用1到2个额外的字节来记录字符串的长度,增加它的update的操作时间,\n\ndatetime改为timestamp后者在1978-2038年之间\n\n\n最后使用count(1)检验的时候最快耗时,168s.虽然有些慢但是可以接受.\n总结:\n\n重新设计你表中的字段,尽量优化它的长度.不要一味使用过多的varchar.\n使用count(1)而不是count(*)来检索.\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}