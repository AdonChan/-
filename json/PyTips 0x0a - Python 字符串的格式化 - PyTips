{"title": "PyTips 0x0a - Python 字符串的格式化 - PyTips ", "index": "pytips,python3.5,python3.x,python", "content": "项目地址：https://git.io/pytips\n相信很多人在格式化字符串的时候都用\"%s\" % v的语法，PEP 3101 提出一种更先进的格式化方法 str.format() 并成为 Python 3 的标准用来替换旧的 %s 格式化语法，CPython 从 2.6 开始已经实现了这一方法（其它解释器未考证）。\nformat()\n新的 format() 方法其实更像是一个简略版的模板引起（Template Engine），功能非常丰富，官方文档对其语法的描述如下：\n\"\"\"\nreplacement_field ::=  \"{\" [field_name] [\"!\" conversion] [\":\" format_spec] \"}\"\nfield_name        ::=  arg_name (\".\" attribute_name | \"[\" element_index \"]\")*\narg_name          ::=  [identifier | integer]\nattribute_name    ::=  identifier\nelement_index     ::=  integer | index_string\nindex_string      ::=  <any source character except \"]\"> +\nconversion        ::=  \"r\" | \"s\" | \"a\"\nformat_spec       ::=  <described in the next section>\n\"\"\"\npass # Donot output\n我将其准换成铁路图的形式，（可能）更直观一些：\n\n模板中替换变量用 {} 包围，且由 : 分为两部分，其中后半部分 format_spec 在后面会单独讨论。前半部分有三种用法：\n\n空\n代表位置的数字\n代表keyword的标识符\n\n这与函数调用的参数类别是一致的：\nprint(\"{} {}\".format(\"Hello\", \"World\"))\n# is equal to...\nprint(\"{0} {1}\".format(\"Hello\", \"World\"))\nprint(\"{hello} {world}\".format(hello=\"Hello\", world=\"World\"))\n\nprint(\"{0}{1}{0}\".format(\"H\", \"e\"))\nHello World\nHello World\nHello World\nHeH\n\n除此之外，就像在0x05 函数参数与解包中提到的一样，format() 中也可以直接使用解包操作：\nprint(\"{lang}.{suffix}\".format(**{\"lang\": \"Python\", \"suffix\": \"py\"}))\nprint(\"{} {}\".format(*[\"Python\", \"Rocks\"]))\nPython.py\nPython Rocks\n\n在模板中还可以通过 .identifier 和 [key] 的方式获取变量内的属性或值（需要注意的是 \"{}{}\" 相当于 \"{0}{1}\"）：\ndata = {'name': 'Python', 'score': 100}\nprint(\"Name: {0[name]}, Score: {0[score]}\".format(data)) # 不需要引号\n\nlangs = [\"Python\", \"Ruby\"]\nprint(\"{0[0]} vs {0[1]}\".format(langs))\n\nprint(\"\\n====\\nHelp(format):\\n {.__doc__}\".format(str.format))\nName: Python, Score: 100\nPython vs Ruby\n\n====\nHelp(format):\n S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}').\n\n强制转换\n可以通过 ! + r|s|a 的方式对替换的变量进行强制转换：\n\n\"{!r}\" 对变量调用 repr()\n\"{!s}\" 对变量调用 str()\n\"{!a}\" 对变量调用 ascii()\n\n格式\n最后 : 之后的部分定义输出的样式：\n\nalign 代表对齐方向，通常要配合 width 使用，而 fill 则是填充的字符（默认为空白）：\nfor align, text in zip(\"<^>\", [\"left\", \"center\", \"right\"]):\n    print(\"{:{fill}{align}16}\".format(text, fill=align, align=align))\n    \nprint(\"{:0=10}\".format(100)) # = 只允许数字\nleft<<<<<<<<<<<<\n^^^^^center^^^^^\n>>>>>>>>>>>right\n0000000100\n\n同时可以看出，样式设置里面可以嵌套 {} ，但是必须通过 keyword 指定，且只能嵌套一层。\n接下来是符号样式：+|-|' ' 分别指定数字是否需要强制符号（其中空格是指在正数的时候不显示 + 但保留一位空格）：\nprint(\"{0:+}\\n{1:-}\\n{0: }\".format(3.14, -3.14))\n+3.14\n-3.14\n 3.14\n\n# 用于表示特殊格式的数字（二进制、十六进制等）是否需要前缀符号；, 也是用于表示数字时是否需要在千位处进行分隔；0 相当于前面的 {:0=} 右对齐并用 0 补充空位：\nprint(\"Binary: {0:b} => {0:#b}\".format(3))\n\nprint(\"Large Number: {0:} => {0:,}\".format(1.25e6))\n\nprint(\"Padding: {0:16} => {0:016}\".format(3))\nBinary: 11 => 0b11\nLarge Number: 1250000.0 => 1,250,000.0\nPadding:                3 => 0000000000000003\n\n最后两个就是我们熟悉的小数点精度 .n 和格式化类型了，这里仅给出一些示例，详细内容可以查阅文档：\nfrom math import pi\nprint(\"pi = {pi:.2}, also = {pi:.7}\".format(pi=pi))\npi = 3.1, also = 3.141593\n\nInteger\nfor t in \"b c d #o #x #X n\".split():\n    print(\"Type {0:>2} of {1} shows: {1:{t}}\".format(t, 97, t=t))\nType  b of 97 shows: 1100001\nType  c of 97 shows: a\nType  d of 97 shows: 97\nType #o of 97 shows: 0o141\nType #x of 97 shows: 0x61\nType #X of 97 shows: 0X61\nType  n of 97 shows: 97\n\nFloat\nfor t, n in zip(\"eEfFgGn%\", [12345, 12345, 1.3, 1.3, 1, 2, 3.14, 0.985]):\n    print(\"Type {} shows: {:.2{t}}\".format(t, n, t=t))\nType e shows: 1.23e+04\nType E shows: 1.23E+04\nType f shows: 1.30\nType F shows: 1.30\nType g shows: 1\nType G shows: 2\nType n shows: 3.1\nType % shows: 98.50%\n\nString (default)\ntry:\n    print(\"{:s}\".format(123))\nexcept:\n    print(\"{}\".format(456))\n456\n\n\n\n欢迎关注 PyHub！\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "10"}