{"title": "记一次基于mpvue的小程序开发及上线实战 - 个人文章 ", "index": "javascript,小程序,前端,python,python3.x", "content": "\n小程序名称：一起打车吧\n项目地址：客户端：https://github.com/jrainlau/t...\n服务端：https://github.com/jrainlau/t...\n\n小程序二维码：\n\n\n经过为期两个晚上下班时间的努力，终于把我第一个小程序开发完成并发布上线了。整个过程还算顺利，由于使用了mpvue方案进行开发，故可以享受和vue一致的流畅开发体验；后台系统使用了python3+flask框架进行，使用最少的代码完成了小程序的后台逻辑。除了开发之外，还实实在在地体验了一把微信小程序的开发流程，包括开发者工具的使用、体验版的发布、上线的申请等等。这些开发体验都非常值得被记录下来，于是便趁热打铁，写下这篇文章。\n一、需求&功能\n由于公司里有相当多的同事都住在同一个小区，所以上下班的时候经常会在公司群里组织拼车。但是由于完全依赖聊天记录，且上下班拼车的同事也很多，依赖群聊很容易把消息刷走，而且容易造成信息错乱。既然如此，那么完全可以开发一个小工具把这些问题解决。\n发起拼车的人把出发地点、目的地点、打车信息以卡片的形式分享出来，参与拼车的人点击卡片就能选择参加拼车，并且能看到同车拼友是谁，拼单的信息等等内容。\n交互流程如下：\n\n可以看到，逻辑是非常简单的，我们只需要保证生成拼单、分享拼单、进入拼单和退出拼单这四个功能就好。\n需求和功能已经确定好，首先按照小程序官网的介绍，注册好小程序并拿到appId，接下来可以开始进行后台逻辑的开发。\n二、后台逻辑开发\n由于时间仓促，功能又简单，所以并没有考虑任何高并发等复杂场景，仅仅考虑功能的实现。从需求的逻辑可以知道，其实后台只需要维护两个列表，分别存储当前所有拼车单以及当前所有参与了拼车的用户即可，其数据结构如下：\n\n当前所有拼单列表billsList\n\n当前所有参与了拼车的用户列表inBillUsers\n\n\n当用户确定并分享了一个拼单之后，会直接新建一个拼单，同时把该用户添加到当前所有参与了拼车的用户列表列表里面，并且添加到该拼单的成员列表当中：\n\n只要维护好这两个列表，接下来就是具体的业务逻辑了。\n为了快速开发，这里我使用了python3+flask框架的方案。不懂python的读者看到这里也不用紧张，代码非常简单且直白，看看也无妨。\n首先新建一个BillController类：\nclass BillController:\n    billsList = []\n    inBillUsers = []\n接下来会在这个类的内部添加创建拼单、获取拼单、参与拼单、退出拼单、判断用户是否在某一拼单中、图片上传的功能。\n1、获取拼单getBill()\n\n该方法接收客户端传来的拼单ID，然后拿这个ID去检索是否存在对应的拼单。若存在则返回对应的拼单，否则报错给客户端。\n    def getBill(self, ctx):\n        ctxBody = ctx.form\n        billId = ctxBody['billId']\n        try: \n            return response([item for item in self.billsList if item['billId'] == billId][0])\n        except IndexError:\n            return response({\n                'errMsg': '拼单不存在！',\n                'billsList': self.billsList,\n            }, 1)\n2、创建拼单createBill()\n\n该方法会接收来自客户端的用户信息和拼单信息，分别添加到billsList和inBillUsers当中。\n    def createBill(self, ctx):\n        ctxBody = ctx.form\n        user = {\n            'userId': ctxBody['userId'],\n            'billId': ctxBody['billId'],\n            'name': ctxBody['name'],\n            'avatar': ctxBody['avatar']\n        }\n        bill = {\n            'billId': ctxBody['billId'],\n            'from': ctxBody['from'],\n            'to': ctxBody['to'],\n            'time': ctxBody['time'],\n            'members': [user]\n        }\n\n        if ctxBody['userId'] in [item['userId'] for item in self.inBillUsers]:\n            return response({\n                'errMsg': '用户已经在拼单中！'\n            }, 1)\n\n        self.billsList.append(bill)\n        self.inBillUsers.append(user)\n        return response({\n            'billsList': self.billsList,\n            'inBillUsers': self.inBillUsers\n        })\n创建完成后，会返回当前的billsList和inBillUsers到客户端。\n3、参与拼单joinBill()\n\n接收客户端传来的用户信息和拼单ID，把用户添加到拼单和inBillUsers列表中。\n    def joinBill(self, ctx):\n        ctxBody = ctx.form\n        billId = ctxBody['billId']\n        user = {\n            'userId': ctxBody['userId'],\n            'name': ctxBody['name'],\n            'avatar': ctxBody['avatar'],\n            'billId': ctxBody['billId']\n        }\n        if ctxBody['userId'] in [item['userId'] for item in self.inBillUsers]:\n            return response({\n                'errMsg': '用户已经在拼单中！'\n            }, 1)\n        theBill = [item for item in self.billsList if item['billId'] == billId]\n        if not theBill:\n            return response({\n                'errMsg': '拼单不存在'\n            }, 1)\n        theBill[0]['members'].append(user)\n        self.inBillUsers.append(user)\n        return response({\n            'billsList': self.billsList,\n            'inBillUsers': self.inBillUsers\n        })\n4、退出拼单leaveBill()\n\n接收客户端传来的用户ID和拼单ID，然后删除掉两个列表里面的该用户。\n这个函数还有一个功能，如果判断到这个拼单ID所对应的拼单成员为空，会认为该拼单已经作废，会直接删除掉这个拼单以及所对应的车辆信息图片。\n    def leaveBill(self, ctx):\n        ctxBody = ctx.form\n        billId = ctxBody['billId']\n        userId = ctxBody['userId']\n        indexOfUser = [i for i, member in enumerate(self.inBillUsers) if member['userId'] == userId][0]\n        indexOfTheBill = [i for i, bill in enumerate(self.billsList) if bill['billId'] == billId][0]\n        indexOfUserInBill = [i for i, member in enumerate(self.billsList[indexOfTheBill]['members']) if member['userId'] == userId][0]\n        # 删除拼单里面的该用户\n        self.billsList[indexOfTheBill]['members'].pop(indexOfUserInBill)\n        # 删除用户列表里面的该用户\n        self.inBillUsers.pop(indexOfUser)\n        # 如果拼单里面用户为空，则直接删除这笔拼单\n        if len(self.billsList[indexOfTheBill]['members']) == 0:\n            imgPath = './imgs/' + self.billsList[indexOfTheBill]['img'].split('/getImg')[1]\n            if os.path.exists(imgPath):\n                os.remove(imgPath)\n            self.billsList.pop(indexOfTheBill)\n        return response({\n            'billsList': self.billsList,\n            'inBillUsers': self.inBillUsers\n        })\n5、判断用户是否在某一拼单中inBill()\n\n接收客户端传来的用户ID，接下来会根据这个用户ID去inBillUsers里面去检索该用户所对应的拼单，如果能检索到，会返回其所在的拼单。\n    def inBill(self, ctx):\n        ctxBody = ctx.form\n        userId = ctxBody['userId']\n        if ctxBody['userId'] in [item['userId'] for item in self.inBillUsers]:\n            return response({\n                'inBill': [item for item in self.inBillUsers if ctxBody['userId'] == item['userId']][0],\n                'billsList': self.billsList,\n                'inBillUsers': self.inBillUsers\n            })\n        return response({\n            'inBill': False,\n            'billsList': self.billsList,\n            'inBillUsers': self.inBillUsers\n        })\n6、图片上传uploadImg()\n\n接收客户端传来的拼单ID和图片资源，先存储图片，然后把该图片的路径写入对应拼单ID的拼单当中。\n    def uploadImg(self, ctx):\n        billId = ctx.form['billId']\n        file = ctx.files['file']\n        filename = file.filename\n        file.save(os.path.join('./imgs', filename))\n        # 把图片信息挂载到对应的拼单\n        indexOfTheBill = [i for i, bill in enumerate(self.billsList) if bill['billId'] == billId][0]\n        self.billsList[indexOfTheBill]['img'] = url_for('getImg', filename=filename)\n        return response({\n            'billsList': self.billsList\n        })\n完成了业务逻辑的功能，接下来就是把它们分发给不同的路由了：\n@app.route('/create', methods = ['POST'])\ndef create():\n    return controller.createBill(request)\n\n@app.route('/join', methods = ['POST'])\ndef join():\n    return controller.joinBill(request)\n\n@app.route('/leave', methods = ['POST'])\ndef leave():\n    return controller.leaveBill(request)\n\n@app.route('/getBill', methods = ['POST'])\ndef getBill():\n    return controller.getBill(request)\n\n@app.route('/inBill', methods = ['POST'])\ndef inBill():\n    return controller.inBill(request)\n\n@app.route('/uploadImg', methods = ['POST'])\ndef uploadImg():\n    return controller.uploadImg(request)\n\n@app.route('/getImg/<filename>')\ndef getImg(filename):\n  return send_from_directory('./imgs', filename)\n完整的代码可以直接到仓库查看，这里仅展示关键的内容。\n三、前端业务开发\n前端借助vue-cli直接使用了mpvue的mpvue-quickstart来初始化项目，具体过程不再细述，直接进入业务开发部分。\n首先，微信小程序的API都是callback风格，为了使用方便，我把用到的小程序API都包装成了Promise，统一放在src/utils/wx.js内部，类似下面这样：\nexport const request = obj => new Promise((resolve, reject) => {\n  wx.request({\n    url: obj.url,\n    data: obj.data,\n    header: { 'content-type': 'application/x-www-form-urlencoded', ...obj.header },\n    method: obj.method,\n    success (res) {\n      resolve(res.data.data)\n    },\n    fail (e) {\n      console.log(e)\n      reject(e)\n    }\n  })\n})\n\n1、注册全局Store\n由于开发习惯，我喜欢把所有接口请求都放在store里面的actions当中，所以这个小程序也是需要用到Vuex。但由于小程序每一个Page都是一个新的Vue实例，所以按照Vue的方式，用全局Vue.use(Vuex)是不会把$store注册到实例当中的，这一步要手动来。\n在src/目录下新建一个store.js文件，然后在里面进行使用注册：\nimport Vue from 'vue'\nimport Vuex from 'vuex'\n\n\nVue.use(Vuex)\n\nexport default new Vuex.Store({})\n接下来在src/main.js当中，手动在Vue的原型里注册一个$store：\nimport Vue from 'vue'\nimport App from './App'\nimport Store from './store'\n\nVue.prototype.$store = Store\n这样，以后在任何的Page里都可以通过this.$store来操作这个全局Store了。\n2、构建好请求的API接口\n和后台系统的逻辑对应，前端也要构造好各个请求的API接口，这样的做法能够避免把API逻辑分散到页面四处，具有清晰、易维护的优势。\n    /**\n     * @param  {} {commit}\n     * 获取用户公开信息\n     */\n    async getUserInfo ({ commit }) {\n      const { userInfo } = await getUserInfo({\n        withCredenitals: false\n      })\n      userInfo.avatar = userInfo.avatarUrl\n      userInfo.name = userInfo.nickName\n      userInfo.userId = encodeURIComponent(userInfo.nickName + userInfo.city + userInfo.gender + userInfo.country)\n      commit('GET_USER_INFO', userInfo)\n      return userInfo\n    },\n    /**\n     * @param  {} {commit}\n     * @param  { String } userId 用户ID\n     * 检查用户是否已经存在于某一拼单中\n     */\n    async checkInBill ({ commit }, userId) {\n      const res = await request({\n        method: 'post',\n        url: `${apiDomain}/inBill`,\n        data: {\n          userId\n        }\n      })\n      return res\n    },\n    /**\n     * @param  {} {commit}\n     * @param  { String } userId 用户ID\n     * @param  { String } name   用户昵称\n     * @param  { String } avatar 用户头像\n     * @param  { String } time   出发时间\n     * @param  { String } from   出发地点\n     * @param  { String } to     目的地点\n     * @param  { String } billId 拼单ID\n     * 创建拼单\n     */\n    async createBill ({ commit }, { userId, name, avatar, time, from, to, billId }) {\n      const res = await request({\n        method: 'post',\n        url: `${apiDomain}/create`,\n        data: {\n          userId,\n          name,\n          avatar,\n          time,\n          from,\n          to,\n          billId\n        }\n      })\n      commit('GET_BILL_INFO', res)\n      return res\n    },\n    /**\n     * @param  {} {commit}\n     * @param  { String } billId 拼单ID\n     * 获取拼单信息\n     */\n    async getBillInfo ({ commit }, billId) {\n      const res = await request({\n        method: 'post',\n        url: `${apiDomain}/getBill`,\n        data: {\n          billId\n        }\n      })\n      return res\n    },\n    /**\n     * @param  {} {commit}\n     * @param  { String } userId 用户ID\n     * @param  { String } name   用户昵称\n     * @param  { String } avatar 用户头像\n     * @param  { String } billId 拼单ID\n     * 参加拼单\n     */\n    async joinBill ({ commit }, { userId, name, avatar, billId }) {\n      const res = await request({\n        method: 'post',\n        url: `${apiDomain}/join`,\n        data: {\n          userId,\n          name,\n          avatar,\n          billId\n        }\n      })\n      return res\n    },\n    /**\n     * @param  {} {commit}\n     * @param  { String } userId 用户ID\n     * @param  { String } billId 拼单ID\n     * 退出拼单\n     */\n    async leaveBill ({ commit }, { userId, billId }) {\n      const res = await request({\n        method: 'post',\n        url: `${apiDomain}/leave`,\n        data: {\n          userId,\n          billId\n        }\n      })\n      return res\n    },\n    /**\n     * @param  {} {commit}\n     * @param  { String } filePath 图片路径\n     * @param  { String } billId   拼单ID\n     * 参加拼单\n     */\n    async uploadImg ({ commit }, { filePath, billId }) {\n      const res = await uploadFile({\n        url: `${apiDomain}/uploadImg`,\n        header: {\n          'content-type': 'multipart/form-data'\n        },\n        filePath,\n        name: 'file',\n        formData: {\n          'billId': billId\n        }\n      })\n      return res\n    }\n3、填写拼单并实现分享功能实现\n新建一个src/pages/index目录，作为小程序的首页。\n该首页的业务逻辑如下：\n\n进入首页的时候先获取用户信息，得到userId\n然后用userId去请求判断是否已经处于拼单\n若是，则跳转到对应拼单Id的详情页\n若否，才允许新建拼单\n\n在onShow的生命周期钩子中实现上述逻辑：\n  async onShow () {\n    this.userInfo = await this.$store.dispatch('getUserInfo')\n    const inBill = await this.$store.dispatch('checkInBill', this.userInfo.userId)\n\n    if (inBill.inBill) {\n      wx.redirectTo(`../join/main?billId=${inBill.inBill.billId}&fromIndex=true`)\n    }\n  },\n当用户填写完拼单后，会点击一个带有open-type=\"share\"属性的button，然后会触发onShareAppMessage生命周期钩子的逻辑把拼单构造成卡片分享出去。当分享成功后会跳转到对应拼单ID的参加拼单页。\n  onShareAppMessage (result) {\n    let title = '一起拼车'\n    let path = '/pages/index'\n    if (result.from === 'button') {\n      this.billId = 'billId-' + new Date().getTime()\n      title = '我发起了一个拼车'\n      path = `pages/join/main?billId=${this.billId}`\n    }\n    return {\n      title,\n      path,\n      success: async (res) => {\n        await this.$store.dispatch('createBill', { ...this.userInfo, ...this.billInfo })\n\n        // 上传图片\n        await this.$store.dispatch('uploadImg', {\n          filePath: this.imgSrc,\n          billId: this.billId\n        })\n        \n        // 分享成功后，会带着billId跳转到参加拼单页\n        wx.redirectTo(`../join/main?billId=${this.billId}`)\n      },\n      fail (e) {\n        console.log(e)\n      }\n    }\n  },\n4、参与拼单&退出拼单功能实现\n新建一个src/pages/join目录，作为小程序的“参加拼单页”。\n该页面的运行逻辑如下：\n\n首先会获取从url里面带来的billId\n其次会请求一次userInfo，获取userId\n然后拿这个userId去检查该用户是否已经处于拼单\n如果已经处于拼单，那么就会获取一个新的billId代替从url获取的\n拿当前的billId去查询对应的拼单信息\n如果billId都无效，则redirect到首页\n\n由于要获取url携带的内容，亲测onShow()是不行的，只能在onLoad()里面获取：\n  async onLoad (options) {\n    // 1. 首先会获取从url里面带来的billId\n    this.billId = options.billId\n    // 2. 其次会请求一次userInfo，获取userId\n    this.userInfo = await this.$store.dispatch('getUserInfo')\n    // 3. 然后拿这个userId去检查该用户是否已经处于拼单\n    const inBill = await this.$store.dispatch('checkInBill', this.userInfo.userId)\n    // 4. 如果已经处于拼单，那么就会有一个billId\n    if (inBill.inBill) {\n      this.billId = inBill.inBill.billId\n    }\n    // 5. 如果没有处于拼单，那么将请求当前billId的拼单\n    // 6. 如果billId都无效，则redirect到首页，否则检查当前用户是否处于该拼单当中\n    await this.getBillInfo()\n  }\n此外，当用户点击“参与拼车”后，需要重新请求拼单信息，以刷新视图拼车人员列表；当用户点击“退出拼车”后，要重定向到首页。\n经过上面几个步骤，客户端的逻辑已经完成，可以进行预发布了。\n四、预发布&申请上线\n如果要发布预发布版本，需要运行npm run build命令，打包出一个生产版本的包，然后通过小程序开发者工具的上传按钮上传代码，并填写测试版本号：\n\n接下来可以在小程序管理后台→开发管理→开发版本当中看到体验版小程序的信息，然后选择发布体验版即可：\n\n当确定预发布测试无误之后，就可以点击“提交审核”，正式把小程序提交给微信团队进行审核。审核的时间非常快，在3小时内基本都能够有答复。\n值得注意的是，小程序所有请求的API，都必须经过域名备案和使用https证书，同时要在设置→开发设置→服务器域名里面把API添加到白名单才可以正常使用。\n五、后记\n这个小程序现在已经发布上线了，算是完整体验了一把小程序的开发乐趣。小程序得到了微信团队的大力支持，以后的生态只会越来越繁荣。当初小程序上线的时候我也对它有一些抵触，但后来想了想，这只不过是前端工程师所需面对的又一个“端“而已，没有必要为它戴上有色眼镜，多掌握一些总是好的。\n“一起打车吧”微信小程序依然是一个玩具般的存在，仅供自己学习和探索，当然也欢迎各位读者能够贡献代码，参与开发~\n\n                ", "mainLikeNum": ["47 "], "mainBookmarkNum": "103"}