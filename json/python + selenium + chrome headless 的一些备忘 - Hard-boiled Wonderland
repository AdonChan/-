{"title": "python + selenium + chrome headless 的一些备忘 - Hard-boiled Wonderland ", "index": "selenium,chromium,python", "content": "使用python3.6在Ubuntu中进行了一项使用Chrome headless浏览器的工作, 在此记录下遇到的问题以及解决方法.\n入门?\n参考 unning-selenium-with-headless-chrome\nUbuntu中如何安装chrome浏览器, 以及chromedriver?\n参考 Installing ChromeDriver on Ubuntu\nselenium启动浏览器时常用的属性\nfrom selenium.webdriver.chrome.options import Options\nchrome_options = Options()\nchrome_options.add_argument('window-size=1920x3000') #指定浏览器分辨率\nchrome_options.add_argument('--disable-gpu') #谷歌文档提到需要加上这个属性来规避bug\nchrome_options.add_argument('--hide-scrollbars') #隐藏滚动条, 应对一些特殊页面\nchrome_options.add_argument('blink-settings=imagesEnabled=false') #不加载图片, 提升速度\nchrome_options.add_argument('--headless') #浏览器不提供可视化页面. linux下如果系统不支持可视化不加这条会启动失败\nchrome_options.binary_location = r'/Applications/Google Chrome Canary.app/Contents/MacOS/Google Chrome Canary' #手动指定使用的浏览器位置\nselenium如何连接到已经开启的浏览器?\n需要在打开浏览器后, 获取浏览器的command_executor url, 以及session_id\nopener.command_executor._url, opener.session_id #opener为webdriver对象\n之后通过remote方式链接\nfrom selenium import webdriver\nopener = webdriver.Remote(command_executor=_url,desired_capabilities={}) #_url为上面的_url\nopener.close() #这时会打开一个全新的浏览器对象, 先把新的关掉\nopener.session_id = session_id #session_id为上面的session_id\n之后对opener的任何操作都会反映在之前的浏览器上.\nselenium 的 desired_capabilities 如何传递--headless这样的浏览器参数\nfrom selenium.webdriver.common.desired_capabilities import DesiredCapabilities\ncapabilities = DesiredCapabilities.CHROME\ncapabilities.setdefault('chromeOptions', {'args':['--headless', '--disable-gpu']})\nselenium 使用 crontab等环境启动时提示chromedriver not in PATH\n\n初始化的时候, 传入chromedriver绝对路径\nopener = webdriver.Chrome(r'/usr/local/bin/chromedriver', chrome_options=chrome_options)\nselenium使用cookies\n\n获得cookiesopener.get_cookies()\n\n写入cookiesopener.add_cookie(cookie) #需要先访问该网站产生cookies后再进行覆写\n\n\nselenium 等待页面所有异步函数完成\nopener.implicitly_wait(30) #30是最长等待时间\nselenium 打开新标签页\n偏向使用js函数来执行\nopener.execute_script('''window.open(\"http://baidu.com\",\"_blank\");''') \nselenium 获得页面的网络请求信息\n有些时候页面在你点击后会异步进行请求, 完成一些操作, 这时可能就会生成输出数据的url, 只要抓到这个url就可以跳过token验证等安全监测, 直接获得数据.\nscript =  \"var performance = window.performance || window.mozPerformance || window.msPerformance || window.webkitPerformance || {}; var network = performance.getEntries() || {}; return network;\"\nperformances = opener.execute_script(script)\nscript里是js代码, 一般用来进行性能检查, 网络请求状况, 使用selenium执行这段js就可以获得所有的请求信息.\nおわり.\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "4"}