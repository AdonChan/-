{"title": "利用Python生成随机的IP地址 - luqiuwen ", "index": "python", "content": "需求\n\n在某应用中，需要根据一定的规则生成随机的IP地址，规则类似于192.168.11.0/24这样的CIDR形式给出。\n\n实现\n\n经过艰苦卓绝的调试，下面的代码是可以用的：\n\nRANDOM_IP_POOL=['192.168.10.222/0']\ndef __get_random_ip():\n    str_ip = RANDOM_IP_POOL[random.randint(0,len(RANDOM_IP_POOL) - 1)]\n    str_ip_addr = str_ip.split('/')[0]\n    str_ip_mask = str_ip.split('/')[1]\n    ip_addr = struct.unpack('>I',socket.inet_aton(str_ip_addr))[0]\n    mask = 0x0\n    for i in range(31, 31 - int(str_ip_mask), -1):\n        mask = mask | ( 1 << i)\n    ip_addr_min = ip_addr & (mask & 0xffffffff)\n    ip_addr_max = ip_addr | (~mask & 0xffffffff)\n    return socket.inet_ntoa(struct.pack('>I', random.randint(ip_addr_min, ip_addr_max)))\n\n\n生成的结果如：\n\n 192.168.10.175   192.168.10.29   \n 192.168.10.30    192.168.10.207  \n 192.168.10.248   192.168.10.145  \n 192.168.10.168   192.168.10.223  \n 192.168.10.66    192.168.10.138  \n 192.168.10.99    192.168.10.136  \n 192.168.10.147   192.168.10.244  \n 192.168.10.73    192.168.10.180  \n\n\n备注\n\n(mask & 0xffffffff)这一用法，目的在于消除mask上32位以上的高位数据。由于mask是IPv4的掩码，所以不需要32位以上的数据。这一问题在mask取反之后比较明显。由于mask是一个32位以上的数（有可能是64位），取反之后，高位全部为1，计算的结果就不正确了。因此，在使用之前，需要利用(mask & 0xffffffff)清除高位。\n\n供各位读者参考。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "5"}