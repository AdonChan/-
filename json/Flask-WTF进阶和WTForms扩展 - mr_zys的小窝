{"title": "Flask-WTF进阶和WTForms扩展 - mr_zys的小窝 ", "index": "wtforms,flask-wtf,python", "content": "Flask-WTF和Flask-SQLAlchemy都是很好用的插件，然而当它们结合到一起后，就不是那么美妙了。\n问题的提出\n在models.py中定义了一个Article、Category和Tag类：\nclass Article(db.Model):\n    \"\"\"定义文章\"\"\"\n\n    __tablename__ = 'articles'\n    id = db.Column(db.Integer, primary_key=True)\n    title = db.Column(db.String(128), unique=True, index=True)\n    # 保存md格式的文本\n    content = db.Column(db.Text)\n    # 保存html格式的文本\n    content_html = db.Column(db.Text)\n    # 文章分类\n    category_id = db.Column(db.Integer, db.ForeignKey('categories.id'))\n    # 文章标签\n    tags = db.relationship(\n        'Tag', secondary='article_tag_ref', backref='articles')\nclass Category(db.Model):\n    \"\"\"文章分类\"\"\"\n\n    __tablename__ = 'categories'\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(128), unique=True)\n    articles = db.relationship('Article', backref='category', lazy='dynamic')\n\nclass Tag(db.Model):\n    \"\"\"文章标签\"\"\"\n\n    __tablename__ = 'tags'\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(128), unique=True)\n\n# 文章和标签的映射表 ，多对多关系\narticle_tag_ref = db.Table('article_tag_ref',\n                           db.Column('article_id', db.Integer,\n                                     db.ForeignKey('articles.id')),\n                           db.Column('tag_id',  db.Integer,\n                                     db.ForeignKey('tags.id'))\n                           )\n然后在forms.py中定义一个ArticleForm表单\nclass ArticleForm(Form):\n\n    title = StringField(u\"标题\", validators=[Required()])\n    category = QuerySelectField(u\"分类\", query_factory=getUserFactory(['id', 'name']), get_label='name')\n    tags = StringField(u\"标签\", validators=[Required()])\n    content = PageDownField(u\"正文\", validators=[Required()])\n    submit = SubmitField(u\"发布\")\n\n此时在处理表单的时候可以这样：\nform = ArticleForm()\nif form.validate_on_submit():\n    article = Article(title=from.data.title, content=form.data.content,category=form.category.data)\n    ...\n等等，这样怎么处理form.data.tags？只有像下面这样写了：\n\"\"\"\n:param tags:\n    标签列表，如[u'测试',u'Flask']\n\"\"\"\ndef str_to_obj(tags):\n    r = []\n    for tag in tags:\n        tag_obj = Tag.query.filter_by(name=tag).first()\n        if tag_obj is None:\n            tag_obj = Tag(name=tag)\n        r.append(tag_obj)\n    return r\n然后在上面的代码中加入：\n form = ArticleForm()\nif form.validate_on_submit():\n    article = Article(title=from.data.title, content=form.data.content, category=form.category.data, tags=str_to_obj(form.data.tags))   \n这样是不是很难看，像form.data.category就是一个对象，为撒到form.data.tags了就不是了，还要专门写一个函数来坐一个转换？这个时候就有必要扩展WTForms中的表单了。　\nWTForms入门\n阅读WTForms文档，关于如何创建一个TagListField，贴一下代码：\nclass TagListField(Field):\n    widget = TextInput()\n\n    def _value(self):\n        if self.data:\n            return u', '.join(self.data)\n        else:\n            return u''\n\n    def process_formdata(self, valuelist):\n        if valuelist:\n            self.data = [x.strip() for x in valuelist[0].split(',')]\n        else:\n            self.data = []\n简单了看了一下WTForms源码，大致搞清楚了上面代码两个方法的作用：\n\n_value The _value method is called by the TextInput widget to provide the value that is displayed in the form. 在初始化表单的时候，就是调用这个方法在表单中渲染数据\nprocess_formdata 表单提交时，处理该字段的数据。\n\n编写WTForm扩展\n根据上面的代码，将TagListField中的字符串转为models.py中定义的Tag对象即可：\nclass TagListField(Field):\n    widget = TextInput()\n\n    def __init__(self, label=None, validators=None,\n                 **kwargs):\n        super(TagListField, self).__init__(label, validators, **kwargs)\n\n    def _value(self):\n        if self.data:\n            r = u''\n            for obj in self.data:\n                r += self.obj_to_str(obj)\n            return u''\n        else:\n            return u''\n\n    def process_formdata(self, valuelist):\n        print 'process_formdata..'\n        print valuelist\n        if valuelist:\n            tags = self._remove_duplicates([x.strip() for x in valuelist[0].split(',')])\n            self.data = [self.str_to_obj(tag) for tag in tags]\n        else:\n            self.data = None\n\n    def pre_validate(self, form):\n        pass\n\n    @classmethod\n    def _remove_duplicates(cls, seq):\n        \"\"\"去重\"\"\"\n        d = {}\n        for item in seq:\n            if item.lower() not in d:\n                d[item.lower()] = True\n                yield item\n\n    @classmethod\n    def str_to_obj(cls, tag):\n        \"\"\"将字符串转换位obj对象\"\"\"\n        tag_obj = Tag.query.filter_by(name=tag).first()\n        if tag_obj is None:\n            tag_obj = Tag(name=tag)\n        return tag_obj\n\n    @classmethod\n    def obj_to_str(cls, obj):\n        \"\"\"将对象转换为字符串\"\"\"\n        if obj:\n            return obj.name\n        else:\n            return u''\n主要就是在process_formdata这一步处理表单的数据，将字符串转换为需要的数据。最终就可以在forms.py中这样定义表单了：\n...\nclass ArticleForm(Form):\n    \"\"\"编辑文章表单\"\"\"\n\n    title = StringField(u'标题', validators=[Required()])\n    category = QuerySelectField(u'分类', query_factory=get_category_factory(['id', 'name']), get_label='name')\n    tags = TagListField(u'标签', validators=[Required()])\n    content = PageDownField(u'正文', validators=[Required()])\n    submit = SubmitField(u'发布')\n...\n在views.py中处理表单就很方便了：\ndef edit_article():\n    \"\"\"编辑文章\"\"\"\n\n    form = ArticleForm()\n    if form.validate_on_submit():\n        article = Article(title=form.title.data, content=form.content.data)\n        article.tags = form.tags.data\n        article.category = form.category.data\n        try:\n            db.session.add(article)\n            db.session.commit()\n        except:\n            db.session.rollback()\n    return render_template('dashboard/edit.html', form=form)\n代码是不是很简洁了？^_^。。。\n当然了写一个完整的WTForms扩展还是很麻烦的。这里只是刚刚入门。可以看官方扩展QuerySelectField的源码。。。\n最终效果\n\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "12"}