{"title": "使用OpenCV与Face++实现人脸解锁 - Python玩具集 ", "index": "opencv,python", "content": "近几天微软的发布会上讲到了不少认脸解锁的内容，经过探索，其实利用手头的资源我们完全自己也可以完成这样一个过程。\n本文讲解了如何使用Python，基于OpenCV与Face++实现人脸解锁的功能。\n本文基于Python 2.7.11，Windows 8.1 系统。\n主要内容\n\nWindows 8.1上配置OpenCV\nOpenCV的人脸检测应用\n使用Face++完成人脸辨识（如果你想自己实现这部分的功能，可以借鉴例如这个项目）\n\nWindows 8.1上配置OpenCV\n入门的时候配置环境总是一个非常麻烦的事情，在Windows上配置OpenCV更是如此。\n既然写了这个推广的科普教程，总不能让读者卡在环境配置上吧。\n下面用到的文件都可以在这里（提取码：b6ec）下载，但是注意，目前OpenCV仅支持Python2.7。\n将cv2加入site-packages\n将下载下来的cv2.pyd文件放入Python安装的文件夹下的Lib\\site-packages目录。\n就我的电脑而言，这个目录就是C:\\Python27\\Lib\\site-packages。\n记得不要直接使用pip安装，将文件拖过去即可。\n安装numpy组件\n在命令行下进入到下载下来的文件所在的目录（按住Shift右键有在该目录打开命令行的选项）\n键入命令：\npip install numpy-1.11.0rc2-cp27-cp27m-win32.whl\n如果你的系统或者Python不适配，可以在这里下载别的轮子。\n测试OpenCV安装\n在命令行键入命令：\npython -c \"import cv2\"\n如果没有出现错误提示，那么cv2就已经安装好了。\nOpenCV的人脸检测应用\n人脸检测应用，简而言之就是一个在照片里找到人脸，然后用方框框起来的过程（我们的相机经常做这件事情）\n那么具体而言就是这样一个过程：\n\n获取摄像头的图片\n在图片中检测到人脸的区域\n在人脸的区域周围绘制方框\n\n获取摄像头的图片\n这里简单的讲解一下OpenCV的基本操作。\n以下操作是打开摄像头的基本操作：\n#coding=utf8\nimport cv2\n\n# 一般笔记本的默认摄像头都是0\ncapInput = cv2.VideoCapture(0)\n# 我们可以用这条命令检测摄像头是否可以读取数据\nif not capInput.isOpened(): print('Capture failed because of camera')\n那么怎么从摄像头读取数据呢？\n# 接上段程序\n# 现在摄像头已经打开了，我们可以使用这条命令读取图像\n# img就是我们读取到的图像，就和我们使用open('pic.jpg', 'rb').read()读取到的数据是一样的\nret, img = capInput.read()\n# 你可以使用open的方式存储，也可以使用cv2提供的方式存储\ncv2.imwrite('pic.jpg', img)\n# 同样，你可以使用open的方式读取，也可以使用cv2提供的方式读取\nimg = cv2.imread('pic.jpg')\n为了方便显示图片，cv2也提供了显示图片的方法：\n# 接上段程序\n# 定义一个窗口，当然也可以不定义\nimgWindowName = 'ImageCaptured'\nimgWindow = cv2.namedWindow(imgWindowName, cv2.WINDOW_NORMAL)\n# 在窗口中显示图片\ncv2.imshow(imgWindowName, img)\n当然在完成所有操作以后需要把摄像头和窗口都做一个释放：\n# 接上段程序\n# 释放摄像头\ncapInput.release()\n# 释放所有窗口\ncv2.destroyAllWindows()\n在图片中检测到人脸的区域\nOpenCV给我们提供了已经训练好的人脸的xml模板，我们只需要载入然后比对即可。\n# 接上段程序\n# 载入xml模板\nfaceCascade = cv2.CascadeClassifier('haarcascade_frontalface_default.xml')\n# 将图形存储的方式进行转换\ngray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n# 使用模板匹配图形\nfaces = faceCascade.detectMultiScale(gray, 1.3, 5)\nprint(faces)\n在人脸的区域周围绘制方框\n在上一个步骤中，faces中的四个量分别为左上角的横坐标、纵坐标、宽度、长度。\n所以我们根据这四个量很容易的就可以绘制出方框。\n# 接上段程序\n# 函数的参数分别为：图像，左上角坐标，右下角坐标，颜色，宽度\nimg = cv2.rectangle(img, (x, y), (x + w, y + h), (255, 0, 0), 2)\n成果\n根据上面讲述的内容，我们现在已经可以完成一个简单的人脸辨认了：\n#coding=utf8\nimport cv2, time\n\nprint('Press Esc to exit')\nfaceCascade = cv2.CascadeClassifier('haarcascade_frontalface_default.xml')\nimgWindow = cv2.namedWindow('FaceDetect', cv2.WINDOW_NORMAL)\n\ndef detect_face():\n    capInput = cv2.VideoCapture(0)\n    # 避免处理时间过长造成画面卡顿\n    nextCaptureTime = time.time()\n    faces = []\n    if not capInput.isOpened(): print('Capture failed because of camera')\n    while 1:\n        ret, img = capInput.read()\n        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n        if nextCaptureTime < time.time():\n            nextCaptureTime = time.time() + 0.1\n            faces = faceCascade.detectMultiScale(gray, 1.3, 5)\n        if faces:\n            for x, y, w, h in faces:\n                img = cv2.rectangle(img, (x, y), (x + w, y + h), (255, 0, 0), 2)\n        cv2.imshow('FaceDetect', img)\n        # 这是简单的读取键盘输入，27即Esc的acsii码\n        if cv2.waitKey(1) & 0xFF == 27: break\n    capInput.release()\n    cv2.destroyAllWindows()\n\nif __name__ == '__main__':\n    detect_face()\n使用Face++完成人脸辨识\n第一次认识Face++还是因为支付宝的人脸支付，响应速度还是非常让人满意的。\n现在只需要免费注册一个账号然后新建一个应用就可以使用了，非常方便。\n他的官方网址是这个，注册好之后在这里的我的应用中创建应用即可。\n创建好应用之后你会获得API Key与API Secret。\nFace++的API调用逻辑简单来说是这样的：\n\n上传图片获取读取到的人的face_id\n创建Person，获取person_id（Person中的图片可以增加、删除）\n比较两个face_id，判断是否是一个人\n比较face_id与person_id，判断是否是一个人\n\n上传图片获取face_id\n在将图片通过post方法上传到特定的地址后将返回一个json的值。\n如果api_key, api_secret没有问题，且在上传的图片中有识别到人脸，那么会存储在json的face键值下。\n#coding=utf8\nimport requests\n\n# 这里填写你的应用的API Key与API Secret\nAPI_KEY = ''\nAPI_SECRET = ''\n\n# 目前的API网址是这个，你可以在API文档里找到这些\nBASE_URL = 'http://apicn.faceplusplus.com/v2'\n\n# 使用Requests上传图片\nurl = '%s/detection/detect?api_key=%s&api_secret=%s&attribute=none'%(\n        BASE_URL, API_KEY, API_SECRET)\nfiles = {'img': (os.path.basename(fileDir), open(fileDir, 'rb'),\n        mimetypes.guess_type(fileDir)[0]), }\nr = requests.post(url, files = files)\n\n# 如果读取到图片中的头像则输出他们，其中的'face_id'就是我们所需要的值\nfaces = r.json().get('face')\nprint faces\n创建Person\n这个操作没有什么可以讲的内容，可以对照这段程序和官方的API介绍。\n官方的API介绍可以见这里，相信看完这一段程序以后你就可以自己完成其余的API了。\n# 上接上一段程序\n# 读取face_id\nif not faces is None: faceIdList = [face['face_id'] for face in faces]\n\n# 使用Requests创建Person\nurl = '%s/person/create'%BASE_URL\nparams = {\n    'api_key': API_KEY,\n    'api_secret': API_SECRET,\n    'person_name': 'LittleCoder',\n    'face_id': ','.join(faceIdList), }\nr = requests.get(url, params = params)\n# 获取person_id\nprint r.json.()['person_id']\n进度确认\n到目前为止，你应该已经可以就给定的两张图片比对是否是同一个人了。\n那么让我们来试着写一下这个程序吧，两张图片分别为'pic1.jpg', 'pic2.jpg'好了。\n下面我给出了我的代码：\ndef upload_img(fileDir, oneface = True):\n    url = '%s/detection/detect?api_key=%s&api_secret=%s&attribute=none'%(\n            BASE_URL, API_KEY, API_SECRET)\n    if oneface: url += '&mode=oneface'\n    files = {'img': (os.path.basename(fileDir), open(fileDir, 'rb'),\n            mimetypes.guess_type(fileDir)[0]), }\n    r = requests.post(url, files = files)\n    faces = r.json().get('face')\n    if faces is None:\n        print('There is no face found in %s'%fileDir)\n    else:\n        return faces[0]['face_id']\n\ndef compare(faceId1, faceId2):\n    url = '%s/recognition/compare'%BASE_URL\n    params = BASE_PARAMS\n    params['face_id1'] = faceId1\n    params['face_id2'] = faceId2\n    r = requests.get(url, params)\n    return r.json()\n\nfaceId1 = upload_img('pic1.jpg')\nfaceId2 = upload_img('pic2.jpg')\nif face_id1 and face_id2:\n    print(compare(faceId1, faceId2))\nelse:\n    print('Please change two pictures')\n成品\n到此，所有的知识介绍都结束了，相比大致如何完成这个项目各位读者也已经有想法了吧。\n下面我们需要构思一下人脸解锁的思路，大致而言是这样的：\n\n使用一个程序设置账户（包括向账户中存储解锁用的图片）\n使用另一个程序登陆（根据输入的用户名测试解锁）\n\n这里会有很多重复的代码，就不再赘述了，你可以在这里或者这里（提取码：c073）下载源代码测试使用。\n这里是设置账户的截图：\n\n这里是登陆的截图：\n\n结束语\n希望读完这篇文章能对你有帮助，有什么不足之处万望指正（鞠躬）。\n160331\nLittleCoder\nEOF\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "15"}