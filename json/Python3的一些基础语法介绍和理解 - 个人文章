{"title": "Python3的一些基础语法介绍和理解 - 个人文章 ", "index": "python3.x,python", "content": "作者：心叶时间：2018-04-23 22:18\n此处长期维护一些对帮助快速使用python3的一些基础语法，方便日常算法练习使用。\n控制语法\nbreak 语句可以跳出 for 和 while 的循环体。如果你从 for 或 while 循环中终止，任何对应的循环 else 块将不执行。\ncontinue语句被用来告诉Python跳过当前循环块中的剩余语句，然后继续进行下一轮循环。\nif条件控制\nif 表达式:\n    语句\n    if 表达式:\n        语句\n    elif 表达式:\n        语句\nelse:\n    语句\n\nwhile循环\nPython中没有do..while循环\nwhile 判断条件:\n    语句\nelse:\n    语句\n\nfor语句\nfor <variable> in <sequence>:\n    <statements>\nelse:\n    <statements>\n\nrange()函数\n这个函数不得不提，为什么滴？因为在实际用python练习算法题目时，这个函数真的用的太频繁了。\nprint(list(range(5,9))) #[5, 6, 7, 8]\n\nfor i in range(5):print(i,end=' ') #0 1 2 3 4\n\nfor i in range(1,3):print(i,end=' ') #1 2\n\nfor i in range(0, 10, 3):print(i,end=' ') #0 3 6 9\n\nfor i in range(-10, -100, -30):print(i,end=' ') #-10 -40 -70\n    \n\n迭代器与生成器\n迭代器\n迭代器是什么东西？哈哈，有没有想起java中集合的方法iterator()返回迭代器？是的，就是类似这个的存在。\n迭代器有两个基本的方法：iter() 和 next()，这点也很类似java（字符串，列表或元组对象都可用iter()方法创建迭代器对象）。\n下面先简单演示一下这二个方法的用法：\nlist=['中国','美国','俄罗斯','埃塞俄比亚']\n\n#1.使用iter()方法获取迭代器对象\nit = iter(list) \n\n#2.使用next()方法依次获取数据\nprint (next(it)) #打印结果是'中国'\nprint (next(it)) #打印结果是'美国'\n\n上面的例子应该已经明白这二个方法的用法了，使用iter()方法获取迭代器对象，再用next(it)方法依次获取集合的数据。\n当然，到末尾了已经没有可以取的数据的时候，再次调用会抛出异常，因此我们可以借助这个来实现迭代全部的数据，如下：\nlist=['中国','美国','俄罗斯','埃塞俄比亚']\n\nit = iter(list)  \n\nflag=True; \n\nwhile flag:\n\n    try:\n        print (next(it))\n        \n    except StopIteration:\n        print ('迭代结束了',end='\\n')\n        flag=False\n除此之外，使用for可以实现类似的效果，如下：\nlist=['中国','美国','俄罗斯','埃塞俄比亚']\n\nit = iter(list)\n\nfor x in it: \n    print (x, end=\" \") #'中国','美国','俄罗斯','埃塞俄比亚'\n\n\n因此，迭代全部的数据肯定不是迭代器存在的全部意义，更多的时候，你可以把它看成一个管理一列数据的对象，需要的时候告诉他一下，他就会给你下一个数据，不像for循环那样一下子迭代结束，你可以在任何需要的时候获取下一个数据。\n记住这一个特点，特别是在设计算法或者模式的时候，会很有用的（当然，具体用好他从来都是经验的事情，祝你好运）。\n生成器\nTS或者ES6+有所了解的人应该都知道yield函数，基本上和这里的差不多用法。\n在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回yield的值。并在下一次执行 next()方法时从当前位置继续运行。\n上面的说法可能有点不好理解，ok，下面用大白话说一下：\n生成器就是一个可以自定义一个生成迭代器对象函数的概念，生成的迭代器对象每次被询问返回下一个数据的时候，自定义的如果返回，使用的就是yield函数，先看下下面的例子：\n#定义一下可以生成迭代器对象的函数，类似上面例子中的iter()方法\ndef generatorDemo(array):\n    index=0\n    while(index<len(array)):\n        #你每次调用next(it)的时候，就是这里返回给你的数据\n        yield array[index]\n        index=index+1\n\n#用上面的迭代器对象生成函数生成一个迭代器对象\nit=generatorDemo(['中国','美国','俄罗斯','埃塞俄比亚'])\n \n#下面就是和之前一样使用\nflag=True\nwhile flag:\n    try:\n        print (next(it), end=\" \")\n    except StopIteration:\n        flag=False\n\n#执行结果：中国 美国 俄罗斯 埃塞俄比亚 \n        \n因此，你可以从二个角度来理解生成器：\n1.一个和迭代器配合使用的迭代器对象生成方法；\n2.更本质的理解：yield类似return，可以返回数据，不过不同的是，可以多次返回数据，调用一下返回一下，再次调用返回下一个yield定义返回数据的地方，就如同上面的例子，直到yield语句全部完毕再次调用会抛出错误。\n如果你问我什么时候使用他，这具体看业务需求，就好比if语句一样，他就在那里，需要用的时候可以记起来他，就够了。\n函数\n具体就不用多说明了，直接给出定义，然后说几个重要的问题。\ndef 函数名（参数列表）:\n    函数体\n\n参数传递\n在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。\n函数中传递参数的时候，不可更改的对象和可以修改的对象在操作影响上是有很大区别的，用一句话说明的话就是：不可更改的对象类似传递的是值，可以修改的对象传递的是'指针'，也就是引用传递，应该可以感受出来区别了吧。\npython 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。\n参数\n参数有四点，具体的很多和ES很像，不过在第一点上和ES区别很大，下面来简单说明一下：\n1.必需参数：就是你定义函数的时候，定义了几个参数，调用的时候就要传递几个，当然是普通定义方法，不包括下面的不定长参数，这点ES就很随意了；\n2.关键字参数：举个例子，比如你定义了一个函数有二个参数age和name，函数名称是getInfo，正常调用是依次传递参数：getInfo(7,'yelloxing')，当然你可以不这样，你还可以这样：\ngetInfo(name='yelloxing',age=7)；\n\n3.默认参数：这个就和ES6差不多意思，举例，定义函数时（没有写全，值写函数头部）：\ngetInfo(age,name='默认名称')；\n\n4.不定长参数：定义方法：getInfo(age,name,*vartuple)，这样多传递的数据就全部在vartuple中，调用前它是一个空元组。\n别的更多细节说明就到此为止，如果后续有必要再添加或单独整理，此时的已经够用了。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}