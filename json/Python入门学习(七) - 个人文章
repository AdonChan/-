{"title": "Python入门学习(七) - 个人文章 ", "index": "python", "content": "在熟悉了自定义函数和函数中使用到的参数(必选参数, 默认参数, 可变参数, 关键字参数, 命名关键字参数), 以及由函数返回值引伸出的递归和装饰器后, 让我们继续前行.\nPython 高阶函数\nmap\nmap()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回\ndef func(x):\n    return x * x\nm = map(func, [2, 3])\nprint(m)\nfor x in m:\n    print(x)\n\nmap函数, 就有点类似一个加工厂, func 就像是加工规则, [2, 3] 就像是加工原料, 每个原料加工后, 就成了map的返回值[4, 9]\nreduce\nreduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算\nfrom functools import reduce\ndef func(x, y):\n    return x + y\ns = reduce(func, [1, 2, 3, 4, 5]) # 15\n\n# s = func(func(func(func(1, 2), 3), 4), 5) # 15\nreduce函数, 就像是个面包机, [1, 2, 3, 4, 5] 就像是事先要准备的原料 [面粉,鸡蛋, 牛奶, 糖] 而func, 就像是向面包机里加的动作 最后的面包机中的热腾腾的面包, 就是返回结果了.^_^\nfilter\nfilter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。\ndef remove_ood(x):\n    if x % 2 == 0:\n        return True\n    else:\n        return False\n\narr = list(range(1, 10))\n\nenvn = filter(remove_ood, arr)\nprint(even) # <filter object at 0x10a444630>\nfor x in envn:\n    print(x)\n# 2 4 6 8\nfilter函数 就是把传入集合中的元素, 按照指定规则分离. 有点像是做奶油前要从鸡蛋中去出蛋黄, 留下蛋清. (^_^)\nsorted\nsorted()函数就可以对list进行排序\n>>> sorted([36, 5, -12, 9, -21])\n[-21, -12, 5, 9, 36]\nsorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，例如:\n>>> sorted([36, 5, -12, 9, -21], key=abs)\n[5, 9, -12, -21, 36]\n其实还可以这样玩\n>>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower)\n['about', 'bob', 'Credit', 'Zoo']\n这样 排序就忽略了数组中的字符的大小写\n\n>>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)\n['Zoo', 'Credit', 'bob', 'about']\n数组的反转\n匿名函数\n关键字lambda表示匿名函数，冒号前面的x表示函数参数。\nprint(reduce(lambda x, y: x + y, [1, 2, 3, 4, 5])) # 15\nlambda 与 : 之间是匿名函数的入参\n偏函数\n所谓偏函数，其实就是将一个已知参数和函数进行绑定，生成一个新的函数\n假设要转换大量的二进制字符串，每次都传入int(x, base=2)非常麻烦，于是，我们想到，可以定义一个int2()的函数，默认把base=2传进去\ndef int2(x, base=2):\n    return int(x, base)\n这样，我们转换二进制就非常方便了：\n>>> int2('1000000')\n64\n>>> int2('1010101')\n85\nfunctools.partial 就是帮助我们创建一个偏函数的，不需要我们自己定义int2()，可以直接使用下面的代码创建一个新的函数int2：\n>>> import functools\n>>> int2 = functools.partial(int, base=2)\n>>> int2('1000000')\n64\n>>> int2('1010101')\n85\nPython 高级特性\n切片\n切片是Python提供处理Iterable类型数据的一个工具.\n>>> L = list(range(100))\n\n# 前10个元素\n>>> L[:10] # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# 后10个元素\n>>> L[-10:] # [90, 91, 92, 93, 94, 95, 96, 97, 98, 99]\n\n# 前11-20个元素\n>>> L[10:20] # [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]\n\n# 前10个数，每两个取一个\n>>> L[:10:2] # [0, 2, 4, 6, 8]\n\n# 倒数第3个~倒数第5个\n>>> L[-5:-2][::-1] # [97, 96, 95]\n\n>>> 'ABCDEFG'[:3] # 'ABC'\n>>> 'ABCDEFG'[::2] # 'ACEG'\n>>> 'ABC'[::-1] # 'CBA'\nIterable[起始位置=0:截至位置=len(Iterable):步长=1]\n迭代\n我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）\nd = {'a': 1, 'b': 2, 'c': 3}\n\nfor k in d:\n    print(k) \n# a b c\n\nfor v in d.values():\n    print(v)\n# 1 2 3\n\nfor k, v in d.items():\n    print(k, '-', v)\n# a - 1 b - 2 c - 3\n如何判断一个对象是可迭代对象呢？\n>>> from collections import Iterable\n>>> isinstance('abc', Iterable) # str是否可迭代\nTrue\n>>> isinstance([1,2,3], Iterable) # list是否可迭代\nTrue\n>>> isinstance(123, Iterable) # 整数是否可迭代\nFalse\n\n迭代tuple\nfor x, y in [(1, 1), (2, 4), (3, 9)]:\n    print('{0}-{1}'.format(x, y))\n# 1-1 2-4 3-9\n列表生成式\n从一定意义上来说, 列表生成式可以做到的, 用map()函数也可以做到.但列表生成器更容易, 更直观.\n我现在需要一个数组2次方后的一个数组.\nL = [1, 2, 3, 4, 5]\nL1 = map(lambda x: x * x, L)\nL2 = [x * x for x in L]\nprint(L1) # object.map\nprint(L2) #[1, 4, 9, 16, 25]\n其实, 还可以这样^_^\nt = [1, 2, 3]\nl = [t[i] * t[i + 1] for i in range(len(t) -1)]\nprint(l) # [2, 6]\n生成器\n在Python中，这种一边循环一边计算的机制，称为generator(生成器)\ng = (x * x for x in range(10))\nprint(g) # <generator object <genexpr> at 0x1101431a8>\n和列表生成式不同的是, 生成器返回的是一个Iterable, 而列表生成式返回的是一个数组\ngenerator:  存储的是计算规则, 并没有真实的数据. 遍历时, 每次返回的数据, 都是按照所存储的计算规则计算出的\ndef odd():\n    n = 1\n    while True:\n        yield n\n        n += 2\n\no = odd()\nprint(next(o)) # 1\nprint(next(o)) # 3\nodd不是普通函数，而是generator，在执行过程中，遇到yield就中断，下次又继续执行。\n最后附上一位大神用generator实现的杨辉三角\ndef triangles():\n    t = [1]\n    while True:\n        yield t\n        t= [t[i] + t[i-1] for i in range(1,len(t))]\n        t.insert(0,1) # 第一位始终为 1\n        t.append(1) # 最后一位始终为 1\n迭代器\n凡是可作用于for循环的对象都是Iterable类型；凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；集合数据类型如list、dict、str等是Iterable, 但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。\nPython 模块\n\n这是我项目中各文件的路径.我在hello.py中希望引用我web模块下的utils中的函数\nfrom web.utils import reverse\nprint(reverse(\"123\"))\n\nimport web.utils\nweb.utils.welcome(\"Tom\")\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "0"}