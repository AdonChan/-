{"title": "流畅的 Python - 1. 序列类型 - 个人文章 ", "index": "python", "content": "今天看第二章，但是没看完，被其他事缠住了。\n首先登场的是 Python 的内置序列类型，对此我并不陌生，但也有几个生面孔，但是基本的操作我想应该是一样的，只是类型不同。\n对列表的操作中，经常用到的就是列表推导和生成器表达式。刚开始对这概念还有点模糊，之前只是听过，不清楚自己有没用过。但看书之后，发现自己都用过。\n列表推导可用来优雅地创建一个新的列表，而生成器表达式可以优雅地创建其他类型的序列。除此之外，生成器表达式逐个产出元素比用 for 循环节省内存。\n对于元组，之前的印象一直都是「不可变列表」。但现在发现元组的功能远比我想象的要强。首先元组就是记录的数据，字段和位置信息很重要，位置乱了，数据也就乱了。\n一个新成员登场了，那就是具名元组。这个之前没接触过。同样的记录数据，这个可能会更加方便一点，因为数据记录更加清晰，书上介绍的一个属性（获取该对象的所有字段名称组成的元组）和两个函数（通过可迭代对象生成一个实例，和把具名元组以collections.OrderedDict的形式返回）。\n对于元组的拆分，之前也用过，但是对*运算的却没怎么了解。除了可以用来忽略多余的元素，还可以「把一个可迭代对象拆开作为函数的参数」。平行赋值中，用在一个变量名前，表示不确定数量，也只能出现在一个变量名前。\n对序列最常用的操作还有就是切片了。之前一直有接触但不怎么了解的就是s[a:b:c]了，它表示「对 s 在 a 和 b之间以 c 为间隔取值」。之前对此概念比较模糊，现在算是理清了。\n一个之前没用过的技巧就是，对切片进行赋值。这把切片的内容直接替换了。还有 splice 对象，直接把切片包装了。\n对列表的+和*操作还是比较熟悉的，毕竟用的多。\n最后就是排序了，列表自带的list.sort()和内置的sort函数不同，自带的函数把自身排序了，返回的是None，而内置的sort函数不破坏对象本身，而是返回一个新的对象，并且是稳定排序。\n剩下的一点内容还没看完，明天看吧。\n\n后面的先出场的是关于已经有序的序列的操作。这次使用的模块是bisect，可以用来搜索，返回的是该元素应该插入在序列的哪个位置。有可选参数，表示值相同时，应该插入到已有值的左边还是右边，默认是右边。插入操作就是用到了上面的方法。\n然后是数组，之前一直没用过，如作者所说，列表实在是太好用了。但不可否认，数组对于一些固定类型的元素，操作效率更高。比如直接以二进制形式存到文件中比纯文本存消耗的空间要少得多，而且读取时也不用再进行转换。\n然后是两个第三方模块，但主要讲了 Numpy 模块。Numpy 模块对于数学操作很方便，功能也很强大。想学的话，需要专门看一下。\n内存视图的话，有点陌生。看了之后感觉还是有点不懂怎么用。\n 内存视图其实是泛化和去数学化的 NumPy 数组。它让你在不需要复制内容的前提下，在数据结构之间共享内存。其中数据结构可以\n是任何形式，比如 PIL图片、SQLite 数据库和 NumPy 的数组，等等。这个功能在处理大型数据集合的时候非常重要。\n不过书上的例子的操作是看懂了。\n最后出场的是队列了。列表虽然也能做到队列那样的操作，但是效率是个问题。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}