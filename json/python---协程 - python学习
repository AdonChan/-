{"title": "python---协程 - python学习 ", "index": "python", "content": "引子\n之前我们学习了线程、进程的概念，了解了在操作系统中进程是资源分配的最小单位,线程是CPU调度的最小单位。按道理来说我们已经算是把cpu的利用率提高很多了。但是我们知道无论是创建多进程还是创建多线程来解决问题，都要消耗一定的时间来创建进程、创建线程、以及管理他们之间的切换。　　随着我们对于效率的追求不断提高，基于单线程来实现并发又成为一个新的课题，即只用一个主线程（很明显可利用的cpu只有一个）情况下实现并发。这样就可以节省创建线进程所消耗的时间。　　为此我们需要先回顾下并发的本质：切换+保存状态 　 cpu正在运行一个任务，会在两种情况下切走去执行其他的任务（切换由操作系统强制控制），一种情况是该任务发生了阻塞，另外一种情况是该任务计算的时间过长\n\n在介绍进程理论时，提及进程的三种执行状态，而线程才是执行单位，所以也可以将上图理解为线程的三种状态 一：其中第二种情况并不能提升效率，只是为了让cpu能够雨露均沾，实现看起来所有任务都被“同时”执行的效果，如果多个任务都是纯计算的，这种切换反而会降低效率。　　为此我们可以基于yield来验证。yield本身就是一种在单线程下可以保存任务运行状态的方法：\n1 yiled可以保存状态，yield的状态保存与操作系统的保存线程状态很像，但是yield是代码级别控制的，更轻量级\n2 send可以把一个函数的结果传给另外一个函数，以此实现单线程内程序之间的切换\n#串行执行\nimport time\ndef consumer(res):\n    '''任务1:接收数据,处理数据'''\n    pass\n\ndef producer():\n    '''任务2:生产数据'''\n    res=[]\n    for i in range(10000000):\n        res.append(i)\n    return res\n\nstart=time.time()\n#串行执行\nres=producer()\nconsumer(res) #写成consumer(producer())会降低执行效率\nstop=time.time()\nprint(stop-start) #1.874000072479248\n\n\n#基于yield并发执行\nimport time\ndef consumer():\n    '''任务1:接收数据,处理数据'''\n    while True:\n        print(\"this is consumer\")\n        x=yield\n\ndef producer():\n    '''任务2:生产数据'''\n    g=consumer()\n    next(g)\n    for i in range(10):\n        print(\"this is prodecer\")\n        g.send(i)\n\nstart=time.time()\n#基于yield保存状态,实现两个任务直接来回切换,即并发的效果\n#PS:如果每个任务中都加上打印,那么明显地看到两个任务的打印是你一次我一次,即并发执行的.\nproducer()\n\nstop=time.time()\nprint(stop-start) #2.0272178649902344\n\n二：第一种情况的切换。在任务一遇到io情况下，切到任务二去执行，这样就可以利用任务一阻塞的时间完成任务二的计算，效率的提升就在于此。\nimport time\ndef consumer():\n    '''任务1:接收数据,处理数据'''\n    while True:\n        x=yield\n\ndef producer():\n    '''任务2:生产数据'''\n    g=consumer()\n    next(g)\n    for i in range(10000000):\n        g.send(i)\n        time.sleep(2)\n\nstart=time.time()\nproducer() #并发执行,但是任务producer遇到io就会阻塞住,并不会切到该线程内的其他任务去执行\n\nstop=time.time()\nprint(stop-start)\n对于单线程下，我们不可避免程序中出现io操作，但如果我们能在自己的程序中（即用户程序级别，而非操作系统级别）控制单线程下的多个任务能在一个任务遇到io阻塞时就切换到另外一个任务去计算，这样就保证了该线程能够最大限度地处于就绪态，即随时都可以被cpu执行的状态，相当于我们在用户程序级别将自己的io操作最大限度地隐藏起来，从而可以迷惑操作系统，让其看到：该线程好像是一直在计算，io比较少，从而更多的将cpu的执行权限分配给我们的线程。\n协程的本质就是在单线程下，由用户自己控制一个任务遇到io阻塞了就切换另外一个任务去执行，以此来提升效率。为了实现它，我们需要找寻一种可以同时满足以下条件的解决方案：\n1. 可以控制多个任务之间的切换，切换之前将任务的状态保存下来，以便重新运行时，可以基于暂停的位置继续执行。\n2. 作为1的补充：可以检测io操作，在遇到io操作的情况下才发生切换\n\n\n协程介绍\n协程：是单线程下的并发，又称微线程，纤程。英文名Coroutine。一句话说明什么是线程：协程是一种用户态的轻量级线程，即协程是由用户程序自己控制调度的。需要强调的是：\n1. python的线程属于内核级别的，即由操作系统控制调度（如单线程遇到io或执行时间过长就会被迫交出cpu执行权限，切换其他线程运行）\n2. 单线程内开启协程，一旦遇到io，就会从应用程序级别（而非操作系统）控制切换，以此来提升效率（！！！非io操作的切换与效率无关）\n\n对比操作系统控制线程的切换，用户在单线程内控制协程的切换优点如下：\n1. 协程的切换开销更小，属于程序级别的切换，操作系统完全感知不到，因而更加轻量级\n2. 单线程内就可以实现并发的效果，最大限度地利用cpu\n缺点如下：\n1. 协程的本质是单线程下，无法利用多核，可以是一个程序开启多个进程，每个进程内开启多个线程，每个线程内开启协程\n2. 协程指的是单个线程，因而一旦协程出现阻塞，将会阻塞整个线程\n\n总结协程特点：\n1.必须在只有一个单线程里实现并发\n2.修改共享数据不需加锁\n3.用户程序里自己保存多个控制流的上下文栈\n4.一个协程遇到IO操作自动切换到其它协程（如何实现检测IO，yield、greenlet都无法实现，就用到了gevent模块（select机制））   \nGevent模块\n安装：pip3 install geventGevent 是一个第三方库，可以轻松通过gevent实现并发同步或异步编程，在gevent中用到的主要模式是Greenlet, 它是以C扩展模块形式接入Python的轻量级协程。 Greenlet全部运行在主程序操作系统进程的内部，但它们被协作式地调度。用法介绍\ng1=gevent.spawn(func,1,,2,3,x=4,y=5)创建一个协程对象g1，spawn括号内第一个参数是函数名，\n如eat，后面可以有多个参数，可以是位置实参或关键字实参，都是传给函数eat的\n\ng2=gevent.spawn(func2)\n\ng1.join() #等待g1结束\n\ng2.join() #等待g2结束\n\n#或者上述两步合作一步：gevent.joinall([g1,g2])\n\ng1.value#拿到func1的返回值\n例：遇到io主动切换\nimport gevent\ndef eat(name):\n    print('%s eat 1' %name)\n    gevent.sleep(2)\n    print('%s eat 2' %name)\n\ndef play(name):\n    print('%s play 1' %name)\n    gevent.sleep(1)\n    print('%s play 2' %name)\n\n\ng1=gevent.spawn(eat,'egon')\ng2=gevent.spawn(play,'egon')\ng1.join()\ng2.join()\n#或者gevent.joinall([g1,g2])\nprint('主')\n上例gevent.sleep(2)模拟的是gevent可以识别的io阻塞,而time.sleep(2)或其他的阻塞,gevent是不能直接识别的需要用下面一行代码,打补丁,就可以识别了\nfrom gevent import monkey;monkey.patch_all()必须放到被打补丁者的前面，如time，socket模块之前\n或者我们干脆记忆成：要用gevent，需要将from gevent import monkey;monkey.patch_all()放到文件的开头\nfrom gevent import monkey;monkey.patch_all()\n\nimport gevent\nimport time\ndef eat():\n    print('eat food 1')\n    time.sleep(2)\n    print('eat food 2')\n\ndef play():\n    print('play 1')\n    time.sleep(1)\n    print('play 2')\n\ng1=gevent.spawn(eat)\ng2=gevent.spawn(play)\ngevent.joinall([g1,g2])\nprint('主')\n我们可以用threading.current_thread().getName()来查看每个g1和g2，查看的结果为DummyThread-n，即假线程\nfrom gevent import monkey;monkey.patch_all()\nimport threading\nimport gevent\nimport time\ndef eat():\n    print(threading.current_thread().getName())\n    print('eat food 1')\n    time.sleep(2)\n    print('eat food 2')\n\ndef play():\n    print(threading.current_thread().getName())\n    print('play 1')\n    time.sleep(1)\n    print('play 2')\n\ng1=gevent.spawn(eat)\ng2=gevent.spawn(play)\ngevent.joinall([g1,g2])\nprint('主')\nGevent之同步与异步\nfrom gevent import spawn, joinall, monkey;monkey.patch_all()\nimport time\ndef task(pid):\n    \"\"\"\n    Some non-deterministic task\n    \"\"\"\n    time.sleep(0.5)\n    print('Task %s done' % pid)\n\n\ndef synchronous():  # 同步\n    for i in range(10):\n        task(i)\ndef asynchronous():  # 异步\n    g_l = [spawn(task, i) for i in range(10)]\n    joinall(g_l)\n    print('DONE')\nif __name__ == '__main__':\n    print('Synchronous:')\n    synchronous()\n    print('Asynchronous:')\n    asynchronous()\n#  上面程序的重要部分是将task函数封装到Greenlet内部线程的gevent.spawn。\n#  初始化的greenlet列表存放在数组threads中，此数组被传给gevent.joinall 函数，\n#  后者阻塞当前流程，并执行所有给定的greenlet任务。执行流程只会在 所有greenlet执行完后才会继续向下走。\n协程socket\nfrom gevent import monkey;monkey.patch_all()\nimport socket\nimport gevent\n\ndef talk(conn):\n    while True:\n        conn.send(b'hello')\n        print(conn.recv(1024))\n\nsk = socket.socket()\nsk.bind(('127.0.0.1',9090))\nsk.listen()\n\nwhile True:\n    conn,addr = sk.accept()\n    g = gevent.spawn(talk,conn)\n\n                ", "mainLikeNum": ["4 "], "mainBookmarkNum": "4"}