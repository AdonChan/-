{"title": "[Regular Expression]Mastering Python Regular Expression基础通俗(2) - cherishsir ", "index": "python,regexp", "content": "\n续上:[Regular Expression]Mastering Python Regular Expression基础通俗(1)\n\n三类常用的metacharacters的简写形式（偷懒需要）\n#metacharacters用来对某一类特定字符进行匹配，通常，我们用的最多的字符就是下面的三类\n#数字，字母 和 space \\t这类看不到占位符，上一部分学过通过方括号表示这三类的metacharacters的方法\n[0-9],[a-zA-Z],[ \\t\\n\\r\\v\\f]\n#由于上面的表达试比较长，所以需要有一种更简单的写法：\n [0-9] 可以写成\\d\n [a-zA-Z0-9_] 可以写成\\w\n [ \\t\\n\\r\\v\\f] 可以写成\\s\n 对上面metacharacters取反的写法分别为 \\D ,\\W,\\S (全部大写即可）\n \n点(dot)字符的使用\n\n点这个字符作为一最常用的metacharacter，可以匹配任何一个字符，但是不对newline（换行）进行匹配\n举例：\ng/.../p  #这个正则会匹配三个任意字符，但是字符不能为newline\n\n过度使用dot字符，会给阅读带来困难，写正则时，应试尽量做到精确匹配\n如需要匹配的字符确定是数字，就使用\"\\d\",而不要选择使用\".\" \n\n\nwin and 类unix系统中路径分割符的匹配\n先看例子：\ng/[^\\/\\]/p\n\n讲解：\n^ :这个符号是取反情况的意思 \n\\/ :对 /这个符号进行匹配，(因为 这个/符号本身是需要转义)\n\\ :对 \\进行匹配，\n\n所以上面的正则表达式的意思是：只要不是 / 和 \\ 字符，其它的字符都会匹配 \n在windows系统下路径分割符为：\\\n在类unix系统下路径分割符为：/\n“或”符号（alternatation)的使用方法 \n想像一下，我们需要把输入文本中“be smart”和\"be stupid\" 匹配出来，应该怎么写正则呢？\n\n这时应该使用或符号 | 来完成这样的工作：\ng/be (smart|stupid)/p   #注意还使用了圆括号哦！\n\ng/yes|no|maybe/p     #这时会对yes,no,maybe三个单词中的任何一个进行匹配  多个|符号的连用\n数量限定符(quantifiers)的使用方法\n先记住数量限定符，使用这四个符号：?  *  +  {n,m}\n\n他们的意思分别是：\n? : 该符号前面的字符可以出现0个或1个\n* : 该符号前面的字符可以出来0个或多个\n+ : 该符号前面的字符可以出现1个或多个\n{n,m}:该符号前面的字符，最小出现n个，最多出现m个\n\n举例说明就懂了：\n来个简单的：\ng/carS?/p  #  由于?数量限定符，表示前面的字符可以出来0次，或1次，那个这个正则就是在对car 和 carS进行匹配\n\n来个复杂一点的：\n如果我们需要对555-555-555 和 555 555 555和  555555555 进行正则匹配\n\n进行正则匹配的意思就是说，我们写的一个正则表达式，可以把上面三种情况都包含在内：\n实现如下：\ng/\\d+[-\\s]?\\d+[-\\s]?\\d+/p \n\n解析：\n\\d是对数字进行匹配，\n+号表示前面的数字可以有1个或多个，\n[-\\s]表示-或space的二个选一个字符的匹配，\n?表示前面的字符可以出现0次或1次\n\n由于上面的数字个数是确定的，我们也可以用精确的数字来进行匹配，如下：\ng/\\d{3}[-\\s]?\\d{3}[-\\s]?\\d{3}/p\n\n上面的{3} 表示前面的字符（这里是\\d)只能出现三次\n\n对{n,m}进行更多的说明：\n{,m}:前面的字符可出现0到m次\n{n,}:前面的字符可以出现n到无穷次\n\n由此可知：？ * +可以使用{n,m}来表示，只是? * +这样写更省事\n? 等价于 {0,1}\n* 等价于 {0,}\n+ 等价于 {1,}\n数量限定的符的两种工作模式 ：\n通过例子来说明这两种工作模式：\n如果我们使用g/\".+\"/p 正则对下面这句话进行匹配，会得到什么结果？\nEnglish \"hello\" ,Spanish \"hola\"   \n\n很显然，可能会出现两种情况：\n情况1：  匹配到结果为： \"hello\"\n情况2：  匹配到结果为： \"hello\" ,Spanish \"hola\"\n\n上面两种情况就对应了数量限定符 +，的工作模式\n上面的情况2,我们称为Greedy模式 （贪婪模式 ）\n上面的情况1，我们称为Reluctant模式 （勉强够模式）\n\npython中模式使用的是Greedy模式，如果我们想要使用Reluctant模式，也很容易，只需要在+后面加一个？即可\n如下：\ng/\".+?\"/p  #在数量限定符+后面添加了?,这时就会使用Reluctant模式 \n\n\n所以在Python中，当你看到有两个数量限定符时，并且第二个限定符为?时，你需要马上知道第二个数量限定符的作用是\n表示使用Reluctant模式 \n\n\n对边界进行匹配的metacharacters\n思考：对于一个输入文件，我们有什么边界：\n1：文本的开头，和文本的结束\n2：在文本中行的开头，行的结束\n3：单词的边界，（非单词的边界）\n\n对于行的开头和结束，使用^ 和 $进行匹配\n对于文件的开关和结束，使用 \\A 和\\Z进行匹配\n对于单词的边界使用\\b,进行匹配，（非单词的边界使用\\B进行匹配）\n\n举例说明：\n g/^name:/p #对文件中 所有行的开始，内容为name: 的行进行匹配\n\n下面的 1,3,4行就满足正则匹配的结果\n\n下面为进行匹配的文本\nname:Tom\nabc\nname:Jim \nname:\nxxname:abc\n\n来个复杂一点的例子：\ng/^name:[\\sa-zA-z]+$/p\n\n解释：\n看到正则表达式前面后^  $， 就知道行首行尾的内容都要满足要求\n以name:开头的行，然后 后面可以接空格或大小写字母， + 代表前面的字符至少要出现1次\n\n\n最后一个例子（下面两个比较一下）：\ng/hello/p      #这个正则会把hello ,helloxxx,xxhello, xxhelloxx 都匹配出来\ng/\\bhello\\b/p  #这个正则只会把单独的 hello 这个单词匹配出来\n\n第一章总结：\n正则表达式中的主要内容：literal and metacharacters\n\n三个括号的使用:\n()与 |搭配使用\n[] 单个字符的集合，如[0-9a-z]\n{} 属于数量限定符{m,n}\n\n学习了数量限定符： ？ * + {}\n学习了边界匹配符： ^ $ \\A \\Z \\b \\B\n学习了常用字符集合的表达方式 [0-9],[0-9a-zA-Z],[  \\s\\t\\r\\n\\f\\v] ,取反[^\n学习了三类字符的简写式：/s, /d, /w  取反 /S ,/D, /W\n点字符 匹配除newline以外的所有单个字符 \n注意：上面基础内容，需要经常回顾！！容易遗忘\n后面进入Python实战部分：re module的使用\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}