{"title": "Tensorflow Python API 翻译（constant_op） - 个人文章 ", "index": "python", "content": "作者：chen_h微信号 & QQ：862251340微信公众号：coderpai简书地址：https://www.jianshu.com/p/d05...\n\n计划现将 tensorflow 中的 Python API 做一个学习，这样方便以后的学习。原文链接\n\n该章介绍有关常量张量，序列操作，随机数张量的API\n\n常量张量\nTensorflow提供了很多的操作，去帮助你构建常量。\n\ntf.zeros(shape, dtype = tf.float32, name = None)\n解释：这个函数返回一个全是零的张量，数据维度是 shape，数据类型是 dtype。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np \n\nsess = tf.Session()\ndata = tf.zeros(shape = [2, 3], dtype = tf.int32, name = \"input_data\")\nprint sess.run(data)\n输入参数：\n\n\nshape: 一个整型的数组，或者一个一维的Tensor，数据类型是：int32。\n\ndtype: 输出结果Tensor的数据类型。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，里面的所以数据都是0。\n\ntf.zeros_like(tensor, dtype = None, name = None)\n解释：这个函数返回一个全是零的张量，数据维度是和Tensor一样，数据类型是默认是和Tensor一样，但是我们也可以自己指定。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np \n\nsess = tf.Session()\ndata = tf.zeros(shape = [2, 3], dtype = tf.int32, name = \"input_data\")\nd_1 = tf.zeros_like(data)\nd_2 = tf.zeros_like(data, tf.float32)\nprint sess.run(d_1)\nprint sess.run(d_2)\n输入参数：\n\n\ntensor: 一个Tensor。\n\ndtype: 输出结果Tensor的数据类型，必须是 float32，float64，int8，int16，int32，int64，uint8或者complex64。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，里面的所以数据都是0。\n\ntf.ones(shape, dtype = tf.float32, name = None)\n解释：这个函数返回一个全是1的张量，数据维度是shape，数据类型是dtype。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np \n\nsess = tf.Session()\ndata = tf.ones(shape = [2, 3], dtype = tf.int32, name = \"input_data\")\nprint sess.run(data)\n输入参数：\n\n\nshape: 一个整型的数组，或者一个一维的Tensor，数据类型是 int32。\n\ndtype: 输出结果Tensor的数据类型。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，里面的所以数据都是1。\n\ntf.ones_like(tensor, dtype = None, name = None)\n解释：这个函数返回一个全是一的张量，数据维度是和Tensor一样，数据类型是默认是和Tensor一样，但是我们也可以自己指定。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np \n\nsess = tf.Session()\ndata = tf.zeros(shape = [2, 3], dtype = tf.int32, name = \"input_data\")\nd_1 = tf.ones_like(data)\nd_2 = tf.ones_like(data, tf.float32)\nprint sess.run(d_1)\nprint sess.run(d_2)\n输入参数：\n\n\ntensor: 一个Tensor。\n\ndtype: 输出结果Tensor的数据类型，必须是 float32，float64，int8，int16，int32，int64，uint8或者complex64。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，里面的所以数据都是1。\n\ntf.fill(dims, value, name = None)\n解释：这个函数返回一个Tensor，数据维度是dims，填充的数据都是value。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np \n\nsess = tf.Session()\ndata = tf.fill([2,3], 9)\nprint sess.run(data)\n输入参数：\n\n\ndim: 一个Tensor，数据类型是int32，表示输出数据的维度。\n\nvalue: 一个Tensor，数据维度是0维，即是一个常量（标量），输出数据所以填充的都是该值。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和value相同。\n\ntf.constant(value, dtype = None, shape = None, name = 'Const')\n解释：这个函数返回一个常量Tensor。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np \n\nsess = tf.Session()\ndata = tf.constant([1, 2, 3])\nprint sess.run(data)\ndata = tf.constant(-1.0, shape = [2, 3])\nprint sess.run(data)\ndata = tf.constant(2.0, dtype = tf.float32, shape = [2, 3])\nprint sess.run(data)\n输入参数：\n\n\nvalue: 一个常量或者是一个数组，该数据类型就是输出的数据类型。\n\ndtype: 输出数据的类型。\n\nshape:（可选）输出数据的维度。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个常量Tensor。\n\n序列操作\nTensorflow提供了一些函数，去帮助我们构建序列。\n\ntf.linspace(start, stop, num, name = None)\n解释：这个函数返回一个序列数组，数组的第一个元素是start，如果num>1，那么序列的最后一个元素就是 stop - start / num - 1。也就是说，最后一个元素肯定是stop。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np \n\nsess = tf.Session()\ndata = tf.linspace(10.0, 15.0, 10)\nprint sess.run(data)\n输入参数：\n\n\nstart: 一个Tensor。数据类型必须是float32或者float64。该值是输出序列的第一个元素。\n\nstop: 一个Tensor。数据类型必须和start相同。该值是输出序列的最后一个元素。\n\nnum: 一个Tensor，数据类型是int32。该值确定输出序列的个数\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和start相同，数据维度是一维。\n\ntf.range(start, limit, delta = 1, name = 'range')\n解释：这个函数返回一个序列数组，数组的第一个元素是start，之后的每一个元素都在前一个元素的基础上，加上delta，直到limit，但是不包括limit。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np \n\nsess = tf.Session()\ndata = tf.range(3, 15, 3)\nprint sess.run(data)\n输入参数：\n\n\nstart: 一个0维的Tensor，即一个标量。数据类型必须是int32。该值是输出序列的第一个元素。\n\nlimit: 一个0维的Tensor，即一个标量。数据类型必须是int32。该值是输出序列的最后限制，但不包含该值。\n\ndelta: 一个0维的Tensor，即一个标量。数据类型必须是int32。（可选）该值默认是1，也就是说输出数据从start开始。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型int32，数据维度是一维。\n\n随机数张量\nTensorflow提供了一些函数，去帮助我们构建随机数张量。\n\ntf.random_normal(shape, mean = 0.0, stddev = 1.0, dtype = tf.float32, seed = None, name = None)\n解释：这个函数返回一个随机数序列，数组里面的值按照正态分布。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np \n\nsess = tf.Session()\ndata = tf.random_normal([2, 3])\nprint sess.run(data)\n输入参数：\n\n\nshape: 一个一维的Tensor，或者是一个python数组。该值是确定输出序列的数据维度。\n\nmean: 一个0维的Tensor，或者一个数据类型是dtype的python值。该值表示正态分布的均值。\n\nstddev: 一个0维的Tensor，或者一个数据类型是dtype的python值，该值表示正态分布的标准偏差。\n\ndtype: 输出数据的数据类型。\n\nseed: 一个python整型，为分布产生一个随机种子，具体可以参见set_random_seed函数。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型是dtype，数据维度是shape，里面的值符合正态分布。\n\ntf.truncated_normal(shape, mean = 0.0, stddev = 1.0, dtype = tf.float32, seed = None, name = None)\n解释：这个函数返回一个随机数序列，数组里面的值按照正态分布，但和random_normal函数不同的是，该值返回的是一个截断的正态分布类型。也就是说，产生出来的值范围都是在 [mean - 2 * standard_deviations, mean + 2 * standard_deviations]内，下图可以告诉你这个具体范围在哪。\n\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np \n\nsess = tf.Session()\ndata = tf.truncated_normal([2, 3])\nprint sess.run(data)\n输入参数：\n\n\nshape: 一个一维的Tensor，或者是一个python数组。该值是确定输出序列的数据维度。\n\nmean: 一个0维的Tensor，或者一个数据类型是dtype的python值。该值表示正态分布的均值。\n\nstddev: 一个0维的Tensor，或者一个数据类型是dtype的python值，该值表示正态分布的标准偏差。\n\ndtype: 输出数据的数据类型。\n\nseed: 一个python整型，为分布产生一个随机种子，具体可以参见set_random_seed函数。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型是dtype，数据维度是shape，里面的值是一个截断的正态分布。\n\ntf.random_uniform(shape, minval = 0.0, maxval = 1.0, dtype = tf.float32, seed = None, name = None)\n解释：这个函数返回一个随机数序列，数组里面的值按照均匀分布，数据范围是 [minval, maxval)。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np \n\nsess = tf.Session()\ndata = tf.random_uniform([2, 3])\nprint sess.run(data)\n输入参数：\n\n\nshape: 一个一维的Tensor，或者是一个python数组。该值是确定输出序列的数据维度。\n\nminval: 一个0维的Tensor，或者一个数据类型是dtype的python值。该值表示均匀分布的最小值。\n\nmaxval: 一个0维的Tensor，或者一个数据类型是dtype的python值，该值表示均匀分布的最大值，但是不能取到该值。\n\ndtype: 输出数据的数据类型。\n\nseed: 一个python整型，为分布产生一个随机种子，具体可以参见set_random_seed函数。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型是dtype，数据维度是shape，里面的值符合均匀分布。\n\ntf.random_shuffle(value, seed = None, name = None)\n解释：这个函数返回一个随机数序列，将value中的数据打乱输出。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np \n\nsess = tf.Session()\ndata = tf.constant([[1, 2], [3, 4], [5, 6]])\nshuff_data = tf.random_shuffle(data)\nprint sess.run(data)\nprint sess.run(shuff_data)\n\ndata = tf.constant([1, 2, 3, 4, 5, 6])\nshuff_data = tf.random_shuffle(data)\nprint sess.run(data)\nprint sess.run(shuff_data)\n输入参数：\n\n\nvalue: 一个Tensor，需要打乱的数据。\n\nseed: 一个python整型，为分布产生一个随机种子，具体可以参见set_random_seed函数。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和数据维度都和value相同。\n\ntf.set_random_seed(seed)\n解释：这个函数是设置图层面的随机种子。随机种子分为两类，一类是图层面的随机种子，另一类是操作层面的随机种子。具体区别如下：\n第一种，如果图层面和操作层面的随机种子都没有设置，那么随机种子将在每个操作中被更新。例子如下：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np \n\na = tf.random_uniform([1])\nb = tf.random_normal([1])\n\nprint \"Session 1\"\nwith tf.Session() as sess1:\n    print sess1.run(a)  # generates 'A1'\n    print sess1.run(a)  # generates 'A2'\n    print sess1.run(b)  # generates 'B1'\n    print sess1.run(b)  # generates 'B2'\n\nprint \"Session 2\"\nwith tf.Session() as sess2:\n    print sess2.run(a)  # generates 'A3'\n    print sess2.run(a)  # generates 'A4'\n    print sess2.run(b)  # generates 'B3'\n    print sess2.run(b)  # generates 'B4'\n第二种，如果图层面的随机种子被设置了，但是操作层面的随机种子没有被设置。那么，系统将把图层面的随机种子设置成操作层面的随机种子，以至于操作层面的随机种子将被确定下来。\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np \n\ntf.set_random_seed(1234)\na = tf.random_uniform([1])\nb = tf.random_normal([1])\n\n# Repeatedly running this block with the same graph will generate different\n# sequences of 'a' and 'b'.\nprint \"Session 1\"\nwith tf.Session() as sess1:\n    print sess1.run(a)  # generates 'A1'\n    print sess1.run(a)  # generates 'A2'\n    print sess1.run(b)  # generates 'B1'\n    print sess1.run(b)  # generates 'B2'\n\nprint \"Session 2\"\nwith tf.Session() as sess2:\n    print sess2.run(a)  # generates 'A1'\n    print sess2.run(a)  # generates 'A2'\n    print sess2.run(b)  # generates 'B1'\n    print sess2.run(b)  # generates 'B2'\n第三种，如果图层面的随机种子没有被设置，但是操作层面的随机种子被设置了，那么被设置随机种子的操作层将有确定的唯一种子，其他操作层不具有唯一种子。\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np \n\na = tf.random_uniform([1], seed=1)\nb = tf.random_normal([1])\n\n# Repeatedly running this block with the same graph will generate the same\n# sequence of values for 'a', but different sequences of values for 'b'.\nprint \"Session 1\"\nwith tf.Session() as sess1:\n    print sess1.run(a)  # generates 'A1'\n    print sess1.run(a)  # generates 'A2'\n    print sess1.run(b)  # generates 'B1'\n    print sess1.run(b)  # generates 'B2'\n\nprint \"Session 2\"\nwith tf.Session() as sess2:\n    print sess2.run(a)  # generates 'A1'\n    print sess2.run(a)  # generates 'A2'\n    print sess2.run(b)  # generates 'B3'\n    print sess2.run(b)  # generates 'B4'\n第四种，如果图层面和操作层面都设置了随机种子，那么这两个随机种子都将被使用，但是最后起作用的随机种子是唯一的，即操作的随机输出值是确定的。\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np \n\ntf.set_random_seed(1234)\na = tf.random_uniform([1], seed = 1)\nb = tf.random_normal([1], seed = 2)\n\n# Repeatedly running this block with the same graph will generate the same\n# sequence of values for 'a', but different sequences of values for 'b'.\nprint \"Session 1\"\nwith tf.Session() as sess1:\n    print sess1.run(a)  # generates 'A1'\n    print sess1.run(a)  # generates 'A2'\n    print sess1.run(b)  # generates 'B1'\n    print sess1.run(b)  # generates 'B2'\n\nprint \"Session 2\"\nwith tf.Session() as sess2:\n    print sess2.run(a)  # generates 'A1'\n    print sess2.run(a)  # generates 'A2'\n    print sess2.run(b)  # generates 'B1'\n    print sess2.run(b)  # generates 'B2'\n输入参数：\n\nseed: 一个整数类型。\n\n作者：chen_h微信号 & QQ：862251340简书地址：https://www.jianshu.com/p/d05...\nCoderPai 是一个专注于算法实战的平台，从基础的算法到人工智能算法都有设计。如果你对算法实战感兴趣，请快快关注我们吧。加入AI实战微信群，AI实战QQ群，ACM算法微信群，ACM算法QQ群。长按或者扫描如下二维码，关注 “CoderPai” 微信号（coderpai）\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}