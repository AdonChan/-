{"title": "Django增加QQ第三方登录 - python技术的魅力 ", "index": "qq第三方登录,qq互联,qq登录,python,django", "content": "准备工作_OAuth2.0\n接入QQ登录前，网站需首先进行申请，获得对应的appid与appkey，以保证后续流程中可正确对网站与用户进行验证与授权。\n在开发的过程中，发现获取不到QQ号，只能获取一个OpenID的东西。最后采取存储这个OpenID并绑定对应账号的方式。所以需要创建对应的模型，即创建一个应用管理第三方登录。\nQQ登录功能开发流程如下图:\n第1步、QQ互联注册网站应用\n打开QQ互联，进入管理中心。注册一下应用开发者，并添加网站应用，获得对应的appid与appkey。\n\n申请appid和appkey的用途appid：应用的唯一标识。在OAuth2.0认证过程中，appid的值即为oauth_consumer_key的值。appkey：appid对应的密钥，访问用户资源时用来验证应用的合法性。在OAuth2.0认证过程中，appkey的值即为oauth_consumer_secret的值。 \n\n\n理解回调地址需要了解一下OAuth协议。在你的网站页面里面，打开授权页面（这个授权页面不是回调地址）。在授权页面里面，登录QQ并确认授权。授权之后，会得到一个授权码。回调地址就是用于接收这个授权码。授权码以GET的方式返回，例如 http://www.junxi.site/web/oau...通过这种方式，可以获取授权码，所以需要提供一个地址。这个地址先写一个暂时没有的地址，后面开发的时候，再给这个地址写对应的响应方法。\n第2步、放置QQ按钮\n这个QQ按钮是提供QQ登录的入口。从腾讯提供的QQ按钮下载放到你的登录页面即可。不用看帮助文档里面的什么前端代码。这些用不上，只需要加一个固定的访问链接，再重定向即可。前端页面此处的代码如下：\n<div>\n    <span>其他登录方式：</span>\n    <a href=\"{% url 'qq_login' %}\">\n        ![](/static/images/connect_qq.png)\n    </a>\n</div>\nqq_login链接在下面第3步创建web应用里面设置。\n第3步、创建web应用\n怎么创建应用就不细说了，这是基本功。这里我已经创建了一个名称为web的django app应用。创建完成之后，打开models.py文件，编写模型：\n#!/usr/bin/env python\n# _*_ coding:utf-8 _*_\n__author__ = 'junxi'\n\nimport sys\nreload(sys)\nsys.setdefaultencoding('utf8')\n\nclass OAuthQQ(models.Model):\n    \"\"\"QQ and User Bind\"\"\"\n    user = models.ForeignKey(UserProfile)   # 关联用户信息表\n    qq_openid = models.CharField(max_length=64)   # QQ的关联OpenID\n    \n    # def __str__(self):\n    #    return self.user\n该模型用于存储QQ登录返回的OpenID值。这个OpenID值是用QQ号一一对应。腾讯不给得到真实QQ号可能是出于保护隐私的考虑。\n在总的urls路由中，加入这个应用路由。(总路由在和工程名一样的文件夹中的urls.py文件。这种方式对urls管理比较清晰)\nfrom django.conf.urls import url, include\nfrom django.contrib import admin\nimport web.urls\nimport web.views\n\nurlpatterns = [\n    url(r'^admin/', admin.site.urls),\n    url(r'^web/', include(web.urls)),\n]\n路由控制根据自己的工程自己写即可。\n打开web应用目录下urls.py文件，先写一下需要哪些链接地址：\nfrom django.conf.urls import url\nfrom .views import *\n\nurlpatterns = [\n    url(r'^oauth/qq/login/$', login, name='qq_login'),\n    url(r'^oauth/qq/check/$', login, name='qq_check'),\n    url(r'^oauth/bind/account/$', login, name='bind_account'),\n]\nqq_login和qq_check，分别是打开授权页面和回调地址。bind_account是绑定用户的页面。大致思路是授权之后，得到OpenID。判断这个OpenID是否存在数据库中。若存在，则直接登录对应的用户即可；若不存在，则打开这个绑定邮箱页面，绑定对应的用户。\n第4步、开发OAuth登录功能\n为了管理好OAuth，在web应用的文件夹下创建oauth_client.py文件。把相关的OAuth操作方法集成在一起。编辑oauth_client.py文件：\n#!/usr/bin/env python\n# _*_ coding:utf-8 _*_\n__author__ = 'junxi'\n\nimport json\nimport urllib, urllib2, urlparse\n\n\nclass OAuthQQ:\n    def __init__(self, client_id, client_key, redirect_uri):\n        self.client_id = client_id\n        self.client_key = client_key\n        self.redirect_uri = redirect_uri\n\n    def get_auth_url(self):\n        \"\"\"获取授权页面的网址\"\"\"\n        params = {'client_id': self.client_id,\n                  'response_type': 'code',\n                  'redirect_uri': self.redirect_uri,\n                  'scope': 'get_user_info',\n                  'state': 1}\n        url = 'https://graph.qq.com/oauth2.0/authorize?%s' % urllib.urlencode(params)\n        return url\n创建一个类，需要申请QQ登录的APP_ID、APP_KEY和回调地址。这些都是固定的，我把这几个常量放入到settings.py中。settings.py添加如下常量，具体的值请在你的申请页面查找（这里还需要提一下，本地调试的方法。因为授权之后是调整到部署之后的网站上，而部署的网站还没开发响应的代码，无法响应对应的地址。这里我是本地测试环境，强制绑定Hosts域名文件解析）：\n\n# OAuth设置\nQQ_APP_ID = 'XXXXXX'\nQQ_KEY = 'XXXXXX'\nQQ_RECALL_URL = 'http://www.junxi.site/web/oauth/qq/check'\n回到OAuthQQ类，现里面有个get_auth_url方法。该方法是获取打开授权页面的链接地址。（可参考官方帮助，写得不够清晰）\n接着，在编辑web应用的views.py文件，加入qq_login对应的响应方法：\nfrom django.shortcuts import HttpResponseRedirect\nfrom django.conf import settings\nfrom oauth_client import OAuthQQ\n \n\ndef qq_login(request):\n    oauth_qq = OAuthQQ(settings.QQ_APP_ID, settings.QQ_KEY, settings.QQ_RECALL_URL)\n \n    #获取 得到Authorization Code的地址\n    url = oauth_qq.get_auth_url()\n    #重定向到授权页面\n    return HttpResponseRedirect(url)\n到这里为止，就完成了点击QQ登录按钮，跳转到授权页面。登录授权之后，授权页面会自动跳转到我们设置的回调地址。例如 http://www.junxi.site/web/oau...我们可以获取这个地址上面的GET参数。先假设我们可以顺利获取到，继续完善OAuthQQ类。拿到这个授权码之后，需要用该码获取腾讯的access_token通行令牌。\n打开oauth_client.py文件，在OAuthQQ类添加如下方法：\n    def get_access_token(self, code):\n        \"\"\"根据code获取access_token\"\"\"\n        params = {'grant_type': 'authorization_code',\n                  'client_id': self.client_id,\n                  'client_secret': self.client_key,\n                  'code': code,\n                  'redirect_uri': self.redirect_uri}    # 回调地址\n        url = 'https://graph.qq.com/oauth2.0/token?%s' % urllib.urlencode(params)\n\n        # 访问该网址，获取access_token\n        response = urllib2.urlopen(url).read()\n        result = urlparse.parse_qs(response, True)\n\n        access_token = str(result['access_token'][0])\n        self.access_token = access_token\n        return access_token\n该方法使用了urllib2，在服务器后台访问对应的链接，获取access_token，并返回该值。因为我后续不需要用access_token做其他动作，直接一次性获取QQ昵称和OpenID。所以不用记录这个通行令牌的有效期。\n得到这个access_token之后，就可以做其他事了。首先需要获取授权用户的OpenID，因为腾讯不允许获取QQ号。只好退而求次，获取并保存OpenID。可参考官方文档。继续给这个OAuthQQ添加获取OpenID的方法和使用OpenID获取QQ基本信息的方法：\n    def get_open_id(self):\n        \"\"\"获取QQ的OpenID\"\"\"\n        params = {'access_token': self.access_token}\n        url = 'https://graph.qq.com/oauth2.0/me?%s' % urllib.urlencode(params)\n\n        response = urllib2.urlopen(url).read()\n        v_str = str(response)[9:-3]  # 去掉callback的字符\n        v_json = json.loads(v_str)\n\n        openid = v_json['openid']\n        self.openid = openid\n        return openid\n\n    def get_qq_info(self):\n        \"\"\"获取QQ用户的资料信息\"\"\"\n        params = {'access_token': self.access_token,\n                  'oauth_consumer_key': self.client_id,\n                  'openid': self.openid}\n        url = 'https://graph.qq.com/user/get_user_info?%s' % urllib.urlencode(params)\n\n        response = urllib2.urlopen(url).read()\n        return json.loads(response)\n腾讯返回OpenID和QQ基本信息的内容格式都不一样。\n再回头编辑views.py，添加回调地址的处理方法：\nfrom django.shortcuts import render, HttpResponseRedirect, HttpResponse, reverse # reverse url逆向解析\nfrom django.http import JsonResponse\nfrom . import models\nfrom .form import *\nimport json\nimport time\nfrom django.conf import settings\nfrom oauth_client import OAuthQQ\n\ndef qq_check(request):  # 第三方QQ登录，回调函数\n        \"\"\"登录之后，会跳转到这里。需要判断code和state\"\"\"\n        request_code = request.GET.get('code')\n        oauth_qq = OAuthQQ(settings.QQ_APP_ID, settings.QQ_KEY, settings.QQ_RECALL_URL)\n\n        # 获取access_token\n        access_token = oauth_qq.get_access_token(request_code)\n        time.sleep(0.05)  # 稍微休息一下，避免发送urlopen的10060错误\n        open_id = oauth_qq.get_open_id()\n        print open_id\n\n        # 检查open_id是否存在\n        qq_open_id = models.OAuthQQ.objects.filter(qq_openid=str(open_id))\n        print qq_open_id\n        if qq_open_id:\n            # 存在则获取对应的用户，并登录\n            user = qq_open_id[0].user.username\n            print user\n            request.session['username'] = user\n            return HttpResponseRedirect('/web/')\n        else:\n            # 不存在，则跳转到绑定用户页面\n            infos = oauth_qq.get_qq_info()  # 获取用户信息\n            url = '%s?open_id=%s&nickname=%s' % (reverse('bind_account'), open_id, infos['nickname'])\n            return HttpResponseRedirect(url)\n按照思路，授权之后，调整到处理授权结果的页面。获取授权码之后，用get_access_token方法得到access_token。再用access_token获取OpenID。坑出现了，若不加time.sleep(0.05)休息一下的话，会得到urlopen 10060错误。获取到open_id之后，再判断一下数据库中是否存在。若存在，则已经关联对应的用户了，直接登录该用户。若open_id不存在，则跳转到绑定用户的页面。该页面需要知道open_id和QQ昵称（为什么需要QQ昵称，下一步会提到）。通过GET方式，把这两个参数写在链接上即可传递过去。\n本地调试，先本地打开授权页面授权，得到一个回调地址。回调地址上有授权码，如下图：\n\n\n\n第5步、绑定用户\n上面提到若open_id在数据库中不存在，则打开绑定用户页面。该页面我设计成html表单，在templates下新建qq-bind-account.html文件。如下代码：\n{% extends 'base.html' %}\n\n{% block title %}\n    <title>QQ和账户绑定</title>\n{% endblock %}\n\n{% block head-js %}\n{% endblock %}\n\n{% block nav %}\n{% endblock %}\n\n{% block content %}\n<form class=\"form-horizontal\" enctype=\"multipart/form-data\" action=\"\" method=\"post\">\n    <div class=\"login\">\n        <h1><a href=\"{% url 'index' %}\">Primumest</a></h1>\n        <div class=\"login-bottom\">\n            <h2>HI，![](/static/images/connect_qq.png){{ nickname }}！您已登录。请绑定用户，完成QQ登录。</h2>\n            <div class=\"col-md-6\">\n                <div class=\"login-mail\">\n                    <input type=\"text\" placeholder=\"请输入你的账户名\" name=\"username\" required=\"\">\n                    <i class=\"fa fa-user\"></i>\n                </div>\n                <div class=\"login-mail\">\n                    <input type=\"text\" placeholder=\"请输入你的昵称\" name=\"nickname\" required=\"\">\n                    <i class=\"fa fa-users\"></i>\n                </div>\n                <div class=\"login-mail\">\n                    <input type=\"password\" placeholder=\"请输入密码\" name=\"password\" required=\"\">\n                    <i class=\"fa fa-lock\"></i>\n                </div>\n                <div class=\"login-mail\">\n                    <input type=\"password\" placeholder=\"请再次输入密码\" name=\"password\" required=\"\">\n                    <i class=\"fa fa-lock\"></i>\n                </div>\n            </div>\n            <div class=\"col-md-6 login-do\">\n                <label class=\"hvr-shutter-in-horizontal login-sub\">\n                    <input type=\"submit\" value=\"确定\">\n                </label>\n            </div>\n            <div class=\"clearfix\"></div>\n        </div>\n    </div>\n</form>\n    <!---->\n    <div class=\"copy-right\">\n        <p>© 2017 JunXi. All Rights Reserved</p>\n    </div>\n{% endblock %}\n接着，在views.py继续编辑，添加表单处理的对应方法：\ndef bind_account(request):  # 绑定账户\n    open_id = request.GET.get('open_id')\n    nickname = request.GET.get('nickname')\n    if request.method == 'POST' and request.POST:\n        data = request.POST # 接收到前台form表单传过来的注册账户信息\n        user = models.UserProfile()\n        username = data['username']\n        password = data['password'].split(',')[0]\n        user.username = username\n        password = hash_sha256(password, username)\n        user.password = password\n        user.nickname = data['nickname']\n        user.departments_id = 1\n        user.save()\n        oauthqq = models.OAuthQQ()\n        oauthqq.qq_openid = open_id\n        oauthqq.user_id = models.UserProfile.objects.get(username=username).id\n        oauthqq.save()\n        response = HttpResponseRedirect(\"/web/\")\n        request.session['username'] = username  # 设置session\n        return response  # 返回首页\n    return render(request, 'qq-bind-account.html', locals())\n访问测试：打开首页点击QQ登录\n\n获取授权并登录\n写完代码之后，本地测试可以通过。最后再部署到服务器并在QQ互联提交审核。一般审核要1~2天左右。若审核不通过，又不明白审核说明，就直接找客服问问。\n-----<我是分割线，下面是项目在pycharm中的展示>-----\n\n\n-----<我是分割线，下面是urls.py、view.py、oauth_client.py完整的代码>-----urls.py\nurlpatterns = [\n    url(r'^oauth/qq/login', qq_login, name='qq_login'),\n    url(r'^oauth/qq/check', qq_check, name='qq_check'),\n    url(r'^oauth/bind/account', bind_account, name='bind_account'),\n]\nviews.py\n#!/usr/bin/env python\n# _*_ coding:utf-8 _*_\n__author__ = 'junxi'\n\nfrom django.shortcuts import render, HttpResponseRedirect, HttpResponse, reverse # reverse url逆向解析\nfrom django.http import JsonResponse\nfrom . import models\nfrom .form import *\nfrom script.salt_api import salt\nfrom script.web_ssh import webssh\nfrom django.contrib.auth.hashers import make_password, check_password\n# from django.forms.models import model_to_dict\nfrom django.core import serializers\nimport datetime\nimport json\nimport hashlib\nimport re\nimport time\nimport os\nfrom django.conf import settings\nfrom oauth_client import OAuthQQ\n\n\ndef hash_sha256(password, username):  # sha256加密\n    sha256 = hashlib.sha256()\n    sha256.update((password + username).encode('utf-8'))\n    sha256_password = sha256.hexdigest()\n    return sha256_password\n\n\ndef qq_login(request):  # 第三方QQ登录\n    oauth_qq = OAuthQQ(settings.QQ_APP_ID, settings.QQ_KEY, settings.QQ_RECALL_URL)\n\n    # 获取 得到Authorization Code的地址\n    url = oauth_qq.get_auth_url()\n    # 重定向到授权页面\n    return HttpResponseRedirect(url)\n\n\ndef qq_check(request):  # 第三方QQ登录，回调函数\n        \"\"\"登录之后，会跳转到这里。需要判断code和state\"\"\"\n        request_code = request.GET.get('code')\n        oauth_qq = OAuthQQ(settings.QQ_APP_ID, settings.QQ_KEY, settings.QQ_RECALL_URL)\n\n        # 获取access_token\n        access_token = oauth_qq.get_access_token(request_code)\n        time.sleep(0.05)  # 稍微休息一下，避免发送urlopen的10060错误\n        open_id = oauth_qq.get_open_id()\n        print open_id\n\n        # 检查open_id是否存在\n        qq_open_id = models.OAuthQQ.objects.filter(qq_openid=str(open_id))\n        print qq_open_id\n        if qq_open_id:\n            # 存在则获取对应的用户，并登录\n            user = qq_open_id[0].user.username\n            print user\n            request.session['username'] = user\n            return HttpResponseRedirect('/web/')\n        else:\n            # 不存在，则跳转到绑定用户页面\n            infos = oauth_qq.get_qq_info()  # 获取用户信息\n            url = '%s?open_id=%s&nickname=%s' % (reverse('bind_account'), open_id, infos['nickname'])\n            return HttpResponseRedirect(url)\n\n\ndef bind_account(request):  # 绑定账户\n    open_id = request.GET.get('open_id')\n    nickname = request.GET.get('nickname')\n    if request.method == 'POST' and request.POST:\n        data = request.POST # 接收到前台form表单传过来的注册账户信息\n        user = models.UserProfile()\n        username = data['username']\n        password = data['password'].split(',')[0]\n        user.username = username\n        password = hash_sha256(password, username)\n        user.password = password\n        user.nickname = data['nickname']\n        user.departments_id = 1\n        user.save()\n        oauthqq = models.OAuthQQ()\n        oauthqq.qq_openid = open_id\n        oauthqq.user_id = models.UserProfile.objects.get(username=username).id\n        oauthqq.save()\n        response = HttpResponseRedirect(\"/web/\")\n        request.session['username'] = username  # 设置session\n        return response  # 返回首页\n    return render(request, 'qq-bind-account.html', locals())\noauth_client.py\n#!/usr/bin/env python\n# _*_ coding:utf-8 _*_\n__author__ = 'junxi'\n\nimport json\nimport urllib, urllib2, urlparse\n\n\nclass OAuthQQ:\n    def __init__(self, client_id, client_key, redirect_uri):\n        self.client_id = client_id\n        self.client_key = client_key\n        self.redirect_uri = redirect_uri\n\n    def get_auth_url(self):\n        \"\"\"获取授权页面的网址\"\"\"\n        params = {'client_id': self.client_id,\n                  'response_type': 'code',\n                  'redirect_uri': self.redirect_uri,\n                  'scope': 'get_user_info',\n                  'state': 1}\n        url = 'https://graph.qq.com/oauth2.0/authorize?%s' % urllib.urlencode(params)\n        return url\n\n    def get_access_token(self, code):\n        \"\"\"根据code获取access_token\"\"\"\n        params = {'grant_type': 'authorization_code',\n                  'client_id': self.client_id,\n                  'client_secret': self.client_key,\n                  'code': code,\n                  'redirect_uri': self.redirect_uri}    # 回调地址\n        url = 'https://graph.qq.com/oauth2.0/token?%s' % urllib.urlencode(params)\n\n        # 访问该网址，获取access_token\n        response = urllib2.urlopen(url).read()\n        result = urlparse.parse_qs(response, True)\n\n        access_token = str(result['access_token'][0])\n        self.access_token = access_token\n        return access_token\n\n    def get_open_id(self):\n        \"\"\"获取QQ的OpenID\"\"\"\n        params = {'access_token': self.access_token}\n        url = 'https://graph.qq.com/oauth2.0/me?%s' % urllib.urlencode(params)\n\n        response = urllib2.urlopen(url).read()\n        v_str = str(response)[9:-3]  # 去掉callback的字符\n        v_json = json.loads(v_str)\n\n        openid = v_json['openid']\n        self.openid = openid\n        return openid\n\n    def get_qq_info(self):\n        \"\"\"获取QQ用户的资料信息\"\"\"\n        params = {'access_token': self.access_token,\n                  'oauth_consumer_key': self.client_id,\n                  'openid': self.openid}\n        url = 'https://graph.qq.com/user/get_user_info?%s' % urllib.urlencode(params)\n\n        response = urllib2.urlopen(url).read()\n        return json.loads(response)\n参考文章。。。。。。\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "7"}