{"title": "再次阅读 Tornado 中的 coroutine 代码 - kamushin ", "index": "tornado,python", "content": "一年多前的文章 http://segmentfault.com/a/1190000000426460 这次重新读，再加上一些 js 中 co给我的知识，有了更深的理解。\nFront Knowledge\nyield and generator will be the front knowledge of this article. And you should also have some sense of epoll/kqueue and callback style.   Let's enjoy the source code of the implement of coroutine.\nPython Tornado\nA simple async fetch function used by a coroutine in Python, exception handle removed\ndef fetch(self, request):\n    future = TracebackFuture() # TracebackFuture == Future\n    def handle_response(response):\n        future.set_result(response)\n    self.fetch_impl(request, handle_response) # This is a async function\n    return future\n\ndef fetch_impl(self, request, callback):\n    pass\nfuture -- an instance of Future -- is an object that used to collect and send result to generator.  \nA coroutine that uses above fetch\n@gen.coroutine\ndef request(self, uri):\n    response = yield http.fetch(uri)\nAnd we all know @gen.coroutine is a syntax sugar of\nrequest = gen.coroutine(request)\ncoroutine wrapper function, also exception handle removed\ndef _make_coroutine_wrapper(func, replace_callback):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        future = TracebackFuture()\n        try:\n            result = func(*args, **kwargs) # result is a generator if the function is a generator function\n        except (Return, StopIteration) as e:\n            result = getattr(e, 'value', None)\n        else:\n            if isinstance(result, types.GeneratorType): # if the function is a generator function\n                try:\n                    yielded = next(result) # generator.next() will run the code above and right hand of the generator, for our example request here, http.fetch(uri) will run and return yielded(a instance of Future).\n                except (StopIteration, Return) as e:\n                    future.set_result(getattr(e, 'value', None))\n                else:\n                    Runner(gen=result, result_future=future, first_yielded=yielded) # Runner is like the co lib in Js written by TJ, Runner use a While True rather than recursive, because recursive is slower in Python.\n                return future\n            else: # or the function is jsut a normal function\n              pass \n        future.set_result(result)\n        return future\n    return wrapper\nWith the Tornado usage we can learn that the function after yield can be either a coroutine or a normal function.     Both of them returns a Future. You can write return Future by yourself or use @coroutine. But make sure your normal function is an async function.  \nRunner.run function, exception handle removed\ndef __init__(self, gen, result_future, first_yielded): # init of Runner\n    ... # some attrs bind\n    self.future = first_yielded # removed some complex logic, just show the basic logic of running the `request` generator.\n    self.io_loop.add_future(\n                self.future, lambda f: self.run()) # io_loop is a epoll based loop, the second function is a callback function when future is finished.\n\ndef run(self):\n\"\"\"Starts or resumes the generator, running until it reaches a\nyield point that is not ready.\n\"\"\"\n    while True:\n        if not future.done():\n            return\n        try:\n            value = future.result()\n            yielded = self.gen.send(value)\n        except (StopIteration, Return) as e:\n            self.finished = True\n            return\n        except Exception:\n            self.finished = True\n            return\n        if not self.handle_yield(yielded):\n            return\n\nRunner is like the co lib in Js written by TJ, Runner use a While True rather than recursive, because recursive is slower in Python.  Both of them do the same thing, that is executing the generator unitl it's done.\nFirst of all, Runner add the future, or we can say the async function fetch to io_loop. If fetch is finish, itself will invoke the callback function handle_response to set data to future. And the io_loop will invoke another callback function lambda f: self.run() to run the function run to get the result from future by value = future.result() and send to the generator by yield = gen.send(value) and start the next block of the generator function if exists until the whole function is stoped and return a StopIteration.\nSo let us figure out the effect of each object:\n\ngenerator function: a function with yield statement\ngenerator: invoke a generator function will return a generator\ncoroutine: a wrapper function to wrapper a generator function. It will create a runner to run the generator.\nFuture: used to collect and get result, it's a result container.\nRunner: it will register the future to io_loop and send result back to generator, and repeats unitl generator is done.\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}