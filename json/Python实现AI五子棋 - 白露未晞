{"title": "Python实现AI五子棋 - 白露未晞 ", "index": "python", "content": "公众号：Charles的皮卡丘作者：Charles\n开发工具：Python版本：3.6.4相关模块：graphics模块。\n环境搭建：安装Python并添加到环境变量即可。\n原理简介：对于五子棋这样的博弈类AI，很自然的想法就是让计算机把当前所有可能的情况都尝试一遍，找到最优的落子点。这里有两个问题：（1）如何把所有可能的情况都尝试一遍；（2）如何定量判断某落子点的优劣。对于第一个问题，其实就是所谓的博弈树搜索，对于第二个问题，其实就是所谓的选择评估函数。评估函数的选取直接决定了AI算法的优劣，其形式也千变万化。可以说，每个评估函数就是一个选手，对不同的棋型每个选手自然有不同的看法和应对措施，当然他们的棋力也就因此各不相同了。但博弈树搜索就比较固定了，其核心思想无非是让计算机考虑当前局势下之后N步所有可能的情况，其中奇数步（因为现在轮到AI下）要让AI方的得分最大，偶数步要让AI方的得分最小（因为对手也就是人类，也可以选择最优策略）。当然这样的搜索其计算量是极大的，这时候就需要剪枝来减少计算量。例如下图：其中A代表AI方，P代表人类方。AI方搜索最大值，人类方搜索最小值。因此Layer3的A1向下搜索的最终结果为4，Layer3的A2向下搜索，先搜索Layer4的P3，获得的分值为6，考虑到Layer2的P1向下搜索时取Layer3的A1和A2中的较小值，而Layer3的A2搜索完Layer4的P3时，其值就已经必大于Layer3的A1了，就没有搜索下去的必要了，因此Layer3到Layer4的路径3就可以剪掉了。上述搜索策略其实质就是：minimax算法+alpha-beta剪枝算法。了解了上述原理之后，就可以自己写代码实现了。当然实际实现过程中，我做了一些简化，但万变不离其宗，其核心思想都是一样的。\n视频演示：https://mp.weixin.qq.com/s/Y9...\n源代码：关注公众号：Charles的皮卡丘，回复“AI五子棋”获取。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "1"}