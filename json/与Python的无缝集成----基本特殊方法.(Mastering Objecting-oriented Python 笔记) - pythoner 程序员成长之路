{"title": "与Python的无缝集成----基本特殊方法.(Mastering Objecting-oriented Python 笔记) - pythoner 程序员成长之路 ", "index": "python", "content": "第二章 与Python的无缝集成----基本特殊方法.(Mastering Objecting-oriented Python 笔记)\npython中有有一些特殊的方法,它们允许我们的类和python更好的集成\n\n\n__repr__():\n__str__()\n__format__()\n__hash__()\n__bool__()\n__bytes__()\n__lt__()\n__le__()\n__eq__()\n__ne__()\n__gt__()\n__ge__()\n__new__()\n__del__()\n\n2.1 __repr__()和__str__()方法\n通常str()方法表示的对象对用户更加友好.这个方法是有对象的__str__()方法实现的.\n什么时候重写 __str__()跟__repr__()\n\n非集合对象: 一个不包括其他集合对象的'简单'对象,这类对象格式通常不会特别复杂\n集合对象:一个包括集合的对象,这类对象的格式化会非常复杂.\n\n非集合对象的__repr__()和__str__()\n\n问题1: 什么是集合?\nclass Card(object):\n    def __init__(self, rank, suit):\n        self.suit = suit\n        self.rank = rank\n        self.hard, self.soft = self._points()\n\n    def __repr__(self):\n        return '{__class__.__name__}(suit = {suit!r} , rank = {rank!r})'.format(\n            __class__=self.__class__, **self.__dict__\n        )\n\n    def __str__(self):\n        return '{rank}{suit}'.format(**self.__dict__)\n\n\nclass NumberCard(Card):\n    def _points(self):\n        return int(self.rank), int(self.rank)\n\n\nx = NumberCard('2', '♣')\n# 注意下面是重写后的\nprint(str(x))  # 2♣ \nprint(x)       # 2♣\nprint(repr(x)) # NumberCard(suit = '♣' , rank = '2')\n\n__format__()方法\n注意：‘{0!r}'.format()和'{0!s}'.format()并不会调用__format__()方法,它们会调用__repr__()或者__str__().\n\n__hash__()方法\n内置hash()函数调用了__hash__()方法.哈希是一种将复杂的值简化为小整数的计算方式.\npython有两个哈希库:\n\nhashlib\nzip 有两个搞笑的哈希函数adler32()和crc32()\n\n\nhash()函数主要被用来创建set,forzenset,dict这些集合类的键.这些集合利用了不可变对象的哈希值来高效的查找集合中的对象\n决定hash的对象\n并非每个对象都需要提供一个哈希值,尤其是,当我们创建一个包含有状态,可改变对象的类时.这类不应该返回哈希值,__hash__的定义 应该是None\n等价比较有三个层次：\n\n哈希值相等：意味着两个结果可能相等.哈希值是判断两个对象有可能相等的快捷方式,如果哈希值不同,两个对象不可能相等,也不可能是同一个对象.\n比较结果相等：意味着两个对象的哈希值已经是相等的，这个比较用的是==运算符.如果结果相等,那么两个对象的有可能是同一个.\nIDD 相等:这意味着两个对象是同一个对象,它们的哈希值仙童,并且使用==的比较结果相等,这个比较是用的是is运算符.\n\n\n**基本哈希法(Fundametal Law of Hash):比较相等的对象的哈希值一定相等.\n有关不可变对象和继承的默认行为\nclass Card(object):\n    def __init__(self, rank, suit, hard, soft):\n        self.suit = suit\n        self.rank = rank\n        self.hard = hard\n        self.soft = soft\n\n    def __repr__(self):\n        return '{__class__.__name__}(suit = {suit!r} , rank = {rank!r})'.format(\n            __class__=self.__class__, **self.__dict__\n        )\n\n    def __str__(self):\n        return '{rank}{suit}'.format(**self.__dict__)\n\n\nclass NumberCard(Card):\n    def __init__(self, rank, suit):\n        super().__init__(str(rank), suit, rank, rank)\n\n\nclass AceCard(Card):\n    def __init__(self, rank, suit):\n        super(AceCard, self).__init__(\"A\", suit, 1, 11)\n\n\nclass FaceCard(Card):\n    def __init__(self, rank, suit):\n        super(FaceCard, self).__init__({11: 'J',\n                                        12: 'Q',\n                                        13: 'K'}[rank], suit, 10, 10)\n\n\n\nc1 = AceCard(1,'♣')\nc2 = AceCard(1,'♣')\nprint(id(c1),id(c2)) # 52067024 52067120 \nid()值不同意味着是不同的对象.**is测试基于id()的值,哈希值根据id()值来计算的`\n重载不可变对象\n下面是一个重载了__hash__()和__eq__()定义的简单类.\nclass Card2(object):\n    def __init__(self, rank, suit, hard, soft):\n        self.suit = suit\n        self.rank = rank\n        self.hard = hard\n        self.soft = soft\n\n    def __repr__(self):\n        return '{__class__.__name__}(suit = {suit!r} , rank = {rank!r})'.format(\n            __class__=self.__class__, **self.__dict__\n        )\n\n    def __str__(self):\n        return '{rank}{suit}'.format(**self.__dict__)\n\n    def __eq__(self, other):\n        return self.suit == other.suit and self.rank == other.rank\n\n    def __hash__(self):\n        return hash(self.suit) ^ hash(self.rank)\n\n\nclass AceCard2(Card2):\n    insure = True\n\n    def __init__(self, rank, suit):\n        super().__init__(\"A\", suit, 1, 11)\n\n\nc1 = AceCard2(1, '♣')\nc2 = AceCard2(1, '♣')\n\nprint(id(c1), id(c2))     # id 是不相同的\nprint(c1 is c2)           # False\nprint(hash(c1), hash(c2)) # hash是相同的\nprint(c1 == c2)           # True\nprint(set([c1,c2]))       # {AceCard2(suit = '♣' , rank = 'A')}\n重载可变对象\n下面的类层级结构中,我们重载了可变对象的 __hash__()和__eq__()\nclass Card3(object):\n    def __init__(self, rank, suit, hard, soft):\n        self.suit = suit\n        self.rank = rank\n        self.hard = hard\n        self.soft = soft\n\n    def __repr__(self):\n        return '{__class__.__name__}(suit = {suit!r} , rank = {rank!r})'.format(\n            __class__=self.__class__, **self.__dict__\n        )\n\n    def __str__(self):\n        return '{rank}{suit}'.format(**self.__dict__)\n\n    def __eq__(self, other):\n        return self.suit == other.suit and self.rank == other.rank\n\n    __hash__ = None\n\nclass AceCard3(Card3):\n    insure = True\n\n    def __init__(self, rank, suit):\n        super().__init__(\"A\", suit, 1, 11)\n\n\ncc1 = AceCard3(1, '♣')\ncc2 = AceCard3(1, '♣')\n\nprint(id(cc1), id(cc2))     # id 是不相同的\n>>>8813424 8813616\nprint(cc1 is cc2)           # False\n>>>print(hash(cc1), hash(cc2)) # TypeError: unhashable type: 'AceCard3'\nTraceback (most recent call last):\n  File \"E:/cnki/cloudrepository/DataCleansingSystem/src/test/test_excel.py\", line 113, in <module>\n    print(set([cc1,cc2]))       # {AceCard2(suit = '♣' , rank = 'A')}\nTypeError: unhashable type: 'AceCard3'\n__hash__被设置为None,所以这些用Card3生成的对象不可以被哈希,也就无法通过hash()函数提供的哈希值了.\nprint(cc1 == cc2)           # True\nprint(set([cc1,cc2]))       # TypeError: unhashable type: 'AceCard3'\n从可变的Hand类中生成一个不可变的Hand类\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}