{"title": "关于Python类属性与实例属性的讨论 - _Zhao ", "index": "python", "content": "\n标题名字有点长。\n之所以想写这个文章是因为碰巧看到网上一篇关于Pyhon中类属性及实例属性区别的帖子。因为我之前也被这个问题困扰过，今天碰巧看到了这篇帖子，发现帖子的作者只是描述了现象，然后对原因的解释比较含糊，并没有从根本上解释这个问题，所以才想写一下我对这个问题的想法。\n\n\n性子急的可以直接跳到最后看总结。原帖子地址\n\n问题描述\n\n为了方便对比，我还是使用原帖子的例子：\n\nclass AAA():  \n    aaa = 10  \n\n# 情形1   \nobj1 = AAA()  \nobj2 = AAA()   \nprint obj1.aaa, obj2.aaa, AAA.aaa   \n\n# 情形2  \nobj1.aaa += 2  \nprint obj1.aaa, obj2.aaa, AAA.aaa   \n\n# 情形3  \nAAA.aaa += 3  \nprint obj1.aaa, obj2.aaa, AAA.aaa  \n\n\n情形1的结果是：10 10 10；\n情形2的结果是：12 10 10；\n情形3的结果是：12 13 13；\n\n首先为什么会有这个问题呢？\n因为aaa属性被称为类属性，既然是类属性，那么根据从C++/Java这种静态语言使用的经验来判断，类属性应该是为其实例所共享的。很自然的，既然是共享关系，那么从类的层次改变aaa的值，自然其实例的aaa的值也要跟着变化了。\n可是情形3的情况却说明，上面的说法是错的。\n错哪里呢？\n要从Python的类属性讲起\n\nPython中类属性的含义\n\nPython属于动态强类型的语言，在很多地方和静态语言不同，因此，不能把静态语言的规则套到动态语言上来。其中，类属性就是一个很好的例子。Python中属性的获取\n对于属性，我们通常采用类.属性或实例.属性的形式调用。\n例如上例中的AAA.aaa属于类.属性形式，obj1.aaa属于实例.属性的形式Python中属性的设置\n对于属性的设置我们通常采用类.属性 = 值或实例.属性 = 值的形式\n例如obj1.aaa = 3\n\n上例中obj1.aaa += 2等价于obj1.aaa = obj1.aaa + 2，这句话包含了属性获取及属性设置两个操作\n\nOK，重点来了，Python中属性的获取和设置的机制与静态语言是不同的，正是背后机制的不同，导致了Python中类属性不一定是为其实例所共享的\n\nPython中属性查找机制\n\nPython中属性的获取存在一个向上查找机制，还是拿上面的例子做说明：\nPython中一切皆对象，AAA属于类对象，obj1属于实例对象，从对象的角度来看，AAA与obj1是两个无关的对象，但是，Python通过下面的查找树建立了类对象AAA与实例对象obj1、obj2之间的关系。\n如图所示\n\n        AAA\n         |\n       -----\n      |     |  \n    obj1   obj2\n\n\n(图画的不好，见谅 -.-!!!)\n当调用AAA.aaa时，直接从AAA获取其属性aaa。\n但是情形1中调用obj1.aaa时，Python按照从obj1到AAA的顺序由下到上查找属性aaa。\n值得注意的这时候obj1是没有属性aaa的，于是，Python到类AAA中去查找，成功找到，并显示出来。所以，从现象上来看，AAA的属性aaa确实是共享给其所有实例的，虽然这里只是从查找树的形式模拟了其关系。\n\nPython中的属性设置\n\n原帖子的作者也指出问题的关键在于情形2中obj1.aaa += 2。\n为什么呢？\n上面我们指出obj.aaa += 2包含了属性获取及属性设置两个操作。即obj1.aaa += 2等价于obj1.aaa = obj1.aaa + 2。\n其中等式右侧的obj.aaa属于属性获取，其规则是按照上面提到的查找规则进行，即，这时候，获取到的是AAA的属性aaa，所以等式左侧的值为12。\n第二个操作是属性设置，即obj.aaa = 12。当发生属性设置的时候，obj1这个实例对象没有属性aaa，因此会为自身动态添加一个属性aaa。\n由于从对象的角度，类对象和实例对象属于两个独立的对象，所以，这个aaa属性只属于obj1，也就是说，这时候类对象AAA和实例对象aaa各自有一个属性aaa。\n那么，在情形3中，再次调用obj1.aaa时，按照属性调用查找规则，这个时候获取到的是实例对象obj1的属性aaa，而不是类对象AAA的属性aaa。\n\n对问题探讨的总结\n\n到这里就可以完满解释上面的问题：\n1. Python中属性的获取是按照从下到上的顺序来查找属性；\n2. Python中的类和实例是两个完全独立的对象；\n3. Python中的属性设置是针对对象本身进行的；\n\n对情形1的解释\n\n因为Python中的属性获取是按照从下到上的顺序来查找的，所以在情形1：\n\nobj1 = AAA()  \nobj2 = AAA()\n\n\n实例对象obj1和obj2不存在属性aaa。\n证明如下：\n\n>>> obj1.__dict__\n{}\n>>> obj2.__dict__\n{}\n\n\n所以，此时，obj1.aaa, obj2.aaa, AAA.aaa实质上都是指AAA.aaa。因此，输出同样的结果。\n\n对情形2的解释\n\n因为Python中的类和实例是两个完全独立的对象且Python中的属性设置是针对对象本身进行的，所以在情形2：\n\nobj1.aaa += 2  \n\n\n实质上是对实例对象obj1设置了属性aaa，并赋值为12。证明如下：\n\n>>> obj1.aaa = 3\n>>> obj1.__dict__\n{'aaa': 3}\n>>> obj2.__dict__\n{}\n\n\n因此，再次调用obj1.aaa时，将获取到的是实例对象obj1的属性aaa，而不是类对象AAA的属性aaa。而对于实例对象obj2，由于其并没有属性aaa，所以调用obj2.aaa时，获取到的是AAA的属性aaa。\n\n对情形3的解释\n\n顺利理解了前两个情形，那么第3个情形就很容易了，改变AAA的属性aaa只能影响到类对象AAA和实例对象obj2，不能影响obj1，因为，obj1存在aaa，在获取时，不会获取到AAA的属性。\n\n写在最后的话\n\n问题本身很简单，但是通过对这个问题的探讨，可以深入理解Python作为一个动态语言，在OOP的机制上与静态语言的差别。\n最关键的地方在于两点：\n1. 理解Python是如何利用查找树的机制来模仿类及实例之间的关系；\n2. 理解动态语言是可以动态设置属性的\n\n                ", "mainLikeNum": ["11 "], "mainBookmarkNum": "26"}