{"title": "Ryu-OVSDB 被动管理 - 个人文章 ", "index": "sdn,python,mininet", "content": "Ryu-OVSDB 被动管理\n一、设置交换机为被动监听模式\n1.1查看当前的配置\n# Show current configuration\n$ sudo ovs-vsctl get-manager\n返回结果应该为：ptcp:6640\n1.2 对交换机设置为被动管理模式\n被动管理模式设置：\n# Set TCP listen address\n$ sudo ovs-vsctl set-manager \"ptcp:6640\"\n补充主动管理模式官网教程：http://ryu.readthedocs.io/en/latest/library_ovsdb_manager.html\n\n控制器需要运行管理库应用\n交换机指定管理器为控制器的IP\n\n可以使用1.1的查看配置是否变化\n二、控制器端应用\n2.1 导入 vsctl 模块\nfrom ryu.lib.ovs import vsctl\n2.2 获取ovs交换机IP地址\n可以通过交换机连接控制器时，根据datapath获取交换机对应的IP地址。举个例子：通过监听交换机与控制器连接后，获取datapath 后读取datapath.address ：\n@set_ev_cls(ofp_event.EventOFPStateChange,\n            [MAIN_DISPATCHER, DEAD_DISPATCHER])\ndef _state_change_handler(self, ev):\n    datapath = ev.datapath\n    print(datapath.address)\n    if ev.state == MAIN_DISPATCHER:\n        if not datapath.id in self.datapaths:\n            self.logger.debug('Register datapath: %016x', datapath.id)\n            self.datapaths[datapath.id] = datapath\n    elif ev.state == DEAD_DISPATCHER:\n        if datapath.id in self.datapaths:\n            self.logger.debug('Unregister datapath: %016x', datapath.id)\n            del self.datapaths[datapath.id]\n    \n结果为：('交换机的IP地址',端口号)如果采用的是Mininet仿真拓扑，那么得到的地址:('mininet虚拟机的IP地址', 端口号)\n\n2.3 创建vsctl实例对象\nOVSDB_ADDR = 'tcp:127.0.0.1:6640'\novs_vsctl = vsctl.VSCtl(OVSDB_ADDR)\n2.4 编写命令\n等同于 $ ovs-vsctl show 作用：\ncommand = vsctl.VSCtlCommand('show')\novs_vsctl.run_command([command])\n执行完run_command，结果返回到command可以：print(command) 查看执行结果\n2.5 验证\n① 创建一个test_ovsdb.py,粘贴进官网提供的代码：\nfrom ryu.lib.ovs import vsctl\n\nOVSDB_ADDR = 'tcp:127.0.0.1:6640'\novs_vsctl = vsctl.VSCtl(OVSDB_ADDR)\n\n# Equivalent to\n# $ ovs-vsctl show\ncommand = vsctl.VSCtlCommand('show')\novs_vsctl.run_command([command])\nprint(command)\n# >>> VSCtlCommand(args=[],command='show',options=[],result='830d781f-c3c8-4b4f-837e-106e1b33d058\\n    ovs_version: \"2.8.90\"\\n')\n\n# Equivalent to\n# $ ovs-vsctl list Port s1-eth1\ncommand = vsctl.VSCtlCommand('list', ('Port', 's1-eth1'))\novs_vsctl.run_command([command])\nprint(command)\n# >>> VSCtlCommand(args=('Port', 's1-eth1'),command='list',options=[],result=[<ovs.db.idl.Row object at 0x7f525fb682e8>])\nprint(command.result[0].name)\n# >>> s1-eth1\n遇到如打印的消息是 u’’，可以采用encode(‘utf-8’)如：print(command.result[0].encode(‘utf-8‘))官网 OVSDB 库：http://ryu.readthedocs.io/en/latest/library_ovsdb.html\n\n② mininet 创建拓扑\nsudo mn --topo=linear,3 \\—\\-controller=remote\n生成一个三个交换机三个主机的拓扑\n③ 运行 test_ovsdb.py\nsudo python test_ovsdb.py\n可以把代码写进需要使用的Ryu应用中\n三、vsctl.py 解析\nclass ryu.lib.ovs.vsctl.VSCtl(remote)\nOpen vSwitch instance.\nrun_command(commands, timeout_sec=None, exception=None)\n执行命令&发送OVSDB 消息\nvsctl.py的vsctl类中的方法_run_command(self, commands)列举了可用的命令\ntimeout_sec：如果指定了，超时引发异常exception：如果指定了，将使用给定异常类包装异常\nRetruns None but fills result attribute for each command instance.\nclass ryu.lib.ovs.vsctl.VSCtlCommand（command，args = None，options = None ）\n\ncommand指定命令ovs-vsctl。\nargs 指定给定命令的参数列表或元组。\noptions指定给定命令的选项列表或元组。请注意，并非所有选项ovs-vsctl都受支持。例如，--id尚不支持选项。本课程支持以下内容。\n\n--may-exist: 给定端口已存在时什么都不做。支持的命令是add-port和 add-bond--fake-iface:将端口创建为虚假接口。支持的命令是add-bond--must-exist: 如果给定端口不存在，则引发异常。支持的命令是del-port—-with-iface: 对具有相同名称的接口生效。支持的命令是del-port--if-exists: 找不到时忽略异常。支持的命令是get\nryu.lib.ovs.vsctl.valid_ovsdb_addr(addr)\n如果 OVSDB 服务地址正确返回True，否则返回False有效的地址如下：\n\nunix:file\ntcp:ip:port\nssl:ip:port\n\n四、可用的命令\n4.1 查看交换机所连的控制器\ncommand = vsctl.VSCtlCommand('get-controler', (\"s1\", ))\novs_vsctl.run_command([command])\n4.2 设置交换机所连的控制器\n如下所示，设置交换机连接控制器C1(192.168.59.150)，C2(192.168.59.151)\ncommand = vsctl.VSCtlCommand('set-controller', (\"s1\",\"tcp:192.168.59.150:6653\",\"tcp:192.168.59.151\"))\novs_vsctl.run_command([command])\n详细怎么更改可以参照ovs-vsctl的命令对照着改ovs-vsctl 命令:https://blog.csdn.net/x_i_y_u_e/article/details/55105438\n\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "2"}