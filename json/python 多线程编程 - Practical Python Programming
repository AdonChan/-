{"title": "python 多线程编程 - Practical Python Programming ", "index": "concurrency,multi-thread,multiprocessing,python", "content": "python 多线程编程\n使用回调方式\nimport time\ndef countdown(n):\n    while n > 0:\n        print('T-minus', n)\n        n -= 1\n        time.sleep(5)\n\n# Create and launch a thread\nfrom threading import Thread\nt = Thread(target=countdown, args=(10,))\nt.start()\n使用继承方式\nfrom threading import Thread\n\nclass CountdownTask:\n    def __init__(self):\n        self._running = True\n\n    def terminate(self):\n        self._running = False\n\n    def run(self, n):\n        while self._running and n > 0:\n            print('T-minus', n)\n            n -= 1\n            time.sleep(5)\n\nc = CountdownTask()\nt = Thread(target=c.run, args=(10,))\nt.start()\nc.terminate() # Signal termination\nt.join()      # Wait for actual termination (if needed)\n注意使用变量 self._running 退出线程的方式\n使用 Queue 进行线程间通信\nimport Queue\nimport threading\nimport time\n\ntask_queue = Queue.Queue()\n\n\nclass ThreadTest(threading.Thread):\n    def __init__(self, queue):\n        threading.Thread.__init__(self)\n        self.queue = queue\n\n    def run(self):\n        while True:\n            msg = self.queue.get()\n            print(msg)\n            time.sleep(0.1)\n            self.queue.task_done()\n\n\ndef main():\n    start = time.time()\n    # populate queue with data\n    for i in range(100):\n        task_queue.put(\"message\")\n\n    # spawn a pool of threads, and pass them queue instance\n    for i in range(5):\n        t = ThreadTest(task_queue)\n        t.setDaemon(True)\n        t.start()\n\n    # wait on the queue until everything has been processed\n    task_queue.join()\n    print \"Elapsed Time: {}\".format(time.time() - start)\n\n\nif __name__ == \"__main__\":\n    main()\nsetDaemon 设置为 True, run 函数中不需要退出，主线程结束后所有子线程退出  如果 setDaemon 设置为 False,则改为\ndef run(self):\n    while not self.queue.empty():\n        msg = self.queue.get()\n        print(msg)\n        time.sleep(0.1)\n        self.queue.task_done()\n并且在主函数结束前 join 所有线程\n注意\n\n\n向队列中添加数据项时并不会复制此数据项，线程间通信实际上是在线程间传递对象引用。如果你担心对象的共享状态，那你最好只传递不可修改的数据结构（如：整型、字符串或者元组）或者一个对象的深拷贝。\n  from queue import Queue\n  from threading import Thread\n  import copy\n\n  # A thread that produces data\n  def producer(out_q):\n      while True:\n          # Produce some data\n          ...\n          out_q.put(copy.deepcopy(data))\n\n  # A thread that consumes data\n  def consumer(in_q):\n      while True:\n          # Get some data\n          data = in_q.get()\n          # Process the data\n          ...\n\nq.qsize() ， q.full() ， q.empty() 等实用方法可以获取一个队列的当前大小和状态。但要注意，这些方法都不是线程安全的。可能你对一个队列使用 empty() 判断出这个队列为空，但同时另外一个线程可能已经向这个队列中插入一个数据项。\n\n参考\n\npython3-cookbook Chapter 12 'Concurrency-Starting and Stopping Threads'\nPractical threaded programming with Python\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}