{"title": "Python学习之路8.2-对Python类的补充 - VPointer ", "index": "python,类,class", "content": "《Python编程：从入门到实践》笔记。本章主要是对上一章Python类的补充。\n1. 从一个类派生出所有类\n上一篇文章说道Python类的定义与继承一般是如下形式：\nclass A:   # 或者写成class A():\n    pass\n\nclass B(A):\n    pass\n其实，对于类A，它并不是算是一个真正意义上的基类，而是和Java类似，Python中所有的类最终都继承自object类（首字母小写，比较特殊），所以对于A的定义可以写成如下形式：\nclass A(object):\n    pass\n只是通常把object给省略了。\n2. 访问限制\n从上一篇中我们知道，类的属性可以被直接访问，如果需要对访问做一些限制，我们可以通过定义相应的方法。在Python中，对于一般的属性，用C++或Java的话来说，它们都是公有属性，外部可以直接访问，比如像下面的这个name属性：\nclass A:\n    def __init__(self, name):\n        self.name = name\n但如果我们在这个属性前面加两个下划线，将其变成如下形式：\nclass A:\n    def __init__(self, name):\n        self.__name = name\n那么name就变成了一个私有属性，它只能在对象的内部被访问，如果想以如下形式访问则会报错：\n# 代码：\nclass A:\n    -- snip --\n    \na = A(\"test\")\nprint(a.__name)\n\n# 结果：\nAttributeError: 'A' object has no attribute '__name'\n那是不是真的就访问不到这个属性了呢？说不清是有幸还是不幸，Python没有所谓的真正的私有属性，Python中类的所有属性都能被访问。Python解释器只是将__name换了个名称，变成了:\nself._A__name\n即在前面加了一个单下划线和类名。\n# 代码：\nclass A:\n    -- snip --\n    \na = A(\"test\")\nprint(a._A__name)\n\n# 结果：\ntest\n强烈不建议这样访问属性！而且，不同版本的Python解释器会将这样的属性改成不同的名字。\n3. 使用装饰器（decorator）\n在上一点中说到了通过方法来访问类的属性，这种方式一般叫做get/set方法，最后在调用时调用的是类的方法，现在我们使用Python内置的@property装饰器来访问类的属性，最后在调用时是调用的属性，实际上它是将类的方法通过装饰器变为属性。以下是通过装饰器和通过get/set方法来访问属性的代码比较：\nclass Teacher:\n    def __init__(self, name):\n        self.name = name\n\n    def get_name(self):\n        return self.name\n\n    def set_name(self, name):\n        # 可以加上一些限制\n        self.name = name\n\nclass Student:\n    def __init__(self, name):\n        self._name = name\n\n    @property\n    def name(self):\n        return self._name\n\n    @name.setter\n    def name(self, name):\n        # 可以加上一些限制\n        self._name = name\n\nt = Teacher(\"Miss\")\ns = Student(\"Boy\")\n\nprint(t.get_name())\nprint(s.name)\nt.set_name(\"Miss Lee\")\ns.name = \"Kevin\"\n从上述代码也可以看出，定义的时候，两者的代码量区别其实不大，但是在调用的时候，明显使用装饰器更方便些。\n4. 类中其它类型的属性\n类中除了普通的属性，以及上述的私有属性，还有前后都有双下划线的属性，例如__xxx__，它们是特殊变量，可以被直接访问，不是私有属性，所以一般不要起__name__，__score__这样的属性名，对于方法也是如此，不光有想__init__()这样的方法，还有很多前后都有双下划线的方法，比如__del__()，它是类的析构函数。在以后的文章中还会介绍许多这种方法。\n不光有双下划线的属性，还有单下划线的比如 _name，前单下划线，它表示的意思是：虽然能被访问，但请将其看做私有属性，不要随便访问。\n5. 对于多态的补充\n子类可以被看成是父类的类型，但父类不能被看成是子类的类型。比如：\n# 代码：\nclass Animal:\n    pass\n\nclass Dog(Animal):\n    pass\n\na = Animal()\nd = Dog()\n\nprint(isinstance(d, Animal))\nprint(isinstance(a, Dog))\n\n# 结果：\nTrue\nFalse\n也就是说，如果我们定义了这样一个函数：\ndef animal_run(animal):\n    animal.run()\n它接收Animal及其子类的所有对象，只要该类的run()方法正确编写，Python都能在解释时正确调用相应类的run()方法，即调用方只管调用animal_run()函数，不用管类的run()方法的细节，不管是现有的类还是新扩展出的子类，只要保证run()正确实现了，那么animal_run()就是正确的。这就是著名的“开闭原则”：对扩展开放，对修改封闭。\n6. 静态语言与动态语言\n仍以上面的animal_run()函数为例。对于像Java这样的静态语言，传入的参数必须是Animal及其子类，否则就无法调用run()方法。而对于像Python这样的动态语言，传入的不一定要求是Animal及其子类，只要这个对象有run()方法就行了。这就是动态语言的“鸭子类型”，只要“看起来像鸭子，走起道来像鸭子”，那它就能被看做是鸭子。Python的“file-like object”就是一种“鸭子类型”，对于真正的文件对象，都有一个read()方法，用于返回文件内容。但对于其他对象，只要正确实现了read()方法，即使它不是文件对象，它也能被看做是文件。\n7. 多重继承与MixIn设计\n前一篇文章中的继承是单继承，但Python和C++一样，支持多重继承；Java只支持单继承，她通过接口类来实现多重继承的效果。首先需要搞清楚多重继承为什么存在。仍然以Animal类为例，动物里有哺乳动物，卵生动物，有能飞的动物和不能飞的动物，这是两种大的分类方式。如果我们要派生出一个能飞的哺乳动物（比如蝙蝠），如果按照单一继承，可以按如下方式：\n\n也可以先从Animal继承出Runnable和Flyable两个类，再继承出哺乳类和卵生类（相当于将上图的二三层换了位置），但从这种单继承可以看出，如果分类增多，类的数量将呈指数级增加。故而一般采用多重继承的方式：\nclass Animal:\n    pass\n\nclass Mammalia(Animal):\n    pass\n\nclass Flyable:\n    def fly(self):\n        print(\"Flying...\")\n\nclass Bat(Mammalia, Flyable):\n    pass\n这样Bat类将具有Mammalia和Flyable两个父类的所有属性与方法。一般在Java中，以able为结尾类的都作为接口。\n在设计类的继承的时候，一般主线都是单一继承的，像上述例子中的从Animal派生出Manmalia，但如果后续的类中要混入一些额外的功能，但这功能又不是这个子类所独有的，比如上述的Flyable，那么就可以通过多重继承，从Manmalia和Runnable派生出Bat类，这就是MinIn设计，Java中采用接口来实现这种设计。\n为了更好的看出继承关系，一般将Runnable和Flyable类的名字改为RunnableMixIn和FlyableMixIn，同时，还可以定义出肉食动物CarnivorousMixIn和植食动物HerbivoresMixIn，让子类同时拥有好几个MinIn：\nclass Dog(Mammalia, RunnableMixIn, CarnivorousMixIn):\n    pass\n所以在设计类时，我们应该优先考虑通过多重继承来组合多个MinIn，而不是直接考虑更多层次的继承关系。\n最后，本篇较多内容是根据廖雪峰老师的博客再理解而来的，感谢廖雪峰老师！\n\n迎大家关注我的微信公众号\"代码港\" & 个人网站 www.vpointer.net ~\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}