{"title": "如何正确地使用Python的属性和描述符 - 寻寻觅觅 ", "index": "描述符,属性,python", "content": "关于@property装饰器\n在Python中我们使用@property装饰器来把对函数的调用伪装成对属性的访问。\n那么为什么要这样做呢？因为@property让我们将自定义的代码同变量的访问/设定联系在了一起，同时为你的类保持一个简单的访问属性的接口。\n举个栗子，假如我们有一个需要表示电影的类：\nclass Movie(object):\n    def __init__(self, title, description, score, ticket):\n        self.title = title\n        self.description = description\n        self.score = scroe\n        self.ticket = ticket\n　　\n\n你开始在项目的其他地方使用这个类，但是之后你意识到：如果不小心给电影打了负分怎么办？你觉得这是错误的行为，希望Movie类可以阻止这个错误。 你首先想到的办法是将Movie类修改为这样：\nclass Movie(object):\n    def __init__(self, title, description, score, ticket):\n        self.title = title\n        self.description = description\n　　　　 self.ticket = ticket\n        if score < 0:\n            raise ValueError(\"Negative value not allowed:{}\".format(score))\n        self.score = scroe\n\n但这行不通。因为其他部分的代码都是直接通过Movie.score来赋值的。这个新修改的类只会在__init__方法中捕获错误的数据，但对于已经存在的类实例就无能为力了。如果有人试着运行m.scrore= -100，那么谁也没法阻止。那该怎么办？\nPython的property解决了这个问题。\n我们可以这样做\nclass Movie(object):\n    def __init__(self, title, description, score):\n        self.title = title\n        self.description = description\n        self.score = score\n　　　　 self.ticket = ticket\n\n    @property\n    def score(self):\n        return self.__score\n\n\n    @score.setter\n    def score(self, score):\n        if score < 0:\n            raise ValueError(\"Negative value not allowed:{}\".format(score))\n        self.__score = score\n\n    @score.deleter\n    def score(self):\n        raise AttributeError(\"Can not delete score\")\n\n这样在任何地方修改score都会检测它是否小于0。\nproperty的不足\n对property来说，最大的缺点就是它们不能重复使用。举个例子，假设你想为ticket字段也添加非负检查。下面是修改过的新类：\nclass Movie(object):\n    def __init__(self, title, description, score, ticket):\n        self.title = title\n        self.description = description\n        self.score = score\n        self.ticket = ticket\n\n    @property\n    def score(self):\n        return self.__score\n\n\n    @score.setter\n    def score(self, score):\n        if score < 0:\n            raise ValueError(\"Negative value not allowed:{}\".format(score))\n        self.__score = score\n\n    @score.deleter\n    def score(self):\n        raise AttributeError(\"Can not delete score\")\n\n\n    @property\n    def ticket(self):\n        return self.__ticket\n\n    @ticket.setter\n    def ticket(self, ticket):\n        if ticket < 0:\n            raise ValueError(\"Negative value not allowed:{}\".format(ticket))\n        self.__ticket = ticket\n\n\n    @ticket.deleter\n    def ticket(self):\n        raise AttributeError(\"Can not delete ticket\")\n\n可以看到代码增加了不少，但重复的逻辑也出现了不少。虽然property可以让类从外部看起来接口整洁漂亮，但是却做不到内部同样整洁漂亮。\n描述符登场\n什么是描述符？\n一般来说，描述符是一个具有绑定行为的对象属性，其属性的访问被描述符协议方法覆写。这些方法是__get__()、__set__()和__delete__()，一个对象中只要包含了这三个方法中的至少一个就称它为描述符。\n描述符有什么作用？\nThe default behavior for attribute access is to get, set, or delete the attribute from an object’s dictionary. For instance, a.x has a lookup chain starting witha.__dict__['x'], then type(a).__dict__['x'], and continuing through the base classes of type(a) excluding metaclasses. If the looked-up value is an object defining one of the descriptor methods, then Python may override the default behavior and invoke the descriptor method instead. Where this occurs in the precedence chain depends on which descriptor methods were defined.-----摘自官方文档\n简单的说描述符会改变一个属性的基本的获取、设置和删除方式。\n先看如何用描述符来解决上面 property逻辑重复的问题。\nclass Integer(object):\n    def __init__(self, name):\n        self.name = name\n\n    def __get__(self, instance, owner):\n       return instance.__dict__[self.name]\n\n    def __set__(self, instance, value):\n        if value < 0:\n            raise ValueError(\"Negative value not allowed\")\n        instance.__dict__[self.name] = value\n\nclass Movie(object):\n    score = Integer('score')\n    ticket = Integer('ticket')\n\n因为描述符优先级高并且会改变默认的get、set行为，这样一来，当我们访问或者设置Movie().score的时候都会受到描述符Integer的限制。\n不过我们也总不能用下面这样的方式来创建实例。\na = Movie()a.score = 1a.ticket = 2a.title = 'test'a.descript = '...'\n这样太生硬了，所以我们还缺一个构造函数。\nclass Integer(object):\n    def __init__(self, name):\n        self.name = name\n\n    def __get__(self, instance, owner):\n        if instance is None:\n            return self\n        return instance.__dict__[self.name]\n\n    def __set__(self, instance, value):\n        if value < 0:\n            raise ValueError('Negative value not allowed')\n        instance.__dict__[self.name] = value\n\n\nclass Movie(object):\n    score = Integer('score')\n    ticket = Integer('ticket')\n    \n    def __init__(self, title, description, score, ticket):\n        self.title = title\n        self.description = description\n        self.score = score\n        self.ticket = ticket\n\n这样在获取、设置和删除score和ticket的时候都会进入Integer的__get__、__set__，从而减少了重复的逻辑。\n现在虽然问题得到了解决，但是你可能会好奇这个描述符到底是如何工作的。具体来说，在__init__函数里访问的是自己的self.score和self.ticket，怎么和类属性score和ticket关联起来的？\n描述符如何工作\n看官方的说明\nIf an object defines both __get__() and __set__(), it is considered a data descriptor. Descriptors that only define __get__() are called non-data descriptors (they are typically used for methods but other uses are possible).\nData and non-data descriptors differ in how overrides are calculated with respect to entries in an instance’s dictionary. If an instance’s dictionary has an entry with the same name as a data descriptor, the data descriptor takes precedence. If an instance’s dictionary has an entry with the same name as a non-data descriptor, the dictionary entry takes precedence.\nThe important points to remember are:\ndescriptors are invoked by the __getattribute__() methodoverriding __getattribute__() prevents automatic descriptor callsobject.__getattribute__() and type.__getattribute__() make different calls to __get__().data descriptors always override instance dictionaries.non-data descriptors may be overridden by instance dictionaries.类调用__getattribute__()的时候大概是下面这样子：\ndef __getattribute__(self, key):\n    \"Emulate type_getattro() in Objects/typeobject.c\"\n    v = object.__getattribute__(self, key)\n    if hasattr(v, '__get__'):\n        return v.__get__(None, self)\n    return v\n\n　　\n下面是摘自国外一篇博客上的内容。\nGiven a Class “C” and an Instance “c” where “c = C(…)”, calling “c.name” means looking up an Attribute “name” on the Instance “c” like this:\nGet the Class from InstanceCall the Class’s special method getattribute__. All objects have a default __getattributeInside getattribute\nGet the Class’s mro as ClassParentsFor each ClassParent in ClassParentsIf the Attribute is in the ClassParent’s dictIf is a data descriptorReturn the result from calling the data descriptor’s special method __get__()Break the for each (do not continue searching the same Attribute any further)If the Attribute is in Instance’s dictReturn the value as it is (even if the value is a data descriptor)For each ClassParent in ClassParentsIf the Attribute is in the ClassParent’s dictIf is a non-data descriptorReturn the result from calling the non-data descriptor’s special method __get__()If it is NOT a descriptorReturn the valueIf Class has the special method getattrReturn the result from calling the Class’s special method__getattr__.我对上面的理解是，访问一个实例的属性的时候是先遍历它和它的父类，寻找它们的__dict__里是否有同名的data descriptor如果有，就用这个data descriptor代理该属性，如果没有再寻找该实例自身的__dict__，如果有就返回。任然没有再查找它和它父类里的non-data descriptor，最后查找是否有__getattr__\n描述符的应用场景\npython的property、classmethod修饰器本身也是一个描述符，甚至普通的函数也是描述符（non-data discriptor）\ndjango model和SQLAlchemy里也有描述符的应用\nclass User(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(80), unique=True)\n    email = db.Column(db.String(120), unique=True)\n\n    def __init__(self, username, email):\n        self.username = username\n        self.email = email\n\n    def __repr__(self):\n        return '<User %r>' % self.username\n　　\n\n后记\n只有当确实需要在访问属性的时候完成一些额外的处理任务时，才应该使用property。不然代码反而会变得更加啰嗦，而且这样会让程序变慢很多。\n参考文章：\nhttps://docs.python.org/3.5/h...\nhttp://www.betterprogramming....\nhttp://stackoverflow.com/ques...\nhttp://www.jianshu.com/p/250f...\nhttp://www.geekfan.net/7862/\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "6"}