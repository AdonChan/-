{"title": "Python Buildin IO ", "index": "python", "content": "file & open\n两者的调用方法：\n\nfile(name[, mode[, buffering]]) open(filename [, mode [, bufsize]])\n\n两者的区别\n\nfile()是file类型的构造函数，open()为Python内置函数。两者的参数、作用大致相同。但在Python3之中file()已经不存在了，所以从发展趋势来看的话，建议使用open()\n\n两者的参数说明：\n\n如果文件不存在且mode为写或追加时，文件将被创建。\n添加b到mode参数中，将对文件以二进制形式操作。\n添加+到mode参数中，将允许对文件同时进行读 写操作\n参数filename：文件名称。\n参数mode：r（读）、w（写）、a（追加）。\n参数buffering：\n\n如果为0表示不进行缓冲，\n如果为1表示进行行缓冲，\n如果是一个大于1的数表示缓冲区的大小 。\n\n\n返回值：\n两者都返回一个file对象\n由于两者的用法区别不大，下面以open为例：\nIn [15]: f1 = open('test1.txt', 'r')        # 以只读的方式打开\n\nIn [16]: type(f1)\nOut[16]: file\nfile对象支持的方法：\n\n\n方法\n描述\n\n\n\nfile.close()\n关闭文件，关闭后文件不能再进行读写操作，<br/>但也节省了资源！\n\n\nfile.flush()\n刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件，<br/>而不是被动的等待文件资源关闭后，缓冲区自然输出\n\n\nfile.fileno()\n返回一个整型的文件描述符（file descriptor FD赘型)，<br/>可以用在如os模块的read方法等一些底层操作上，\n\n\nfile.isatty()\n如果文件连接到一个终端设备返回：True ，否则返回False\n\n\nfile.next()\n返回文件下一行。\n\n\nfile.read (size)\n从文件读取指定的字节数，如果未给定或为负则读取所有。\n\n\nfile.readline( [size])\n读取整行，包括\"n”字符，\n\n\nfile.readlines([sizehint])\n读取所有行并返回列表，若给定sizehint > 0,<br/>返回总和大约为sizehint字节的行，实际读取值可能比sizhint较大\n\n\nfile.seek(offset[, whence])]\n设文件指针当前位置\n\n\nfile.tell()\n返回文件指针当前位置，若是EOF，则等于-1\n\n\nfile.truncate( [size])\n截取文件，截取的字节通过size指定，默认为当前文件位置开始。\n\n\nfile.write(str)\n将字符串写入文件，没有返回值\n\n\nfile.writelines(sequence)\n写入一个字符串列表，需要换行则要加入每行的换行符。(LF或者CRLF)\n\n\n\n常用的属性：\n\n\n属性\n描述\n\n\n\nclosed\n文件是否关闭\n\n\nmode\n文件打开的模式\n\n\nencoding\n文件的编码方式\n\n\nnewlines\n可以取的值有None, \\n, \\r, ”, ‘\\r\\n'，用于区分换行符\n\n\n\n一些栗子\n文件描述符\n#!/usr/bin/python\n# -*- coding: UTF-8 -*-\n\n# 打开文件\nfo = open(\"test1.txt\", \"wb\")\nprint \"文件名为: \", fo.name\n\nfid = fo.fileno()\nprint \"文件描述符为: \", fid\n\n# 关闭文件\nfo.close()\n运行结果：\n文件名为:  runoob.txt\n文件描述符为:  3\n设备连接情况\n#!/usr/bin/python\n# -*- coding: UTF-8 -*-\n\n# 打开文件\nfo = open(\"test1.txt\", \"wb\")\nprint \"文件名为: \", fo.name\n\nret = fo.isatty()\nprint \"返回值 : \", ret\n\n# 关闭文件\nfo.close()\n运行结果：\n文件名为:  test1.txt\n返回值 :  False\n[Finished in 0.1s]\n迭代方法\n#!/usr/bin/python\n# -*- coding: UTF-8 -*-\n\n# 打开文件\nfo = open(\"test1.txt\", \"r+\")\nprint \"文件名为: \", fo.name\n\nfor index in range(5):\n    line = fo.next()\n    print \"第 %d 行 - %s\" % (index, line)\n\n# 关闭文件\nfo.close()\n运行结果：\n文件名为:  test1.txt\n第 0 行 - 1. Google\n\n第 1 行 - 2. Microsoft\n\n第 2 行 - 3. IBM\n\n第 3 行 - 4. Oracle\n\n第 4 行 - 5. FaceBook\n\n[Finished in 0.1s]\n脚本：\n#!/usr/bin/python\n# -*- coding: UTF-8 -*-\n\n# 打开文件\nfo = open(\"test1.txt\", \"r+\")\nprint \"文件名为: \", fo.name\n\nline = fo.read(10)\nprint \"读取的字符串: %s\" % (line)\n\n# 关闭文件\nfo.close()\n运行结果：\n文件名为:  test1.txt\n读取的字符串: 1. Google\n\n[Finished in 0.1s]\n缓存分块\n在处理日志文件的时候，常常会遇到这样的情况：日志文件巨大，不可能一次性把整个文件读入到内存中进行处理，例如需要在一台物理内存为 2GB 的机器上处理一个 2GB 的日志文件，我们可能希望每次只处理其中 200MB 的内容。  在 Python 中，内置的 File 对象直接提供了一个 readlines(sizehint) 函数来完成这样的事情。以下面的代码为例：\nfile = open('test.log', 'r')\nsizehint = 209715200   # 200M\nposition = 0\nlines = file.readlines(sizehint)\nwhile not file.tell() - position < 0:\n    position = file.tell()\n    lines = file.readlines(sizehint)\n每次调用 readlines(sizehint) 函数，会返回大约 200MB 的数据，而且所返回的必然都是完整的行数据，大多数情况下，返回的数据的字节数会稍微比 sizehint 指定的值大一点（除最后一次调用 readlines(sizehint) 函数的时候）。通常情况下，Python 会自动将用户指定的 sizehint 的值调整成内部缓存大小的整数倍。\n截断文件\n#!/usr/bin/python\n# -*- coding: UTF-8 -*-\n\n# 打开文件\nfo = open(\"test1.txt\", \"r+\")\nprint \"文件名为: \", fo.name\n\nline = fo.readline()\nprint \"读取第一行: %s\" % (line)\n\n# 截断剩下的字符串\nfo.truncate()\n\n# 尝试再次读取数据\nline = fo.readline()\nprint \"读取数据: %s\" % (line)\n\n# 关闭文件\nfo.close()\n\n运行结果：\n文件名为:  test1.txt\n读取第一行: 1. Google\n\n读取数据: \n[Finished in 0.1s]\n\ntruncate方法需要文件对象以可写的方式打开，运行之后文件内容清空。注意操作\n写入多选\n需要指定换行符\n#!/usr/bin/python\n# -*- coding: UTF-8 -*-\n\n# 打开文件\nfo = open(\"test.txt\", \"w\")\nprint \"文件名为: \", fo.name\nseq = [\"hello the cruel world! 1\\n\", \"hello the cruel world! 2\"]\nfo.writelines(seq)\n\n# 关闭文件\nfo.close()\n运行结果：\n文件名为:  test.txt\n[Finished in 0.1s]\n查看文件内容：\n✐ at [10/30/17][22:59:10] on master✂ ☁☁☁\n✎ ➤  cat test.txt\nhello the cruel world! 1\nhello the cruel world! 2\nraw_input & input\nPython2 提供了 input，raw_input 等用于输入，但在 Python3 中发生了一些改变，raw_input 已经没有了，input 的用法发生了变化，\n\ninput([prompt]) & raw_input([prompt])input与 repr相似的是两者都要精确，raw_input与str相似的是两者都要可读\n\n首先看 Python2 中的 raw_input，它的用法如下：\nraw_input(prompt)\n其中，prompt 表示输入提示。raw_input 会读取控制台的输入，并返回字符串类型。\n一些栗子\n>>> name = raw_input('please enter your name: ')\nplease enter your name: ethan     # 输入一个字符串\n>>> name\n'ethan'\n>>> type(name)\n<type 'str'>\n>>>\n>>> num = raw_input('please enter your id: ')\nplease enter your id: 12345       # 输入一个数值\n>>> num\n'12345'\n>>> type(num)\n<type 'str'>\n>>>\n>>> sum = raw_input('please enter a+b: ')\nplease enter a+b: 3+6             # 输入一个表达式\n>>> sum\n'3+6'\n>>> type(sum)\n<type 'str'>\n可以看到，不管我们输入一个字符串、数值还是表达式，raw_input 都直接返回一个字符串。\n\ninput 的用法跟 raw_input 类似，形式如下：\ninput(prompt)\n事实上，input 本质上是使用 raw_input 实现的，如下：\ndef input(prompt):\n    return (eval(raw_input(prompt)))\n也就是说，调用 input 实际上是通过调用 raw_input 再调用 eval 函数实现的。\n这里的 eval 通常用来执行一个字符串表达式，并返回表达式的值，它的基本用法如下：\n>>> eval('1+2')\n3\n>>> a = 1\n>>> eval('a+9')\n10\n这就说明需要精确输入表达式才不会报错。现在，让我们看看 input 的用法：\n>>> name = input('please input your name: ')\nplease input your name: ethan         # 输入字符串如果没加引号会出错\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"<string>\", line 1, in <module>\nNameError: name 'ethan' is not defined\n>>>\n>>> name = input('please input your name: ')\nplease input your name: 'ethan'       # 添加引号\n>>> name\n'ethan'\n>>>\n>>> num = input('please input your id: ')\nplease input your id: 12345           # 输入数值\n>>> num                               # 注意返回的是数值类型，而不是字符串\n12345\n>>> type(num)\n<type 'int'>\n>>>\n>>> sum = input('please enter a+b: ')  # 输入数字表达式，会对表达式求值\nplease enter a+b: 3+6\n>>> sum\n9\n>>> type(sum)\n<type 'int'>\n>>>\n>>> sum = input('please enter a+b: ')   # 输入字符串表达式，会字符串进行运算\nplease enter a+b: '3'+'6'\n>>> sum\n'36'\n可以看到，使用 input 的时候，如果输入的是字符串，必须使用引号把它们括起来；如果输入的是数值类型，则返回的也是数值类型；如果输入的是表达式，会对表达式进行运算。\n再来看一下 Python3 中的 input。\n事实上，Python3 中的 input 就是 Python2 中的 raw_input，也就是说，原 Python2 中的 raw_input 被重命名为 input 了。那如果我们想使用原 Python2 的 input 功能呢？你可以这样做：\neval(input())\n也就是说，手动添加 eval 函数。\nprint\n一些栗子\n格式化输出整数\n>>> strHello = \"the length of (%s) is %d\" %('Hello World',len('Hello World'))\n>>> print strHello\nthe length of (Hello World) is 11\n格式化输出16制整数\n#%x --- hex 十六进制\n#%d --- dec 十进制\n#%o --- oct 八进制\n\n>>> nHex = 0x20\n>>> print \"nHex = %x,nDec = %d,nOct = %o\" %(nHex,nHex,nHex)\nnHex = 20,nDec = 32,nOct = 40\n格式化输出浮点数(float)\n>>> import math\n>>> #default\n>>> print \"PI = %f\"%math.pi\nPI = 3.141593\n>>> #width = 10,precise = 3,align = left\n>>> print \"PI = %10.3f\"%math.pi\nPI =      3.142\n>>> #width = 10,precise = 3,align = rigth\n>>> print \"PI = %-10.3f\" % math.pi\nPI = 3.142     \n>>> #前面填充字符\n>>> print \"PI = %06d\" % int(math.pi)\nPI = 000003\n>>> #显示正负号\n>>> print '%+f'% math.pi\n+3.141593\n>>> print(format(math.pi,'6.2f'))\n  3.14\n>>> print(format(math.pi,'6f'))\n3.141593\n>>> print(format(math.pi,'15f'))\n       3.141593\n>>> print(format(math.pi,'6.0f'))\n     3\n>>> print(format(math.pi,'6%'))\n314.159265%\n格式化输出字符串(string)\n>>> #precise = 3\n>>> print \"%.3s \" % (\"jcodeer\")\njco \n>>> #precise = 4\n>>> print \"%.*s\" % (4,\"jcodeer\")\njcod\n>>> #width = 10,precise = 3\n>>> print \"%10.3s\" % (\"jcodeer\")\n       jco\n输出列表(list)\n>>> l = [1,2,3,4,'jcodeer']\n>>> print l\n[1, 2, 3, 4, 'jcodeer']\n'''6.出字典(dictionary)'''\n>>> d = {1:'A',2:'B',3:'C',4:'D'}\n>>> print d\n{1: 'A', 2: 'B', 3: 'C', 4: 'D'}\npython print自动换行\nprint 会自动在行末加上回车,如果不需回车，只需在print语句的结尾添加一个逗号”,“，就可以改变它的行为。\n>>> for i in range(0,5):\n        print i\n\n        \n0\n1\n2\n3\n4\n>>> for i in range(0,5):\n        print i,\n\n        \n0 1 2 3 4\n或直接使用下面的函数进行输出：\n>>> import sys\n>>> sys.stdout.write('Hello World')\nHello World\n万能的 %r%r是一个万能的格式符，它会将后面给的参数原样打印出来，带有类型信息。\n>>> formatter = \"%r %r %r %r\"\n>>> print formatter % (1, 2, 3, 4)\n1 2 3 4\n>>> print formatter % (\"one\", \"two\", \"three\", \"four\")\n'one' 'two' 'three' 'four'\n>>> print formatter % (True, False, False, True)\nTrue False False True\n>>> print formatter % (formatter, formatter, formatter, formatter)\n'%r %r %r %r' '%r %r %r %r' '%r %r %r %r' '%r %r %r %r'\n>>> print formatter % (\n\"I had this thing.\",\n\"That you could type up right.\",\n \"But it didn't sing.\",\n \"So I said goodnight.\"\n )\n'I had this thing.' 'That you could type up right.' \"But it didn't sing.\" 'So I said goodnight.'\nprint语句输出包含转义字符的字符串的处理方法\n>>> print \"I'm OK\"\nI'm OK\n>>> print 'Learn \"Python\" in imooc'\nLearn \"Python\" in imooc\n>>> print 'Bob said \\\"I\\'m OK\\\".'\nBob said \"I'm OK\".\n>>> s = 'Python was started in 1989 by \\\"Guido\\\".\\nPython is free and easy to learn.'\n>>> s\n'Python was started in 1989 by \"Guido\".\\nPython is free and easy to learn.'\n>>> print s\nPython was started in 1989 by \"Guido\".\nPython is free and easy to learn.\n>>> print r'''\"To be, or not to be\": that is the question.\nWhether it's nobler in the mind to suffer.'''\n\"To be, or not to be\": that is the question.\nWhether it's nobler in the mind to suffer.\nprint语句输出包含中文字符的字符串的处理方法\n>>> print u'''静夜思\n... 床前明月光，\n... 疑是地上霜。\n... 举头望明月，\n... 低头思故乡。'''\n静夜思\n床前明月光，\n疑是地上霜。\n举头望明月，\n低头思故乡。\n输出类似10000L的字符串类型\n>>> print(format(math.pi,'6%'))\n314.159265%\n>>> print repr('hello,world!')\n'hello,world!'\n>>> print repr(10000L)\n10000L\n>>> print str('hello,world!')\nhello,world!\n>>> print str(10000L)\n10000\nPython3.x中的print 函数\n到3.x时print语句没有了，取而代之的是print()函数。 Python 2.6与2.7部分地支持这种形式的print语法。在Python 2.6与Python 2.7里面，以下四种形式是等价的：\n>>> print 'fish'\nfish\n>>> print \"fish\"\nfish\n>>> print (\"fish\")\nfish\n>>> print(\"fish\")\nfish\n然而吉多有一个时光机：\n>>> from __future__ import print_function\n>>> print(\"numpy\",\"pandas\",'scipy','matplotlib',sep='_')\nnumpy_pandas_scipy_matplotlib\nformat\n一些栗子\n\nformat(value [, format_spec])本函数把值value按format_spec的格式来格式化，然而函数解释format_spec是根据value的类型来决定的，不同的类型有不同的格式化解释。当参数format_spec为空时，本函数等同于函数str(value)的方式。其实本函数调用时，是把format(value, format_spec)的方式转换为type(value).__format__(format_spec)方式来调用，因此在value类型里就查找方法__format__()，如果找不到此方法，就会返回异常TypeError。\n其中format_spec的编写方式如下形式：\nformat_spec ::=  [[fill]align][sign][#][0][width][,][.precision][type]\nfill        ::=  <any character>\nalign       ::=  \"<\" | \">\" | \"=\" | \"^\"\nsign        ::=  \"+\" | \"-\" | \" \"\nwidth       ::=  integer\nprecision   ::=  integer\ntype        ::=  \"b\"|\"c\"|\"d\"|\"e\"|\"E\"|\"f\"|\"F\"|\"g\"|\"G\"|\"n\"|\"o\"|\"s\"|\"x\"|\"X\"|\"%\"\nfill是表示可以填写任何字符。\nalign是对齐方式，<是左对齐， >是右对齐，^是居中对齐。\nsign是符号， +表示正号， -表示负号。\nwidth是数字宽度，表示总共输出多少位数字。\nprecision是小数保留位数。\ntype是输出数字值是的表示方式，比如b是二进制表示；比如E是指数表示；比如X是十六进制表示。\n\n>>> print(format(2918))\n2918\n>>> print(format(0x500,'X'))\n500\n>>> print(format(0x500,'x'))\n500\n>>> import math\n>>> print(format(math.pi,'0=10'))\n3.14159265359\n>>> print(format(math.pi,'0=20'))\n00000003.14159265359\n>>> print(format(math.pi,'E'))\n3.141593E+00\n>>> print(format(math.pi,'e'))\n3.141593e+00\n>>> print(format(math.pi,'05.3'))\n03.14\n>>> print(format(math.pi,'5.3'))\n 3.14\n>>> print(format('test','<20'))\ntest\n>>> print(format('test','>20'))\n                test\n>>> print(format('test','^20'))\n        test\n>>> print(format(math.pi,'0=+20'))\n+0000003.14159265359\n>>> print(format(math.pi,'0^+20'))\n000+3.14159265359000\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}