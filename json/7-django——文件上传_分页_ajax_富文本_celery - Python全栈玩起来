{"title": "7-django——文件上传_分页_ajax_富文本_celery - Python全栈玩起来 ", "index": "django,python", "content": "上传文件\n概述\n当Django在处理文件上传时，文件的数据被存储在request.FILES属性中\nFILES只有在请求的方法为POST且提交的form表单带有enctype=\"multipart/form-data\"属性的情况才会包含数据。否则，FILES将为一个空的类似字典的对象\nFILES中的键为input的name属性值\n上传界面\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>文件上传</title>\n</head>\n<body>\n    <form method=\"post\" action=\"/upfile/\" enctype=\"multipart/form-data\">\n        {% csrf_token %}\n        <input type=\"file\" name=\"file\">\n        <input type=\"file\" name=\"file\">\n        <input type=\"file\" name=\"pic\">\n        <input type=\"submit\" value=\"上传\">\n    </form>\n</body>\n</html>\n文件存储路径\n在static目录下创建名为media的目录\n配置路径:\nsettings\n# 文件上传的路径\nMEDIA_URL = '/media/'   # 访问资源的地址如 http://127.0.0.1:5000/media/1.jpg\n# 写相对路径也可以\nMEDIA_ROOT=os.path.join(BASE_DIR,\"static/media\")\nrequest.FILES数据结构\n{\n    'file': [\n        <InMemoryUploadedFile: a.txt (text/plain)>, \n        <InMemoryUploadedFile: b.txt (text/plain)>\n    ], \n    'pic': [\n        <InMemoryUploadedFile: c.jpg (image/jpeg)>\n    ]\n}\n视图实现\nfrom django.conf import settings\ndef upfile(request):\n    if request.method == \"GET\":\n        return render(request, \"upfile.html\")\n    else:\n        # print(request.FILES)\n        for name in request.FILES:\n            files = request.FILES.getlist(name)\n            # print(files)\n            for file in files:\n                #处理每个文件\n                filePath = r\"%s\\%s\"%(settings.MEDIA_ROOT,file.name)\n                with open(filePath, \"wb\") as fp:\n                    # 将文件数据切片写入描述符\n                    for part in file.chunks():\n                        fp.write(part)\n        return HttpResponse(\"上传文件成功\")\n图片生成缩略图\n# 生成缩略图\n\nfrom PIL import Image\nim = Image.open('c.jpg')\nprint(im.format, im.size, im.mode)\n# JPEG (840, 1024) RGB\nim.thumbnail((100,200))\nim.save(\"c1.jpg\", \"JPEG\")\n分页\nPaginator对象\n\nPage对象\n\n示例\nfrom django.core.paginator import Paginator\ndef students(request, num):\n    allStudents = Student.objects.all()\n    #分页 每页6条数据\n    paginator = Paginator(allStudents, 6)\n    print(paginator.count, paginator.num_pages, paginator.page_range)\n    pageStus = paginator.page(num)\n    return render(request, \"students.html\", {\"stus\":pageStus})\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>学生信息</title>\n</head>\n<body>\n<h1>学生信息</h1>\n<ul>\n    {% for stu in stus %}\n        <li>{{ stu.name }}--{{ stu.grade }}--{{ stu.age }}</li>\n    {% endfor %}\n</ul>\n{% if stus.has_previous %}\n    <a href=\"/students/{{ stus.previous_page_number }}\">上一页</a>\n{% endif %}\n\n\n{% for index in stus.paginator.page_range %}\n    {% if index == stus.number %}\n        {{ index }}\n    {% else %}\n    <a href=\"/students/{{ index }}/\">{{ index }}</a>\n    {% endif %}\n{% endfor %}\n{% if stus.has_next %}\n<a href=\"/students/{{ stus.next_page_number }}\">下一页</a>\n{% endif %}\n</body>\n</html>\nAjax\n问题\n使用视图通过上下文向模板中传递数据，需要先加载完成模板的静态页面，再执行模板模型代码，生成最后的HTML代码，返回给浏览器，这个过程将页面与数据集成到了一起，扩展性差\n解决\n通过ajax的方式获取数据，再通过DOM操作将数据呈现到界面上\n异步：如发邮件（注册的时候提示邮件已经发送成功，其实并没有） 能提高用户体验。 如豆瓣，防止页面卡死。\n前端代码\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>展示学生</title>\n    <script type=\"text/javascript\" src=\"/static/js/jquery-3.1.1.min.js\"></script>\n</head>\n<body>\n    <button id=\"btn\">显示学生信息</button>\n    <ul id=\"stus\">\n\n    </ul>\n\n    <script type=\"text/javascript\">\n        $(document).ready(function () {\n            $(\"#btn\").bind(\"click\", function () {\n                /*\n                $.get(\"/allStudents/\",{\"a\":1,\"b\":2},function (data, status) {\n                    console.log(\"************************2\");\n                    console.log(data, status);\n                    stus = data[\"data\"];\n                    for (var i = 0; i < stus.length; i++){\n                        stu = stus[i];\n                        $li = $(\"<li>\"+stu.name+\"---\"+stu.age+\"</li>\");\n                        $(\"#stus\").append($li)\n                    }\n                });\n                */\n                $.ajax({\n                    url:\"/allStudents/\",\n                    type:\"get\",\n                    data:{\"a\":1,\"b\":2,\"c\":3},\n                    dataType:\"json\",\n                    success:function (data, status) {\n                        console.log(\"************************2\");\n                        console.log(data, status);\n                        stus = data[\"data\"];\n                        for (var i = 0; i < stus.length; i++){\n                            stu = stus[i];\n                            $li = $(\"<li>\"+stu.name+\"&&&\"+stu.age+\"</li>\");\n                            $(\"#stus\").append($li)\n                        }\n                    }\n                });\n                console.log(\"************************1\");\n            });\n        });\n    </script>\n</body>\n</html>\ndef allStudents(request):\n    if request.method == \"GET\":\n        if not request.is_ajax():\n            return render(request, \"allStudents.html\")\n        else:\n            stus = Student.objects.all()\n            arr = []\n            for stu in stus:\n                arr.append({\"name\":stu.name, \"age\":stu.age})\n            return JsonResponse({\"data\":arr})\n富文本\n安装：pip install django-tinymce\n在站点中使用\n激活应用\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'myApp',\n    'tinymce',\n]\n配置\nTINYMCE_DEFAULT_CONFIG={\n    'theme':'advanced',\n    'width':600,\n    'height':400\n}\n模型\nfrom tinymce.models import HTMLField\nclass Article(models.Model):\n    title = models.CharField(max_length=20)\n    content = HTMLField()\nadmin.py\nadmin.site.register(Article)\n在自定义页面中使用\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>书写博客</title>\n    <script type=\"text/javascript\" src=\"/static/tiny_mce/tiny_mce.js\"></script>\n    <script type=\"text/javascript\">\n        tinyMCE.init({\n            'mode':'textareas',\n            'theme':'advanced',\n            'width':600,\n            'height':400\n        });\n    </script>\n</head>\n\n<body>\n    <form method=\"post\" action=\"/tinymce/\">\n        {% csrf_token %}\n        <input type=\"text\" name=\"title\" value=\"\"><hr/>\n        <textarea name=\"article\"></textarea><hr/>\n        <input type=\"submit\" value=\"提交\">\n    </form>\n</body>\n</html>\nCelery\n问题\n用户发起request请求，并等待response返回。在本次views中，可能需要执行一段耗时的程序，那么用户会等待很长时间，造成不好的用户体验\n网站每小时需要同步数据(天气预报信息)，但是http是需要触发的，难道要一个小时请求一次吗？\n解决方案\n使用celery：将耗时的程序放到celery中执行 使用celery定时执行\ncelery\n任务task：就是一个python函数\n队列queue：将需要执行的任务加入队列中\n工人worker：在一个新的进程中负责执行队列中的任务\n代理broker：负责调度，在布置环境中使用redis\n安装\npip  install  celery==3.1.25\npip  install  celery-with-redis==3.0\npip  install  django-celery==3.2.1\n配置\n激活应用\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'myApp',\n    'tinymce',\n    'djcelery',\n]\n配置redis\n#celery\nimport djcelery\ndjcelery.setup_loader()\n#配置redis数据库\n#redis://:密码@ip:端口/库\nBROKER_URL='redis://:sunck@127.0.0.1:6379/0'\n#配置任务文件\nCELERY_IMPORTS=(\"myApp.task\")\n创建任务文件，并分装任务\n# 在应用目录下创建名为task.py的文件\n# -*- coding:utf-8 -*-\nfrom celery import task\nimport time\n\n@task\ndef longIO():\n    print(\"开始耗时操作……\")\n    time.sleep(5)\n    print(\"结束耗时操作……\")\n迁移\npython  manage.py  migrate\n生成celery所需要的表\n添加celery.py文件\n将已存在的celery.py添加到工程目录下的与工程目录同名的目录下\ncelery.py\nfrom __future__ import absolute_import\n\nimport os\nfrom celery import Celery\nfrom django.conf import settings\n\nos.environ.setdefault('DJANGO_SETTINGS_MODULE', 'whthas_home.settings')\n\napp = Celery('portal')\n\napp.config_from_object('django.conf:settings')\napp.autodiscover_tasks(lambda: settings.INSTALLED_APPS)\n\n\n@app.task(bind=True)\ndef debug_task(self):\n    print('Request: {0!r}'.format(self.request))\n导入celery\n在工程目录下的与工程目录同名的目录中的__init__.py文件中添加from .celery import app as celery_app\n在视图使用任务\nfrom myApp.task import longIO\ndef registe(request):\n    longIO.delay()\n    return HttpResponse(\"sunck is a good man\")\n启动redis\nredis-server.exe     redis.windows.conf\n启动worker\npython  manage.py  celery  worker  --loglevel=info\n启动Django服务\npython  manage.py  runserver\n\n                ", "mainLikeNum": ["12 "], "mainBookmarkNum": "7"}