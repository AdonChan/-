{"title": "开发NEO智能合约的步骤流程 - 个人文章 ", "index": "python,java", "content": "摘要：开发NEO智能合约的典型开发流程有两个实际阶段：编码（在IDE中编码并将源码编译为.avm文件）以及测试（在测试网上部署、调用、检查结果）。这个工作流需要编译和部署来调试任何代码的变更。在NEO社区开发的一些最新工具集的帮助下，出现了四步流程法，从而进一步加快了开发效率。\n在本教程中，我们将首先简要地讨论一下标准的两步流程法，并提供一些有用的参考资料，然后介绍四步流程法以及相关的新开发的工具。除非另有说明，否则讨论时使用C#作为智能合约开发语言。\n在本教程中，我很有可能会犯错误或者遗漏一些要点，非常感谢您的评论。\n两步流程法\n传统上来说，NEO智能合约开发有两步开发流程：编码和测试。这篇官方的教程提供了关于这个工作流程的详细信息。\n在编码阶段，NEO官方支持C#（示例）。我们也可以使用Java和Python开发智能合约。你可以轻松的在Google和YouTube上找到教程和示例代码页，以了解如何编写NEO智能合约。\n\n我们依赖于测试网来进行测试工作。如上图所示，对于测试网，我们有很多选择。\n公共测试网络\n最常见的方法是使用公共的测试网络。NEO智能经济、CoZ和NEL分别维护了三个主要的公共测试网络。Alex Guba的教程详细阐述了如何在NEO和CoZ测试网络上进行测试之前，同步区块并申请GAS，不过NEL的测试网络对支持本地化的中国开发者更加友好。\n在大多数情况下，你可以通过NEO API（完整引用）运行RPC调用来与区块链进行交互。部分APIs只有当你运行了一个具有开放钱包的NEO.CLI节点时，才可使用。但是如果NEO.Scan赋予了测试网权限，则可以在不运行节点的情况下调用类似的服务。例如，API getBalance需要一个正在运行的节点，但是你可以使用Neo-Scan提供的get_balance接口来获得类似的功能。我建立了一个Postman集合来帮助测试这些远程调用。你只需更改测试网络（或Neo-Scan）的值即可使用它。\nNeoCompile Eco有一个新的特殊的公共测试网络，这激发了我们转向四步工作流程的灵感。我们将在下一节详细讨论它。\n私人测试网络\n另一个好的方法是建立你自己的私人测试网络。与公共测试网络相比，私人测试网络的优势在于你可以获得完全的控制权。使用私人测试网络的第一个原因是，它真的非常有用，也很鼓舞人心，因为它会让人产生钱包中持有数百万的NEO和GAS的错觉。与此同时，与公共测试网络相比，我们不需要担心链再生，连接失败，或者因为其他开发者错误导致的网络拥堵。\nNEO官网提供了一个在云服务器上设置私人网络的逐步指南。不过查看了我在Azure上的账单后，我不建议你这么做，除非你不得不和其他人共享链数据。Neo-privatenet-docker非常适合在本地计算机上构建私人的测试网络，同时可以帮你节省大量配置和执行指令的时间。如果你在笔记本电脑上运行它，它还能帮助你在加拿大的冬天保持你的体温。\n两步流程法的局限性\n这个两步工作流程法已经成熟，并且被大多数现有的项目所采用。然而，与传统的软件项目相比，它仍有一些局限性。主要的一点是调试的代价非常高昂，要监视变量的运行时值，最好的选择是使用运行时通知，如以下代码段所示：\nbyte[] ba0 = CallSomeFunction();\nbyte[] ba1 = CallAnotherFunction();\n\n//Print out the value of ba0 and ba1 to ApplicationhLog\nRuntime.Notify(ba0, ba1);\n我们需要使用neon重新编译项目，确保有足够的GAS并进行重新部署，使用正确的格式组成适当的参数，然后调用它，并等待20-30秒的时间等待下一个区块的出现，调用API getapplicationlog来获取JSON格式的日志，使用pretty format格式打印响应的内容来查找日志值（查看以下示例中高亮的部分）。日志值通常表示为字节数组，因此我们需要将它们转换为字符串或者大整数类型…总共7个步骤。\n[\n  {\n    \"jsonrpc\": \"2.0\",\n    \"id\": 5,\n    \"result\": {\n      \"txid\": \"0x7e3f08a8af4290693184b413ba1d58bede8462cb565baba8ffcc380bf947e317\",\n      \"executions\": [\n        {\n          \"trigger\": \"Application\",\n          \"contract\": \"0x32682404d4313ecf80b70e1323ccf908a80fdfc0\",\n          \"vmstate\": \"HALT, BREAK\",\n          \"gas_consumed\": \"0.039\",\n          \"stack\": [],\n          \"notifications\": [\n            {\n              \"contract\": \"0xaeccdcf6d7ecf827e7e6baec3c233eca08c27ee3\",\n              \"state\": {\n                \"type\": \"Array\",\n                \"value\": [\n                  {\n                    \"type\": \"ByteArray\",\n                    \"value\": \"010203\"\n                  },\n                  {\n                    \"type\": \"ByteArray\",\n                    \"value\": \"04090d\"\n                  }\n                ]\n              }\n            }\n          ]\n        }\n      ]\n    }\n  }\n]\n官方文档中有介绍单元测试的章节，但是其中的示例仍然需要提前编译和/或部署.avm文件。\n当我们在开发基于NEO的区块链游戏CarryBattle时，我的团队norchain.io强烈地感受到了这种限制。在社区的帮助下，我们开始尝试4阶段工作流程，这大大提高了开发效率。\n四步流程法\n这个工作流程的四个阶段是：编辑、调试、私人测试以及Beta测试。主要的想法是：\n\n利用一些新工具将编码阶段拆分成编码阶段和调试阶段。在调试阶段，我们尽可能多地跳过或运行本地测试案例，就像传统软件项目那样，而不与区块链进行交互。\n将测试阶段拆分为私人测试和Beta测试，分别使用privateNet / NeoCompiler   Eco进行私人测试以及公共测试网络进行beta测试。 使用这种方法，我们以最小的代价确保最大程度上的灵活性和兼容性。\n\n\n四步工作流程法开发NEO智能合约(C#) 对于编辑和调试阶段，我建议使用两种方法：Neo-Debugger和Neunity。\nNeo-Debugger\nNeo-Debugger的项目是由Relfos公司开发的。使用特殊版本的Neon和调试json文件，你可以编写调用级别的测试用例，并在IDE中逐步运行源代码，跟踪GAS使用情况和应用程序日志，而无需与区块链交互。Neo-Debugger的另一个不错的功能是，它可以在检查堆栈时跳过OpCode(操作码)。Nikolaj- k制作过一个针对Neo-Debugger的视频教程。\nFabio也用类似的想法做了一个不错的项目SCTracker，但是当他知道Neo-Debugger的存在的时候，他决定跳过这个项目。但还是要感谢他的贡献。\nNeunity.Adapter\nNeo-Debugger在NeoVM级别的调试方面做得很好，但是它仍然有一些局限性。例如，它还不支持变量监视、断点或功能级别的测试用例。\n由Norchain.io创建的框架Neunity的Adapter层正在采用了不同的本地调试方式。 Neunity.Adapter的思路是：\n\n引入适配器层来隔离NeoVM和普通.Net项目之间的差异。   我们有两个适配器Neunity.Adapter.NEO和Neunity.Adapter.Unity，它们具有相同的方法签名的集合，同时具有不同的命名空间和实现。   它们分别用于NEO智能合约和Unity项目（实际上也适用于许多其他.Net项目）。   这些方法大多数都与类型转换，运算符或系统调用模拟有关。\n然后我们可以在适配器层上编写应用层逻辑。 显然，通过简单地更改命名空间，这个应用层逻辑可以被智能合约或普通的.Net项目使用。\n现在我们可以使用功能级别测试驱动开发（TDD），甚至可以与C＃Dapp客户端共享逻辑。\n\n我制作了一个视频教程来演示如何使用Neunity.Adapter来执行功能级别的TDD，执行测试步骤，同时监视变量和调用堆栈。\n\n与下表相比，我们可以相应看到Neo-Debugger和Neunity.Adapter的优势。根据我们的经验，Neo-Debugger更适合小规模项目，因为它不消耗GAS，而Neunity.Adapter更适合较大规模或更复杂的项目，因为它更好地支持TDD，多类，断点，变量跟踪等。\n\nNeunity的设计实践了大规模软件的项目方法学（我指的是系统逻辑的规模，并不意味着单个调用必须复杂或者昂贵的）。通过适配器层的使用迈出了缩小.Net开发者和NEO开发者之间差距的重要的一步。与此同时，Neunity还提供了一个Neunity.Tools层，它具有灵活的序列化工具（NuSD），类HTTP的通信协议（NuTP），类URI的存储管理器（NuIO）等。我们希望能够助力更多的NEO区块链Dapps的落地。\n私人测试\n通过迭代编码和调试阶段完成逻辑后，我们可以转到私人测试阶段并开始与区块链进行交互。我们建议使用私人测试网络或NeoCompiler Eco进行私人测试，因为它们的环境简单且易于交互和管理。\nNeoResearch公司开发的NeoCompiler Eco公共测试网络是新的、特殊的。它不需要使用GAS，同时提供了一整套基于Web的GUI工具，包括编译，导入OpCode，部署，调用，交易，转换等.NeoResearch最近还集成了gitter.im用于即时聊天，以便更好地与开发者沟通。 Igor有一个很好的教程来介绍它的基本功能。\n这个测试网络的另一个优点是，区块生成的时间间隔是5-7秒，几乎比正常情况快5倍。它缩短了等待时间，几乎不会出现开发者在同一个区块发生调用冲突的情况，这使得测试几乎与私人测试网络一样简单。这就是为什么我们建议将其视为私人测试选项的原因。\nBeta测试\n如果成功完成了在私人测试阶段的所有功能测试，我们就可以进入最后的一个阶段，之后就可上线Dapp。 公共测试网络是最适合于Beta测试的地方，因为它类似于主网环境。 另一个好处是你还可以邀请你的朋友来帮忙测试。 你的智能合约还要能沉着地面对来自并行调用、潜在盲区或者无效输入等的挑战。\n总结\n与许多其他公有链项目相比，NEO具有许多优势：诸如高交易速度，相对友好的开发语言（C＃，Python），国际化且活跃的社区氛围。\n改进开发工作流程有助于提高NEO的语言优势，同时可以将出色的想法与有生命力的项目相结合，而无需花费太多时间来解决琐碎的问题。\n本人知识有限，希望本教程可以给大家提供些许帮助。感谢Fabio和Relfos对本教程提供的帮助。 欢迎任何建议和意见。\n\nNEOFANS：neofans.org NEOFANS 微博：https://www.weibo.com/neofans...NEOFANS  telegram群：https://t.me/NEOfansCN\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}