{"title": "4-函数 - Python全栈玩起来 ", "index": "python", "content": "通用函数\ndef fun(*args, **kwargs):\n    print(args) # 元组\n    print(kwargs) # 字典 关键字传参\n匿名函数\nlambda x：x*x if x>5\nlambda num:'TRUE' if num == 1 else 'FALSE'\n装饰器\n本身是一个闭包，就是一个返回函数的函数 闭包：把一个函数作为参数，返回一个代替版的函数\n        \ndef getAge(age):\n    print(\"我的年龄是 %d\" % age)\ndef getHeight(height):\n    print(height)\n            \ndef outer(paraFun):\n    def inner(num):\n        # 添加检测条件\n        if num < 0:\n            num = 12\n        paraFun(num)\n    return inner\n            \nouter(getAge) === inner\nouter(getAge)(-12)\n\n#语法糖 @后可以继续使用原来函数的名字\ndef outer(func):\n    def inner(num):\n        if num < 0:\n            num = 99999\n         func(num)\n    return inner\n\n@outer   # 相当于 getAge  == outer(getAge)\ndef getAge(age):\n    print(age)\n# f4 = outer(getAge)\n# f4(-90)\ngetAge(-99)\n\n@outer\ndef getWeight(ww):\n        print(ww)\ngetWeight(-99) \n\n偏函数\nint('1010',base=2)\ndef myInt(str):\n    return int(str, base=2)\nimport functools \nnewInt = functools.partial(int, base=2)\n\n迭代器\n可迭代对象：可以直接作用于for循环的对象，叫做可迭代对象[Iterable] 可以直接作用于for的对象：1、基本数据类型：list tuple dict set string 2、generator生成器：带有yield的生成器函数\nfrom collections import Iterable\nprint(isinstance([], Iterable))  # T\nprint(isinstance({}, Iterable))  # T\nprint(isinstance((), Iterable))  # T\nprint(isinstance(\"abc\", Iterable))  # T\nprint(isinstance((x for x in range(5)), Iterable))   # T\n\n迭代器：Iterator 迭代器：不仅可以作用于for循环，也可以使用next()函数不断用并获取下一个值，直到取出最后一个。当取出嘴一个元素时，再继续调用next()时，会提出一个StopIteration错误表示无法继续下一个数据的提取。可以被next()函数调用并提取元素的对象称为迭代器对象。判断一个对象是否为迭代器对象：isinstance(obj,Iterator)\nfrom  collections import Iterator\nprint(isinstance([], Iterator))  # F\nprint(isinstance({}, Iterator))  # F\nprint(isinstance((), Iterator))  # F\nprint(isinstance(\"abc\", Iterator))  # F\nprint(isinstance((x for x in range(5)), Iterator))  # T\n        \n# 将list、tuple、dict、str转为Iterator对象\na = iter([1, 2, 3]\n\n生成器\n生成器：generator：使用yield的函数被称为是生成器函数。使用yield的函数与普通函数的区别：生成器函数是一个返回迭代器的函数，只能用于迭代操作可以认为生成器就是一个迭代器\n        \ndef fib(max):\n    n, a, b = 0, 0, 1\n    while n < max:\n        yield b\n        a, b = b, a + b\n        n = n + 1\n    return\n\nfor i in fib(6):\n       print(i)\n   \n   \n   # 生成器打印杨辉三角\ndef Triangle(n):\n    l, index = [1], 0\n    while index < n:\n        yield l\n        l = [1] + [l[i] + l[i + 1] for i in range(len(l) - 1)] + [1]\n        index += 1\nfor x in Triangle(10):\n    print(x)\n\n\n闭包\n闭包：概念：在函数体内定义的内部函数，并且该内部函数使用的外部函数的变量，外部函数将内部函数作为返回值返回，该内部函数就叫做闭包。优点：避免变量污染全局环境，我们可以在全局范围内间接使用局部变量。缺点：数据会长期驻留在内存中，造成内存浪费，在IE浏览器中，极易崩溃，所以请慎重使用。\n\n作用域\nbuilt-in Global Enclosing Local变量查找规则：L->E->G->B只有module class def lambda 才会引入新的作用域\n\ni = 666\ndef outer():\n    i = 555   # 局部变量\n    def inner():\n        nonlocal i  # nonlocal 非局部的\n        i = 444   #\n        print(\"inner ==\", i)\n    inner()\n    print(\"outer ==\", i)\n        \nouter() # 444\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}