{"title": "Python 装饰器使用指南 - 古寺比的寺 ", "index": "读书笔记,装饰器,python", "content": "装饰器是可调用的对象，其参数是另一个函数（被装饰的函数）。\n装饰器基础知识\n首先看一下这段代码\ndef deco(fn):\n    print \"I am %s!\" % fn.__name__\n\n@deco\ndef func():\n    pass\n\n# output\nI am func!\n\n# 没有执行func 函数 但是 deco 被执行了\n在用某个@decorator来修饰某个函数func时\n@decorator\ndef func():\n    pass\n\n其解释器会解释成下面这样的语句：\nfunc = decorator(func)\n其实就是把一个函数当参数传到另一个函数中，然后再回调，但是值得注意的是装饰器必须返回一个函数给func\n装饰器的一大特性是，能把被装饰的函数替换成其他函数。第二大特性是，装饰器在加载模块时立即执行。\n装饰器何时执行\n装饰器的一个关键特性是，它们在被装饰的函数定义后立即运行。这通常在导入是（python 加载模块时）。\n看下下面的示例：\nregistry = []  # registry 保存被@register 装饰的函数的引用\n\ndef register(func):  # register 的参数是一个函数\n    print('running register(%s)' % func)  # 打印被装饰的函数\n    registry.append(func)  # 把 func 存入 `registery`\n    return func  # 返回 func：必须返回函数，这里返回的函数与通过参数传入的一样\n\n@register  # `f1` 和 `f2`被 `@register` 装饰\ndef f1():\n    print('running f1()')\n\n@register\ndef f2():\n    print('running f2()')\n\ndef f3():  # <7>\n    print('running f3()')\n\ndef main():  # main 打印 `registry`，然后调用 f1()、f2()和 f3()\n    print('running main()')\n    print('registry ->', registry)\n    f1()\n    f2()\n    f3()\n\nif __name__=='__main__':\n    main()  # <9>\n运行代码结果如下：\nrunning register(<function f1 at 0x1023fb378>)\nrunning register(<function f2 at 0x1023fb400>)\nrunning main()\nregistry -> [<function f1 at 0x1023fb378>, <function f2 at 0x1023fb400>]\nrunning f1()\nrunning f2()\nrunning f3()\n从结果可以发现register 在模块中其他函数之前运行了两次。调用 register 时，传给它的参数是被装饰的函数（例如<function f1 at 0x1023fb378>）。\n看完上边的示例我们知道，函数被装饰器装饰后会变成装饰器函数的一个参数，那这时就不得不说变量的作用域了。\n变量作用域\n先看下下边这段代码：\ndef f1(a):\n    print(locals())\n    print(a)\n    print(b)\n    \n    \nf1(3)\n# output\n{'a': 3}\n3\nTraceback(most recent call last):\n    File \"<stdin>\", line 1, in <module>\n    File \"<stdin>\", line 3, in f1\nNameError: global name 'b' is not defined\n这里的错误是因为全局变量 b 没有定义，如果我们先在函数外部给 b 赋值，再调用这个方法就不会报错了。\n函数运行时会创建一个新的作用域（命名空间）。函数的命名空间随着函数调用开始而开始，结束而销毁。这个例子中 f1 的命名空间中只有 {'a': 3}，所以 b 会被认为是全局变量。\n再看一个例子：\nb = 6\ndef f2(a):\n    print(a)\n    print(globals())\n    print(locals())\n    print(b)\n    b = 9\n    \nf2(3)\n# output\n3\n{\n    '__name__': '__main__',\n    '__doc__': None, \n    '__package__': None, \n    '__loader__': <_frozen_importlib_external.SourceFileLoader object at 0x10c7f2dd8>, \n    '__spec__': None, \n    '__annotations__': {}, \n    '__builtins__': <module 'builtins' (built-in)>, \n    '__file__': '~/var_local.py', \n    '__cached__': None, \n    'b': 6, \n    'f2': <function f2 at 0x10c7e7598>\n}\n{'a': 3}\n3\nTraceback(most recent call last):\n    File \"<stdin>\", line 1, in <module>\n    File \"<stdin>\", line 3, in f1\nUnboundLocalError: local variable 'b' referenced before assignment\n这个例子和上一个例子不同是，我现在函数外部定义了全局变量b，但是执行f2 这个方法并没有打印6，这是为什么呢？这是因为执行函数时 Python 会尝试从局部变量中获取 b，函数对于已经引用但未赋值的变量并不会自动声明为局部变量，所以解释器发现后边的赋值之前有引用就会抛出 UnboundLocalError 错误。\nPython 不要求声明变量，但是假定在函数定义体中赋值的变量是局部变量。\n如果要让解释器把b当做全局变量，要使用global声明：\nb = 6\ndef f3(a):\n    global b\n    print(a)\n    print(b)\n    b = 9\n    \nf2(3)\n# output\n3\n6\n闭包\n闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时，虽然定义作用域不可用，但仍能使用那些绑定。\n介绍闭包前先要说明一下 Python 的函数参数\n函数的两种参数\n函数有两种参数\n\n位置参数\n命名参数\n\ndef foo(x, y=0):\n    return x - y\npython 中一切都是对象\n函数和python中其他一样都是对象\nIn [7]: class A(object):\n   ...:     pass\n\n\nIn [8]: A\nOut[8]: __main__.A\nIn [9]: type(A)\nOut[9]: type\nIn [10]: def foo():\n   ....:     pass\n\n\nIn [11]: type(foo)\nOut[11]: function\n\nIn [12]: A.__class__\nOut[12]: type\n\nIn [13]: foo.__class__\nOut[13]: function\n\nIn [14]: a = 1\nIn [15]: a.__class__\nOut[15]: int\n\n# 类 是对象\nIn [16]: issubclass(A.__class__, object)\nOut[16]: True\n\n# 变量 是对象\nIn [17]: issubclass(a.__class__, object)\nOut[17]: True\n\n# 函数 是对象\nIn [18]: issubclass(foo.__class__, object)\nOut[18]: True\n所以函数也可以作为参数传递给其它函数，也可以被当做返回值返回\ndef add(x, y):\n    return x + y\n\ndef apply(func):\n    return func\n\n>> a = apply(add)\n>> type(a)\n<type 'function'>\n\n>> a(1, 2)\n>> 3\n闭包的使用\n先来看一个示例：假设有个名为 avg 的函数，它的作用是计算不断增加的系列值的均值；它是这么使用的：\n>>> avg(10)\n10\n>>> avg(11)\n10.5\n>>> avg(12)\n11\n那么我们考虑下，avg 从何而来，它又在哪里保存历史值呢，这个用闭包如何实现呢？下边的代码是闭包的实现：\ndef make_averager():\n    series = []\n\n    def averager(new_value):\n        series.append(new_value)\n        total = sum(series)\n        return total/len(series)\n\n    return averager\n调用  make_averager 时，返回一个 averager 函数对象。每次调用 averager 时，它都会把参数添加到系列值中，然后计算当前平均值。\navg = make_averager()\n\n>>> avg(10)\n10\n>>> avg(11)\n10.5\n>>> avg(12)\n11\nseries 是make_averager 函数的局部变量，因为那个函数的定义体中初始化了series: series=[]。但在averager 函数中，series 是自由变量（指未在本地作用域中绑定的变量）。\n\naverager 的闭包延伸到那个函数的作用域之外，包含自由变量series的绑定。\n\navg 就是一个闭包\n也可以说 make_averager 指向一个闭包\n或者说 make_averager 是闭包的工厂函数\n\n\n闭包可以认为是一个内层函数(averager)，由一个变量指代，而这个变量相对于外层包含它的函数而言，是本地变量嵌套定义在非全局作用域里面的函数能够记住它在被定义的时候它所处的封闭命名空间\n闭包 只是在形式和表现上像函数，但实际上不是函数。函数是一些可执行的代码，这些代码在函数被定义后就确定了，不会在执行时发生变化，所以一个函数只有一个实例。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。\n\n装饰器\n实现一个简单的装饰器\n对一个已有的模块做一些“修饰工作”，所谓修饰工作就是想给现有的模块加上一些小装饰（一些小功能，这些小功能可能好多模块都会用到），但又不让这个小装饰（小功能）侵入到原有的模块中的代码里去\ndef my_decorator(func):\n    def wrapper():\n        print \"Before the function runs\"\n        func() # 这行代码可用，是因为 wrapper 的闭包中包含自由变量 func\n        print \"After the function runs\"\n    return wrapper\n\ndef my_func():\n    print \"I am a stand alone function\"\n\n\n>> my_func()\n\n# output\nI am a stand alone function\n\n# 然后，我们在这里装饰这个函数\n# 将函数传递给装饰器，装饰器将动态地将其包装在任何想执行的代码中，然后返回一个新的函数\n\n>> my_func = my_decorator(my_func)\n>> my_func()\n#output\nBefore the function runs\nI am a stand alone function\nAfter the function runs\n\n# 也可以这么写\n\n@ my_decorator\ndef my_func():\n    print \"I am a stand alone function\"\n\n>> my_func()\n#output\nBefore the function runs\nI am a stand alone function\nAfter the function runs\n装饰器是设计模式中装饰器模式（英文版）的python实现。\n多个装饰器\n装饰器可以嵌套使用\ndef bread(func):\n    def wrapper():\n        print \"</''''''\\>\"\n        func()\n        print \"<\\______/>\"\n    return wrapper\n\ndef ingredients(func):\n    def wrapper():\n        print \"#tomatoes#\"\n        func()\n        print \"~salad~\"\n    return wrapper\n\ndef sandwich(food=\"--ham--\"):\n    print food\n\n#### outputs:\n嵌套两个装饰器\n>> sandwich = bread(ingredients(sandwich))\n>> sandwich()\n\n#### outputs\n</''''''\\>\n #tomatoes#\n --ham--\n ~salad~\n<\\______/>\n更简单的写法\n@bread\n@ingredients\ndef sandwich(food=\"--ham--\"):\n    print food\n\n装饰器的顺序是很重要的\n如果我们换下顺序就会发现，三明治变成了披萨。。\n@ingredients\n@bread\ndef sandwich(food=\"--ham--\"):\n    print food\n\n# outputs:\n    \n #tomatoes#\n </' ' ' ' ' '\\>\n   --ham--\n <\\______/>\n ~salad~\nDecorator 的工作原理\n首先看一下这段代码\ndef deco(fn):\n    print \"I am %s!\" % fn.__name__\n\n@deco\ndef func():\n    pass\n\n# output\nI am func!\n\n# 没有执行func 函数 但是 deco 被执行了\n在用某个@decorator来修饰某个函数func时\n@decorator\ndef func():\n    pass\n\n其解释器会解释成下面这样的语句：\nfunc = decorator(func)\n其实就是把一个函数当参数传到另一个函数中，然后再回调但是值得注意的是装饰器必须返回一个函数给func\n回到刚才的例子\n\ndef my_decorator(func):\n    def wrapper():\n        print \"Before the function runs\"\n        func()\n        print \"After the function runs\"\n    return wrapper\n\ndef my_func():\n    print \"I am a stand alone function\"\n\n>> my_func = my_decorator(my_func)\n>> my_func()\n#output\nBefore the function runs\nI am a stand alone function\nAfter the function runs\n\nmy_decorator(my_func)返回了wrapper()函数，所以，my_func其实变成了wrapper的一个变量，而后面的my_func()执行其实变成了wrapper()\n比如：多个decorator\n@decorator_one\n@decorator_two\ndef func():\n    pass\n相当于：\nfunc = decorator_one(decorator_two(func))\n比如：带参数的decorator：\n@decorator(arg1, arg2)\ndef func():\n    pass\n# 相当于：\n\nfunc = decorator(arg1,arg2)(func)\n带参数的装饰器\n首先看一下， 如果被装饰的方法有参数\ndef a_decorator(method_to_decorate):\n    def wrapper(self, x):\n        x -= 3\n        print 'x is %s' % x\n        method_to_decorate(self, x)\n    return wrapper\n\n\nclass A(object):\n\n    def __init__(self):\n        self.b = 42\n\n    @a_decorator\n    def number(self, x):\n        print \"b is %s\" % (self.b + x)\n\n\na = A()\na.number(-3)\n\n# output\nx is -6\nb is 36\n通常我们都使用更加通用的装饰器，可以作用在任何函数或对象方法上，而不必关心其参数使用\ndef a_decorator(method_to_decorate):\n    def wrapper(*args, **kwargs):\n        print '****** args ******'\n        print args\n        print kwargs\n        method_to_decorate(*args, **kwargs)\n    return wrapper\n\n@a_decorator\ndef func():\n    pass\n\nfunc()\n#output\n****** args ******\n()\n{}\n\n@a_decorator\ndef func_with_args(a, b=0):\n    pass\n    return a + b\n\nfunc_with_args(1, b=2)\n\n#output\n****** args ******\n(1,)\n{'b': 2}\n\n上边的示例是带参数的被装饰函数\n现在我们看一下向装饰器本身传递参数\n向装饰器本身传递参数\n装饰器必须使用函数作为参数，你不能直接传递参数给装饰器本身如果想传递参数给装饰器，可以 声明一个用于创建装饰器的函数\n# 我是一个创建装饰器的函数\ndef decorator_maker():\n    print \"I make decorators!\"\n\n    def my_decorator(func):\n        print \"I am a decorator!\"\n\n        def wrapped():\n            print \"I am the wrapper around the decorated function. \"\n            return func()\n\n        print \"As the decorator, I return the wrapped function.\"\n        return wrapped\n\n    print \"As a decorator maker, I return a decorator\"\n    return my_decorator\n\n# decorator_maker()返回的是一个装饰器\nnew_deco = decorator_maker()\n\n#outputs\nI make decorators!\nAs a decorator maker, I return a decorator\n\n# 使用装饰器\ndef decorated_function():\n    print \"I am the decorated function\"\n\ndecorated_function = new_deco(decorated_function)   \ndecorated_function()\n\n# outputs\nI make decorators!\nAs a decorator maker, I return a decorator\nI am a decorator!\nAs the decorator, I return the wrapped function.\nI am the wrapper around the decorated function.\nI am the decorated  function\n\n使用@修饰\ndecorated_function = new_deco(decorated_function)\n\n# 等价于下面的方法\n\n@new_deco\ndef func():\n    print \"I am the decorated function\"\n\n\n@decorator_maker()\ndef func():\n    print \"I am the decorated function\"\n\nmy_decorator（装饰器函数）是decorator_maker（装饰器生成函数）的内部函数\n所以可以使用把参数加在decorator_maker（装饰器生成函数）的方法像装饰器传递参数\n# 我是一个创建带参数装饰器的函数\ndef decorator_maker_with_arguments(darg1, darg2):\n    print \"I make decorators! And I accept arguments:\", darg1, darg2\n\n    def my_decorator(func):\n        print \"I am a decorator! Somehow you passed me arguments:\", darg1, darg2\n\n        def wrapped(farg1, farg2):\n            print \"I am the wrapper around the decorated function.\"\n            print \"I can access all the variables\", darg1, darg2, farg1, farg2\n            return func(farg1, farg2)\n\n        print \"As the decorator, I return the wrapped function.\"\n        return wrapped\n\n    print \"As a decorator maker, I return a decorator\"\n    return my_decorator\n\n@decorator_maker_with_arguments(\"deco_arg1\", \"deco_arg2\")\ndef decorated_function_with_arguments(function_arg1, function_arg2):\n    print (\"I am the decorated function and only knows about my arguments: {0}\"\n           \" {1}\".format(function_arg1, function_arg2))\n\n\ndecorated_function_with_arguments('farg1', 'farg2')\n\n# outputs\n\nI make decorators! And I accept arguments: deco_arg1 deco_arg2\nAs a decorator maker, I return a decorator\nI am a decorator! Somehow you passed me arguments: deco_arg1 deco_arg2\nAs the decorator, I return the wrapped function.\nI am the wrapper around the decorated function.\nI can access all the variables deco_arg1 deco_arg2 farg1 farg2\nI am the decorated function and only knows about my arguments: farg1 farg2    \n\n这里装饰器生成函数内部传递参数是闭包的特性\n使用装饰器需要注意\n\n装饰器是Python2.4的新特性\n装饰器会降低代码的性能\n装饰器仅在Python代码导入时被调用一次,之后你不能动态地改变参数.当你使用\"import x\",函数已经被装饰\n\n使用 functools.wraps\n\n最后Python2.5解决了最后一个问题，它提供functools模块，包含functools.wraps，这个函数会将被装饰函数的名称、模块、文档字符串拷贝给封装函数\ndef foo():\n    print \"foo\"\n\nprint foo.__name__\n#outputs: foo\n\n# 但当你使用装饰器\ndef bar(func):\n    def wrapper():\n        print \"bar\"\n        return func()\n    return wrapper\n\n@bar\ndef foo():\n    print \"foo\"\n\nprint foo.__name__\n#outputs: wrapper\n\n\"functools\" 可以修正这个错误\n\nimport functools\n\ndef bar(func):\n    # 我们所说的 \"wrapper\", 封装 \"func\"\n    @functools.wraps(func)\n    def wrapper():\n        print \"bar\"\n        return func()\n    return wrapper\n\n@bar\ndef foo():\n    print \"foo\"\n\n# 得到的是原始的名称, 而不是封装器的名称\nprint foo.__name__\n#outputs: foo\n类装饰器\nclass myDecorator(object):\n\n    def __init__(self, func):\n        print \"inside myDecorator.__init__()\"\n        self.func = func\n\n    def __call__(self):\n        self.func()\n        print \"inside myDecorator.__call__()\"\n\n@myDecorator\ndef aFunction():\n    print \"inside aFunction()\"\n\nprint \"Finished decorating aFunction()\"\n\naFunction()\n\n# output：\n# inside myDecorator.__init__()\n# Finished decorating aFunction()\n# inside aFunction()\n# inside myDecorator.__call__()\n我们可以看到这个类中有两个成员：\n\n一个是__init__()，这个方法是在我们给某个函数decorator时被调用，所以，需要有一个func的参数，也就是被decorator的函数。\n一个是__call__()，这个方法是在我们调用被decorator函数时被调用的\n\n如果decorator有参数的话，__init__() 就不能传入func了，而fn是在__call__的时候传入\nclass myDecorator(object):\n\n    def __init__(self, arg1, arg2):\n        self.arg1 = arg2\n\n    def __call__(self, func):\n        def wrapped(*args, **kwargs):\n            return self.func(*args, **kwargs)\n        return wrapped\n装饰器示例\nPython 内置了三个用于装饰方法的函数：property、classmethod和 staticmethod。另一个常见的装饰器是 functools.wraps，它的作用是协助构建行为良好的装饰器。\nfunctools.lru_cache\nfunctools.lru_cache 实现了内存缓存功能，它可以把耗时长的函数结果保存起来，避免传入相同参数时重复计算。\n我们自己的实现代码如下：\n\nfrom functools import wraps\ndef memo(fn):\n    cache = {}\n    miss = object()\n\n    @wraps(fn)\n    def wrapper(*args):\n        result = cache.get(args, miss)\n        if result is miss:\n            result = fn(*args)\n            print \"{0} has been used: {1}x\".format(fn.__name__, wrapper.count)\n            cache[args] = result\n        return result\n\n    return wrapper\n\n@memo\ndef fib(n):\n    if n < 2:\n        return n\n    return fib(n - 1) + fib(n - 2)\n统计函数执行次数的装饰器\ndef counter(func):\n    \"\"\"\n    记录并打印一个函数的执行次数\n    \"\"\"\n    def wrapper(*args, **kwargs):\n        wrapper.count = wrapper.count + 1\n        res = func(*args, **kwargs)\n        print \"{0} has been used: {1}x\".format(func.__name__, wrapper.count)\n        return res\n    wrapper.count = 0\n    return wrapper\n装饰器做缓存\n带有过期时间的内存缓存\ndef cache_for(duration):\n    def deco(func):\n        @wraps(func)\n        def fn(*args, **kwargs):\n            key = pickle.dumps((args, kwargs))\n            value, expire = func.func_dict.get(key, (None, None))\n            now = int(time.time())\n            if value is not None and expire > now:\n                return value\n            value = func(*args, **kwargs)\n            func.func_dict[key] = (value, int(time.time()) + duration)\n            return value\n        return fn\n    return deco\n统计代码运行时间\ndef timeit(fn):\n\n    @wraps(fn)\n    def real_fn(*args, **kwargs):\n        if config.common['ENVIRON'] == 'PRODUCTION':\n            return fn(*args, **kwargs)\n\n        _start = time.time()\n        #app.logger.debug('Start timeit for %s' % fn.__name__)\n        result = fn(*args, **kwargs)\n        _end = time.time()\n        _last = _end - _start\n        app.logger.debug('End timeit for %s in %s seconds.' %\n                         (fn.__name__, _last))\n        return result\n\n    return real_fn\n参考链接\n\nHow can I make a chain of function decorators in Python?\n理解PYTHON中的装饰器\nPython修饰器的函数式编程\nUnderstanding Python Decorators in 12 Easy Steps!\nPEP 0318 -- Decorators for Functions and Methods\nPEP 3129 -- Class Decorators\n[args and *kwargs? [duplicate]](http://stackoverflow.com/ques...\nwhy-cant-i-set-a-global-variable-in-python\n【flask route】\nPythonDecoratorLibrary\n关于Python Decroator的各种提案\n\n\n最后，感谢女朋友支持。\n\n\n欢迎关注(April_Louisa)\n请我喝芬达\n\n\n\n\n\n\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "27"}