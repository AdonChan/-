{"title": "Python 正则表达式 - 太不白的学习频道 ", "index": "正则表达式,python", "content": "最近研究Python爬虫，很多地方用到了正则表达式，但是没好好研究，每次都得现查文档。今天就专门看看Python正则表达式。本文参考了官方文档 re模块。\n模式\n首先正则表达式的语法我就不说了，这玩意倒是不算难，用的时候现查就行了——正则表达式_百度百科。\n在很多编程语言中，由于有转义字符这么一种东西的存在，导致正则表达式需要使用两个斜杠来处理。如果编程语言支持原始字符串，那么就不需要两个斜杠了。在Python中，字符串前面添加字母r即可把字符串变成原始字符串。\n下面是一个正则表达式最简单的使用例子。我们查找所有以字母F开头的单词，不论大小写。这个例子使用了正则表达式模块的re.findall函数，它会返回所有符合模式的列表。\nimport re\n\ntext = 'fuck shit it make she forest'\n\nresults = re.findall(r'\\b[Ff]\\w+', text)\nprint(results)\n如果某一个模式需要经常使用，我们可以把它编译为模式对象。然后从模式对象上调用各种正则查询方法。这样做的优点是：由于模式已经编译了，所以后续的查询速度会更快。\npattern = re.compile(r'\\b[Ff]\\w+')\nprint(pattern.findall(text))\n查询标志\n大部分查询方法还可以接受一个查询标志参数。查询标志让正则表达式具有不同的行为。下面一一说明。\n\n\n标志\n作用\n\n\n\nre.A、re.ASCII\n以ASCII模式查询，默认是Unicode模式\n\n\nre.DEBUG\n显示编译表达式的调试信息\n\n\nre.I、re.IGNORECASE\n忽略字母的大小写\n\n\nre.L、re.LOCALE\n以区域敏感方式查询匹配\n\n\nre.M、re.MULTILINE\n开启多行模式，开启之后行边界符^$会匹配每行的开始和结束，而不是整个字符串的开始和结束\n\n\nre.S、re.DOTALL\n使用此标志，会让点符号匹配所有字符，默认情况下点符号会匹配换行符以外的符号\n\n\nre.X、re.VERBOSE\n开启啰嗦模式，可以在写正则表达式的时候添加注释\n\n\n\n下面是啰嗦模式的例子，来自Python官方文档。\na = re.compile(r\"\"\"\\d +  # the integral part\n                   \\.    # the decimal point\n                   \\d *  # some fractional digits\"\"\", re.X)\nb = re.compile(r\"\\d+\\.\\d*\")\n查询方法\n查询方法有两种形式，第一种是re模块的函数，这些函数需要接受一个模式字符串。第二种就是从编译好的模式对象上调用，这样不需要模式字符串了。基本上大部分方法都有这两种形式，所以这里只需要介绍一种形式。\n\nre.search(pattern, string, flags=0)方法查询字符串，返回第一个结果的匹配对象。不管有多少个满足条件的字符串，这个方法之返回第一个。如果查询不到，就返回None。\nre.match(pattern, string, flags=0)查询字符串，当字符串的前面一部分和模式匹配的时候，会返回相应的匹配对象。如果不匹配，那么返回None。需要注意即使开启了多行模式，这个方法也只查询字符串最前面的一部分，不会查询每行的前面。\nre.fullmatch(pattern, string, flags=0)，如果整个字符串和模式匹配，返回相应的匹配对象。否则返回None。\nre.split(pattern, string, maxsplit=0, flags=0)，按给定正则表达式分割字符串。\nre.findall(pattern, string, flags=0)，最常用的方法，返回一个列表，包含所有匹配模式的字符串。\nre.finditer(pattern, string, flags=0)，和findall方法类似，不过返回的是一个迭代器。\nre.sub(pattern, repl, string, count=0, flags=0)，将字符串中匹配模式的部分使用repl替换，返回替换后的字符串。\nre.subn(pattern, repl, string, count=0, flags=0)，和sub方法类似，不过返回元组(新字符串,替换的数量)。\nre.purge()，清除正则表达式缓存。\n\n在已编译好的正则表达式对象上还有以下几个属性。\n\nflags，正则表达式的所有标志，包括flags参数设置的，compile方法编译传入的，以及正则表达式中本身的标志。\ngroups，正则表达式中捕获组的数量。\npattern，返回模式字符串。\ngroupindex，返回(?P<id>)形式的命名组和组编号键值对组成的字典。\n\n匹配对象\n上面提到的很多方法都返回匹配对象。匹配对象包含了一些方法和属性，方便我们进行查询。\n最常用的就是group函数，它会返回指定组对应的字符串。下面的例子就查询了给定数据中的数据量和每页的条数。第0组返回整个匹配，第1组返回第一个匹配，以此类推……也可以采用命名组的方式。\ntext = '总共20条数据 每页5条'\npattern = re.compile(r'总共(?P<total>\\d+)条数据\\s+每页(?P<per>\\d+)条')\n\nmatch = pattern.match(text)\nprint(match.group(0))\n另一个比较常用的函数就是groups(default=None)，它返回所有组组成的元组。如果有的组没有匹配到字符串，就会显示为None，这时候可以使用default参数指定默认值。\ntext = '总共20条数据 每页5条'\npattern = re.compile(r'总共(?P<total>\\d+)条数据\\s+每页(?P<per>\\d+)条')\n\nmatch = pattern.match(text)\n\nprint(match.groups())\n\n# 结果\n# ('20', '5')\ngroupdict(default=None)返回组名和字符串组成的字典。还是上面的例子。\nprint(match.groupdict())\n# {'total': '20', 'per': '5'}\nstart和end函数返回给定组的在字符串的起始和结束索引，如果对应的组没有任何匹配，则返回-1。下面的例子来自Python官方文档，从电子邮件地址中去除remove_this。\n>>> email = \"tony@tiremove_thisger.net\"\n>>> m = re.search(\"remove_this\", email)\n>>> email[:m.start()] + email[m.end():]\n'tony@tiger.net'\nmatch.span([group])返回给定组的起始索引和结束索引组成的元组。\n以上就是Python正则表达式的大部分内容了，灵活使用这些知识，可以获得强大的功能。关于如何巧用，就看大家的智慧了。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "7"}