{"title": "用 Python 拓展 GDB（三） - spacewander ", "index": "python,gdb", "content": "欢迎来到《用python拓展gdb》的第三篇。上一篇我们谈到了pretty printer，一个需要python支持的特性。这一篇我们谈论另一个需要python支持的特性，convenience function。\n什么是convenience function\n所谓的convenience function，正如其名“便利函数”，指gdb会话中，可用于辅助数据处理的一类函数。\n举个例子：\n(gdb) print foo()\n$1 = void\n(gdb) print $_isvoid(foo())\n$2 = 1\n上面的$_isvoid就是convenience functions。它们必须以$开头，以此区别于来自于C/C++上下文的函数。\ngdb中内置了一些convenience functions，可惜它们的数量并不多。还好gdb提供了python接口，让我们能够添加自定义的convenience functions。\n跟自定义命令一样，该接口也需要用户继承特定的类。convenience function提供的基类名为gdb.Function。用户需要实现其中的__init__和invoke(self, *args)两个方法，然后通过构造一个对象来向gdb注册该函数。基本上就是自定义命令的一个翻版。不过有一个区别是，gdb.Function的invoke方法通常会返回一个gdb.Value对象，表示调用该函数后的返回值。如果返回的不是gdb.Value对象，gdb会尝试把它转化成对应的gdb.Value对象。比方说，如果invoke方法返回的是一个字符串，那么gdb会把该字符串包装成表示字符串的gdb.Value。\n比起自定义命令，convenience function有一个劣势。它不能（像通常意义上的函数）独立使用，只能跟某个命令搭配。举个例子，(gdb) $aryType()是语法不正确的，你只能(gdb) p $aryType()。即使在调试脚本里这一条也成立，单独一个$setSize(\"ary\", 20)就不行，需要用p $setSize(\"ary\", 20)绕过。事实上，用自定义命令setSize \"ary\" 20看上去会更顺眼。convenience function能干的事，自定义命令大部分也能干，导致它的存在感一向很稀薄。\n当然，它也不全是个鸡肋。convenience function有一个优势，它可以返回值。这是自定义命令做不到的。属于它的生存空间也就剩下这么一点了。\n实现一个convenience function\n老规矩，还是用我最爱的教学方式，先上示例代码。\n这次我们尝试用DSL实现mv命令的第二版。该版本的mv接受两个参数，一个是待移除断点的位置，另一个是待设定断点的位置。\nmv具体实现参见《用python拓展gdb》第一篇。由于DSL里面没有函数，我们会用python代码实现名为findBreakpoint的convenience function。当然了，如果我们选择用python实现mv，就没有这个需求了。还是创造下机会让convenience function上一会场吧。\nfindBreakpoint的功能是接受一个位置，返回该位置上首个断点的编号，这样就能在delete命令里移除目标断点。实现代码如下：\n# mv2.gdb\n# 使用python...end语句块，使得我们可以在gdb的DSL文件里面编写python代码。\npython\nimport os\n# 1. 继承gdb.Function\nclass FindBreakpoint(gdb.Function):\n    \"Find specific breakpoint with location\"\n    def __init__(self):\n        # 2. 注册函数名字'findBreakpoint'\n        super(self.__class__, self).__init__('findBreakpint')\n\n    def invoke(self, location):\n        # 3. 不要忘了，invoke方法接受的参数是gdb.Value，所以后面我通过\n        # string方法来获得字符串值。\n        bps = gdb.breakpoints() # 获取全部断点\n        if bps is None:\n            raise gdb.GdbError('No breakpoints')\n        for bp in bps:\n            # 由于断点的location属性返回的是绝对路径，把它转成相对路径\n            if os.path.relpath(bp.location) == location.string():\n                # 4. convenience function需要返回值，gdb会把它包装成gdb.Value类型\n                return bp.number\n        raise gdb.GdbError(\"Specific breakpoint can't be found.\")\n\n# 5. 最后一步，向gdb会话注册该函数\nFindBreakpoint()\nend\n\ndefine mv\n    if $argc == 2\n        # 调用它的时候不要忘记'$'前缀\n        set $i = $findBreakpint($arg0)\n        delete $i\n        # 看到我在上面耍的一个trick吗？\n        # findBreakpint返回的是一个gdb.Value，\n        # 需要把它绑定到DSL变量上，才能在DSL中使用。\n        break $arg1\n    ...\n使用方式：gdb a.out -x mv2.gdb。\n(gdb) help function\n...\nfunction findBreakpint -- Find specific breakpoint with location\n...\n(gdb) mv \"gdb.c:4\" 5\n注意mv第一个参数需要用双引号括起来，否则gdb会报错，说找不到符号gdb.c。\n小结\n下篇将会是本教程的最后一篇。在这最后一篇里，我们会看到，如何用python在gdb内跟外部程序交互。希望“gdb + X”的想法能让你脑洞大开，激发出更多的玩法。敬请期待！\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "5"}