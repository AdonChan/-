{"title": "python闭包探究一二 - mugbya ", "index": "python,闭包", "content": "复习\npython引用变量的顺序： 当前作用域局部变量 -> 外层作用域变量 -> 当前模块中的全局变量 -> python内置变量\nglobal：声明一个全局变量\nnonlocal：用来在函数或其他作用域中使用外层(非全局)变量 \n对于global跟nonlocal请点击 python3中global 和 nonlocal 的作用域\n变量生存期\n我们写个简单的变量生存期的小例子\n\ndef transmit_to_space(message):\n    print(message)\n\nprint(transmit_to_space(\"Test message\"))\n\nprint(message)  # 报错 NameError: name 'message' is not defined \n嵌套函数\nPython 允许函数中有函数，即为嵌套函数。\ndef transmit_to_space(message):\n    \"This is the enclosing function\"\n    def data_transmitter():\n        \"The nested function\"\n        print(message)\n\n    data_transmitter()\n\nprint(transmit_to_space(\"Test message\"))\n在嵌套函数中访问了最外层函数的参数，结果我们是能正常访问 message\n闭包\n我们将上面的最外层（enclosing function) 的返回值修改为返回嵌套函数的引用(Python一切皆对象)\ndef transmit_to_space(message):\n  \"This is the enclosing function\"\n  def data_transmitter():\n      \"The nested function\"\n      print(message)\n  return data_transmitter\n\nfun2 = transmit_to_space(\"Burn the Sun!\")\nfun2()\n根据前面变量生存期例子，按理说 transmit_to_space(\"Burn the Sun!\") 调用完 message 的生命周期应该结束了，fun2调用应该失败才对，但是实际却调用成功了。\n其实这里涉及到了闭包，我们查看 fun2 的 __closure__ 属性 (python2下是func_closure)。看到有一个cell对象，里面值就是 message 的内容。\n\n所以闭包是： 嵌套定义在非全局作用域里面的函数能够记住它在被定义的时候它所处的封闭命名空间。（只会记住被嵌套函数使用的值，如果enclosing function 里面还定义了其他的值，封闭作用域里面是不会有的）  \n看下面例子的变化\n\n我们增加一个参数，但是嵌套函数中未使用这个参数，发现fun2就没有再记住这个值。\n\n更多链接：Python闭包详解\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "2"}