{"title": "Pythonic Code in Practice - 小杰控的清水道场 ", "index": "python", "content": "此文章收集平时工作中一些Pythonic code，以供后面参考。\n循环结束处理\n通常以往的做法是设置一个标志位来处理或其他额外处理:\ndef get_file_content(fpath):\n    \"\"\"Get file content by the right encoding.\"\"\"\n    G_ENCODING_LIST = ['utf-8', 'gbk', 'latin1']\n    for encode in G_ENCODING_LIST:\n        try:\n            content = open(fpath, encoding=encode).read()\n            return content\n        except UnicodeDecodeError:\n            if encode == G_ENCODING_LIST[-1]:\n                raise\n        except FileNotFoundError:\n            raise\n而下例中的做法则是利用了Python本身语法的特性：\ndef get_file_content(fpath):\n    \"\"\"Get file content by the right encoding.\"\"\"\n    G_ENCODING_LIST = ['utf-8', 'gbk', 'latin1']\n    for encode in G_ENCODING_LIST:\n        try:\n            content = open(fpath, encoding=encode).read()\n            return content\n        except UnicodeDecodeError:\n            pass\n        except FileNotFoundError:\n            raise\n    else:\n        raise UnicodeDecodeError\n另外需要注意的是:\n\n在except分支中，如果是抛出刚抓取的异常，可不必指定。\n为了避免过深的try except嵌套，这里使用了for循环使代码块更加扁平\n\n列表生成式\n创建列表，通常的做法可以是这样：\ndef add_patterns(self, ptn_docs):\n    \"\"\"Add pattern set info.\"\"\"\n    ltypes = []\n    for ltype, doc in ptn_docs:\n        ltypes.append(ltype)\n        # 不使用列表表达式创建列表\n        doc_list = []\n        for word in jieba.cut(doc):\n            doc_list.append(word)\n        doc_list = [word for word in jieba.cut(doc)]\n        doc_list = list(set(doc_list) - set(G_STOP_WORDS))\n        self._ptn_simtest_dbs[ltype]['all_doc_list'].append(doc_list)\n        self._ptn_simtest_dbs[ltype]['dict'].add_documents([doc_list])\n    ......\nPythonic的做法则是这样：\ndef add_patterns(self, ptn_docs):\n    \"\"\"Add pattern set info.\"\"\"\n    ltypes = []\n    for ltype, doc in ptn_docs:\n        ltypes.append(ltype)\n        # 使用列表表达式创建列表\n        doc_list = [word for word in jieba.cut(doc)]\n        doc_list = list(set(doc_list) - set(G_STOP_WORDS))\n        self._ptn_simtest_dbs[ltype]['all_doc_list'].append(doc_list)\n        self._ptn_simtest_dbs[ltype]['dict'].add_documents([doc_list])\n    ......\n注释：\n这里使用了集合差的方式求列表差集：\ndoc_list = list(set(doc_list) - set(G_STOP_WORDS))\n布尔值判断\n根据判断对象结果返回True or False，可以通过以下方法简写：\ndef _check_fingerprint(self, suspect):\n    \"\"\"Check whether fingerprint exist.\"\"\"\n    content = open(suspect, 'rb').read()\n    md5sum = hashlib.md5(content).hexdigest()\n    wsp = self.ws_data.filter(fingerprint=md5sum)\n    return True is wsp else False\n还有更简洁的写法吗：\ndef _check_fingerprint(self, suspect):\n    \"\"\"Check whether fingerprint exist.\"\"\"\n    content = open(suspect, 'rb').read()\n    md5sum = hashlib.md5(content).hexdigest()\n    wsp = self.ws_data.filter(fingerprint=md5sum)\n    return bool(wsp)\ngoto in Python\n记得学习C语言的时候，老师通常会说不建议我们使用“goto”这样的语法，以免造成意想不到的结果。但实际工作中，想“goto”这种语法糖在有些场景中有让人爱不释手。\n先看这个场景，下面代码解析一个压缩包中的pattern是否满足指定格式：\ndef check_pattern_package(fpath):\n    \"\"\"Check pattern package correctness.\"\"\"\n    base_dir = os.path.dirname(fpath)\n    ret, reason, extract_dir = True, None, None\n    with zipfile.ZipFile(fpath) as zf:\n        infolist = zf.infolist()\n        if not infolist[0].is_dir():\n            return False, REST_ERR_400_ZIP_BADFILE\n        zf_base_dir = infolist[0].filename\n        md5sum_file = os.path.join(zf_base_dir, 'md5sum.txt')\n        if md5sum_file not in zf.namelist():\n            return False, REST_ERR_400_ZIP_BADFORMAT\n        zf.extractall(base_dir)\n\n    extract_dir = os.path.join(base_dir, zf_base_dir)\n    try:\n        with open(os.path.jion(base_dir, md5sum_file)) as md5_fp:\n            reader = csv.reader(md5_fp, delimiter=' ')\n    except FileNotFoundError:\n        return False, REST_ERR_400_ZIP_BADFORMAT\n    else:\n        for row in reader:\n            if len(row) < 2:\n                raise PtnPackageParseError(REST_ERR_400_ZIP_BADFORMAT)\n            pzf = os.path.join(extract_dir, row[1])\n            with open(pzf, 'rb') as fpzf:\n                fdata = fpzf.read()\n            md5sum = hashlib.md5(fdata).hexdigest()\n            if md5sum != row[0]:\n                return False, REST_ERR_400_ZIP_BADFILE\n    return True, _\n在上述代码中，为了更好的执行效率，一旦发现格式不符函数直接返回。\n现在对这个函数有一个新的需求：根据函数的输入参数，删除压缩包和解压缩目录所有文件。对于该需求，如果按照上述代码执行，则需要在每一个“return”关键字处对需要删除的文件进行处理，这样会有很多重复代码。以往在C语言中，使用“goto”可以很好的完成任务，很遗憾Python并不支持“goto”。\n使用“try exception”控制代码执行路径模拟“goto”:\nclass PtnPackageParseError(Exception):\n\n    \"\"\"Exception for pattern package parse.\"\"\"\n\n    def __init__(self, reason, message=''):\n        self.reason = reason\n        self.message = message\n        super().__init__()\n        \n        \ndef check_pattern_package(fpath, cleanup=False):\n    \"\"\"Check pattern package correctness.\"\"\"\n    base_dir = os.path.dirname(fpath)\n    ret, reason, extract_dir = True, None, None\n    try:\n        with zipfile.ZipFile(fpath) as zf:\n            infolist = zf.infolist()\n            if not infolist[0].is_dir():\n                raise PtnPackageParseError(REST_ERR_400_ZIP_BADFILE)\n            zf_base_dir = infolist[0].filename\n            md5sum_file = os.path.join(zf_base_dir, 'md5sum.txt')\n            if md5sum_file not in zf.namelist():\n                raise PtnPackageParseError(REST_ERR_400_ZIP_BADFORMAT)\n            zf.extractall(base_dir)\n\n        extract_dir = os.path.join(base_dir, zf_base_dir)\n        try:\n            with open(os.path.jion(base_dir, md5sum_file)) as md5_fp:\n                reader = csv.reader(md5_fp, delimiter=' ')\n        except FileNotFoundError:\n            raise PtnPackageParseError(REST_ERR_400_ZIP_BADFORMAT)\n        else:\n            for row in reader:\n                if len(row) < 2:\n                    raise PtnPackageParseError(REST_ERR_400_ZIP_BADFORMAT)\n                pzf = os.path.join(extract_dir, row[1])\n                with open(pzf, 'rb') as fpzf:\n                    fdata = fpzf.read()\n                md5sum = hashlib.md5(fdata).hexdigest()\n                if md5sum != row[0]:\n                    raise PtnPackageParseError(REST_ERR_400_ZIP_BADFILE)\n    except PtnPackageParseError as e:\n        ret, reason = False, e.reason\n    finally:\n        if cleanup:\n            os.unlink(fpath)\n            if os.path.exists(extract_dir):\n                os.removedirs(extract_dir)\n    return ret, reason, extract_dir\n原文出处：github: jasonTu/python-material-collection\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}