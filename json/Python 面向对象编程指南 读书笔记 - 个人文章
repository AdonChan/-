{"title": "Python 面向对象编程指南 读书笔记 - 个人文章 ", "index": "oop,python", "content": "第一部分 用特殊方法实现Python风格的类\n为了实现更好的可扩展性，Python语言提供了大量的特殊方法，它们大致分为以下几类。\n\n特性访问\n可调用对象\n集合\n数字\n上下文\n迭代器\n\n第一章  使用__init()__方法\nPython中一切事物皆对象！！！！！！__init__()方法记住两点：\n\n__init()__（初始化）是对象生命周期的开始，每个对象必须正确初始化才能够正常的工作。\n__init__()可以赋值\n\n对象的生命周期主要是有创建、初始化、销毁。‘显示而非隐式’：对于每个__init__()方法，都应当显示的制定要初始化的变量。每当创建一个对象，python会创建一个空对象，然后调用该对象的__init__()函数，提供了初始化的操作。\n# 以21点为例作为说明。\nclass Card(object):\n    def __init__(self, suit, rank):\n        self.suit = suit\n        self.rank = rank\n        self.hard, self.soft = self._points()\n\n\nclass NumberCard(Card):\n    def _points(self):\n        return int(self.rank), int(self.rank)\n\n\nclass AceCard(Card):\n    def _points(self):\n        return 1, 11\n\n\nclass FaceCard(Card):\n    def _points(self):\n        return 10, 10\n   \nclass Suit(object):\n    def __init__(self,name,symbol):\n        self.name = name\n        self.symbol = symbol\n\nClub,Diamond,Heart,Spade = Suit('Club','♣'),Suit('Diamond','♦'),Suit('Heart','♥'),Suit('Spade','♠')\n通过工厂函数来调用__init__():\n\ndef card(rank, suit):\n    if rank == 1:\n        return AceCard('A', suit)\n    elif 2 <= rank < 11:\n        return NumberCard(str(rank), suit)\n    elif 11 <= rank < 14:\n        name = {11: 'J', 12: 'Q', 13: 'K'}[rank]\n        return FaceCard(name, suit)\n    else:\n        raise Exception(\"rank out of range\")\n 这个函数通过传入牌面值rank 和花色值suit来创建card对象.\ndeck = [card(rank, suit) for rank in range(1, 14) for suit in (Club, Diamond, Heart, Spade)]\nprint(deck[0].rank,deck[0].suit.symbol)\n这段代码完成了52张牌对象的创建.\n使用映射和类来简化设计.\n由于类是第一级别的对象,从rank参数射到对象是很容易的事情.下面的Card类工厂就是使用映射实现的版本.\ndef card4(rank,suit):\n    class_ = {1:AceCard,11:FaceCard,12:FaceCard,13:FaceCard}.get(rank,NumberCard)\n    return class_(rank,suit)\n需要修改映射逻辑,除了提供Card子类,还需要提供rank对象的字符串结果.如何实现这两部分映射,有四种常见方案.\n\n可以建立两个并行映射\n可以映射为一个二元组.\n可以映射为partial()函数.\n可以考虑修改类定义的完成映射逻辑.1.并行映射\n\n\ndef card5(rank,suit):\n    class_ = {1:AceCard,11:FaceCard,12:FaceCard,13:FaceCard}.get(rank,NumberCard)\n    rank_str = {1:'A',11: 'J', 12: 'Q', 13: 'K'}.get(rank,str(rank))\n    return class_(rank_str,suit)\n这样是不值得做的,带来映射键1,11,12,13的逻辑重复.\n不要使用并行结构,并行结构应该被元祖或者一些更好的组合所代替\n映射到一个牌面值的元组\ndef card6(rank,suit):\n   class_,rank_str= {\n       1:(AceCard,'A'),\n       11:(FaceCard,'J'),\n       12:(FaceCard,'Q'),\n       13:(FaceCard,'K')\n   }.get(rank,(NumberCard,str(rank)))\n   \n   return class_(rank_str,suit)\n从rank值映射到类对象时很少见的,而且两个参数只有一个用于对象的初始化.从rank映射到一个相对简单的类或者是函数对象,而不必提供目的不明确的参数,这才是明智的选择.\n3.partial 函数设计\ndef card7(rank,suit):\n  from  functools import partial\n  part_class = {\n      1:partial(AceCard,'A'),\n      11:partial(FaceCard,'J'),\n      12:partial(FaceCard,'Q'),\n      13:partial(FaceCard,'K')\n  }.get(rank,partial(NumberCard,str(rank)))\n\n  return part_class(suit)\n通过调用partial()函数然后复制给part_class,完成于rank对象的管的关联,可以使用同样的方式来创建suit对象,并且完成最终的Card对象的创建.partial()函数的使用在函数时编程中是很常见的.当时用的是函数而非对象方法的时候就可以考虑使用.\n大致上,partial()函数在面向对象编程中不是很常用,我们可以简单的的提供构造函数不同版本来做相同的事情.partial()函数和构造对象时的流畅接口很类似.\n工厂模式的流畅的API设计有时候我们定义类中的方法必须按照特定的顺序来调用.这种顺序调用的方法和创建 partial() 函数的方式非常类似.\n\n我们可以在流畅接口函数中设置可以返回self值的rank对象,然后传入花色类从而创建Card实例/\n以下是Card工厂流畅接口的定义,包含两个函数,他们必须按照顺序调用.\nclass CardFactory(object):\n    def rank(self,rank):\n        self.class_,self.rank_str = {\n            1:(AceCard,'A'),\n            11:(FaceCard,'J'),\n            12:(FaceCard,'Q'),\n            13:(FaceCard,'K')\n        }.get(rank,(NumberCard,str(rank)))\n    \n    def suit(self,suit):\n        return self.class_(self.rank_str,suit)\n先使用rank()函数更新了构造函数的状态,然后通过suit()函数创造了 最终的Card对象.\ndef A (rank):\n\n    a,b ={                      # 本身为一个字典的传递值.返回对应的值.是dict的get方法\n        1: (AceCard, 'A'),\n        11: (FaceCard, 'J'),\n        12: (FaceCard, 'Q'),\n        13: (FaceCard, 'K')\n    }.get(rank, (NumberCard, str(rank)))\n    return a,b # 返回的是一个tuple(),a 为 <class '__main__.NumberCard'> , b 为'3'\n\na = A(3)\nprint(a)\n我们先实例化一个工厂对象,然然后在创建Card实例,这用方式没有利用__init__() 在Card类层级结构的作用,改变的是调用者创建创建对象的方式.\n在每个子类中实现__init__()方法\n以下代码演示了如何把__init__()方法提到基类Card中实现的过程.然后在子类中可以重用基类的实现.\n\nclass Card(object):\n    def __init__(self, rank, suit, hard, soft):\n        self.rank = rank\n        self.suit = suit\n        self.hard = hard\n        self.soft = soft\n\n\nclass NumberCard(Card):\n    def __init__(self, rank, suit):\n        super().__init__(str(rank), suit, rank, rank)\n\n\nclass AceCard(Card):\n    def __init__(self, rank, suit):\n        super(AceCard, self).__init__(\"A\", suit, 1, 11)\n\n\nclass FaceCard(Card):\n    def __init__(self, rank, suit):\n        super(FaceCard, self).__init__({11: 'J',\n                                        12: 'Q',\n                                        13: 'K'}[rank], suit, 10, 10)\n        \n\ndef card10(rank,suit):\n    if rank == 1:\n        return AceCard(rank,suit)\n    elif 2<= rank < 11:\n        return NumberCard(rank,suit)\n    elif 11<= rank <14:\n        return FaceCard(rank,suit)\n    \n    else:\n        raise  Exception('Rank out of range')\n在这里重构了基类中的__init__,虽然将它复杂化,但是这样的权衡是正常的.\n使用工厂函数封装的复杂性\n 在 `__init__()`方法和工厂函数之间存在一些权衡,通常直接调动比'程序员友好'的`__init__()`函数并把复杂性分发给工厂函数更好.当需要封装复杂的构造函数逻辑时,考虑使用工厂函数则更好.\n\n\n简单的组合对象\n一个组合对象也可以称作容器.\n如果业务逻辑相对简单,为什么定义新类?\n类的定义的一个优势是:\n类给对象提供了简单的,不需要实现的接口.\n设计集合类,通常是下面三种策略:\n\n封装:这个实际是基于现有集合类来定义一个新类,属于外观模式的一个使用场景.\n扩展:这个设计是对现有集合类进行扩展,通常使用定义子类的方式来实现.\n创建:即重新设计.\n\n以上是面向对象设计的核心.\n封装集合类\n以下是对内部集合进行封装设计.\nimport random\nclass Deck(object):\n   def __init__(self):\n       self._cards = [card6(r+1,s) for r in range(13) for s in (Club,Diamond,Heart,Spade)]\n       random.shuffle(self._cards)\n   def pop(self):\n       return self._cards.pop()\n\nd = Deck()\n\nhand = [d.pop(),d.pop()]\n一般来说买外观模式或者封装类中的方法实现只是对底层对象相应函数的代理调用.\nclass Desk3(list):\n    def __init__(self, decks=1):\n       super(Desk3, self).__init__()\n       for i in range(decks):\n           self.extend(card6(r + 1, s) for r in range(13) for s in (Club, Diamond, Heart, Spade))\n           random.shuffle(self)\n           burn = random.random(1,52)\n           for i in range(burn):\n               self.pop()\n这里我们使用了基类的 __init__()函数来创建了一个空集合,然后调用了 self.extrend()来吧多副牌加载到发牌机中.\n复杂的组合对象\n模拟打牌策略\nclass Hand:\n    def __init__(self,dealer_card):\n        self.dealer_card = dealer_card\n        self.cards = []\n        \n    def hard_total(self):\n        return sum(c.hard for c in self.cards)\n    \n    def soft_total(self):\n        return sum(c.soft for c in self.cards)\nd = Deck()\nh = Hand(d.pop())\nh.cards.append(d.pop())\nh.cards.append(d.pop())\n\n需要一个一个的添加非常不方便\n完成组合对象的初始化\n__init__()初始化方法应当返回一个完成的对象,当然这个是理想的情况.而这样也带来复杂性,因为要创建的对象内部可能包含了集合,集合里面又包含了其他对象.\n通常考虑使用一个流畅的接口来完成逐个讲对象添加到集合的操作,同时将集合对象作为构造函数来完成初始化.例如:\nclass Hand2:\n    def __init__(self, dealer_card, *cards):\n        self.dealer_card = dealer_card\n        self.cards = list(cards)\n\n    def hard_total(self):\n        return sum(c.hard for c in self.cards)\n\n    def soft_total(self):\n        return sum(c.soft for c in self.cards)\n\nd = Deck()\nh = Hand2(d.pop(),d.pop(),d.pop(),d.pop())\nprint(h.cards)\n不带__init__方法的无状态对象\n一个策略对象以插件的形式复合在主对象上来完成一种算法或逻辑.它或许以来主对象中的数据,策略对象自身并不携带任何数据.通常策略类会和亨元设计模式一起使用:在策略对象中避免内部存储.所需要的值都从策略对象方法参数传入.策略对象自身是无状态的.可以把它看做是一系列函数的集合.\n这里定义了一个类给Player实例提供了游戏的选择模式,以下这个策略包括拿牌和下注.\nclass GameStrategy:\n    def insurnace(self, hand):\n        return False\n\n    def split(self, hand):\n        return False\n\n    def double(self, hand):\n        return False\n\n    def hit(self, hand):\n        return False\n每个函数需要传入已有的Hand对象,函数逻辑所需要的数据基于现有的可用信息.意味着数据来自于庄家跟玩家的手牌.\n一起其他的类定义\n玩家有两张策略:打牌和下注.每个Player实例回合模拟器进行很多次交互.我们这里把这个模拟器命名为Table\nTable类的职责需要配合Player实例完成以下事件:\n\n玩家必须要基于玩牌策略初始化一个牌局.\n随后玩家会得到一手牌\n如果\n\n以下是Table类中投注和牌的逻辑处理相关的代码\n\nclass Table:\n    def __init__(self):\n        # 生成52张牌\n        self.deck = Deck()\n\n    def place_bet(self, amount):\n        print('Bet', amount)\n\n    def get_hand(self):\n        try:\n            # self.hand = Hand2(d.pop(), d.pop(), d.pop())\n            # self.hole_card = d.pop() 书上是这么写的我认为不对，改为下面写法\n            self.hand = Hand2(self.deck.pop(), self.deck.pop(), self.deck.pop())\n            self.hole_card = self.deck.pop()\n        except IndexError:\n            # Out of cards: need to shuffle\n            self.deck = Deck()\n            return self.get_hand()\n        print('Deal', self.hand)\n        return self.hand\n\n    # 没有看明白hand从何而来，所以也未找到insure的方法。估计是写错了。\n    def can_insure(self, hand):\n        return hand.dealer_card.insure\n\nclass BettingStrategy:\n    def bet(self):\n        raise NotImplementedError('No bet method')\n    \n    def record_win(self):\n        pass\n    \n    def record_lose(self):\n        pass\n    \nclass Flat(BettingStrategy):\n    def bet(self):\n        return 1\n上面的那一段代码还未看懂需要以后再来看一遍.\n多策略的__init__()方法\nclass Hand4:\n    def __init__(self, *args, **kwargs):\n        print(len(args),args,kwargs)\n        if len(args) == 1 and isinstance(args[0], Hand4):\n            other = args[0]\n            self.dealer_card = other.dealer_card\n            self.cards = other.cards\n\n        elif len(args) == 2 and isinstance(args[0], Hand4) and 'split' in kwargs:\n            # Split an existing hand\n            other, card = args\n            self.dealer_card = other.dealer_card\n            self.cards = [other.cards[kwargs['split']], card]\n        elif len(args) == 3:\n            # Bulid a fresh ,new hand\n            dealer_card,*cards = args\n            self.dealer_card = dealer_card\n            self.cards = list(cards)\n\n        else:\n            raise TypeError('Invaild constructor args= {0!r} kw={1!r}'.format(args,kwargs))\n\n    def __str__(self):\n        return ','.join(map(str,self.cards))\n\n\nd = Deck()\n\nh = Hand4(d.pop(),d.pop(),d.pop())\nprint(h)\n\n# s1 = Hand4(h,d.pop(),split = 0)\n# s2 = Hand4(h,d.pop(),split = 1)\nclass Hand5:\n    def __init__(self,dealer_card,*cards):\n        self.dealer_card = dealer_card\n        self.cards = list(cards)\n\n    @staticmethod\n    def freeze(other):\n        hand = Hand5(other.dealer_card,*other.cards)\n        return hand\n\n    @staticmethod\n    def split(other,card0,card1):\n        hand0 = Hand5(other.dealer_card,other.cards[0],card0)\n        hand1 = Hand5(other.dealer_card,other.cards[1],card1)\n        return hand0,hand1\n\n    def __str__(self):\n        return ','.join(map(str,self.cards))\n\nd = Deck()\n\nh = Hand5(d.pop(),d.pop(),d.pop())\ns1,s2 = Hand5.split(h,d.pop(),d.pop())\n上面这段代码实现了:当第一轮发完牌是,dealer手牌有一张,Player手牌有两张,当手牌的两张牌相同的时候玩家可以选择分牌,将手中的的两张牌分为两组牌,继续进行游戏.然后发牌器会给Palyer每组牌中个发一张牌\n更多的__init__()技术\n以下是Player类的定义,初始化使用两个策略对象和一个table对象\n略\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "3"}