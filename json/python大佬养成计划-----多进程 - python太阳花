{"title": "python大佬养成计划-----多进程 - python太阳花 ", "index": "python", "content": "进程\nPython是运行在解释器中的语言，查找资料知道，python中有一个全局锁（GIL），在使用多进程(Thread)的情况下，不能发挥多核的优势。而使用多进程(Multiprocess)，则可以发挥多核的优势真正地提高效率。如果多线程的进程是CPU密集型的，那多线程并不能有多少效率上的提升，相反还可能会因为线程的频繁切换，导致效率下降，推荐使用多进程；如果是IO密集型，多线程的进程可以利用IO阻塞等待时的空闲时间执行其他线程，提升效率。\n创建进程\nlinux和mac系统特殊方法\n1.Linux创建子进程的原理:1).  父进程和子进程, 如果父进程结束， 子进程也随之结束;2).  先有父进程， 再有子进程， 通过fork函数实现;\n2.fork函数的返回值:调用该方法一次， 返回两次;\n\n产生的子进程返回一个0\n父进程返回子进程的pid;\n\n3.Window也能使用fork函数么?\nWindows没有fork函数， Mac有fork函数(Unix -> Linux, Unix-> Mac),\n封装了一个模块multiprocessing\n\n4.常用方法:\n\nos.fork()\nos.getpid(): 获取当前进程的pid;\nos.getppid(): parent process id, 获取当前进程的父进程的id号；\n\nimport  os\nimport  time\nprint(\"当前进程(pid=%d)正在运行...\" %(os.getpid()))\nprint(\"当前进程的父进程(pid=%d)正在运行...\" %(os.getppid()))\nprint(\"正在创建子进程......\")\npid = os.fork()\npid2 = os.fork()\nprint(\"第1个:\", pid)\nprint(\"第2个: \", pid2)\n\nif pid == 0:\n    print(\"这是创建的子进程， 子进程的id为%s, 父进程的id为%s\"\n          %(os.getpid(), os.getppid()))\nelse:\n    print(\"当前是父进程[%s]的返回值%s\" %(os.getpid(), pid))\ntime.sleep(100)\nwin系统\n在win系统下，使用实例化multiprocessing.Process创建进程须添加'if __name__==\"__main__\"'，否则会出现以下报错：\nRuntimeError:\nAn attempt has been made to start a new process before the\ncurrent process has finished its bootstrapping phase.\n\nThis probably means that you are not using fork to start your\nchild processes and you have forgotten to use the proper idiom\nin the main module:\n\n   if __name__ == '__main__':\n       freeze_support()\n       ...\n\nThe \"freeze_support()\" line can be omitted if the program\nis not going to be frozen to produce an executable.\n\nimport  multiprocessing\ndef job():\n    print(\"当前子进程的名称为%s\" %(multiprocessing.current_process()))\nif __name__==\"__main__\":    #win操作系统需要加上,否则会出现异常报错RuntimeError\n\n    # 创建一个进程对象(group=None, target=None, name=None, args=(), kwargs={})\n    p1 = multiprocessing.Process(target=job)\n    p2 = multiprocessing.Process(target=job)\n    # 运行多进程， 执行任务\n    p1.start()\n    p2.start()\n\n    # 等待所有的子进程执行结束， 再执行主进程的内容\n    p1.join()\n    p2.join()\n    print(\"任务执行结束.......\")\n\n通过重写multiprocessing.Process类创建多进程\nfrom multiprocessing import Process\nimport multiprocessing\nclass JobProcess(Process):\n    # 重写Process的构造方法， 获取新的属性\n    def __init__(self,queue):\n        super(JobProcess, self).__init__()\n        self.queue = queue\n    # 重写run方法， 将执行的任务放在里面即可\n    def run(self):\n        print(\"当前进程信息%s\" %(multiprocessing.current_process()))\n\nif __name__==\"__main__\":\n    processes = []\n    # 启动10个子进程， 来处理需要执行的任务;\n    for i in range(10):\n        #示例化类，创建进程\n        p = JobProcess(queue=3)\n        processes.append(p)\n        #启动多进程，执行任务\n        p.start()\n    #等待所有的子进程结束，再执行主进程\n    [pro.join() for pro in processes]\n    print(\"任务执行结束\")\n\n守护进程\n守护线程:\nsetDeamon:\n    True: 主线程执行结束， 子线程不再继续执行;\n    Flase:\n守护进程:\n  setDeamon:\n    True: 主进程执行结束， 子进程不再继续执行;\n    Flase:\n\nimport multiprocessing\nimport time\ndef deamon():\n    #守护进程：当主程序运行结束，子进程也结束\n    name = multiprocessing.current_process()\n    print(\"%s开始执行\" %(name))\n    time.sleep(3)\n    print(\"执行结束\")\n\nif __name__==\"__main__\":\n    p1 = multiprocessing.Process(target=deamon,name='hello')\n    p1.daemon = True\n    p1.start()\n    time.sleep(2)\n    print(\"整个程序执行结束\")\n\n终止进程\n有些进程或许再执行死循环任务，此时我们手动结束进程terminate()\nimport multiprocessing\nimport time\n\ndef job():\n    name = multiprocessing.current_process()\n    print(\"%s进程开启\" %(name))\n    time.sleep(3)\n    print(\"进程结束\")\n\nif __name__==\"__main__\":\n    p = multiprocessing.Process(target=job)\n    print(\"进程开启：\",p.is_alive())\n    p.start()\n    print(\"进程开启：\",p.is_alive())\n    p.terminate()\n    print(\"进程开启：\",p.is_alive())\n    time.sleep(0.001)\n    print(\"进程开启：\",p.is_alive())\n    print(\"程序执行结束\")\n\n\n计算密集型和I/O密集型\n计算密集型任务的特点是要进行大量的计算， 消耗CPU资源， 比如计算圆周率、 对视频进行高清解码等等， 全靠CPU的运算能力。 这种计算密集型任务虽然也可以用多任务完成， 但是任务越多， 花在任务切换的时间就越多， CPU执行任务的效率就越低， 所以， 要最高效地利用CPU， 计算密集型任务同时进行的数量应当等于CPU的核心数。计算密集型任务由于主要消耗CPU资源， 因此， 代码运行效率至关重要。 Python这样的脚本语言运行效率很低， 完全不适合计算密集型任务。 对于计算密集型任务，最好用C语言编写。\n第二种任务的类型是IO密集型， 涉及到网络、 磁盘IO的任务都是IO密集型任务， 这类任务的特点是CPU消耗很少， 任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务， 任务越多， CPU效率越高， 但也有一个限度。 常见的大部分任务都是IO密集型任务， 比如Web应用。\n多进程和多线程对比\n多进程模式最大的优点就是稳定性高， 因为一个子进程崩溃了， 不会影响主进程和其他子进程。（当然主进程挂了所有进程就全挂了， 但是Master进程只负责分配任务， 挂掉的概率低）著名的Apache最早就是采用多进程模式。\n多进程模式的缺点是创建进程的代价大， 在Unix/Linux系统下， 用 fork 调用还行， 在Windows下创建进程开销巨大。 另外， 操作系统能同时运行的进程数也是有限的， 在内存和。CPU的限制下， 如果有几千个进程同时运行， 操作系统连调度都会成问题。\n多线程模式通常比多进程快一点， 但是也快不到哪去， 而且， 多线程模式致命的缺点就是任何一个线程挂掉都可能直接造成整个进程崩溃， 因为所有线程共享进程的内存。 在Windows上， 如果一个线程执行的代码出了问题， 你经常可以看到这样的提示：“该程序执行了非法操作， 即将关闭”， 其实往往是某个线程出了问题， 但是操作系统会强制结束整个进程。这里通过一个计算密集型任务，来测试多进程和多线程的执行效率。\nimport multiprocessing\nimport threading\nfrom mytimeit import timeit\n\nclass JobProcess(multiprocessing.Process):\n    def __init__(self,li):\n        super(JobProcess, self).__init__()\n        self.li = li\n    def run(self):\n        for i in self.li:\n            sum(i)\n\n\nclass JobThread(threading.Thread):\n    def __init__(self,li):\n        super(JobThread, self).__init__()\n        self.li = li\n    def run(self):\n        for i in self.li:\n            sum(i)\n@timeit\ndef many_processs():\n    li = [[24892,23892348,239293,233],[2382394,49230,2321234],[48294,28420,29489]]*10\n    processes = []\n    for i in li :\n        p = JobProcess(li)\n        processes.append(p)\n        p.start()\n    [pro.join() for pro in processes]\n    print(\"多进程执行任务结束，✌\")\n@timeit\ndef many_thread():\n    #创建进程和销毁进程是时间的，如果li长度不够，会造成多线程快过多进程\n    li = [[24892,23892348,239293,233],[2382394,49230,2321234],[48294,28420,29489]]*1000\n    threads = []\n    for i in li :\n        t = JobThread(li)\n        threads.append(t)\n        t.start()\n    [thread.join() for thread in threads]\n    print(\"多线程执行任务结束，✌\")\nif __name__ ==\"__main__\":\n    many_processs()\n    many_thread()\n\n进程间通信-生产者消费者模型与队列\n演示了生产者和消费者的场景。生产者生产货物，然后把货物放到一个队列之类的数据结构中，生产货物所要花费的时间无法预先确定。消费者消耗生产者生产的货物的时间也是不确定的。通过队列来实现进程间的通信\nimport multiprocessing\nimport threading\nfrom multiprocessing import Queue\n\nclass Producer(multiprocessing.Process):\n    def __init__(self,queue):\n        super(Producer, self).__init__()\n        self.queue = queue\n    def run(self):\n        for i in range(13):\n            #往队列添加内容\n            self.queue.put(i)\n            print(\"生产者传递的消息为%s\" %(i))\n        return self.queue\n\nclass Consumer(multiprocessing.Process):\n    def __init__(self,queue):\n        super(Consumer, self).__init__()\n        self.queue = queue\n    def run(self):\n        #获取队列内容\n        #get会自动判断队列是否为空,如果是空， 跳出循环， 不会再去从队列获取数据;\n        while True:\n            print(\"进程获取消息为：%s\" %(self.queue.get()))\nif __name__==\"__main__\":\n    queue  = Queue(maxsize=100)\n    p = Producer(queue)\n    p.start()\n    c = Consumer(queue)\n    c.start()\n    p.join()\n    c.join(2)\n    c.terminate()   #终止进程\n    print(\"进程间通信结束，( •̀ ω •́ )y\")\n\n\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "0"}