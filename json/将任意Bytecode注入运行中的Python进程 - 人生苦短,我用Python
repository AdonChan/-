{"title": "将任意Bytecode注入运行中的Python进程 - 人生苦短,我用Python ", "index": "bytecode,进程注入,python", "content": "在调试 Python 程序的时候，一般我们只能通过以下几种方式进行调试:\n\n\n程序中已经有的日志\n在代码中插入 import pdb; pdb.set_trace()\n\n但是以上的方法也有不方便的地方，　比如对于已经在运行中的程序，　就不可能停止程序后加入 调试代码和增加新的日志．\n\n从 JAVA 的 BTrace（https://kenai.com/projects/btrace） 项目得到灵感，尝试对正在运行的 Python 进程插入代码，在程序运行到指定的函数后，自动连接远程主机进行调试\n\n首先介绍三个开源的项目，　本实验需要用到这三个项目\n\n\n\nPyasite https://github.com/lmacken/pyrasite Tools for injecting code into running Python processes\n\nByteplay https://github.com/serprex/byteplay 一个字节码维护项目，类似 java的asm/cglib\n\nRpdb-Shell https://github.com/alex8224/Rpdb-Shell\n\n\n待注入的代码, 用官方的　tornado hello demo 做例子\n\nimport tornado.ioloop\nimport tornado.web\nimport os\n\nclass MainHandler(tornado.web.RequestHandler):\n    def get(self):        \n        self.write(\"Hello, world\")        \n\napplication = tornado.web.Application([\n    (r\"/\", MainHandler),\n])\n\nif __name__ == \"__main__\":\n    application.listen(8888)\n    print(os.getpid())\n    tornado.ioloop.IOLoop.instance().start()\n\n\n注入以下代码(testinject.py)到 get 中\n\nimport sys\nimport dis\nimport inspect\nfrom byteplay import *\n\ndef wearedcode(fcode):\n    c = Code.from_code(fcode)\n    if c.code[1] == (LOAD_CONST, 'injected'):\n        return fcode\n\n    c.code[1:1] = [\n                    (LOAD_CONST, injected'), (STORE_FAST, 'name'),\n                    (LOAD_FAST, 'name'), \n                    (PRINT_ITEM, None), (PRINT_NEWLINE, None),\n                    (LOAD_CONST, -1), (LOAD_CONST, None), \n                    (IMPORT_NAME, 'rpdb'), (STORE_FAST, 'rpdb'), \n                    (LOAD_FAST, 'rpdb'), (LOAD_ATTR, 'trace_to_remote'), \n                    (LOAD_CONST, '192.168.1.1'), (CALL_FUNCTION, 1),\n                     (POP_TOP, None)\n                  ] \n\n    return c.to_code()\n\n\ndef trace(frame, event, arg):\n    if event != 'call':\n        return\n    co = frame.f_code\n    func_name = co.co_name\n\n    if func_name == \"write\":\n        return\n\n    if func_name == \"get\":\n        import tornado.web\n        args = inspect.getargvalues(frame)\n        if 'self' in args.locals:\n            if isinstance(args.locals['self'], tornado.web.RequestHandler):\n                getmethod = args.locals['self'].get\n                code = getmethod.__func__.__code__\n                getmethod.__func__.__code__ = wearedcode(code)\n        return\n\nsys.settrace(trace)\n\n\n环境\n\n\nubuntu 14.04 64bit LTS\nPython 2.7.6\n\n步骤\n\n\n在机器上安装上面需要用到的三个项目\npython server.py\n在 192.168.1.1 执行 nc -l 4444\n\npyrasite $(ps aux |grep server.py |grep -v grep|awk '{print $2}') testinject.py\n执行 curl http://localhost:8000 两次，　在第二次请求时替换的 bytecode 才会生效\n\n结果\n\n在执行上面的步骤后，　在执行第二次 curl http://127.0.0.1:8000 后，　应该能够看到控制台输入 injected 的字样，并且 nc -l 4444 监听的终端会出现 (pdb)> 的字样，　这样就能够对正在运行中的程序进行调试了．\n\n原理\n\nPyasite 可以注入代码到运行中的 Python 进程，它利用了 Python 的 PyRun_SimpleString 这个API插入代码，　至于进程注入应该是使用了 ptraceByteplay 是一个可以维护 Python bytecode的工具，　这部分跟 cglib/asm类似\n\nPyasite 只能把代码注入到进程中并运行，不能定位到具体的函数并注入 bytecode, 在 testinject.py 中结合 Byteplay 完成了函数定位和替换 get 函数字节码的功能．\n\n函数的定位用到了 sys.settrace 这个API,他提供了 call, line, return, exception事件，在合适的时机调用用户提供的函数, 具体可以参考 https://docs.python.org/2/library/sys.html#sys.settrace　的解释\n\n理论上可以插入任意字节码到程序中的任意位置，　实现对现有进程中代码的任意修改．\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "11"}