{"title": "MCMC和Gibbs Sampling算法 - 个人文章 ", "index": "python", "content": "作者：chen_h微信号 & QQ：862251340微信公众号：coderpai简书地址：https://www.jianshu.com/p/278...\n\n本文是整理网上的几篇博客和论文所得出来的，所有的原文连接都在文末。\n在科学研究中，如何生成服从某个概率分布的样本是一个重要的问题。如果样本维度很低，只有一两维，我们可以用反切法，拒绝采样和重要性采样等方法。但是对于高位样本，这些方法就不适用了。这时我们就可以使用一些“高档”的算法，比如Metropolis-Hasting算法和Gibbs Sampling算法。\nMetropolis-Hasting算法和Gibbs Sampling算法是马尔科夫链蒙特卡洛（Markov Chain Mento Carlo，MCMC）方法。\n1. 马尔科夫链蒙特卡洛（MCMC）方法\nMCMC方法是用蒙特卡洛方法去体现马尔科夫链的方法。在讲MCMC之前，必须要先讲一下马尔科夫链，马尔链的数学定义为：\n\n也就是说当前状态只和前一个状态有关，而与其他状态无关，Markov Chain 体现的是状态空间的转换关系，下一个状态只和当前状态有关。比如下图就是一个马尔科夫链的示意图：\n\n图中转换关系可以用一个概率转换矩阵 p 表示，如下：\n\n在上图中，我们假设当前状态为 u = [0.5, 0.2, 0.3]，那么下一个矩阵的状态就是 u*p = [0.18, 0.64, 0.18]，再下一个矩阵的状态就是 u*p*p = [ 0.108, 0.316, 0.576]，依照这个转换矩阵一直转换下去，最后的系统就趋近于一个稳定状态 [0.22, 0.41, 0.37]。而事实证明无论你从哪个点出发，经过很长的 Markov Chain 之后都会稳定到这一点。\n>>> u\narray([ 0.5,  0.2,  0.3])\n>>> p\narray([[ 0. ,  1. ,  0. ],\n       [ 0. ,  0.1,  0.9],\n       [ 0.6,  0.4,  0. ]])\n>>> for _ in xrange(100):\n...     u = np.dot(u,p)\n...     print u\n\n再举一个例子，社会学家经常把人按其经济状况分为3类：下层（lower-class）、中层（middle-class）、上层（upper-class）。我们用1,2,3分别代表这三个阶层。社会学家们发现决定一个人的收入阶层的最重要的因素就是其父母的结束阶层。如果一个人的收入属于下层类别，那么他的孩子属于下层收入的概率是 0.65，属于中层收入的概率是 0.28，属于上层收入的概率是 0.07。事实上，从父代到子代，收入阶层的变化的转移概率如下：\n\n\n同理，图中的转换关系可以用一个概率转换矩阵 p 表示，如下：\n\n假设当前这一代人处在下层、中层、上层的概率分布向量是：\n\n那么他们的子女的分布比例将是：\n\n他们的孙子代的分布比例将是：\n\n以此类推，第 n 代子孙的收入分布比例将是：\n\n我们举个具体的例子，假设初始概率分布为：\n\n则我们可以计算前 n 代人的分布状况如下：\n\n>>> x\narray([ 0.21,  0.68,  0.11])\n>>> p\narray([[ 0.65,  0.28,  0.07],\n       [ 0.15,  0.67,  0.18],\n       [ 0.12,  0.36,  0.52]])\n>>> for _ in xrange(10):\n...     x = np.dot(x,p)\n...     print x\n...\n[ 0.2517  0.554   0.1943]\n[ 0.270021  0.511604  0.218375]\n[ 0.27845925  0.49699556  0.22454519]\n[ 0.28249327  0.49179188  0.22571485]\n[ 0.28447519  0.48985602  0.22566879]\n[ 0.28546753  0.48909735  0.22543512]\n[ 0.28597071  0.48878278  0.22524651]\n[ 0.28622796  0.488645    0.22512704]\n[ 0.28636017  0.48858171  0.22505812]\n[ 0.28642834  0.48855152  0.22502014]\n我们发现从第7代人开始，这个分布就稳定不变了，事实上，在这个问题中，从任意初始概率分布开始都会收敛到这个稳定的结果。也就是说，收敛的行为和初始概率分布 π0 无关。这说明这个收敛行为主要是由概率转移矩阵 P 决定的。我们可以计算一下 P^n ：\n\n我们发现，当 n 足够大的时候，这个 P^n 矩阵的每一行都是稳定地收敛到 π=[0.286,0.489,0.225] 这个概率分布。自然的，这个收敛现象并非是我们这个马氏链都有的，而是绝大多数马氏链的共同行为，关于马氏链的收敛我们有如下漂亮的定理：\n\n这个马氏链的收敛定理非常重要，所有的MCMC（Markov Chain Monte Carlo）方法都是以这个定理作为理论基础的。\n对于给定的概率分布 p(x) ，我们希望能与便捷的方式生成它对应的样本。由于马氏链能收敛到平稳分布，于是一个很漂亮的想法就是：如果我们能构造一个转移矩阵为 P 的马氏链，使得该马氏链的平稳分布恰好是 p(x)，那么我们从任何一个初始状态 x(0) 出发沿着马氏链转移，得到一个转移序列 x(0)，x(1)，x(2)，...，x(n)，x(n+1)，...，如果马氏链在第 n 步已经收敛了，于是我们就得到了 π(x) 的样本 x(n)，x(n+1)，...。\n这个绝妙的想法在1953年被 Metropolis想到了，为了研究粒子系统的平稳性质， Metropolis 考虑了物理学中常见的波尔兹曼分布的采样问题，首次提出了基于马氏链的蒙特卡罗方法，即Metropolis算法，并在最早的计算机上编程实现。Metropolis 算法是首个普适的采样方法，并启发了一系列 MCMC方法，所以人们把它视为随机模拟技术腾飞的起点。 Metropolis的这篇论文被收录在《统计学中的重大突破》中， Metropolis算法也被遴选为二十世纪的十个最重要的算法之一。\n我们接下来介绍的MCMC 算法是 Metropolis 算法的一个改进变种，即常用的 Metropolis-Hastings 算法。由上一节的例子和定理我们看到了，马氏链的收敛性质主要由转移矩阵 P 决定, 所以基于马氏链做采样的关键问题是如何构造转移矩阵 P，使得平稳分布恰好是我们要的分布p(x)。如何能做到这一点呢？我们主要使用如下的定理。\n\n其实这个定理是显而易见的，因为细致平稳条件的物理含义就是对于任何两个状态 i，j， 从 i 转移出去到 j 而丢失的概率质量，恰好会被从 j 转移回ii 的概率质量补充回来，所以状态ii上的概率质量 π(i) 是稳定的，从而 π(x) 是马氏链的平稳分布。数学上的证明也很简单，由细致平稳条件可得：\n\n由于 π 是方程 πP=π 的解，所以 π 是平稳分布。\n假设我们已经有一个转移矩阵为 Q 的马氏链（q(i,j)表示从状态 i 转移到状态 j 的概率，也可以写为 q(j|i) 或者q(i→j)），显然，通常情况下：\n\n也就是细致平稳条件不成立，所以 p(x) 不太可能是这个马氏链的平稳分布。我们可否对马氏链做一个改造，使得细致平稳条件成立呢？譬如，我们引入一个 α(i,j), 我们希望：\n\n取什么样的 α(i,j) 以上等式能成立呢？最简单的，按照对称性，我们可以取：\n\n于是(*)式就成立了。所以有：\n\n于是我们把原来具有转移矩阵 Q 的一个很普通的马氏链，改造为了具有转移矩阵 Q′ 的马氏链，而 Q′ 恰好满足细致平稳条件，由此马氏链 Q′ 的平稳分布就是 p(x)！\n在改造 Q 的过程中引入的 α(i,j) 称为接受率，物理意义可以理解为在原来的马氏链上，从状态 i 以 q(i,j) 的概率转跳转到状态 j 的时候，我们以 α(i,j) 的概率接受这个转移，于是得到新的马氏链 Q′ 的转移概率为 q(i,j)α(i,j) 。\n\n假设我们已经有一个转移矩阵 Q (对应元素为 q(i,j) ), 把以上的过程整理一下，我们就得到了如下的用于采样概率分布 p(x) 的算法。\n\n上述过程中 p(x),q(x|y) 说的都是离散的情形，事实上即便这两个分布是连续的，以上算法仍然是有效，于是就得到更一般的连续概率分布 p(x)的采样算法，而 q(x|y) 就是任意一个连续二元概率分布对应的条件分布。\n以上的 MCMC 采样算法已经能很漂亮的工作了，不过它有一个小的问题：马氏链 Q 在转移的过程中的接受率 α(i,j) 可能偏小，这样采样过程中马氏链容易原地踏步，拒绝大量的跳转，这使得马氏链遍历所有的状态空间要花费太长的时间，收敛到平稳分布 p(x) 的速度太慢。有没有办法提升一些接受率呢?\n假设 α(i,j)=0.1,α(j,i)=0.2, 此时满足细致平稳条件，于是\n\n上式两边扩大5倍，我们改写为\n\n看，我们提高了接受率，而细致平稳条件并没有打破！这启发我们可以把细致平稳条件(**) 式中的 α(i,j),α(j,i) 同比例放大，使得两数中最大的一个放大到1，这样我们就提高了采样中的跳转接受率。所以我们可以取：\n\n这个公式可以进一步简化为下面的公式：\n\n于是，经过对上述MCMC 采样算法中接受率的微小改造，我们就得到了如下教科书中最常见的 Metropolis-Hastings 算法。\n\n对于分布 p(x)，我们构造转移矩阵 Q′ 使其满足细致平稳条件\n\n此处 x 并不要求是一维的，对于高维空间的 p(x)，如果满足细致平稳条件\n\n那么以上的 Metropolis-Hastings 算法一样有效。\n2. Gibbs Sampling算法\n对于高维的情形，由于接受率 α 的存在(通常 α<1), 以上 Metropolis-Hastings 算法的效率不够高。能否找到一个转移矩阵 Q 使得接受率 α=1 呢？我们先看看二维的情形，假设有一个概率分布 p(x,y), 考察 x坐标相同的两个点 A(x1,y1),B(x1,y2)，我们发现\n\n所以得到\n\n即\n\n基于以上等式，我们发现，在 x=x1 这条平行于 y 轴的直线上，如果使用条件分布 p(y|x1) 做为任何两个点之间的转移概率，那么任何两个点之间的转移满足细致平稳条件。同样的，如果我们在 y=y1y=y1 这条直线上任意取两个点 A(x1,y1),C(x2,y1)，也有如下等式\n\n\n于是我们可以如下构造平面上任意两点之间的转移概率矩阵 Q\n\n有了如上的转移矩阵 Q, 我们很容易验证对平面上任意两点 X,Y, 满足细致平稳条件\n\n于是这个二维空间上的马氏链将收敛到平稳分布 p(x,y)。而这个算法就称为 Gibbs Sampling 算法,是 Stuart Geman 和Donald Geman 这两兄弟于1984年提出来的，之所以叫做Gibbs Sampling 是因为他们研究了Gibbs random field, 这个算法在现代贝叶斯分析中占据重要位置。\n\n\nGibbs Sampling 算法中的马氏链转移\n以上采样过程中，如图所示，马氏链的转移只是轮换的沿着坐标轴 x 轴和 y 轴做转移，于是得到样本 (x0,y0),(x0,y1),(x1,y1),(x1,y2),(x2,y2),⋯ 马氏链收敛后，最终得到的样本就是 p(x,y) 的样本，而收敛之前的阶段称为 burn-in period。额外说明一下，我们看到教科书上的 Gibbs Sampling 算法大都是坐标轴轮换采样的，但是这其实是不强制要求的。最一般的情形可以是，在 t 时刻，可以在 x 轴和 y 轴之间随机的选一个坐标轴，然后按条件概率做转移，马氏链也是一样收敛的。轮换两个坐标轴只是一种方便的形式。\n以上的过程我们很容易推广到高维的情形，对于(*) 式，如果 x1 变为多维情形 x1，可以看出推导过程不变，所以细致平稳条件同样是成立的\n\n此时转移矩阵 Q 由条件分布 p(y|x1) 定义。上式只是说明了一根坐标轴的情形和二维情形类似，很容易验证对所有坐标轴都有类似的结论。所以 n 维空间中对于概率分布 p(x1,x2,⋯,xn) 可以如下定义转移矩阵\n\n如果当前状态为 (x1,x2,⋯,xn)，马氏链转移的过程中，只能沿着坐标轴做转移。沿着 xi 这根坐标轴做转移的时候，转移概率由条件概率 p(xi|x1,⋯,xi−1,xi+1,⋯,xn) 定义；\n其它无法沿着单根坐标轴进行的跳转，转移概率都设置为 0。\n\n于是我们可以把Gibbs Smapling 算法从采样二维的 p(x,y) 推广到采样 n 维的 p(x1,x2,⋯,xn)\n\n以上算法收敛后，得到的就是概率分布 p(x1,x2,⋯,xn) 的样本，当然这些样本并不独立，但是我们此处要求的是采样得到的样本符合给定的概率分布，并不要求独立。同样的，在以上算法中，坐标轴轮换采样不是必须的，可以在坐标轴轮换中引入随机性，这时候转移矩阵 Q 中任何两个点的转移概率中就会包含坐标轴选择的概率，而在通常的 Gibbs Sampling 算法中，坐标轴轮换是一个确定性的过程，也就是在给定时刻tt，在一根固定的坐标轴上转移的概率是1。\n\nReference：\nMetropolis-Hastings 和 Gibbs sampling\n随机采样方法整理与讲解（MCMC、Gibbs Sampling等）\nLDA-math-MCMC 和 Gibbs Sampling\nIntroduction to Monte Carlo Methods\nAn Introduction to MCMC for Machine Learning\n\n作者：chen_h微信号 & QQ：862251340简书地址：https://www.jianshu.com/p/278...\nCoderPai 是一个专注于算法实战的平台，从基础的算法到人工智能算法都有设计。如果你对算法实战感兴趣，请快快关注我们吧。加入AI实战微信群，AI实战QQ群，ACM算法微信群，ACM算法QQ群。长按或者扫描如下二维码，关注 “CoderPai” 微信号（coderpai）\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}