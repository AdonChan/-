{"title": "Python中的可迭代的对象、迭代器和生成器 - 个人文章 ", "index": "python", "content": "导语：本文章记录了本人在学习Python基础之控制流程篇的重点知识及个人心得，打算入门Python的朋友们可以来一起学习并交流。\n本文重点：\n1、掌握可迭代的对象的定义；2、掌握可迭代对象、迭代器与生成器之间的关系和异同；3、熟悉标准库中生成器。\n一、可迭代的对象\n可迭代的对象：使用iter内置函数可以获取迭代器的对象。如果对象实现了能返回迭代器的__iter__方法，那么对象就是可迭代的。如果没有实现__iter__而实现了__getitem__方法，并且其参数是从零开始的索引，这种对象如序列也是可迭代的。向后兼容：之所以任何Python序列可迭代是为了向后兼容。\n当解释器需要迭代对象时，会自动调用iter(x)：\n\n若对象实现了__iter__方法，获取一个迭代器；\n若对象没实现__iter__方法，但实现了__getitem__方法，Python会创建一个迭代器，尝试从索引0开始获取元素；\n若尝试失败，Python抛出TypeError。\n\n标准的序列都实现了__iter__方法，这是鸭子类型的极端形式。在白鹅类型中，只要对象实现了__iter__方法，那么它就是可迭代的对象。\n注意：（1）只有实现了__iter__方法的对象能通过子类测试issubclass(Object,abc.Iterator)（2）检查对象能否迭代最准确的方法是调用iter(x)函数，如果不可迭代再处理TypeError。因为iter(x)会考虑到实现__getitem__方法的部分可迭代对象。\n二、迭代器\n1、迭代器介绍\n迭代器：用于从集合中取出元素的对象。迭代器的功能：用于支持下列操作\n\nfor循环\n构建和扩展集合类型\n逐行遍历文本文件\n列表推导、字典推导和集合推导\n元组拆包\n调用函数时，使用 * 拆包实参\n\n迭代器的接口协议：\n\n__next__，返回下一个可用的元素。当没有元素时抛出StopIteration异常。\n__iter__，返回self，即迭代器本身。\n\n迭代器特点：\n\n\n可迭代。由于Python中的迭代器实现了__iter__方法，因此也可以迭代。\n\n易耗损。迭代器经过一次逐次取值的循环后便耗尽了。若想再次迭代须重建迭代器。\n\n迭代器检查方式：调用isinstance(object，abc.Iterator)。检查原理：归结于Iterator.__subclasshook__方法。无论对象所属的类是Iterator的真实子类还是虚拟子类，都能够检查。\n2、迭代器和可迭代对象之辨析：\n\n联系：Python从可迭代的对象中获取迭代器。\n区别：可迭代的对象不是迭代器。\n\n3、迭代器模式\n迭代器模式：按需一次获取一个数据项。扫描内存中放不下的数据集时，我们要找到一种惰性获取数据项的方式，即按需一次获取一个数据项。这就是迭代器模式（Iterator pattern） 。迭代器模式的用途：\n\n\n访问一个聚合对象的内容而无需暴露它的内部表示；\n\n支持对聚合对象的多种遍历；\n\n为遍历不同的聚合结构提供一个统一的接口（即支持多态迭代）。\n\n4、迭代器模式实例\n下面构造一个可以处理文本匹配并迭代的实例：\nimport reprlib\nimport re\n\nreword=re.compile('\\w+')\n#第一版：迭代器模式\nclass Sentence:\n    def __init__(self,text):\n        self.text=text\n        self.words=reword.findall(text)\n    def __repr__(self):\n        return \"Sentence({})\".format(reprlib.repr(self.text))\n    def __iter__(self):\n        return SentenceIterator(self.words)\nclass SentenceIterator:\n    def __init__(self,text):\n        self.words=text\n        self.index=0\n    def __next__(self):\n        try:\n            word=self.words[self.index]\n\n        except IndexError:\n            raise StopIteration()\n        self.index += 1\n        return word\n    def __iter__(self):\n        return self\ntitle=Sentence('We have a dream!')\nprint(title)\nfor i in title:\n    print(i)\n输出：\nSentence('We have a dream!')\nWe\nhave\na\ndream\n注意：（1）不要把迭代器接口应用到可迭代对象上，这是常见的反模式。（2）可迭代对象必须实现__iter__方法，但不能实现__next__方法。\n三、生成器\n1、生成器相关概念介绍\n生成器：用于按需生成元素的对象。在Python社区中大多数时候都把迭代器和生成器视作同一概念。\n生成器函数：拥有yield关键字的Python函数。生成器表达式：制造生成器的工厂，支持惰性产值。生成器工厂函数：返回生成器的函数，定义体中可以没有yield关键字。\n生成器函数与生成器表达式优点比较：\n\n生成器函数：使用重复使用的情景，也可以作为协程使用。\n生成器表达式：代码简洁易读。\n\nTips:生成器表达式作为单参数传入时无须写一对括号，而多参数时须将小括号加上。\n2、生成器函数工作原理\n实例1：通过一个问候同学的代码来了解生成器函数是如何工作的\ndef gen():\n    print(\"start\")\n    yield \"Jack\"\n    print(\"continue\")\n    yield \"Dennis\"\n    print(\"end\")\nfor i in gen():\n    print(\"Hello \",i)\n输出：\nstart\nHello  Jack\ncontinue\nHello  Dennis\nend\n原理分析：不难发现，for循环中操作的对象是生成器中的yield生成的值。原因在于，生成器是迭代器，会生成传给yield关键字的表达式的值。注意：不管有没有return语句，生成器函数都不会抛出StopIteration异常，而是在生成全部值之后直接退出。\n实例2：生成器函数改进版\nimport reprlib\nimport re\n\nreword=re.compile('\\w+')\n#第二版：生成器函数\nclass Sentence:\n    def __init__(self,text):\n        self.text=text\n        self.words=reword.findall(text)\n    def __repr__(self):\n        return \"Sentence({})\".format(reprlib.repr(self.text))\n    def __iter__(self):\n        for i in self.words:\n            yield i\n        return\ntitle=Sentence('We have a dream!')\nprint(title)\nfor i in title:\n    print(i)\n3、惰性产值：生成器表达式模式改进版\nimport reprlib\nimport re\n\nreword=re.compile('\\w+')\n#第三版：生成器表达式\nclass Sentence:\n    def __init__(self,text):\n        self.text=text\n    def __repr__(self):\n        return \"Sentence({})\".format(reprlib.repr(self.text))\n    def __iter__(self):\n        return (match.group() for match in reword.finditer(self.text))\ntitle=Sentence('We have a dream!')\nprint(title)\nfor i in title:\n    print(i)\nTips:re.finditer函数是re.findall函数的惰性版本，返回的不是列表而是一个生成器，按需惰性生成元素。\n四、标准库中有用的生成器\n1、五大类生成器\n\n用于过滤的生成器函数: itertools.takewhile/compress/dropwhile/filter/filterfalse/islice/\n用于映射的生成器函数: 内置的 enumerate/map itertools.accumulate/starmap\n用于合并的生成器函数：itertools.chain/from_iterable/product/zip_longest/ 内置的 zip\n从一个元素产生多个值，扩展输入的可迭代对象: itertools.combinations/combinations_with_replacement/count/cycle/permutations/repeat\n\n产出输入可迭代对象的全部元素，以某种方式排列：itertools.groupby/tee/ 内置的 reversed\n\n五、其它\n1、归约函数：接受可迭代对象并返回单个结果的函数。这里的all和any函数会短路，即一旦得出结果马上停止迭代。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "0"}