{"title": "【数据结构_浙江大学MOOC】第二讲 线性结构 - 个人文章 ", "index": "数据结构,python", "content": "函数题给出编译器为 C(gcc) 的解答，编程题给出编译器 C++(g++) 或 Python(python3) 的解答。\n\n函数题\n两个有序链表序列的合并\n题目\n函数接口定义：\nList Merge( List L1, List L2 );\n其中List结构定义如下：\ntypedef struct Node *PtrToNode;\nstruct Node {\n    ElementType Data; /* 存储结点数据 */\n    PtrToNode   Next; /* 指向下一个结点的指针 */\n};\ntypedef PtrToNode List; /* 定义单链表类型 */\nL1和L2是给定的带头结点的单链表，其结点存储的数据是递增有序的；函数Merge要将L1和L2合并为一个非递减的整数序列。应直接使用原序列中的结点，返回归并后的带头结点的链表头指针。\n裁判测试程序样例：\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef int ElementType;\ntypedef struct Node *PtrToNode;\nstruct Node {\n    ElementType Data;\n    PtrToNode   Next;\n};\ntypedef PtrToNode List;\n\nList Read(); /* 细节在此不表 */\nvoid Print( List L ); /* 细节在此不表；空链表将输出NULL */\n\nList Merge( List L1, List L2 );\n\nint main()\n{\n    List L1, L2, L;\n    L1 = Read();\n    L2 = Read();\n    L = Merge(L1, L2);\n    Print(L);\n    Print(L1);\n    Print(L2);\n    return 0;\n}\n\n/* 你的代码将被嵌在这里 */\n输入样例：\n3\n1 3 5\n5\n2 4 6 8 10\n\n输出样例：\n1 2 3 4 5 6 8 10 \nNULL\nNULL\n解读题目\n题目中有两句话：1、L1和L2是给定的带头结点的单链表，其结点存储的数据是递增有序的；函数Merge要将L1和L2合并为一个非递减的整数序列。\n这里也说明了我们只需要写一个函数Merge。实现思路为比较链表 L1 和 L2，然后以非递减的形式输出到一个新链表 L 上，最后返回链表 L。\n2、应直接使用原序列中的结点，返回归并后的带头结点的链表头指针。\n第二句话中的“直接使用原序列中的结点”其实是要求我们把原链表上的结点一个一个摘下来，挂到新链表上。\n实现代码\nList Merge( List L1, List L2 ){\n  List p1, p2, p3, L;\n  // 用malloc函数申请结构\n  L = (List)malloc(sizeof(struct Node));\n  p1 = L1->Next;\n  p2 = L2->Next;\n  p3 = L;\n  // 通过循环来遍历一遍，比较L1和L2，将值小的依次加到p3\n  // 循环条件为 P1!=NULL && p2!=NULL\n  while(p1 && p2){\n    if(p1->Data <= p2->Data){\n      //把结果拷贝过去\n      p3->Next = p1;\n      p3 = p1;\n      // p1指针向后移一位\n      p1 = p1->Next;\n    }else{\n      p3->Next = p2;\n      p3 = p2;\n      p2 = p2->Next;\n    }\n  }\n  //将未处理完的另一个链表的结点复制过去\n  p3->Next = p1? p1 : p2;\n  L1->Next = NULL;\n  L2->Next = NULL;\n  return L;\n}\n提交结果\n\n编程题\n一元多项式的乘法与加法运算\n题目\n设计函数分别求两个一元多项式的乘积与和。\n输入格式:输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。\n输出格式:输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出0 0。\n输入样例:\n4 3 4 -5 2  6 1  -2 0\n3 5 20  -7 4  3 1\n输出样例:\n15 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 1\n5 20 -4 4 -5 2 9 1 -2 0\n解读题目\n首先我们看输入样例，其实表示了两个多项式。第一个多项式非零项有 4 项：$3x^4-5x^2+6x-2$，第二哥多项式非零项有 3 项：$5x^{20}-7x^4+3x$。\n要求分别计算两个多项式的乘积与和，输出第一项为乘积的系数和指数，第二行为和的系数和指数。\n求解思路从以下几个方面考虑：\n多项式表示\n表示多项式的关键信息，即非零项。有两种表示方法：数组和链表。根据它们二者的特点，在这道题里项数是已知的，有一种比较好的实现方法叫动态数组。\n选定了表示方法后，考虑数据结构设计。\n选择链表在设计数据结构的时候有系数、指数、和指针（结构指针）。\n程序框架\n程序框架搭建的大致流程如下：\nint main(){\n    读入多项式1\n    读入多项式2\n    乘法运算并输出\n    加法运算并输出\n    \n    return 0;\n}\n实现以下四步：\n\n读一个多项式\n两个多项式相乘\n两个多项式相加\n多项式输出\n\n实现代码\nC++ 版本\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define Max_Expon 1001\n#define Max_Mul_Expon 1000001\n\nint main(int argc, const char * argv[])\n{\n    //输入\n    vector<int > Polynomial_1(Max_Expon, 0);\n    vector<int > Polynomial_2(Max_Expon, 0);\n    int coef = 0;\n    int expon = 0;\n    int num = 0;\n\n    cin>>num;\n    for(int i=0; i<num; ++i)\n    {\n        cin>>coef>>expon;\n        Polynomial_1[expon] = coef;\n    }\n\n    cin>>num;\n    for (int i=0; i<num; ++i)\n    {\n        cin>>coef>>expon;\n        Polynomial_2[expon]=coef;\n    }\n\n    //进行计算\n    vector<int> Polynomial_Result_Mul(Max_Mul_Expon,0);\n    vector<int> Polynomial_Result_Add(Max_Expon,0);\n\n    for (int i=0; i<Polynomial_1.size(); ++i)\n    {\n        for (int k=0;k<Polynomial_2.size(); ++k)\n        {\n            Polynomial_Result_Mul[i+k]+=Polynomial_1[i]*Polynomial_2[k];\n        }\n    }\n\n    for (int i=0; i<Max_Expon; ++i)\n    {\n        Polynomial_Result_Add[i]=Polynomial_1[i]+Polynomial_2[i];\n    }\n\n    //输出\n    int flag_1=0,flag_2=0;\n    for (int i=Max_Mul_Expon-1; i>=0; i--)\n    {\n        if (Polynomial_Result_Mul[i]!=0)\n        {\n            if (flag_1==0)\n            {\n                flag_1=1;\n                cout<<Polynomial_Result_Mul[i]<<' '<<i;\n            } else\n            {\n                cout<<' '<<Polynomial_Result_Mul[i]<<' '<<i;\n            }\n        }\n    }\n\n    if(flag_1==0)\n    {\n        cout<<\"0 0\";\n    }\n    cout<<endl;\n\n    for (int i = Max_Expon-1; i >=0; i--)\n    {\n        if(Polynomial_Result_Add[i]!=0)\n        {\n            if(flag_2==0)\n            {\n                flag_2=1;\n                cout<<Polynomial_Result_Add[i]<<''<<i;\n            }else\n            {\n                cout<<' '<<Polynomial_Result_Add[i]<<' '<<i;\n            }\n        }\n    }\n\n    if(flag_2==0)\n    {\n        cout<<\"0 0\";\n    }\n\n    return 0;\n    \n}\n\n提交结果：\n\nPython3 版本\np= {}\n\ndef mysplit(s, split = ' '):\n    l = []\n    for i in s:\n        if i == split:\n            num = s[ : s.index(i)]\n            if len(num) != 0:\n                l.append(num)\n            s = s[s.index(i)+1 : ]\n            \n    l.append(s)         \n    return l\n\n# 输入\nfor i in range(2):\n    s = input()\n    l = mysplit(s)\n    n = int(l.pop(0))\n    p[i+1] = {}\n    for j in range(n):\n        p[i+1][int(l[j*2+1])] =int(l[j*2])\n\n# 多项式相乘\np['*'] = {}\nfor i in p[1]:\n    for j in p[2]:\n        if p['*'].get(i+j):\n            p['*'][i+j] += p[1][i] * p[2][j]\n        else:\n            p['*'][i+j] = p[1][i] * p[2][j]\n\n# 多项式相加\np['+'] ={}\np['+'] = p[1]\nfor j in p[2]:\n    if p['+'].get(j):\n        p['+'][j] += p[2][j]\n    else:\n        p['+'][j] = p[2][j]\n\n# 处理多项式为空的情况\ndef zero(p):\n    for i in p:\n        if p[i] != 0:\n            return\n    p.clear()\n    p[0] = 0\n\nzero(p['*'])\nzero(p['+'])\n\n# 输出\ndef pprint(p):\n    for i in sorted(p, reverse = True):\n        e = ' '\n        if(i  == sorted(p, reverse = True)[-1]):\n            e = ''\n\n        print(p[i], i, end = e)\n\npprint(p['*'])\nprint('')\npprint(p['+'])\n\n\n\n提交结果\n\n\n参考链接：\n视频编程作业-两个有序列表的合并两个有序链表序列的合并（15 分）02-线性结构1 一元多项式的乘法与加法运算 (20分)一元多项式的乘法与加法运算（20 分）数据结构2.1-一元多项式的乘法与加法运算\n不足之处，欢迎指正。\n$$$$\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "1"}