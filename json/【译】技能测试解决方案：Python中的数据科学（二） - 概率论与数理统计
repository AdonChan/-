{"title": "【译】技能测试解决方案：Python中的数据科学（二） - 概率论与数理统计 ", "index": "python", "content": "本文是译文，可以转载，但需注明出处，点击这里可以获取原文，有删减。  本系列博文包含四篇文章：【译】技能测试解决方案：Python中的数据科学（一）——Q1-Q15  【译】技能测试解决方案：Python中的数据科学（二）——Q16-Q30【译】技能测试解决方案：Python中的数据科学（三）——Q31-Q45【译】技能测试解决方案：Python中的数据科学（四）——A1-A45及其解释\nQ16在上述数据集中， “Cabin”变量5个样本中就有3个是缺失值，如果某个变量含有较高比例的缺失值，我们可以删除该类变量，但这样做又会损失一定的信息量。比较折中的解决方案是，另外建立二分类变量 “Missing_Cabin”，当“Cabin”变量为缺失值时，该变量取值1，否则取值0。下列哪行代码可以实现这个需求？\nA - train['Missing_Cabin'] = train.Cabin.apply(lambda x: x == '')\nB - train['Missing_Cabin'] = train.Cabin.isnull() == False\nC - train['Missing_Cabin'] = train.Cabin.isnull().astype(int)\nD - 以上选项都不能\nQ17\n上述数据集是出口产品的属性数据，但是在原始数据中，没有列名。我们怎样读入包含指定列名的数据框的数据集？\nA - pd.read_csv(\"train.csv\", header=None, columns=['Item_Identifier', 'Item_Weight', 'Item_Fat_Content', 'Item_Visibility' ])\nB - pd.read_csv(\"train.csv\", header=None, usecols=['Item_Identifier', 'Item_Weight', 'Item_Fat_Content', 'Item_Visibility'])\nC - pd.read_csv(\"train.csv\", header=None, names=['Item_Identifier' ,'Item_Weight' ,'Item_Fat_Content', 'Item_Visibility'])\nD - 以上选项都不能    \nQ18当我们使用pandas读入数据集时，变量的类型可能解析得不对。为此，我们需要在读入数据集时，指定每个变量的数据类型，或者读入数据集后，转换指定变量的数据类型。下列哪行代码可以把“Item_Fat_Content” 变量由“object”类型改变成“category”类型？\nA - train['Item_Fat_Content'] = train['Item_Fat_Content'].asdtype('categorical')\nB - train['Item_Fat_Content'] = train['Item_Fat_Content'].astype('category')\nC - train['Item_Fat_Content'] = train['Item_Fat_Content'].asdtype('category')\nD - 以上选项都不能 \nQ19\n上述数据集中， “Item_Identifier”变量似乎和“Item_Type”变量存在一些关系：当“Item_Identifier”变量首字母发生变化时， “Item_Type” 变量随即也发生变化。当“Item_Identifier”变量以字母“F”开头时，对应的“Item_Type” 变量取值都是可以吃的物品，而“D”则对应的是饮料。为了检验这个假设，下列哪行代码可以查询出所有“Item_Identifier” 变量以“F”开头的样本？\nA - train.Item_Identifier.str.starts_with('F')\nB - train.Item_Identifier.str.startswith('F')\nC - train.Item_Identifier.str.is_start('F')\nD - 以上选项都不能 \nQ20下列哪行代码可以把 “Item_MRP”变量由“浮点型”改变成“整型”？\nA - train['Item_MRP'] = train.Item_MRP.astype(real)\nB - train['Item_MRP'] = train.Item_MRP.astype(int)\nC - train['Item_MRP'] = train.Item_MRP.astype(float)\nD - 以上选项都不能\nQ21\n我们现在还有另外一个假设：在超市里，对于新顾客而言，一个物品越容易看到，它的销量就会越好。下列哪行代码可以计算 “Item_Outlet_Sales”变量和 “Item_Visibility”变量之间的皮尔逊相关系数？\nA - train.Item_Visibility.corr(train.Item_Outlet_Sales, method='pearson')\nB - train.Item_Visibility.corr(train.Item_Outlet_Sales)\nC - train.Item_Visibility.corrwith(train.Item_Outlet_Sales, method='pearson')\nD - A和B都可以\nQ22我们想查看“Hours.Per.Week”变量相对于用户的“Marital.Status”变量和“Occupation”变量的分布。一种方案是创建“Marital.Status”变量vs“Occupation”变量的数据透视表，并求“Hours.Per.Week”变量的值。下列哪行代码可以实现这个需求？（聚合函数设定为“Sum”）\nA - train.pivot(index='Marital.Status', columns='Occupation', values='Hours.Per.Week', aggfunc='sum')\nB - train.pivot_table(index='Marital.Status', columns='Occupation', values='Hours.Per.Week', aggfunc='sum')\nC - train.pivot_table(index='Marital.Status', columns='Hours.Per.Week', values='Occupation', aggfunc='sum')\nD - 以上选项都不能\nQ23上述数据集中，假设前两行都不是我们想要的，我们想从第三行开始读入数据，在pandas 中如何操作？\nA - train = pd.read_csv('train.csv', startrow=2)\nB - train = pd.csvReader('train.csv', startrow=2)\nC - train = pd.read_csv('train.csv', skiprows=2)\nD - 以上选项都不能\nQ24假设数据集太大而不能加载到本地机器中，但是我们仍然想把它加载到内存中。一种解决办法是加载指定数目的行数到内存中。下列哪行代码可以只读取前500行数据到内存中？\nA - train = pd.read_csv('train.csv', nrows=500)\nB - train = pd.read_csv('train.csv', numrows=500)\nC - train = pd.read_csv('train.csv', rows=500)\nD - 以上选项都不能\nQ25\n我们现在想要知道“Relationship”变量在数据集中的分布。 为此，我们可以发现用户数与“Relationship”变量的百分比分布。要做到这一点，需要找到“Relationship”变量所有取值的样本量，然后将其除以总样本数，得到百分比并将其映射到每一列即可。下列哪行代码可以实现这个需求？\nA - train['Relationship_Percentage'] = train.Relationship.map(train.Relationship.value_count/train.shape[0])\nB - train['Relationship_Percentage'] = train.Relationship.map(train.Relationship.value_counts()/train.shape[0])\nC - train['Relationship_Percentage'] = train.Relationship.map(train.Relationship.value_counts/train.shape[0])\nD - 以上选项都不能\nQ26\n上述数据集中，“Date_time_of_event”变量被解析成“分类型”变量，因此，一些有关日期的操作不能作用于该变量。下列哪行代码可以把 “Date_time_of_event”变量由“分类型”变量转换成“时间型”变量？\nA - train['Date_time_of_event'] = pd.to_datetime(train.Date_time_of_event, date_format=\"%d-%m-%Y\")\nB - train['Date_time_of_event'] = pd.to_datetime(train.Date_time_of_event, format=\"%d-%m-%Y %H:%M\")\nC - train['Date_time_of_event'] = pd.to_datetime(train.Date_time_of_event, date_format=\"%d-%m-%Y %h:%m\")\nD - 以上选项都不能\nQ27\n上述数据集中，我们想根据“Date_time_of_event” 变量衍生出 “Date”变量，下列哪行代码可以提取出“Date_time_of_event” 变量中的日期？\nA - train.Date_time_of_event.dt.days\nB - train.Date_time_of_event.dt.day\nC - train.Date_time_of_event.dt.Day\nD - 以上选项都不能\nQ28下列哪行代码可以提取“Date_time_of_event” 变量中的工作日？\nA - train.Date_time_of_event.dt.weekdayname\nB - train.Date_time_of_event.dt.weekday_name\nC - train.Date_time_of_event.dt.Weekday_name\nD - 以上选项都不能\nQ29\n“时间型”变量可能被解析成unix格式，在抽取有用信息之前，我们必须把它转换成可用的格式，下列哪行代码可以实现？\nA - pd.to_datetime(train['TIMESTAMP'],unit='s')\nB - pd.to_datetime(train['TIMESTAMP'],unit='second')\nC - pd.to_datetime(train['TIMESTAMP'],unit='unix')\nD - 以上选项都不能\nQ30下列哪行代码可以找出“现在”与 ‘Date_time_of_event’变量之间的时间差？\nA - pd.datetime.now - train.Date_time_of_event.dt\nB - pd.datetime.now() - train.Date_time_of_event.dt\nC - pd.datetime.now() - train.Date_time_of_event\nD - 以上选项都不能\n友情链接：【译】技能测试解决方案：Python中的数据科学（一）——Q1-Q15【译】技能测试解决方案：Python中的数据科学（三）——Q31-Q45【译】技能测试解决方案：Python中的数据科学（四）——A1-A45及其解释\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}