{"title": "Python locals() 的陷阱 - 技术栈大杂烩 ", "index": "python", "content": "在工作中, 有时候会遇到一种情况: 动态地进行变量赋值, 不管是局部变量还是全局变量, 在我们绞尽脑汁的时候, Python已经为我们解决了这个问题.\nPython的命名空间通过一种字典的形式来体现, 而具体到函数也就是locals() 和 globals(), 分别对应着局部命名空间和全局命名空间. 于是, 我们也就能通过这些方法去实现我们\"动态赋值\"的需求.\n例如:\ndef test():\n    globals()['a2'] = 4\ntest()\nprint a2   # 输出 4\n很自然, 既然 globals能改变全局命名空间, 那理所当然locals应该也能修改局部命名空间.修改函数内的局部变量. \n但事实真是如此吗? 不是!\ndef aaaa():\n    print locals()\n    for i in ['a', 'b', 'c']:\n        locals()[i] = 1\n    print locals()\n    print a\naaaa()\n输出:\n{}\n{'i': 'c', 'a': 1, 'c': 1, 'b': 1}\nTraceback (most recent call last):\n  File \"5.py\", line 17, in <module>\n    aaaa()\n  File \"5.py\", line 16, in aaaa\n    print a\nNameError: global name 'a' is not defined\n程序运行报错了! \n但是在第二次print locals()很清楚能够看到, 局部空间是已经有那些变量了, 其中也有变量a并且值也为1, 但是为什么到了print a却报出NameError异常?\n再看一个例子:\ndef aaaa():\n    print locals()\n    s = 'test'                    # 加入显示赋值 s       \n    for i in ['a', 'b', 'c']:\n        locals()[i] = 1\n    print locals()\n    print s                       # 打印局部变量 s \n    print a\naaaa()\n输出:\n{}\n{'i': 'c', 'a': 1, 's': 'test', 'b': 1, 'c': 1}\ntest\nTraceback (most recent call last):\n  File \"5.py\", line 19, in <module>\n    aaaa()\n  File \"5.py\", line 18, in aaaa\n    print a\nNameError: global name 'a' is not defined\n上下两段代码, 区别就是, 下面的有显示赋值的代码, 虽然也是同样触发了NameError异常, 但是局部变量s的值被打印了出来.\n这就让我们觉得很纳闷, 难道通过locals()改变局部变量, 和直接赋值有不同? 想解决这个问题, 只能去看程序运行的真相了, 又得上大杀器dis~\n根源探讨\n直接对第二段代码解析:\n13           0 LOAD_GLOBAL              0 (locals)\n              3 CALL_FUNCTION            0\n              6 PRINT_ITEM\n              7 PRINT_NEWLINE\n\n 14           8 LOAD_CONST               1 ('test')\n             11 STORE_FAST               0 (s)\n\n 15          14 SETUP_LOOP              36 (to 53)\n             17 LOAD_CONST               2 ('a')\n             20 LOAD_CONST               3 ('b')\n             23 LOAD_CONST               4 ('c')\n             26 BUILD_LIST               3\n             29 GET_ITER\n        >>   30 FOR_ITER                19 (to 52)\n             33 STORE_FAST               1 (i)\n\n 16          36 LOAD_CONST               5 (1)\n             39 LOAD_GLOBAL              0 (locals)\n             42 CALL_FUNCTION            0\n             45 LOAD_FAST                1 (i)\n             48 STORE_SUBSCR\n             49 JUMP_ABSOLUTE           30\n        >>   52 POP_BLOCK\n\n 17     >>   53 LOAD_GLOBAL              0 (locals)\n             56 CALL_FUNCTION            0\n             59 PRINT_ITEM\n             60 PRINT_NEWLINE\n\n 18          61 LOAD_FAST                0 (s)\n             64 PRINT_ITEM\n             65 PRINT_NEWLINE\n\n 19          66 LOAD_GLOBAL              1 (a)\n             69 PRINT_ITEM\n             70 PRINT_NEWLINE\n             71 LOAD_CONST               0 (None)\n             74 RETURN_VALUE\nNone\n在上面的字节码可以看到:\n\n\nlocals()    对应的字节码是: LOAD_GLOBAL\n\n\ns='test'  对应的字节码是: LOAD_CONST 和 STORE_FAST\n\n\nprint s   对应的字节码是: LOAD_FAST\n\n\nprint a 对应的字节码是: LOAD_GLOBAL\n\n\n从上面罗列出来的几个关键语句的字节码可以看出, 直接赋值/读取 和 通过locals()赋值/读取 本质是很大不同的. 那么触发NameError异常, 是否证明通过 locals()[i] = 1 存储的值, 和真正的局部命名空间 是不同的两个位置?\n想要回答这个问题, 我们得先确定一个东西, 就是真正的局部命名空间如何获取? 其实这个问题, 在上面的字节码上, 已经给出了标准答案了! \n真正的局部命名空间, 其实是存在 STORE_FAST 这个对应的数据结构里面. 这个是什么鬼, 这个需要源码来解答:\n// ceval.c  从上往下, 依次是相应函数或者变量的定义\n// 指令源码\nTARGET(STORE_FAST)\n{\n    v = POP();\n    SETLOCAL(oparg, v);\n    FAST_DISPATCH();\n}\n--------------------\n// SETLOCAL 宏定义      \n#define SETLOCAL(i, value)      do { PyObject *tmp = GETLOCAL(i); \\\n                                     GETLOCAL(i) = value; \\\n                                     Py_XDECREF(tmp); } while (0)\n-------------------- \n// GETLOCAL 宏定义                                    \n#define GETLOCAL(i)     (fastlocals[i])     \n\n-------------------- \n// fastlocals 真面目\nPyObject * PyEval_EvalFrameEx(PyFrameObject *f, int throwflag){\n    // 省略其他无关代码\n   fastlocals = f->f_localsplus;\n....\n}\n                            \n看到这里, 应该就能明确了, 函数内部的局部命名空间, 实际是就是帧对象的f的成员f_localsplus, 这是一个数组, 了解函数创建的童鞋可能会比较清楚, 在CALL_FUNCTION时, 会对这个数组进行初始化, 将形参赋值什么都会按序塞进去, 在字节码 18          61 LOAD_FAST                0 (s)中, 第四列的0, 就是将f_localsplus第 0 个成员取出来, 也就是值 \"s\".\n所以STORE_FAST才是真正的将变量存入局部命名空间, 那locals()又是什么鬼? 为什么看起来就跟真的一样?\n这个就需要分析locals, 对于这个, 字节码可能起不了作用, 直接去看内置函数如何定义的吧:\n// bltinmodule.c\nstatic PyMethodDef builtin_methods[] = {\n    ...\n    // 找到 locals 函数对应的内置函数是 builtin_locals \n    {\"locals\",          (PyCFunction)builtin_locals,     METH_NOARGS, locals_doc},\n    ...\n}\n\n-----------------------------\n\n// builtin_locals 的定义\nstatic PyObject *\nbuiltin_locals(PyObject *self)\n{\n    PyObject *d;\n\n    d = PyEval_GetLocals();\n    Py_XINCREF(d);\n    return d;\n}\n-----------------------------\n\nPyObject *\nPyEval_GetLocals(void)\n{\n    PyFrameObject *current_frame = PyEval_GetFrame();  // 获取当前堆栈对象\n    if (current_frame == NULL)\n        return NULL;\n    PyFrame_FastToLocals(current_frame); // 初始化和填充 f_locals\n    return current_frame->f_locals;\n}\n-----------------------------\n\n// 初始化和填充 f_locals 的具体实现\nvoid\nPyFrame_FastToLocals(PyFrameObject *f)\n{\n    /* Merge fast locals into f->f_locals */\n    PyObject *locals, *map;\n    PyObject **fast;\n    PyObject *error_type, *error_value, *error_traceback;\n    PyCodeObject *co;\n    Py_ssize_t j;\n    int ncells, nfreevars;\n    if (f == NULL)\n        return;\n    locals = f->f_locals;\n    \n    // 如果locals为空, 就新建一个字典对象\n    if (locals == NULL) {\n        locals = f->f_locals = PyDict_New();  \n        if (locals == NULL) {\n            PyErr_Clear(); /* Can't report it :-( */\n            return;\n        }\n    }\n    \n    co = f->f_code;\n    map = co->co_varnames;\n    if (!PyTuple_Check(map))\n        return;\n    PyErr_Fetch(&error_type, &error_value, &error_traceback);\n    fast = f->f_localsplus;\n    j = PyTuple_GET_SIZE(map);\n    if (j > co->co_nlocals)\n        j = co->co_nlocals;\n        \n    // 将 f_localsplus 写入 locals\n    if (co->co_nlocals)\n        map_to_dict(map, j, locals, fast, 0);\n    ncells = PyTuple_GET_SIZE(co->co_cellvars);\n    nfreevars = PyTuple_GET_SIZE(co->co_freevars);\n    if (ncells || nfreevars) {\n        // 将 co_cellvars 写入 locals\n        map_to_dict(co->co_cellvars, ncells,\n                    locals, fast + co->co_nlocals, 1);\n                    \n        if (co->co_flags & CO_OPTIMIZED) {\n            // 将 co_freevars 写入 locals\n            map_to_dict(co->co_freevars, nfreevars,\n                        locals, fast + co->co_nlocals + ncells, 1);\n        }\n    }\n    PyErr_Restore(error_type, error_value, error_traceback);\n}\n\n从上面PyFrame_FastToLocals已经看出来, locals() 实际上做了下面几件事:\n\n判断帧对象 的 f_f->f_locals 是否为空, 若是, 则新建一个字典对象.\n分别将 localsplus, co_cellvars 和 co_freevars 写入 f_f->f_locals.\n\n在这简单介绍下上面几个分别是什么鬼:\n\n\nlocalsplus: 函数参数(位置参数+关键字参数), 显示赋值的变量.\n\nco_cellvars 和 co_freevars: 闭包函数会用到的局部变量.\n\n结论\n通过上面的源码, 我们已经很明确知道locals() 看到的, 的确是函数的局部命名空间的内容, 但是它本身不能代表局部命名空间, 这就好像一个代理, 它收集了A, B, C的东西, 展示给我看, 但是我却不能简单的通过改变这个代理, 来改变A, B, C真正拥有的东西!\n这也就是为什么, 当我们通过locals()[i] = 1的方式去动态赋值时, print a却触发了NameError异常, 而相反的, globals()确实真正的全局命名空间, 所以一般会说\nlocals() 只读,    globals() 可读可写\n欢迎各位大神指点交流, QQ讨论群: 258498217 转载请注明来源: https://segmentfault.com/a/11...\n\n                ", "mainLikeNum": ["8 "], "mainBookmarkNum": "3"}