{"title": "二叉树查找 - 易水禾 ", "index": "二叉树,算法,python", "content": "问题\n\n二叉树查找\n\n思路说明\n\n二叉树查找是一个面对动态数据比较常用的查找算法。本文根据下面地址文章翻译，并根据本人的理解进行适当修改。\n\n这里看原文\n\n二叉树查找的定义\n\n定义内容可以参阅Wikipedia词条\n\n这里是中文的内容\n\n摘要其中对二叉树的描述：\n\n\n  \n    二叉树查找的性质：\n  \n\n\n\n  \n    \n若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；\n    任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；\n    任意节点的左、右子树也分别为二叉查找树。\n    没有键值相等的节点（no duplicate nodes）。\n    \n\n\n\n\n  \n    二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为O(log n)。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、multiset、关联数组等。\n  \n\n\n\n  \n    虽然二叉查找树的最坏效率是O(n),但它支持动态查询,且有很多改进版的二叉查找树可以使树高为O(logn),如SBT,AVL,红黑树等.\n  \n\n\n用python实现二叉树查找\n\n以下面图示的二叉树为例说明查找算法\n\n\n\nNode 类\n\n创建一个类，命名为Node，做为二叉树节点结构，其中包括：左枝、右枝、节点数据三个变量。\n\nclass Node:\n    \"\"\"\n    二叉树左右枝\n    \"\"\"\n    def __init__(self, data):\n        \"\"\"\n        节点结构\n\n        \"\"\"\n        self.left = None\n        self.right = None\n        self.data = data\n\n\n例如创建一个含整数8的节点。因为仅仅创建一个节点，所以左右枝都是None。\n\nroot = Node(8)\n\n\n这样就得到如下图所示的只有一个节点的树。\n\n\n\n插入方法\n\n现在已经有了一棵光秃秃的树，要有枝杈和叶子，就必须用插入数据方法，添加新的节点和数据。\n\ndef insert(self, data):\n    \"\"\"\n    插入节点数据\n    \"\"\"\n    if data < self.data:\n        if self.left is None:\n            self.left = Node(data)\n        else:\n            self.left.insert(data)\n    elif data > self.data:\n        if self.right is None:\n            self.right = Node(data)\n        else:\n            self.right.insert(data)\n\n\n承接前面的操作，可以用下面的方式增加树的枝杈和叶子（左右枝以及节点数据）。\n\nroot.insert(3)\nroot.insert(10)\nroot.insert(1)\n\n\n当增加了第二个节点数据3,程序会：\n\n\n第一步，root会调用insert()，其参数是data=3\n第二步，比较3和8（已有的根节点），3比8小。并且树的左枝还是None，于是就在左边建立一个新的节点。\n\n增加第三个节点数据10,程序会：\n\n\n第一步，跟前面的第一步一样，只不过data=10\n第二步，发现10大于8,同时右边是None,于是就把它做为右边新建分支的节点数据。\n\n增加第四个节点数据1,程序会：\n\n\n第一步，同前，data=1\n第二步，1小于8,所以要放在树的左枝；\n第三步，左枝已经有子节点3,该节点再次调用insert()方法，1小于3,所以1就做为3的子节点，且放在原本就是None的左侧。\n\n如此，就形成了下图的树\n\n\n\n继续增加节点数据\n\nroot.insert(6)\nroot.insert(4)\nroot.insert(7)\nroot.insert(14)\nroot.insert(13)\n\n\n最终形成下图的树\n\n\n\n遍历树\n\n此方法用于查找树中的某个节点，如果找到了，就返回该节点，否则返回None。为了方便，也返回父节点。\n\ndef lookup(self, data, parent=None):\n    \"\"\"\n    遍历二叉树\n    \"\"\"\n    if data < self.data:\n        if self.left is None:\n            return None, None\n        return self.left.lookup(data, self)\n    elif data > self.data:\n        if self.right is None:\n            return None, None\n        return self.right.lookup(data, self)\n    else:\n        return self, parent\n\n\n测试一下，找一找数据为6的节点\n\nnode, parent = root.lookup(6)\n\n\n调用lookup()后，程序会这么干：\n\n\n调用lookup()，传递参数data=6,默认parent=None\ndata=6，小于根节点的值8\n指针转到根节点左侧，此时:data=6,parent=8,再次调用lookup()\ndata=6大于左侧第一层节点数据3\n指针转到3的右侧分支，data=6,parent=3,再次调用lookup()\n节点数据等于6,于是返回这个节点和它的父节点3\n\n删除方法\n\n删除节点数据。代码如下：\n\ndef delete(self, data):\n    \"\"\"\n    删除节点\n    \"\"\"\n    node, parent = self.lookup(data)        #已有节点\n    if node is not None:\n        children_count = node.children_count()      #判断子节点数\n        if children_count == 0:\n            # 如果该节点下没有子节点，即可删除\n            if parent.left is node:\n                parent.left = None\n            else:\n                parent.right = None\n            del node\n        elif children_count == 1:\n            # 如果有一个子节点，则让子节点上移替换该节点（该节点消失)\n            if node.left:\n                n = node.left\n            else:\n                n = node.right\n            if parent:\n                if parent.left is node:\n                    parent.left = n\n                else:\n                    parent.right = n\n            del node\n        else:\n            # 如果有两个子节点，则要判断节点下所有叶子\n            parent = node\n            successor = node.right\n            while successor.left:\n                parent = successor\n                successor = successor.left\n            node.data = successor.data\n            if parent.left == successor:\n                parent.left = successor.right\n            else:\n                parent.right = successor.right\n\n\n在上述方法中，得到当前节点下的子节点数目后，需要进行三种情况的判断\n\n\n如果没有子节点，直接删除\n如果有一个子节点，要将下一个子节点上移到当前节点，即替换之\n如果有两个子节点，要对自己点的数据进行判断，并从新安排节点排序\n\n上述方法中用到了统计子节点数目的方法，代码如下：\n\ndef children_count(self):\n    \"\"\"\n    子节点个数\n    \"\"\"\n    cnt = 0\n    if self.left:\n        cnt += 1\n    if self.right:\n        cnt += 1\n    return cnt\n\n\n例1：删除数据为1的节点，它是3的子节点，1后面没有子节点\n\nroot.delete(1)\n\n\n\n\n例2：删除数据为14的节点，它是10的子节点，它下面有唯一一个子节点13,13替换之。\n\nroot.delete(14)\n\n\n\n\n例3：来个复杂的，删除节点数据为3的节点，它下面有两个节点，而节点6下面又有两个4,7。需要一个临时变量successor，将节点3下面的子节点进行查询，并把小于3下面的第一级子节点6左测节点数据4（该数据一定小于其父节点6）替换当前节点3，维持二叉树结构。如下图：\n\nroot.delete(3)\n\n\n\n\n比较两个二叉树\n\n比较两个二叉树的方法中，只要有一个节点（叶子）与另外一个树的不同，就返回False，也包括缺少对应叶子的情况。\n\ndef compare_trees(self, node):\n    \"\"\"\n    比较两棵树\n    \"\"\"\n    if node is None:\n        return False\n    if self.data != node.data:\n        return False\n    res = True\n    if self.left is None:\n        if node.left:\n            return False\n    else:\n        res = self.left.compare_trees(node.left)\n    if res is False:\n        return False\n    if self.right is None:\n        if node.right:\n            return False\n    else:\n        res = self.right.compare_trees(node.right)\n    return res\n\n\n例如，比较tree(3,8,10)和tree(3,8,11)\n\n#root2 是tree(3,8,11)的根\n#root 是tree(3,8,10)的根\nroot.compare_trees(root2)\n\n\n执行上面的代码，程序会这么走：\n\n\nroot调用compare_trees()方法\nroot有左侧子节点，调用该节点的compare_trees()\n两个左侧子节点比较，返回true\n按照前面的过程，比较右侧节点，发现不同，则返回False\n\n打印树\n\n把二叉树按照一定的顺序打印出来。不需要参数了。做法就是先左后右（左小于右）。\n\ndef print_tree(self):\n    \"\"\"\n    按顺序打印数的内容\n    \"\"\"\n    if self.left:\n        self.left.print_tree()\n    print self.data,\n    if self.right:\n        self.right.print_tree()\n\n\n操作一下：\n\nroot.print_tree()\n\n\n输出： 1, 3, 4, 6, 7, 8, 10, 13, 14\n\n包含所有树元素的生成器\n\n创建一个包含所有树元素的生成器，有时候是有必要的。考虑到内存问题，没有必要实时生成所有节点数据列表，而是要每次调用此方法时，它返回的下一个节点的值。为此，使用它返回一个对象，并停止在那里，那么该函数将在下一次调用方法时从那里继续通过yield关键字返回值。在这种情况下，要使用堆栈，不能使用递归。\n\ndef tree_data(self):\n    \"\"\"\n    二叉树数据结构\n    \"\"\"\n    stack = []\n    node = self\n    while stack or node: \n        if node:\n            stack.append(node)\n            node = node.left\n        else: \n            node = stack.pop()\n            yield node.data\n            node = node.right\n\n\n举例，通过循环得到树：\n\nfor data in root.tree_data():\n    print data\n\n\n\n\n程序会按照先左后右边的原子将数据入栈、出栈，顺序取出值，并返回结果\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "4"}