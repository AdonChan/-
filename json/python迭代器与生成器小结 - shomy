{"title": "python迭代器与生成器小结 - shomy ", "index": "iterable,generator,iterator,python", "content": "\n2016.3.10关于例子解释的补充更新\n源自我的博客\n\n例子\n老规矩，先上一个代码：\ndef add(s, x):\n    return s + x\n\ndef gen():\n    for  i in range(4):\n        yield i\n\nbase = gen()\nfor n in [1, 10]:\n    base = (add(i, n) for i in base)\n\nprint list(base)\n这个东西输出可以脑补一下， 结果是[20,21,22,23], 而不是[10, 11, 12, 13]。 当时纠结了半天，一直没搞懂，后来齐老师稍微指点了一下， 突然想明白了--真够笨的，唉。。好了--正好趁机会稍微小结一下python里面的生成器。\n迭代器(iterator)\n要说生成器，必须首先说迭代器\n区分iterable,iterator与itertion\n讲到迭代器，就需要区别几个概念:iterable,iterator,itertion, 看着都差不多，其实不然。下面区分一下。\n\nitertion: 就是迭代,一个接一个(one after another),是一个通用的概念，比如一个循环遍历某个数组。\n\niterable: 这个是可迭代对象,属于python的名词，范围也很广，可重复迭代，满足如下其中之一的都是iterable:\n\n可以for循环: for i in iterable\n可以按index索引的对象，也就是定义了__getitem__方法，比如list,str;\n定义了__iter__方法。可以随意返回。\n可以调用iter(obj)的对象，并且返回一个iterator\n\n\n\niterator: 迭代器对象,也属于python的名词，只能迭代一次。需要满足如下的迭代器协议\n\n定义了__iter__方法，但是必须返回自身\n定义了next方法,在python3.x是__next__。用来返回下一个值，并且当没有数据了，抛出StopIteration\n可以保持当前的状态\n\n\n\n首先str和list是iterable 但不是iterator:\nIn [3]: s = 'hi'\n\nIn [4]: s.__getitem__\nOut[4]: <method-wrapper '__getitem__' of str object at 0x7f9457eed580>\n\nIn [5]: s.next # 没有next方法\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\n<ipython-input-5-136d3c11be25> in <module>()\n----> 1 s.next\n\nAttributeError: 'str' object has no attribute 'next'\n\nIn [6]: l = [1,2] # 同理\n\nIn [7]: l.__iter__\nOut[7]: <method-wrapper '__iter__' of list object at 0x7f945328c320>\n\nIn [8]: l.next\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\n<ipython-input-8-c6f8fb94c4cd> in <module>()\n----> 1 l.next\n\nAttributeError: 'list' object has no attribute 'next'\nIn [9]: iter(s) is s #iter() 没有返回本身\nOut[9]: False\nIn [10]: iter(l) is l #同理\nOut[10]: False\n但是对于iterator则不一样如下, 另外iterable可以支持多次迭代，而iterator在多次next之后，再次调用就会抛异常,只可以迭代一次。\nIn [13]: si = iter(s)\n\nIn [14]: si\nOut[14]: <iterator at 0x7f9453279dd0>\n\nIn [15]: si.__iter__ # 有__iter__\nOut[15]: <method-wrapper '__iter__' of iterator object at 0x7f9453279dd0>\n\nIn [16]: si.next #拥有next\nOut[16]: <method-wrapper 'next' of iterator object at 0x7f9453279dd0>\n\nIn [20]: si.__iter__() is si #__iter__返回自己\nOut[20]: True\n这样，由这几个例子可以解释清楚这几个概念的区别。\n自定义iterator 与数据分离\n说到这里，迭代器对象基本出来了。下面大致说一下，如何让自定义的类的对象成为迭代器对象，其实就是定义__iter__和next方法:\nIn [1]: %paste\nclass DataIter(object):\n\n    def __init__(self, *args):\n        self.data = list(args)\n        self.ind = 0\n\n    def __iter__(self): #返回自身\n        return self\n\n    def next(self): #　返回数据\n        if self.ind == len(self.data):\n            raise StopIteration\n        else:\n            data = self.data[self.ind]\n            self.ind += 1\n            return data\n## -- End pasted text --\n\nIn [9]: d  = DataIter(1,2)\n\nIn [10]: for x in d: #　开始迭代\n   ....:     print x\n   ....:\n1\n2\n\nIn [13]: d.next() #　只能迭代一次,再次使用则会抛异常\n---------------------------------------------------------------------------\nStopIteration                             Traceback (most recent call last)\n----> 1 d.next()\n<ipython-input-1-c44abc1904d8> in next(self)\n     10     def next(self):\n     11         if self.ind == len(self.data):\n---> 12             raise StopIteration\n     13         else:\n     14             data = self.data[self.ind]\n\n从next函数中只能向前取数据,一次取一个可以看出来，不过不能重复取数据，那这个可不可以解决呢？\n我们知道iterator只能迭代一次，但是iterable对象则没有这个限制，因此我们可以把iterator从数据中分离出来，分别定义一个iterable与iterator如下：\nclass Data(object):   # 只是iterable:可迭代对象而不iterator:迭代器\n\n    def __init__(self, *args):\n        self.data = list(args)\n\n    def __iter__(self):  # 并没有返回自身\n        return DataIterator(self)\n\n\nclass DataIterator(object):  # iterator: 迭代器\n\n    def __init__(self, data):\n        self.data = data.data\n        self.ind = 0\n\n    def __iter__(self):\n        return self\n\n    def next(self):\n        if self.ind == len(self.data):\n            raise StopIteration\n        else:\n            data = self.data[self.ind]\n            self.ind += 1\n            return data\n\nif __name__ == '__main__':\n    d = Data(1, 2, 3)\n    for x in d:\n        print x,\n    for x in d:\n        print x,\n\n输出就是：\n1,2,3\n1,2,3\n可以看出来数据可以复用，因为每次都返回一个DataIterator，但是数据却可以这样使用，这种实现方式很常见，比如xrange的实现便是这种数据与迭代分离的形式，但是很节省内存，如下：\nIn [8]: sys.getsizeof(range(1000000))\nOut[8]: 8000072\n\nIn [9]: sys.getsizeof(xrange(1000000))\nOut[9]: 40\n另外有个小tips， 就是为什么可以使用for 迭代迭代器对象，原因就是for替我们做了next的活，以及接收StopIteration的处理。\n迭代器大概就记录到这里了，下面开始一个特殊的更加优雅的迭代器: 生成器\n生成器(generator)\n首先需要明确的就是生成器也是iterator迭代器，因为它遵循了迭代器协议.\n两种创建方式\n包含yield的函数\n生成器函数跟普通函数只有一点不一样，就是把 return 换成yield,其中yield是一个语法糖，内部实现了迭代器协议，同时保持状态可以挂起。如下:记住一点，yield是数据的生产者，而诸如for等是数据的消费者。\ndef gen():\n    print 'begin: generator'\n    i = 0\n    while True:\n        print 'before return ', i\n        yield i\n        i += 1\n        print 'after return ', i\n\na  = gen()\n\nIn [10]: a #只是返回一个对象\nOut[10]: <generator object gen at 0x7f40c33adfa0>\n\nIn [11]: a.next() #开始执行\nbegin: generator\nbefore return  0\nOut[11]: 0\n\nIn [12]: a.next()\nafter return  1\nbefore return  1\nOut[12]: 1\n首先看到while True 不必惊慌，它只会一个一个的执行～看结果可以看出一点东西:\n\n调用gen()并没有真实执行函数，而是只是返回了一个生成器对象\n执行第一次a.next()时，才真正执行函数，执行到yield一个返回值，然后就会挂起，保持当前的名字空间等状态。然后等待下一次的调用,从yield的下一行继续执行。\n\n还有一种情况也会执行生成器函数，就是当检索生成器的元素时，如list(generator), 说白了就是当需要数据的时候，才会执行。\nIn [15]: def func():\n   ....:     print 'begin'\n   ....:     for i in range(4):\n   ....:         yield i\n\nIn [16]: a = func()\n\nIn [17]: list(a) #检索数据，开始执行\nbegin\nOut[17]: [0, 1, 2, 3]\n\nyield还有其他高级应用，后面再慢慢学习。\n生成器表达式\n列表生成器十分方便：如下,求10以内的奇数:[i  for i in range(10) if i % 2]\n同样在python 2.4也引入了生成器表达式，而且形式非常类似，就是把[]换成了().\nIn [18]: a = ( i for i in range(4))\n\nIn [19]: a\nOut[19]: <generator object <genexpr> at 0x7f40c2cfe410>\n\nIn [20]: a.next()\nOut[20]: 0\n可以看出生成器表达式创建了一个生成器，而且生有个特点就是惰性计算, 只有在被检索时候，才会被赋值。之前有篇文章:python 默认参数问题及一个应用,最后有一个例子:\ndef multipliers():\n    return (lambda x : i * x for i in range(4))  #修改成生成器\nprint [m(2) for m in multipliers()]\n这个就是说，只有在执行m(2)的时候，生成器表达式里面的for才会开始从0循环，然后接着才是i * x,因此不存在那篇文章中的问题.惰性计算这个特点很有用，上述就是一个应用，2gua这样说的:\n惰性计算想像成水龙头，需要的时候打开，接完水了关掉，这时候数据流就暂停了，再需要的时候再打开水龙头，这时候数据仍是接着输出，不需要从头开始循环\n个人理解就是就是可以利用生成器来作为数据管道使用，当被检索的时候，每次拿出一个数据，然后向下面传递,传到最后，再拿第二个数据，在下面的例子中会详细说明。其实本质跟迭代器差不多,不一次性把数据都那过来，需要的时候，才拿。\n回到例子\n看到这里，开始的例子应该大概可以有点清晰了，核心语句就是:\ndef gen():\n    for i in range(4):\n        yield i\nfor n in [1, 10]:\n    base = (add(i, n) for i in base)\n之前的解释有点瑕疵，容易误导对生成器的理解:在执行list(base)的时候，开始检索，然后生成器开始运算了。关键是，这个循环次数是2,也就是说，有两次生成器表达式的过程。必须牢牢把握住这一点。生成器返回去开始运算，n = 10而不是1没问题吧，这个在上面提到的文章中已经提到了，就是add(i+n)绑定的是n这个变量，而不是它当时的数值。然后首先是第一次生成器表达式的执行过程:base = (10 + 0, 10 + 1, 10 + 2, 10 +3),这是第一次循环的结果(形象表示，其实已经计算出来了(10,11,12,3))，然后第二次，base = (10 + 10, 11 + 10, 12 + 10, 13 + 10) ,终于得到结果了[20, 21, 22, 23].\n新思路这个可以以管道的思路来理解，首先gen()函数是第一个生成器,下一个是第一次循环的base = (add(i, n) for i in base),最后一个生成器是第二次循环的base = (add(i, n) for i in base)。这样就相当于三个管道依次连接,但是水(数据)还没有流过，现在到了list(base),就相当于驱动器，打开了水的开关，这时候，按照管道的顺序，由第一个产生一个数据，yield 0,然后第一个管道关闭。之后传递给第二个管道就是第一次循环,此时执行了add(0, 10),然后水继续流，到第二次循环，再执行add(10, 10),此时到管道尾巴了，此时产生了第一个数据20,然后第一个管道再开放：yield 1,　流程跟上面的一样，依次产生21,22,23; 直到没有数据。把代码改一下容易理解:\ndef gen():\n    for i in range(4):\n        yield i  #  第一个管道\n\nbase = (add(i, 10) for i in base) #  第二个管道\nbase = (add(i, 10) for i in base) #  第三个管道\n\nlist(base) #  开关驱动器\n具体执行过程可以在pythontutor上：之前的解释被误导的原因是，可能会误以为是在第二个管道就把gen()执行完毕了，其实不是这样的。这种写法的好处显而易见：内存占用低。在数据量极大的时候，用list就只能爆内存，而用生成器模式则完全不用担心\n小结\n概括\n主要介绍了大概这样几点：\n\niterable,iterator与itertion的概念\n\n迭代器协议\n自定义可迭代对象与迭代器分离，保证数据复用\n\n生成器: 特殊的迭代器,内部实现了迭代器协议\n\n其实这一块， 那几个概念搞清楚， ,这个很关键， 搞懂了后面就水到渠成了。而且对之前的知识也有很多加深。比如常见list就是iterator与iteable分离实现的,本身是可迭代对象，但不是迭代器， 类似与xrange,但是又不同。越来越明白，看源码的重要性了。\n参考\n\nhttp://www.shutupandship.com/2012/01/understanding-python-iterables-and.html\nhttp://www.learningpython.com/2009/02/23/iterators-iterables-and-generators-oh-my/\nhttp://stackoverflow.com/questions/9884132/what-exactly-are-pythons-iterator-iterable-and-iteration-protocols\nhttp://python.jobbole.com/81881/\n\n\n                ", "mainLikeNum": ["5 "], "mainBookmarkNum": "22"}