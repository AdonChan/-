{"title": "python blinker库学习 - nummy的专栏 ", "index": "flask,python", "content": "参考  Blinker Documentation\nBlinker 是一个基于Python的强大的信号库，它既支持简单的对象到对象通信，也支持针对多个对象进行组播。Flask的信号机制就是基于它建立的。\nBlinker的内核虽然小巧，但是功能却非常强大，它支持以下特性：\n\n支持注册全局命名信号\n支持匿名信号\n支持自定义命名信号\n支持与接收者之间的持久连接与短暂连接\n通过弱引用实现与接收者之间的自动断开连接\n支持发送任意大小的数据\n支持收集信号接收者的返回值\n线程安全\n\n创建信号\n信号通过signal()方法进行创建：\n>>> from blinker import signal\n>>> initialized = signal(\"initialized\")\n>>> initialized is signal(\"initialized\")\nTrue\n每次调用signal('name')都会返回同一个信号对象。因此这里signal()方法使用了单例模式。\n订阅信号\n使用Signal.connect()方法注册一个函数，每当触发信号的时候，就会调用该函数。该函数以触发信号的对象作为参数，这个函数其实就是信号订阅者。\n>>> def subscriber(sender):\n...     print(\"Got a signal sent by %r\" % sender)\n...\n>>> ready = signal('ready')\n>>> ready.connect(subscriber)\n<function subscriber at 0x...>\n触发信号\n使用Signal.send()方法通知信号订阅者。\n下面定义类Processor，在它的go()方法中触发前面声明的ready信号，send()方法以self为参数，也就是说Processor的实例是信号的发送者。\n>>> class Processor:\n...    def __init__(self, name):\n...        self.name = name\n...\n...    def go(self):\n...        ready = signal('ready')\n...        ready.send(self)\n...        print(\"Processing.\")\n...        complete = signal('complete')\n...        complete.send(self)\n...\n...    def __repr__(self):\n...        return '<Processor %s>' % self.name\n...\n>>> processor_a = Processor('a')\n>>> processor_a.go()\nGot a signal sent by <Processor a>\nProcessing.\n注意到go()方法中的complete信号没？并没有订阅者订阅该信号，但是依然可以触发该信号。如果没有任何订阅者的信号，结果是什么信号也不会发送，而且Blinker内部对这种情况进行了优化，以尽可能的减少内存开销。\n订阅特定的发布者\n默认情况下，任意发布者触发信号，都会通知订阅者。可以给Signal.connect()传递一个可选的参数，以便限制订阅者只能订阅特定发送者。\n>>> def b_subscriber(sender):\n...     print(\"Caught signal from processor_b.\")\n...     assert sender.name == 'b'\n...\n>>> processor_b = Processor('b')\n>>> ready.connect(b_subscriber, sender=processor_b)\n<function b_subscriber at 0x...>\n现在订阅者只订阅了processor_b发布的ready信号:\n>>> processor_a.go()\nGot a signal sent by <Processor a>\nProcessing.\n>>> processor_b.go()\nGot a signal sent by <Processor b>\nCaught signal from processor_b.\nProcessing.\n通过信号收发数据\n可以给send()方法传递额外的关键字参数，这些参数会传递给订阅者。\n>>> send_data = signal('send-data')\n>>> @send_data.connect\n... def receive_data(sender, **kw):\n...     print(\"Caught signal from %r, data %r\" % (sender, kw))\n...     return 'received!'\n...\n>>> result = send_data.send('anonymous', abc=123)\nCaught signal from 'anonymous', data {'abc': 123}\nsend()方法的返回值收集每个订阅者的返回值，拼接成一个元组组成的列表。每个元组的组成为(receiver function, return value)。\n匿名信号\n前面我们创建的信号都是命名信号，每次调用Signal构造器都会创建一个唯一的信号,，也就是说每次创建的信号是不一样的。下面对前面的Processor类进行改造，将signal作为它的类属性。\n>>> from blinker import Signal\n>>> class AltProcessor:\n...    on_ready = Signal()\n...    on_complete = Signal()\n...\n...    def __init__(self, name):\n...        self.name = name\n...\n...    def go(self):\n...        self.on_ready.send(self)\n...        print(\"Alternate processing.\")\n...        self.on_complete.send(self)\n...\n...    def __repr__(self):\n...        return '<AltProcessor %s>' % self.name\n...\n上面创建的就是匿名信号。on_ready与on_complete是两个不同的信号。\n使用修饰器订阅信号\n除了使用connect()方法订阅信号之外，使用@connect修饰器可以达到同样的效果。\n>>> apc = AltProcessor('c')\n>>> @apc.on_complete.connect\n... def completed(sender):\n...     print \"AltProcessor %s completed!\" % sender.name\n...\n>>> apc.go()\nAlternate processing.\nAltProcessor c completed!\n尽管这样用起来很方便，但是这种形式不支持订阅指定的发送者。这时，可以使用connect_via()：\n>>> dice_roll = signal('dice_roll')\n>>> @dice_roll.connect_via(1)\n... @dice_roll.connect_via(3)\n... @dice_roll.connect_via(5)\n... def odd_subscriber(sender):\n...     print(\"Observed dice roll %r.\" % sender)\n...\n>>> result = dice_roll.send(3)\nObserved dice roll 3.\n优化信号发送\n信号通常会进行优化，以便快速的发送。不管有没有订阅者，都可以发送信号。如果发送信号时需要传送的参数要计算很长时间，可以在发送之前使用receivers属性先检查一下是否有订阅者。\n>>> bool(signal('ready').receivers)\nTrue\n>>> bool(signal('complete').receivers)\nFalse\n>>> bool(AltProcessor.on_complete.receivers)\nTrue\n还可以检查订阅者是否订阅了某个具体的信号发布者。\n>>> signal('ready').has_receivers_for(processor_a)\nTrue\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "6"}