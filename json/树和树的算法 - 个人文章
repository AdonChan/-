{"title": "树和树的算法 - 个人文章 ", "index": "python,java,算法,数据结构", "content": "树和树的算法\n一、树\n1.1 树的概念\n树（英语：tree）是一种抽象数据类型（ADT）或是实作这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n>=1）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：\n\n每个节点有零个或多个子节点；\n没有父节点的节点称为根节点；\n每一个非根节点有且只有一个父节点；\n除了根节点外，每个子节点可以分为多个不相交的子树；\n\n1.2 树的术语\n\n\n节点的度：一个节点含有的子树的个数称为该节点的度；\n\n树的度：一棵树中，最大的节点的度称为树的度；\n\n叶节点或终端节点：度为零的节点；\n\n父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；\n\n孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；\n\n兄弟节点：具有相同父节点的节点互称为兄弟节点；\n\n节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；\n\n树的高度或深度：树中节点的最大层次；\n\n堂兄弟节点：父节点在同一层的节点互为堂兄弟；\n\n节点的祖先：从根到该节点所经分支上的所有节点；\n\n子孙：以某节点为根的子树中任一节点都称为该节点的子孙。\n\n森林：由m（m>=0）棵互不相交的树的集合称为森林；\n\n1.3 树的种类\n1.3.1\n无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树；\n1.3.2 有序树\n树中任意节点的子节点之间有顺序关系，这种树称为有序树；二叉树：每个节点最多含有两个子树的树称为二叉树；\n\n\n完全二叉树：对于一颗二叉树，假设其深度为d(d>1)。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树，其中满二叉树的定义是所有叶节点都在最底层的完全二叉树;\n\n平衡二叉树（AVL树）：当且仅当任何节点的两棵子树的高度差不大于1的二叉树；\n\n排序二叉树（二叉查找树（英语：Binary Search Tree），也称二叉搜索树、有序二叉树)\n\n霍夫曼树（用于信息编码）：带权路径最短的二叉树称为哈夫曼树或最优二叉树；B树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多余两个子树。\n1.4 树的存储与表示\n顺序存储：将数据结构存储在固定的数组中，然在遍历速度上有一定的优势，但因所占空间比较大，是非主流二叉树。二叉树通常以链式存储。\n1.5 常见的一些树的应用场景\n\nxml，html等，那么编写这些东西的解析器的时候，不可避免用到树\n路由协议就是使用了树的算法\nmysql数据库索引\n文件系统的目录结构\n所以很多经典的AI算法其实都是树搜索，此外机器学习中的decision tree也是树结构\n\n二、二叉树\n2.1 二叉树的基本概念\n二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）\n2.2 二叉树的性质(特性)\n性质1: 在二叉树的第i层上至多有2^(i-1)个结点（i>0）性质2: 深度为k的二叉树至多有2^k - 1个结点（k>0）性质3: 对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1;性质4:具有n个结点的完全二叉树的深度必为 log2(n+1)性质5:对完全二叉树，若从上至下、从左至右编号，则编号为i 的结点，其左孩子编号必为2i，其右孩子编号必为2i＋1；其双亲的编号必为i/2（i＝1 时为根,除外）\n(1)完全二叉树——若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树。\n(2)满二叉树——除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。\n2.3 二叉树的节点表示以及树的创建\n2.3.1 Python 建树\n通过使用Node类中定义三个属性，分别为elem本身的值，还有lchild左孩子和rchild右孩子\nclass Node(object):\n    \"\"\"节点类\"\"\"\n    def __init__(self, elem=-1, lchild=None, rchild=None):\n        self.elem = elem\n        self.lchild = lchild\n        self.rchild = rchild\n树的创建,创建一个树的类，并给一个root根节点，一开始为空，随后添加节点\n\nclass Tree(object):\n    \"\"\"树类\"\"\"\n    def __init__(self, root=None):\n        self.root = root\n\n    def add(self, elem):\n        \"\"\"为树添加节点\"\"\"\n        node = Node(elem)\n        #如果树是空的，则对根节点赋值\n        if self.root == None:\n            self.root = node\n        else:\n            queue = []\n            queue.append(self.root)\n            #对已有的节点进行层次遍历\n            while queue:\n                #弹出队列的第一个元素\n                cur = queue.pop(0)\n                if cur.lchild == None:\n                    cur.lchild = node\n                    return\n                elif cur.rchild == None:\n                    cur.rchild = node\n                    return\n                else:\n                    #如果左右子树都不为空，加入队列继续判断\n                    queue.append(cur.lchild)\n                    queue.append(cur.rchild)\n2.3.2 Java的建树\nNode节点类：\nclass Node{\n    public int value;\n    public Node lChild;\n    public Node rChild;\n    public Node(int value){\n        this.value = value;\n    }\n}\nTree类：\nclass Tree{\n    public Node root;\n    //根节点初始化\n    public Tree(Node node){\n        root = node;\n    }\n    //树中通过广度优先遍历的方式寻找空位置加新节点\n    public void add(int value){\n        Node temp = new Node(value);\n        if(root==null){\n            root = temp;\n        }\n        Queue<Node> queue = new LinkedList<Node>();\n        queue.add(root);\n        while(!queue.isEmpty()) {\n            Node curNode = queue.poll();\n            if (curNode.lChild == null) {\n                curNode.lChild = temp;\n                return;\n            } else if (curNode.rChild == null) {\n                curNode.rChild = temp;\n                return;\n            } else {\n                queue.add(curNode.lChild);\n                queue.add(curNode.rChild);\n            }\n\n        }\n    }\n}\n三、二叉树的遍历\n树的遍历是树的一种重要的运算。所谓遍历是指对树中所有结点的信息的访问，即依次对树中每个结点访问一次且仅访问一次，我们把这种对所有节点的访问称为遍历（traversal）。那么树的两种重要的遍历模式是深度优先遍历和广度优先遍历,深度优先一般用递归，广度优先一般用队列。一般情况下能用递归实现的算法大部分也能用堆栈来实现(掌握先序、中序、后序的非递归方式)。\n3.1 深度优先遍历\n对于一颗二叉树，深度优先搜索(Depth First Search)是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。那么深度遍历有重要的三种方法。这三种方式常被用于访问树的节点，它们之间的不同在于访问每个节点的次序不同。这三种遍历分别叫做先序遍历（preorder），中序遍历（inorder）和后序遍历（postorder）。我们来给出它们的详细定义，然后举例看看它们的应用。\n递归实现先序、中序、后序非常强大的地方是每个都会访问同一个节点三次，所以三个遍历方式只是调换一下函数执行顺序。\n无论是否是递归方式都用到了栈(函数栈也是栈)：因为树的结构是从上到下访问，如果要返回去访问另一处的节点，那么必须要有栈来“记忆”。\n3.1.1 先序遍历\n在先序遍历中，我们先访问根节点，然后递归使用先序遍历访问左子树，再递归使用先序遍历访问右子树根节点->左子树->右子树Python代码实现：\ndef preorder(self, root):\n      \"\"\"递归实现先序遍历\"\"\"\n      if root == None:\n          return\n      print root.elem\n      self.preorder(root.lchild)\n      self.preorder(root.rchild)\nJava代码实现(递归方式)：\npublic class PreOrder {\n\n    private void preOrder(Node node){\n        if(node == null){\n            return;\n        }\n        System.out.println(node.value);\n        preOrder(node.lChild);\n        preOrder(node.rChild);\n    }\n\n    public static void main(String[] args){\n        PreOrder sort = new PreOrder();\n        Tree tree = new Tree(new Node(0));\n        tree.add(1);\n        tree.add(2);\n        tree.add(3);\n        tree.add(4);\n        sort.preOrder(tree.root);\n    }\n}\nJava 代码实现(非递归方式)：\npublic void preOrderUnRecur(Node head){\n    System.out.print(\"preOrder:\");\n    if(head!=null){\n        //利用栈来实现\n        Stack<Node> stack = new Stack<Node>();\n        stack.push(head);\n        while(!stack.isEmpty()){\n            Node node = stack.pop();\n            System.out.print(node.value + \" \");\n            //先压进右孩子，利用先进后出原则\n            if(node.rChild!=null){\n                stack.push(node.rChild);\n            }\n            if(node.lChild!=null){\n                stack.push(node.lChild);\n            }\n        }\n    }\n}\n3.1.2 中序遍历\n在中序遍历中，我们递归使用中序遍历访问左子树，然后访问根节点，最后再递归使用中序遍历访问右子树左子树->根节点->右子树Python代码实现：\ndef inorder(self, root):\n      \"\"\"递归实现中序遍历\"\"\"\n      if root == None:\n          return\n      self.inorder(root.lchild)\n      print root.elem\n      self.inorder(root.rchild)\nJava代码实现(递归方式)：\npublic class InOrder {\n\n    public void inOrder(Node node){\n        if(node==null){\n            return;\n        }\n        inOrder(node.lChild);\n        System.out.println(node.value);\n        inOrder(node.rChild);\n    }\n\n    public static void main(String[] args){\n        Tree tree = new Tree(new Node(0));\n        tree.add(1);\n        tree.add(2);\n        tree.add(3);\n        tree.add(4);\n        InOrder sort = new InOrder();\n        sort.inOrder(tree.root);\n    }\n}\nJava实现(非递归方式)：\npublic void inOrderUnRecur(Node head){\n    System.out.print(\"InOrder:\");\n    if(head!=null){\n        Stack<Node> stack = new Stack<>();\n        while(!stack.isEmpty() || head!=null){\n            if(head != null){\n                stack.push(head);\n                head = head.lChild;\n            }else{\n                head = stack.pop();\n                System.out.print(head.value + \" \");\n                head = head.rChild;\n            }\n        }\n    }\n}\n3.1.3 后序遍历\n在后序遍历中，我们先递归使用后序遍历访问左子树和右子树，最后访问根节点左子树->右子树->根节点Python代码实现：\ndef postorder(self, root):\n      \"\"\"递归实现后续遍历\"\"\"\n      if root == None:\n          return\n      self.postorder(root.lchild)\n      self.postorder(root.rchild)\n      print root.elem\nJava代码实现(递归方式)：\npublic class PostOrder {\n\n    public void postOrder(Node node){\n        if(node==null){\n            return;\n        }\n        postOrder(node.lChild);\n        postOrder(node.rChild);\n        System.out.println(node.value);\n    }\n\n    public static void main(String[] args) {\n        Tree tree = new Tree(new Node(0));\n        tree.add(1);\n        tree.add(2);\n        tree.add(3);\n        tree.add(4);\n        PostOrder sort = new PostOrder();\n        sort.postOrder(tree.root);\n    }\n}\nJava代码实现(非递归方式：采用辅助空间方式,把先序(中右左)存储到辅助栈，然后根据先进后出打印出结果就是后序遍历结果(左右中)):\npublic void postOrderUnRecur(Node head){\n    System.out.print(\"postOrder:\");\n    if(head!=null){\n        Stack<Node> stack1 = new Stack<Node>();\n        Stack<Node> stack2 = new Stack<Node>();\n        stack1.push(head);\n        while(!stack1.isEmpty()){\n            head = stack1.pop();\n            stack2.push(head);  //与先序的不同：先序打印，后序存储起来\n            if(head.lChild!=null){\n                stack1.push(head.lChild);\n            }\n            if(head.rChild!=null){\n                stack1.push(head.rChild);\n            }\n        }\n        //利用栈先进后出原则输出后序遍历结果\n        while(!stack2.isEmpty()){\n            head = stack2.pop();\n            System.out.print(head.value + \" \");\n        }\n    }\n}\n思考：哪两种遍历方式能够唯一的确定一颗树？？？\n3.2 广度优先遍历(层次遍历)\n通过一个队列的方法来实现\n从树的root开始，从上到下从从左到右遍历整个树的节点\ndef breadth_travel(self, root):\n        \"\"\"利用队列实现树的层次遍历\"\"\"\n        if root == None:\n            return\n        queue = []\n        queue.append(root)\n        while queue:\n            node = queue.pop(0)\n            print node.elem,\n            if node.lchild != None:\n                queue.append(node.lchild)\n            if node.rchild != None:\n                queue.append(node.rchild)\n3.3 Morris 遍历\n二叉树的遍历一般额外空间复杂度为O(logn)，根据高度来的(节点回到自身需要保存到栈中)，要回到上一个很难(通过栈解决)。\n一种时间复杂度O(n),额外空间复杂度O(1)的二叉树的遍历方式，N为二叉树的节点个数。\nMorris 遍历规则：\n\n来到当前节点，记为cur，如果cur无左孩子，cur向右移动cur = cur.right\n如果cur有左孩子：找到左子树上最右节点，记为mostright,①如果mostright的right指针指向空，让其指向cur,然后cur向左移动cur = cur.left ②如果mostright指向cur，让其指向空，cur向右移动。\n\npublic static void morrisIn(Node head){\n    if(head == null){\n        return;\n    }\n    Node cur = head;\n    Node mostRight = null;\n    while(cur!=null){\n        mostRight = cur.left;\n        if(mostRight!=null){ //有左孩子，找到左子树的最右节点\n            while(mostRight.right!=null && mostRight.right!=cur){\n                mostRight = mostRight.right;\n            }\n            if(mostRight.right == null){\n                mostRight.right = cur;\n                cur = cur.left;\n                continue;\n            }else{\n                mostRight.right = null;\n            }\n        }\n        System.out.print(cur.value + \" \");//要往右节点走了，就是中序遍历\n        cur = cur.right;\n    }\n}\n如果一个节点有左子树，morris能回到节点两次。如果没有左子树，只到节点一次。\nmorris改先序遍历\npublic static void morrisPre(Node head){\n    if(head == null){\n        return;\n    }\n    Node cur = head;\n    Node mostRight = null;\n    while(cur!=null){\n        mostRight = cur.left;\n        if(mostRight!=null){\n            while(mostRight.right!=null && mostRight.right!=cur){\n                mostRight = mostRight.right;\n            }\n            if(mostRight.right == null){\n                mostRight.right = cur;\n                System.out.print(cur.value + \" \")\n                cur = cur.left;\n                continue;\n            }else{\n                mostRight.right = null;\n            }\n        }else{\n            System.out.print(cur.value + \" \");\n        }\n        cur = cur.right;\n    }\n    System.out.println();\n}\n后序遍历是第三次回到节点时候打印的，但是morris没有回到节点第三次的。怎么做？先去关注能回到节点两次的节点，逆序打印它左子树的右边界。退出函数时单独打印整棵树的右边界\npublic static void morrisPos(Node head){\n    if(head == null){\n        return;\n    }\n    Node cur1 = head;\n    Node cur2 = head;\n    while(cur1 !=null) {\n        cur2 = cur1.left;\n        if(cur2!=null){\n            while(cur2.right!=null && cur2.right!=cur1){\n                cur2 = cur2.right;\n            }  \n            if(cur2.right==null){\n                cur2.right = cur1;\n                cur1 = cur1.left;\n                continue;\n            }else{\n                cur2.right = null;\n                printEdge(cur1.left);\n            }\n        }\n        cur1 = cur1.right;\n    }\n    printEdge(head);\n    System.out.println();\n}\n怎么实现逆序打印？采用链表逆序的方法，打印完再调整回来，这样就没有引入额外空间复杂度\n四、树的题目\n4.1 如何画出一棵树\n先序 + 中序思想：\n\n先序取第一位即是根，然后根据这个元素找到中序的左子树和右子树\n先判断左子树，先序除了第一位后是连续的一块左子树的元素和连续的一块右子树元素，去先序连续一块左子树的第一位，再到中序去分割新的左子树和右子树\n通过重复2，可以画出一个树\n\n中序+后序也可以\n4.2 二叉树中找到一个节点的后继节点\n\n题目：现有一种新的二叉树节点类型如下\npublic class Node{\n    public int value;\n    public Node left;\n    public Node right;\n    public Node parent;\n    public Node(int value){\n        this.value = value;\n    }\n}\n这个结构只比普通二叉树节点结构多了一个指向父节点的parent指针。假设一棵Node类型的节点组成的二叉树，树中每个节点的parent指针都正确地指向父节点，头节点的parent指向Null，只给一个在二叉树中的某个节点Node，请实现返回node的后继节点的函数。在二叉树的中序遍历的序列中，node的下一个节点叫作node的后继节点。\n解决思路：如果一个节点有右子树，那么右子树的左边界(整个树最左下角)节点一定是它的后继节点；如果没有右子树，通过这个节点的父指针parent指向父节点，如果发现这个节点是父节点的右孩子，就继续往上，一直到某个节点是它父节点的左孩子，那么这个最初节点的后继就是这个父节点。\nJava 代码创建特殊的节点类：\npublic class FatherPointNode {\n    public int value;\n    public FatherPointNode lChild;\n    public FatherPointNode rChild;\n    public FatherPointNode parent;\n    public FatherPointNode(int value){\n        this.value = value;\n    }\n}\nJava 代码创建特殊的树类：\npublic class FatherPointTree {\n\n    public FatherPointNode root;\n    //根节点初始化\n    public FatherPointTree(FatherPointNode node){\n        root = node;\n    }\n    //树中通过广度优先遍历的方式寻找空位置加新节点\n    public void add(int value){\n        FatherPointNode temp = new FatherPointNode(value);\n        if(root==null){\n            root = temp;\n        }\n        Queue<FatherPointNode> queue = new LinkedList<FatherPointNode>();\n        queue.add(root);\n        while(!queue.isEmpty()) {\n            FatherPointNode curNode = queue.poll();\n            if (curNode.lChild == null) {\n                curNode.lChild = temp;\n                temp.parent = curNode; //与原来的树不同地方：添加父节点\n                return;\n            } else if (curNode.rChild == null) {\n                curNode.rChild = temp;\n                temp.parent = curNode;\n                return;\n            } else {\n                queue.add(curNode.lChild);\n                queue.add(curNode.rChild);\n            }\n\n        }\n    }\n\n}\nJava 代码找后继节点：\npublic class SuccessorNode {\n\n    public FatherPointNode successorNode(FatherPointNode node){\n        if(node==null){\n            return null;\n        }\n        if(node.rChild!=null){\n            return getLeftMost(node); //找右子树的左边界节点\n        }else{\n            while(node.parent!=null && node.parent.lChild!=node){\n                node = node.parent;\n            }\n            return node.parent;\n        }\n    }\n\n    public FatherPointNode getLeftMost(FatherPointNode node){\n        if(node!=null){\n            while(node.lChild!=null){\n                node = node.lChild;\n            }\n            return node;\n        }\n        return null;\n    }\n\n    public static void main(String[] args) {\n        FatherPointTree tree = new FatherPointTree(new FatherPointNode(0));\n        tree.add(1);\n        tree.add(2);\n        tree.add(3);\n        tree.add(4);\n        SuccessorNode sn = new SuccessorNode();\n        FatherPointNode result = sn.successorNode(tree.root.lChild.rChild);//节点4，后序节点应该是为0;\n        System.out.println(tree.root.lChild.rChild.value + \" 后续节点：\" + result.value);\n        result = sn.successorNode(tree.root.lChild);//节点3，后序节点应该是为1;\n        System.out.println(tree.root.lChild.value + \" 后续节点：\" + result.value);\n    }\n\n}\n\n先驱节点：节点有左子树，那么左子树的右节点一定是它的前驱。如果没有左子树，往上找，如果一个节点是父节点的右孩子，那么这个父节点就是前驱节点\n4.3 二叉树的序列化与反序列化\n序列化：\neg:    12     3  4  5   6  7先先序遍历变成字符串：1_2_4_#_#_5_#_#_3_6_#_#_7_#_#_用“#”来占住位置，用_可以区分节点，否则124，都在一起无法区分了\nJava代码实现：\npublic class SerialTree {\n    //通过先序遍历改编成序列化，原来打印处改为添加到字符串\n    public static String  serialTree(Node curNode){\n        if(curNode==null){\n            return \"#_\"; //子节点为null用#占住\n        }\n        String res = \"\";\n        res += curNode.value+\"_\"; \n        res += serialTree(curNode.lChild);\n        res += serialTree(curNode.rChild);\n        return res;\n    }\n\n    public static void main(String[] args) {\n        Tree tree = new Tree(new Node(0));\n        tree.add(1);\n        tree.add(2);\n        tree.add(3);\n        tree.add(4);\n\n        String result = serialTree(tree.root);\n        System.out.println(result);\n    }\n\n}\n序列化+反序列化完整代码：\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class SerialTree {\n    public static String  serialTree(Node curNode){\n        if(curNode==null){\n            return \"#_\";\n        }\n        String res = \"\";\n        res += curNode.value+\"_\";\n        res += serialTree(curNode.lChild);\n        res += serialTree(curNode.rChild);\n        return res;\n    }\n    //解析字符串，将节点信息存入到队列中\n    public static Node reconByPreString(String preString){\n        String[] value = preString.split(\"_\");\n        Queue<String> queue = new LinkedList<String>();\n        for (int i = 0; i < value.length; i++) {\n            queue.offer(value[i]);\n        }\n        return reconPreOrder(queue);\n    }\n    //根据队列的信息递归生成节点\n    public static Node reconPreOrder(Queue<String> queue){\n        String value = queue.poll();\n        if(value.equals(\"#\")){\n            return null;\n        }\n        Node head = new Node(Integer.valueOf(value));\n        head.lChild = reconPreOrder(queue);\n        head.rChild = reconPreOrder(queue);\n        return head;\n    }\n    //采用先序遍历打印来验证反序列化结果是否正确\n    public static void preOrder(Node node){\n        if(node == null){\n            return;\n        }\n        System.out.print(node.value + \" \");\n        preOrder(node.lChild);\n        preOrder(node.rChild);\n    }\n\n    public static void main(String[] args) {\n        Tree tree = new Tree(new Node(0));\n        tree.add(1);\n        tree.add(2);\n        tree.add(3);\n        tree.add(4);\n\n        String result = serialTree(tree.root);\n        System.out.println(result);\n        Node head = reconByPreString(result);\n        System.out.println(\"验证反序列化树(先序遍历结果):\");\n        preOrder(head);\n    }\n\n}\n\n同理可以学习中序、后序，层次化的序列化和反序列化\n4.4 判断二叉树是否是平衡二叉树\n平衡二叉树：一个树的任一节点的左子树和右子树的高度差不超过1。\n套路：递归函数有什么特点？到达一个节点三次！\n第一次来到这个节点，左子树转一圈完回到这个节点，右子树转一圈完回到这个节点\n解题思路：以每个节点为头的子树判断是否平衡，如果都平衡那么这个树就是平衡的。对于每个节点的判断：\n\n左树是否平衡？如果不平衡后续就不用判断了\n右树是否平衡？\n左树平衡和右树平衡的情况下，需要左树和右树高度信息\n\n因此递归函数需要返回两个信息(通过一个对象返回，成员变量为 ①是否平衡 ②高度）\nJava 代码实现:\n//创建返回数据类：携带是否平衡信息和高度信息\nclass ReturnData{\n    public boolean isB;\n    public int high;\n    public ReturnData(boolean isB, int high){\n        this.isB = isB;\n        this.high = high;\n    }\n}\npublic class IsBalanceTree {\n\n    public static ReturnData processData(Node head){\n        if(head==null){\n            return new ReturnData(true, 0);\n        }\n        ReturnData leftData = processData(head.lChild);\n        if(!leftData.isB){\n            return new ReturnData(false,0);\n        }\n        ReturnData rightData = processData(head.rChild);\n        if(!rightData.isB){\n            return new ReturnData(false,0);\n        }\n        if(Math.abs(leftData.high-rightData.high)>1){\n            return new ReturnData(false,0);\n        }\n        return new ReturnData(true,Math.max(leftData.high,rightData.high)+1);\n    }\n\n    public static boolean isBalance(Node head){\n        return processData(head).isB;\n    }\n\n    public static void main(String[] args) {\n        Tree tree = new Tree(new Node(0));\n        tree.add(1);\n        tree.add(2);\n        tree.add(3);\n        tree.add(4);\n        Boolean result = isBalance(tree.root);\n        System.out.println(\"是否是平衡树？：\" + result);\n    }\n}\n4.5 如何判断一棵树是二叉搜索树\n二叉搜索树：任何一个节点，左子树都比它小，右子树都比它大。\n解题思路：二叉树的中序遍历节点是依次升序的就是搜索二叉树。用非递归版本的中序遍历中与前一个值进行比较:一旦产生前一个节点比后一个节点要大，说明不是二叉搜索树。\n通常搜索二叉树是不出现重复节点的，一般重复的节点的信息都是压到一个节点内的(如前缀树)。\nJava代码实现：\nimport java.util.Stack;\n\npublic class IsBST {\n    public static boolean isBST(Node head){\n        if(head==null){\n            return false;\n        }\n        Stack<Node> stack = new Stack<>();\n        int value = Integer.MIN_VALUE;\n        while(!stack.isEmpty() || head!=null){\n            if(head!=null){   //注意判断条件不要写成了head.lChild!=null\n                stack.push(head);\n                head = head.lChild;\n            }else{\n                head = stack.pop();\n                if(head.value<value) {\n                    return false;\n                }\n                value = head.value;\n                head = head.rChild;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Tree tree1 = new Tree(new Node(0)); //创建一个非二叉搜索树\n        tree1.add(1);\n        tree1.add(2);\n        tree1.add(3);\n        tree1.add(4);\n        Tree tree2 = new Tree(new Node(7)); //创建一个二叉搜索树\n        tree2.add(4);\n        tree2.add(8);\n        tree2.add(3);\n        tree2.add(5);\n        Boolean result = isBST(tree1.root);\n        System.out.println(\"tree1 is BST?:\" + result);\n        result = isBST(tree2.root);\n        System.out.println(\"tree2 is BST?:\" + result);\n    }\n}\n\n4.6 怎么判断一棵树是否是完全二叉树\n判断方式：二叉树按层遍历判断依据：\n\n一个节点有右孩子但是没有左孩子 ，一定不是完全二叉树\n如果一个节点不是左右孩子都全，在1的条件下，后面遇到的所有节点都必须是叶节点，否则就不是完全二叉树\n\nJava 代码实现：\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class IsCBT {\n\n    public static boolean isCBT(Node head){\n        if(head==null){\n            return false;\n        }\n        Queue<Node> queue = new LinkedList<Node>();\n        queue.offer(head);\n        Node lChild = null;\n        Node rChild = null;\n        boolean leaf = false;\n        while(!queue.isEmpty()){\n            head = queue.poll();\n            lChild = head.lChild;\n            rChild = head.rChild;\n            //判断第一种情况：右孩子不为null，左孩子为null\n            if((leaf && (lChild!=null && rChild!=null)) || (lChild==null && rChild!=null)){\n                return false;\n            }\n            if(lChild!=null){\n                queue.offer(lChild);\n            }else{\n                leaf = true; //出现情况：左孩子不为Null，右孩子为Null 或者 左右孩子都为Null，之后为叶节点。\n            }\n        }\n        return true;\n    }\n}\n\n补充知识：使用二叉树实现堆比数组的节省了扩容代价\n4.7 已知一棵完全二叉树，求节点的个数\n题目要求：时间复杂度低于O(n),n为这棵树的节点个数\n时间复杂度低于O(n)，说明无法采用广度优先遍历的方式获取\n解题思路：\n\n先遍历左子树的左边界，记录层数(完全二叉树性质，这个就是树的层数)，时间复杂度为O(logn)\n\n遍历右子树的左边界，是不是到了最后一层，如果到达最后一层那么左子树就是满二叉树，如果不是，那么左子树可能满可能不满。\n如果右子树的左边界不是到最后一层(右子树少一层：右子树节点总数=1<<(h-level-1))，那么节点总数等于 1<<(h-level-1)+左树递归求总数\n\n补充知识点：如果一棵树是一棵满二叉树，高度是l，那么节点个数是2^l -1\nJava 代码实现：\npublic class TreeNodeNum {\n    public static int treeNodeNum(Node head){\n        if(head==null){\n            return 0;\n        }\n        return bs(head,1, mostLeftLevel(head,1));\n    }\n\n    //h:树的深度， level：当前层数\n    public static int bs(Node node, int level, int h){\n        //如果level==h，说明当前节点是叶节点，节点个数为1\n        if(level == h){\n            return 1;\n        }\n        if(mostLeftLevel(node.rChild,level + 1) == h){\n            System.out.println(\"左子树满\");\n            return (1<<(h-level)) + bs(node.rChild,level+1, h);\n        }else{\n            System.out.println(\"左子树不一定满\");\n            return (1 << (h-level-1)) + bs(node.lChild, level+1, h);\n        }\n\n    }\n\n    public static  int mostLeftLevel(Node node,int level){\n        while(node!=null){\n            level++;\n            node = node.lChild;\n        }\n        return level-1;\n    }\n\n    public static void main(String[] args) {\n        Tree tree = new Tree(new Node(0));\n        tree.add(1);\n        tree.add(2);\n        tree.add(3);\n        tree.add(4);\n        int result = treeNodeNum(tree.root);\n        System.out.println(\"完全二叉树的节点数目：\" + result);\n    }\n}\n结果：算法的时间复杂度 O(logn)平方\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "0"}