{"title": "Python 多线程抓取图片效率实验 - web高性能开发 ", "index": "python", "content": "Python 多线程抓取图片效率实验\n实验目的:\n是学习python 多线程的工作原理，及通过抓取400张图片这种IO密集型应用来查看多线程效率对比\nimport requests\nimport urlparse\nimport os\nimport time\nimport threading\nimport Queue\n\npath = '/home/lidongwei/scrapy/owan_img_urls.txt'\n#path = '/home/lidongwei/scrapy/cc.txt'\nfetch_img_save_path = '/home/lidongwei/scrapy/owan_imgs/'\n\n# 读取保存再文件里面400个urls\nwith open(path) as f :\n    urls = f.readlines()\n\nurls = urls[:400]\n# 使用Queue来线程通信，因为队列是线程安全的（就是默认这个队列已经有锁）\nq = Queue.Queue()\nfor url in urls:\n    q.put(url)\n\nstart = time.time()\n\ndef fetch_img_func(q):\n    while True:\n        try:\n            # 不阻塞的读取队列数据\n            url = q.get_nowait()\n            i = q.qsize()\n        except Exception, e:\n            print e\n            break;\n        print 'Current Thread Name Runing %s ... 11' % threading.currentThread().name\n        url = url.strip()\n        img_path = urlparse.urlparse(url).path\n        ext = os.path.splitext(img_path)[1]\n        print 'handle %s pic... pic url %s ' % (i, url)\n        res = requests.get(url, stream=True)\n\n        if res.status_code == 200:\n            save_img_path = '%s%s%s' % (fetch_img_save_path, i, ext)\n            # 保存下载的图片\n            with open(save_img_path, 'wb') as fs:\n                for chunk in res.iter_content(1024):\n                    fs.write(chunk)\n                print 'save %s pic ' % i\n\n# 可以开多个线程测试不同效果\nt1 = threading.Thread(target=fetch_img_func, args=(q, ), name=\"child_thread_1\")\n#t2 = threading.Thread(target=fetch_img_func, args=(q, ), name=\"child_thread_2\")\n#t3 = threading.Thread(target=fetch_img_func, args=(q, ), name=\"child_thread_3\")\n#t4 = threading.Thread(target=fetch_img_func, args=(q, ), name=\"child_thread_4\")\nt1.start()\n#t2.start()\n#t3.start()\n#t4.start()\nt1.join()\n#t2.join()\n#t3.join()\n#t4.join()\n\nend = time.time()\nprint 'Done %s ' %  (end-start)\n实验结果\n400图片\n4线程 Done 12.443133831\n3线程 Done 12.9201757908 \n2线程 Done 32.8628299236\n1线程 Done 54.6115460396 \n\n总结\nPython 自带GIL 大锁， 没有真正意义上的多线程并行执行。GIL 大锁会在线程阻塞的时候释放，此时等待的线程就可以激活工作，这样如此类推，大大提高IO阻塞型应用的效率。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "12"}