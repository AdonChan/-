{"title": "python并发3：使用asyncio编写服务器 - 古寺比的寺 ", "index": "协程,并发,python3.x,python", "content": "asyncio 上一篇我们介绍了 asyncio 包，以及如何使用异步编程管理网络应用中的高并发。在这一篇，我们主要介绍使用 asyncio 包编程的两个例子。\nasync/await语法\n我们先介绍下 async/await 语法，要不然看完这篇可能会困惑，为什么之前使用 asyncio.coroutine 装饰器 和 yield from，这里都是 用的 async 和 await？\npython并发2：使用asyncio处理并发\nasync/await 是Python3.5 的新语法，语法如下：\nasync def read_data(db):\n    pass\nasync 是明确将函数声明为协程的关键字，即使没有await表达式，函数执行也会返回一个协程对象。在协程函数内部，可以在某个表达式之前使用 await 关键字来暂停协程的执行，以等待某协程完成：\nasync def read_data(db):\n    data = await db.fetch('SELECT ...')\n这个代码如果使用 asyncio.coroutine 装饰器语法为：\n@asyncio.coroutine\ndef read_data(db):\n    data = yield from db.fetch('SELECT ...')\n这两段代码执行的结果是一样的，也就是说 可以把 asyncio.coroutine 替换为 async， yield from 替换为 await。\n使用新的语法有什么好处呢：\n\n使生成器和协程的概念更容易理解，因为语法不同\n可以消除由于重构时不小心移出协程中yield 声明而导致的不明确错误，这回导致协程变成普通的生成器。\n\n使用 asyncio 包编写服务器\n这个例子主要是使用 asyncio 包 和 unicodedata 模块，实现通过规范名称查找Unicode 字符。\n我们先来看一下代码：\n# charfinder.py\nimport sys\nimport re\nimport unicodedata\nimport pickle\nimport warnings\nimport itertools\nimport functools\nfrom collections import namedtuple\n\nRE_WORD = re.compile('\\w+')\nRE_UNICODE_NAME = re.compile('^[A-Z0-9 -]+$')\nRE_CODEPOINT = re.compile('U\\+[0-9A-F]{4, 6}')\n\nINDEX_NAME = 'charfinder_index.pickle'\nMINIMUM_SAVE_LEN = 10000\nCJK_UNI_PREFIX = 'CJK UNIFIED IDEOGRAPH'\nCJK_CMP_PREFIX = 'CJK COMPATIBILITY IDEOGRAPH'\n\nsample_chars = [\n    '$',  # DOLLAR SIGN\n    'A',  # LATIN CAPITAL LETTER A\n    'a',  # LATIN SMALL LETTER A\n    '\\u20a0',  # EURO-CURRENCY SIGN\n    '\\u20ac',  # EURO SIGN\n]\n\nCharDescription = namedtuple('CharDescription', 'code_str char name')\n\nQueryResult = namedtuple('QueryResult', 'count items')\n\n\ndef tokenize(text):\n    '''\n    :param text: \n    :return: return iterable of uppercased words \n    '''\n    for match in RE_WORD.finditer(text):\n        yield match.group().upper()\n\n\ndef query_type(text):\n    text_upper = text.upper()\n    if 'U+' in text_upper:\n        return 'CODEPOINT'\n    elif RE_UNICODE_NAME.match(text_upper):\n        return 'NAME'\n    else:\n        return 'CHARACTERS'\n\n\nclass UnicodeNameIndex:\n    # unicode name 索引类\n\n    def __init__(self, chars=None):\n        self.load(chars)\n\n    def load(self, chars=None):\n        # 加载 unicode name    \n        self.index = None\n        if chars is None:\n            try:\n                with open(INDEX_NAME, 'rb') as fp:\n                    self.index = pickle.load(fp)\n            except OSError:\n                pass\n        if self.index is None:\n            self.build_index(chars)\n        if len(self.index) > MINIMUM_SAVE_LEN:\n            try:\n                self.save()\n            except OSError as exc:\n                warnings.warn('Could not save {!r}: {}'\n                              .format(INDEX_NAME, exc))\n\n    def save(self):\n        with open(INDEX_NAME, 'wb') as fp:\n            pickle.dump(self.index, fp)\n\n    def build_index(self, chars=None):\n        if chars is None:\n            chars = (chr(i) for i in range(32, sys.maxunicode))\n        index = {}\n        for char in chars:\n            try:\n                name = unicodedata.name(char)\n            except ValueError:\n                continue\n            if name.startswith(CJK_UNI_PREFIX):\n                name = CJK_UNI_PREFIX\n            elif name.startswith(CJK_CMP_PREFIX):\n                name = CJK_CMP_PREFIX\n\n            for word in tokenize(name):\n                index.setdefault(word, set()).add(char)\n\n        self.index = index\n\n    def word_rank(self, top=None):\n        # (len(self.index[key], key) 是一个生成器，需要用list 转成列表，要不然下边排序会报错\n        res = [list((len(self.index[key], key)) for key in self.index)]\n        res.sort(key=lambda  item: (-item[0], item[1]))\n        if top is not None:\n            res = res[:top]\n        return res\n\n    def word_report(self, top=None):\n        for postings, key in self.word_rank(top):\n            print('{:5} {}'.format(postings, key))\n\n    def find_chars(self, query, start=0, stop=None):\n        stop = sys.maxsize if stop is None else stop\n        result_sets = []\n        for word in tokenize(query):\n            # tokenize 是query 的生成器 a b 会是 ['a', 'b'] 的生成器\n            chars = self.index.get(word)\n            if chars is None:\n                result_sets = []\n                break\n            result_sets.append(chars)\n\n        if not result_sets:\n            return QueryResult(0, ())\n\n        result = functools.reduce(set.intersection, result_sets)\n        result = sorted(result)  # must sort to support start, stop\n        result_iter = itertools.islice(result, start, stop)\n        return QueryResult(len(result),\n                           (char for char in result_iter))\n\n    def describe(self, char):\n        code_str = 'U+{:04X}'.format(ord(char))\n        name = unicodedata.name(char)\n        return CharDescription(code_str, char, name)\n\n    def find_descriptions(self, query, start=0, stop=None):\n        for char in self.find_chars(query, start, stop).items:\n            yield self.describe(char)\n\n    def get_descriptions(self, chars):\n        for char in chars:\n            yield self.describe(char)\n\n    def describe_str(self, char):\n        return '{:7}\\t{}\\t{}'.format(*self.describe(char))\n\n    def find_description_strs(self, query, start=0, stop=None):\n        for char in self.find_chars(query, start, stop).items:\n            yield self.describe_str(char)\n\n    @staticmethod  # not an instance method due to concurrency\n    def status(query, counter):\n        if counter == 0:\n            msg = 'No match'\n        elif counter == 1:\n            msg = '1 match'\n        else:\n            msg = '{} matches'.format(counter)\n        return '{} for {!r}'.format(msg, query)\n\ndef main(*args):\n    index = UnicodeNameIndex()\n    query = ' '.join(args)\n    n = 0\n    for n, line in enumerate(index.find_description_strs(query), 1):\n        print(line)\n    print('({})'.format(index.status(query, n)))\n\n\nif __name__ == '__main__':\n    if len(sys.argv) > 1:\n        main(*sys.argv[1:])\n    else:\n        print('Usage: {} word1 [word2]...'.format(sys.argv[0]))\n\n这个模块读取Python内建的Unicode数据库，为每个字符名称中的每个单词建立索引，然后倒排索引，存入一个字典。例如，在倒排索引中，'SUN' 键对应的条目是一个集合，里面是名称中包含'SUN' 这个词的10个Unicode字符。倒排索引保存在本地一个名为charfinder_index.pickle 的文件中。如果查询多个单词，会计算从索引中所得集合的交集。运行示例如下：\n    >>> main('rook')  # doctest: +NORMALIZE_WHITESPACE\n    U+2656  ♖  WHITE CHESS ROOK\n    U+265C  ♜  BLACK CHESS ROOK\n    (2 matches for 'rook')\n    >>> main('rook', 'black')  # doctest: +NORMALIZE_WHITESPACE\n    U+265C  ♜  BLACK CHESS ROOK\n    (1 match for 'rook black')\n    >>> main('white bishop')  # doctest: +NORMALIZE_WHITESPACE\n    U+2657  ♗   WHITE CHESS BISHOP\n    (1 match for 'white bishop')\n    >>> main(\"jabberwocky's vest\")\n    (No match for \"jabberwocky's vest\")\n这个模块没有使用并发，主要作用是为使用 asyncio 包编写的服务器提供支持。下面我们来看下 tcp_charfinder.py 脚本：\n# tcp_charfinder.py\nimport sys\nimport asyncio\n\n# 用于构建索引，提供查询方法\nfrom charfinder import UnicodeNameIndex\n\nCRLF = b'\\r\\n'\nPROMPT = b'?> '\n\n# 实例化UnicodeNameIndex 类，它会使用charfinder_index.pickle 文件\nindex = UnicodeNameIndex()\n\nasync def handle_queries(reader, writer):\n    # 这个协程要传给asyncio.start_server 函数，接收的两个参数是asyncio.StreamReader 对象和 asyncio.StreamWriter 对象\n    while True:  # 这个循环处理会话，直到从客户端收到控制字符后退出\n        writer.write(PROMPT)  # can't await!  # 这个方法不是协程，只是普通函数；这一行发送 ?> 提示符\n        await writer.drain()  # must await!  # 这个方法刷新writer 缓冲；因为它是协程，所以要用 await\n        data = await reader.readline()  # 这个方法也是协程，返回一个bytes对象，也要用await\n        try:\n            query = data.decode().strip()\n        except UnicodeDecodeError:\n            # Telenet 客户端发送控制字符时，可能会抛出UnicodeDecodeError异常\n            # 我们这里默认发送空字符\n            query = '\\x00'\n        client = writer.get_extra_info('peername')  # 返回套接字连接的远程地址\n        print('Received from {}: {!r}'.format(client, query))  # 在控制台打印查询记录\n        if query:\n            if ord(query[:1]) < 32:  # 如果收到控制字符或者空字符，退出循环\n                break\n            # 返回一个生成器，产出包含Unicode 码位、真正的字符和字符名称的字符串\n            lines = list(index.find_description_strs(query)) \n            if lines:\n                # 使用默认的UTF-8 编码把lines    转换成bytes 对象，并在每一行末添加回车符合换行符\n                # 参数列表是一个生成器\n                writer.writelines(line.encode() + CRLF for line in lines) \n            writer.write(index.status(query, len(lines)).encode() + CRLF) # 输出状态\n\n            await writer.drain()  # 刷新输出缓冲\n            print('Sent {} results'.format(len(lines)))  # 在服务器控制台记录响应\n\n    print('Close the client socket')  # 在控制台记录会话结束\n    writer.close()  # 关闭StreamWriter流\n\n\n\ndef main(address='127.0.0.1', port=2323):  # 添加默认地址和端口，所以调用默认可以不加参数\n    port = int(port)\n    loop = asyncio.get_event_loop()\n    # asyncio.start_server 协程运行结束后，\n    # 返回的协程对象返回一个asyncio.Server 实例，即一个TCP套接字服务器\n    server_coro = asyncio.start_server(handle_queries, address, port,\n                                loop=loop) \n    server = loop.run_until_complete(server_coro) # 驱动server_coro 协程，启动服务器\n\n    host = server.sockets[0].getsockname()  # 获得这个服务器的第一个套接字的地址和端口\n    print('Serving on {}. Hit CTRL-C to stop.'.format(host))  # 在控制台中显示地址和端口\n    try:\n        loop.run_forever()  # 运行事件循环 main 函数在这里阻塞，直到服务器的控制台中按CTRL-C 键\n    except KeyboardInterrupt:  # CTRL+C pressed\n        pass\n\n    print('Server shutting down.')\n    server.close()\n    # server.wait_closed返回一个 future\n    # 调用loop.run_until_complete 方法，运行 future\n    loop.run_until_complete(server.wait_closed())  \n    loop.close()  # 终止事件循环\n\n\nif __name__ == '__main__':\n    main(*sys.argv[1:])\n\n运行 tcp_charfinders.py\npython tcp_charfinders.py\n打开终端，使用 telnet 命令请求服务，运行结果如下所示：\n\nmain 函数几乎会立即显示 Serving on... 消息，然后在调用loop.run_forever() 方法时阻塞。这时，控制权流动到事件循环中，而且一直等待，偶尔会回到handle_queries 协程，这个协程需要等待网络发送或接收数据时，控制权又交给事件循环。\nhandle_queries 协程可以处理多个客户端发来的多次请求。只要有新客户端连接服务器，就会启动一个handle_queries 协程实例。\nhandle_queries 的I/O操作都是使用bytes格式。我们从网络得到的数据要解码，发出去的数据也要编码\nasyncio包提供了高层的流API，提供了现成的服务器，我们只需要实现一个处理程序。详细信息可以查看文档：https://docs.python.org/3/library/asyncio-stream.html\n虽然，asyncio包提供了服务器，但是功能相对来说还是比较简陋的，现在我们使用一下 基于asyncio包的 web 框架 sanci，用它来实现一个http版的简易服务器\nsanic 的简单入门在上一篇文章有介绍，python web 框架 Sanci 快速入门\n使用 sanic 包编写web 服务器\nSanic 是一个和类Flask 的基于Python3.5+的web框架，提供了比较高阶的API，比如路由、request参数，response等，我们只需要实现处理逻辑即可。\n下边是使用 sanic 实现的简易的 字符查询http web 服务：\nfrom sanic import Sanic\nfrom sanic import response\n\nfrom charfinder import UnicodeNameIndex\n\napp = Sanic()\n\nindex = UnicodeNameIndex()\n\nhtml_temp = '<p>{char}</p>'\n\n@app.route('/charfinder')  # app.route 函数的第一个参数是url path，我们这里指定路径是charfinder\nasync def charfinder(request):\n    # request.args 可以取到url 的查询参数\n    # ?key1=value1&key2=value2 的结果是 {'key1': ['value1'], 'key2': ['value2']}\n    # 我们这里支持传入多个查询参数，所以这里使用 request.args.getlist('char')\n    # 如果我们 使用 request.args.get('char') 只能取到第一个参数\n    query = request.args.getlist('char')\n    query = ' '.join(query)\n    lines = list(index.find_description_strs(query))\n    # 将得到的结果生成html\n    html = '\\n'.join([html_temp.format(char=line) for line in lines])\n    return response.html(html)\n\nif __name__ == '__main__':\n    app.run(host=\"0.0.0.0\", port=8000)  # 设置服务器运行地址和端口号\n对比两段代码可以发现，使用 sanic 非常简单。\n运行服务：\npython http_charsfinder.py\n我们在浏览器输入地址 http://0.0.0.0:8000/charfinde... 结果示例如下\n\n现在对比下两段代码\n在TCP 的示例中，服务器通过main函数下的这两行代码创建并排定运行时间：\nserver_coro = asyncio.start_server(handle_queries, address, port,\n                                loop=loop)\nserver = loop.run_until_complete(server_coro)\n而在sanic的HTTP示例中，使用，创建服务器：\napp.run(host=\"0.0.0.0\", port=8000)\n这两个看起来运行方式完全不同，但如果我们翻开sanic的源码会看到 app.run() 内部是调用 的 server_coroutine = loop.create_server()创建服务器，server_coroutine 是通过 loop.run_until_complete()驱动的。\n所以说，为了启动服务器，这两个都是由 loop.run_until_complete 驱动，完成运行的。只不过 sanic 封装了run 方法，使得使用更加方便。\n这里可以得到一个基本事实：只有驱动协程，协程才能做事，而驱动 asyncio.coroutine 装饰的协程有两种方式，使用 yield from 或者传给asyncio 包中某个参数为协程或future的函数，例如 run_until_complete\n现在如果你搜索 cjk，会得到7万多条数据3M 的一个html文件，耗时大约2s，这如果是生产服务的一个请求，耗时2s是不能接收的，我们可以使用分页，这样我们可以每次只取200条数据，当用户想看更多数据时再使用 ajax 或者 websockets发送下一批数据。\n这一篇我们使用 asyncio 包实现了TCP服务器，使用sanic（基于asyncio sanic 默认使用 uvloop替代asyncio）实现了HTTP服务器，用于按名称搜索Unicode 字符。但是并没有涉及服务器并发部分，这部分可以以后再讨论。\n这一篇还是 《流畅的python》asyncio 一章的读书笔记，下一篇将是python并发的第三篇，《使用线程处理并发》。\n参考链接\n\nPython 3.5将支持Async/Await异步编程:http://www.infoq.com/cn/news/2015/05/python-async-await\npython web 框架 Sanci 快速入门\npython并发2：使用asyncio处理并发\n\n最后，感谢女朋友支持。\n\n\n>欢迎关注\n>请我喝芬达\n\n\n\n\n\n\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "9"}