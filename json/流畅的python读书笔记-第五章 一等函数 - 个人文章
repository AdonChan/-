{"title": "流畅的python读书笔记-第五章 一等函数 - 个人文章 ", "index": "python", "content": "高阶函数\n接受函数为参数，或者把函数作为结果返回的函数是高阶函数\n    def reverse(word):\n        return word[::-1]\n    \n    \n    fruits = ['strawberry', 'fig', 'apple', 'cherry', 'raspberry', 'banana']\n    \n    print(reverse('testing'))\n    \n    print(sorted(fruits, key=reverse))\nall 和 any 也是内置的归约函数。\nall(iterable)\n如果 iterable 的每个元素都是真值，返回 True；all([]) 返回True。\nany(iterable)\n只要 iterable 中有元素是真值，就返回 True；any([]) 返回False。\n匿名函数\nfruits = ['strawberry', 'fig', 'apple', 'cherry', 'raspberry', 'banana']\n\nprint(sorted(fruits, key=lambda word: word[::-1]))\n\n可调用对象\n如果类定义了 call 方法，那么它的 实例 可以作为函数调用。\n因此判断对象能否调用，最安全的方法是使用内置的 callable() 函数\n实现 call 方法的类是创建函数类对象的简便方式，\n函数内省\n用户定义的函数的属性 page 252\n案例 生成html标签的函数\ndef tag(name, *content, cls=None, **attrs):\n    \"\"\"生成一个或多个HTML标签\"\"\"\n\n    if cls is not None:\n        attrs['class'] = cls\n\n    if attrs:\n        attr_str = ''.join(' %s=\"%s\"' % (attr, value)\n                           for attr, value\n                           in sorted(attrs.items()))\n    else:\n        attr_str = ''\n\n    if content:\n        return '\\n'.join('<%s%s>%s</%s>' % (name, attr_str, c, name) for c in content)\n    else:\n        return '<%s%s />' % (name, attr_str)\n\n\nprint(tag('br'))\n\nprint(tag('p', 'hello'))\n\nprint(tag('p', 'hello', 'world'))\n\nprint(tag('p', 'hello', 'world', cls='sidebar')) \n获取关于参数的信息\nimport bobo\n@bobo.query('/')\ndef hello(person):\nreturn 'Hello %s!' % person\nbobo.query 装饰器把一个普通的函数（如 hello）与框架的请求处理机制集成起来了。\nBobo 会内省 hello 函数，发现它需要一个名为 person的参数，然后从请求中获取那个名称对应的参数，将其传给 hello 函数，因此程序员根本不用触碰请求对象。\n提取关于函数参数的信息\n使用 inspect 模块\nfrom clip import clip\nfrom inspect import signature\nsig = signature(clip)\n\nprint(sig)\n\n\nprint(str(sig))\n\nfor name, param in sig.parameters.items():\n    print(param.kind, ':', name, '=', param.default)\n\ninspect.signature 函数返回一个inspect.Signature 对象\n\n它有一个 parameters 属性，这是一个有序映射，\n把参数名和 inspect.Parameter 对象对应起来。\n各个Parameter 属性也有自己的属性，\n例如 name、default 和 kind。特殊的 inspect._empty 值表示没有默认值\n\nkind 属性的值是 _ParameterKind 类中的 5 个值之一，列举如下。\n\n\nPOSITIONAL_OR_KEYWORD\n可以通过定位参数和关键字参数传入的形参（多数 Python 函数的参数属于此类）。\n\n\nVAR_POSITIONAL\n定位参数元组。\n\n\nVAR_KEYWORD\n关键字参数字典。\n\n\nKEYWORD_ONLY\n仅限关键字参数（Python 3 新增）。\n\n\nPOSITIONAL_ONLY\n仅限定位参数；\n\n\ninspect.Signature 对象有个 bind 方法，\n它可以把任意个参数绑定到签名中的形参上，所用的规则与实参到形参的匹配方式一样。框架可以使用这个方法在真正调用函数前验证参数，\n示例 5-18 把tag 函数（见示例 5-10）的签名绑定到一个参数字典上\n>>> import inspect\n>>> sig = inspect.signature(tag) ➊\n>>> my_tag = {'name': 'img', 'title': 'Sunset Boulevard',\n... 'src': 'sunset.jpg', 'cls': 'framed'}\n>>> bound_args = sig.bind(**my_tag) ➋\n>>> bound_args\n<inspect.BoundArguments object at 0x...> ➌\n>>> for name, value in bound_args.arguments.items(): ➍\n... print(name, '=', value)\n...\nname = img\ncls = framed\nattrs = {'title': 'Sunset Boulevard', 'src': 'sunset.jpg'}\n>>> del my_tag['name'] ➎\n>>> bound_args = sig.bind(**my_tag) ➏\nTraceback (most recent call last):\n...\nTypeError: 'name' parameter lacking default value\n❷ 把一个字典参数传给 .bind() 方法。❸ 得到一个 inspect.BoundArguments 对象。❹ 迭代 bound_args.arguments（一个 OrderedDict 对象）中的元素，显示参数的名称和值。❺ 把必须指定的参数 name 从 my_tag 中删除。❻ 调用 sig.bind(**my_tag)，抛出 TypeError，抱怨缺少 name 参数。\n函数注解\ndef clip(text: str, max_len: 'int > 0' = 80) -> str:\n    print(text, max_len)\n\n\nclip(\"sdf\", 18)\n\nprint(clip.__annotations__)\n\n如果想注解返回值，在 ) 和函数声明末尾的 : 之间添加 -> 和一个表达式。\n各个参数可以在 : 之后增加注解表达式。如果参数有默认值，注解放在参数名和 = 号之间。\n\n注解不会做任何处理，只是存储在函数的 annotations 属性（一个字典）中：\noperator模块\nreduce计算阶乘\nfrom functools import reduce\n\n\n# 阶乘\ndef fact(n):\n    print(reduce(lambda a, b: a * b, range(1, n + 1)))\n\n\n# operator.mul 函数计算阶乘\nfrom functools import reduce\nfrom operator import mul\n\n\ndef fact2(n):\n    return reduce(mul, range(1, n + 1))\n\nprint(fact2(3))\nitemgetter\n展示了 itemgetter 的常见用途：根据元组的某个字段给元组列表排序。在这个示例中，按照国家代码（第 2 个字段）的顺序打印各个城市的信息。\nmetro_data = [\n    ('Tokyo', 'JP', 36.933, (35.689722, 139.691667)),\n    ('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)),\n    ('Mexico City', 'MX', 20.142, (19.433333, -99.133333)),\n    ('New York-Newark', 'US', 20.104, (40.808611, -74.020386)),\n    ('Sao Paulo', 'BR', 19.649, (-23.547778, -46.635833)),\n]\n\n### 演示使用 itemgetter 排序一个元组列表\n\nfrom operator import itemgetter\n\nfor city in sorted(metro_data, key=itemgetter(1)):\n    print(city)\n如果把多个参数传给 itemgetter，它构建的函数会返回提取的值构成的元组：\ncc_name = itemgetter(1, 0)\nfor city in metro_data:\n    print(cc_name(city))\nattrgetter\n此外，如果参数名中包含 .（点号），attrgetter 会深入嵌套对象，获取指定的属性。\nfrom collections import namedtuple\n\nmetro_data = [\n    ('Tokyo', 'JP', 36.933, (35.689722, 139.691667)),\n    ('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)),\n    ('Mexico City', 'MX', 20.142, (19.433333, -99.133333)),\n    ('New York-Newark', 'US', 20.104, (40.808611, -74.020386)),\n    ('Sao Paulo', 'BR', 19.649, (-23.547778, -46.635833)),\n]\n\n## 就像数据格式化一样 数据带上标签\nLatLong = namedtuple('LatLong', 'lat long')\n\nMetropolis = namedtuple('Metropolis', 'name cc pop coord')\n\nmetro_areas = [Metropolis(name, cc, pop, LatLong(lat, long))\n               for name, cc, pop, (lat, long) in metro_data]\n\nprint(metro_areas[0])\nprint(metro_areas[0].coord.lat)\n\n#\nfrom operator import attrgetter\n\nname_lat = attrgetter('name', 'coord.lat')\n\nfor city in sorted(metro_areas, key=attrgetter('coord.lat')):\n    print(name_lat(city))\n\nmethodcaller 自行创建函数\n它会自行创建函数。methodcaller 创建的函数会在对象上调用参数指定的方法自己创建函数\nfrom operator import methodcaller\ns = 'The time has come'\nupcase = methodcaller('upper')\n\nprint(upcase)\n\nhiphenate = methodcaller('replace', ' ', '-')\nprint(hiphenate(s))\nfunctools.partial冻结参数\nfunctools.partial 这个高阶函数用于部分应用一个函数。部分应用是指，基于一个函数创建一个新的可调用对象，把原函数的某些参数固定。\nfrom operator import mul\nfrom functools import partial\n\nprint(mul(3, 7))\n# 第一个函数, 第二个固定的参数\ntriple = partial(mul, 3)\nprint(list(map(triple, range(1, 10))))\n\n小总结\n高阶函数\n\n接受函数为参数，或者把函数作为结果返回的函数是高阶函数.\nPython 中常用的高阶函数有内置函数\nsorted、min、max 和 functools. partial\n\n实例 直接函数化运行\n\n从 lambda 表达式创建的简单函数到实现__call__ 方法的类实例。\n这些可调用对象都能通过内置的callable() 函数检测。\n\n函数注解\n\n在 inspect 模块的帮助下，可以读取它们。\n例如，Signature.bind 方法使用灵活的规则把实参绑定到形参上，这与 Python 使用的规则一样。\n\noperator 模块\n\n介绍了 operator 模块中的一些函数，\n以及functools.partial 函数，\n有了这些函数，函数式编程就不太需要功能有限的 lambda 表达式了\n\n其他\n\nall 和 any 也是内置的归约函数.\n用来判断是否所有都为真,或者有一个为真\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}