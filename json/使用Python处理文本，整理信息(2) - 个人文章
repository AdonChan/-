{"title": "使用Python处理文本，整理信息(2) - 个人文章 ", "index": "python", "content": "处理思科设备 show inventory输出内容\n任务目标\n通过Python读取show inventory的内容，并将设备的槽位、模块型号和序列号自动写入CVS文件。否则，我需要打开每一个文件，找到设备每一个槽位、母卡、子卡和序列号，并一一填写到表格中。操作繁琐且重复，因此考虑用Python实现。\nshow inventory 输出内容示例\nRP/0/RP0/CPU0:crs-1#admin show inventory \nThu Jul XX 16:08:46.990 GMT\nNAME: \"0/1/*\", DESCR: \"Cisco CRS Series Modular Services Card 400G\"\nPID: CRS-MSC-X, VID: V03, SN: CAT20XXXX0J\n\nNAME: \"ControlEthernet0/1/CPU0\", DESCR: \"CPU_PORT_0\"\nPID:    , VID: N/A, SN: \n\nNAME: \"0/PL1/*\", DESCR: \"Cisco CRS Series 4x100GbE Interface Module\"\nPID: 4X100GE-LO, VID: V01, SN: CATXXXXT00W\n\nNAME: \"HundredGigE0/1/0/0\", DESCR: \"100GBASE-LR4\"\nPID: CPAK-100G-LR4  , VID: V04, SN: FBNXXXX0141\n\nNAME: \"HundredGigE0/1/0/1\", DESCR: \"100GBASE-LR4\"\nPID: CPAK-100G-LR4  , VID: V04, SN: FBNXXXX0582\n\nNAME: \"HundredGigE0/1/0/2\", DESCR: \"100GBASE-LR4\"\nPID: CPAK-100G-LR4  , VID: V04, SN: FBNXXXX0546\n\nNAME: \"HundredGigE0/1/0/3\", DESCR: \"100GBASE-LR4\"\nPID: CPAK-100G-LR4  , VID: V04, SN: FBNXXXX0340\n\nNAME: \"0/4/*\", DESCR: \"Cisco CRS-1 Series Modular Services Card revision B\"\nPID: CRS-MSC-B, VID: V07, SN: SADXXXX020C\n\nNAME: \"ControlEthernet0/4/SP\", DESCR: \"CPU_PORT_0\"\nPID:    , VID: N/A, SN: \n\nNAME: \"ControlEthernet0/4/CPU0\", DESCR: \"CPU_PORT_1\"\nPID:    , VID: N/A, SN: \n\nNAME: \"0/PL4/*\", DESCR: \"Cisco Carrier Routing System SPA Interface Processor Card\"\nPID: CRS1-SIP-800, VID: V04, SN: SALXXXXGX57\n\nNAME: \"0/4/0\", DESCR: \"1-port OC192/STM64 POS/RPR XFP Optics\"\nPID: SPA-OC192POS-XFP, VID: V05, SN: SALXXXXFAN0\n\nPython代码的实现\n# 引入re、csv模块\nimport re\nimport csv\n\n# 将待处理的文件读入data_buff。\nwith open(inventory) as file_obj:\ndata_buff = file_obj.read()\n\n# 定义几个正则表达式对象如下：\nmixRegex = re.compile(r'^NAME: .*\\n'\nr'^PID: .*SN: .*'\n,re.MULTILINE)\nmix_match = mixRegex.findall(data_buff)\n\nnameRegex = re.compile('^NAME: .*,')\nmodRegex = re.compile('^PID: .*,',re.MULTILINE)\nsnRegex = re.compile('SN: .*',re.MULTILINE)\n\n# 以上几个正则表达式的目的如下：\n# mixRegex，该表达式匹配以”NAME:”开头，并且，第二行以”PID:”开头，包含”SN:”。\n# 通过findall函数找到所有符合上述要求的文本内容，并赋值给mix_match，通过打印，该值是一个list，每一个匹配项作为一个列表单元。\n# nameRegex、modRegex和snRegex分别在以下代码中进行过滤\n# 初始化两个列表，其中一个作为子列表，最终形成一个二维列表。\nslot_map = []\nsub_map = []\n\n# for循环遍历上述的查找结果mix_match；\n# 通过nameRegex查找出来的内容，使用group()访问，并将”NAME: ”剥去，就变成槽位信息了。字符最后多一个”””是为了防止Excel表自动的把0/4/0改成日期。len(slot) < 10，是去除一些不需要统计的内容，如\"ControlEthernet0/4/SP\"。\n# 通过modRegex查找出来的内容，经过处理后就变成PID信息了。\n# 通过snRegex查找出来的内容，经过处理就变成SN信息了。\n# 然后分别把这些信息存入list sub_map中，再存到slot_map，变为二维表。\n\nfor each_pair in mix_match:\nslot = nameRegex.search(each_pair).group()[7:-1]\nif len(slot) < 10:\n        card = modRegex.search(each_pair).group().split(',')[0][5:].strip()\n        sn = snRegex.search(each_pair).group()[4:]\n        # print(sn)\n        sub_map.append(slot)\n        sub_map.append(card)\n        sub_map.append(sn)\n        slot_map.append(sub_map)\n        # print(sub_map)\n    sub_map = []\n\n# 以下代码将上述生成的二维列表写入到CSV文件中。\ncsv_output = inventory + '-slotmap.csv'\n\nwith open(csv_output,'w') as file_obj:\n    wr = csv.writer(file_obj)\n    for list in slot_map:\n        wr.writerow(list)\n\n前一篇文章写了处理show ip int brief输出。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "1"}