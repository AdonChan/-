{"title": "226. Invert Binary Tree - 卢卡斯 ", "index": "python,leetcode", "content": "题目链接：Invert Binary Tree\n思路：如果需要反转一个二叉树，那么我们需要遍历整个树的所有节点。如果想遍历所有的节点，我们可以用Depth First Search(DFS)或者Breadth First Search(BFS)。这两种办法分别可以用迭代(iterative)或者递归(recursive)的办法实现。\n算法复杂度：\n递归：\n时间：O(n) where n is the number of nodes\n空间：O(n)\n\nDFS/BFS：\n时间：O(n) where n is the number of nodes\n空间：O(n)\n\n代码：\n递归：\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        if root:\n            root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)\n        return root\n\n\nDFS (Stack):\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        stack = [root]\n        while stack:\n            node = stack.pop()\n            if node:\n                node.left, node.right = node.right, node.left\n                stack.extend([node.right, node.left])\n        return root\n\nBFS (Queue):\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        queue = [root]\n        while queue:\n            node = queue.pop(0)\n            if node:\n                node.left, node.right = node.right, node.left\n                queue.extend([node.left, node.right])\n        return root\n\n\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}