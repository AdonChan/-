{"title": "Python基础之(二)字符串_列表_元组 - 再读斋 ", "index": "python", "content": "Python字符串\n在Python中，万物皆对象，显然字符串是对象类型，用str表示。字符串类型通常用单引号或者双引号包裹起来。\n>>> \"Hello,world\"\n'Hello,world'\n>>> 'Hello,world'\n'Hello,world'\n>>> type(\"Hello,world\")\n<type 'str'>\n>>> \n变量和字符串\n在Python中变量无类型，对象有类型\n>>> b = \"hello,world\"\n>>> b\n'hello,world'\n\n>>> print b\nhello,world\n\n>>> type(b)\n<type 'str'>\n\n连接字符串\n>>> \"py\" + \"thon\"\n'python'\n>>> \n\n>>> a = 1989\n>>> b = \"free\"\n>>> print a + b\n\nTraceback (most recent call last):\n  File \"<pyshell#195>\", line 1, in <module>\n    print a + b\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\n\n>>> print b + `a` #反引号将整数a转化为字符串\nfree1989\n>>> \n用“+”拼接起来的字符串的两个对象必须是同一类型的。如果是数字则是求和，如果是字符串则得到一个新的字符串。\n还有其他两种方法可以将整数转化为字符串：\nstr():将整数对象转换为字符串对象\n>>> print b + str(a)\nfree1989\nrepr():相当于反引号``\n>>> print b + repr(a)\nfree1989\nint():将字符串对象转换为整数对象\n>>> a = \"250\"\n>>> b = int(a)\n>>> b\n250\n>>> type(b)\n<type 'int'>\n>>> \n转义字符\n在字符串中，总会有一些特殊的符号，就需要用转义符。所谓转义，就是不采用符号本来的含义，而采用另外一含义。下面表格中列出常用的转义符：\n\n\n转义字符\n描述\n\n\n\n\\\n(在行尾时) 续行符\n\n\n\\\n反斜杠符号\n\n\n'\n单引号\n\n\n\"\n双引号\n\n\na\n响铃\n\n\nb\n退格(Backspace)\n\n\ne\n转义\n\n\n000\n空\n\n\nn\n换行\n\n\nv\n纵向制表符\n\n\nt\n横向制表符\n\n\nr\n回车\n\n\nf\n换页\n\n\noyy\n八进制数，yy代表的字符，例如：o12代表换行\n\n\nxyy\n十六进制数，yy代表的字符，例如：x0a代表换行\n\n\nother\n其它的字符以普通格式输出\n\n\n\n原始字符串\n用转义符能够让字符串中的某些符号表示原来的含义，而不是被解析成某种具有特别能力的符号。下面看看这个代码：\n>>> dos = \"c:\\news\"\n>>> dos\n'c:\\news'\n>>> print dos #当用print打印时就出现问题了\nc:\news\n如何避免上述代码的问题？有两种方法，其一是前面介绍的转义符解决。\n>>> dos = \"c:\\\\news\"\n>>> print dos\nc:\\news\n>>> \n其二是声明为原始字符串\n>>> dos = r\"c:\\news\"\n>>> print dos\nc:\\news\n>>> dos = r\"c:\\news\\python\"\n>>> print dos\nc:\\news\\python\n如r\"c:news\"，由r开头引起的字符串就是声明了后面引号里的东西是原始字符串，在里面放任何字符都表示该字符的原始含义，不需要再用转义符了。\nraw_input和print\n下面实现接收和打印用户通过键盘输入的内容：\n不过在写这个功能前，要了解函数：\n\nPython 2：raw_input()\nPython 3: input()\n\n这是Python的内建函数（built-in function）。关于内建函数，可以分别通过下面的链接查看：\n\nPython 2的内建函数\nPython 3的内建函数\n\n关于Python的内建函数，下面列出来，供参考：\nabs()    divmod()    input()    open()    staticmethod()\nall()    enumerate()    int()    ord()    str()\nany()    eval()    isinstance()    pow()    sum()\nbasestring()    execfile()    issubclass()    print()    super()\nbin()    file()    iter()    property()    tuple()\nbool()    filter()    len()    range()    type()\nbytearray()    float()    list()    raw_input()    unichr()\ncallable()    format()    locals()    reduce()    unicode()\nchr()    frozenset()    long()    reload()    vars()\nclassmethod()    getattr()    map()    repr()    xrange()\ncmp()    globals()    max()    reversed()    zip()\ncompile()    hasattr()    memoryview()    round()    __import__()\ncomplex()    hash()    min()    set()    \ndelattr()    help()    next()    setattr()    \ndict()    hex()    object()    slice()    \ndir()    id()    oct()    sorted()\n怎么才能知道哪个函数怎么用，并且用来干什么的呢？\n\nhelp(abs)命令\nPython的官网https://docs.python.org/2/library/functions.html\nraw_input\n\n>>> raw_input(\"input your name: \")\ninput your name: michael\n'michael'\n>>> name = raw_input(\"input your name: \")\ninput your name: michael\n>>> name\n'michael'\n>>> type name\nSyntaxError: invalid syntax\n>>> type(name)\n<type 'str'>\n>>> age = raw_input(\"How old are you? \");\nHow old are you? 25  #输入数字\n>>> age\n'25'\n>>> type(age)\n<type 'str'>  #返回仍是str类型\nprint\n>>> print \"Hello, world\"\nHello, world\n>>> a = \"python\"\n>>> print a\npython\n>>> b = \"good\"\n>>> print a,b\npython good\n>>> \n特别提醒的是，print的返回值默认是以n结尾的，所以每个输出语句之后自动换行。\n索引和切片\n索引\n在Python中，把像字符串这样的对象类型统称为序列，顾名思义，序列就是有序排列。在这个序列中，每个人都有编号，编号和每个字符一一对应，在Python中这些编号称为索引。\n>>> lang = \"study python\"\n>>> lang[0]\n's'\n>>> lang[1]\n't'\n也可以这样做：\n>>> \"study python\"[0]\n's'\n>>> \"study python\"[1]\n't'\n>>> \n通过字符找到其在字符串中的索引值：\n>>> lang = \"study python\"\n>>> lang.index(\"p\")\n6\n>>> lang.in\nSyntaxError: invalid syntax\n>>> lang.index(\"y\")\n4\n切片\n不管是得到一个字符还是多个字符，通过索引得到字符的过程称为切片。\n>>> lang = \"study python\"\n\n>>> lang[2:9] #得到从2号到9号之间的字符串（包括2号但不包括9号）\n'udy pyt'\n>>> b = lang[1:] #得到从1号到最末尾的字符\n>>> b\n'tudy python'\n>>> c = lang[:] #得到所有的字符\n>>> c\n'study python'\n>>> d = lang[:10] #得到从0到10号之前的字符\n>>> d\n'study pyth'\n>>> lang[1:12] \n'tudy python'\n>>> lang[0:13] #如果第二个数字的长度大于字符串的长度，得到的返回结果就自动到最大长度终止，但是这种获得切片的方法是值得提倡的。特别是如果在循环中，这样做很可能会遇到麻烦。\n'study python'\n>>> lang[0:14]\n'study python\n如果在切片的时候，冒号左右都不写数字，就是前面所操作的c = lang[:],其结果是变量的值c与源字符串lang一样，即复制了一份，那是不是真的复制呢？下面的方式检验一下：\n>>> id(c)\n44841944\n>>> id(lang)\n44841944\n从上面可以看出,两个内存地址一样，说明c和lang两个变量指向的是同一个对象。用c = lang[:]的方式并没有生成一个新的字符串，而是将变量c这个标签页贴在原来那个字符串上了。\n>>> lang = \"study python\"\n>>> c = lang\n>>> id(c)\n50456160\n>>> id(lang)\n50456160\n上述这种情况，变量c和lang也指向同一个对象。\n基本操作\n所有序列都有如下操作，字符串是序列的子集。\n\nlen():返回序列长度\n+:连接两个序列\n*:重复序列元素\nin: 判断元素是否存在于序列中\nmax():返回最大值\nmin():返回最小值\ncmp(str1,str2): 比较两个序列值是否相同\n\n\"+\"连接字符串\n>>> str1 = \"study\"\n>>> str2 = \"python\"\n>>> str1 + str2\n'studypython'\n>>> str1 + \"-->\" + str2\n'study-->python'\nin\nin用来判断某个字符串是不是在另外一个字符串内，或者判断某个字符串内是否包含某个字符串，包含则返回True，否则返回false。\n>>> str = \"study python\"\n>>> \"s\" in str\nTrue\n>>> \"i\" in str\nFalse\n>>> \"su\" in str\nFalse\n>>> \"stu\" in str\nTrue\n>>> \nmax()\nstr = \"python\"max(str)\n'y'\nmin()\n>>> str = \"python\"\n'y'\n>>> min(str)\n'h'\ncmp()\n将两个字符串进行比较，首先将字符串中的符号转化为对应的数字，然后再比较\n\n如果返回的数值小于0，说明前者小于后者\n等于0，表示两者相等\n大于0，表示前者大于后者\n\n>>> cmp(\"aaa\",\"abc\")  #\n-1\n>>> cmp(\"abc\",\"aaa\");\n1\n>>> cmp(\"abc\",\"abc\");\n0\n>>> ord(\"a\") #返回字符的ASCII值\n97\n>>> chr(97)  #返回ASCII值所对应的字符\n'a'\n\"*\"\n以指定的次数重复打印字符串\n>>> str = \"python\"\n>>> str * 4\n'pythonpythonpythonpython'\n>>> print \"-\" * 20\n--------------------\nlen()\nlen()返回字符串的长度，返回值类型是int型\n>>> a = \"hello\"\n>>> m = len(a)\n>>> m\n5\n>>> type(m)\n<type 'int'>\n>>> \n常用的字符串方法\n字符串的方法有很多，可以通过dir来查看：\n>>> dir(str)\n['__add__', '__class__', '__contains__', '__delattr__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__getslice__', '__gt__', '__hash__', '__init__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '_formatter_field_name_split', '_formatter_parser', 'capitalize', 'center', 'count', 'decode', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'index', 'isalnum', 'isalpha', 'isdigit', 'islower', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']\n判断字符串是否全是字母\n>>> \"python\".isalpha()  #字符串全是字母，返回TRUE\nTrue\n>>> \"2python\".isalpha() #字符串含有非字母，返回FALSE\nFalse\n>>> \n分割字符串\nsplit()作用是将字符串根据某个分隔符进行分割。\n>>> str = \"I love Beijing\"\n>>> str.split(\" \")\n['I', 'love', 'Beijing']  #返回值为名叫列表（list）的类型\n>>> str = \"www.baidu.com\"\n>>> str.split(\",\")\n['www', 'baidu', 'com']\n>>> \n去掉字符串两头的空格\n>>> str = \"  python  \"\n>>> str.strip()  #去掉字符串左右空格\n'python'\n>>> str.lstrip() #去掉字符串左边空格\n'python  '\n>>> str.rstrip() #去掉字符串右边空格\n'  python'\n>>> \n字符大小写转换\n>>> str = \"pyThon\" \n>>> str.upper() #将小写字母完全变为大写字母\n'PYTHON'\n>>> str.lower() #将大写字母完全变成小写字母\n'python'\n\n>>> str.isupper() #判断是否全是大写字母\nFalse\n>>> str.islower() #判断是否全是小写字母\nFalse\n>>> str = \"this is book\"\n>>> str.capitalize() #把所有单词的第一个字母转化为小写字母\n'This is book'\n>>> str.istitle() #判断每个单词的第一个字母是否为大写字母\nFalse\n>>> \njoin连接字符串\n>>> b = \"www.baidu.com\"\n>>> c = b.split(\".\")\n>>> c\n['www', 'baidu', 'com']\n>>> \".\".join(c)\n'www.baidu.com'\n>>> \"**\".join(c)\n'www**baidu**com'\n字符串格式化输出\n使用占位符\n>>> \"I like %s\" % \"Python\" #%s表示字符串\n'I like Python'\n>>> \"%d years old\" % 25 #%d表示整数\n'25 years old'\n\"I like 'python'\"\n>>> \"%s is %d years old\" % (\"deason\",25)\n'deason is 25 years old'\n\n%s 字符串（采用str()的显示）\n%r 字符串（采用repr（）的显示）\n%c 单个字符\n%b 二进制整数\n%d 十进制整数\n%e 指数（底数为e）\n%f 浮点数\n\n使用format格式化\n{}作为占位符\n>>> str = \"I like {}\".format(\"python\");\n>>> str\n'I like python'\n>>> str = \"{0} is {1} years old\".format(\"michael\",25)\n>>> str\n'michael is 25 years old'\n字典式格式化\n>>> lang = \"python\"\n>>> print \"I love %(program)s\" %{\"program\":lang}\nI love python\n>>> print \"I love %(program)s\" %{\"program\":\"python\"}\nI love python\n综上，推荐使用:string.format()\nPython列表\n此前已经知道了Python的三种对象类型：int、float和str。下面开始学习一种新的Python对象类型：list。list在Python中具有非常强大的功能。\n定义\n在Python中，用方括号表示一个list：[]，方括号里面的元素类型，可以是int型数据，也可以是str类型的数据，甚至也可以是bool类型数据。而像Java语言，数组里面只能存在一种类型的数据。\n>>> a=[]  #定义了一个空的列表，变量a相当于一个贴在其上的标签\n>>> type(a)  #用内置函数type()查看变量a引用对象的类型，为list\n<type 'list'>\n>>> bool(a) #用内置函数bool()查看a的布尔值，因为是空，所以为False\nFalse\n>>> print a\n[]\n下面看看list具体的使用\n>>> a=['a',3,'hello',True]  #list中可以有多中数据类型\n>>> a\n['a', 3, 'hello', True]\n>>> type(a)\n<type 'list'>\n>>> bool(a)\nTrue\n>>> print a\n['a', 3, 'hello', True]\n>>> a[3]\nTrue\n>>> type(a[3])\n<type 'bool'>\n索引和切片\n索引\n和字符串中的索引类似，只不过list是以元素为单位，而不是以字符为单位进行索引。\n>>> a=[2,3,True,\"Hello,world\"]\n>>> a\n[2, 3, True, 'Hello,world']\n>>> a[0]\n2\n>>> a[1]\n3\n>>> a[2]\nTrue\n>>> a[3]\n'Hello,world'\n>>> type(a[0])\n<type 'int'>\n>>> type(a[2])\n<type 'bool'>\n>>> type(a[3])\n<type 'str'>\n\n>>> a.index(2)\n0\n>>> a.index(3)\n1\n>>> a.index(True)\n2\n>>> a.index(\"Hello,world\")\n3\n>>> \n\n切片\n>>> lst = ['python','java','c++']\n>>> lst[-1]\n'c++'\n>>> lst[-3:-1]\n['python', 'java']\n>>> lst[-1:-3]\n[]\n>>> lst[0:3]\n['python', 'java', 'c++']\n>>> \n序列的切片，一定要左边的数字小于右边的数字，lst[-1:-3]就没有遵守这个规则，返回的是一个空。\n反转\n>>> mList = [1,2,3,4,5,6]\n>>> mList[::-1]\n[6, 5, 4, 3, 2, 1]\n>>> m\n>>> mList\n[1, 2, 3, 4, 5, 6]\n>>> \n\n当然，也可以对字符串进行反转:\n>>> lang=\"python\"\n>>> lang[::-1]\n'nohtyp'\n>>> lang\n'python'\n可以看出，不管是str还是list，反转之后原来的值没有改变。这说明，这里的反转不是把原来的值倒过来，而是新生成了一个值，生成的值跟原来的值相比是倒过来的。\nPython还有一种方法使list反转，且比较容易阅读和理解，特别推荐：\nmList = [1,2,3,4,5,5,6,8,7]\n>>> list(reversed(mList))\n[7, 8, 6, 5, 5, 4, 3, 2, 1]\n\n>>> s='abcd'\n>>> list(reversed(s))\n['d', 'c', 'b', 'a']\n'abcd'\n对list的操作\nlen()\n>>> lst=['python','java','c++']\n>>> len(lst)\n3\n+,连接连个序列\n>>> lst=['python','java','c++']\n>>> lst\n['python', 'java', 'c++']\n>>> alst =[1,2,3,4,5]\n>>> lst + alst\n['python', 'java', 'c++', 1, 2, 3, 4, 5]\n*,重复元素\n>>> lst * 3\n['python', 'java', 'c++', 'python', 'java', 'c++', 'python', 'java', 'c++']\nin\n>>> 'python' in lst\nTrue\nmax()和min()\n>>> max(alst)\n5\n>>> min(alst)\n1\n>>> max(lst)\n'python'\n>>> min(lst)\n'c++'\ncmp()\n>>> a = [2,3]\n>>> b = [2,4]\n>>> cmp(a,b)\n-1\n>>> cmp(b,a)\n1\n>>> c=[2]\n>>> cmp(a,c)\n1\n>>> d=['2']\n>>> cmp(a,d)\n-1\n追加元素\n>>> lst\n['python', 'java', 'c++']\n>>> lst.append(\"html5\") #将元素追加到list的尾部\n>>> lst\n['python', 'java', 'c++', 'html5']\n>>> lst.append(100)\n>>> lst\n['python', 'java', 'c++', 'html5', 100]\n等价于：\n>>> lst\n['python', 'java', 'c++', 'html5', 100]\n>>> lst[len(lst):] = [3]\n>>> lst\n['python', 'java', 'c++', 'html5', 100, 3]\n>>> len(lst)\n6\n>>> lst[6:]=['javascript']\n>>> lst\n['python', 'java', 'c++', 'html5', 100, 3, 'javascript']\n列表的函数\nlist是Python中的苦力，那么它都有哪些函数呢？\n>>> dir(list)\n['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__delslice__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getslice__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__setslice__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']\n\n先不管以双下划线开始和结尾的函数，就剩下以下几个\n'append', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort'\nappend和extend\nlist.append(x),是将某个元素x添加到已知的一个列表的尾部。\nlist.extend(L),则是将两个列表合并，或者说将列表L追加到列表list中。\n>>> a=[1,2,3]\n>>> b=[\"lau\",3,4,5]\n>>> a.extend(b)\n>>> a\n[1, 2, 3, 'lau', 3, 4, 5]\n>>> b\n['lau', 3, 4, 5]\n>>> a=[1,2,3]\n>>> b=\"abc\"\n>>> a.extend(b)\n>>> a\n[1, 2, 3, 'a', 'b', 'c']\n>>> c = 5\n>>> a.extend(c) \n\nTraceback (most recent call last):\n  File \"<pyshell#20>\", line 1, in <module>\n    a.extend(c)\nTypeError: 'int' object is not iterable\n如果extend的参数对象是数值型则报错。所以，extend的参数对象是一个list，如果是str，则Python会先把它按照字符为单位转化为list再添加到目标list中。官方文档指出extend的元素对象必须是iterable（可迭代的）。\n判断一个对象是不是可迭代的？\n>>> s=\"python\"\n>>> hasattr(s,'__iter__')\nFalse\n>>> a=[1,2,3]\n>>> hasattr(a,'__iter__')\nTrue\n通过内建函数hasattr()判断一个对象是不是可迭代的，它的判断本质就是看那个类型中是否有__iter__函数。\nappend和extend函数的相同点\n>>> a=[1,2,3]\n>>> b=[4,5,6]\n>>> id(a)\n49822856\n>>> id(b)\n50066536\n>>> a.extend(b)\n>>> a\n[1, 2, 3, 4, 5, 6]\n>>> id(a)\n49822856\n>>> a=[1,2,3]\n>>> id(a)\n50068376\n>>> a.append(12)\n>>> a\n[1, 2, 3, 12]\n>>> id(a)\n50068376\n由上面两段代码可知，append和extend函数的共同点：\n\n都是原地址修改列表，不会创建一个新的列表\n没有返回值\n\nappend和extend函数的不同点\n>>> lst=[1,2,3]\n>>> lst.append([\"python\",\"java\"])\n>>> lst\n[1, 2, 3, ['python', 'java']]\n>>> len(lst)\n4\n\n>>> \n>>> lst2=[1,2,3]\n>>> lst2.extend([\"python\",\"java\"])\n>>> lst2\n[1, 2, 3, 'python', 'java']\n\n>>> len(lst2)\n5\n可知，append是整体的追加，extend是单个的追加\ncount\ncount的作用是计算某个元素在该list中出现的次数\n>>> a=[1,2,1,1,1]\n>>> a.count(1)\n4\n>>> a.append('a')\n>>> a.append('a')\n>>> a\n[1, 2, 1, 1, 1, 'a', 'a']\n>>> a.count('a')\n2\n>>> a.count(4) #不存在，则返回为0\n0\nindex\nindex计算元素在该列表首次出现的位置\n>>> a=[1,2,3,4,4,5]\n>>> a.index(4)\n3\n>>> a.index(6) #如果不存，就报错\n\nTraceback (most recent call last):\n  File \"<pyshell#85>\", line 1, in <module>\n    a.index(6)\nValueError: 6 is not in list\ninsert\nlist.insert(i,x),想列表中指定的位置插入元素x。\n>>> a=[1,2,3,4,5]\n>>> a.insert(0,0)\n>>> a\n[0, 1, 2, 3, 4, 5]\n>>> a.insert(3,7)\n>>> a\n[0, 1, 2, 7, 3, 4, 5]\n>>> a.insert(8,4)  #若超出列表长度，则将元素插入到列表末尾\n>>> a\n[0, 1, 2, 7, 3, 4, 5, 4]\npop和remove\n删除列表中元素的方法有两个，分别是：\nlist.remove(x)\n删除列表中首次出现的元素x，如果不存在元素x，则报错\n>>> a\n[0, 1, 2, 7, 3, 4, 5, 4]\n>>> a.remove(4)\n>>> a\n[0, 1, 2, 7, 3, 5, 4]\n>>> a.remove(6)\n\nTraceback (most recent call last):\n  File \"<pyshell#103>\", line 1, in <module>\n    a.remove(6)\nValueError: list.remove(x): x not in list\nlist.pop([i])\n删除列表中位置i的元素并且返回该元素。如果没有指定位置i，则默认删除并返回列表的最后一个元素。\n>>> a.pop(0) #删除指定位置0\n0\n>>> a\n[1, 2, 7, 3, 5, 4]\n>>> a.pop() #删除默认位置\n4  \n>>> a\n[1, 2, 7, 3, 5]\n\n>>> a.pop(5) #超过列表长度则会报错\n\nTraceback (most recent call last):\n  File \"<pyshell#116>\", line 1, in <module>\n    a.pop(5)\nIndexError: pop index out of range\nreverse\n将列表的元素顺序反过来,不会创建新的列表，因此没有返回值\n>>> a=[1,2,3,4,5,6,7]\n>>> a.reverse()\n>>> a\n[7, 6, 5, 4, 3, 2, 1]\n>>> a=['ss','aaa','dd']\n\n>>> a.reverse()\n>>> a\n['dd', 'aaa', 'ss']\nsort\nsort是对列表进行排序，不会创建新的列表，因此没有返回值\n>>> a=[1,3,9,7,5] \n>>> a.sort() #默认从小到大的排序\n>>> a\n[1, 3, 5, 7, 9]\n>>> a.sort(reverse = True) #从大到小的排序\n>>> a\n[9, 7, 5, 3, 1]\n>>> lst=[\"python\",\"java\",\"c\",\"basic\",\"ruby\"]\n>>> lst.sort(key=len) #以字符串长度为关键词进行排序\n>>> lst\n['c', 'java', 'ruby', 'basic', 'python']\n比较列表和字符串\n相同点\n都属于序列，因此那些属于序列的操作对两者都适用\n区别\n\n最大区别是，列表自身可以改变，字符串自身不可以改变\n字符串只能通过创建一个新的str来改变，新的str不是原来的字符串对象\n\n多维列表\n\n在字符串中，每个元素只能是字符\n在列表中，每个元素可以是任何类型\n\n>>> matrix=[[1,2,3],[4,5,6],[7,8,9]]\n>>> type(matrix)\n<type 'list'>\n>>> matrix[0][1]\n2\n>>> matrix[0]\n[1, 2, 3]\n列表和字符串的相互转化\nstr.split()\n>>> line=\"hello I am good\"\n>>> line.split(\" \")\n['hello', 'I', 'am', 'good']\n>>> a = line.split(\" \")\n>>> a\n['hello', 'I', 'am', 'good']\n>>> type(a)\n<type 'list'>\n\"split\".join(list)\n>>> a\n['hello', 'I', 'am', 'good']\n>>> type(a)\n<type 'list'>\n>>> \" \".join(a)\n'hello I am good'\n\nPython元组\n定义\n元组（tuple）是用圆括号括起来的，元素之间用逗号隔开。\n>>> t = 123,'abc',[\"come\",\"here\"]\n>>> t\n(123, 'abc', ['come', 'here'])\n>>> type(t)\n<type 'tuple'>\n元组也是一种序列，这一点与列表、字符串类似。有以下特点：\n\n元组其中的元素不能更改，和字符串类似\n元组中的元素可以是任何类型的数据，和列表类似\n\n索引和切片\n元组的索引和切片的基本操作和字符串、列表是一样的。\n>>> t\n(123, 'abc', ['come', 'here'])\n>>> t[2]\n['come', 'here']\n>>> t[1:]\n('abc', ['come', 'here'])\n>>> t[2][0]\n'come'\n特别注意：如果一个元组中只有一个元素，应该在该元素后面加上一个半角的英文逗号：\n>>> a=(3)\n>>> type(a)\n<type 'int'>\n>>> a=(3,) #加了逗号就是元组\n>>> type(a)\n<type 'tuple'>\n列表和元组之间可以实现转换，分别使用list()和tuple()\n>>> t\n(123, 'abc', ['come', 'here'])\n>>> tlst = list(t)   # tuple--->list\n>>> tlst\n[123, 'abc', ['come', 'here']]\n>>> type(tlst)\n<type 'list'>\n>>> \n>>> t_tuple = tuple(tlst)  #list--->tuple\n>>> t_tuple\n(123, 'abc', ['come', 'here'])\n>>> type(t_tuple)\n<type 'tuple'>\n用途\n\n元组比列表操作速度快。如果定义了一个值的常量集，并且唯一要用它做的是不断地遍历它，请使用元组代替列表\n如果对不需要修改的数据进行“写保护”，可以使代码更安全，这时使用元组而不是列表。如果必须要改变这些值，则需要执行元组到列表的转换。\n元组可以在字典中被用作key，但是列表不行。因为字典的key必须是不可变的，元组本身是不可变的。\n元组可以用在字符串格式化中。\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "5"}