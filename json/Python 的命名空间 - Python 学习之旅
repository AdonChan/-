{"title": "Python 的命名空间 - Python 学习之旅 ", "index": "命名空间,标识符,python,全局变量,scope", "content": "懒得扫全文的童鞋，可以直接跳到最后看总结。我们先从一个简单的栗子说起：\n栗子\na 文件中有变量 va 以及类 A，b 文件导入 a 中class A ，并打印出 A：\n#a.py\nva = ['dobi', 'a', 'dog']\n\nprint('a1', id(va))\n\nclass A():\n    def __init__(self):\n        pass\n\n    def rtn(self):\n        global va\n        va.insert(1,'is')\n        print('a3', id(va))\n        return va\n\nprint('a2', va)\n\n\n#b.py\nfrom a import A\n\nprint('b', A)\n执行 b 文件的结果为：\nReloaded modules: a\na1 2407907960200\na2 ['dobi', 'a', 'dog']\nb <class 'a.A'>\n可以发现，虽然 b 只是导入了 a 中的 class A,但导入这个过程却执行了整个 a 文件，那么我们是否能够在 b 中访问 a 中的全局变量 va 呢：\nprint(va)\n# NameError: name 'va' is not defined\nprint(a.va)\n# NameError: name 'a' is not defined\nprint(b.va)\n# NameError: name 'b' is not defined\n\n尝试了各类调用方法，发现都无法正常访问 a 的全局变量 va，既然 b 的导入执行了整个 a 文件，甚至还打印出了 va 的 id 和值，又为什么无法在 b 中调用 va 呢？\n这个问题所涉及到的内容就是：命名空间。\n但在开始正题之前，我们需要阐明若干概念：\n一些基本概念的澄清\n对象\nPython 一切皆对象，每个对象都具有 一个ID、一个类型、一个值；对象一旦建立，ID 便不会改变，可以直观的认为 ID 就是对象在内存中的地址：\na = [1, 2]\nb = a\nid(a)\n# 2407907978632\nid(b)\n# 2407907978632\nb[1] = 3\na\n# [1, 3]\n上例 a, b 共享了同一个 ID、同一个值、同一个类型。因此 a, b 表达的是同一个对象，但 a, b 又明显是不同的，比如一个叫 'a' 一个叫 'b'...既然是同一个对象，为什么又有不同的名字呢？难道名字不是对象的属性？\n标识符\n事实确实如此，这是 Python 比较特殊一点：如同'a'  'b' 这样的名称其实有一个共同的名字：identifier（注意不要与 ID 混淆了），中文名为“标识符”，来解释一下：\n标识符：各类对象的名称，比如函数名、方法名、类名，变量名、常量名等。\n在 Python 中赋值并不会直接复制数据，而只是将名称绑定到对象，对象本身是不知道也不需要关心（该关心这个的是程序猿）自己叫什么名字的。一个对象甚至可以指向不同的标识符，上例中的'a' 'b'便是如此。真正管理这些名子的事物就是本文的主角“命名空间”。\n命名空间\n命名空间（Namespace）：名字（标识符）到对象的映射。\n简而言之，命名空间可以理解为：记录对象和对象名字对应关系的空间；现今 Python 的大部分命名空间是通过字典来实现的，也即一个命名空间就是名字到对象的映射，标识符是键，对象则是值。\n作用域\n与命名空间相对的一个概念就是“作用域”，那么什么又是作用域呢？\n作用域（Scope）：本质是一块文本区域，Python 通过该文本区域可以直接访问相应的命名空间。\n这里需要搞清楚什么是直接访问：\n#x.py\na = 1\nclass A():\n    def func():pass\npython x.py\na   #直接访问\n# 1\nA.func  #属性访问\nPython 中不加 . 的访问为直接访问，反之为属性访问。\n因此可以简单的将作用域理解为“直接访问命名空间的一种实现”，具体而言：\n\n作用域内相应的命名空间可以被直接访问；\n只有作用域内的命名空间才可以被直接访问（因此并不是所有的命名空间都可以被直接访问）。\n\n看不懂？ 没关系，后面会解释，现在先回到命名空间这个话题上，我们经常接触的命名空间有四类：\nLEGB\nLEGB 命名空间\n这四类命名空间可以简记为 LEGB:\n\n局部命名空间（local）：指的是一个函数或者一个类所定义的名称空间；包括函数的参数、局部变量、类的属性等。\n闭包命名空间（enclosing function）：闭包函数 的名称空间（Python 3 引入）。\n全局命名空间（global）：读入一个模块（也即一个.py文档）后产生的名称空间。\n内建命名空间（builtin）：Python 解释器启动时自动载入__built__模块后所形成的名称空间；诸如 str/list/dict...等内置对象的名称就处于这里。\n\n为了说清楚这几类命名空间，举个栗子：\n#c.py\nv1 = 'a global var'\n\ndef func(v):\n    v2 = 'a local var'\n    def inn_func():\n        v3 = v2 + v\n        return v3\n    return inn_func\n内建命名空间比较好理解，我们重点讲解下其他三个：\n\n'v1' 为全局变量 v1 的名子，其所处的命名空间为全局命名空间；需要注意的是全局命名空间包括 'func' 但不包括 func 的参数和内部变量。\nfunc 囊括 'v'、'v2' 和 'inn_func' 名称的空间为局部命名空间；\n执行 func 后，func 的作用域释放（或许遗忘更合适），并返回了绑定了 v 和 v2 变量的闭包函数 inn_func，此时闭包所具有命名空间即为闭包命名空间，因此局部命名空间和闭包命名空间是相对而言的，对于父函数 func 而言，两者具有产生时间上的差异。\n\nLEGB 访问规则\n通过上面描述，我们发现 LEGB 四类命名空间本身具有明显的内外层级概念，而这种层级概念正是构建作用域的前提：作用域依据这种层级概念将不同类型的命名空间组织起来并划归到不同层级的作用域，然后定义好不同层级作用域之间的访问规则，从而实现命名空间的直接访问：LEGB  访问规则： 同样的标识符在各层命名空间中可以被重复使用而不会发生冲突，但 Python 寻找一个标识符的过程总是从当前层开始逐层往上找，直到首次找到这个标识符为止：\n#d.py\nv1 = 1\nv2 = 3\ndef f():\n    v1 = 2\n    print(1, v1)\n    print(2, v2)\n\nf()\nprint(3, v1)\n1 2\n2 3\n3 1\n上例中，全局变量和函数 f 都定义了 变量 v1,结果 Python 会优先选择 f 的局部变量 v1 ，对于 f 内并未定义的变量 v2 ，Python 会向上搜寻全局命名空间，读取全局变量 v2 后打印输出。\nglobal 和 nonlocal 语句\nglobal 和 nonlocal 的作用\n如前所述，对于上层变量，python 允许直接读取，但是却不可以在内层作用域直接改写上层变量，来看一个典型的闭包结构:\n#e.py\ngv = ['a', 'global', 'var']\n\ndef func(v):\n    gv = ['gv'] + gv #UnboundLocalError:local variable 'gv' referenced before assignment\n    lv = []\n    def inn_func():\n        lv = lv + [v]  #UnboundLocalError:local variable 'lv' referenced before assignment\n        gv.insert(1, lv[0])\n        return gv\n    return inn_func\n实际调用 func()函数后，上面两处对 gv 和 lv 进行赋值操作的地方都会发生 UnboundLocalError：因为 Python 在执行函数前，会首先生成各层命名空间和作用域，因此 Python 在执行赋值前会将func 内的 'gv' 'lv' 写入局部命名空间和闭包命名空间，当 Python 执行赋值时会在局部作用域、闭包作用域内发现局部命名空间和闭包命名空间内已经具有'gv' 和 'lv' 标识符，但这两个非全局标识符在该赋值语句执行之前并没有被赋值，也即没有对象与标识符关联，因此无法参与四则运算，从而引发错误；但这段程序本意可能只是想让具有对象的全局变量gv 和局部变量 lv 参与运算，为了避免类似的情况发生，Python 便引入了  global、nonlocal 语句就来说明所修饰的 gv、lv 分别来自全局命名空间和局部命名空间，声明之后，就可以在 func 和 inn_func 内直接改写上层命名空间内 gv 和 lv 的值：\n#f.py\ngv = ['a', 'global', 'var']\n\ndef func(v):\n    global gv\n    gv = ['gv'] + gv\n    lv = []\n    print(id(lv))\n    def inn_func():\n        nonlocal lv\n        lv = lv + [v]\n        print(id(lv))\n        gv.insert(1, lv[0])\n        return gv\n    return inn_func\na = func('is')\n# 2608229974344\n\na()\n# 2608229974344\n# ['gv', 'is', 'a', 'global', 'var']\n\nprint(gv)\n# ['gv', 'is', 'a', 'global', 'var']\n如上，全局变量 gv 值被函数改写了， inn_func 修改的也确实是父函数 lv的值 （依据 ID 判断）。\n借壳\n那么是不是不使用 global 和 nonlocal 就不能达到上面的目的呢？来看看这段程序：\n#g.py\ngv = ['a', 'global', 'var']\n\ndef func(v):\n    gv.insert(0, 'gv')\n    lv = []\n    print(id(lv))\n    def inn_func():\n        lv.append(v)\n        print(id(lv))\n        gv.insert(1, lv[0])\n        return gv\n    return inn_func\n执行的结果：\na = func('is')\n# 2608110869168\n\na()\n# 2608110869168\n# ['gv', 'is', 'a', 'global', 'var']\n\nprint(gv)\n# ['gv', 'is', 'a', 'global', 'var']\n可以发现，执行结果同上面完全一致，问题自然来了：“为什么不用 global nonlocal 也可以改写全局变量gv和父函数变量lv的值？\n为了看清楚这个过程，我们将上面的gv.insert(0, 'gv') lv.append(v) 改写为 gv[0:0] = ['gv'] lv[:] = [v]:\n#h.py\ngv = ['a', 'global', 'var']\n\ndef func(v):\n    gv[0:0] = ['gv']\n    lv = []\n    print(id(lv))\n    def inn_func():\n        lv[:] = [v]\n        print(id(lv))\n        gv.insert(1, lv[0])\n        return gv\n    return inn_func\n\n执行结果：\na = func('is')\n# 2608229959496\n\na()\n# 2608229959496\n# ['gv', 'is', 'a', 'global', 'var']\n同 g.py 文件的执行结果完全一致，事实上两者之间的内在也是完全一样的。So 我们其实改写的不是 gv 和 lv ,而是 gv 和 lv 的元素 gv[0:0] 和 lv[:] 。因此，不需要 global 和 nonlocal 修饰就可以直接改写，这就是“借壳”，在 nonlocal 尚未引入 Python 中，比如 Python 2.x 若要在子函数中改写父函数变量的值就得通过这种方法。当然借壳蕴藏着一个相对复杂的标识符创建的问题：比如子函数通过借壳修改父函数变量lv的值，那么子函数的标识符lv是怎么绑定到父函数变量lv的值 ID 的上的？\n关于这个问题，这里有个问答就是讨论这个的：python的嵌套函数中局部作用域问题?\nglobal 和 nonlocal 语句对标识符创建的不同影响\n另外，需要注意的是：global 语句只是声明该标识符引用的变量来自于全局变量，但并不能直接在当前层创建该标识符；nonlocal 语句则会在子函数命名空间中创建与父函数变量同名的标识符：\n#j.py\ngv = 'a global var'\n\ndef func():\n    global gv\n    lv = 'a local var'\n    print(locals())\n    def inn_func():\n        nonlocal lv\n        global gv\n        print(locals())\n    return inn_func\n执行结果：\nc = func()\n{'lv': 'a local var'}   #运行 `func` 函数后，`global` 语句并未将 `gv` 变量引入局部命名空间\n\nc()\n{'lv': 'a local var'}   #运行闭包函数后，`nonlocal` 语句将父函数变量 `lv` 引入闭包命名空间\n之所以 nonlocal 语句与 global 语句的处置不同，在于全局变量的作用域生存期很长，在模块内随时都可以访问，而父函数的局部作用域在父函数执行完毕后便会直接释放，因此 nonlocal 语句必须将父函数变量的标识符和引用写入闭包命名空间。\n命名空间的生命周期\n创建规则\n实际上，到这里其实还有一个重要的重要问题没有解决：“标识符并不是天生就在命名空间内的，命名空间也不是平白无故就产生的，那么命名空间是在什么时候被创建？又是在什么时候被删除的呢？”规则有四：\n\n内建命名空间在 Python 解释器启动时创建，之后会一直存在；\n模块的全局命名空间在模块定义被读入时创建，通常模块命名空间也会保持到解释器退出。\n函数调用时产生新的局部命名空间；函数返回结果、抛出异常时释放命名空间，每一次递归都生成一个命名空间。\n标识符产生地点决定标识符所处的命名空间。\n\n这四点就是拿来秒懂的！不过，仍然有一点常常被忽视：类的命名空间：\n类的局部命名空间\n首先，函数和类执行时都会产生局部命名空间，但类的执行机制不同于函数：\n#i.py\ndef a():\n    print('function')\n\nclass A():\n    print(1)\n    class B():\n        print(2)\n        class C():\n            print(3)\n执行文件，结果为：\n1\n2\n3\n如上，类就是一个可执行的代码块，只要该类被加载，就会被执行，这一点不同于函数。类之所以这么设计的原因在于：类是创建其他实例（生成其他的类或者具体的对象）的对象，因此必须在实例之前被创建，而类又可能涉及到与其他类的继承、重载等一系列问题，故在代码加载时就被创建利于提高效率和降低逻辑复杂度。\n其次，与函数不同的是，类的局部命名空间并非作用域\nclass A():\n    a = 1\n    b = [a + i for i in range(3)]  #NameError: name 'a' is not defined\n执行上段代码，我们可以发现在类 A 内列表推导式无法调取 a 的值，但函数却可以：\ndef func():\n    a = 1\n    b = [a + i for i in range(3)]\n    print(b)\n\nfunc()  #[1, 2, 3]\n因此，A 中的 a 不同于函数 func 中的 a 在局部命名空间中可以被任意读取，之所以说是“不可以被任意”读取而不是“不可被读取”，原因在于在类A 的局部空间内，a 其实一定程度上是可以直接被读取的：\nclass A():\n    a = 1\n    c = a + 2\n执行上段代码后：\nA.c \n#3\n而上例中 b 的赋值操作不能执行，原因在于列表推导式会创建自己的局部命名空间，因此难以访问到 a。\n编译与局部命名空间\nPython 是动态语言，很多行为是动态发生的，但 Python 自身也在不断进步，比如为了提高效率，有些行为会在编译时候完成，局部变量的创建就是如此：\ndef func():\n    a = 1\n    def inn_func():\n        print(a)  # error\n        a = 2     # error\n    inn_func()\n\n上段程序还未执行，就提示存在有语法错误，原因在于python 解释器发现 inn_func 内存在自身的 a 变量，但却在声明之前就被 print 了。\n总结\n啰嗦了这么多，终于该结尾了！我们再来回过头来看下文章开头的栗子：1、为什么 b.py 只是导入 a.py 中的 class A,却执行了整个 a.py 文件?答：因为 Python 并不知道 class A 在 a.py 文档的何处，为了能够找到 class A，Python 需要执行整个文档。2、为什么 b.py 的导入执行了整个 a.py 文档，却在 b 中难以调用 a 的全局变量 va？答：Python 的全局变量指的是模块全局，因此不可以跨文档，因此 global 语句也是不可以跨文档的。另外， b 只是导入了 a 的 class A，因此并不会导入 a 中所有的标识符，所以 类似a.va 这样的调用也是不起作用的。\n关于命名空间：1、赋值、定义类和函数都会产生新的标识符；2、全局变量的标识符不能跨文档；3、各级命名空间相互独立互不影响；4、Python 总是从当前层逐渐向上寻找标识符；5、内层作用域若想直接修改上层变量，需要通过 global nonlocal 语句先声明；6、单纯的 global 语句并不能为所在层级创建相应标识符，但 nonlocal 语句可以在闭包空间中创建相应标识符；7、类的局部命名空间不是作用域。\n\n                ", "mainLikeNum": ["12 "], "mainBookmarkNum": "34"}