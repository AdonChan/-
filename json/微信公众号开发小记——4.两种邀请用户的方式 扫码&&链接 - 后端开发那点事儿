{"title": "微信公众号开发小记——4.两种邀请用户的方式 扫码&&链接 - 后端开发那点事儿 ", "index": "微信开发,django,python", "content": "描述\n假设的我们的服务号有这么一些功能，比如底部有按钮，点击会有一些复杂的功能，这时候可能就需要一个用户系统，有用户系统就经常想要做什么分享邀请新用户之类的，这时候就又有几种方式，1.直接一个连接，让其他用户点；2.有一个二维码，让离得近的朋友扫。\n借着这个需求体会了下微信开发的两种不同类型（80非80端口的两种开发），以及python-social-auth的一些正确姿势。\n而这个需求其实就对应了两种开发模式，比如有个需求可以在公众号内直接回复，或者在一个页面里面让用户提交表单等等。\n\n通过连接邀请\n首先，理解需求：用户在微信点击我们的邀请连接后，会引导用户做一个有绿色按钮的微信登录，用户登陆后成为我们的用户，并且跳转到某个页面。\n关于用户微信登录的事情我们通过python-social-auth已经解决了（参考我的上一篇博客微信公众号开发小记——3.接入三方登录），所以可以直接用django的login_required装饰器完成这种事情。\n由于微信号的登录只有微信，所以LOGIN_URL = '/login/weixinapp/'\nclass InviteUserView(View):\n    '''邀请注册'''\n\n    @method_decorator(login_required)\n    def get(self, request):\n        return HttpResponseRedirect(reverse('myauth:personal-center'))\n        \n        \n上面的代码只是保证用户点解邀请链接会成为我们的用户，但是没有记录对应的邀请者信息等等，由于邀请这个事情其实是一个登录的流程，所以可以写在pipeline里面\ndef invite_user(backend, user, response, *args, **kwargs):\n    is_new = kwargs['is_new']\n    if not is_new or not user:\n        return\n    # 二维码扫描\n    ...\n    # 点击邀请链接\n    next_url = backend.strategy.session_get('next')\n    if next_url:\n        params = parse_url(next_url)['params']\n        inviter_id = params.get('inviter_id')\n        if inviter_id and user:\n            try:\n                inviter = User.objects.get(id=inviter_id)\n                UserInvite.invite_user(inviter_id, user, only_allow_invited_by_one_user=True)\n            except:\n                return\n            user._inviter = inviter\n        return {'inviter': inviter}\n        \n通过扫码邀请\n首先，扫码是一个服务号80端口的事件，所以代码添加在weixin_server/views.py 微信公众号开发小记——2.80端口上的服务\n难点在于这里，微信扫码后是直接进入公众号的，如果你想要让用户进入公众号之后就变成我们的用户而不是让他在点一个东西这里是比较蛋疼的，因为你的服务器在这时候做302微信是不认得。这就导致了几个问题：\n由于不引导用户登录，我这里没办法直接用python-social-auth里面的do_complete方法（因为拿不到用户的access_token），不过好处是使用微信服务器的access_token以及用户的openid我可以直接拿到这个用户的用户信息。这个问题就变成了python-social-auth的do_complete有用户response后执行pipeline的逻辑了。\n然后我扒了下代码，用了几个小时从单测里面找到了这个逻辑,具体见handle_invite_scan，这段代码才是这篇博客里面难度最大的东西\ndef weixin_handler_event_scan(self, request, parsed_wechat, *args, **kwargs):\n    key = parsed_wechat.message.key # 对应生成二维码的key\n    ticket = parsed_wechat.message.ticket\n    if ticket:\n        response = self.handle_invite_scan(request, parsed_wechat, key)\n        if response:\n            return response\n    return self.weixin_handler_event(\n            request, parsed_wechat, *args, **kwargs)\n            \ndef handle_invite_scan(self, request, parsed_wechat, scene_id):\n    try:\n        qrcode = QRCode.objects.get(scene_id=scene_id, action_type='invite_user')\n    except QRCode.DoesNotExist:\n        return\n    openid = parsed_wechat.message.source\n    user_info = parsed_wechat.get_user_info(openid)\n    strategy = load_strategy(request)\n    backend = WeixinOAuth2APP()\n    backend.strategy = strategy\n    idx, backend, xargs, xkwargs = strategy.partial_from_session(\n        {\n            'next':0,\n            'backend': backend,\n            'args':[],\n            'kwargs':{'qrcode': qrcode},\n        }\n    )\n    xkwargs.update({'response': user_info})\n    user = backend.continue_pipeline(pipeline_index=idx, *xargs, **xkwargs)\n            if not user:\n        return\n    if user.is_new and hasattr(user, '_inviter'):\n        content = u'感谢您的加入，邀请者是 {}'.format(user._inviter.username)\n        response_xml = parsed_wechat.response_text(content=content)\n        return HttpResponse(response_xml, content_type='application/xml')\n        \n然后就可以正常的执行了，由于二维码的机制跟url不同，所以需要单独的二维码处理逻辑\n下面先把pipeline的那段代码贴过来，这里没什么特殊的\ndef invite_user(backend, user, response, *args, **kwargs):\n    is_new = kwargs['is_new']\n    if not is_new or not user:\n        return\n    # 二维码扫描\n    qrcode = kwargs.get('qrcode')\n    if qrcode and qrcode.userprofile_set.all().exists():\n        inviter = qrcode.userprofile_set.all()[0].user\n        try:\n            UserInvite.invite_user(inviter.id, user, only_allow_invited_by_one_user=True)\n        except:\n            return\n        user._inviter = inviter\n        return {'inviter': inviter}\n    ....\n\n微信二维码\n二维码有两种大的类型，永久二维码、临时二维码，永久上线10万张，scenen_id为1~10万，然而他又有scenen_str这种字符串的形式，那肯定选第二种字符串了；临时二维码则scenen_id为1~2^10，这点需要注意，超过这个限制secen_id都是2^10-1，而且蛋疼的是，临时二维码会有过期时间需要维护这个二维码。为了方便我们的业务逻辑查询，我添加了一个action_type的字段，来做业务上的区别，方便查询。\nclass QRCode(models.Model):\n\n    TEMP_QRCODE_UPDATE_DAYS = 7\n\n    QR_SCENE = 'QR_SCENE'\n    QR_LIMIT_SCENE = 'QR_LIMIT_SCENE'\n    QR_LIMIT_STR_SCENE = 'QR_LIMIT_STR_SCENE'\n    ACTION_NAME_CHOICES = (\n        (QR_SCENE, QR_SCENE),\n        (QR_LIMIT_SCENE, QR_LIMIT_SCENE),\n        (QR_LIMIT_STR_SCENE, QR_LIMIT_STR_SCENE),\n    )\n    url = models.URLField(blank=True, max_length=255, default='')\n    # QR_SCENE时上限为2**32\n    scene_id = models.CharField(blank=True, max_length=255, db_index=True, default='')\n    update_time = models.DateTimeField(blank=True, null=True)\n    action_name = models.CharField(max_length=30,\n            choices=ACTION_NAME_CHOICES, default=QR_SCENE, db_index=True)\n    action_type = models.CharField(max_length=255, default='', db_index=True)\n\n    @classmethod\n    def get_qrcode(cls, action_name, scene_id, action_type=None):\n        now = timezone.now()\n        qrcode = None\n        try:\n            qrcode = cls.objects.get(action_name=action_name, scene_id=scene_id)\n            # 临时二维码判断是否过期\n            if qrcode.action_name == cls.QR_SCENE:\n                if qrcode.update_time and qrcode.url:\n                    _delta = now - qrcode.update_time\n                    if _delta.days < qrcode.TEMP_QRCODE_UPDATE_DAYS:\n                        return qrcode\n            else:\n                return qrcode\n        except cls.DoesNotExist:\n            pass\n        if not qrcode:\n            qrcode = cls(\n                    action_name=action_name,\n                    scene_id=scene_id,\n                    action_type=action_type)\n        qrcode.update_time = now\n        if action_name == cls.QR_SCENE:\n            qrcode.url = create_temp_qrcode(scene_id)\n        else:\n            qrcode.url = create_permanent_qrcode(scene_id)\n        qrcode.save()\n        return qrcode\n\n    @classmethod\n    def generate_temp_scene_id(cls, obj_id):\n        '''max id: 2 ** 32 = 4294967296'''\n        return int('{}{}{}'.format(randint(1, 3), obj_id, uuid4().int)[:9])\n\n    @property\n    def qrcode_url(self):\n        if not self.action_name or not self.scene_id:\n            raise Exception(u'qrcode object must have action_name and scene_id value')\n        now = timezone.now()\n        # 永久化的二维码不必更新\n        if self.action_name != self.QR_SCENE:\n            if not self.url:\n                self.update_time = now\n                self.url = create_permanent_qrcode(self.scene_id)\n                self.save()\n            return self.url\n        # 临时二维码判断是否过期\n        if self.update_time and self.url:\n            _delta = now - self.update_time\n            if _delta.days < self.TEMP_QRCODE_UPDATE_DAYS:\n                return self.url\n        self.update_time = now\n        self.url = create_temp_qrcode(self.scene_id)\n        self.save()\n        return self.url\n\n       \n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "4"}