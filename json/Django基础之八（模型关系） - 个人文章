{"title": "Django基础之八（模型关系） - 个人文章 ", "index": "mysql,centos,django,python", "content": "模型关系\n简介\n关系数据库的威力体现在表之间的相互关联，Django提供了三种最常见的数据库关系：多对一（many-to-one），多对多（many-to-many），一对一（one-to-one）\n\n多对一关系\n多对多关系\n一对一关系\n\n多对一\n\ndjango是使用django.db.models.ForeignKey 定义多对一关系\nForeignKey需要一个位置参数来指定本Model关联的Model，ForeignKey关联的Model是\"一\", ForeignKey所在的Model是\"多\"\n\n比如汽车和制造商的例子，一辆汽车只能属于一个制造商，但是一个制造商有多辆汽车，这个关系，用Django的Model来表示，就是\n  class Manufacturer(models.Model):\n      name = models.CharField(max_length=30)\n\n  class Car(models.Model):\n      manufacturer = models.ForeignKey(Manufacturer)\n      name = models.CharField(max_length=30)\n数据创建\nIn [1]: from dashboard.models import Manufacturer,Car                                   \nIn [2]: m1 = Manufacturer()                                                             \nIn [3]: m1.name = \"丰田\"                                                                \nIn [4]: m1.save()                                                                       \nIn [5]: m2 = Manufacturer()                                                             \nIn [6]: m2.name = \"大众\"                                                                \nIn [7]: m2.save()                                                                       \nIn [8]: m1                                                                              \nOut[8]: <Manufacturer: Manufacturer object>\nIn [9]: m2                                                                              \nOut[9]: <Manufacturer: Manufacturer object>\nIn [10]: c1 = Car()                                                                     \nIn [11]: c1.name = \"xxx1\"                                                               \nIn [12]: m = Manufacturer.objects.get(pk=1)                                             \nIn [13]: c1.manufacturer = m                                                            \nIn [14]: c1.save()                                                                      \nIn [15]: c2 = Car()                                                                     \nIn [16]: c2.name = \"宝来\"                                                               \nIn [17]: m3 = Manufacturer.objects.get(pk=2)                                            \nIn [18]: c2.manufacturer = m3                                                           \nIn [19]: c2.save()   \n多对一查询\n正向查询（ ForeignKey 所在的模型查询关联的模型）\n In [22]: xxx1 = Car.objects.get(name=\"xxx1\")    \nIn [23]: xxx1                                               \nOut[23]: <Car: Car object>\nIn [24]: xxx1.manufacturer                                                                                                                                                       Out[24]: <Manufacturer: Manufacturer object>\nIn [25]: xxx1.manufacturer.name                                                                                                                                             Out[25]: '宝马'\n反向查询（ ForeignKey 指向的模型查询ForeignKey 所在的模型）\n如果模型有一个ForeignKey，那么该ForeignKey 所指的模型实例可以通过一个管理器返回前一个有ForeignKey的模型的所有实例。默认情况下，这个管理器的名字为foo_set，其中foo 是源模型的小写名称。该管理器返回的查询集可以用上一节提到的方式进行过滤和操作。\nIn [27]: m1 = Manufacturer.objects.get(pk=1)                                                                                                                         \nIn [28]: m1.car_set.all()                                                                                                    \nOut[28]: <QuerySet [<Car: Car object>, <Car: Car object>]>\nIn [29]: c2 = Car.objects.get(pk=2)                                       \nIn [30]: c2                                 \nOut[30]: <Car: Car object>\nIn [31]: m1.car_set.add(c2)                       \nIn [32]: m1.save()   返回多个car对象\n多对多\n要实现多对多，就要使用django.db.models.ManyToManyField类，和ForeignKey一样，它也有一个位置参数，用来指定和它关联的Model如果不仅仅需要知道两个Model之间是多对多的关系，还需要知道这个关系的更多信息，比如Person和Group是多对多的关系，每个person可以在多个group里，那么group里可以有多个person\n多对多示例\n class Group(models.Model):\n     #...\n\n  class Person(models.Model):\n      groups = models.ManyToManyField(Group)\n\n建议以被关联模型名称的复数形式做为 ManyToManyField 的名字\n在哪个模型中设置 ManyToManyField 并不重要，在两个模型中任选一个即可——不要在两个模型中都设置\n用户和组操作实例\nIn [1]: from django.contrib.auth.models import User,Group                               \nIn [2]: g = Group.objects.create(name='test')                                           \nIn [3]: User.objects.all()                                                              \nOut[3]: <QuerySet []>\nIn [4]: u = User()                                                                      \nIn [5]: u.username = \"wanghui\"                                                          \nIn [6]: u.email = \"122@qq.com\"                                                          \nIn [7]: u.password = \"123456\"                                                           \nIn [8]: u.save()                                                                        \nIn [9]: u1 = User.objects.get(pk=1)                                                     \nIn [10]: g1 = Group.objects.get(pk=1)                                                   \nIn [11]: u1.groups                    #证明manytomany在User表                                                    \nOut[11]: <django.db.models.fields.related_descriptors.create_forward_many_to_many_manager.<locals>.ManyRelatedManager at 0x7f3dce15ea58>\nIn [12]: g1.user_set                                                                    \nOut[12]: <django.db.models.fields.related_descriptors.create_forward_many_to_many_manager.<locals>.ManyRelatedManager at 0x7f3dce0ec748>\nIn [13]: g1.user_set.add(u1)                                                            \nIn [14]: g1.save()                                                                      \nIn [15]: u1 = User.objects.get(pk=1)                                                    \nIn [16]: u1.groups.all()                                                                \nOut[16]: <QuerySet [<Group: test>]>\nIn [17]: g1 = Group.objects.get(pk=1)                                                   \nIn [18]: g1.user_set.all()                                                              \nOut[18]: <QuerySet [<User: wanghui>]>\n处理关联对象的其它方法\nadd(obj1, obj2, ...) #添加一指定的模型对象到关联的对象集中。\ncreate(**kwargs) #创建一个新的对象，将它保存并放在关联的对象集中。返回新创建的对象。\nremove(obj1, obj2, ...) #从关联的对象集中删除指定的模型对象。\nclear() #从关联的对象集中删除所有的对象。\n一对一\n一对一是通过django.db.models.OneToOneField来实现的，被关联的Model会被加上Unique的限制， OneToOneField要一个位置参数，与模型关联的类\n当某个对象想扩展自另一个对象时，最常用的方式就是在这个对象的主键上添加一对一关系\n接口小练习\n需求：\nGET：获取所有用户组列表  GET：获取组下的成员列表  GET：获取用户的组列表  POST：将用户添加至指定组  POST：将用户从指定组中踢出\n类视图如下：\nfrom django.contrib.auth.models import User,Group\nfrom django.core import serializers\nfrom django.http import Http404,QueryDict\n\nclass GroupListView(View):\n    def get(self,request,*args,**kwargs):\n        queryset = Group.objects.all()\n        return HttpResponse(serializers.serialize(\"json\",queryset),content_type=\"application/json\")\n\nclass GroupMembersView(View):\n    def get_queryset(self):\n        groupObj = self.get_group_obj()\n        return groupObj.user_set.all()\n\n    def get_group_obj(self):\n        try:\n            groupObj = Group.objects.get(name=self.request.GET.get(\"name\"))\n        except Group.DoesNotExist:\n            return Http404\n        except Group.MultipleObjectsReturned:\n            return Http404\n        return groupObj\n\n    def get(self,request,*args,**kwargs):\n        user_queryset = self.get_queryset()\n        return HttpResponse(serializers.serialize(\"json\",user_queryset),content_type=\"application/json\")\n\nclass UserGroupsView(View):\n    def get_queryset(self):\n        userObj = self.get_user_obj()\n        return userObj.groups.all()\n\n    def get_user_obj(self):\n        try:\n            userObj = User.objects.get(username=self.request.GET.get(\"name\"))\n        except User.DoesNotExist:\n            return Http404\n        except User.MultipleObjectsReturned:\n            return Http404\n        return userObj\n\n    def get(self,request,*args,**kwargs):\n        group_queryset = self.get_queryset()\n        return HttpResponse(serializers.serialize(\"json\",group_queryset),content_type=\"application/json\")\n\nclass UserGroupManageView(View):\n    def get_query(self):\n        groupObj = self.get_group_obj()\n        userObj = self.get_user_obj()\n\n    def get_group_obj(self):\n        try:\n            groupObj = Group.objects.get(name=QueryDict(self.request.body).get(\"name\"))\n        except Group.DoesNotExist:\n            return Http404\n        except Group.MultipleObjectsReturned:\n            return Http404\n        return groupObj\n        return groupObj\n\n    def get_user_obj(self):\n        try:\n            userObj = User.objects.get(username=QueryDict(self.request.body).get(\"name\"))\n        except User.DoesNotExist:\n            return Http404\n        except User.MultipleObjectsReturned:\n            return Http404\n        return userObj\n\n    def delete(self,request,*args,**kwargs):\n        groupObj = self.get_group_obj()\n        userObj = self.get_user_obj()\n        groupObj.user_set.remove(userObj)\n        return HttpResponse()\n\n    def put(self,request,*args,**kwargs):\n        groupObj = self.get_group_obj()\n        userObj = self.get_user_obj()\n        groupObj.user_set.add(userObj)\n        return HttpResponse()\n路由：\nurlpatterns = [\n    url(r'^grouplist/$',views.GroupListView.as_view()),\n    url(r'^groupmembers/$',views.GroupMembersView.as_view()),\n    url(r'^usergroups/$',views.UserGroupsView.as_view()),\n    url(r'^usergroupmanage/$',views.UserGroupManageView.as_view()),\n]\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}