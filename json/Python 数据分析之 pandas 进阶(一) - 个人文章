{"title": "Python 数据分析之 pandas 进阶(一) - 个人文章 ", "index": "python", "content": "导入本篇中使用到的模块：\n    import numpy as np\n    import pandas as pd\n    from pandas import Series, DataFrame\n我们可以调整数据输出框大小以便观察：\n    pd.set_option('display.width', 200)\n一、创建对象1、可以通过传递一个list对象来创建一个Series，pandas会默认创建整型索引：\n    s = pd.Series([1,3,5,np.nan,6,8])\n    s\n    0     1\n    1     3\n    2     5\n    3   NaN\n    4     6\n    5     8\n    dtype: float64\n2、通过传递一个numpy array，时间索引以及列标签来创建一个DataFrame：\n    dates = pd.date_range('20130101', periods=6)\n    df = pd.DataFrame(np.random.randn(6,4), index=dates, columns=list('ABCD'))\n    dates\n    df\n    DatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04',\n                   '2013-01-05', '2013-01-06'],\n                  dtype='datetime64[ns]', freq='D')\n     \n                A           B            C            D\n    2013-01-01    -1.857957    -0.297110    0.135704    0.199878\n    2013-01-02    0.139027    1.683491    -1.031190    1.447487\n    2013-01-03    -0.596279    -1.211098    1.169525    0.663366\n    2013-01-04    0.367213    -0.020313    2.169802    -1.295228\n    2013-01-05    0.224122    1.003625    -0.488250    -0.594528\n    2013-01-06    0.186073    -0.537019    -0.252442    0.530238\n3、通过传递一个能够被转换成类似序列结构的字典对象来创建一个DataFrame：\n    df2 = pd.DataFrame({'A':1.,\n                        'B':pd.Timestamp('20130102'),\n                        'C':pd.Series(1, index=list(range(4)),dtype='float32'),\n                        'D':np.array([3] * 4, dtype='int32'),\n                        'E':pd.Categorical(['test','train', 'test','train']),\n                        'F':'foo'\n                       })\n    df2\n4、查看不同列的数据类型：\n    df2.dtypes \n    A           float64\n    B    datetime64[ns]\n    C           float32\n    D             int32\n    E          category\n    F            object\n    dtype: object\n5、使用Tab自动补全功能会自动识别所有的属性以及自定义的列\n二、查看数据1.查看Frame中头部和尾部的行：\n    df.head() \n                A            B                C            D\n    2013-01-01    -1.857957    -0.297110    0.135704    0.199878\n    2013-01-02    0.139027    1.683491    -1.031190    1.447487\n    2013-01-03    -0.596279    -1.211098    1.169525    0.663366\n    2013-01-04    0.367213    -0.020313    2.169802    -1.295228\n    2013-01-05    0.224122    1.003625    -0.488250    -0.594528\n    df.tail(3)\n     \n                A            B            C            D\n    2013-01-04    0.367213    -0.020313    2.169802    -1.295228\n    2013-01-05    0.224122    1.003625    -0.488250    -0.594528\n    2013-01-06    0.186073    -0.537019    -0.252442    0.530238\n2、显示索引、列和底层的numpy数据：\n    df.index\n     \n    DatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04',\n                   '2013-01-05', '2013-01-06'],\n                  dtype='datetime64[ns]', freq='D')\n    df.columns\n     \n    Index(['A', 'B', 'C', 'D'], dtype='object') \n3、describe()函数对于数据的快速统计汇总：\n    df.describe()\n     \n        A            B            C            D\n    count    6.000000    6.000000    6.000000    6.000000\n    mean    -0.256300    0.103596    0.283858    0.158536\n    std    0.854686    1.060269    1.181208    0.973309\n    min    -1.857957    -1.211098    -1.031190    -1.295228\n    25%    -0.412452    -0.477042    -0.429298    -0.395927\n    50%    0.162550    -0.158711    -0.058369    0.365058\n    75%    0.214610    0.747641    0.911070    0.630084\n    max    0.367213    1.683491    2.169802    1.447487\n4、对数据的转置(tranverse):\n    df.T\n     \n        2013-01-01     2013-01-02     2013-01-03    2013-01-04     2013-01-05     2013-01-06 \n            00:00:00        00:00:00        00:00:00        00:00:00        00:00:00        00:00:00\n    A    -1.857957    0.139027    -0.596279    0.367213    0.224122    0.186073\n    B    -0.297110    1.683491    -1.211098    -0.020313    1.003625    -0.537019\n    C    0.135704    -1.031190    1.169525    2.169802    -0.488250    -0.252442\n    D    0.199878    1.447487    0.663366    -1.295228    -0.594528    0.530238\n5、按轴进行排序：\n    df.sort_index(axis=1,ascending=False)\n     \n                D            C            B            A\n    2013-01-01    0.199878    0.135704    -0.297110    -1.857957\n    2013-01-02    1.447487    -1.031190    1.683491    0.139027\n    2013-01-03    0.663366    1.169525    -1.211098    -0.596279\n    2013-01-04    -1.295228    2.169802    -0.020313    0.367213\n    2013-01-05    -0.594528    -0.488250    1.003625    0.224122\n    2013-01-06    0.530238    -0.252442    -0.537019    0.186073\n6、按值进行排序：\n    df.sort(columns='B')\n     \n                A            B            C            D\n    2013-01-03    -0.596279    -1.211098    1.169525    0.663366\n    2013-01-06    0.186073    -0.537019    -0.252442    0.530238\n    2013-01-01    -1.857957    -0.297110    0.135704    0.199878\n    2013-01-04    0.367213    -0.020313    2.169802    -1.295228\n    2013-01-05    0.224122    1.003625    -0.488250    -0.594528\n    2013-01-02    0.139027    1.683491    -1.031190    1.447487\n三、选择数据以下是将要操作的数组：\n    df\n     \n                A            B            C            D\n    2013-01-01    -1.857957    -0.297110    0.135704    0.199878\n    2013-01-02    0.139027    1.683491    -1.031190    1.447487\n    2013-01-03    -0.596279    -1.211098    1.169525    0.663366\n    2013-01-04    0.367213    -0.020313    2.169802    -1.295228\n    2013-01-05    0.224122    1.003625    -0.488250    -0.594528\n    2013-01-06    0.186073    -0.537019    -0.252442    0.530238\n1、获取数据\n(1)、选择一个单独的列，这将会返回一个Series:\n    df['A']\n     \n    2013-01-01   -1.857957\n    2013-01-02    0.139027\n    2013-01-03   -0.596279\n    2013-01-04    0.367213\n    2013-01-05    0.224122\n    2013-01-06    0.186073\n    Freq: D, Name: A, dtype: float64\n(2)、通过[]进行选择，即：切片\n    df[0:3]\n     \n                A            B            C             D\n    2013-01-01    -1.857957    -0.297110    0.135704    0.199878\n    2013-01-02    0.139027    1.683491    -1.031190    1.447487\n    2013-01-03    -0.596279    -1.211098    1.169525    0.663366\n2、标签选择\n(1)、使用标签来获取一个交叉的区域\n    df.loc[dates[0]]\n     \n    A   -1.857957\n    B   -0.297110\n    C    0.135704\n    D    0.199878\n    Name: 2013-01-01 00:00:00, dtype: float64\n(2)、通过标签来在多个轴上进行选择\n    df.loc[:,['A', 'B']]\n     \n                A              B\n    2013-01-01    -1.857957    -0.297110\n    2013-01-02    0.139027    1.683491\n    2013-01-03    -0.596279    -1.211098\n    2013-01-04    0.367213    -0.020313\n    2013-01-05    0.224122    1.003625\n    2013-01-06    0.186073    -0.537019\n(3)、标签切片\n    df.loc['20130102':'20130104', ['A','B']]\n     \n                A            B\n    2013-01-02    0.139027    1.683491\n    2013-01-03    -0.596279    -1.211098\n    2013-01-04    0.367213    -0.020313\n(4)、对于返回的对象进行维度缩减\n    df.loc['20130102', ['A','B']]\n     \n    A    0.139027\n    B    1.683491\n    Name: 2013-01-02 00:00:00, dtype: float64\n(5)、获取一个标量\n    df.loc[dates[0], 'A']\n     \n    -1.8579571971312099\n3、位置选择\n(1)、通过传递数值进行位置选择（选择的是行）\n    df.iloc[3]\n     \n    A    0.367213\n    B   -0.020313\n    C    2.169802\n    D   -1.295228\n    Name: 2013-01-04 00:00:00, dtype: float64\n(2)、通过数值进行切片\n    df.iloc[3:5,0:2]\n     \n                A             B\n    2013-01-04    0.367213    -0.020313\n    2013-01-05    0.224122    1.003625\n(3)、通过指定一个位置的列表\n    df.iloc[[1,2,4],[0,2]]\n     \n                A            C\n    2013-01-02    0.139027    -1.031190\n    2013-01-03    -0.596279    1.169525\n    2013-01-05    0.224122    -0.488250\n(4)、对行进行切片\n    df.iloc[1:3,:]\n     \n                A            B            C            D\n    2013-01-02    0.139027    1.683491    -1.031190    1.447487\n    2013-01-03    -0.596279    -1.211098    1.169525    0.663366\n(5)、获取特定的值\n    df.iloc[1,1]\n     \n    1.6834910794696132\n4、布尔索引\n(1)、使用一个单独列的值来选择数据：\n    df[df.A > 0]\n     \n                A            B             C            D\n    2013-01-02    0.139027    1.683491    -1.031190    1.447487\n    2013-01-04    0.367213    -0.020313    2.169802    -1.295228\n    2013-01-05    0.224122    1.003625    -0.488250    -0.594528\n    2013-01-06    0.186073    -0.537019    -0.252442    0.530238\n(2)、使用where操作来选择数据：\n    df[df > 0]\n     \n                A            B            C            D\n    2013-01-01    NaN            NaN            0.135704    0.199878\n    2013-01-02    0.139027    1.683491    NaN            1.447487\n    2013-01-03    NaN            NaN            1.169525    0.663366\n    2013-01-04    0.367213    NaN            2.169802    NaN\n    2013-01-05    0.224122    1.003625    NaN            NaN\n    2013-01-06    0.186073    NaN            NaN            0.530238\n(3)、使用isin()方法来过滤：\n    df2 = df.copy()\n    df2['E'] = ['one', 'one', 'two', 'three', 'four', 'three']\n    df2\n     \n                A            B             C            D            E\n    2013-01-01    -1.857957    -0.297110    0.135704    0.199878    one\n    2013-01-02    0.139027    1.683491    -1.031190    1.447487    one\n    2013-01-03    -0.596279    -1.211098    1.169525    0.663366    two\n    2013-01-04    0.367213    -0.020313    2.169802    -1.295228    three\n    2013-01-05    0.224122    1.003625    -0.488250    -0.594528    four\n    2013-01-06    0.186073    -0.537019    -0.252442    0.530238    three\n    df2[df2['E'].isin(['two', 'four'])]\n     \n                A            B             C            D            E\n    2013-01-03    -0.596279    -1.211098    1.169525    0.663366    two\n    2013-01-05    0.224122    1.003625    -0.488250    -0.594528    four\n5、设置\n(1)、设置一个新的列：\n    s1 = pd.Series([1,2,3,4,5,6], index=pd.date_range('20130102', periods=6))\n    s1\n     \n    2013-01-02    1\n    2013-01-03    2\n    2013-01-04    3\n    2013-01-05    4\n    2013-01-06    5\n    2013-01-07    6\n    Freq: D, dtype: int64\n    df['F'] = s1\n    df\n     \n                A            B            C            D    F\n    2013-01-01    0.000000    0.000000    0.135704    5    NaN\n    2013-01-02    0.139027    1.683491    -1.031190    5    1\n    2013-01-03    -0.596279    -1.211098    1.169525    5    2\n    2013-01-04    0.367213    -0.020313    2.169802    5    3\n    2013-01-05    0.224122    1.003625    -0.488250    5    4\n    2013-01-06    0.186073    -0.537019    -0.252442    5    5\n(2)、设置新值\n    df.at[dates[0],'A'] = 0  #通过标签设置新值\n    df.iat[0,1] = 0  #通过位置设置新值\n    df.loc[:, 'D'] = np.array([5] * len(df))  #通过一个numpy数值设置一组新值\n    df\n     \n                A            B            C            D    F\n    2013-01-01    0.000000    0.000000    0.135704    5    NaN\n    2013-01-02    0.139027    1.683491    -1.031190    5    1\n    2013-01-03    -0.596279    -1.211098    1.169525    5    2\n    2013-01-04    0.367213    -0.020313    2.169802    5    3\n    2013-01-05    0.224122    1.003625    -0.488250    5    4\n    2013-01-06    0.186073    -0.537019    -0.252442    5    5\n四、缺失值处理\n在pandas中，使用np.nan来代替缺失值，这些值将默认不会包含在计算中。所处理的数组是：\n    df\n     \n                A            B            C            D    F\n    2013-01-01    0.000000    0.000000    0.135704    5    NaN\n    2013-01-02    0.139027    1.683491    -1.031190    5    1\n    2013-01-03    -0.596279    -1.211098    1.169525    5    2\n    2013-01-04    0.367213    -0.020313    2.169802    5    3\n    2013-01-05    0.224122    1.003625    -0.488250    5    4\n    2013-01-06    0.186073    -0.537019    -0.252442    5    5\n1、reindex()方法可以对指定轴上的索引进行改变/增加/删除操作，这将返回原始数据的一个拷贝：\n    df1 = df.reindex(index=dates[0:4],columns=list(df.columns) + ['E'])\n    df1.loc[dates[0]:dates[1], 'E'] = 1\n    df1\n     \n     \n                    A            B            C            D    F    E\n    2013-01-01    0.000000    0.000000    0.135704    5    NaN    1\n    2013-01-02    0.139027    1.683491    -1.031190    5    1    1\n    2013-01-03    -0.596279    -1.211098    1.169525    5    2    NaN\n    2013-01-04    0.367213    -0.020313    2.169802    5    3    NaN\n2、去掉包含缺失值的行：\n df1.dropna(how='any')\n  \n             A            B            C            D    F    E\n 2013-01-02    0.139027    1.683491    -1.03119    5    1    1\n3、对缺失值进行填充：\n    df1.fillna(value=5)\n     \n                A            B            C            D    F    E\n    2013-01-01    0.000000    0.000000    0.135704    5    5    1\n    2013-01-02    0.139027    1.683491    -1.031190    5    1    1\n    2013-01-03    -0.596279    -1.211098    1.169525    5    2    5\n    2013-01-04    0.367213    -0.020313    2.169802    5    3    5\n4、对数据进行布尔填充：\n    pd.isnull(df1)\n     \n                A    B    C    D    F    E\n    2013-01-01    False    False    False    False    True    False\n    2013-01-02    False    False    False    False    False    False\n    2013-01-03    False    False    False    False    False    True\n    2013-01-04    False    False    False    False    False    True\n五、合并\npandas提供了大量的方法能够轻松的对Series、DataFrame和Panel对象进行各种符合各种逻辑关系的合并操作。\n1、Concat\n    df = pd.DataFrame(np.random.randn(10, 4))\n    df\n     \n        0            1            2             3\n    0    0.680581    1.918851    0.521201    -0.389951\n    1    0.724157    2.282989    0.648427    -0.827308\n    2    2.437781    0.232518    1.066197    -0.233117\n    3    0.038747    3.174875    -1.384120    0.322864\n    4    -0.835962    1.015841    0.042094    -1.903701\n    5    0.095194    1.926612    0.512825    0.786349\n    6    -1.098231    -0.669381    -0.623124    -0.411114\n    7    -1.229527    -0.738026    0.453683    -2.037488\n    8    -0.499546    -0.816864    -0.395079    -0.320400\n    9    0.850367    1.047287    -1.205815    -1.287821\n    pieces = [df[:3], df[3:7], df[7:]]\n    # break it into pieces\n    pieces\n     \n    [          0         1         2         3\n     0  0.680581  1.918851  0.521201 -0.389951\n     1  0.724157  2.282989  0.648427 -0.827308\n     2  2.437781  0.232518  1.066197 -0.233117,\n               0         1         2         3\n     3  0.038747  3.174875 -1.384120  0.322864\n     4 -0.835962  1.015841  0.042094 -1.903701\n     5  0.095194  1.926612  0.512825  0.786349\n     6 -1.098231 -0.669381 -0.623124 -0.411114,\n               0         1         2         3\n     7 -1.229527 -0.738026  0.453683 -2.037488\n     8 -0.499546 -0.816864 -0.395079 -0.320400\n     9  0.850367  1.047287 -1.205815 -1.287821]\n2、Append将一行连接到一个DataFrame上\n    df = pd.DataFrame(np.random.randn(8, 4), columns=['A', 'B', 'C', 'D'])\n    df\n     \n        A            B            C            D\n    0    -0.923050    -1.798683    -0.543700    0.983715\n    1    -0.031082    1.069746    -0.761914    0.142136\n    2    0.178376    -0.984427    0.270601    0.737754\n    3    -0.882595    0.057637    -1.027661    -1.829378\n    4    0.570082    0.210366    0.805305    -1.233238\n    5    0.442322    0.709155    -0.304849    0.885378\n    6    -0.218852    0.052263    0.467727    0.832747\n    7    0.516890    0.005642    -0.990794    -1.624444\n    s = df.iloc[3]\n    df.append(s, ignore_index=True)\n     \n        A            B            C            D\n    0    -0.923050    -1.798683    -0.543700    0.983715\n    1    -0.031082    1.069746    -0.761914    0.142136\n    2    0.178376    -0.984427    0.270601    0.737754\n    3    -0.882595    0.057637    -1.027661    -1.829378\n    4    0.570082    0.210366    0.805305    -1.233238\n    5    0.442322    0.709155    -0.304849    0.885378\n    6    -0.218852    0.052263    0.467727    0.832747\n    7    0.516890    0.005642    -0.990794    -1.624444\n    8    -0.882595    0.057637    -1.027661    -1.829378\n以上代码不想自己试一试吗？镭矿 raquant提供 jupyter(研究） 在线练习学习 python 的机会，无需安装 python 即可运行 python 程序。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "3"}