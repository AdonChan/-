{"title": "高效的 itertools 模块 - Keep Going ", "index": "python", "content": "itertools\n我们知道，迭代器的特点是：惰性求值（Lazy evaluation），即只有当迭代至某个值时，它才会被计算，这个特点使得迭代器特别适合于遍历大文件或无限集合等，因为我们不用一次性将它们存储在内存中。\nPython 内置的 itertools 模块包含了一系列用来产生不同类型迭代器的函数或类，这些函数的返回都是一个迭代器，我们可以通过 for 循环来遍历取值，也可以使用 next() 来取值。\nitertools 模块提供的迭代器函数有以下几种类型：\n\n无限迭代器：生成一个无限序列，比如自然数序列 1, 2, 3, 4, ...；\n有限迭代器：接收一个或多个序列（sequence）作为参数，进行组合、分组和过滤等；\n组合生成器：序列的排列、组合，求序列的笛卡儿积等；\n\n无限迭代器\nitertools 模块提供了三个函数（事实上，它们是类）用于生成一个无限序列迭代器：\n\n\ncount(firstval=0, step=1)\n创建一个从 firstval (默认值为 0) 开始，以 step (默认值为 1) 为步长的的无限整数迭代器\n\n\n\ncycle(iterable)\n\n对 iterable 中的元素反复执行循环，返回迭代器\n\n\n\nrepeat(object [,times]\n反复生成 object，如果给定 times，则重复次数为 times，否则为无限\n\n\n\n下面，让我们看看一些例子。\ncount\ncount() 接收两个参数，第一个参数指定开始值，默认为 0，第二个参数指定步长，默认为 1：\n>>> import itertools\n>>>\n>>> nums = itertools.count()\n>>> for i in nums:\n...     if i > 6:\n...         break\n...     print i\n...\n0\n1\n2\n3\n4\n5\n6\n>>> nums = itertools.count(10, 2)    # 指定开始值和步长\n>>> for i in nums:\n...     if i > 20:\n...         break\n...     print i\n...\n10\n12\n14\n16\n18\n20\ncycle\ncycle() 用于对 iterable 中的元素反复执行循环：\n>>> import itertools\n>>>\n>>> cycle_strings = itertools.cycle('ABC')\n>>> i = 1\n>>> for string in cycle_strings:\n...     if i == 10:\n...         break\n...     print i, string\n...     i += 1\n...\n1 A\n2 B\n3 C\n4 A\n5 B\n6 C\n7 A\n8 B\n9 C\nrepeat\nrepeat() 用于反复生成一个 object：\n>>> import itertools\n>>>\n>>> for item in itertools.repeat('hello world', 3):\n...     print item\n...\nhello world\nhello world\nhello world\n>>>\n>>> for item in itertools.repeat([1, 2, 3, 4], 3):\n...     print item\n...\n[1, 2, 3, 4]\n[1, 2, 3, 4]\n[1, 2, 3, 4]\n有限迭代器\nitertools 模块提供了多个函数（类），接收一个或多个迭代对象作为参数，对它们进行组合、分组和过滤等：\n\nchain()\ncompress()\ndropwhile()\ngroupby()\nifilter()\nifilterfalse()\nislice()\nimap()\nstarmap()\ntee()\ntakewhile()\nizip()\nizip_longest()\n\nchain\nchain 的使用形式如下：\nchain(iterable1, iterable2, iterable3, ...)\nchain 接收多个可迭代对象作为参数，将它们『连接』起来，作为一个新的迭代器返回。\n>>> from itertools import chain\n>>>\n>>> for item in chain([1, 2, 3], ['a', 'b', 'c']):\n...     print item\n...\n1\n2\n3\na\nb\nc\nchain 还有一个常见的用法：\nchain.from_iterable(iterable)\n接收一个可迭代对象作为参数，返回一个迭代器：\n>>> from itertools import chain\n>>>\n>>> string = chain.from_iterable('ABCD')\n>>> string.next()\n'A'\ncompress\ncompress 的使用形式如下：\ncompress(data, selectors)\ncompress 可用于对数据进行筛选，当 selectors 的某个元素为 true 时，则保留 data 对应位置的元素，否则去除：\n>>> from itertools import compress\n>>>\n>>> list(compress('ABCDEF', [1, 1, 0, 1, 0, 1]))\n['A', 'B', 'D', 'F']\n>>> list(compress('ABCDEF', [1, 1, 0, 1]))\n['A', 'B', 'D']\n>>> list(compress('ABCDEF', [True, False, True]))\n['A', 'C']\ndropwhile\ndropwhile 的使用形式如下：\ndropwhile(predicate, iterable)\n其中，predicate 是函数，iterable 是可迭代对象。对于 iterable 中的元素，如果 predicate(item) 为 true，则丢弃该元素，否则返回该项及所有后续项。\n>>> from itertools import dropwhile\n>>>\n>>> list(dropwhile(lambda x: x < 5, [1, 3, 6, 2, 1]))\n[6, 2, 1]\n>>>\n>>> list(dropwhile(lambda x: x > 3, [2, 1, 6, 5, 4]))\n[2, 1, 6, 5, 4]\ngroupby\ngroupby 用于对序列进行分组，它的使用形式如下：\ngroupby(iterable[, keyfunc])\n其中，iterable 是一个可迭代对象，keyfunc 是分组函数，用于对 iterable 的连续项进行分组，如果不指定，则默认对 iterable 中的连续相同项进行分组，返回一个 (key, sub-iterator) 的迭代器。\n>>> from itertools import groupby\n>>>\n>>> for key, value_iter in groupby('aaabbbaaccd'):\n...     print key, ':', list(value_iter)\n...\na : ['a', 'a', 'a']\nb : ['b', 'b', 'b']\na : ['a', 'a']\nc : ['c', 'c']\nd : ['d']\n>>>\n>>> data = ['a', 'bb', 'ccc', 'dd', 'eee', 'f']\n>>> for key, value_iter in groupby(data, len):    # 使用 len 函数作为分组函数\n...     print key, ':', list(value_iter)\n...\n1 : ['a']\n2 : ['bb']\n3 : ['ccc']\n2 : ['dd']\n3 : ['eee']\n1 : ['f']\n>>>\n>>> data = ['a', 'bb', 'cc', 'ddd', 'eee', 'f']\n>>> for key, value_iter in groupby(data, len):\n...     print key, ':', list(value_iter)\n...\n1 : ['a']\n2 : ['bb', 'cc']\n3 : ['ddd', 'eee']\n1 : ['f']\nifilter\nifilter 的使用形式如下：\nifilter(function or None, sequence)\n将 iterable 中 function(item) 为 True 的元素组成一个迭代器返回，如果 function 是 None，则返回  iterable 中所有计算为 True 的项。\n>>> from itertools import ifilter\n>>>\n>>> list(ifilter(lambda x: x < 6, range(10)))\n[0, 1, 2, 3, 4, 5]\n>>>\n>>> list(ifilter(None, [0, 1, 2, 0, 3, 4]))\n[1, 2, 3, 4]\nifilterfalse\nifilterfalse 的使用形式和 ifilter 类似，它将 iterable 中 function(item) 为 False 的元素组成一个迭代器返回，如果 function 是 None，则返回 iterable 中所有计算为 False 的项。\n>>> from itertools import ifilterfalse\n>>>\n>>> list(ifilterfalse(lambda x: x < 6, range(10)))\n[6, 7, 8, 9]\n>>>\n>>> list(ifilter(None, [0, 1, 2, 0, 3, 4]))\n[0, 0]\nislice\nislice 是切片选择，它的使用形式如下：\nislice(iterable, [start,] stop [, step]) \n其中，iterable 是可迭代对象，start 是开始索引，stop 是结束索引，step 是步长，start 和 step 可选。\n>>> from itertools import count, islice\n>>>\n>>> list(islice([10, 6, 2, 8, 1, 3, 9], 5))\n[10, 6, 2, 8, 1]\n>>>\n>>> list(islice(count(), 6))\n[0, 1, 2, 3, 4, 5]\n>>>\n>>> list(islice(count(), 3, 10))\n[3, 4, 5, 6, 7, 8, 9]\n>>> list(islice(count(), 3, 10 ,2))\n[3, 5, 7, 9]\nimap\nimap 类似 map 操作，它的使用形式如下：\nimap(func, iter1, iter2, iter3, ...)\nimap 返回一个迭代器，元素为 func(i1, i2, i3, ...)，i1，i2 等分别来源于 iter, iter2。\n>>> from itertools import imap\n>>>\n>>> imap(str, [1, 2, 3, 4])\n<itertools.imap object at 0x10556d050>\n>>>\n>>> list(imap(str, [1, 2, 3, 4]))\n['1', '2', '3', '4']\n>>>\n>>> list(imap(pow, [2, 3, 10], [4, 2, 3]))\n[16, 9, 1000]\ntee\ntee 的使用形式如下：\ntee(iterable [,n])\ntee 用于从 iterable 创建 n 个独立的迭代器，以元组的形式返回，n 的默认值是 2。\n>>> from itertools import tee\n>>>\n>>> tee('abcd')   # n 默认为 2，创建两个独立的迭代器\n(<itertools.tee object at 0x1049957e8>, <itertools.tee object at 0x104995878>)\n>>>\n>>> iter1, iter2 = tee('abcde')\n>>> list(iter1)\n['a', 'b', 'c', 'd', 'e']\n>>> list(iter2)\n['a', 'b', 'c', 'd', 'e']\n>>>\n>>> tee('abc', 3)  # 创建三个独立的迭代器\n(<itertools.tee object at 0x104995998>, <itertools.tee object at 0x1049959e0>, <itertools.tee object at 0x104995a28>)\ntakewhile\ntakewhile 的使用形式如下：\ntakewhile(predicate, iterable)\n其中，predicate 是函数，iterable 是可迭代对象。对于 iterable 中的元素，如果 predicate(item) 为 true，则保留该元素，只要 predicate(item) 为 false，则立即停止迭代。\n>>> from itertools import takewhile\n>>>\n>>> list(takewhile(lambda x: x < 5, [1, 3, 6, 2, 1]))\n[1, 3]\n>>> list(takewhile(lambda x: x > 3, [2, 1, 6, 5, 4]))\n[]\nizip\nizip 用于将多个可迭代对象对应位置的元素作为一个元组，将所有元组『组成』一个迭代器，并返回。它的使用形式如下：\nizip(iter1, iter2, ..., iterN)\n如果某个可迭代对象不再生成值，则迭代停止。\n>>> from itertools import izip\n>>> \n>>> for item in izip('ABCD', 'xy'):\n...     print item\n...\n('A', 'x')\n('B', 'y')\n>>> for item in izip([1, 2, 3], ['a', 'b', 'c', 'd', 'e']):\n...     print item\n...\n(1, 'a')\n(2, 'b')\n(3, 'c')\nizip_longest\nizip_longest 跟 izip 类似，但迭代过程会持续到所有可迭代对象的元素都被迭代完。它的形式如下：\nizip_longest(iter1, iter2, ..., iterN, [fillvalue=None])\n如果有指定 fillvalue，则会用其填充缺失的值，否则为 None。\n>>> from itertools import izip_longest\n>>>\n>>> for item in izip_longest('ABCD', 'xy'):\n...     print item\n...\n('A', 'x')\n('B', 'y')\n('C', None)\n('D', None)\n>>>\n>>> for item in izip_longest('ABCD', 'xy', fillvalue='-'):\n...     print item\n...\n('A', 'x')\n('B', 'y')\n('C', '-')\n('D', '-')\n组合生成器\nitertools 模块还提供了多个组合生成器函数，用于求序列的排列、组合等：\n\nproduct\npermutations\ncombinations\ncombinations_with_replacement\n\nproduct\nproduct 用于求多个可迭代对象的笛卡尔积，它跟嵌套的 for 循环等价。它的一般使用形式如下：\nproduct(iter1, iter2, ... iterN, [repeat=1])\n其中，repeat 是一个关键字参数，用于指定重复生成序列的次数，\n>>> from itertools import product\n>>>\n>>> for item in product('ABCD', 'xy'):\n...     print item\n...\n('A', 'x')\n('A', 'y')\n('B', 'x')\n('B', 'y')\n('C', 'x')\n('C', 'y')\n('D', 'x')\n('D', 'y')\n>>>\n>>> list(product('ab', range(3)))\n[('a', 0), ('a', 1), ('a', 2), ('b', 0), ('b', 1), ('b', 2)]\n>>>\n>>> list(product((0,1), (0,1), (0,1)))\n[(0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1), (1, 1, 0), (1, 1, 1)]\n>>>\n>>> list(product('ABC', repeat=2))\n[('A', 'A'), ('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'B'), ('B', 'C'), ('C', 'A'), ('C', 'B'), ('C', 'C')]\n>>>\npermutations\npermutations 用于生成一个排列，它的一般使用形式如下：\npermutations(iterable[, r])\n其中，r 指定生成排列的元素的长度，如果不指定，则默认为可迭代对象的元素长度。\n>>> from itertools import permutations\n>>>\n>>> permutations('ABC', 2)\n<itertools.permutations object at 0x1074d9c50>\n>>>\n>>> list(permutations('ABC', 2))\n[('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'C'), ('C', 'A'), ('C', 'B')]\n>>>\n>>> list(permutations('ABC'))\n[('A', 'B', 'C'), ('A', 'C', 'B'), ('B', 'A', 'C'), ('B', 'C', 'A'), ('C', 'A', 'B'), ('C', 'B', 'A')]\n>>>\ncombinations\ncombinations 用于求序列的组合，它的使用形式如下：\ncombinations(iterable, r)\n其中，r 指定生成组合的元素的长度。\n>>> from itertools import combinations\n>>>\n>>> list(combinations('ABC', 2))\n[('A', 'B'), ('A', 'C'), ('B', 'C')]\ncombinations_with_replacement\ncombinations_with_replacement 和 combinations 类似，但它生成的组合包含自身元素。\n>>> from itertools import combinations_with_replacement\n>>>\n>>> list(combinations_with_replacement('ABC', 2))\n[('A', 'A'), ('A', 'B'), ('A', 'C'), ('B', 'B'), ('B', 'C'), ('C', 'C')]\n小结\nitertools 模块提供了很多用于产生多种类型迭代器的函数，它们的返回值不是 list，而是迭代器。\n本文由 funhacks 发表于个人博客，采用 Creative Commons BY-NC-ND 4.0（自由转载-保持署名-非商用-禁止演绎）协议发布。非商业转载请注明作者及出处。商业转载请联系作者本人。本文标题为: 高效的 itertools 模块本文链接为: http://funhacks.net/2017/02/1...\n参考链接\n\nitertools — Functions creating iterators for efficient looping\nitertools – Iterator functions for efficient looping - Python Module of the Week\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "4"}