{"title": "Python -- 元类metaclass详解 - 个人文章 ", "index": "python", "content": "学习契机\n项目中使用Elasticsearch（ES）存储海量业务数据，基于ES向外提供的API进一层封装，按需处理原始数据提供更精确、更多样化的结果。在研究这一层的代码时接触到@six.add_metaclass(abc.ABCMeta)，故而学习一下Python的元类。不过，虽然@six.add_metaclass(abc.ABCMeta)实现上与元类有关，但实际应用只需要调用其接口，并不需要接触后幕后的元类操作。翻译这篇答案是为了方便自己记忆理解，其实原文中一些地方我自己不是很明白，所以这个翻译会根据自己理解的程度持续更新。\n原链接\nstackoverflow-What are metaclasses in Python?\nPython中的元类是什么\n类也是对象\n在理解元类之前，需要掌握Python中类概念。Python的类概念稍有奇特，其借鉴于Smalltalk。在大部分语言中，类用于描述如何生成一个对象，在Python中也是如此：\n>>> class ObjectCreator(object):\n...       pass\n...\n\n>>> my_object = ObjectCreator()\n>>> print(my_object)\n<__main__.ObjectCreator object at 0x8974f2c>\n但是，在Python中类的意义更多，类同时也是对象。当你使用关键字class时，Python解释器执行代码时会生成一个对象。以下代码会在内存中创建一个名为“ObjectCreator”的对象：\n>>> class ObjectCreator(object):\n...       pass\n...\n这个对象（类）自身可以创建对象（实例），这是为什么它是类的原因。不过它仍然是一个对象，你可以：\n\n可以将它赋值给变量\n可以复制\n可以添加属性 TODO 添加属性只是对象的特性？\n\n可以将其当作函数参数传递\n\n举例：\n>>> print(ObjectCreator) # you can print a class because it's an object\n<class '__main__.ObjectCreator'>\n>>> def echo(o):\n...       print(o)\n...\n>>> echo(ObjectCreator) # you can pass a class as a parameter\n<class '__main__.ObjectCreator'>\n>>> print(hasattr(ObjectCreator, 'new_attribute'))\nFalse\n>>> ObjectCreator.new_attribute = 'foo' # you can add attributes to a class\n>>> print(hasattr(ObjectCreator, 'new_attribute'))\nTrue\n>>> print(ObjectCreator.new_attribute)\nfoo\n>>> ObjectCreatorMirror = ObjectCreator # you can assign a class to a variable\n>>> print(ObjectCreatorMirror.new_attribute)\nfoo\n>>> print(ObjectCreatorMirror())\n<__main__.ObjectCreator object at 0x8997b4c>\n动态创建类\n既然类也是对象，那就可像其他对象那样，动态创建类。首先，可以使用关键字class，在函数中创建类：\n>>> def choose_class(name):\n...     if name == 'foo':\n...         class Foo(object):\n...             pass\n...         return Foo # return the class, not an instance\n...     else:\n...         class Bar(object):\n...             pass\n...         return Bar\n...\n>>> MyClass = choose_class('foo')\n>>> print(MyClass) # the function returns a class, not an instance\n<class '__main__.Foo'>\n>>> print(MyClass()) # you can create an object from this class\n<__main__.Foo object at 0x89c6d4c>\n但是这还不够动态，因为还是需要自己编写整个类的代码。所以，想一想，这些类既然是对象，就必然是某种东西生成的。当使用class关键字时，Python自动创建了类这个对象，但是像Python中大部分事情一样，Python中也可以手动创建类。还记type方法吗？一个可以让你知道一个对象是什么类型的方法：\n>>> print(type(1))\n<type 'int'>\n>>> print(type(\"1\"))\n<type 'str'>\n>>> print(type(ObjectCreator))\n<type 'type'>\n>>> print(type(ObjectCreator()))\n<class '__main__.ObjectCreator'>\n除此之外，type还有一个完全不同的功能：动态创建类。将类的描述作为参数传递给type，会返回一个类。（我知道，同一个函数根据传参的不同而展示出两种完全不同的功能很不合理，不过这是为了Python的向后兼容。）type如何创建类:\ntype(类名,\n     父类元祖 (可为空),\n     包含键值对属性的字典)\n举例:\n>>> class MyShinyClass(object):\n...       pass\n上面这个MyShinyClass类可以用以下方法手动创建:\n>>> MyShinyClass = type('MyShinyClass', (), {}) # 返回一个类\n>>> print(MyShinyClass)\n<class '__main__.MyShinyClass'>\n>>> print(MyShinyClass()) # 创建一个类对象\n<__main__.MyShinyClass object at 0x8997cec>\n应该注意到了，使用\"MyShinyClass\"作为类名，也将其作为一个变量名，赋值为类的引用。类名和变量名是可以不同的，但是没必要把事情搞复杂。type可以接受一个定义类属性的字典作为参数：\n>>> class Foo(object):\n...       bar = True\n以上定义等同于：\n>>> Foo = type('Foo', (), {'bar':True})\n使用起来跟一个普通类一样：\n>>> print(Foo)\n<class '__main__.Foo'>\n>>> print(Foo.bar)\nTrue\n>>> f = Foo()\n>>> print(f)\n<__main__.Foo object at 0x8a9b84c>\n>>> print(f.bar)  # 利用实例打印类属性\nTrue\n当然，也可以作为基类，给其他类继承：\n>>>   class FooChild(Foo):\n...         pass\n以上代码等同于：\n>>> FooChild = type('FooChild', (Foo,), {})\n>>> print(FooChild)\n<class '__main__.FooChild'>\n>>> print(FooChild.bar) # bar属性继承自类Foo\nTrue\n你肯定还想为类添加方法。只需要定义一个名称合理的函数，并将这个函数名作为属性传递给type就行：\n>>> def echo_bar(self):\n...       print(self.bar)\n...\n>>> FooChild = type('FooChild', (Foo,), {'echo_bar': echo_bar})\n>>> hasattr(Foo, 'echo_bar')\nFalse\n>>> hasattr(FooChild, 'echo_bar')\nTrue\n>>> my_foo = FooChild()\n>>> my_foo.echo_bar()\nTrue\n在动态创建一个类之后，为这个类添加更多的方法，就像为一个正常创建的类添加方法一样：\n>>> def echo_bar_more(self):\n...       print('yet another method')\n...\n>>> FooChild.echo_bar_more = echo_bar_more\n>>> hasattr(FooChild, 'echo_bar_more')\nTrue\n现在已经看到：在Python中，类也是对象，可以动态地创建类。当使用关键字class时，Python使用元类像这样创建类的。\n什么是元类（终于讲到了）\n元类就是创建类的“东西”。我们定义类是为了创建对象，是吧？但是我们认识到在Python中类也是对象，而元类就是创建类这种对象（类）的，它们是类的类，你可以这样理解：\nMyClass = MetaClass()\nMyObject = MyClass()\n你已经看到type可以让你做如下操作：\nMyClass = type('MyClass', (), {})\n这是因为type方法实际上是一个元类。事实上，type是Python中用于创建所有类的元类。不过现在你一定很奇怪为什么这个类名首字母是小写，而不是Type？我猜这是同str保持一致，str是用来创建string对象的类，int是用来创建integer对象的类，type则是创建类对象的类。在Python中，一切，对就是一切，都是对象。包括整数、字符串、函数和类。所有东西都是对象，它们都是创建自某个类。通过__class__属性可以验证这一点：\n>>> age = 35\n>>> age.__class__\n<type 'int'>\n>>> name = 'bob'\n>>> name.__class__\n<type 'str'>\n>>> def foo(): pass\n>>> foo.__class__\n<type 'function'>\n>>> class Bar(object): pass\n>>> b = Bar()\n>>> b.__class__\n<class '__main__.Bar'>\n那么，一个__class__的__class__属性是什么呢?\n>>> age.__class__.__class__\n<type 'type'>\n>>> name.__class__.__class__\n<type 'type'>\n>>> foo.__class__.__class__\n<type 'type'>\n>>> b.__class__.__class__\n<type 'type'>\n由此可见：元类确实就是创建类对象的东西。如果你觉得合适你就可以称之为“类工厂”。type是Python使用的内置元类，当然，你也可以自己创建元类。\n__metaclass__属性\n编写一个类时添加上__metaclass__属性：\nclass Foo(object):\n    __metaclass__ = something...\n    [...]\n如果你像上面这样做，Python就会使用元类创建一个Foo类。要当心了，这里有些小圈套。你先写下了“class Foo(object)”，但此时内存中还没有创建Foo类对象。Python会在类的声明中寻找属性__metaclass_，如果找到了就会使用其创建Foo类；如果没有，会使用type创建这个类。下面这段文字要多读几遍。当你编写以下代码时:\nclass Foo(Bar):\n    pass\nPython做了这些事情:\n在类Foo中有定义__metaclass__属性吗？\n如果有，则继续；\n如果没有，Python会在模块层寻找__metaclass__属性（这只针对没有继承任何其他类的情况）；\n如果模块层也没有，则会在Bar（第一个父类）中寻找（这就有可能是内置的type）。\n这样找到__metaclass__后，使用它在内存中创建名称为Foo的类对象（这边跟上，一个类对象）\n需要注意的是，__metaclass__属性不会被继承，但是父类的元类（Bar.__class__）可以被继承：如果Bar的__metaclass__属性定义了使用type()（不是type.__new()）创建Bar类，其子类不会继承这个行为。（Be careful here that the metaclass attribute will not be inherited, the metaclass of the parent (Bar.__class__) will be. If Bar used a metaclass attribute that created Bar with type() (and not type.__new__()), the subclasses will not inherit that behavior.）TODO 这边不太理解现在有个新问题，你可以赋什么值给__metaclass__？答案是：可以创建一个类的东西。那什么可以创建类？type、子类化type或者使用type的东西。\n自定义元类\n元类的主要目的，是在创建类的时候动态地改变类。通常你会想创建符合当前上下文的类供API使用。举一个简单的例子，当你希望一个模块中所有的类属性都是小写时，有几种方法可以实现，其中有一种方法就是在模块层设置__metaclass__。使用这种方法，这个模块中所有的类都将使用此元类创建，我们只需要使元类将所有类属性置为小写。幸运的是，__metaclass__可以被任意调用，不一定非要是一个正式的类（我知道，名称包含“class”不一定非要是一个类，搞清楚了...这很有用）。现在先用一个函数举一个简单的例子：\n# 元类会自动获取通常传给`type`的参数\ndef upper_attr(future_class_name, future_class_parents, future_class_attr):\n    \"\"\"\n      返回一个类对象，将其属性置为大写\n    \"\"\"\n\n    # 过滤出所有开头不为'__'的属性，置为大写\n    uppercase_attr = {}\n    for name, val in future_class_attr.items():\n        if not name.startswith('__'):\n            uppercase_attr[name.upper()] = val\n        else:\n            uppercase_attr[name] = val\n\n    # 利用'type'创建类\n    return type(future_class_name, future_class_parents, uppercase_attr)\n\n__metaclass__ = upper_attr  # 这会影响此模块中所有的类\n\nclass Foo():  # global __metaclass__ won't work with \"object\" though  == 没看懂\n    # but we can define __metaclass__ here instead to affect only this class\n    # and this will work with \"object\" children\n    bar = 'bip'\n\nprint(hasattr(Foo, 'bar'))\n# Out: False\nprint(hasattr(Foo, 'BAR'))\n# Out: True\n\nf = Foo()\nprint(f.BAR)\n# Out: 'bip'\n现在，完成同样的功能，但是为元类定义一个真实的类：\n# 记住`type`实际上是一个像`str`和`int`的类，可以用于被继承\nclass UpperAttrMetaclass(type):\n    # __new__放在__init__之前调用，此方法创建对象并反回\n    # 而__init__则是初始化作为参数传递给此方法的对象\n    # 除非你想控制如何创建一个对象，否则很少用到__new__\n    # 在这里，被创建的对象是类，而我们想自定义这个类，所以重写了__new__\n    # 如果需要的话你也可以在__init__中做一些操作\n    # 一些高级用法会包括重写__call__，不过这里还不需要\n    def __new__(upperattr_metaclass, future_class_name,\n                future_class_parents, future_class_attr):\n\n        uppercase_attr = {}\n        for name, val in future_class_attr.items():\n            if not name.startswith('__'):\n                uppercase_attr[name.upper()] = val\n            else:\n                uppercase_attr[name] = val\n\n        return type(future_class_name, future_class_parents, uppercase_attr)\n这不是真正的面向对象（OOP），这里直接调用了type，没有重写或者调用父类的__new__。现在像这样处理:\nclass UpperAttrMetaclass(type):\n\n    def __new__(upperattr_metaclass, future_class_name,\n                future_class_parents, future_class_attr):\n\n        uppercase_attr = {}\n        for name, val in future_class_attr.items():\n            if not name.startswith('__'):\n                uppercase_attr[name.upper()] = val\n            else:\n                uppercase_attr[name] = val\n\n        # 复用type.__new__方法\n        # 这是基本的OOP，没什么深奥的\n        return type.__new__(upperattr_metaclass, future_class_name,\n                            future_class_parents, uppercase_attr)\n你大概发现了传给type的额外的参数upperattr_metaclass。这没什么奇怪的：__new__的第一个参数总是其定义的类。就像类方法中第一个参数总是self。当然，为了清晰期间，这里我起的名字比较长，但是像self这样的参数通常有一个传统的名字。所以真正的产品代码中，元类是像这样的：\nclass UpperAttrMetaclass(type):\n\n    def __new__(cls, clsname, bases, dct):\n\n        uppercase_attr = {}\n        for name, val in dct.items():\n            if not name.startswith('__'):\n                uppercase_attr[name.upper()] = val\n            else:\n                uppercase_attr[name] = val\n\n        return type.__new__(cls, clsname, bases, uppercase_attr)\n使用super可以更清晰，which will ease inheritance (because yes, you can have metaclasses, inheriting from metaclasses, inheriting from type)TODO:\nclass UpperAttrMetaclass(type):\n\n    def __new__(cls, clsname, bases, dct):\n\n        uppercase_attr = {}\n        for name, val in dct.items():\n            if not name.startswith('__'):\n                uppercase_attr[name.upper()] = val\n            else:\n                uppercase_attr[name] = val\n\n        return super(UpperAttrMetaclass, cls).__new__(cls, clsname, bases, uppercase_attr)\n以上，关于元类也没有更多了。使用元类的代码比较复杂的原因不在于元类，而在于你通常会依靠自省、操纵继承、__dict__变量等，使用元类做一些晦涩的事情。（it's because you usually use metaclasses to do twisted stuff relying on introspection, manipulating inheritance, vars such as __dict__, etc.）TODO元类来用于黑魔法时的确特别有用，因为也会将事情搞得很复杂。但就其本身而言，是简单的：\n\n拦截一个类的创建\n修改类\n返回修改的类\n\n为什么会用元类代替函数？\n既然__metaclass__可以被任意调用，为什么要使用明显更复杂的类呢？有这样一些理由：\n\n意图明显。当你看到UpperAttrMetaclass(type)，你知道接下来会发生什么。\n可以使用OOP。元类可以继承自元类，重写父类的方法，元类甚至可以使用元类。\n如果为一个类指定的元类是类而不是方法，这个类的子类将是元类的一个实例。Children of a class will be instances of its metaclass if you specified a metaclass-class, but not with a metaclass-function.TODO\n\n你可以将代码组织得更好。使用元类时肯定不会仅想像上面举的例子那样简单，通常是用于比较复杂的场景。将多个方法组织在一个类中有益于使代码更容易阅读。\n你可以使用__new__，__init__ 和 __call__，这些方法可以处理不用的事情。即使很多时候你可以在__new__中完成所有工作，当然，一些人会更习惯用__init__。\n这些东西叫 “metaclass”，小心了！这一定很难搞！\n\n为什么使用元类\n好了，现在的问题是：为什么要是用这样晦涩且容易出错的特性？其实，通常你不会用：\n元类是99%的用户根本不必操心的深度魔法。如果你在考虑是否需要使用，那就不要用（真正需要的用户很清楚他们的需求，根本不需要解释为什么要使用元类） Python领袖 Tim Peters\n\n使用元类的一个主要场景是创建API。Django ORM是一个典型的例子，它允许你像下面这样定义：\nclass Person(models.Model):\n    name = models.CharField(max_length=30)\n    age = models.IntegerField()\n如果你这样做:\nguy = Person(name='bob', age='35')\nprint(guy.age)\n它不会返回一个IntegerField的对象，而是返回一个整数，甚至可以从数据库中直接获取数据。TODO这是因为，在models.Model中定义了__metaclass__，使用了一些魔法将你定义的简单的Person类转换为一个复杂的数据库挂钩。（turn the Person you just defined with simple statements into a complex hook to a database field.）TODO\nDjango使用元类对外提供简单的API，简化了一些复杂的东西，API中重建的代码会去完成幕后真正的工作。\n结语\n首先，类是可以创建实例的对象。类本身是元类的对象：\n>>> class Foo(object): pass\n>>> id(Foo)\n142630324\n在Python中，除了type，一切皆对象，一切都是类或者元类的对象。事实上type是自己的元类，这在纯Python中这是无法实现的，这里在实现层上做了一些手段。其次，元类是复杂的。你可能不希望对非常简单的类使用元类，那么还有其他两种手段用来改变类：\n\nmonkey patching\n类装饰器\n\n如果你需要改变类，99%的情况下使用这两种方法。但其实98%的情况你根本不需要改变类。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}