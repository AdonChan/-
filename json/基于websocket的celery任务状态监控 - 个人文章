{"title": "基于websocket的celery任务状态监控 - 个人文章 ", "index": "python,flask", "content": "1. 目的曾经想向前台实时返回Celery任务的状态监控，也查看了很多博客，但是好多也没能如愿，因此基于网上已有的博客已经自己的尝试，写了一个小的demo，实现前台实时获取后台传输的任务状态。\n2. 准备 本篇文章使用的是Flask框架，安装celery，celery采用redis作为存储。同时用到了Flask-SocketIO建立websocket。同时还用到了协程库eventlet（这个是Flask-SocketIO文档建议的，链接文档）。\n3. 实现demo仿照其他例子实现了一个简单的后台任务监控。我们直接上代码吧，下面是server端代码：\n# -*- utf-8 -*-\n# app.py\nimport time\nimport uuid\nfrom flask import Flask, render_template, request, make_response, jsonify\nfrom flask_socketio import SocketIO\nfrom celery import Celery\nimport eventlet\nfrom flask_redis import FlaskRedis\neventlet.monkey_patch()\n\napp = Flask(__name__)\n\napp.config['BROKER_URL'] = 'redis://localhost:6379/0'\napp.config['CELERY_RESULT_BACKEND'] = 'redis://localhost:6379/0'\napp.config['CELERY_ACCEPT_CONTENT'] = ['json', 'pickle']\napp.config['REDIS_URL'] = 'redis://localhost:6379/0'\n\nsocketio = SocketIO(app, async_mode='eventlet',message_queue=app.config['CELERY_RESULT_BACKEND'])\nredis = FlaskRedis(app)\n\ncelery = Celery(app.name)\ncelery.conf.update(app.config)\n\n#模拟后台耗时任务\n@celery.task\ndef background_task(uid):\n    sid = redis.get(uid)\n    socketio.emit('info', {'data': 'Task starting ...', 'time': time.time() * 1000 },room=sid, namespace='/task')\n    socketio.sleep(4)\n    socketio.emit('info', {'data': 'Task running!', 'time': time.time() * 1000 }, room=sid, namespace='/task')\n    socketio.sleep(5)\n    socketio.emit('info', {'data': 'Task complete!', 'time': time.time()*1000 }, room=sid, namespace='/task')\n\n#建立链接时把sid传到浏览器端保存。\n@socketio.on('connect', namespace='/task')\ndef connect_host():\n    sid = request.sid\n    socketio.emit('hostadd', {'sid': sid}, room=sid, namespace='/task')\n\n#将每一个客户端生成一个uuid存放在cookie中\n@app.route('/')\ndef index():\n    if not request.cookies.get('host_uid', None):\n        uid = uuid.uuid1().get_hex()\n        response = make_response(render_template('index.html'))\n        response.set_cookie('host_uid', uid)\n        return response\n    return render_template('index.html')\n\n@app.route('/task')\ndef start_background_task():\n    uid = request.cookies.get('host_uid')\n    background_task.delay(uid)\n    return 'Started'\n\n#设置sid建立链接后浏览器将sid传送到server，并将uid与sid映射存放在redis里面，默认保留12小时\n@app.route('/setsid', methods=['POST'])\ndef set_uid():\n    data = request.json\n    uid = request.cookies.get('host_uid')\n    redis.set(uid, data['sid'])\n    redis.expire(uid, 3600 * 12)\n    return jsonify({'success': True})\n\nif __name__ == '__main__':\n    socketio.run(app, host='0.0.0.0', port=5000, debug=True)\n如果不想使用debug模式的话，可以用gunicorn运行，命令如下所示：\ngunicorn --worker-class eventlet -w 1 app:app\n使用上述命令需要注意，由于gunicorn负载均衡算法的限制，文档建议worker数量为1，我测试过大于1，确实会出问题。前端代码如下，index.html:\n<!DOCTYPE html>\n<html>\n<head>\n    <title>test</title>\n    <script type=\"text/javascript\" src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js\"></script>\n    <script type=\"text/javascript\" src=\"https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.1.0/socket.io.js\"></script>\n</head>\n<body>\n    <h3>Logging</h3>\n    <p id=\"log\"></p>\n    <button id=\"background\">Execute</button>\n    <script type=\"text/javascript\">\n        $(document).ready(function () {\n            namespace = '/task';\n            socket = io.connect('http://' + document.domain + ':' + location.port + namespace);\n            socket.on('hostadd', function(msg){\n                console.log(msg.sid);\n                $.ajax({\n                    url: \"{{ url_for('set_uid') }}\",\n                    data: JSON.stringify({ sid: msg.sid }),\n                    type: 'post',\n                    dataType: 'json',\n                    contentType: \"application/json; charset=utf-8\"\n                })\n            });\n            socket.on('info', function (msg) {\n                console.log('Recived: ' + msg.data);\n                var t = new Date(msg.time);\n                $('#log').append('Recived: ' + t.toLocaleTimeString() + '->' + msg.data + '<br>');\n            });\n            $('#background').on('click', function(){\n                $.get(\"{{ url_for('start_background_task') }}\");\n            });\n        });\n    </script>\n</body>\n</html>\n\nGitHub地址：https://github.com/junfenggoo...\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}