{"title": "ORACLE 历史数据管理策略--数据清理 - devops ", "index": "python,oracle", "content": "背景\n由于性能数据每天导入量，数据库表空间每天增长很快，且不需要太长的保存周期，为避免爆表，因此需要定制定期清理计划。数据的清理可以有多种方案，根据场景的不同可以分为离线，在线。后续又在可以细分。这里仅考虑在线方式数据里比如DELETE与 REDEFINITION，这种方式带来的问题就是会产生大量的LOG,同时产生回滚段，需要定期进行redefinition。为避免场景复杂，这里采用分区表方式。\n分区方案\n目前有两种方案，一种是按照ingerval分区，未定义分区oracle会智能分区，分区简单，但是带来的问题就是分区名字无法直接确定，后期维护不方便这里不做重点介绍使用虚拟列，固定分区名字，引入问题需要新增虚拟列，即本文使用方案。\n关于索引\n表分区以后，同时需要同步修改索引，这里根据我们的应用场景，需要构建LNP(LOCAL NON PREFIXED) INDEX--引入的虚拟列作为分区字段，没有其它功能。如果需要构建唯一索引，LNP index必须包含分区键。对于程序访问路径带来的变化就是最好显式的指定分区，如果不指定，即使匹配索引，也是匹配所有表的LNP IDNEX\nselect INDEX_NAME,PARTITIONING_TYPE,LOCALITY, ALIGNMENT from all_part_indexes where table_name='xxx'\nselect index_name,status from user_indexes where index_name='xxx'\nselect INDEX_NAME,PARTITION_NAME,status from User_Ind_Partitions a where a.Index_Name='xxx'\n新增虚拟列\n新增虚拟列语法\n v_month as (substr(datadate,6,2))\n partition by list(v_month)\n(\n partition p1 values('01'),\n partition p2 values('02'),\n partition p3 values('03'),\n partition p4 values('04')\n);\n新增虚拟列不会增加存储空间消耗，但是会增加CPU消耗，即新增列的信息仅写入metadata.\nSELECT TABLE_NAME,PARTITION_NAME,HIGH_VALUE FROM user_tab_partitions WHERE TABLE_NAME=\nselect TABLE_NAME,PARTITIONING_TYPE  from user_part_tables where table_name='\nselect segment_name||' '||partition_name||' '||segment_type from user_segments where segment_name like \n应用程序变化\nSELECT\nSELECT *\n会现实虚拟列\nINSERT\n不支持\ninsert into table xx values()\n需要显式指定插入列：\ninsert into table xx(col1,col2,...) values()\n\nupdate\n同insert\n按月份分区数据清理\n表按照月分区，共12个分区，数据保留3个月，每个月出清理三个月之前的分区数据，即清理脚本每月执行生成truncate分区的脚本如下：\nfrom  datetime import date,timedelta\nfrom monthdelta import MonthDelta\ncurrent_day = date.today()\nprev_2month = current_day- MonthDelta(2)\nmonth_of_partition = prev_2month.month\nprint 'current day is:{0} and previous day of last 2 months is:{1},so the partition need to truncate is:{2}'.format(current_day,prev_2month,month_of_partition)\nwith open(\"partition_by_day_table\") as f:\n    for table in f:\n        print 'alter table {0} truacate partition p{1}'.format(table.strip(),month_of_partition)\n确定分区后，通过定时任务执行对应的SQL即可。\n按天分区数据清理\n表按照天分区，数据至少保留7天以上表分区原则：表按天分区，共31个分区，每天清理8天前的分区，清理脚本每月执行生成truncate分区的脚本如下：\n#!/usr/bin/python\nfrom  datetime import date,timedelta,datetime\ncurrent_day = date.today()\nprev_8day = current_day-timedelta(days=8)\nday_of_partition = prev_8day.day\nprint 'current day is: {0}  and  previsus day of 8 day is:{1},so the partition need to trucate is:{2}'.format(current_day,prev_8day,day_of_partition)\nprint '#'*72\nfout=open('/home/oracle/scripts/minute.log','a')\nwith open(\"/home/oracle/scripts/partition_by_day_tables\") as f:\n        for table in f:\n                syntax= 'alter table {0} truacate partition p{1}'.ljust(72,' ').format(table.strip(),day_of_partition)+'; commit;\\n'\n                #print syntax \n                fout.write(syntax)\nnow=datetime.now().strftime('%Y-%m-%d %H:%M:%S')\nfout.write(now+'\\n')\nf.close()\nprint '#'*72\n对应的SQL脚本如下：\nalter table xx1 truacate partition p3                                 ; commit;\nalter table xx2 truacate partition p3                                 ; commit;\nalter table xx3 truacate partition p3                                 ; commit;\n确定分区后，通过定时任务执行对应的SQL即可。\n定时脚本\n通过crontab定时任务完成\n5 4 * * * --daily \n5 4 1 * * ---monthly\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "2"}