{"title": "leetcode-39-Combination Sum - 个人文章 ", "index": "python", "content": "\"\"\"39. Combination SumDescriptionHintsSubmissionsDiscussSolutionGiven a set of candidate numbers (C) (without duplicates) and a target number (T),find all unique combinations in C where the candidate numbers sums to T.\nThe same repeated number may be chosen from C unlimited number of times.\nNote:All numbers (including target) will be positive integers.The solution set must not contain duplicate combinations.For example, given candidate set [2, 3, 6, 7] and target 7,A solution set is:[  [7],  [2, 2, 3]]\n\"\"\"\nimport copy\n\n\nclass Solution:\n    def recursive(self,candidates,target_cur,nums_in,numlist_cur):\n        \"\"\"\n        分为  每次从set里边循环所有数，已有值减去所有数，新值作为已有值，继续处理。遇到0 返回保存，负数去掉\n        :param candidates:\n        :param target:\n        :return:\n        \"\"\"\n        # numlist_cur_in=numlist_cur\n        outlist=[]\n        for index,num in enumerate(candidates):\n            target_cur_new=target_cur-num\n            if target_cur_new==0:\n                numlist_cur.append(nums_in+[num])\n            elif target_cur_new>0:\n                self.recursive(candidates[index:],target_cur_new,nums_in+[num],numlist_cur)\n            else:\n                pass\n\n\n\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        numlist_cur=[]\n\n        out=self.recursive(candidates,target,[],numlist_cur)\n        return numlist_cur\n        # print(out)\n        # print(numlist_cur)\nclass Solution_:\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        self.rec(candidates, target, [], res)\n        return res\n\n\n    def rec(self, candidates, target, path, res):\n        if target < 0:\n            return\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(len(candidates)):\n            self.rec(candidates[i:], target - candidates[i], path + [candidates[i]], res)\nif __name__=='__main__':\n    st=Solution()\n    nums=[2, 3, 6, 7]\n    target=6\n    out=st.combinationSum(nums,target)\n    print(out)\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}