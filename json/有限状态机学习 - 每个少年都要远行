{"title": "有限状态机学习 - 每个少年都要远行 ", "index": "python,java,有限状态机", "content": "有限状态机是什么\n有限状态机（英语：finite-state machine，缩写：FSM）又称有限状态自动机，简称状态机，是表示有限个状态（State）以及在这些状态之间的转移（Transition）和动作（Action）等行为的数学模型。\n状态机有三个特征：\n\n状态（State）总数是有限的。\n在任一时刻，只处于一种状态。\n在某种条件（Event）下，会从某种状态转移（Transition）到另一种状态，同时执行某个动作（Action）。\n\n从有限状态机的定义和特征我们可以看到它的几个重要概念：\n\n状态（State）：包括初始状态和事件触发后的状态，同时必须要有一个最终状态。\n事件（Event）：触发状态机从一种状态切换到另一种状态。\n转移（Transition）：状态切换路径，包含Event(触发该转移的事件)，Source(源状态），Target(目的状态)。\n动作（Action）：表示在进行状态转移后要执行的具体行为。\n\n由于有限状态机的这些特征，我们可以把状态转移的过程做成类似这样的状态转移表。\n\n\n条件\\当前状态\n状态A\n状态B\n状态C\n状态D\n\n\n\n条件X\n状态B\n状态C\n状态D\n...\n\n\n条件Y\n状态C\n状态D\n...\n...\n\n\n条件Z\n...\n状态A\n状态A\n状态A\n\n\n\n可以归纳为一个公式。Old State + Event = New State\n把上面的状态转移表用公式表达就是状态A + 条件X = 状态B状态A + 条件Y = 状态C...\n有限状态机例子\n我们小时候都应该玩过贪吃蛇这个游戏，游戏规则不必再说，我们看看使用有限状态机来实现这个游戏。\n状态转移表：\n\n\n条件\\当前状态\nGAME_OVER\nUP\nDOWN\nLEFT\nRIGHT\n\n\n\nEAT\n...\nUP\nDOWN\nLEFT\nRIGHT\n\n\nHIT\n...\nGAME_OVER\nGAME_OVER\nGAME_OVER\nGAME_OVER\n\n\nTURN_UP\nUP\n...\n...\nUP\nUP\n\n\nTURN_DOWN\nDOWN\n...\n...\nDOWN\nDOWN\n\n\nTURN_LEFT\nLEFT\nLEFT\nLEFT\n...\n...\n\n\nTURN_RIGHT\nRIGHT\nRIGHT\nRIGHT\n...\n...\n\n\n\nEAT：吃掉食物HIT：撞墙或自己TURN_UP：向上转向事件...GAME_OVER： 为了简便一点，我们让它既是开始又是结束的状态，当按下上下左右任一键时开始游戏。UP: 向上前进状态，此时可以吃掉食物，也可以撞到墙或自己，同时可以向左向右转向，但按下向上或向下是不会触发任何动作。...\n当我们把状态转移表定义好之后就会发现这个游戏剩下的部分非常好写，而且逻辑非常清楚，这就是有限状态机的好处。\n有限状态机在编程中有哪些应用\n\n词法分析\n正则表达式\n网络协议\n游戏设计\n自动电话客服\n...\n\n我们用有限状态机做什么\n笔者目前所在的部门是正在使用OpenStack做电子网络靶场的一个项目，必然少不了对虚拟机各项指标的采集，因此对采集进行监控也是必要的措施，以便在采集故障之后及时预警。\n整个监控流程是由客户端（Java微服务）往Kafka中发一条采集配置，采集端（Python）收到这条配置后进行解析配置，然后进行指标采集，同时往Kafka回传一些运行信息，当想要停止采集时需要客户端再次下发一条关闭配置，采集端进行执行并回传至Kafka关闭信息。\n看似这个过程十分简单，像把大象装进冰箱一样简单。\n\n打开冰箱门。\n把大象塞进行。\n关上冰箱门。\n\n使用有限状态机来做其中的状态转移时真的就像是把大象塞进冰箱一样简单（其中使用restful接口接收客户端的开始关闭配置，监听kafka指定topic来处理采集端消息）。\n定义状态转移表\n\n\n条件\\当前状态\nIdle\nprocessing\nwait_close\nexception\ntimeout\nclosed\n\n\n\nstart_conf\n \n \n \n \n \n \n\n\nerror_conf\nclosed\n \n \n \n \n \n\n\npro_start\nprocessing\n \n \n \n \n \n\n\nheartbeat\n \nprocessing\n \n \nprocessing\n \n\n\nerror_runtime\n \nexception\n \n \n \n \n\n\nstop_conf\nwait_close\nwait_close\n \nwait_close\n \n \n\n\npro_stop\n \n \nclosed\nclosed\nclosed\n \n\n\nmsg_timeout\ntimeout\ntimeout\ntimeout\ntimeout\n \n \n\n\nfix\n \n \n \n \nclosed\n \n\n\n\n事件\n\nstart_conf：客户端（Java微服务）采集配置\nerror_conf：采集端（Python）配置解析错误\npro_start：采集端（Python）开始采集\nheartbeat：采集端（Python）正在采集\nerror_runtime ：采集端（Python）采集过程中出错\nstop_conf:客户端（Java微服务）关闭配置\npro_stop: 采集端（Python）退出采集\nmsg_timeout:采集端（Python）消息超时\nfix: 监控端 手动确认任务已经人为修复\n\n状态\n\nIdle：收到采集配置后有限状态机的默认状态\nprocessing：正在采集\nwait_close ：收到关闭配置后等待关闭\nexception：采集异常\ntimeout：超时\nclosed：采集关闭\n\n使用状态机进行编码\n笔者这里使用的库是squirrel-foundation，支持多实例状态机并且和spring进行整合也比较简单。\n总结\n有限状态机能使我们从复杂的状态转移判断中脱离出来，专心业务逻辑，并且避免状态转移过程的判断错误，是一种很强大的模型。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "3"}