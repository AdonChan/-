{"title": "前序遍历树 - 与神兽党一起成长 ", "index": "python", "content": "代码来自：pickle and cPickle – Python object serialization\n首先树的结构，如图\n\nimport pickle\n\nclass Node(object):\n    \"\"\"A simple digraph where each node knows about the other nodes\n    it leads to.\n    \"\"\"\n    def __init__(self, name):\n        self.name = name\n        self.connections = []\n        return\n\n    def add_edge(self, node):\n        \"Create an edge between this node and the other.\"\n        self.connections.append(node)\n        return\n\n    def __iter__(self):\n        return iter(self.connections)\n\ndef preorder_traversal(root, seen=None, parent=None):\n    \"\"\"Generator function to yield the edges via a preorder traversal.\"\"\"\n    if seen is None:\n        seen = set()\n    yield (parent, root)\n    if root in seen:\n        return\n    seen.add(root)\n    for node in root:\n        for (parent, subnode) in preorder_traversal(node, seen, root):\n            yield (parent, subnode)\n    return\n\ndef show_edges(root):\n    \"Print all of the edges in the graph.\"\n    for parent, child in preorder_traversal(root):\n        if not parent:\n            continue\n        print '%5s -> %2s (%s)' % (parent.name, child.name, id(child))\n\n# Set up the nodes.\nroot = Node('root')\na = Node('a')\nb = Node('b')\nc = Node('c')\n\n# Add edges between them.\nroot.add_edge(a)\nroot.add_edge(b)\na.add_edge(b)\nb.add_edge(a)\nb.add_edge(c)\na.add_edge(a)\n\nprint 'ORIGINAL GRAPH:'\nshow_edges(root)\n\n# Pickle and unpickle the graph to create\n# a new set of nodes.\ndumped = pickle.dumps(root)\nreloaded = pickle.loads(dumped)\n\nprint\nprint 'RELOADED GRAPH:'\nshow_edges(reloaded)\n\n\n输出结果：\n\n$ python pickle_cycle.py\n\nORIGINAL GRAPH:\n root ->  a (4299721744)\n    a ->  b (4299721808)\n    b ->  a (4299721744)\n    b ->  c (4299721872)\n    a ->  a (4299721744)\n root ->  b (4299721808)\n\nRELOADED GRAPH:\n root ->  a (4299722000)\n    a ->  b (4299722064)\n    b ->  a (4299722000)\n    b ->  c (4299722128)\n    a ->  a (4299722000)\n root ->  b (4299722064)\n\n\n其中preorder_traversal是生成器。这里记录下生成器方法的每一步的意思。\n\n# root 要遍历的根节点\n# seen 保存遍历过的节点（集合）\n# parent 每次yield的父节点，有可能不存在\ndef preorder_traversal(root, seen=None, parent=None):\n    \"\"\"Generator function to yield the edges via a preorder traversal.\"\"\"\n    if seen is None: # 如果没有开始遍历，seen是空，初始化集合\n        seen = set()\n    yield (parent, root) # 记一次输出，这个要在下面判断之前\n    if root in seen: # 要遍历的根节点是否已经遍历过，防止循环遍历\n        return\n    seen.add(root) # 保存已遍历的“根”节点\n    for node in root: # 遍历子节点\n        for (parent, subnode) in preorder_traversal(node, seen, root):\n            yield (parent, subnode)\n    return\n\n\n一开始不明白的地方是这样\n\n    yield (parent, root) # 记一次输出，这个要在下面判断之前\n    if root in seen: # 要遍历的根节点是否已经遍历过，防止循环遍历\n        return\n\n\n为什么不是先判断呢。\n看循环引用的情况。\n前序输出从root -> a -> b -> a这一路下来，有两个a是正确的，\n如果先判断要遍历的节点是否已经遍历过的话，那么b -> a就走不通了，所以应该允许，点到就记一次输出，再来判断是否能继续往下走。b -> a记一次输出，接下来发现a已经遍历过它的子节点了(a in seen)，才停止不往下遍历。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}