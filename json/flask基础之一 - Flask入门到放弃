{"title": "flask基础之一 - Flask入门到放弃 ", "index": "html,css,html5,python", "content": "flask基础之一\nhello world\n#从flask这个包中导入Flask这个类\n#Flask这个类是项目的核心，以后的很多操作都是基于这个类的对象\n#注册url，注册蓝图都是这个类的对象\nfrom flask import Flask\n#创建一个Flask对象，传递__name__这个参数进去\n#__name__这个参数的作用：\n# 1.规定模板和静态资源的路径\n# 2.以后的一些Flask插件，比如Flask_migrate,Flask_SQLAlchemy报错的话，哪么Flask就会通过这个参数找到具体的报错位置\napp = Flask(__name__)\n# @app.route()是一个装饰器，将对应的“/”路径应用到hello_world()这个函数上面\n# 在访问“/”的时候在页面上返回Hello World\n@app.route('/')\ndef hello_world():\n    return 'Hello World!'\n# 如果作为一个主文件运行，哪么执行app.run()方法，也就是启动这个网站\nif __name__ == '__main__':\n    app.run()\ndebug模式\n为什么要开启DEBUG模式？\n\n如果开启了debug模式，name代码在调试过程中出现了异常，在浏览器页面中可以看到具体的报错信息，以及具体的错误代码位置，方便开发者调试。\n如果flask开启了debug模式，name以后再python中修改任何代码，只要在pycharm中使用ctrl+s即可保存重载，不需要手动去重载程序\n\n如何配置debug模式：\napp.run()\napp.run（debug=True）\napp.debug\napp.debug = True\n配置信息方式（使用参数形式的方式）\napp.config.update[DEBUG=True]\n#其实也就是update了config字典\n通过配置文件的形式\n- 创建一个config.py的配置文件，写入\nDEBUG = True\n- 然后在你的app.py文件中写入\napp.config.from_object(config) #即可读取配置文件中的DEBUG=True\ndebug PIN码\nD:\\MyDevSoftInstallDir\\Python3\\python3.exe D:/myflask/base/base.py\n* Restarting with stat\n* Debugger is active!\n* Debugger PIN: 177-952-649\n* Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)\n然后在页面上调试代码的时候用到。也是为了安全考虑。\n配置文件两种方式详解\n第一种方式：\n在项目主路径下创建config.py\nDEBUG=True\n然后在主项目里面去读取config.py里面的配置：\nfrom flask import Flask\nimport config\napp = Flask(__name__)\napp.config.from_object(config)\n第二种方式：直接读取文件的形式，也可以是普通的txt文件形式；这种方式不需要直接import config\n\n在项目主路径下创建config.py\nDEBUG=True\n然后在主项目里面去读取config.py里面的配置：\nfrom flask import Flask\napp = Flask(__name__)\napp.config.from_pyfile('config.py',silent=True) #静默模式加载配置文件（找不到配置文件不报错）,文件的后缀名不可少\nurl与视图函数的映射\n传递参数：\n传递参数的语法是/<参数类型:参数名称>/，然后在视图函数中也要定义同名的参数\n参数的数据类型\n\nstring：只接受字符串，没有任何“/或者”的文本\nint：只接受整数\nfloat：只接受浮点数，整数都不行哈\npath：和string类似，但是接受斜杠\nuuid：只有接受符合uuid的字符赤岸，一般用作表的主键\nany：可以指定多种路径\n\n接收用户传递参数的方式：\n\n使用path的方式（将参数嵌入到路径中）\n使用查询字符串的形式 （也就是通过?key=value的形式传递的，只能通过request.args.get的方式来获取）\n\n如果页面想要做SEO优化的话，那么推荐使用path的形式，反之就是查询字符串的形式练习\nfrom flask import Flask,request\napp = Flask(__name__)\n@app.route('/')\ndef hello_world():\n    return 'Hello World!'\n@app.route('/list/')\ndef article_list():\n    return 'article list!'\n@app.route('/p1/<article_id1>')\ndef article_detail(article_id1):\n    return \"请求的文章是：%s\" %article_id1\n@app.route('/p2/<string:article_id2>')\ndef article_detail2(article_id2):\n    return \"请求的文章是：%s\" %article_id2\n@app.route('/p3/<int:article_id3>')\ndef article_detail3(article_id3):\n    return \"请求的文章是：%s\" %article_id3\n@app.route('/p4/<path:article_id4>')\ndef article_detail4(article_id4):\n    return \"请求的文章是：%s\" %article_id4\n# import uuid\n# print(uuid.uuid4())\n@app.route('/p5/<uuid:article_id5>') #数据的唯一性，长度较长，有损效率（一般在用户表中使用）6a9221f6-afea-424a-a324-8ceaa5bdfc98\ndef article_detail5(article_id5):\n    return \"请求的文章是：%s\" %article_id5\n@app.route('/p6/<any(blog,user):url_path>/<id>/')\ndef detail(url_path,id):\n    if url_path == \"blog\":\n        return \"博客详情 %s\" %id\n    else:\n        return \"用户详情 %s\" %id\n#通过问号形式传递参数\n@app.route('/d/')\ndef d():\n    wd = request.args.get('wd') #获取浏览器传递参数\n    return '通过查询字符串的方式传递的参数是，%s'%wd #请求http://127.0.0.1:8080/d/?wd=php\nif __name__ == '__main__':\n    app.run(debug=True,host='0.0.0.0',port=8080)\nurl_for\n\n将视图函数反转回URL，跟app.route相反\nURL的更新大于视图函数，所以在大规模项目中比较实用\n\n* 基本使用 ：\n\nurl_for的第一个参数是视图函数的函数名对应的字符串（endpoint），后面的参数就是你传递给url；如果传递的参数在url中已经定义了，那么这个参数就会被当成path的值传递给url；如果这个参数没有在url中定义，那么将变成查询字符串的形式\nfrom flask import Flask,url_for,request\napp.route('/')\n    return url_for('my_list',page=1,count=2) #这样的话就会在页面上构建出/post/list/1/?count=2的信息\napp.route('/post/list/<page>/')\ndef my_list():\n    return 'my list'\n为什么需要url_for？\n如果将来要修改URL，但没有修改URL对应的函数名，就不用到处去替换URL了。URL会自动处理特殊字符（转义成十六进制），不需要手动去处理\nfrom flask import Flask,url_for,request\n@app.route('/')\ndef hello_world():\n    return url_for('login',next='/current') #页面返回/login/?next=%2Fcurrent登录前的信息\n    # print(url_for('my_list',page=1,count=200))\n    # return 'hello world'\n@app.route('/login/')\ndef login():\n    # next = request.args.get('next') #登录前的信息，在登陆之后仍旧保持\n    return 'login'\n@app.route('/list/<page>')\ndef my_list():\n    return 'my list'\n@app.route('/detail/<id>/')\ndef detail():\n    return 'detail'\nif __name__ == '__main__':\n    app.run(debug=True)\n自定义url转换器\nurl的参数转换成满足自己需求的数据类型\n自定义url转换器的方式：\n实现一个类，继承BaseConverter\n\n\n在自定义的类中重写regex，也就是这个变量的正则表达式\n将自定义的类映射到app.url_map.converters上。\n\n实现用户访问/posts/a+bto_python的作用这个方法的返回值会传到view函数中作为参数to_url的作用这个方法的返回值会调用url_for来生成符合要求的url形式\nfrom flask import Flask,url_for\nfrom werkzeug.routing import BaseConverter\napp = Flask(__name__)\n#手机号码正则\nclass TelephoneConveter(BaseConverter):\n    regex = r'1[85734]\\d{9}'\napp.url_map.converters['tel'] = TelephoneConveter\n#用户访问/posts/a+b/\nclass ListConverter(BaseConverter):\n    def to_python(self, value):\n        return value.split(\"+\")\n    def to_url(self, value):\n        print(value)\n        return '+'.join(value)\n        # return \"hello\"\napp.url_map.converters['list'] = ListConverter\n@app.route('/')\ndef hello_world():\n    print(url_for('posts',broads=['a','b']))\n    return 'Hello World!'\n@app.route('/user/<int:user_id>/')\ndef user(user_id):\n    return \"your user id is %d\" %user_id\n@app.route('/telephone/<tel:my_tel>/')\ndef my_tel(my_tel):\n    return \"your telephone number is %s\"%my_tel\n@app.route('/posts/<list:broads>/')\ndef posts(broads):\n    # broads = broads.split(\"+\")\n    return \"your posts is %s\"%broads\nif __name__ == '__main__':\n    app.run(debug=True)\n小细节\n在局域网访问站点\napp.run(host='0.0.0.0')\n指定端口号\n默认是5000端口，修改端口如下\napp.run(host='0.0.0.0',port=8899 )\nulr唯一\n\n在定义URL的时候，尽量在url后面加/，原因如下：\n\n如果不加/的话浏览器访问这个url的时候会默认加/，这样的话就访问不到了\n搜索引擎会将不加/的url和加/的url是两个不同的url，会将其误解。\n\n\nGET和POST请求\n在网络请求中有许多的请求方式，比如GET,POST,DELETE,PUT,常用的请求方式如下：\n\n\nGET：也就是获取服务器上的资源，不会修改服务器上的内容。\n\nPOST：就是向服务器提交文件或者数据，一般POST会对服务器的状态产生影响。\n\n关于参数传递：\n\n\nGET：把参数放到URL中，通过?xx=xxx的形式传递的，因为会把参数放到url中，所以视力好的话，一眼就可以看到传递的参数。\n\nPOST：把参数放到Form Data中，避免被偷窥到的风险（也有可能通过抓包的方式被窃取），一般不安全的，不晓得提交的内容是否是带病毒的文件。\n\n\n\n在flask中，route方法，默认只能使用GET的方式请求url。如果想要设置自己的请求方式，那就要在methods中多传递一个请求方式的参数。实例如下：创建url_detail的项目，项目结构如下：\n├─url_detail.py\n├─static\n└─templates\n   |_login.html\nurl_detail.py\"\nfrom flask import Flask,request,render_template\napp = Flask(__name__)\n@app.route('/',methods=['GET'])\ndef hello_world():\n    return 'Hello World!'\n@app.route('/list/',methods=['POST'])\ndef my_list():\n    return 'list'\n@app.route('/login/',methods=[\"POST\",\"GET\"])\ndef login():\n    if request.method == 'GET':\n       return render_template('login.html')\n    else:\n        return \"Success\"\nif __name__ == '__main__':\n    app.run(debug=True,host='0.0.0.0')\ntemplates/login.html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<form action=\"\",method=\"POST\">\n    <input type=\"text\",name=\"username\">\n    <input type=\"text\",name=\"password\">\n    <input type=\"submit\",name=\"submmit\">\n</form>\n</body>\n</html>\nURL重定向\n也就是从一个页面跳转到另一个页面，也就是重新定位一个方向分类：\n\n永久性重定向：http的状态码是301，多用于旧的网址废弃了要转到一个新的网址，确保用户的访问。最经典的就是jingdong.com了\n暂时性重定向：http的状态码是302，表示页面暂时性被跳转，比如访问一个需要权限的网址，如果当前用户没有登录，应该重定向到登录页面。这种情况的话就是用暂时性重定向。\n\n在flask中，重定向是通过flask.redirect(location,code=302)这个函数来实现的，location指的是需要重定向到的URL，应该配合之前讲过的url_for()来是用。code代表的是什么类型的重定向，默认是302，可以修改成301实现永久重定向。\n小例子：\nfrom flask import Flask,url_for,redirect,request\napp = Flask(__name__)\napp.debug = True\n@app.route('/login/',methods=['GET','POST'])\ndef login():\n    return 'login page'\n@app.route('/profile/',methods=['GET','POST'])\ndef profile():\n    name = request.args.get('name')\n    if not name:\n        return redirect(url_for('login'))\n    else:\n        return name\nif __name__ == '__main__':\n    app.run()\n这样的话就能访问profile了：\nhttp://127.0.0.1:5000/profile/?name=sss\n关于响应\n视图函数的返回值会被自动转换成一个响应对象，flask的转换逻辑如下：\n\n如果返回的是一个合法的响应对象，则直接返回\n如果返回的是一个字符串，那么flask会重新创建一个werkzeug.wrappers.Response对象。Response会将该字符串作为主体，状态码为200，MIME的类型为text/html，然后返回给Response对象\n如果返回的是一个元组，元组中的数据类型是response,status,headers，status会覆盖默认的200状态码，headers可以是一个字典或者列表。作为额外的消息头\n如果以上的条件都不满足，flask会假设返回值是一个合法的WSGI应用程序，并通过Response.force_type(rv,request.environ)转换成一个请求对象。\n\n自定义响应：\n\n必须继承自Response类\n实现类方法：force_type\n\n必须指定app.response_class为你自定义的Response\n如果视图函数返回的数据既不是字符串，也不是元组，也不是Response对象，那么会将返回值传给force_type，然后将force_type的返回值返回给前端。\n\n\n\n#!/usr/bin/python\n# -*- coding:utf8 -*-\nfrom flask import Flask,Response,jsonify\nimport json\napp = Flask(__name__)\napp.debug = True\n#自定义响应\nclass JSONResponse(Response):\n    @classmethod\n    def force_type(cls, response, environ=None):\n        '''\n        这个方法只有视图函数返回非字符串，非元组，非Response对象才会调用\n        :param response:\n        :param environ:\n        :return:\n        '''\n        print response\n        print type(response)\n        if isinstance(response,dict):\n            #jsonify除了将字典转换成为json对象，还将对象封装成了一个Response对象\n            response = jsonify(response)\n            #response = json.dumps(response) #这样转换的话程序启动会报错\n        return super(JSONResponse,cls).force_type(response,environ) #返回父类信息\napp.response_class = JSONResponse\n@app.route('/')\n#第一种情况\ndef hello_world():\n    #Response('Hello World',status=200,mimetype='text/html')\n    return 'Hello World!'\n#第二种情况\n@app.route('/list1/')\ndef list1():\n    resp = Response('List1')\n    resp.set_cookie('country','china')\n    return resp\n#第三种情况\n@app.route('/list2')\ndef list2():\n    return 'list2',200,{'X-Name':'abc'}\n@app.route('/list3/')\ndef list3():\n    return {\"username\":\"abc\",\"age\":11}\nif __name__ == '__main__':\n    app.run(host='0.0.0.0')\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "2"}