{"title": "Python：Tornado 第一章：异步及协程基础：第三节：协程 - python3 ：公司内部培训专栏 ", "index": "python", "content": "上一篇文章：Python：Tornado 第一章：异步及协程基础：第二节：Python关键字yield下一篇文章：Python：Tornado 第二章：实战演练：开发Tornado网站：第一节：网站结构：HelloWorld\n\n使用Tornado协程可以开发出类似同步代码的异步行为。同时，因为协程本身不使用线程，所以减少了线程上下文切换的开销，是一种高效的开发模式。\n1、编写协程函数\n实例：用协程技术开发网页访问功能\n#用协程技术开发网页访问功能\nfrom tornado import  gen #引入协程库gen\nfrom tornado.httpclient import AsyncHTTPClient\nimport time\n\n#使用gen.coroutine修饰器\n@gen.coroutine\ndef coroutine_visit():\n    http_client=AsyncHTTPClient()\n    response=yield http_client.fetch(\"http://www.baidu.com\")\n    print(response.body)\n本例中任然使用了异步客户端AsyncHTTPClient进行页面访问，装饰器@gen.coroutine声明这是一个协程函数，由于yield关键字的作用，使得代码中不用再编写回调函数用于处理访问结果，而可以直接在yield语句的后面编写结果处理语句。\n2、调用协程函数\n由于Tornado协程基于Python的yield关键字实现，所以不能像普通函数那样直接调用。协程函数可以通过以下三张方式调用：\n\n在本身是协程的函数内通过yield关键字调用。\n在IOLoop尚未启动时，通过IOLoop的run_sync()函数调用。\n在IOLoop已经启动时，通过IOLoop的spawn_callback()函数调用。\n\n实例：通过协程函数调用协程函数\n代码：\n#用协程技术开发网页访问功能\nfrom tornado import  gen #引入协程库gen\nfrom tornado.httpclient import AsyncHTTPClient\nimport time\n\n#使用gen.coroutine修饰器\n@gen.coroutine\ndef coroutine_visit():\n    http_client=AsyncHTTPClient()\n    response=yield http_client.fetch(\"http://www.baidu.com\")\n    print(response.body)\n\n@gen.coroutine\ndef outer_coroutine():\n    print(\"start call coroutine_visit\")\n    yield coroutine_visit()\n    print(\"end call coroutine_cisit\")\n本例中outer_coroutine()和coroutine_visit()都是协程函数，所以他们之间可以通过yield关键字调用。_\n实例：IOLoo尚未启动时，通过IOLoop的run_sync()函数调用。\nIOLoop是Tornado的主事件循环对象，Tornado程序通过它监听外部客户端的访问请求，并执行相应操作。\n代码：\n#用协程技术开发网页访问功能\nfrom tornado import  gen #引入协程库gen\nfrom tornado.httpclient import AsyncHTTPClient\nfrom tornado.ioloop import IOLoop  #引入IOLoop对象\n\n#使用gen.coroutine修饰器\n@gen.coroutine\ndef coroutine_visit():\n    http_client=AsyncHTTPClient()\n    response=yield http_client.fetch(\"http://www.baidu.com\")\n    print(response.body)\n\ndef func_normal():\n    print(\"start call coroutine_visit\")\n    IOLoop.current().run_sync(lambda :coroutine_visit())\n    print(\"end call coroutine_visit\")\n当程序尚未进入IOLoop的running状态时，可以通过run_sync()函数调用协程函数。⚠️注意：run_sync()函数将阻塞当前函数的调用，直到被调用的协程执行完成。\n事实上，Tornado要求协程函数在IOLoop的running状态种才能被调用，只不过run_sync函数自动完成了启动、停止IOLoop的操作步骤，他的实现逻辑是：\n【启动IOLoop】》【调用被lambda封装的协程函数】》【停止IOLoop】\n\n实例：在IOLoop启动时，通过spawn_callback()函数调用\n代码：\n#用协程技术开发网页访问功能\nfrom tornado import  gen #引入协程库gen\nfrom tornado.httpclient import AsyncHTTPClient\nfrom tornado.ioloop import IOLoop  #引入IOLoop对象\n\n#使用gen.coroutine修饰器\n@gen.coroutine\ndef coroutine_visit():\n    http_client=AsyncHTTPClient()\n    response=yield http_client.fetch(\"http://www.baidu.com\")\n    print(response.body)\n\ndef func_normal():\n    print(\"start call coroutine_visit\")\n    IOLoop.current().spawn_callback(coroutine_visit)\n    print(\"end call coroutine_visit\")\nspawn_callback()函数将不会等待被调用协程执行完成，所有上下两条打印语句将马上完成，而coroutine__visit本身将会由IOLoop在合适的时机进行调用。⚠️注意：IOLoop的spawn_callback()函数没有为开发者提供获取协程函数调用返回值的方法，所以只能用span_callback()调用没有返回值的协程函数。\n\n3、在协程中调用阻塞函数\n在协程中直接调用阻塞函数会影响协程本身的性能，所以Tornado提供了在协程中利用线程池调度阻塞函数，从而不影响协程本身继续执行的方法。\n代码实例：\nfrom concurrent.futures import ThreadPoolExecutor\nfrom tornado import gen\n\n#定义线程池\nthread_pool=ThreadPoolExecutor(2)\n\ndef mySleep(count):\n    import time\n    for x in range(count):\n        time.sleep(1)\n\n@gen.coroutine\ndef call_blocking():\n    print(\"start\")\n    yield thread_pool.submit(mySleep,10)\n    print(\"end\")\n代码中首先引用了concurrent.futures种的ThreadPoolExecutor类，实例化了一个由两个线程的线程池thread_pool。在需要调用阻塞函数的协程call_blocking种，使用thread_pool.submit调用阻塞函数，并通过yield返回。这样便不会阻塞协程所在的线程的继续执行，也保证了阻塞函数前后代码的执行顺序。\n4、在协程中等待多个异步调用\n到目前为止，我们知道了协程中一个yield关键字等待一个异步调用的编程方法。其实，Tornado允许在协程中用一个yield关键字等待多个异步调用，只需要把这些调用以列表(list)或字典(dictionary)的方式传递给yield关键字即可。\n实例：使用列表方式传递多个异步调用\n#使用列表方式传递多个异步调用\nfrom tornado import gen  #引入协程库gen\nfrom tornado.httpclient import AsyncHTTPClient\n\n@gen.coroutine   #使用gen.coroutine修饰器\ndef coroutine_visit():\n    http_client=AsyncHTTPClient()\n    list_response=yield [\n        http_client.fetch(\"http://www.baidu.com\"),\n        http_client.fetch(\"http://www.api.jiutouxiang.com\")\n    ]\n    for response in list_response:\n        print(response.body)\n\n\n\n在代码中仍然使用@gen.coroutine装饰器定义协程，在需要yield的地方用列表传递若干个异步调用，只有在列表种的所有调用都执行完成后，yield才会返回并且继续执行。yield以列表方式返回调用结果。\n实例：用字典方式传递多个异步调用：\n#使用列表方式传递多个异步调用\nfrom tornado import gen  #引入协程库gen\nfrom tornado.httpclient import AsyncHTTPClient\n\n@gen.coroutine   #使用gen.coroutine修饰器\ndef coroutine_visit():\n    http_client=AsyncHTTPClient()\n    dict_response=yield {\n       \"baidu\": http_client.fetch(\"http://www.baidu.com\"),\n        \"9siliao\":http_client.fetch(\"http://www.api.jiutouxiang.com\")\n    }\n    print(dict_response[\"baidu\"].body)\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "0"}