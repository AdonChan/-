{"title": "Python 用函数重构经典策略模式 - 终南山下 ", "index": "python", "content": "前言\n合理使用作为一等对象的函数，可以使某种设计模式得以简化。\n关于策略\n定义一系列算法，把它们一一封装起来，并且使它们可以相互替换。\n一个策略模式的示例\n\n规则\n1 有1000或以上积分的客户，每个订单享受5%的折扣。\n2 同一个订单中，单个商品的数量达到20个或以上，享受10%折扣。\n3 订单中的不同商品数达到10个或以上，享受7%折扣。\n\n\n策略模式\n上下文\n把一些计算委托给实现不同算法的可互换组件，它提供服务。本例中，上下文是Order，它会根据不同的算法计算促销折扣\n策略\n实现不同算法的组件共同的接口。本例中Promotion这个抽象类扮演这个角色。\n具体策略\n策略的具体子类。本例中为 fidelityPromo, BulkPromo, LargeOrderPromo三个子类。\n\n经典模式\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# @File    : ex1.py\n# @Time    : 18/10/09 17:01\n\nfrom abc import ABC, abstractmethod\nfrom collections import namedtuple\n\nCustomer = namedtuple('Customer', 'name fidelity')\n\nclass LineItem:\n\n    def __init__(self, product, quantity, price):\n        self.product = product\n        self.quantity = quantity\n        self.price = price\n\n    def total(self):\n        return self.price * self.quantity\n\n\nclass Order:  # 上下文\n\n    def __init__(self, customer, cart, promotion=None):\n        self.customer = customer\n        self.cart = cart\n        self.promotion = promotion\n\n    def total(self):\n        if not hasattr(self, '__total'):\n            self.__total = sum(item.total() for item in self.cart)\n        return self.__total\n\n    def due(self):\n        if self.promotion is None:\n            discount = 0\n        else:\n            discount = self.promotion.discount(self)\n        return self.total() - discount\n\n    def __repr__(self):\n        fmt = '<Order total: {:.2f} due: {:.2f}>'\n        return fmt.format(self.total(), self.due())\n\n\nclass Promotion(ABC):  # 策略:抽象基类\n\n    @abstractmethod\n    def discount(self, order):\n        '''\n        返回折扣金额(正值)\n        :param order:\n        :return:\n        '''\nclass FidelityPromo(Promotion):  # 第一个具体策略\n    '''\n    为积分1000或以上的顾客提供5%折扣\n    '''\n\n    def discount(self, order):\n        return order.total() * .05 if order.customer.fidelity >= 1000 else 0\n\nclass BulkItemPromo(Promotion): # 第二个具体策略\n    '''\n    单个商品为20个或以上时提供10%折扣\n    '''\n\n    def discount(self, order):\n        discount = 0\n        for item in order.cart:\n            if item.quantity >= 20:\n                discount += item.total() * .1\n        return discount\n\nclass LargeOrderPromo(Promotion): # 第三个具体策略\n    '''\n    订单中的不同商品达到10个或以上时提供7%折扣\n    '''\n\n    def discount(self, order):\n        distinct_items = {item.product for item in order.cart}\n        if len(distinct_items) >= 10:\n            return order.total() * .07\n        return 0\n\n# 两个顾客:joe的积分为0，ann的积分是1100\njoe = Customer('John Doe', 0)\nann = Customer('Ann Smith', 1100)\n\n# 有3个商品的购物车\ncart = [LineItem('banana', 4, .5), LineItem('apple', 10, 1.5), LineItem('watermellon', 5, 5.0)]\n\n# joe未享受到折扣，ann享受到了5%折扣\nex1 = Order(joe, cart, FidelityPromo())\nex2 = Order(ann, cart, FidelityPromo())\n\n# banana数量超过20个,joe享受到了10%的折扣\nbanana_cart = [LineItem('banana', 30, .5), LineItem('apple', 10, 1.5)]\nex3 = Order(joe, banana_cart, BulkItemPromo())\n\n# 商品数量超过了10个，为joe提供了7%的折扣\nlong_order = [LineItem(str(item_code), 1, 1.0) for item_code in range(10)]\nex4 = Order(joe, long_order, LargeOrderPromo())\nex5 = Order(joe, cart, LargeOrderPromo())\n\nprint(ex1)\nprint(ex2)\nprint(ex3)\nprint(ex4)\nprint(ex5)\n函数模式\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# @File    : ex2.py\n# @Time    : 18/10/10 10:46\n\nfrom collections import namedtuple\n\nCustomer = namedtuple('Customer', 'name fidelity')\n\nclass LineItem:\n\n    def __init__(self, product, quantity, price):\n        self.product = product\n        self.quantity = quantity\n        self.price = price\n\n    def total(self):\n        return self.price * self.quantity\n\nclass Order:  # 上下文\n\n    def __init__(self, customer, cart, promotion=None):\n        self.customer = customer\n        self.cart = cart\n        self.promotion = promotion\n\n    def total(self):\n        if not hasattr(self, '__total'):\n            self.__total = sum(item.total() for item in self.cart)\n        return self.__total\n\n    def due(self):\n        if self.promotion is None:\n            discount = 0\n        else:\n            discount = self.promotion(self)\n        return self.total() - discount\n\n    def __repr__(self):\n        fmt = '<Order total: {:.2f} due: {:.2f}>'\n        return fmt.format(self.total(), self.due())\n\ndef fidelity_promo(order):\n\n    return order.total() * .05 if order.customer.fidelity >= 1000 else 0\n\ndef bulk_item_promo(order):\n\n     discount = 0\n     for item in order.cart:\n         if item.quantity >= 20:\n             discount += item.total() * .1\n     return discount\n\ndef large_order_promo(order):\n\n     distinct_items = {item.product for item in order.cart}\n     if len(distinct_items) >= 10:\n         return order.total() * .07\n     return 0\n\n\n# 两个顾客:joe的积分为0，ann的积分是1100\njoe = Customer('John Doe', 0)\nann = Customer('Ann Smith', 1100)\n\n# 有3个商品的购物车\ncart = [LineItem('banana', 4, .5), LineItem('apple', 10, 1.5), LineItem('watermellon', 5, 5.0)]\n\neg1 = Order(joe, cart, fidelity_promo)\neg2 = Order(ann, cart, fidelity_promo)\n\nbanana_cart = [LineItem('banana', 30, .5), LineItem('apple', 10, 1.5)]\neg3 = Order(joe, banana_cart, bulk_item_promo)\n\nlong_order = [LineItem(str(item_code), 1, 1.0) for item_code in range(10)]\neg4 = Order(joe, long_order, large_order_promo)\n\nprint(eg1,'\\n', eg2, '\\n',  eg3, '\\n', eg4)\n对比\n\n经典模式中每个具体策略都是一个类，而且只定义了一个方法，即discount。此外，策略实例没有状态(实例属性)\n\n使用函数代替抽象类，每个策略都是函数，不必实例化，拿来即用。新的Order类使用起来更简单，代码行数更少。\n参考\n<<流畅的Python>>\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}