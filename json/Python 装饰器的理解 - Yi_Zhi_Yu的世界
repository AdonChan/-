{"title": "Python 装饰器的理解 - Yi_Zhi_Yu的世界 ", "index": "装饰器,python", "content": "Python的装饰器可以实现在代码运行期间修改函数的上下文， 即可以定义函数在执行之前进行何种操作和函数执行后进行何种操作， 而函数本身并没有任何的改变。\n这个看起来很复杂， 实际上应用到了我之前说过的闭包的概念， 仔细看一看， 其实并不复杂。\n首先， 我们先定义一个函数， 这个函数可以输出我的个人昵称：\n    def my_name():\n        print \"Yi_Zhi_Yu\"\n    my_name() # Yi_Zhi_Yu\n那假如我需要在个人昵称输出前， 在输出我的个人uid呢， 当然， 要求是不改动现有的my_name函数， 这个时候就可以使用装饰器了\n首先， 装饰器也是个函数, 其次， 他需要接受一个参数，该参数表示了要被装饰的函数(即my_name)：\n    def my_info(func):\n        def wrapper(*args, **params):\n            print 218\n            return func(*args, **params)\n        return wrapper\n然后与相应的被装饰函数关联起来的方法就是使用@my_info写在被装饰函数的前面\n    @my_info\n    def my_name():\n        print \"Yi_Zhi_Yu\"\n最后， 在执行my_name的时候， 就能既输出我的uid， 又能输出我的昵称了\n    my_name()\n    #218\n    #Yi_Zhi_Yu\n在上面， 最让我们疑惑的是装饰器函数定义里面的wrapper函数， 装饰器本身返回的是wrapper函数的定义， 而wrapper中则定义了对被装饰函数(my_name)的调用， func表示的就是被装饰函数, 说白了， 装饰器只是把某个不得改动的函数(a)放到另一个函数(b)中， 在b里面调用a, 在调用前后就可以做所谓的看起来像装饰的工作了。my_info的最终返回的wrapper函数的定义， 并不是执行结果，只有当wrapper真正执行的时候， 才会真正的执行my_name方法， 这就是闭包时所说的内容。wrapper中的参数， 实际上则是传递给func(实际上是my_name)的参数\n因为装饰器也是个函数， 那么装饰器自己的能不能有参数传递呢。可以， 不过需要定义一个更高阶的函数， 也就是外面还要套一层函数， 比如， 我还要输出我的自定义的一个信息，需要传递参数\n    def c_info(text):\n        def my_info(func):\n            def wrapper(*args, **params):\n                print text\n                print 218\n                return func(*args, **params)\n            return wrapper\n        return my_info\n        \n     #使用装饰器\n     @c_info(\"Tony\")\n     def my_name():\n        print \"Yi_Zhi_Yu\"\n        \n     my_name()\n     #Tony\n     #218\n     #Yi_Zhi_Yu\n与前面的那个装饰器相比， 仅仅是多了个外层， 内层也仅仅是增加了对外层传入参数(text)的调用\n总而言之， Python在函数定义中支持了对oop思想中的装饰器的实现， 其本质也只是使用了闭包的思路， 延迟调用， 并在调用前后增加自己的其他实现内容\nPs: 以上皆为学习笔记， 附带自己的理解， 难免有偏差， 如有发现纰漏， 还望指正\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "31"}