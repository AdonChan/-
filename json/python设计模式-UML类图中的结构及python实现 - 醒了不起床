{"title": "python设计模式-UML类图中的结构及python实现 - 醒了不起床 ", "index": "python,设计模式", "content": "前言\n最近在看设计模式。在学习初期一直有一个问题困扰着我，那就是UML类图  中的各种结构用python代码是如何实现的？这个在初期可以说是深深的困扰着我的设计模式  学习之路。下面我将介绍一下我自己总结的实现，如果有错误也希望各位给指出，不胜感激。\n工具介绍\n本文的UML图采用Enterprise Architect绘制。  Python版本2.7.12  （在用了Enterprise Architect 后才知道他有从类图导出代码的功能，/捂脸  早知道就用这个学习各种结构的实现了。文末有介绍如何用Enterprise Architect 导出代码。）\n类图\n类图是由类和类之间的连接关系构成。  类我们这里只介绍类和抽象类。连接关系我们介绍泛化(generalization)、实现(realize)、聚合(aggregation)、组合(compositon)、关联(assocation)和依赖(dependency)共六种。\n类\n抽象类（java中接口）\n图示\n接口在UML中的图形为  \n可以看到再其上半部分有一个interface的表示。在接口中一般只给出接口的定义  而实现一般放在子类和实现。\n代码\n在python中本事是没有接口和抽象类这一概念的，但是可以通过abc(Abstract Base Class)这个python库来实现。或者是通过抛出NotImplementedError这个异常来实现。\n通过abc模块来实现\nfrom abc import ABCMeta, abstractmethod, abstractproperty\n\nclass Drawable:\n    __metaclass__ = ABCMeta\n\n    @abstractproperty\n    def size(self):\n        pass\n\n    @abstractmethod\n    def draw(self, x, y, scale=1.0):\n        pass\n\n\nclass Cicle(Drawable):\n    def size(self):\n        print 'Cicle'\n\n    def draw(self, x, y, scale=1.0):\n        print str(x*y*scale)\n\nc = Cicle()\n如果在子类里面没有实现方法，当实例化子类的时候会报错。abc模块的具体使用这里就不介绍了。放上abc的 PEP3119\n通过抛异常来实现\nclass Drawable1:\n    def size(self):\n        raise NotImplementedError\n\n    def draw(self, x, y, scale=1.0):\n        raise NotImplementedError\n\n\nclass Cicle(Drawable):\n    def size(self):\n        print 'Cicle'\n\n    def draw(self, x, y, scale=1.0):\n        print str(x*y*scale)\n\nc = Cicle()\nc.draw()\n这里如果子类没有实现方法，在实例化的时候不会报错。只有当调用到未实现的方法时候才会报错。这种通过abc的注册机制也可以实现。\n类\n图示\n类的图示如下  \n可以看到整个图形分为三部分：上面为类名，中间为类属性，下面为类方法。  其中可以看到有- + 和# 三种符号，其分别代表私有、公有、保护。其中保护变量在python中是不存在的。公有变量可以在类外被直接访问。且可以被子类继承，私有变量只能再此类中被访问且不可以被子类继承。\n代码\nclass Flower(object):\n    def __init__(self, floral=None, leaf=None):\n        self.floral = floral\n        self.__leaf = leaf\n        \n    def flowing(self):\n        print 'flower'\n        \n    def __grow(self):\n        print 'grow grow'\n其中以两条下划线开头的变量为私有变量，方法为私有方法。其实在python中也不是在类外面无法访问到私有变量或方法。只是在生成python字节码的时候在编译器自动再含有__ 开头的属性或变量前加上了 _{classname}了你可以在类外通过  _Flower__leaf 访问到__leaf属性，当然这并没有什么意义。\n连接关系\n泛化（generalization）\n图示\n首先我们来看一下泛化关系的UML结构图。  \n连接器的是由一条直线和一个三角组成的，连接的两端都是类。在代码中的结构就是继承非抽象类。\n代码\nclass Car(object):\n    def __init__(self):\n        self.wheel = ['11', '12', '21', '22']\n        self.body = 'car body'\n\n    def run(self):\n        print self.wheel\n        print self.body\n\n    def horn(self):\n        print 'bbbbbbb'\n\n\nclass SUV(Car):\n    def run(self):\n        print 'suv'\n        super(SUV, self).run()\n\n\nclass Jeep(Car):\n    def run(self):\n        print 'jeep'\n        super(Jeep, self).run()\n\njeep = Jeep()\njeep.run()\njeep.horn()\n我们可以看到Jeep和SUV继承了Car这个非抽象类\n实现(realize)\n图示\n\n从图中可以看出实现关系为一个三角箭头加一段虚线构成。箭头指向抽象类。在代码中表现为继承抽象类。\n代码\nclass Vehicle(object):\n    def run(self):\n        raise NotImplementedError\n    \n    \nclass Car(Vehicle):\n    def run(self):\n        print 'car run run'\n        \n        \nclass Bicycle(Vehicle):\n    def run(self):\n        print 'bicycle run run'\n代码中Car和Bicycle继承了Vehicle这个抽象类。\n关联关系(assocation)\n关联关系是用一条直线表示的；它描述不同类的对象之间的结构关系；它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的；它一般用来定义对象之间静态的、天然的结构； 所以，关联关系是一种“强关联”的关系；比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系；[1]\n图示\n\n关联关系为一条直线，可以有箭头，如图表示car知道Moter的存在而Moter不知道Car的存在。表现在代码中就是Car中有一个属性为Motor类的实例。也可以为双箭头表示互相知道。\n代码\nclass Motor(object):\n    pass\n\nclass Car(object):\n    def __init__(self):\n        self.motor = Motor()\n依赖关系(dependency)\n他描述一个对象在运行期间会用到另一个对象的关系.与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化；\n显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生；注：在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是“使用”对方的方法和属性；[1]\n图示\n\n从图中可以看出依赖关系为在类的方法中将另一个类当作参数传入。\n代码\nclass People(object):\n    def cooking(self, wok):\n        wok.cook()\n\nclass Wok(object):\n    def cook(self):\n        print 'cook'\n我们在People的cooking方法中传入了Wok实例，调用其cook方法，完成people的cooking动作。\n组合关系(composition)\n组合关系表示整体由部分构成，但是当整体不存在时部分也不存在，是一种强依赖关系。\n图示\n\n从图中看到组合关系是由一个实心的菱形箭头表示，菱形箭头指向整体。 公司由部分组成。当公司不存在了，部门也就不存在了。\n代码\nclass Company(object):\n    def __init__(self):\n        self.__departments = []\n\n    def build_department(self, department):\n        self.__departments.append(department)\n\n\nclass Department(object):\n    def __init__(self, name):\n        self.name = name\n\n\nc = Company()\nd1 = Department('1')\nd2 = Department('2')\nc.build_department(d1)\nc.build_department(d2)\n聚合关系(aggregation)\n聚合关系表示整体由部分构成但是当整体不存在的时候部分也是可以存在的。\n图示\n\n从图中看到聚合关系由一个空心的菱形箭头表示， 菱形箭头指向整体。及公司是由人组成的。 当公司不存在的时候人还是可以单独存在的。 组合关系和聚合关系由常识来区别的。在实现上区别不大。\n代码\nclass Company(object):\n    def __init__(self):\n        self.__employees = []\n    \n    def add_employee(self, people):\n        self.__employees.append(people)\n        \nclass People(object):\n    pass\n\nc = Company()\np1 = People()\np2 = People()\np3 = People()\nc.add_employee(p1)\nc.add_employee(p2)\nc.add_employee(p3)\n如何从Enterprise Architect 导出代码\n有点长我把这个再写一篇，如何从Enterprise Architect 导出代码\n\n                ", "mainLikeNum": ["5 "], "mainBookmarkNum": "5"}