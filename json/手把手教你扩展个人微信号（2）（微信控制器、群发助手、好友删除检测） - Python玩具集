{"title": "手把手教你扩展个人微信号（2）（微信控制器、群发助手、好友删除检测） - Python玩具集 ", "index": "微信,python", "content": "现在的日常生活已经离不开微信，本文将会抛砖引玉演示如何使用Python调用微信API做一些有意思的东西。\n看完这一系列教程，你就能从头开始实现自己关于微信的想法。\n本文为教程的第二部分，主要以微信控制器、群发助手、好友删除检测为例演示如何调用微信API。\nPython基础并不困难，所以即使没有这方面基础辅助搜索引擎也完全可以学习本教程。\n关于本教程有任何建议或者疑问，都欢迎邮件与我联系（i7meavnktqegm1b@qq.com），或者在github上提出。\n教程流程简介\n这一系列教程从如何分析微信协议开始，第一部分教你如何从零开始获取并模拟扩展个人微信号所需要的协议。\n第二部分将会就这些协议进行利用，以各项目为例介绍一些微信有意思功能的实现。\n第三部分就协议的一些高级用法进行介绍，对框架做进一步介绍与扩展。\n本文为教程的第二部分。\n简单成果展示\n完成了本文的学习，你将会完成三个小项目：（出于方便二次阅读，括号中都放上了源码链接）\n\n通过微信操作的音乐播放器（源码）\n消息内容与对象可自定义的消息群发助手（源码）\n特定好友删除检测（源码）\n\n使用微信协议完成机器人较为平常，如果对具体细节感兴趣，可以添加个人号littlecodersh并回复“源代码”。\n本文主要基于微信API的第三方包itchat，你可以在项目主页获取更多信息。\n本部分所需环境\n本文是这一教程的第二部分，需要基本的pip可用的Python环境。\n本教程使用的环境如下：\n\nWindows 8.1 （其他平台也可用）\nPython 2 or 3\n微信版本6.3.25\n\n微信控制器\n\n在项目主页上，专门有人就微信作为智能家居入口向我提出了很多想法。\n如果微信可以作为控制器，就可以不必自制手机端客户端的麻烦。\n其实这个需求实现起来非常简单，这里我借鉴了yaphone的RasWxMusicbox，使用了其中部分的代码作为演示。\n这是一个通过微信控制电脑播放音乐的小项目，那么主要就是三个功能：\n\n输入“帮助”，显示帮助\n输入“关闭”，关闭音乐播放\n输入具体歌名，进入歌曲的选择\n\n换成代码就是这样一个逻辑：\nif msg == u'关闭':\n    close_music()\n    print(u'音乐已关闭')\nif msg == u'帮助':\n    print(u'帮助信息')\nelse:\n    print(interact_select_song(msg))\n那么现在需要解决的就是如何关闭音乐，如何选择音乐和如何使用微信交互。\n关闭音乐我们这里使用打开空文件的方式，而选择音乐我们使用网易云音乐的API完成：\nimport os\n# 通过该命令安装该API： pip install NetEaseMusicApi\nfrom NetEaseMusicApi import interact_select_song\n\nwith open('stop.mp3', 'w') as f: pass\ndef close_music():\n    os.startfile('stop.mp3')\n而微信的调用可以通过itchat包简单的完成，这里要注意的是：\n\n有些账号无法与自己通信，所以我们选择与文件传输助手（filehelper）通信\n为了防止对于其他消息的响应，我们在第一行过滤了无关信息\nitchat.run的选项分别为允许热拔插，方便调试\n\n# 接上段程序\n# 通过该命令安装该API： pip install itchat\nimport itchat\n\n@itchat.msg_register(itchat.content.TEXT)\ndef music_player(msg):\n    if msg['ToUserName'] != 'filehelper': return\n    if msg['Text'] == u'关闭':\n        close_music()\n        itchat.send(u'音乐已关闭', 'filehelper')\n    if msg['Text'] == u'帮助':\n        itchat.send(u'帮助信息', 'filehelper')\n    else:\n        itchat.send(interact_select_song(msg['Text']), 'filehelper')\n\nitchat.auto_login(True)\nitchat.send(HELP_MSG, 'filehelper') \nitchat.run()\nitchat对常用功能都做好了封装，调用还是非常容易的。\n完整的程序我放在了gist上面，使用时不要忘记安装第三方包。\n通过与文件传输助手的交互，微信就能够轻松变成其他程序的入口。\n群发助手\n在短信的时代，逢年过节都会需要接收和发送大量的短信。\n虽然自己也看到短信就烦，但不发又怕会错过什么。\n所以当时就产生了各式各样的群发工具，最简单的比如在消息中加入昵称，让人感觉不像群发。\n不过可惜的是，微信自带的群发助手真的只是群发。\n当然，稍加操作，一切皆有可能。\n例如在消息中加入昵称：\n\n通过get_friends方法可以轻松获取所有的好友（好友首位是自己）\n基于不同的好友可以发送不同的消息\n这条程序运行后是真的会发消息出去，如果只是演示目的，把itchat.send改为print即可\n\n#coding=utf8\nimport itchat, time\n\nitchat.auto_login(True)\n\nSINCERE_WISH = u'祝%s新年快乐！'\n\nfriendList = itchat.get_friends(update=True)[1:]\nfor friend in friendList:\n    # 如果是演示目的，把下面的方法改为print即可\n    itchat.send(SINCERE_WISH % (friend['DisplayName']\n        or friend['NickName']), friend['UserName'])\n    time.sleep(.5)\n又例如给特定的人发送特定的消息。\n我们这里通过群聊实现，划定一个群聊，在群聊内则私信发送祝福。\n\n如果仅是创建群聊不说话，对方是不会有提示的\n群聊如果不保存到通讯录，是无法在各设备之间同步的（所以itchat也无法读取到）\n群聊在被获取的时候不会自带用户列表，所以需要使用update_chatroom更新用户列表\n当然，如果只是演示目的，把itchat.send改为print即可\n\n#coding=utf8\nimport itchat, time\n\nitchat.auto_login(True)\n\nREAL_SINCERE_WISH = u'祝%s新年快乐！！'\n\nchatroomName='wishgroup'\nitchat.get_chatrooms(update=True)\nchatrooms = itchat.search_chatrooms(name=chatroomName)\nif chatrooms is None:\n    print(u'没有找到群聊：' + chatroomName)\nelse:\n    chatroom = itchat.update_chatroom(chatrooms[0]['UserName'])\n    for friend in chatroom['MemberList']:\n        friend = itchat.search_friends(userName=friend['UserName'])\n        # 如果是演示目的，把下面的方法改为print即可\n        itchat.send(REAL_SINCERE_WISH % (friend['DisplayName']\n            or friend['NickName']), friend['UserName'])\n        time.sleep(.5)\n所以我的通讯录里会有从来不用的客户群、教师群什么的。\n完整的程序我放在了gist上面，使用时不要忘记安装第三方包。\n当然，为了防止误操作，完整程序中我把所有的itchat.send换成了print。\n另外，不只有文字可以发送，文件、图片也都是可行的，具体操作见itchat的文档了。\nitchat获取微信可以获取到的各种内容也都非常方便。\n其余的例如生日，节日什么的就看具体需求了。\n好友删除检测\n\n有时候我们会想知道某个好友有没有删除自己或者把自己拉入黑名单。\n这一操作使用itchat也会变的非常简单。\n原理的话，在于将好友拉入群聊时，非好友和黑名单好友不会被拉入群聊。\n所以群聊的返回值中就有了好友与你关系的数据。\n另外，群聊在第一次产生普通消息时才会被除创建者以外的人发现的（系统消息不算普通消息）。\n这样，就可以隐蔽的完成好友检测。\n写成代码的话，这个操作就是这样的：（只是演示，不能运行，运行版本在段末）\nchatroomUserName = '@1234567'\nfriend = itchat.get_friends()[1]\n\nr = itchat.add_member_into_chatroom(chatroomUserName, [friend])\nif r['BaseResponse']['ErrMsg'] == '':\n    status = r['MemberList'][0]['MemberStatus']\n    itchat.delete_member_from_chatroom(chatroom['UserName'], [friend])\n    return { 3: u'该好友已经将你加入黑名单。',\n        4: u'该好友已经将你删除。', }.get(status,\n        u'该好友仍旧与你是好友关系。')\n其中，通过add_member_into_chatroom操作获取我们需要的返回值，即可得到好友的状态。\n同样的，这次我们也将文件传输助手作为终端，具体方法与控制器一节类似。\n这次我们确定的交互方式是接收“名片”消息，并判断名片中的好友与自己的关系。\n那么获取名片信息的内容可以这么写：\nimport itchat\n\n@itchat.msg_register(itchat.content.CARD)\ndef get_friend(msg):\n    if msg['ToUserName'] != 'filehelper': return\n    friendStatus = get_friend_status(msg['RecommendInfo'])\n    itchat.send(friendStatus['NickName'], 'filehelper')\n\nitchat.auto_login(True)\nitchat.run()\n那么我们所需要的所有部分就都解决了，下面将他们组合起来即可。\n完整的程序我放在了gist上面，使用时不要忘记安装第三方包。\n在网页版微信的接口受到限制之前完全可以批量进行这一操作，检测哪些好友删除了自己。\n但目前显然操作存在频率限制，所以只能做一些变通了。\n之后的内容\n到这里这一篇文章的主要内容就结束了。\n主要从微信作为终端使用、自定义的消息交互、微信协议研究三方面开了一个简单的头。\n其余有一些过于大众，如机器人，就不再赘述。\n而另一些，需要一定的基础或者不适合分享，就留给各位自行研究。\n如果要留个悬念，可以想象添加好友的方法status传2，轻松实现好友病毒式扩张。\n利用微信的API可以做很多事情，文档我放在这里，祝好运！\n结束语\n希望读完这篇文章能对你有帮助，有什么不足之处万望指正（鞠躬）。\n有什么想法或者想要关注我的更新，欢迎来Github上Star或者Fork。\n160928\nLittleCoder\nEOF\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "6"}