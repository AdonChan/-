{"title": "python3 使用 asyncio 代替线程 - Hard-boiled Wonderland ", "index": "asyncio,python", "content": "python3提供了协程专用的关键字async await, 还提供了asyncio库, 来进行异步非阻塞的io操作\n异步非阻塞的io操作?\n没有老师检查我也不知道自己算不算完全懂了, 就不做无用功尝试说得通俗易懂了.想要从原理开始理解的话, 推荐tornado的文档\n我为何使用asyncio来代替传统线程进行io操作?\n\n由于时间主要耗费在io操作上, 其他操作并发需求不大.\n不用规定并行多少, 比较方便稳定.\n熟悉tornado工作原理\n\n举例\n并行访问某网页十次\nimport asyncio\nimport requests\nloop = asyncio.get_event_loop()\nasync def t():                                                    \n    get = lambda:requests.get('http://baidu.com')\n    temp = await loop.run_in_executor(None, get)\n    print(temp)   \nloop.run_until_complete(asyncio.gather(*[t() for i in range(10)]))\n上面这几行代码就可以完成这些操作了.\nloop = asyncio.get_event_loop() 协程本身并不具备并行能力, 但是有了这个事件loop就可以进行并行io请求\nget = lambda:requests.get('http://baidu.com')\ntemp = await loop.run_in_executor(None, get)\n一般函数是无法被await修饰的, 必须用api封装一下(感觉很像threading), 我之所以再封装一次get, 是因为run_in_executor传参数比较坑, 不支持**kwargs\nloop.run_until_complete(asyncio.gather(*[t() for i in range(10)])) \nrun_until_complete这个api是指运行内容物直到结束(api如其名), gather是把任务组合到一起, 如果*的部分有迷惑的话, 你写asycio.gather(t(),t(), t()...)也是可以的.\nおわり.\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "0"}