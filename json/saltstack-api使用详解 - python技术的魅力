{"title": "saltstack-api使用详解 - python技术的魅力 ", "index": "saltstack,python,运维自动化", "content": "简述\n接触了saltstack感觉十分强大，非常适合做自动化运维。本文介绍下salt-api的简单使用。后续打算用django + saltsatck做一个web界面的自动化运维平台。\nsalt-api介绍\nsaltsatck本身就提供了一套算完整的api，使用 CherryPy 来实现 restful 的 api，供外部的程序调用。\nsalt-api安装\nsalt-api需要安装，然后进行一些配置才可以正常使用，安装方法有两种。方法一：yum安装，需要的依赖包cherry也会被补全装上。安装salt-api，并设置开机启动\nyum -y install salt-api pyOpenSSL \nsystemctl enable salt-api\n方法二：pip安装，首先要确认机器上有没有安装pip模块。\nrpm -ivh https://mirrors.aliyun.com/epel/7/x86_64/s/salt-api-2015.5.10-2.el7.noarch.rpm\npip install cherrypy==3.2.3\npip install cherrypy\npip install salt-api\n配置自签名证书\ncd /etc/pki/tls/certs/\nmake testcert\n\n\n\nEnter pass phrase:    ===>  输入加密短语，这里我使用salt2017\nVerifying - Enter pass phrase:    ===>  确认加密短语\numask 77 ; \\\n/usr/bin/openssl req -utf8 -new -key /etc/pki/tls/private/localhost.key -x509 -days 365 -out /etc/pki/tls/certs/localhost.crt -set_serial 0\nEnter pass phrase for /etc/pki/tls/private/localhost.key:    ===>  再次输入相同的加密短语\nYou are about to be asked to enter information that will be incorporated\ninto your certificate request.\nWhat you are about to enter is what is called a Distinguished Name or a DN.\nThere are quite a few fields but you can leave some blank\nFor some fields there will be a default value,\nIf you enter '.', the field will be left blank.\n-----\nCountry Name (2 letter code) [XX]:CN\nState or Province Name (full name) []:BeiJing\nLocality Name (eg, city) [Default City]:BeiJing\nOrganization Name (eg, company) [Default Company Ltd]:\nOrganizational Unit Name (eg, section) []:\nCommon Name (eg, your name or your server's hostname) []:\nEmail Address []:\n解密key文件，生成无密码的key文件, 过程中需要输入key密码，该密码为之前生成证书时设置的密码\ncd /etc/pki/tls/private/\nopenssl rsa -in localhost.key -out localhost_nopass.key\n修改文件权限\nchmod 755 /etc/pki/tls/certs/localhost.crt \nchmod 755 /etc/pki/tls/private/localhost.key \nchmod 755 /etc/pki/tls/private/localhost_nopass.key\n添加用户\n生产环境请使用密码复杂度高的密码，这里我使用salt2017\nuseradd -M -s /sbin/nologin saltapi\npasswd saltapi        \n配置salt-api\n修改/etc/salt/master文件\nsed -i '/#default_include/s/#default/default/g' /etc/salt/master\n创建/etc/salt/master.d/目录\nmkdir -p /etc/salt/master.d/\ncd /etc/salt/master.d/\ntouch eauth.conf\ntouch api.conf\n编辑eauth.conf，添加下面内容\nexternal_auth:\n  pam:\n    saltapi:   # 用户\n      - .*     # 该配置文件给予saltapi用户所有模块使用权限，出于安全考虑一般只给予特定模块使用权限\n编辑api.conf，添加下面内容\nrest_cherrypy:\n  port: 8001\n  ssl_crt: /etc/pki/tls/certs/localhost.crt\n  ssl_key: /etc/pki/tls/private/localhost_nopass.key\n启动salt-api\nsystemctl restart salt-master\nsystemctl start salt-api\nps -ef|grep salt-api\nnetstat -lnput|grep 8001\n验证服务\n获得token\ncurl -k https://172.16.0.19:8001/login -H \"Accept: application/x-yaml\"  -d username='saltapi'  -d password='salt2017'  -d eauth='pam'\nreturn:\n- eauth: pam\n  expire: 1494365711.173652\n  perms:\n  - .*\n  start: 1494322511.173652\n  token: f40623825ea02606bfc558c982dbbfbb923c7570\n  user: saltapi\n调用test.ping\ncurl -k https://172.16.0.19:8001/ -H \"Accept: application/x-yaml\" -H \"X-Auth-Token: f40623825ea02606bfc558c982dbbfbb923c7570\" -d client='local' -d tgt='*' -d fun='test.ping'\nreturn:\n- client1: true\n  saltstack: true\n编写python脚本请求salt api接口\n自定义一个类，首先初始化时候获得token，然后使用token认证去请求相应的json文件。salt命令在shell中使用方式是salt 客户端 方法 参数（例子：salt 'client1' cmd.run 'free -m'）。这里salt命令方法我们已经封装好了，想使用salt的什么方法就传入对应的客户端、方法、参数即可。代码如下：\n#!/usr/bin/env python\n# _*_ coding:utf-8 _*_\n__author__ = 'junxi'\n\n\nimport requests\nimport json\ntry:\n    import cookielib\nexcept:\n    import http.cookiejar as cookielib\n\n# 使用urllib2请求https出错，做的设置\nimport ssl\ncontext = ssl._create_unverified_context()\n\n# 使用requests请求https出现警告，做的设置\nfrom requests.packages.urllib3.exceptions import InsecureRequestWarning\nrequests.packages.urllib3.disable_warnings(InsecureRequestWarning)\n\n\nsalt_api = \"https://172.16.0.19:8001/\"\n\n\nclass SaltApi:\n    \"\"\"\n    定义salt api接口的类\n    初始化获得token\n    \"\"\"\n    def __init__(self, url):\n        self.url = url\n        self.username = \"saltapi\"\n        self.password = \"salt2017\"\n        self.headers = {\n            \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36\",\n            \"Content-type\": \"application/json\"\n            # \"Content-type\": \"application/x-yaml\"\n        }\n        self.params = {'client': 'local', 'fun': '', 'tgt': ''}\n        # self.params = {'client': 'local', 'fun': '', 'tgt': '', 'arg': ''}\n        self.login_url = salt_api + \"login\"\n        self.login_params = {'username': self.username, 'password': self.password, 'eauth': 'pam'}\n        self.token = self.get_data(self.login_url, self.login_params)['token']\n        self.headers['X-Auth-Token'] = self.token\n\n    def get_data(self, url, params):\n        send_data = json.dumps(params)\n        request = requests.post(url, data=send_data, headers=self.headers, verify=False)\n        # response = request.text\n        # response = eval(response)     使用x-yaml格式时使用这个命令把回应的内容转换成字典\n        # print response\n        # print request\n        # print type(request)\n        response = request.json()\n        result = dict(response)\n        # print result\n        return result['return'][0]\n\n    def salt_command(self, tgt, method, arg=None):\n        \"\"\"远程执行命令，相当于salt 'client1' cmd.run 'free -m'\"\"\"\n        if arg:\n            params = {'client': 'local', 'fun': method, 'tgt': tgt, 'arg': arg}\n        else:\n            params = {'client': 'local', 'fun': method, 'tgt': tgt}\n        print '命令参数: ', params\n        result = self.get_data(self.url, params)\n        return result\n\ndef main():\n    print '=================='\n    print '同步执行命令'\n    salt = SaltApi(salt_api)\n    print salt.token\n    salt_client = '*'\n    salt_test = 'test.ping'\n    salt_method = 'cmd.run'\n    salt_params = 'free -m'\n    # print salt.salt_command(salt_client, salt_method, salt_params)\n    # 下面只是为了打印结果好看点\n    result1 = salt.salt_command(salt_client, salt_test)\n    for i in result1.keys():\n        print i, ': ', result1[i]\n    result2 = salt.salt_command(salt_client, salt_method, salt_params)\n    for i in result2.keys():\n        print i\n        print result2[i]\n        print\n\nif __name__ == '__main__':\n    main()\n查看运行结果第一行请求认证的token。从结果可以看出来我们请求了两条命令，test.ping和free -m\n==================\n同步执行命令\n83ad5789cf8046ff06972e1f92bb31f012609a78\n命令参数:  {'fun': 'test.ping', 'client': 'local', 'tgt': '*'}\nclient1 :  True\nsaltstack :  True\n命令参数:  {'fun': 'cmd.run', 'client': 'local', 'tgt': '*', 'arg': 'free -m'}\nclient1\n              total        used        free      shared  buff/cache   available\nMem:            220         153           7           2          59          31\nSwap:          2046         129        1917\n\nsaltstack\n              total        used        free      shared  buff/cache   available\nMem:            976         516          83          24         376         260\nSwap:          2046           0        2046\n请求异步执行salt命令后的jid结果，首先要修改/etc/salt/master.d/eauth.conf 配置文件，增加权限，然后重启salt-master和salt-api。\ncd /etc/salt/master.d/\nvi eauth.conf\n# 修改内容如下：\nexternal_auth:\n  pam:\n    saltapi:\n      - .*\n      - '@runner'\n      - '@wheel'\npython编写异步请求模块\ndef salt_async_command(self, tgt, method, arg=None):  # 异步执行salt命令，根据jid查看执行结果\n    \"\"\"远程异步执行命令\"\"\"\n    if arg:\n        params = {'client': 'local_async', 'fun': method, 'tgt': tgt, 'arg': arg}\n    else:\n        params = {'client': 'local_async', 'fun': method, 'tgt': tgt}\n    jid = self.get_data(self.url, params)['jid']\n    return jid\n\ndef look_jid(self, jid):  # 根据异步执行命令返回的jid查看事件结果\n    params = {'client': 'runner', 'fun': 'jobs.lookup_jid', 'jid': jid}\n    print params\n    result = self.get_data(self.url, params)\n    return result\n查看执行结果\ndef main():\n    print\n    print '=================='\n    print '异步执行命令'\n    salt1 = SaltApi(salt_api)\n    salt_client = '*'\n    salt_method = 'cmd.run'\n    salt_params = 'df -hT'\n    # 下面只是为了打印结果好看点\n    jid1 = salt1.salt_async_command(salt_client, salt_test)\n    result1 = salt1.look_jid(jid1)\n    for i in result1.keys():\n        print i, ': ', result1[i]\n\n    jid2 = salt1.salt_async_command(salt_client, salt_method, salt_params)\n    result2 = salt1.look_jid(jid2)\n    for i in result2.keys():\n        print i\n        print result2[i]\n        print\n\n\nif __name__ == '__main__':\n    main()\n==================\n异步执行命令\n{'fun': 'jobs.lookup_jid', 'jid': u'20170525095342243770', 'client': 'runner'}\nsaltstack :  True\nclient1 :  True\n{'fun': 'jobs.lookup_jid', 'jid': u'20170525095342994269', 'client': 'runner'}\nclient1\nFilesystem     Type      Size  Used Avail Use% Mounted on\n/dev/sda2      xfs        17G   13G  4.1G  77% /\ndevtmpfs       devtmpfs   97M     0   97M   0% /dev\ntmpfs          tmpfs     111M   12K  111M   1% /dev/shm\ntmpfs          tmpfs     111M  4.7M  106M   5% /run\ntmpfs          tmpfs     111M     0  111M   0% /sys/fs/cgroup\n/dev/sda1      xfs       297M  202M   96M  68% /boot\n\nsaltstack\nFilesystem     Type      Size  Used Avail Use% Mounted on\n/dev/sda2      xfs        17G  7.2G  9.9G  43% /\ndevtmpfs       devtmpfs  475M     0  475M   0% /dev\ntmpfs          tmpfs     489M   16K  489M   1% /dev/shm\ntmpfs          tmpfs     489M  6.9M  482M   2% /run\ntmpfs          tmpfs     489M     0  489M   0% /sys/fs/cgroup\n/dev/sda1      xfs       297M  202M   96M  68% /boot\nsalt-api二次开发遇到的问题\n对salt-api进行了二次开发，通过api控制minion，可能会遇到发送命令线程就进入了等待，然后就是超时。解决方法：salt.netapi.rest_cherrypy包里面有一个app.py方法，修改'server.thread_pool': self.apiopts.get('thread_pool', 100)为200，修改'server.socket_queue_size': self.apiopts.get('queue_size', 30)为300 。重启salt-api 再次测试，OK。\nvi /usr/lib/python2.7/site-packages/salt/netapi/rest_cherrypy/app.py\n修改下面两行内容\n'server.thread_pool': self.apiopts.get('thread_pool', 100),\n'server.socket_queue_size': self.apiopts.get('queue_size', 30),\n为\n'server.thread_pool': self.apiopts.get('thread_pool', 200),\n'server.socket_queue_size': self.apiopts.get('queue_size', 300),\n重启salt-api\nsystemctl restart salt-api\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "1"}