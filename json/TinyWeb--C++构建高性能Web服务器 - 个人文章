{"title": "TinyWeb--C++构建高性能Web服务器 - 个人文章 ", "index": "c++,c,java,python,shell", "content": "C++构建高性能Web服务器——Step 0：前言\n一、想法:\n\n一直想用C++做个项目，因为比较喜欢网络通信这部分，又让事情变得更有些挑战性，我最终选择实现一个高性能的Web服务器。\n\n在宏观上我希望TinyWeb能够这样:\n\n配置简单\n扩展容易\n性能高效\n功能强大\n\n\n\n并希望在开发的过程中能够掌握以下知识:\n\nUnix环境编程的技能\nUnix网络编程的技能\n巩固C++11知识\n掌握构建大型C++项目的技能\n掌握多进程、多线程同步、通信机制\n实现高性能可复用Memory-pool\n掌握基本的数据结构（红黑树、链表、Hash）\n能够把通用的网络部分作为单独的网络库、为以后网络开发提升效率\n\n\n\nTinyWeb 目前的功能是：\n\n基本的Web服务，只能提供静态网页服务。\n单进程＋Reactor+非阻塞方式运行\n只能用于Linux系统，不专注跨平台\n基本的Web服务配置\n\n\n\nTinyWeb 目前的发展计划：\n\n使用进程池的方式提高并发性\n强有力的支持多种版本Http协议\n负载均衡功能\n代理功能\n\n\n\n\n二、设计思想\n1. 网络中最麻烦的是如何处理阻塞的事件:\n如果IO事件没有发生,系统阻塞的等待IO事件发生,那么CPU就被浪费了,为实现高并发,不能让进程阻塞,CPU等待IO事件.借助Linux高效的Epoll机制,\n至于为何使用Epoll,而不使用Select或Poll,点这里看看吧.\n2.为了提高并发性:到底是选择多进程还是多线程模式\n\n多进程与多线程各有优缺点,并且大部分是互补的,具体就不再赘述了,详情请戳这里我选择多进程的原因是:\n\n安全性高,一个进程崩溃不会影响别的进程\n容易调试,不易造成死锁\n有较为成熟的进程间通信同步机制(共享内存,信号,文件锁,socketpair....)\n\n在接受客户端连接的时候,如何再去创建一个进程,效率低下.故因此采用进程池的方式:Master进程为父进程,主要控制子进程的状态;可动态配置数量的Slave子进程,用于接受连接,处理Http逻辑.\n\n3.C++最难管理的还是内存\n为了方便的进行内存管理,我设计了一个内存池,不会产生大量的内存碎片,性能待测试.以后还会介绍如何实现的,尽请期待.\n4.进程间通信的方式很多,到底选择哪几个\n\n了解了下Nginx,有考虑了使用的复杂度,我决定使用这几个通信.同步机制\n\n原子操作\n信号量\n消息队列\n共享内存\n信号\n\n\n\n三、源码\n想要源代码的请戳这里,希望大家多多对代码风格做出评判,毕竟自己只是个大三的学生.\n\n四、参考文献\n小伙伴想要了解更多的高性能的网络编程,推荐一个大神的专栏\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "1"}