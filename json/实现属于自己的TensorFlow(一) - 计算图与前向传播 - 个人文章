{"title": "实现属于自己的TensorFlow(一) - 计算图与前向传播 - 个人文章 ", "index": "tensorflow,神经网络,机器学习,人工智能,python", "content": "前段时间因为课题需要使用了一段时间TensorFlow，感觉这种框架很有意思，除了可以搭建复杂的神经网络，也可以优化其他自己需要的计算模型，所以一直想自己学习一下写一个类似的图计算框架。前几天组会开完决定着手实现一个模仿TensorFlow接口的简陋版本图计算框架以学习计算图程序的编写以及前向传播和反向传播的实现。目前实现了前向传播和反向传播以及梯度下降优化器，并写了个优化线性模型的例子。\n代码放在了GitHub上，取名SimpleFlow, 仓库链接: https://github.com/PytLab/sim...\n<!-- more -->\n虽然前向传播反向传播这些原理了解起来并不是很复杂，但是真正着手写起来才发现,里面还是有很多细节需要学习和处理才能对实际的模型进行优化(例如Loss函数对每个计算节点矩阵求导的处理)。其中SimpleFlow的代码并没有考虑太多的东西比如dtype和张量size的检查等，因为只是为了实现主要图计算功能并没有考虑任何的优化, 内部张量运算使用的Numpy的接口(毕竟是学习和练手的目的嘛)。好久时间没更新博客了，在接下来的几篇里面我将把实现的过程的细节总结一下，希望可以给后面学习的童鞋做个参考。\n正文\n本文主要介绍计算图以及前向传播的实现, 主要涉及图的构建以及通过对构建好的图进行后序遍历然后进行前向传播计算得到具体节点上的输出值。\n先贴上一个简单的实现效果吧:\nimport simpleflow as sf\n\n# Create a graph\nwith sf.Graph().as_default():\n    a = sf.constant(1.0, name='a')\n    b = sf.constant(2.0, name='b')\n    result = sf.add(a, b, name='result')\n\n    # Create a session to compute\n    with tf.Session() as sess:\n        print(sess.run(result))\n计算图(Computational Graph)\n计算图是计算代数中的一个基础处理方法，我们可以通过一个有向图来表示一个给定的数学表达式，并可以根据图的特点快速方便对表达式中的变量进行求导。而神经网络的本质就是一个多层复合函数, 因此也可以通过一个图来表示其表达式。\n本部分主要总结计算图的实现，在计算图这个有向图中，每个节点代表着一种特定的运算例如求和，乘积，向量乘积，平方等等... 例如求和表达式$f(x, y) = x + y$使用有向图表示为:\n\n表达式$f(x, y, z) = z(x+y)$使用有向图表示为:\n\n与TensorFlow的实现不同，为了简化，在SimpleFlow中我并没有定义Tensor类来表示计算图中节点之间的数据流动，而是直接定义节点的类型，其中主要定义了四种类型来表示图中的节点:\n\n\nOperation: 操作节点主要接受一个或者两个输入节点然后进行简单的操作运算，例如上图中的加法操作和乘法操作等。\n\nVariable: 没有输入节点的节点，此节点包含的数据在运算过程中是可以变化的。\n\nConstant: 类似Variable节点，也没有输入节点，此节点中的数据在图的运算过程中不会发生变化\n\nPlaceholder: 同样没有输入节点，此节点的数据是通过图建立好以后通过用户传入的\n\n其实图中的所有节点都可以看成是某种操作，其中Variable, Constant, Placeholder都是一种特殊的操作，只是相对于普通的Operation而言，他们没有输入，但是都会有输出（像上图中的$x$, $y$节点，他们本身输出自身的值到$+$节点中去），通常会输出到Operation节点，进行进一步的计算。\n下面我们主要介绍如何实现计算图的基本组件: 节点和边。\n\nOperation节点\n节点表示操作，边代表节点接收和输出的数据，操作节点需要含有以下属性:\n\n\ninput_nodes: 输入节点，里面存放与当前节点相连接的输入节点的引用\n\noutput_nodes: 输出节点, 存放以当前节点作为输入的节点，也就是当前节点的去向\n\noutput_value: 存储当前节点的数值, 如果是Add节点，此变量就存储两个输入节点output_value的和\n\nname: 当前节点的名称\n\ngraph: 此节点所属的图\n\n下面我们定义了Operation基类用于表示图中的操作节点(详见https://github.com/PytLab/sim...:\nclass Operation(object):\n    ''' Base class for all operations in simpleflow.\n\n    An operation is a node in computational graph receiving zero or more nodes\n    as input and produce zero or more nodes as output. Vertices could be an\n    operation, variable or placeholder.\n    '''\n    def __init__(self, *input_nodes, name=None):\n        ''' Operation constructor.\n\n        :param input_nodes: Input nodes for the operation node.\n        :type input_nodes: Objects of `Operation`, `Variable` or `Placeholder`.\n\n        :param name: The operation name.\n        :type name: str.\n        '''\n        # Nodes received by this operation.\n        self.input_nodes = input_nodes\n\n        # Nodes that receive this operation node as input.\n        self.output_nodes = []\n\n        # Output value of this operation in session execution.\n        self.output_value = None\n\n        # Operation name.\n        self.name = name\n\n        # Graph the operation belongs to.\n        self.graph = DEFAULT_GRAPH\n\n        # Add this operation node to destination lists in its input nodes.\n        for node in input_nodes:\n            node.output_nodes.append(self)\n\n        # Add this operation to default graph.\n        self.graph.operations.append(self)\n\n    def compute_output(self):\n        ''' Compute and return the output value of the operation.\n        '''\n        raise NotImplementedError\n\n    def compute_gradient(self, grad=None):\n        ''' Compute and return the gradient of the operation wrt inputs.\n        '''\n        raise NotImplementedError\n在初始化方法中除了定义上面提到的属性外，还需要进行两个操作:\n\n将当前节点的引用添加到他输入节点的output_nodes这样可以在输入节点中找到当前节点。\n将当前节点的引用添加到图中，方便后面对图中的资源进行回收等操作\n\n另外，每个操作节点还有两个必须的方法: comput_output和compute_gradient. 他们分别负责根据输入节点的值计算当前节点的输出值和根据操作属性和当前节点的值计算梯度。关于梯度的计算将在后续的文章中详细介绍，本文只对节点输出值的计算进行介绍。\n下面我以求和操作为例来说明具体操作节点的实现:\nclass Add(Operation):\n    ''' An addition operation.\n    '''\n    def __init__(self, x, y, name=None):\n        ''' Addition constructor.\n\n        :param x: The first input node.\n        :type x: Object of `Operation`, `Variable` or `Placeholder`.\n\n        :param y: The second input node.\n        :type y: Object of `Operation`, `Variable` or `Placeholder`.\n\n        :param name: The operation name.\n        :type name: str.\n        '''\n        super(self.__class__, self).__init__(x, y, name=name)\n\n    def compute_output(self):\n        ''' Compute and return the value of addition operation.\n        '''\n        x, y = self.input_nodes\n        self.output_value = np.add(x.output_value, y.output_value)\n        return self.output_value\n可见，计算当前节点output_value的值的前提条件就是他的输入节点的值在此之前已经计算得到了。\n\nVariable节点\n与Operation节点类似，Variable节点也需要output_value, output_nodes等属性，但是它没有输入节点，也就没有input_nodes属性了，而是需要在创建的时候确定一个初始值initial_value:\nclass Variable(object):\n    ''' Variable node in computational graph.\n    '''\n    def __init__(self, initial_value=None, name=None, trainable=True): \n        ''' Variable constructor.\n\n        :param initial_value: The initial value of the variable.\n        :type initial_value: number or a ndarray.\n\n        :param name: Name of the variable.\n        :type name: str.\n        '''\n        # Variable initial value.\n        self.initial_value = initial_value\n\n        # Output value of this operation in session execution.\n        self.output_value = None\n\n        # Nodes that receive this variable node as input.\n        self.output_nodes = []\n\n        # Variable name.\n        self.name = name\n\n        # Graph the variable belongs to.\n        self.graph = DEFAULT_GRAPH\n\n        # Add to the currently active default graph.\n        self.graph.variables.append(self)\n        if trainable:\n            self.graph.trainable_variables.append(self)\n\n    def compute_output(self):\n        ''' Compute and return the variable value.\n        '''\n        if self.output_value is None:\n            self.output_value = self.initial_value\n        return self.output_value\n\nConstant节点和Placeholder节点\nConstant和Placeholder节点与Variable节点类似，具体实现详见: https://github.com/PytLab/sim...\n计算图对象\n在定义了图中的节点后我们需要将定义好的节点放入到一个图中统一保管，因此就需要定义一个Graph类来存放创建的节点，方便统一操作图中节点的资源。\nclass Graph(object):\n    ''' Graph containing all computing nodes.\n    '''\n    def __init__(self):\n        ''' Graph constructor.\n        '''\n        self.operations, self.constants, self.placeholders = [], [], []\n        self.variables, self.trainable_variables = [], []\n为了提供一个默认的图，在导入simpleflow模块的时候创建一个全局变量来引用默认的图:\nfrom .graph import Graph\n\n# Create a default graph.\nimport builtins\nDEFAULT_GRAPH = builtins.DEFAULT_GRAPH = Graph()\n为了模仿TensorFlow的接口，我们给Graph添加上下文管理器协议方法使其成为一个上下文管理器, 同时也添加一个as_default方法:\nclass Graph(object):\n    #...\n\n    def __enter__(self):\n        ''' Reset default graph.\n        '''\n        global DEFAULT_GRAPH\n        self.old_graph = DEFAULT_GRAPH\n        DEFAULT_GRAPH = self\n        return self\n\n    def __exit__(self, exc_type, exc_value, exc_tb):\n        ''' Recover default graph.\n        '''\n        global DEFAULT_GRAPH\n        DEFAULT_GRAPH = self.old_graph\n\n    def as_default(self):\n        ''' Set this graph as global default graph.\n        '''\n        return self\n这样在进入with代码块之前先保存旧的默认图对象然后将当前图赋值给全局图对象，这样with代码块中的节点默认会添加到当前的图中。最后退出with代码块时再对图进行恢复即可。这样我们可以按照TensorFlow的方式来在某个图中创建节点.\nOk，根据上面的实现我们已经可以创建一个计算图了:\nimport simpleflow as sf\n\nwith sf.Graph().as_default():\n    a = sf.constant([1.0, 2.0], name='a')\n    b = sf.constant(2.0, name='b')\n    c = a * b\n前向传播(Feedforward)\n实现了计算图和图中的节点，我们需要对计算图进行计算, 本部分对计算图的前向传播的实现进行总结。\n会话\n首先，我们需要实现一个Session来对一个已经创建好的计算图进行计算，因为当我们创建我们之前定义的节点的时候其实只是创建了一个空节点，节点中并没有数值可以用来计算，也就是output_value是空的。为了模仿TensorFlow的接口，我们在这里也把session定义成一个上下文管理器:\nclass Session(object):\n    ''' A session to compute a particular graph.\n    '''\n    def __init__(self):\n        ''' Session constructor.\n        '''\n        # Graph the session computes for.\n        self.graph = DEFAULT_GRAPH\n\n    def __enter__(self):\n        ''' Context management protocal method called before `with-block`.\n        '''\n        return self\n\n    def __exit__(self, exc_type, exc_value, exc_tb):\n        ''' Context management protocal method called after `with-block`.\n        '''\n        self.close()\n\n    def close(self):\n        ''' Free all output values in nodes.\n        '''\n        all_nodes = (self.graph.constants + self.graph.variables +\n                     self.graph.placeholders + self.graph.operations +\n                     self.graph.trainable_variables)\n        for node in all_nodes:\n            node.output_value = None\n\n    def run(self, operation, feed_dict=None):\n        ''' Compute the output of an operation.'''\n        # ...\n计算某个节点的输出值\n上面我们已经可以构建出一个计算图了，计算图中的每个节点与其相邻的节点有方向的联系起来，现在我们需要根据图中节点的关系来推算出某个节点的值。那么如何计算呢? 还是以我们刚才$f(x, y, z) = z(x + y)$的计算图为例,\n若我们需要计算橙色$\\\\times$运算节点的输出值，我们需要计算与它相连的两个输入节点的输出值，进而需要计算绿色$+$的输入节点的输出值。我们可以通过后序遍历来获取计算一个节点所需的所有节点的输出值。为了方便实现，后序遍历我直接使用了递归的方式来实现:\ndef _get_prerequisite(operation):\n    ''' Perform a post-order traversal to get a list of nodes to be computed in order.\n    '''\n    postorder_nodes = []\n\n    # Collection nodes recursively.\n    def postorder_traverse(operation):\n        if isinstance(operation, Operation):\n            for input_node in operation.input_nodes:\n                postorder_traverse(input_node)\n        postorder_nodes.append(operation)\n\n    postorder_traverse(operation)\n\n    return postorder_nodes\n通过此函数我们可以获取计算一个节点值所需要所有节点列表，再依次计算列表中节点的输出值，最后便可以轻易的计算出当前节点的输出值了。\nclass Session(object):\n    # ...\n    def run(self, operation, feed_dict=None):\n        ''' Compute the output of an operation.\n\n        :param operation: A specific operation to be computed.\n        :type operation: object of `Operation`, `Variable` or `Placeholder`.\n\n        :param feed_dict: A mapping between placeholder and its actual value for the session.\n        :type feed_dict: dict.\n        '''\n        # Get all prerequisite nodes using postorder traversal.\n        postorder_nodes = _get_prerequisite(operation)\n\n        for node in postorder_nodes:\n            if type(node) is Placeholder:\n                node.output_value = feed_dict[node]\n            else:  # Operation and variable\n                node.compute_output()\n\n        return operation.output_value\n例子\n上面我们实现了计算图以及前向传播，我们就可以创建计算图计算表达式的值了, 如下:\n$$\nf = \\left[ \\begin{matrix}\n1 & 2 & 3 \\\\\n3 & 4 & 5 \\\\\n\\end{matrix} \\right] \\times\n\\left[ \\begin{matrix}\n9 & 8 \\\\\n7 & 6 \\\\\n10 & 11 \\\\\n\\end{matrix} \\right] + 3 = \n\\left[ \\begin{matrix}\n54 & 54 \\\\\n106 & 104 \\\\\n\\end{matrix} \\right]\n$$\nimport simpleflow as sf\n\n# Create a graph\nwith sf.Graph().as_default():\n    w = sf.constant([[1, 2, 3], [3, 4, 5]], name='w')\n    x = sf.constant([[9, 8], [7, 6], [10, 11]], name='x')\n    b = sf.constant(1.0, 'b')\n    result = sf.matmul(w, x) + b\n\n    # Create a session to compute\n    with sf.Session() as sess:\n        print(sess.run(result))\n输出值:\narray([[  54.,   54.],\n       [ 106.,  104.]])\n总结\n本文使用Python实现了计算图以及计算图的前向传播，并模仿TensorFlow的接口创建了Session以及Graph对象。下篇中将继续总结计算图节点计算梯度的方法以及反向传播和梯度下降优化器的实现。\n最后再附上simpleflow项目的链接, 欢迎相互学习和交流: https://github.com/PytLab/sim...\n参考\n\nDeep Learning From Scratch\nhttps://en.wikipedia.org/wiki...\nhttps://zhuanlan.zhihu.com/p/...\nhttp://blog.csdn.net/magic_an...\n\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "0"}