{"title": "Django框架的学习笔记 - 个人文章 ", "index": "django,python", "content": "基于Django的REST framework 框架的视图说明(二)\n开发环境:Ubuntu16.04+Python3.5x+Pycharm2018.2\n包含方法和属性的通用视图基类及扩展类的继承关系\n\n两个基类\nAPIView类\nGenericAPIView类\n本篇主要说明GenericAPIView类rest_framework.generics.GenericAPIView\n继承自APIView，增加了对于列表视图和详情视图可能用到的通用支持方法。通常使用时，可搭配一个或多个Mixin扩展类.\n支持定义的属性:\n列表视图与详情视图通用：queryset 列表视图的查询集serializer_class 视图使用的序列化器\n列表视图使用：pagination_class 分页控制类filter_backends 过滤控制后端\n详情页视图使用：lookup_field 查询单一数据库对象时使用的条件字段，默认为'pk'lookup_url_kwarg 查询单一数据时URL中的参数关键字名称，默认与look_field相同\n源代码如下:\n    queryset = None\n    serializer_class = None\n\n    # If you want to use object lookups other than pk, set 'lookup_field'.\n    # For more complex lookup requirements override `get_object()`.\n    lookup_field = 'pk'\n    lookup_url_kwarg = None\n\n    # The filter backend classes to use for queryset filtering\n    filter_backends = api_settings.DEFAULT_FILTER_BACKENDS\n\n    # The style to use for queryset pagination.\n    pagination_class = api_settings.DEFAULT_PAGINATION_CLASS\n\n支持定义的方法:\n列表视图与详情视图通用：\nget_queryset(self)源码如下:\n   def get_queryset(self):\n        \"\"\"\n        Get the list of items for this view.\n        This must be an iterable, and may be a queryset.\n        Defaults to using `self.queryset`.\n\n        This method should always be used rather than accessing `self.queryset`\n        directly, as `self.queryset` gets evaluated only once, and those results\n        are cached for all subsequent requests.\n\n        You may want to override this if you need to provide different\n        querysets depending on the incoming request.\n\n        (Eg. return a list of items that is specific to the user)\n        \"\"\"\n        assert self.queryset is not None, (\n            \"'%s' should either include a `queryset` attribute, \"\n            \"or override the `get_queryset()` method.\"\n            % self.__class__.__name__\n        )\n\n        queryset = self.queryset\n        if isinstance(queryset, QuerySet):\n            # Ensure queryset is re-evaluated on each request.\n            queryset = queryset.all()\n        return queryset\n返回视图使用的查询集，是列表视图与详情视图获取数据的基础，默认返回queryset属性，可以重写，例如：\ndef get_queryset(self):\n    user = self.request.user\n    return user.accounts.all()      \nget_serializer_class(self)\n    def get_serializer_class(self):\n        \"\"\"\n        Return the class to use for the serializer.\n        Defaults to using `self.serializer_class`.\n\n        You may want to override this if you need to provide different\n        serializations depending on the incoming request.\n\n        (Eg. admins get full serialization, others get basic serialization)\n        \"\"\"\n        assert self.serializer_class is not None, (\n            \"'%s' should either include a `serializer_class` attribute, \"\n            \"or override the `get_serializer_class()` method.\"\n            % self.__class__.__name__\n        )\n\n        return self.serializer_class\n\n返回序列化器类，默认返回serializer_class，可以重写，例如：\ndef get_serializer_class(self):\n    if self.request.user.is_staff:\n        return FullAccountSerializer\n    return BasicAccountSerializer\n    \nget_serializer(self, args, **kwargs)返回序列化器对象，被其他视图或扩展类使用，如果我们在视图中想要获取序列化器对象，可以直接调用此方法。\n注意，在提供序列化器对象的时候，REST framework会向对象的context属性补充三个数据：request、format、view，这三个数据对象可以在定义序列化器时使用。\n详情视图使用：\nget_object(self)\n   def get_object(self):\n        \"\"\"\n        Returns the object the view is displaying.\n\n        You may want to override this if you need to provide non-standard\n        queryset lookups.  Eg if objects are referenced using multiple\n        keyword arguments in the url conf.\n        \"\"\"\n        queryset = self.filter_queryset(self.get_queryset())\n\n        # Perform the lookup filtering.\n        lookup_url_kwarg = self.lookup_url_kwarg or self.lookup_field\n\n        assert lookup_url_kwarg in self.kwargs, (\n            'Expected view %s to be called with a URL keyword argument '\n            'named \"%s\". Fix your URL conf, or set the `.lookup_field` '\n            'attribute on the view correctly.' %\n            (self.__class__.__name__, lookup_url_kwarg)\n        )\n\n        filter_kwargs = {self.lookup_field: self.kwargs[lookup_url_kwarg]}\n        obj = get_object_or_404(queryset, **filter_kwargs)\n\n        # May raise a permission denied\n        self.check_object_permissions(self.request, obj)\n\n        return obj\n\n返回详情视图所需的模型类数据对象，默认使用lookup_field参数来过滤queryset。 在试图中可以调用该方法获取详情信息的模型类对象。\n若详情访问的模型类对象不存在，会返回404。\ndef get_object_or_404(queryset, *filter_args, **filter_kwargs):\n    \"\"\"\n    Same as Django's standard shortcut, but make sure to also raise 404\n    if the filter_kwargs don't match the required types.\n    \"\"\"\n    try:\n        return _get_object_or_404(queryset, *filter_args, **filter_kwargs)\n    except (TypeError, ValueError, ValidationError):\n        raise Http404\n该方法会默认使用APIView提供的check_object_permissions方法检查当前对象是否有权限被访问。\n举例：以图书与英雄案例(如水浒传与英雄)\n\n# GET /books/\n# url(r'^books/$', views.BookListAPIView.as_view()) 对应的路由\nclass BookListAPIView(GenericAPIView):\n    \"\"\"\n    数据查询集\n    \"\"\"\n    queryset = BookInfo.objects.all()  # 数据库查询集\n    serializer_class = BookInfoSerializer\n\n    def get(self,request):\n        # 数据库查询\n        qs = self.get_queryset()\n        # 构建序列化器对象,进行序列化操作\n        serializer = self.get_serializer(qs,many = True)\n\n        return  Response(serializer.data)\n\n# GET /books/<pk>/\n# url(r'^books/(?P<pk>\\d+)/$', views.BookDetailView.as_view()) 对应的路由\nclass BookDetailAPIView(GenericAPIView):\n    queryset = BookInfo.objects.all()\n\n    serializer_class = BookInfoSerializer\n\n\n    def get(self,request,pk):\n        \"\"\"\n        查询单个\n        :param query:\n        :return:\n        \"\"\"\n        book = self.get_object()\n        serializer = self.get_serializer(book)\n\n        return Response(serializer.data)\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "2"}