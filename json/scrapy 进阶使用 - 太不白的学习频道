{"title": "scrapy 进阶使用 - 太不白的学习频道 ", "index": "网络爬虫,scrapy,python", "content": "前段时间我写了一篇《scrapy快速入门》，简单介绍了一点scrapy的知识。最近我的搬瓦工让墙了，而且我又学了一点mongodb的知识，所以这次就来介绍一些scrapy的进阶知识，做一些真正有用的爬虫来。\nscrapy组件介绍\n首先先来介绍一下scrapy的体系结构和组件。\n\nscrapy引擎。顾名思义，它负责调用爬虫爬取页面并将数据交给管道来处理。\n调度程序。调度程序从引擎获取请求，然后将这些请求交给相应的处理者来处理。\n下载器。下载器负责获取web页面，然后将它们交给引擎来处理。\n爬虫。这是我们要编写的部分，爬虫负责从页面抽取要处理的数据，然后交由管道来处理。\n项目管道。爬虫抽取出来的数据，就要交给管道来处理，我们可以编写自己的管道来清洗、验证和持久化数据。\n下载器中间件。下载器中间件在下载器和scrapy引擎之间工作，我们可以利用下载器中间件在将页面交给爬虫之前做一些事情。scrapy内置了一些下载器中间件，这些中间件将在后面介绍。\n爬虫中间件。爬虫中间件可以让我们控制爬虫的回调等等。在后面会介绍一些内置的爬虫中间件。\n\n下面是scrapy官网的结构图，可以帮助我们理解scrapy的体系。\n项目（Item）\n在以前的爬虫中我们都是直接返回一个字典，其实这并不是最佳实践。scrapy提供了一个Item基类，我们可以通过继承这个类定义自己的结构化数据，比到处传递字典更好。下面是官方文档的例子。\nimport scrapy\n\nclass Product(scrapy.Item):\n    name = scrapy.Field()\n    price = scrapy.Field()\n    stock = scrapy.Field()\n    last_updated = scrapy.Field(serializer=str)\n这些项目类一般都定义在scrapy项目的items.py文件中。定义好之后，在爬虫中我们就不应该在反掌字典了，而是初始化并返回我们自定义的Item对象。\n请求和响应对象\nscrapy通过请求和响应对象来处理网页请求，这部分的文档可以参考https://doc.scrapy.org/en/latest/topics/request-response.html。请求和响应还有一些子类，可以帮助我们完成更具体的工作。例如Request的子类FormRequest就可以帮助我们模拟用户登录。\n有时候需要模拟用户登录，这时候可以使用FormRequest.from_response方法。这时候爬虫功能稍有变化，parse函数用来发送用户名和密码，抽取数据的操作放在回调函数中进行。\nimport scrapy\n\nclass LoginSpider(scrapy.Spider):\n    name = 'example.com'\n    start_urls = ['http://www.example.com/users/login.php']\n\n    def parse(self, response):\n        return scrapy.FormRequest.from_response(\n            response,\n            formdata={'username': 'john', 'password': 'secret'},\n            callback=self.after_login\n        )\n\n    def after_login(self, response):\n        # 检查是否登录成功\n        if \"authentication failed\" in response.body:\n            self.logger.error(\"Login failed\")\n            return\n\n        # 在这里继续爬取数据\n管道（pipeline）\n管道用来处理爬虫抽取到的数据，我们可以通过管道对数据进行验证和持久化等操作。管道其实就是带有process_item(self, item, spider)函数的一个普通类。下面是scrapy官方文档的例子，这个例子验证获取到的数据是否存在价格字段，并丢弃没有价格字段的无效数据。这里还引用了scrapy预定义的DropItem异常，这个异常必须在管道中抛出，表示管道应该丢弃这个数据。如果想了解scrapy异常，可以查看官方文档。\nfrom scrapy.exceptions import DropItem\n\nclass PricePipeline(object):\n\n    vat_factor = 1.15\n\n    def process_item(self, item, spider):\n        if item['price']:\n            if item['price_excludes_vat']:\n                item['price'] = item['price'] * self.vat_factor\n            return item\n        else:\n            raise DropItem(\"Missing price in %s\" % item)\n管道不是一定义好就能用的，还需要在配置文件settings.py中激活。\nITEM_PIPELINES = {\n    'myproject.pipelines.PricePipeline': 300,\n    'myproject.pipelines.JsonWriterPipeline': 800,\n}\n将数据保存到MongoDB的管道\n管道除了验证数据，还可以将数据保存到数据库中。这时候仅仅一个process_item(self, item, spider)函数就不够了。所以操作数据库的管道还应该包含几个函数用于建立和关闭数据库连接。\n下面的例子也是scrapy官方文档的例子，演示了持久化数据管道的用法。这个管道是从类方法from_crawler(cls, crawler)中初始化出来的，该方法实际上读取了scrapy的配置文件。这和直接将数据库连接写在代码中相比，是更加通用的方式。初始化和关闭数据库连接的操作都在对应的方法中执行。\nimport pymongo\n\nclass MongoPipeline(object):\n\n    collection_name = 'scrapy_items'\n\n    def __init__(self, mongo_uri, mongo_db):\n        self.mongo_uri = mongo_uri\n        self.mongo_db = mongo_db\n\n    @classmethod\n    def from_crawler(cls, crawler):\n        return cls(\n            mongo_uri=crawler.settings.get('MONGO_URI'),\n            mongo_db=crawler.settings.get('MONGO_DATABASE', 'items')\n        )\n\n    def open_spider(self, spider):\n        self.client = pymongo.MongoClient(self.mongo_uri)\n        self.db = self.client[self.mongo_db]\n\n    def close_spider(self, spider):\n        self.client.close()\n\n    def process_item(self, item, spider):\n        self.db[self.collection_name].insert_one(dict(item))\n        return item\n使用文件和图片管道\n文件和图片管道处理过程\n除了自己编写管道之外，scrapy还预定义了几个管道，可以帮助我们方便的保存文件和图片。这些管道有以下特点：\n\n可以避免重复下载最近的文件。\n指定文件保存位置（文件系统或者亚马逊S3）\n\n对于图片管道来说还有额外功能：\n\n将图片转换成常见格式（JPG）和模式（RGB）\n生成图片缩略图\n只下载大于某长宽的图片\n\n使用文件管道的过程如下：\n\n首先需要Item类中有file_urls和files两个属性，然后在爬虫中将想爬取的文件地址放到file_urls属性中，然后返回\n在Item传递到文件管道的时候，调度程序会用下载器将地址对应的文件下载下来，将文件属性（包括保存路径等）放到files属性中，file_urls和files中是一一对应的\n\n使用图片管道的过程是相似的，不过要操作的属性是image_urls和images。\n如果你不想使用这几个属性，其实属性名也是可以修改的，需要修改下面四个属性。\nFILES_URLS_FIELD = 'field_name_for_your_files_urls'\nFILES_RESULT_FIELD = 'field_name_for_your_processed_files'\nIMAGES_URLS_FIELD = 'field_name_for_your_images_urls'\nIMAGES_RESULT_FIELD = 'field_name_for_your_processed_images'\n管道配置\n要启用文件管道和图片管道，同样需要激活，当然如果同时激活这两个管道也是可行的。\nITEM_PIPELINES = {'scrapy.pipelines.images.ImagesPipeline': 1}\n# 或者\nITEM_PIPELINES = {'scrapy.pipelines.files.FilesPipeline': 1}\n文件和图片保存位置需要分别指定。\nFILES_STORE = '/path/to/valid/dir'\nIMAGES_STORE = '/path/to/valid/dir'\n文件和图片管道可以避免下载最近的文件，对应的文件过期时间也可以配置，单位是天。\n# 120 days of delay for files expiration\nFILES_EXPIRES = 120\n\n# 30 days of delay for images expiration\nIMAGES_EXPIRES = 30\n图片管道可以在保存图片的时候同时生成缩略图，缩略图配置是一个字典，键是缩略图的名字，值是缩略图长和宽。\nIMAGES_THUMBS = {\n    'small': (50, 50),\n    'big': (270, 270),\n}\n最后图片会保存成下面这样，图片的文件名是图片路径的SHA1哈希值。\n/图片保存路径/full/完整图片.jpg\n/图片保存路径/thumbs/small/小图片.jpg\n/图片保存路径/thumbs/big/中图片.jpg\n如果不想使用SHA1哈希值作为文件名，可以继承ImagesPipeline基类并重写file_path函数，这里是另外一位简书作者的爬虫项目，他重写了这个函数。我们可以作为参考。\n如果要过滤小图片，启用下面的配置。默认情况下对图片尺寸没有约束，所以所有图片都会下载。\nIMAGES_MIN_HEIGHT = 110\nIMAGES_MIN_WIDTH = 110\n默认情况下文件和图片管道不支持重定向，遇到需要重定向的链接意味着下载失败，不过我们也可以启用重定向。\nMEDIA_ALLOW_REDIRECTS = True\n下载器中间件\n下载器中间件可以在scrapy引擎和爬虫之间操纵请求和响应对象。要启用下载器中间件，启用下面的配置。这是一个字典，字典的键是要启用的中间件，值会用来比较中间件之间的顺序。\nDOWNLOADER_MIDDLEWARES = {\n    'myproject.middlewares.CustomDownloaderMiddleware': 543,\n}\n如果希望禁用某些内置的中间件，可以将值设置为None。\nDOWNLOADER_MIDDLEWARES = {\n    'myproject.middlewares.CustomDownloaderMiddleware': 543,\n    'scrapy.downloadermiddlewares.useragent.UserAgentMiddleware': None,\n}\n编写自己的下载器中间件\n自定义下载器中间件应该继承scrapy.downloadermiddlewares.DownloaderMiddleware类，该类有如下几个方法，用于操纵请求和响应，我们只要重写这几个方法即可。这几个方法的作用请参考官方文档，它们比较复杂，所以我就不说了。\n\nprocess_request(request, spider)\nprocess_response(request, response, spider)\nprocess_exception(request, exception, spider)\n\n内置的下载器中间件\nscrapy内置了14个下载器中间件，我简单介绍一下其中的几个。详情参考文档。\nCookiesMiddleware\n用于在爬虫发起请求和获取响应的时候保持Cookie。\nDefaultHeadersMiddleware\n用于设置请求的默认请求头。\n该配置位于DEFAULT_REQUEST_HEADERS，默认值如下。\n{\n    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n    'Accept-Language': 'en',\n}\nHttpProxyMiddleware\n设置使用的网络代理。\nUserAgentMiddleware\n设置使用的用户代理。\n爬虫中间件\n与下载器中间件类似，启用爬虫中间件需要一个字典来配置。\nSPIDER_MIDDLEWARES = {\n    'myproject.middlewares.CustomSpiderMiddleware': 543,\n}\n想要关闭某个中间件的时候传递None值。\nSPIDER_MIDDLEWARES = {\n    'myproject.middlewares.CustomSpiderMiddleware': 543,\n    'scrapy.spidermiddlewares.offsite.OffsiteMiddleware': None,\n}\n自定义爬虫中间件\n编写自己的爬虫中间件需要继承scrapy.spidermiddlewares.SpiderMiddleware基类，并重写以下几个方法。\n\nprocess_spider_input(response, spider)\nprocess_spider_output(response, result, spider)\nprocess_spider_exception(response, exception, spider)\nprocess_start_requests(start_requests, spider)\n\n内置的爬虫中间件\nscrapy内置了5个爬虫中间件，这里我仅介绍一两个。\nDepthMiddleware\n该中间件记录了爬虫爬取请求地址的深度。\n我们可以使用DEPTH_LIMIT来指定爬虫爬取的深度。\nUrlLengthMiddleware\n该中间件会过滤掉超出最大允许长度的URL，爬虫不会访问这些超长URL。\n最大长度通过URLLENGTH_LIMIT配置来指定，默认值是2083。\nURLLENGTH_LIMIT = 2083\n内建服务\nscrapy内置了几个服务，可以让我们使用scrapy更加方便。\n日志\n爬虫类定义了log函数，我们可以方便的在爬虫类中记录日志。\nimport scrapy\n\nclass MySpider(scrapy.Spider):\n\n    name = 'myspider'\n    start_urls = ['https://scrapinghub.com']\n\n    def parse(self, response):\n        self.logger.info('Parse function called on %s', response.url)\n日志相关的配置，点击可以跳转到官方文档查看详细信息。\n\nLOG_FILE\nLOG_ENABLED\nLOG_ENCODING\nLOG_LEVEL\nLOG_FORMAT\nLOG_DATEFORMAT\nLOG_STDOUT\nLOG_SHORT_NAMES\n\n发送电子邮件\n有时候我们可能希望爬到一定数量的数据就发送电子邮件进行提醒。scrapy也内置了这个功能。我们可以通过构造函数参数来创建邮件发送器。\nfrom scrapy.mail import MailSender\nmailer = MailSender(这里是构造函数参数)\n也可以从配置文件实例化。\nmailer = MailSender.from_settings(settings)\n然后调用send方法就可以发送邮件了。\nmailer.send(to=[\"someone@example.com\"], subject=\"Some subject\", body=\"Some body\", cc=[\"another@example.com\"])\n电子邮件相关配置参考官方文档。\nweb服务\n这个功能本来是写在官方文档内建服务条目下的，但是实际上这个功能已经变成了一个单独的项目，需要额外安装。\npip install scrapy-jsonrpc\n然后在扩展中包含这个功能。\nEXTENSIONS = {\n    'scrapy_jsonrpc.webservice.WebService': 500,\n}\n还需要在配置中启用该功能。\nJSONRPC_ENABLED = True\n然后在爬虫运行的时候访问http://localhost:6080/crawler即可查看爬虫运行情况了。\n该项目的其他配置查看其官方文档。\n优化爬虫\n爬虫项目可以通过修改一些配置进行优化。\n增大并发数\n并发数可以通过下面的配置进行设置。具体的并发数需要根据服务器的CPU等设置来进行更改。一般来说服务器CPU使用在80%-90%之间利用率比较高。我们可以从并发数100开始反复进行测试。\nCONCURRENT_REQUESTS = 100\n增大线程池\nscrapy通过一个线程池来进行DNS查询，增大这个线程池一般也可以提高scrapy性能。\nREACTOR_THREADPOOL_MAXSIZE = 20\n降低日志级别\n默认情况下scrapy使用debug级别来打印日志，通过降低日志级别，我们可以减少日志打印，从而提高程序运行速度。\nLOG_LEVEL = 'INFO'\n禁用Cookie\n如果不是必须的，我们可以通过禁用Cookie来提高性能。如果需要登录用户才能爬取数据，不要禁用Cookie。\nCOOKIES_ENABLED = False\n关闭重试\n频繁重试可能导致目标服务器响应缓慢，我们自己访问不了别人也访问不了。所以可以考虑关闭重试。\nRETRY_ENABLED = False\n减少下载超时\n如果网络连接比较快的话，我们可以减少下载超时，让爬虫卡住的请求中跳出来，一般可以提高爬虫效率。\nDOWNLOAD_TIMEOUT = 15\n关闭重定向\n如果不是必要的话，我们可以关闭重定向来提高爬虫性能。\nREDIRECT_ENABLED = False\n自动调整爬虫负载\nscrapy有一个扩展可以自动调节服务器负载，它通过一个算法来确定最佳的爬虫延时等设置。它的文档在这里。\n相关配置如下，点击链接可以跳转到对应文档。\n\nAUTOTHROTTLE_ENABLED\nAUTOTHROTTLE_START_DELAY\nAUTOTHROTTLE_MAX_DELAY\nAUTOTHROTTLE_TARGET_CONCURRENCY\nAUTOTHROTTLE_DEBUG\nCONCURRENT_REQUESTS_PER_DOMAIN\nCONCURRENT_REQUESTS_PER_IP\nDOWNLOAD_DELAY\n\n部署爬虫\n官方文档介绍了两种部署爬虫的方式，可以将爬虫部署到服务器上远程执行。第一种是通过Scrapyd开源项目来部署，也是这里要介绍的方式。第二种是通过scrapy公司提供的商业收费版服务Scrapy Cloud部署，推荐有财力的公司考虑。\n服务器端\n首先服务器需要安装scrapyd包，如果是Linux系统还可以考虑使用对应的包管理器来安装。\npip install scrapyd\napt-get install scrapyd\n然后运行scrapyd服务，如果使用系统包管理器安装，那么可能已经配置好了systemd文件。\nscrapyd\n# 或者\nsystemctl enable scrapyd\nscrapyd附带了一个简单的web界面可以帮助我们查看爬虫运行情况，默认情况下访问http://localhost:6800/来查看这个界面。\nscrapyd的配置文件可以是~/.scrapyd.conf或者/etc/scrapyd/scrapyd.conf。下面是一个简单配置，绑定所有端口，这样一来从任意位置都可以访问web界面。\n[scrapyd]\nbind_address = 0.0.0.0\nscrapyd的功能可以查看其API文档。\n客户端\n客户端如果要上传爬虫，可以通过服务器API的端点addversion.json来实现，或者安装一个简便工具scrapyd-client。\n首先安装客户端工具。\npip install scrapyd-client\n这个客户端目前好像有bug，在windows下运行scrapy-deploy命令不会直接执行，而是弹出一个文件关联对话框。如果你遇到这种情况，可以找到Python安装路径下的脚本路径（例如C:\\Program Files\\Python36\\Scripts），然后编写一个scrapyd-deploy.bat批处理文件，内容如下。这样就可以正常运行了。\n@\"c:\\program files\\python36\\python.exe\" \"c:\\program files\\python36\\Scripts\\scrapyd-deploy\" %*\n然后切换到项目路径，编辑项目全局配置文件scrapy.cfg，添加部署路径。\n[deploy]\nurl = http://192.168.64.136:6800/\nproject = quotesbot\n然后直接运行scrapy-deploy命令，就可以看到项目已经成功部署到服务器上了。\n\n运行爬虫需要使用scrapyd的API，例如使用curl，可以用下面的命令。\n curl http://192.168.64.136:6800/schedule.json -d project=quotesbot -d spider=toscrape-css\n或者使用Jetbrains 系列IDE 2017.3的基于编辑器的HTTP客户端。\n然后点击Jobs就可以看到爬虫已经开始运行了。如果要查看状态，点击右边的log即可。\n以上就是scrapy的进阶介绍了，利用这些功能，我们可以编写更加实用的爬虫，并将它们部署到服务器上。\n\n                ", "mainLikeNum": ["6 "], "mainBookmarkNum": "9"}