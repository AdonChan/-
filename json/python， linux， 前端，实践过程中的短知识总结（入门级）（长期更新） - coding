{"title": "python， linux， 前端，实践过程中的短知识总结（入门级）（长期更新） - coding ", "index": "django,python,javascript,flask,linux", "content": "1.sqlalchemy不自带表更新，官方的迁移工具主要是 alembic和sqlalchemy migrate, 如果不使用工具，创建新表可以更新model后通过sqlalchemy的create_all方法，修改表字段则只能进数据库手动改，同时更新model。另外， sqlite在shell下执行sql脚本的方式是：sqlite my.db < test.sql（在客户端命令行中，是：.read test.sql）\n\n2.flask引用配置文件时，有几种方法，参考链接：https://zhuanlan.zhihu.com/p/...\n主要要注意的是配置文件中，配置项必须以大写形式，否则app.config的几个读配置文件的方法（from_object, from_pyfile等）都不会认小写的变量，官方文档说明如下： The configuration files themselves are actual Python files. Only values in uppercase are actually stored in the config object later on. So make sure to use uppercase letters for your config keys.\n\n3.jquery的$(function () {})写法，意思相当于$(document).ready(function())，即文档加载完再执行。\n摘：$(function () {})是$(document).ready(function())的简写，也相当于window.onload = function(){ }。虽然这段jquery代码与javascript代码在功能上可以互换，但执行的时间不一样，前者页面框架加载完成就执行，后者页面中所有内容加载完成才执行\n\n4.有的系统（比如debian）默认用户的命令环境是sh，而不是bash，导致命令行用起来不正常。打开/etc/passwd，看到比如root:x:0:0:root:/root:/bin/sh，即定义root用户默认使用sh，而我们一般使用的是bash。改成/bin/bash即可\n改为bash后，‘#'号前面的文字有时候是：-bash-4.2#，这个是由一个环境变量PS1决定的。这种情况下执行一下echo $PS1，输出是类似\\s-\\v\\$要显示成常见的类似[user@localhost ~]状态，可以改为[\\u@\\h \\w]\\$。\n\n5.几个技术名词：\n`raid  ->  disk`\n`ipvs  ->  host   (loadbalancing)`\n`vrrp  ->  router  (high-ability)`\n`bond  ->  network card`\n`（lvs   =  ipvs + vrrp）`\n简单理解：\nraid就是把几块硬盘连在一起，达到提高存储稳定性的效果，对存储者来说像是一块硬盘。\nipvs就是把几台服务器主机合在一起，主要用于负载均衡，对客户端访问者来说像是一台服务器。\nvrrp就是多个路由器合在一起，主要用于高可用，对主机来说就像是一个路由器。\nbond就是多个网卡合在一起，既可用于高可用也可用于负载均衡，对主机来说就像是一张网卡。\n其实无非是把多个对象对外表现为一个，实现负载均衡或者高可用。当然细节就比较复杂了。\n\n\n\n6.debian系下cron默认使用run-parts命令执行小时、天、周等定时，man一下可知此命令用于执行一个文件夹内所有可执行文件，但是ln了一个软链到/etc/cron.hourly目录下发现并不会执行，手动执行run-parts也确实没有输出，原来是因为run-parts这个命令，对于带.sh后缀的不会执行…\n\n7.sqlalchemy 报错：TypeError: an integer is required，这种情况一般是有数据项的值不符合数据类型，但不一定跟整型有关，比如我就是给boolean类型的字段赋了个字符串的值就出现了这个报错。另外sqlite里boolean的值显示出来是0和1.\n\n8.关于flask上下文：之前用django，习惯了进python命令行，class request():DATA={}手动编一个请求，然后直接实例化view对象，调对应函数把request传进去即模拟了一次请求。\nflask中请求并不直接作为参数传递到响应的函数中，而是作为一个上下文环境中的类似全局变量(好像不同于普通全局变量，待继续学习)。因此，在flask中要实现类似django那样命令行交互，需要些特殊处理，参考    http://flask.pocoo.org/docs/0...。\n这里简单讲下流程： main.py是我的view文件，其中实例化了Flask对象（app），get_all是其中一个响应请求的函数。\n>>> from main.main import *\n>>> d=app.test_request_context('shiki/?shiki=hahahahahaha')\n>>> print(get_all().get_data())\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"E:\\workbench\\flasksite\\main\\main.py\", line 68, in get_all\n    db = get_db()\n  File \"E:\\workbench\\flasksite\\main\\main.py\", line 80, in get_db\n    if not hasattr(g, 'db'):\n  File \"C:\\Program Files\\Python36\\lib\\site-packages\\werkzeug\\local.py\", line 347, in __getattr__\n    return getattr(self._get_current_object(), name)\n  File \"C:\\Program Files\\Python36\\lib\\site-packages\\werkzeug\\local.py\", line 306, in _get_current_object\n    return self.__local()\n  File \"C:\\Program Files\\Python36\\lib\\site-packages\\flask\\globals.py\", line 44, in _lookup_app_object\n    raise RuntimeError(_app_ctx_err_msg)\nRuntimeError: Working outside of application context.\n\nThis typically means that you attempted to use functionality that needed\nto interface with the current application object in a way.  To solve\nthis set up an application context with app.app_context().  See the\ndocumentation for more information.\n>>> d.push()\n>>> print(get_all().get_data())\nb'[\\n  \"hahahahahaha\"\\n]\\n'\n>>>\n\n可以看到直接执行get_all是会提示Working outside of application context。创建一个test_request_context对象，传入url作为参数，并执行push，就相当于进入了上下文环境，可以执行了。d.pop可退出上下文环境。\nps：看起来比起用postman好像毫无优势，不过有时候就是双手不想离开键盘… (:з」∠)\n\n9.python2, 标准库urllib(2)和三方库requests的差别一图流……\n\n10.关于nfs配置\nno_root_squash：登入 NFS 主机使用分享目录的使用者，如果是 root 的话，那么对于这个分享的目录来说，他就具有 root 的权限！这个项目『极不安全』，不建议使用！ \nroot_squash：在登入 NFS 主机使用分享之目录的使用者如果是 root 时，那么这个使用者的权限将被压缩成为匿名使用者，通常他的 UID 与 GID 都会变成 nfsnobody 那个系统账号的身份。\n\n\n\n11.关于原生django(2.0.4)和rest_framework在rest_framework中，封装了data属性，可以由这个统一接口拿到不同请求类型的数据。官方文档如下：\n\nrequest.data returns the parsed content of the request body. This issimilar to the standard request.POST and request.FILES attributesexcept that:· It includes all parsed content, including file and non-file inputs. · It supports parsing the content of HTTP methods other than POST,meaning that you can access the content of PUT and PATCH requests.    · It supports REST framework's flexible request parsing, rather thanjust supporting form data. For example you can handle incoming JSONdata in the same way that you handle incoming form data.\n\n在django中，request对象有request.GET和request.POST方法分别用于获取数据，但POST不能获取application/json类型的请求体。json数据只能在request.body属性中拿到，是一个bytes类型(python3)，需要json.loads转为字典。没有一个像rest_framework那样的统一接口拿各种请求类型的数据。如果要做到那样，一种解决办法是和前端约定请求体全部用json，然后写个中间件。类似：\ntry:\n    request.DATA = json.loads(request.body)\nexcept json.decoder.JSONDecodeError:\n    xxx\n\n注意中间件不应该去访问request.POST.Accessing request.POST inside middleware before the view runs or in process_view() will prevent any view running after the middleware from being able to modify the upload handlers for the request, and should normally be avoided.当然也可以get和post明确各自用，json再另外一个接口，关于这一点好像没有找到风格指南。直觉来说肯定是统一接口方便。\n我的情况是公司原本项目用了rest_framework，而我最近的任务要撸个独立的系统，我打算纯用django。关于我们为什么要使用rest_framework，见：When should i use django-rest-framework?\n\n11.关于gevent.subprocess.Popengevent.subprocess.Popen使用数组作为参数(shell=False)时元素必须都为字符串类型，否则会抛出异常--- execv() arg 2 must contain only strings\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}