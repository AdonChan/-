{"title": "流畅的python读书笔记-第二章Python 数据结构 - 个人文章 ", "index": "python", "content": "列表表达式\n>>> symbols = '$¢£¥€¤'\n>>> codes = [ord(symbol) for symbol in symbols]\n>>> codes\n[36, 162, 163, 165, 8364, 164]\n生成器表达式(节省内存)\n>>> symbols = '$¢£¥€¤'\n>>> tuple(ord(symbol) for symbol in symbols) ➊\n(36, 162, 163, 165, 8364, 164)\n>>> import array\n>>> array.array('I', (ord(symbol) for symbol in symbols)) ➋\narray('I', [36, 162, 163, 165, 8364, 164])\n元素拆包\nlatitude, longitude = lax_coordinates # 元组拆包\n不用中间变量交换值b, a = a, b\n_用来临时挡住不要的对象_, filename = os.path.split('/home/luciano/.ssh/idrsa.pub')\n平行赋值\n>>> a, b, *rest = range(5)\n>>> a, b, rest\n(0, 1, [2, 3, 4])\n>>> a, b, *rest = range(3)\n>>> a, b, rest\n(0, 1, [2])\n>>> a, b, *rest = range(2)\n>>> a, b, rest\n(0, 1, [])\n\n# 任意位置\n>>> a, *body, c, d = range(5)\n>>> a, body, c, d\n(0, [1, 2], 3, 4)\n>>> *head, b, c, d = range(5)\n>>> head, b, c, d\n([0, 1], 2, 3, 4)\n解包\n可见在调用参数的时候使用*号可以自动解包\ndef add（x，y）:\n    print x+y\npara = (1,2)\nadd(*para)\n同理如果是两个星号的话，就是带有**号的字典，自动解包\ndef add(x,y):\n    print x+y\nkkwd = {'x' :1,'y':2}\nadd(**kkwd)\n嵌套元素拆包metro_areas = [('Tokyo','JP',36.933,(35.689722,139.691667)), # ➊('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)),('Mexico City', 'MX', 20.142, (19.433333, -99.133333)),('New York-Newark', 'US', 20.104, (40.808611, -74.020386)),('Sao Paulo', 'BR', 19.649, (-23.547778, -46.635833)),]\nfor name, cc, pop, (latitude, longitude) in metro_areas: # ➋if longitude <= 0: # ➌print(fmt.format(name, latitude, longitude))\n具名元组\nCard = collections.namedtuple('Card', ['rank', 'suit'])\n>>> City._fields ➊\n('name', 'country', 'population', 'coordinates')\n>>> LatLong = namedtuple('LatLong', 'lat long')\n>>> delhi_data = ('Delhi NCR', 'IN', 21.935, LatLong(28.613889, 77.208889))\n>>> delhi = City._make(delhi_data) ➋\n>>> delhi._asdict() ➌\nOrderedDict([('name', 'Delhi NCR'), ('country', 'IN'), ('population',\n21.935), ('coordinates', LatLong(lat=28.613889, long=77.208889))])\n>>> for key, value in delhi._asdict().items():\nprint(key + ':', value)\nname: Delhi NCR\ncountry: IN\npopulation: 21.935\ncoordinates: LatLong(lat=28.613889, long=77.208889)\n>>>\n❶ _fields 属性是一个包含这个类所有字段名称的元组。❷ 用 _make() 通过接受一个可迭代对象来生成这个类的一个实例，它的作用跟 City(*delhi_data) 是一样的。❸ _asdict() 把具名元组以 collections.OrderedDict 的形式返回，我们可以利用它来把元组里的信息友好地呈现出来。\n列表或元组的方法和属性（那些由object类支持的方法没有\n列出来） page 84\n切片\n为什么切片和区间会忽略最后一个元素\n\n当只有最后一个位置信息时，我们也可以快速看出切片和区间里有几个元素：range(3) 和 my_list[:3] 都返回 3 个元素。\n当起止位置信息都可见时，我们可以快速计算出切片和区间的长度，用后一个数减去第一个下标（stop - start）即可。\n这样做也让我们可以利用任意一个下标来把序列分割成不重叠的两部分，只要写成 my_list[:x] 和 my_list[x:] 就可以了，如下所示。\n\n>>> l = [10, 20, 30, 40, 50, 60]\n>>> l[:2] # 在下标2的地方分割\n[10, 20]\n>>> l[2:]\n[30, 40, 50, 60]\n>>> l[:3] # 在下标3的地方分割\n[10, 20, 30]\n>>> l[3:]\n[40, 50, 60]\n步进切片\n对seq[start:stop:step] 进行求值的时候，Python 会调用seq.__getitem__(slice(start, stop, step))。\n+=\n+= 背后的特殊方法是 iadd （用于“就地加法”）。但是如果一个类没有实现这个方法的话，Python 会退一步调用 add 。考\n+= 的概念也适用于 *=，不同的是，后者相对应的是 imul\n好工具\nPython Tutor（http://www.pythontutor.com）是一个对 Python 运行原理进行可视化分析的工具。\n内置函数sorted\n一个只有一个参数的函数，这个函数会被用在序列里的每一个元素上，所产生的结果将是排序算法依赖的对比关键字。\nreverse如果被设定为 True，被排序的序列里的元素会以降序输出\n注意并不是简单的把排序结果给反过来,是降序(按照之前的反排序)\n数组\n\n如果我们需要一个只包含数字的列表，那么 array.array 比 list 更高效。\n数组支持所有跟可变序列有关的操作，包括 .pop、.insert 和.extend。\n另外，数组还提供从文件读取和存入文件的更快的方法，如.frombytes 和 .tofile。\n\n示例代码\n>>> from array import array ➊\n>>> from random import random\n>>> floats = array('d', (random() for i in range(10**7))) ➋\n>>> floats[-1] ➌\n0.07802343889111107\n>>> fp = open('floats.bin', 'wb')\n>>> floats.tofile(fp) ➍\n>>> fp.close()\n>>> floats2 = array('d') ➎\n>>> fp = open('floats.bin', 'rb')\n>>> floats2.fromfile(fp, 10**7) ➏\n>>> fp.close()\n>>> floats2[-1] ➐\n0.07802343889111107\n>>> floats2 == floats ➑\nTrue\n结论:\n\narray.tofile 和 array.fromfile 用 起来很简单。\n用 array.fromfile 从一个二进制文件里读出 1000 万个 双精度浮点数只需要 0.1 秒，\n这比从文本文件里读取的速度要快 60倍，因为后者会使用内置的 float 方法把每一行文字转换成浮点数。\n\n列表和数组的属性和方法 page110\nNumPy 和 SciPy\nNumPy 和 SciPy 提供的高阶数组和矩阵操作，Python 成为科学计算应用的主流语言。\n双向队列和其他形式的队列\ncollections.deque 类（双向队列）是一个线程安全、可以快速从两端添加或者删除元素的数据类型。\n>>> from collections import deque\n>>> dq = deque(range(10), maxlen=10) ➊\n>>> dq\ndeque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)\n>>> dq.rotate(3) ➋\n>>> dq\ndeque([7, 8, 9, 0, 1, 2, 3, 4, 5, 6], maxlen=10)\n>>> dq.rotate(-4)\n>>> dq\ndeque([1, 2, 3, 4, 5, 6, 7, 8, 9, 0], maxlen=10)\n>>> dq.appendleft(-1) ➌\n>>> dq\ndeque([-1, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)\n>>> dq.extend([11, 22, 33]) ➍\n>>> dq\ndeque([3, 4, 5, 6, 7, 8, 9, 11, 22, 33], maxlen=10)\n>>> dq.extendleft([10, 20, 30, 40]) ➎\n>>> dq\ndeque([40, 30, 20, 10, 3, 4, 5, 6, 7, 8], maxlen=10)\n❶ maxlen 是一个可选参数，代表这个队列可以容纳的元素的数量❹ 在尾部添加 3 个元素的操作会挤掉 -1、1 和 2。\n列表和双向队列 page 119\n小总结\n\n列表表达式 和 生成器表达式(元祖省内存)很好用\n元祖的拆包十分神奇,尤其是*号的存在\n具名元组的实例也很节省空间,有点像模拟字典使用,._asdict() 方法来把记录变成 OrderedDict 类型\n切片是基本用法,给切片赋值是个好的修改方式\n+=\n\n\n增量赋值 += 和 *= 会区别对待可变和不可变序列。\n在遇到不可变序列时，这两个操作会在背后生成新的序列。\n但如果被赋值的对象是可变的，那么这个序列会就地修改\n\n\nsorted 函数,只需要一个比较方法key\n纯数字数组用 array.array比较好,NumPy 和 SciPy科学计算神奇世界\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}