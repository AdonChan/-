{"title": "leetcode-854-K-Similar Strings - 个人文章 ", "index": "python", "content": "题目本质：通过将字符串A的字母之间的连续交换位置，达到 两个字符串之间完全相同的情况解析：通过将不相等处的字母，发现之后找到想等的，然后进行位置替换。如此反复。\n   问题在于慢，慢在于只要不相等，就会遍历字符串之后所有的字符，大量重复的无意义的计算比较，所以将遍历过的计算过的存在于memo字符串中间。\n错误：没有找到效率低的问题所在，在于比较过的无意义的比较。\n   没有发现字符串的遍历，一种向前，一种向后。\n   对付效率低，一种有效的方式就是缓存，将比较过的先储存起来\n应用：缓存意识，发现大量比较，可能有重复，储存。\n   递归函数，利用返回结果的话，返回结果是递归到最后，结束遍历以后，得到的结果才有效。  \n             \n\nimport sys\nclass Solution:\n    def kSimilarity(self, A, B):\n        memo=dict()\n        self.ans=sys.maxsize\n        def helper(a,b):\n            if len(a)!=len(b):\n                return 0\n            elif a==b:\n                return 0\n            elif (a,b) in memo:\n                print(a,b,memo[(a,b)])\n                return memo[(a,b)]\n            elif a[-1]==b[-1]:\n                self.ans=min(self.ans,helper(a[:-1],b[:-1]))\n            else:\n                for i in range(0,len(a)-1):\n                    # print(a,b)\n                    if a[i]==b[-1]:\n                        # print(a[:i],b[-1],a[i+1:])\n                        a_new=a[:i]+a[-1]+a[i+1:-1]\n                        # print(a_new,b[:-1])\n                        self.ans=min(self.ans,1+helper(a_new,b[:-1]))\n                        # self.ans=1+helper(a_new,b[:-1])\n                        # break\n                        # print(self.ans)\n            memo[(a,b)]=self.ans\n            return self.ans\n        self.ans=helper(A,B)\n        return self.ans\n\nif __name__=='__main__':\n    A = \"aabc\"\n    B = \"abca\"\n    A=\"abbcac\"\n    B=\"abcbca\"\n    A=\"abccaacceecdeea\"\n    B=\"bcaacceeccdeaae\"\n    A=\"fffeaacbdbdafcfbbafb\"\n    B=\"abcbdfafffefabdbbafc\"\n    # A=\"abfdfacbd b d a f cfbbafb\"\n    # B=\"abcbdfaff f e f a bdbbafc\"\n    # A=\"abccab\"\n    # B=\"abccab\"\n    st=Solution()\n    # out=st.kSimilarity(A,B)\n    out=st.kSimilarity(A,B)\n    print(out)\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}