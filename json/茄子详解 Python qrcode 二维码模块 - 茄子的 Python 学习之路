{"title": "茄子详解 Python qrcode 二维码模块 - 茄子的 Python 学习之路 ", "index": "qrcode,二维码,python", "content": "https://github.com/lincolnloo...\n声明\nimport qrcode\n使用\nQRCode 方法\nqrcode.QRCode(\n    version=1,\n    error_correction=qrcode.ERROR_CORRECT_L,\n    box_size=10,\n    border=4,\n    image_factory=None,\n    mask_pattern=None\n)\n参数解释：\n\n\nversion：控制二维码的大小，取值范围从1到40。取最小值1时，二维码大小为21*21。取值为 None （默认）或者使用fit=true参数（默认）时，二维码会自动调整大小。\n\nerror_correction：控制二维码纠错级别。\n\nERROR_CORRECT_L：大约7%或者更少的错误会被更正。\nERROR_CORRECT_M：默认值，大约15%或者更少的错误会被更正。\nERROR_CORRECT_Q：大约25%或者更少的错误会被更正。\nERROR_CORRECT_H：大约30%或者更少的错误会被更正。\n\n\n\nbox_size：控制二维码中每个格子的像素数，默认为 10。\n\nborder：控制二维码四周留白包含的格子数，默认为4。\n\nimage_factory：选择生成图片的形式，默认为 PIL 图像。\n\nmask_pattern：选择生成图片的的掩模。\n\n方法属性解释：\n常用方法：\n\n\nadd_data(str,optimize=20):添加要转换的文字到data参数；如果使用了optimize优化参数，数据将被拆分为多个块来进行优化，以找到一个长度至少为这个值的足够简洁的方式来生成二维码。设置为“0”以避免优化。\n\nmake(fit=True):当fit参数为真或者没有给出version参数时，将会调用best_fit方法来找到适合数据的最小尺寸。如果没有设置mask_pattern，将会调用best_mask_pattern方法来找到找到最有效的掩模图案。最后将这些数据传递给makeImpl方法来生成二维码。与qrcode本体的make方法不一样的是，这个方法没有任何返回值。\n\n\nmake_image(fill_color=None, back_color=None,image_factory=None):创建二维码的图像并返回，默认为 PIL 图像。**\n\n如果要让二维码有颜色，可以在这里设置。**\n\n\nclear:清空数据\n\nget_matrix:返回二维码数组。\n\nprint_ascii(out=None, tty=False, invert=False):这个方法就比较有趣了，可以用字符画的形式来输出二维码，但是扫的时候一般都扫不出来。其中的invert参数是决定是否反转颜色的参数，默认为假，如果为真的话会这样：\n\n\n其他方法：\n\n\nbest_fit(start=self.version):找到适合数据所需的最小尺寸。\n\nbest_mask_pattern():找到最有效的掩模图案。\n\nmakeImpl(test, mask_pattern):生成二维码的直接函数\n\nmap_data:（内部函数，无需了解）\n\nprint_tty(out=None):用TTY颜色输出二维码，如果没有给出out参数，会使用sys.stdout。\n\nsetup_position_adjust_pattern:（内部函数，无需了解）\n\nsetup_position_probe_pattern:（内部函数，无需了解）\n\nsetup_timing_pattern:（内部函数，无需了解）\n\nsetup_type_info:（内部函数，无需了解）\n\nsetup_type_number:（内部函数，无需了解）\n\n属性（这些大家基本都不用管）：\n\n\nborder:\n\nbox_size:\n\ndata_cache:\n\ndata_list:\n\nerror_correction:\n\nimage_factory:\n\nmask_pattern:\n\nmodules:\n\nmodules_count:\n\nversion:\n\n生成 SVG 图像\nqrcode可以生成三种不同的svg图像，一种是用路径表示的svg，一种是用矩形集合表示的完整svg文件，还有一种是用矩形集合表示的svg片段。第一种用路径表示的svg其实就是矢量图，可以在图像放大的时候可以保持图片质量，而另外两种可能会在格子之间出现空隙。 \n这三种分别对应了svg.py中的SvgPathImage、SvgImage和SvgFragmentImage类。在调用qrcode.make函数或者实例化QRCode时当作image_factory参数的值传入就可以了。\nimport qrcode.image.svg\n\nif method == 'basic':\n    # Simple factory, just a set of rects.\n    factory = qrcode.image.svg.SvgImage\nelif method == 'fragment':\n    # Fragment factory (also just a set of rects)\n    factory = qrcode.image.svg.SvgFragmentImage\nelse:\n    # Combined path factory, fixes white space that may occur when zooming\n    factory = qrcode.image.svg.SvgPathImage\n\nimg = qrcode.make('Some data here', image_factory=factory)\n生成 PNG 图像\n执行命令安装pymaging相关模块：\npip install git+git://github.com/ojii/pymaging.git#egg=pymaging\n\npip install git+git://github.com/ojii/pymaging-png.git#egg=pymaging-png\n然后给image_factor参数传入qrcode.image.pure.PymagingImage就可以生成PNG图片了。\nimport qrcode\nfrom qrcode.image.pure import PymagingImage\nimg = qrcode.make('Some data here', image_factory=PymagingImage)\n这是作者推荐的方式，但是我个人认为，完全没有必要这么麻烦，直接用默认的 PIL 就可以获取 PNG 图片了，例子看下文。\nmake 方法\nmake方法实际上就是在内部调用了QRCode(要转换的文本).make_image()，最后（默认）返回了一个PIL图像对象。\n# 显示图片\nqrcode.make(\"hello world!\").show()\n# 保存 PNG 图片\nqrcode.make(\"hello world!\").save('hello.png')\nrun_example 方法\n生成一个作者项目网站地址的二维码并显示出来。\n翻译自作者的Github地址中的 README 和具体代码注释。\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "0"}