{"title": "Python中的类元编程 - 个人文章 ", "index": "python", "content": "导语：本文章记录了本人在学习Python基础之元编程篇的重点知识及个人心得，打算入门Python的朋友们可以来一起学习并交流。\n本文重点：\n1、了解运行时创建类的方法——类工厂函数；2、熟悉元类的基础知识和使用场景；3、了解元类的__prepare__的意义；4、了解class的属性以及Python解释器如何处理导入的模块。\n类元编程是指在运行时创建或定制类的技艺。\n一、类工厂函数\n类是一等对象，因此任何时候都可以使用函数新建类，而无需使用class关键字。\n实例： 下面我们写一个简单的类工厂函数：\ndef record_factory(cls_name,field_names):\n    try:\n        field_names=field_names.replace(',',' ').split()\n    except AttributeError:\n        pass\n    field_names=tuple(field_names)#使用属性名构建元组，这将成为新的__slots__。\n\n    def __init__(self,*args,**kwards):#通过字典解析输入数据，然后将值赋给新建的类的属性。\n        attrs=dict(zip(self.__slots__,args))\n        attrs.update(kwards)\n        for key,value in attrs.items():\n            setattr(self,key,value)\n\n    def __iter__(self):#迭代特殊方法的思想在于让解释器查询到属性对应的值。\n        for name in self.__slots__:\n            yield getattr(self,name)#实现迭代的方法在于：通过内置getattr方法获取已经初始化的类属性对应的值。\n    def __repr__(self):#返回一个合适的字符串。\n        msg=', '.join('{}={!r}'.format(*i) for i in zip(self.__slots__,self))\n        return '{}({})'.format(self.__class__.__name__,msg)\n\n    cls_attrs=dict(__slots__=field_names,\n                   __init__=__init__,\n                  __iter__=__iter__,\n                   __repr__=__repr__)\n\n    return type(cls_name,(object,),cls_attrs)#使用type构造方法构建新类并返回，注意object后的逗号很重要。\nanimal=record_factory('animal','name,age,price')\ndog=animal('dog','Bob','1000')\nprint(dog)#构造animal实例对象\na,b,_=dog#可以实现预期的拆包赋值\nprint(a,b）\n输出：\nanimal(name='dog', age='Bob', price='1000')\ndog Bob\ntype的三个参数：class type(name, bases, dict)type最后一个参数是一个映射，指定新类的属性名和值。\n注意：在Python中做元编程时, 最好不要用 exec 和 eval 函数.。如果接接收的字符串来自不可信的源，这两个函数会带来严重的安全风险.\n二、定制描述符的类装饰器\n类装饰器：本质上是高阶函数，其参数是被装饰的类，用于审查审查、修改、甚至把被装饰的类替换成其他类。\n类装饰器的重大缺点：只对直接依附的类有效。即被装饰的类的子类可能继承也可能不继承装饰器所做的改动，具体情况视改动的方式而定。\n三、元类\n1、基础知识\n元类：是类元编程最高级的工具：使用元类可以创建具有某种特质的全新变种，例如抽象基类。功能：元类是创建类的类。特点：\n\n所有类都直接或间接地是type的实例，不过只有元类同时也是type的子类。\n具体而言，元类可以通过实现__init__方法定制类。\n为了避免无限回溯，type.__class是type，即type是自身的实例。\n\n建议：除非开发框架，否则不要在生产代码中定义元类或抽象基类。\n实例：使用元类定制描述符\nclass EntityMeta(type):\n    \"\"\"Metaclass for business entities with validated fields\"\"\"\n\n    def __init__(cls, name, bases, attr_dict):\n        super().__init__(name, bases, attr_dict)  # 创建类对象。\n        for key, attr in attr_dict.items():  # <2>\n            if isinstance(attr, Validated):\n                type_name = type(attr).__name__\n                attr.storage_name = '_{}#{}'.format(type_name, key)\n\nclass Entity(metaclass=EntityMeta):  # <3>\n    \"\"\"Business entity with validated fields\"\"\"\n2、元类的使用场景：\n\n验证属性\n一次把装饰器依附到多个方法上\n序列化对象或转换数据\n对象关系映射\n基于对象的持久存储\n动态转换使用其他语言编写为所有类定义的方法\n\n四、元类的特殊方法__prepare__\n__prepare__的功能：知道类的属性定义的顺序。使用场景：__prepare__只在元类中有用，而且必须声明为类方法（即要使用@classmethod 装饰器定义）。参数要求：__prepare__方法的第一个参数是元类，随后两个参数分别是要构建的类的名称和基类组成的元组， 返回值必须是映射。工作原理：元类构建新类时，解释器会先调用__prepare__ 方法，使用类定义体中的属性创建映射。接着把__prepare__方法返回的映射会传给__new__ 方法的最后一个参数，然后再传给__init__ 方法。\n实例：使用__prepare__\nclass EntityMeta(type):\n    \"\"\"Metaclass for business entities with validated fields\"\"\"\n\n    @classmethod\n    def __prepare__(cls, name, bases):\n        return collections.OrderedDict()  # 返回一个空的 OrderedDict 实例，类属性将存储在里面。\n\n    def __init__(cls, name, bases, attr_dict):\n        super().__init__(name, bases, attr_dict)\n        cls._field_names = []  # 中创建一个 _field_names 属性\n        for key, attr in attr_dict.items():\n            if isinstance(attr, Validated):\n                type_name = type(attr).__name__\n                attr.storage_name = '_{}#{}'.format(type_name, key)\n                cls._field_names.append(key)\n\nclass Entity(metaclass=EntityMeta):\n    \"\"\"Business entity with validated fields\"\"\"\n\n    @classmethod\n    def field_names(cls):  # field_names 类方法的作用简单：按照添加字段的顺序产出字段的名称\n        for name in cls._field_names:\n            yield name\n五、其他\n1、Python中的导入时和运行时\n在进程中首次导入模块时，Python解释器还会运行所导入模块中的全部顶层代码。以后导入相同的模块则使用缓存，只做名称绑定。\n对函数而言，首次导入模块时：解释器会执行顶层的 def 语句，编译函数的定义体，把函数对象绑定到对应的全局名称上，但是显然解释器不会执行函数的定义体。通常这意味着解释器在导入时定义顶层函数，但是仅当在运行时调用函数时才会执行函数的定义体。\n对类而言，首次导入模块时：解释器会执行每个类的定义体，甚至会执行嵌套类的定义体。执行类定义体的结果是，定义了类的属性和方法，并构建了类对象。从这个意义上理解，类的定义体属于“顶层代码”，因为它在导入时运行。\n2、类的属性\nclass除了除__mro__、__class__、和__name__之外还有以下属性：\n\n\ncls.__bases__：由类的基类组成的元组。\n\ncls.__qualname__：其值是类或函数的限定名称，即从模块的全局作用域到类的点分路径。\n\ncls.__subclasses__()：这个方法返回一个列表，包含类的直接子类。其实现使用弱引用，防止超类和子类之间出现循环引用。这个方法返回的列表是内存里现存的子类。\n\ncls.mro()：构建类时，如果需要获取储存在类属性__mro__ 中的超类元组，解释器会调用这个方法。元类可以覆盖这个方法，定制要构建的类解析方法的顺序。\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}