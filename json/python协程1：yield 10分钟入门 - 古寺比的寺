{"title": "python协程1：yield 10分钟入门 - 古寺比的寺 ", "index": "读书笔记,协程,python", "content": "最近找到一本python好书《流畅的python》，是到现在为止看到的对python高级特性讲述最详细的一本。看了协程一章，做个读书笔记，加深印象。\n协程定义\n协程的底层架构是在pep342 中定义，并在python2.5 实现的。\npython2.5 中，yield关键字可以在表达式中使用，而且生成器API中增加了 .send(value)方法。生成器可以使用.send(...)方法发送数据，发送的数据会成为生成器函数中yield表达式的值。\n协程是指一个过程，这个过程与调用方协作，产出有调用方提供的值。因此，生成器可以作为协程使用。\n除了 .send(...)方法，pep342 和添加了 .throw(...)（让调用方抛出异常，在生成器中处理）和.close()（终止生成器）方法。\npython3.3后，pep380对生成器函数做了两处改动：\n\n生成器可以返回一个值；以前，如果生成器中给return语句提供值，会抛出SyntaxError异常。\n引入yield from 语法，使用它可以把复杂的生成器重构成小型的嵌套生成器，省去之前把生成器的工作委托给子生成器所需的大量模板代码。\n\n协程生成器的基本行为\n首先说明一下，协程有四个状态，可以使用inspect.getgeneratorstate(...)函数确定：\n\nGEN_CREATED    # 等待开始执行\nGEN_RUNNING    # 解释器正在执行（只有在多线程应用中才能看到这个状态）\nGEN_SUSPENDED  # 在yield表达式处暂停\nGEN_CLOSED     # 执行结束\n\n#! -*- coding: utf-8 -*-\nimport inspect\n\n# 协程使用生成器函数定义：定义体中有yield关键字。\ndef simple_coroutine():\n    print('-> coroutine started')\n    # yield 在表达式中使用；如果协程只需要从客户那里接收数据，yield关键字右边不需要加表达式（yield默认返回None）\n    x = yield\n    print('-> coroutine received:', x)\n\n\nmy_coro = simple_coroutine()\nmy_coro # 和创建生成器的方式一样，调用函数得到生成器对象。\n# 协程处于 GEN_CREATED (等待开始状态)\nprint(inspect.getgeneratorstate(my_coro))\n\nmy_coro.send(None)\n# 首先要调用next()函数，因为生成器还没有启动，没有在yield语句处暂停，所以开始无法发送数据\n# 发送 None 可以达到相同的效果 my_coro.send(None) \nnext(my_coro)\n# 此时协程处于 GEN_SUSPENDED (在yield表达式处暂停)\nprint(inspect.getgeneratorstate(my_coro))\n\n# 调用这个方法后，协程定义体中的yield表达式会计算出42；现在协程会恢复，一直运行到下一个yield表达式，或者终止。\nmy_coro.send(42)\nprint(inspect.getgeneratorstate(my_coro))\n运行上述代码，输出结果如下\nGEN_CREATED\n-> coroutine started\nGEN_SUSPENDED\n-> coroutine received: 42\n\n# 这里，控制权流动到协程定义体的尾部，导致生成器像往常一样抛出StopIteration异常\nTraceback (most recent call last):\n  File \"/Users/gs/coroutine.py\", line 18, in <module> \n    my_coro.send(42)\nStopIteration\nsend方法的参数会成为暂停yield表达式的值，所以，仅当协程处于暂停状态是才能调用send方法。如果协程还未激活（GEN_CREATED 状态）要调用next(my_coro) 激活协程，也可以调用my_coro.send(None)\n如果创建协程对象后立即把None之外的值发给它，会出现下述错误：\n>>> my_coro = simple_coroutine()\n>>> my_coro.send(123)\n\nTraceback (most recent call last):\n  File \"/Users/gs/coroutine.py\", line 14, in <module>\n    my_coro.send(123)\nTypeError: can't send non-None value to a just-started generator\n仔细看错误消息\ncan't send non-None value to a just-started generator\n最先调用next(my_coro) 这一步通常称为”预激“（prime）协程---即，让协程向前执行到第一个yield表达式，准备好作为活跃的协程使用。\n再看一个两个值得协程\ndef simple_coro2(a):\n    print('-> coroutine started: a =', a)\n    b = yield a\n    print('-> Received: b =', b)\n    c = yield a + b\n    print('-> Received: c =', c)\n\nmy_coro2 = simple_coro2(14)\nprint(inspect.getgeneratorstate(my_coro2))\n# 这里inspect.getgeneratorstate(my_coro2) 得到结果为 GEN_CREATED （协程未启动）\n\nnext(my_coro2)\n# 向前执行到第一个yield 处 打印 “-> coroutine started: a = 14”\n# 并且产生值 14 （yield a 执行 等待为b赋值）\nprint(inspect.getgeneratorstate(my_coro2))\n# 这里inspect.getgeneratorstate(my_coro2) 得到结果为 GEN_SUSPENDED （协程处于暂停状态）\n\nmy_coro2.send(28)\n# 向前执行到第二个yield 处 打印 “-> Received: b = 28”\n# 并且产生值 a + b = 42（yield a + b 执行 得到结果42 等待为c赋值）\nprint(inspect.getgeneratorstate(my_coro2))\n# 这里inspect.getgeneratorstate(my_coro2) 得到结果为 GEN_SUSPENDED （协程处于暂停状态）\n\nmy_coro2.send(99)\n# 把数字99发送给暂停协程，计算yield 表达式，得到99，然后把那个数赋值给c 打印 “-> Received: c = 99”\n# 协程终止，抛出StopIteration\n运行上述代码，输出结果如下\nGEN_CREATED\n-> coroutine started: a = 14\nGEN_SUSPENDED\n-> Received: b = 28\n-> Received: c = 99\n\nTraceback (most recent call last):\n  File \"/Users/gs/coroutine.py\", line 37, in <module>\n    my_coro2.send(99)\nStopIteration\nsimple_coro2 协程的执行过程分为3个阶段，如下图所示\n\n\n调用next(my_coro2)，打印第一个消息，然后执行yield a，产出数字14.\n调用my_coro2.send(28)，把28赋值给b，打印第二个消息，然后执行 yield a + b 产生数字42\n调用my_coro2.send(99)，把99赋值给c，然后打印第三个消息，协程终止。\n\n使用装饰器预激协程\n我们已经知道，协程如果不预激，不能使用send() 传入非None 数据。所以，调用my_coro.send(x)之前，一定要调用next(my_coro)。为了简化，我们会使用装饰器预激协程。\nfrom functools import wraps\n\ndef coroutinue(func):\n    '''\n    装饰器： 向前执行到第一个`yield`表达式，预激`func`\n    :param func: func name\n    :return: primer\n    '''\n\n    @wraps(func)\n    def primer(*args, **kwargs):\n        # 把装饰器生成器函数替换成这里的primer函数；调用primer函数时，返回预激后的生成器。\n        gen = func(*args, **kwargs)\n        # 调用被被装饰函数，获取生成器对象\n        next(gen)  # 预激生成器\n        return gen  # 返回生成器\n    return primer\n\n\n# 使用方法如下\n\n@coroutinue\ndef simple_coro(a):\n    a = yield\n\nsimple_coro(12)  # 已经预激\n终止协程和异常处理\n协程中，为处理的异常会向上冒泡，传递给next函数或send方法的调用方，未处理的异常会导致协程终止。\n看下边这个例子\n#! -*- coding: utf-8 -*-\n\nfrom functools import wraps\n\ndef coroutinue(func):\n    '''\n    装饰器： 向前执行到第一个`yield`表达式，预激`func`\n    :param func: func name\n    :return: primer\n    '''\n\n    @wraps(func)\n    def primer(*args, **kwargs):\n        # 把装饰器生成器函数替换成这里的primer函数；调用primer函数时，返回预激后的生成器。\n        gen = func(*args, **kwargs)\n        # 调用被被装饰函数，获取生成器对象\n        next(gen)  # 预激生成器\n        return gen  # 返回生成器\n    return primer\n\n\n@coroutinue\ndef averager():\n    # 使用协程求平均值\n    total = 0.0\n    count = 0\n    average = None\n    while True:\n        term = yield average\n        total += term\n        count += 1\n        average = total/count\n\ncoro_avg = averager()\nprint(coro_avg.send(40))\nprint(coro_avg.send(50))\nprint(coro_avg.send('123')) # 由于发送的不是数字，导致内部有异常抛出。\n执行上述代码结果如下\n40.0\n45.0\nTraceback (most recent call last):\n  File \"/Users/gs/coro_exception.py\", line 37, in <module>\n    print(coro_avg.send('123'))\n  File \"/Users/gs/coro_exception.py\", line 30, in averager\n    total += term\nTypeError: unsupported operand type(s) for +=: 'float' and 'str'\n出错的原因是发送给协程的'123'值不能加到total变量上。出错后，如果再次调用 coro_avg.send(x) 方法 会抛出 StopIteration 异常。\n由上边的例子我们可以知道，如果想让协程退出，可以发送给它一个特定的值。比如None和Ellipsis。（推荐使用Ellipsis，因为我们不太使用这个值）从Python2.5 开始，我们可以在生成器上调用两个方法，显式的把异常发给协程。这两个方法是throw和close。\ngenerator.throw(exc_type[, exc_value[, traceback]])\n这个方法使生成器在暂停的yield表达式处抛出指定的异常。如果生成器处理了抛出的异常，代码会向前执行到下一个yield表达式，而产出的值会成为调用throw方法得到的返回值。如果没有处理，则向上冒泡，直接抛出。\ngenerator.close()\n生成器在暂停的yield表达式处抛出GeneratorExit异常。如果生成器没有处理这个异常或者抛出了StopIteration异常，调用方不会报错。如果收到GeneratorExit异常，生成器一定不能产出值，否则解释器会抛出RuntimeError异常。\n示例： 使用close和throw方法控制协程。\nimport inspect\n\n\nclass DemoException(Exception):\n    pass\n\n\n@coroutinue\ndef exc_handling():\n    print('-> coroutine started')\n    while True:\n        try:\n            x = yield\n        except DemoException:\n            print('*** DemoException handled. Conginuing...')\n        else:\n            # 如果没有异常显示接收到的值\n            print('--> coroutine received: {!r}'.format(x))\n    raise RuntimeError('This line should never run.')  # 这一行永远不会执行 \n\n\nexc_coro = exc_handling()\n\nexc_coro.send(11)\nexc_coro.send(12)\nexc_coro.send(13)\nexc_coro.close()\nprint(inspect.getgeneratorstate(exc_coro))\nraise RuntimeError('This line should never run.') 永远不会执行，因为只有未处理的异常才会终止循环，而一旦出现未处理的异常，协程会立即终止。\n执行上述代码得到结果为：\n-> coroutine started\n--> coroutine received: 11\n--> coroutine received: 12\n--> coroutine received: 13\nGEN_CLOSED    # 协程终止\n上述代码，如果传入DemoException，协程不会中止，因为做了异常处理。\nexc_coro = exc_handling()\n\nexc_coro.send(11)\nexc_coro.send(12)\nexc_coro.send(13)\nexc_coro.throw(DemoException) # 协程不会中止，但是如果传入的是未处理的异常，协程会终止\nprint(inspect.getgeneratorstate(exc_coro))\nexc_coro.close()\nprint(inspect.getgeneratorstate(exc_coro))\n\n## output\n\n-> coroutine started\n--> coroutine received: 11\n--> coroutine received: 12\n--> coroutine received: 13\n*** DemoException handled. Conginuing...\nGEN_SUSPENDED\nGEN_CLOSED\n如果不管协程如何结束都想做些处理工作，要把协程定义体重的相关代码放入try/finally块中。\n@coroutinue\ndef exc_handling():\n    print('-> coroutine started')\n    try:\n        while True:\n            try:\n                x = yield\n            except DemoException:\n                print('*** DemoException handled. Conginuing...')\n            else:\n                # 如果没有异常显示接收到的值\n                print('--> coroutine received: {!r}'.format(x))\n    finally:\n        print('-> coroutine ending')\n上述部分介绍了：\n\n生成器作为协程使用时的行为和状态\n使用装饰器预激协程\n调用方如何使用生成器对象的 .throw(...)和.close() 方法控制协程\n\n下一部分将介绍：\n\n协程终止时如何返回值\nyield新句法的用途和语义\n\n最后，感谢女朋友支持。\n\n\n>欢迎关注\n>请我喝芬达\n\n\n\n\n\n\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "11"}