{"title": "opencv python Canny边缘检测 - 个人文章 ", "index": "opencv-python,opencv,python", "content": "Canny Edge Detection \nCanny边缘检测是一种流行的边缘检测算法.它是由John F. Canny开发的,\n\n这是一个多阶段算法.\n\n减少噪音由于边缘检测易受图像中的噪声影响，因此第一步是使用5x5高斯滤波器去除图像中的噪声.\n\n计算图像梯度对平滑后的图像使用sobel算子在水平与竖直方向上计算一阶导数，得到图像梯度（Gx和Gy）。根据梯度图找到边界梯度和方向$$ Edge\\_Gradient \\; (G) = \\sqrt{G_x^2 + G_y^2} $$$$\\ Angle  (\\theta) = \\tan^{-1} \\bigg(\\frac{G_y}{G_x}\\bigg) $$ 梯度方向一般与边界垂直，有四类：垂直、水平、两个对角线\n\n非极大值抑制在获得梯度幅度和方向之后，完成图像的全扫描以去除可能不构成边缘的任何不需要的像素.为此，在每个像素处，检查像素是否是其在梯度方向上的邻域中的局部最大值.A点位于边缘（垂直方向），梯度方向与边缘垂直. B点和C点处于梯度方向。 因此，用点B和C检查点A，看它是否形成局部最大值.如果是这样，则考虑下一阶段，否则，它被抑制（置零）.\n\n\n滞后阈值 这个阶段决定哪些边缘是边缘，哪些边缘不是边缘. 为此，我们需要两个阈值，minVal和maxVal. 强度梯度大于maxVal的边缘肯定是边缘，而minVal以下的边缘肯定是非边缘的，因此被丢弃. 两者之间的值要判断是否与真正的边界相连，相连就保留，不相连舍弃.\n边缘A高于maxVal，因此被视为“真实边缘”。 虽然边C低于maxVal，但它连接到边A，因此也被视为有效边，我们得到完整的曲线。 但边缘B虽然高于minVal并且与边缘C的区域相同，但它没有连接到任何“真实边缘”，因此被丢弃。 因此，我们必须相应地选择minVal和maxVal才能获得正确的结果\n\n\n我们最终得到的是图像中的强边缘\nOpenCV中的Canny边缘检测\ncv2.Canny(image, threshold1, threshold2[, edges[, apertureSize[, L2gradient]]])\n\nimage:输入图像\nthreshold1和threshold2：minVal和maxVal\napertureSize：用于查找图像渐变的Sobel内核的大小，3（默认）\nL2gradient：指定用于查找梯度幅度的等式，如果它是True，它使用上面提到的更准确的等式，否则它=False（默认）使用：\n\n$$Edge\\_Gradient \\; (G) = |G_x| + |G_y|$$\n代码：\nimport cv2\nfrom matplotlib import pyplot as plt\n\nimg = cv2.imread('img.jpg',0)\n\nedges = cv2.Canny(img,100,200)\n\nplt.subplot(121),plt.imshow(img,cmap = 'gray')\nplt.title('Original Image'), plt.xticks([]), plt.yticks([])\nplt.subplot(122),plt.imshow(edges,cmap = 'gray')\nplt.title('Edge Image'), plt.xticks([]), plt.yticks([])\n\nplt.show()\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}