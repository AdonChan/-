{"title": "想将算法进一步开发吗？手把手教你搭建基于CNN模型的Flask Web应用 - 个人文章 ", "index": "cnn,神经网络,http,python", "content": "摘要： 想将算法进一步开发应用产品吗？本文手把手教你搭建基于CNN模型的Flask Web应用，算是抛砖引玉了。感兴趣的读者可以将自己的算法开发成其他类型的应用产品，说不定下一个人工智能创业公司Boss就是你哦！\n对于机器学习和人工智能研究人员而言，好多人都只是构建好模型后就没有进一步处理了，停留在一个比较粗糙的模型上面，没有将其变成一个产品，其实好多创业型人工智能公司都是设计好模型后，将其转化成产品，之后再推向市场。每一个深度学习研究者心中或多或少都想成为一名创业者，但不知道超哪个方向发展。那么，本文将从最简单的网页应用开始，一步一步带领你使用TensorFlow创建一个卷积神经网络（CNN）模型后，使用Flash RESTful API将模型变成一个网页应用产品。\n   本文使用TensorFlow NN模块构建CNN模型，并在CIFAR-10数据集上进行训练和测试。为了使模型可以远程访问，使用Python创建Flask web应用来接收上传的图像，并使用HTTP返回其分类标签。\n\n1.安装Python、TensorFlow、PyCharm和Flask API\n孔子云：工欲善其事，比先利其器。程序员亦如此，在进行开发前，需要准备好开发环境并基本掌握开发工具。Python是第一个需要安装的工具，因为整个环境都依赖于它。如果你已经配置好了开发环境，那么可以跳过第一步。\n1.1 安装Anaconda/Python虽然可以安装传统的方法安装Python，但是建议使用类似于Anaconda这样完整的包，因为里面已经安装了一些好的库可供你直接调用。本文中使用的是Anaconda3版本，对于Windows系统，可以从该网站下载并安装。\n为了确保Anaconda3是否安装成功，在CMD命令行中输入（where Python），如果结果类似于下图，则表明安装成功。\n\n1.2 安装TensorFlow在上一步Anaconda3安装完毕后，接下来是安装TensorFlow（TF）。本文使用的是Windows系统下CPU版本的TF，安装指导可以见此链接。TF的安装步骤如下：\n1）使用下面代码创建conda环境：\nC:> conda create -n tensorflow pip python=3.5\n这为TF安装创建了一个空的文件以保持虚拟环境（virtual environment, venv），vevn的位置在Anaconda3安装的目录文件下：（Anaconda3envstensorflow）。\n2）使用下行命令激活venv\nC:> activate tensorflow\n上行命令告诉我们venv和所需安装的所有库，输入这行命令后，命令行将变(tensorflow)C:>，接下来是安装TensorFlow包。\n3）在激活venv后，Window下CPU版本的TensorFlow可以直接使用pip安装：代码\n为了测试TF是否安装成功，可以导入TensorFlow，若结果与下图一样，则表明安装成功。但是在导入TF之前，请确保venv被激活。\n1.3安装PyCharm Python IDE\n相较于在CMD命令行中输入代码，本文更倾向于使用Python IDE。本文选择PyCharm，Windows版本的下载链接在此。此外，下载安装完毕后，需要设置Python编译器，操作如下图所示，选择之前安装的Python.exe作为IDE的编译器。\n加粗文字\n1.4 安装Flask\n最后的一个工具是安装Flask RESTful API，安装命令如下：\nC:> pip install Flask-API\n在全部安装完毕后，接下来要开始新建工程了。\n2.下载并预处理CIFAR-10数据集\nCIFAR-10数据集可以在此下载，该数据集包含60,000张图像，并将其划分为训练集和测试集。其中训练集有5个文件夹，分别命名为data_batch_1、data_batch_2...,data_batch_5，每个文件夹中包含10,000张，每张都是32x32x3的RGB图像。测试集只有一个文件夹，命名为batches.meta，包含10,000张图像。训练集和测试集中包含的图像类别为飞机（airplane）、手机（automobile）、鸟（bird）、猫（cat）、鹿（deer）、狗（dog）、青蛙（frog）、马（horse）、船（ship）以及truck（卡车）。\n由于数据集中的每个文件都是二进制文件，因此应该对其进行解码以检索实际的图像数据。基于此，创建unpickle_patch函数来执行如下操作：\ndef unpickle_patch(file):\n\n    \"\"\"\n    Decoding the binary file.\n    :param file:File to decode it data.\n    :return:Dictionary of the file holding details including input data and output labels.\n    \"\"\"\n    patch_bin_file = open(file, 'rb')#Reading the binary file.\n    patch_dict = pickle.load(patch_bin_file, encoding='bytes')#Loading the details of the binary file into a dictionary.\n    return patch_dict#Returning the dictionary.\n该方法接收二进制文件并返回一个包含有关此文件详细信息的字典。该字典除了标签之外还包含文件中所有的10,000个样本的数据。\n为了解码整个训练集，创建get_dataset_images函数。该函数接收数据集路径并仅对训练数据起作用。因此，它会过滤一些文件并只返回以data_batch_开头的文件。测试数据在模型训练好后再进行处理。\n对于每一个训练文件夹，使用unpickle_patch函数解码，该函数输出一个字典。之后使用get_dataset_image函数获取图像数据以及其对应的类别标签。图像数据是从“data”键中检索，类别标签从“labels”键中检索。\n由于数据图形是以一维向量的形式保存，此外TensorFlow接收的是三维形式，因此应对其进行变换处理。基于此，get_dataset_images函数接收的参数为图像的文件路径、行/列数以及图像的通道数。\ndef get_dataset_images(dataset_path, im_dim=32, num_channels=3):\n\n    \"\"\"\n    This function accepts the dataset path, reads the data, and returns it after being reshaped to match the requierments of the CNN.\n    :param dataset_path:Path of the CIFAR10 dataset binary files.\n    :param im_dim:Number of rows and columns in each image. The image is expected to be rectangular.\n    :param num_channels:Number of color channels in the image.\n    :return:Returns the input data after being reshaped and output labels.\n    \"\"\"\n    num_files = 5#Number of training binary files in the CIFAR10 dataset.\n    images_per_file = 10000#Number of samples withing each binary file.\n    files_names = os.listdir(patches_dir)#Listing the binary files in the dataset path.\n    \"\"\"\n    Creating an empty array to hold the entire training data after being reshaped.\n    The dataset has 5 binary files holding the data. Each binary file has 10,000 samples. Total number of samples in the dataset is 5*10,000=50,000.\n    Each sample has a total of 3,072 pixels. These pixels are reshaped to form a RGB image of shape 32x32x3.\n    Finally, the entire dataset has 50,000 samples and each sample of shape 32x32x3 (50,000x32x32x3).\n    \"\"\"\n    dataset_array = numpy.zeros(shape=(num_files * images_per_file, im_dim, im_dim, num_channels))\n    #Creating an empty array to hold the labels of each input sample. Its size is 50,000 to hold the label of each sample in the dataset.\n    dataset_labels = numpy.zeros(shape=(num_files * images_per_file), dtype=numpy.uint8)\n    index = 0#Index variable to count number of training binary files being processed.\n    for file_name in files_names:\n        \"\"\"\n        Because the CIFAR10 directory does not only contain the desired training files and has some  other files, it is required to filter the required files.\n        Training files start by 'data_batch_' which is used to test whether the file is for training or not.\n        \"\"\"\n        if file_name[0:len(file_name) - 1] == \"data_batch_\":\n            print(\"Working on : \", file_name)\n            \"\"\"\n            Appending the path of the binary files to the name of the current file.\n            Then the complete path of the binary file is used to decoded the file and return the actual pixels values.\n            \"\"\"\n            data_dict = unpickle_patch(dataset_path+file_name)\n            \"\"\"\n            Returning the data using its key 'data' in the dictionary.\n            Character b is used before the key to tell it is binary string.\n            \"\"\"\n            images_data = data_dict[b\"data\"]\n            #Reshaping all samples in the current binary file to be of 32x32x3 shape.\n            images_data_reshaped = numpy.reshape(images_data, newshape=(len(images_data), im_dim, im_dim, num_channels))\n            #Appending the data of the current file after being reshaped.\n            dataset_array[index * images_per_file:(index + 1) * images_per_file, :, :, :] = images_data_reshaped\n            #Appening the labels of the current file.\n            dataset_labels[index * images_per_file:(index + 1) * images_per_file] = data_dict[b\"labels\"]\n            index = index + 1#Incrementing the counter of the processed training files by 1 to accept new file.\n    return dataset_array, dataset_labels#Returning the training input data and output labels.\n\n处理好训练集后，下一步构建CNN模型并进行训练。\n3.使用TensorFlow构建CNN模型\n使用creat_CNN函数创建CNN模型，该函数创建卷积层（conv）、ReLU激活函数、最大池化（max pooling）、dropout以及全连接层（full connection,FC），最后一层全连接层输出结果。每一层的输出都是下一层的输入，这就要求相邻两层之间的特征图尺寸大小要一致。此外，对于每个conv、ReLU以及最大池化层等，都有一些超参数需要设置，比如卷积或池化时候设置的步长等。\ndef create_CNN(input_data, num_classes, keep_prop):\n\n    \"\"\"\n    Builds the CNN architecture by stacking conv, relu, pool, dropout, and fully connected layers.\n    :param input_data:patch data to be processed.\n    :param num_classes:Number of classes in the dataset. It helps determining the number of outputs in the last fully connected layer.\n    :param keep_prop:probability of dropping neurons in the dropout layer.\n    :return: last fully connected layer.\n    \"\"\"\n    #Preparing the first convolution layer.\n    filters1, conv_layer1 = create_conv_layer(input_data=input_data, filter_size=5, num_filters=4)\n    \"\"\"\n    Applying ReLU activation function over the conv layer output. \n    It returns a new array of the same shape as the input array.\n    \"\"\"\n    relu_layer1 = tensorflow.nn.relu(conv_layer1)\n    print(\"Size of relu1 result : \", relu_layer1.shape)\n    \"\"\"\n    Max pooling is applied to the ReLU layer result to achieve translation invariance.\n    It returns a new array of a different shape from the the input array relative to the strides and kernel size used.\n    \"\"\"\n    max_pooling_layer1 = tensorflow.nn.max_pool(value=relu_layer1,\n                                                ksize=[1, 2, 2, 1],\n                                                strides=[1, 1, 1, 1],\n                                                padding=\"VALID\")\n    print(\"Size of maxpool1 result : \", max_pooling_layer1.shape)\n\n    #Similar to the previous conv-relu-pool layers, new layers are just stacked to complete the CNN architecture.\n    #Conv layer with 3 filters and each filter is of sisze of 5x5.\n    filters2, conv_layer2 = create_conv_layer(input_data=max_pooling_layer1, filter_size=7, num_filters=3)\n    relu_layer2 = tensorflow.nn.relu(conv_layer2)\n    print(\"Size of relu2 result : \", relu_layer2.shape)\n    max_pooling_layer2 = tensorflow.nn.max_pool(value=relu_layer2,\n                                                ksize=[1, 2, 2, 1],\n                                                strides=[1, 1, 1, 1],\n                                                padding=\"VALID\")\n    print(\"Size of maxpool2 result : \", max_pooling_layer2.shape)\n\n    #Conv layer with 2 filters and a filter sisze of 5x5.\n    filters3, conv_layer3 = create_conv_layer(input_data=max_pooling_layer2, filter_size=5, num_filters=2)\n    relu_layer3 = tensorflow.nn.relu(conv_layer3)\n    print(\"Size of relu3 result : \", relu_layer3.shape)\n    max_pooling_layer3 = tensorflow.nn.max_pool(value=relu_layer3,\n                                                ksize=[1, 2, 2, 1],\n                                                strides=[1, 1, 1, 1],\n                                                padding=\"VALID\")\n    print(\"Size of maxpool3 result : \", max_pooling_layer3.shape)\n\n    #Adding dropout layer before the fully connected layers to avoid overfitting.\n    flattened_layer = dropout_flatten_layer(previous_layer=max_pooling_layer3, keep_prop=keep_prop)\n\n    #First fully connected (FC) layer. It accepts the result of the dropout layer after being flattened (1D).\n    fc_resultl = fc_layer(flattened_layer=flattened_layer, num_inputs=flattened_layer.get_shape()[1:].num_elements(),\n                          num_outputs=200)\n    #Second fully connected layer accepting the output of the previous fully connected layer. Number of outputs is equal to the number of dataset classes.\n    fc_result2 = fc_layer(flattened_layer=fc_resultl, num_inputs=fc_resultl.get_shape()[1:].num_elements(),\n                          num_outputs=num_classes)\n    print(\"Fully connected layer results : \", fc_result2)\n    return fc_result2#Returning the result of the last FC layer.\n   由于卷积层将输入数据与设置的卷积核进行卷积运算，因此create_CNN函数将输入数据作为输入参数，这些数据是由get_dataset_images函数返回的数据。create_conv_layer函数接收输入数据、过滤器大小和过滤器数量，并返回输入数据与过滤器集合进行卷积的结果。这组滤波器的大小根据输入图像的深度而设置。 create_conv_layer的定义如下：\n\ndef create_conv_layer(input_data, filter_size, num_filters):\n\"\"\"\nBuilds the CNN convolution (conv) layer.\n:param input_data:patch data to be processed.\n:param filter_size:#Number of rows and columns of each filter. It is expected to have a rectangular filter.\n:param num_filters:Number of filters.\n:return:The last fully connected layer of the network.\n\"\"\"\n\"\"\"\nPreparing the filters of the conv layer by specifiying its shape. \nNumber of channels in both input image and each filter must match.\nBecause number of channels is specified in the shape of the input image as the last value, index of -1 works fine.\n\"\"\"\nfilters = tensorflow.Variable(tensorflow.truncated_normal(shape=(filter_size, filter_size, tensorflow.cast(input_data.shape[-1], dtype=tensorflow.int32), num_filters),\n                                                          stddev=0.05))\nprint(\"Size of conv filters bank : \", filters.shape)\n\n\"\"\"\nBuilding the convolution layer by specifying the input data, filters, strides along each of the 4 dimensions, and the padding.\nPadding value of 'VALID' means the some borders of the input image will be lost in the result based on the filter size.\n\"\"\"\nconv_layer = tensorflow.nn.conv2d(input=input_data,\n                                  filter=filters,\n                                  strides=[1, 1, 1, 1],\n                                  padding=\"VALID\")\nprint(\"Size of conv result : \", conv_layer.shape)\nreturn filters, conv_layer#Returing the filters and the convolution layer result.\n   对于dropout层，接收一个保持神经元的概率参数，它表明会有多少神经元在dropout层被丢弃。 dropout层是使用dropout_flatten_layer函数实现，如下所示：\n\nef dropout_flatten_layer(previous_layer, keep_prop):\n\"\"\"\nApplying the dropout layer.\n:param previous_layer: Result of the previous layer to the dropout layer.\n:param keep_prop: Probability of keeping neurons.\n:return: flattened array.\n\"\"\"\ndropout = tensorflow.nn.dropout(x=previous_layer, keep_prob=keep_prop)\nnum_features = dropout.get_shape()[1:].num_elements()\nlayer = tensorflow.reshape(previous_layer, shape=(-1, num_features))#Flattening the results.\nreturn layer\n\n由于最后一个FC层的输出神经元数应等于数据集类别数量，因此数据集类的数量将用作create_CNN函数的另一个输入参数。全连接层是使用fc_layer函数创建，该函数接收dropout层输出结果，输出结果中的特征数量以及来自此FC层的输出神经元的数量。根据输入和输出的数量，创建一个权重张量，然后乘以flattened_layer得到FC层的返回结果。\ndef fc_layer(flattened_layer, num_inputs, num_outputs):\n\n    \"\"\"\n    uilds a fully connected (FC) layer.\n    :param flattened_layer: Previous layer after being flattened.\n    :param num_inputs: Number of inputs in the previous layer.\n    :param num_outputs: Number of outputs to be returned in such FC layer.\n    :return:\n    \"\"\"\n    #Preparing the set of weights for the FC layer. It depends on the number of inputs and number of outputs.\n    fc_weights = tensorflow.Variable(tensorflow.truncated_normal(shape=(num_inputs, num_outputs),\n                                                              stddev=0.05))\n    #Matrix multiplication between the flattened array and the set of weights.\n    fc_resultl = tensorflow.matmul(flattened_layer, fc_weights)\n    return fc_resultl#Output of the FC layer (result of matrix multiplication).\n使用TensorBoard可以可视化网络模型结构，如下图所示：\n\n4.训练CNN模型\n在构建好CNN模型之后，下一步就是使用之前处理的训练数据进行模型训练，代码如下所示。代码首先准备训练数据的路径，然后调用之前的讨论过的函数，训练的CNN使用梯度下降算法，优化方式是尽可能最小化代价函数。\n#Nnumber of classes in the dataset. Used to specify number of outputs in the last fully connected layer.\nnum_datatset_classes = 10\n#Number of rows & columns in each input image. The image is expected to be rectangular Used to reshape the images and specify the input tensor shape.\nim_dim = 32\n#Number of channels in rach input image. Used to reshape the images and specify the input tensor shape.\nnum_channels = 3\n\n#Directory at which the training binary files of the CIFAR10 dataset are saved.\npatches_dir = \"C:\\\\Users\\\\Dell\\\\Downloads\\\\Compressed\\\\cifar-10-python\\\\cifar-10-batches-py\\\\\"\n#Reading the CIFAR10 training binary files and returning the input data and output labels. Output labels are used to test the CNN prediction accuracy.\ndataset_array, dataset_labels = get_dataset_images(dataset_path=patches_dir, im_dim=im_dim, num_channels=num_channels)\nprint(\"Size of data : \", dataset_array.shape)\n\n\"\"\"\nInput tensor to hold the data read above. It is the entry point of the computational graph.\nThe given name of 'data_tensor' is useful for retreiving it when restoring the trained model graph for testing.\n\"\"\"\ndata_tensor = tensorflow.placeholder(tensorflow.float32, shape=[None, im_dim, im_dim, num_channels], name='data_tensor')\n\n\"\"\"\nTensor to hold the outputs label. \nThe name \"label_tensor\" is used for accessing the tensor when tesing the saved trained model after being restored.\n\"\"\"\nlabel_tensor = tensorflow.placeholder(tensorflow.float32, shape=[None], name='label_tensor')\n\n#The probability of dropping neurons in the dropout layer. It is given a name for accessing it later.\nkeep_prop = tensorflow.Variable(initial_value=0.5, name=\"keep_prop\")\n\n#Building the CNN architecure and returning the last layer which is the fully connected layer.\nfc_result2 = create_CNN(input_data=data_tensor, num_classes=num_datatset_classes, keep_prop=keep_prop)\n\n\"\"\"\nPredicitions probabilities of the CNN for each training sample.\nEach sample has a probability for each of the 10 classes in the dataset.\nSuch tensor is given a name for accessing it later.\n\"\"\"\nsoftmax_propabilities = tensorflow.nn.softmax(fc_result2, name=\"softmax_probs\")\n\n\"\"\"\nPredicitions labels of the CNN for each training sample.\nThe input sample is classified as the class of the highest probability.\naxis=1 indicates that maximum of values in the second axis is to be returned. This returns that maximum class probability fo each sample.\n\"\"\"\nsoftmax_predictions = tensorflow.argmax(softmax_propabilities, axis=1)\n\n#Cross entropy of the CNN based on its calculated probabilities.\ncross_entropy = tensorflow.nn.softmax_cross_entropy_with_logits(logits=tensorflow.reduce_max(input_tensor=softmax_propabilities, reduction_indices=[1]),\n                                                                labels=label_tensor)\n#Summarizing the cross entropy into a single value (cost) to be minimized by the learning algorithm.\ncost = tensorflow.reduce_mean(cross_entropy)\n#Minimizng the network cost using the Gradient Descent optimizer with a learning rate is 0.01.\nerror = tensorflow.train.GradientDescentOptimizer(learning_rate=.01).minimize(cost)\n\n#Creating a new TensorFlow Session to process the computational graph.\nsess = tensorflow.Session()\n#Wiriting summary of the graph to visualize it using TensorBoard.\ntensorflow.summary.FileWriter(logdir=\"./log/\", graph=sess.graph)\n#Initializing the variables of the graph.\nsess.run(tensorflow.global_variables_initializer())\n\n\"\"\"\nBecause it may be impossible to feed the complete data to the CNN on normal machines, it is recommended to split the data into a number of patches.\nA percent of traning samples is used to create each path. Samples for each path can be randomly selected.\n\"\"\"\nnum_patches = 5#Number of patches\nfor patch_num in numpy.arange(num_patches):\n    print(\"Patch : \", str(patch_num))\n    percent = 80 #percent of samples to be included in each path.\n    #Getting the input-output data of the current path.\n    shuffled_data, shuffled_labels = get_patch(data=dataset_array, labels=dataset_labels, percent=percent)\n    #Data required for cnn operation. 1)Input Images, 2)Output Labels, and 3)Dropout probability\n    cnn_feed_dict = {data_tensor: shuffled_data,\n                     label_tensor: shuffled_labels,\n                     keep_prop: 0.5}\n    \"\"\"\n    Training the CNN based on the current patch. \n    CNN error is used as input in the run to minimize it.\n    SoftMax predictions are returned to compute the classification accuracy.\n    \"\"\"\n    softmax_predictions_, _ = sess.run([softmax_predictions, error], feed_dict=cnn_feed_dict)\n    #Calculating number of correctly classified samples.\n    correct = numpy.array(numpy.where(softmax_predictions_ == shuffled_labels))\n    correct = correct.size\n    print(\"Correct predictions/\", str(percent * 50000/100), ' : ', correct)\n\n与其将整个数据集一下子送入网络中去，不如将数据分为一批数据块（patch），将数据块分批次送入网络之中形成一个循环。每个数据块都包含训练数据的子集，这些数据块使用get_patch函数返回，该函数接收的参数为输入数据、标签以及返回的百分数，函数根据百分数划分子集。\ndef get_patch(data, labels, percent=70):\n\n    \"\"\"\n    Returning patch to train the CNN.\n    :param data: Complete input data after being encoded and reshaped.\n    :param labels: Labels of the entire dataset.\n    :param percent: Percent of samples to get returned in each patch.\n    :return: Subset of the data (patch) to train the CNN model.\n    \"\"\"\n    #Using the percent of samples per patch to return the actual number of samples to get returned.\n    num_elements = numpy.uint32(percent*data.shape[0]/100)\n    shuffled_labels = labels#Temporary variable to hold the data after being shuffled.\n    numpy.random.shuffle(shuffled_labels)#Randomly reordering the labels.\n    \"\"\"\n    The previously specified percent of the data is returned starting from the beginning until meeting the required number of samples. \n    The lab`els` indices are also used to return their corresponding input images samples.\n    \"\"\"\n    return data[shuffled_labels[:num_elements], :, :, :], shuffled_labels[:num_elements]\n\n5.保存训练好的CNN模型\n在训练好CNN模型之后，需要保存训练好的参数以便测试时使用，保存路径由你指定，代码如下：\n#Saving the model after being trained.\nsaver = tensorflow.train.Saver()\nsave_model_path = \"C:\\\\model\\\\\"\nsave_path = saver.save(sess=sess, save_path=save_model_path+\"model.ckpt\")\nprint(\"Model saved in : \", save_path)\n\n6.准备测试数据并加载训练好的CNN模型\n在测试之前，需要准备测试数据并恢复以前的训练模型。测试数据准备与训练数据准备的情况类似，不同的是只有一个二进制文件需要解码，根据修改后的get_dataset_images函数对测试文件进行解码，该函数完全按照训练数据所做的那样调用unpickle_patch函数：\ndef get_dataset_images(test_path_path, im_dim=32, num_channels=3):\n\n    \"\"\"\n    Similar to the one used in training except that there is just a single testing binary file for testing the CIFAR10 trained models.\n    \"\"\"\n    print(\"Working on testing patch\")\n    data_dict = unpickle_patch(test_path_path)\n    images_data = data_dict[b\"data\"]\n    dataset_array = numpy.reshape(images_data, newshape=(len(images_data), im_dim, im_dim, num_channels))\n    return dataset_array, data_dict[b\"labels\"]\n\n7.测试CNN模型\n准备好测试数据并恢复训练好的模型后，可以按照以下代码开始测试模型。值得一提的是，目标是仅返回输入样本的网络预测结果，这也是TF会话运行只返回预测的原因。此外，与训练CNN时会话将尽可能降低代价不同的是，在测试中并不想将成本降到最低，而是关注于预测精度。另一个有趣的地方是，dropout层的概率设置为1，即不丢弃任何节点。\n#Dataset path containing the testing binary file to be decoded.\npatches_dir = \"C:\\\\Users\\\\Dell\\\\Downloads\\\\Compressed\\\\cifar-10-python\\\\cifar-10-batches-py\\\\\"\ndataset_array, dataset_labels = get_dataset_images(test_path_path=patches_dir + \"test_batch\", im_dim=32, num_channels=3)\nprint(\"Size of data : \", dataset_array.shape)\n\nsess = tensorflow.Session()\n\n#Restoring the previously saved trained model.\nsaved_model_path = 'C:\\\\Users\\\\Dell\\\\Desktop\\\\model\\\\'\nsaver = tensorflow.train.import_meta_graph(saved_model_path+'model.ckpt.meta')\nsaver.restore(sess=sess, save_path=saved_model_path+'model.ckpt')\n\n#Initalizing the varaibales.\nsess.run(tensorflow.global_variables_initializer())\n\ngraph = tensorflow.get_default_graph()\n\n\"\"\"\nRestoring previous created tensors in the training phase based on their given tensor names in the training phase.\nSome of such tensors will be assigned the testing input data and their outcomes (data_tensor, label_tensor, and keep_prop).\nOthers are helpful in assessing the model prediction accuracy (softmax_propabilities and softmax_predictions).\n\"\"\"\nsoftmax_propabilities = graph.get_tensor_by_name(name=\"softmax_probs:0\")\nsoftmax_predictions = tensorflow.argmax(softmax_propabilities, axis=1)\ndata_tensor = graph.get_tensor_by_name(name=\"data_tensor:0\")\nlabel_tensor = graph.get_tensor_by_name(name=\"label_tensor:0\")\nkeep_prop = graph.get_tensor_by_name(name=\"keep_prop:0\")\n\n#keep_prop is equal to 1 because there is no more interest to remove neurons in the testing phase.\nfeed_dict_testing = {data_tensor: dataset_array,\n                     label_tensor: dataset_labels,\n                     keep_prop: 1.0}\n#Running the session to predict the outcomes of the testing samples.\nsoftmax_propabilities_, softmax_predictions_ = sess.run([softmax_propabilities, softmax_predictions],\n                                                      feed_dict=feed_dict_testing)\n#Assessing the model accuracy by counting number of correctly classified samples.\ncorrect = numpy.array(numpy.where(softmax_predictions_ == dataset_labels))\ncorrect = correct.size\nprint(\"Correct predictions/10,000 : \", correct)\n\n8.构建Flask web应用\n在训练好CNN模型后，将它加入到HTTP服务器中，并允许用户在线使用。使用者将使用HTTP客户端上传一张图像，该图像之后会被HTTP服务器（Flask web应用）接收，该应用将基于训练好的CNN模型预测该图像的类别，并最终将类别返还给HTTP客户端。整个过程如下图所示：\n\nimport flask\n#Creating a new Flask Web application. It accepts the package name.\napp = flask.Flask(\"CIFAR10_Flask_Web_App\")\n\n\"\"\"\nTo activate the Web server to receive requests, the application must run.\nA good practice is to check whether the file is whether the file called from an external Python file or not.\nIf not, then it will run.\n\"\"\"\nif __name__ == \"__main__\":\n    \"\"\"\n    In this example, the app will run based on the following properties:\n    host: localhost\n    port: 7777\n    debug: flag set to True to return debugging information.\n    \"\"\"\n    app.run(host=\"localhost\", port=7777, debug=True)\n目前，服务器没有提供任何功能。服务器应该做的第一件事是允许用户上传图像，当用户访问该应用程序的根URL时，该应用程序不会执行任何操作。应用程序可以将用户重定向到用户可以上传图像的HTML页面。为此，该应用程序有一个redirect_upload的函数，可将用户重定向到用于上传图像的页面，让用户在访问应用程序根目录后执行此函数能的是使用以下行创建的路由：\napp.add_url_rule(rule=\"/\", endpoint=\"homepage\", view_func=redirect_upload)\n上行代码表示：如果用户访问应用程序的根目录（标记为“/”），则将调用查看函数（redirect_upload）。除了渲染upload_image.html的HTML页面之外，这个函数什么也不做，此页面位于服务器的特殊模板目录下。模板目录内的页面通过调用render_template函数来呈现。\ndef redirect_upload():\n\n    \"\"\"\n    A viewer function that redirects the Web application from the root to a HTML page for uploading an image to get classified.\n    The HTML page is located under the /templates directory of the application.\n    :return: HTML page used for uploading an image. It is 'upload_image.html' in this exmaple.\n    \"\"\"\n    return flask.render_template(template_name_or_list=\"upload_image.html\")\n\"\"\"\nCreating a route between the homepage URL (http://localhost:7777) to a viewer function that is called after getting to such URL. \nEndpoint 'homepage' is used to make the route reusable without hard-coding it later.\n\"\"\"\napp.add_url_rule(rule=\"/\", endpoint=\"homepage\", view_func=redirect_upload)\nHTML页面的屏幕显示如下图所示：\n\n以下代码是上图页面的HTML代码，实现的功能也很简单，允许用户上传一张图像，当提交此类表单时，POST HTTP消息将被返回给URL：http://localhost:7777/upload/\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"{{url_for(endpoint='static', filename='project_styles.css')}}\">\n    <meta charset=\"UTF-8\">\n    <title>Upload Image</title>\n</head>\n<body>\n<form enctype=\"multipart/form-data\" method=\"post\" action=\"http://localhost:7777/upload/\">\n    <center>\n    <h3>Select CIFAR10 image to predict its label.</h3>\n    <input type=\"file\" name=\"image_file\" accept=\"image/*\"><br>\n    <input type=\"submit\" value=\"Upload\">\n    </center>\n</form>\n</body>\n</html>\n在从HTML表单返回到服务器之后，将调用与action表单属性中指定URL关联的查看函数upload_image，该函数获取用户选择的图像并将其保存到服务器。\ndef upload_image():\n\n    \"\"\"\n    Viewer function that is called in response to getting to the 'http://localhost:7777/upload' URL.\n    It uploads the selected image to the server.\n    :return: redirects the application to a new page for predicting the class of the image.\n    \"\"\"\n    #Global variable to hold the name of the image file for reuse later in prediction by the 'CNN_predict' viewer functions.\n    global secure_filename\n    if flask.request.method == \"POST\":#Checking of the HTTP method initiating the request is POST.\n        img_file = flask.request.files[\"image_file\"]#Getting the file name to get uploaded.\n        secure_filename = werkzeug.secure_filename(img_file.filename)#Getting a secure file name. It is a good practice to use it.\n        img_path = os.path.join(app.root_path, secure_filename)#Preparing the full path under which the image will get saved.\n        img_file.save(img_path)#Saving the image in the specified path.\n        print(\"Image uploaded successfully.\")\n        \"\"\"\n        After uploading the image file successfully, next is to predict the class label of it.\n        The application will fetch the URL that is tied to the HTML page responsible for prediction and redirects the browser to it.\n        The URL is fetched using the endpoint 'predict'.\n        \"\"\"\n        return flask.redirect(flask.url_for(endpoint=\"predict\"))\n    return \"Image upload failed.\"\n\"\"\"\nCreating a route between the URL (http://localhost:7777/upload) to a viewer function that is called after navigating to such URL. \nEndpoint 'upload' is used to make the route reusable without hard-coding it later.\nThe set of HTTP method the viewer function is to respond to is added using the 'methods' argument.\nIn this case, the function will just respond to requests of method of type POST.\n\"\"\"\napp.add_url_rule(rule=\"/upload/\", endpoint=\"upload\", view_func=upload_image, methods=[\"POST\"])\n将图像成功上传到服务器后，已准备好读取图像并使用之前训练过的CNN模型预测其类别标签。基于此，upload_image函数将应用程序重定向到负责预测图像类标签的查看器函数。这个查看器功能是通过它的端点（endpoint）来达到的，如下行所指定的：\nreturn flask.redirect(flask.url_for(endpoint=\"predict\"))\n\n负责预测图像类别标签的函数CNN_predict定义如下：\ndef CNN_predict():\n\n    \"\"\"\n    Reads the uploaded image file and predicts its label using the saved pre-trained CNN model.\n    :return: Either an error if the image is not for CIFAR10 dataset or redirects the browser to a new page to show the prediction result if no error occurred.\n    \"\"\"\n    \"\"\"\n    Setting the previously created 'secure_filename' to global.\n    This is because to be able invoke a global variable created in another function, it must be defined global in the caller function.\n    \"\"\"\n    global secure_filename\n    #Reading the image file from the path it was saved in previously.\n    img = scipy.misc.imread(os.path.join(app.root_path, secure_filename))\n\n    \"\"\"\n    Checking whether the image dimensions match the CIFAR10 specifications.\n    CIFAR10 images are RGB (i.e. they have 3 dimensions). It number of dimenions was not equal to 3, then a message will be returned.\n    \"\"\"\n    if(img.ndim) == 3:\n        \"\"\"\n        Checking if the number of rows and columns of the read image matched CIFAR10 (32 rows and 32 columns).\n        \"\"\"\n        if img.shape[0] == img.shape[1] and img.shape[0] == 32:\n            \"\"\"\n            Checking whether the last dimension of the image has just 3 channels (Red, Green, and Blue).\n            \"\"\"\n            if img.shape[-1] == 3:\n                \"\"\"\n                Passing all conditions above, the image is proved to be of CIFAR10.\n                This is why it is passed to the predictor.\n                \"\"\"\n                predicted_class = CIFAR10_CNN_Predict_Image.main(img)\n                \"\"\"\n                After predicting the class label of the input image, the prediction label is rendered on an HTML page.\n                The HTML page is fetched from the /templates directory. The HTML page accepts an input which is the predicted class.\n                \"\"\"\n                return flask.render_template(template_name_or_list=\"prediction_result.html\", predicted_class=predicted_class)\n            else:\n                # If the image dimensions do not match the CIFAR10 specifications, then an HTML page is rendered to show the problem.\n                return flask.render_template(template_name_or_list=\"error.html\", img_shape=img.shape)\n        else:\n            # If the image dimensions do not match the CIFAR10 specifications, then an HTML page is rendered to show the problem.\n            return flask.render_template(template_name_or_list=\"error.html\", img_shape=img.shape)\n    return \"An error occurred.\"#Returned if there is a different error other than wrong image dimensions.\n\"\"\"\nCreating a route between the URL (http://localhost:7777/predict) to a viewer function that is called after navigating to such URL. \nEndpoint 'predict' is used to make the route reusable without hard-coding it later.\n\"\"\"\napp.add_url_rule(rule=\"/predict/\", endpoint=\"predict\", view_func=CNN_predict)\n负责预测图像类别标签的主函数定义如下，它加载训练好的模型并运行会话，返回图像的预测类别，预测的类别将返回到Flask Web应用程序。\ndef main(img):\n\n    \"\"\"\n    The 'main' method accepts an input image array of size 32x32x3 and returns its class label.\n    :param img:RGB image of size 32x32x3.\n    :return:Predicted class label.\n    \"\"\"\n    #Dataset path containing a binary file with the labels of classes. Useful to decode the prediction code into a significant textual label.\n    patches_dir = \"C:\\\\cifar-10-python\\\\cifar-10-batches-py\\\\\"\n    dataset_array = numpy.random.rand(1, 32, 32, 3)\n    dataset_array[0, :, :, :] = img\n\n    sess = tensorflow.Session()\n\n    #Restoring the previously saved trained model.\n    saved_model_path = 'C:\\\\model\\\\'\n    saver = tensorflow.train.import_meta_graph(saved_model_path+'model.ckpt.meta')\n    saver.restore(sess=sess, save_path=saved_model_path+'model.ckpt')\n\n    #Initalizing the varaibales.\n    sess.run(tensorflow.global_variables_initializer())\n\n    graph = tensorflow.get_default_graph()\n\n    \"\"\"\n    Restoring previous created tensors in the training phase based on their given tensor names in the training phase.\n    Some of such tensors will be assigned the testing input data and their outcomes (data_tensor, label_tensor, and keep_prop).\n    Others are helpful in assessing the model prediction accuracy (softmax_propabilities and softmax_predictions).\n    \"\"\"\n    softmax_propabilities = graph.get_tensor_by_name(name=\"softmax_probs:0\")\n    softmax_predictions = tensorflow.argmax(softmax_propabilities, axis=1)\n    data_tensor = graph.get_tensor_by_name(name=\"data_tensor:0\")\n    label_tensor = graph.get_tensor_by_name(name=\"label_tensor:0\")\n    keep_prop = graph.get_tensor_by_name(name=\"keep_prop:0\")\n\n    #keep_prop is equal to 1 because there is no more interest to remove neurons in the testing phase.\n    feed_dict_testing = {data_tensor: dataset_array,\n                         keep_prop: 1.0}\n    #Running the session to predict the outcomes of the testing samples.\n    softmax_propabilities_, softmax_predictions_ = sess.run([softmax_propabilities, softmax_predictions],\n                                                          feed_dict=feed_dict_testing)\n    label_names_dict = unpickle_patch(patches_dir + \"batches.meta\")\n    dataset_label_names = label_names_dict[b\"label_names\"]\n    return dataset_label_names[softmax_predictions_[0]].decode('utf-8')\nCNN_predict函数预测图像的返回类标签将按照下图在prediction_result.html的新HTML页面上呈现。\n\n注意到，Flask应用程序使用允许HTML页面接收输入参数的Jinja2模板引擎，在这种情况下传递的输入参数是\npredict_class = predicted_class。\nreturn flask.render_template(template_name_or_list=\"prediction_result.html\", predicted_class=predicted_class)\n该页的HTML代码如下：\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"{{url_for(endpoint='static', filename='project_styles.css')}}\">\n    <script type=\"text/javascript\" src=\"{{url_for(endpoint='static', filename='result.js')}}\"></script>\n    <meta charset=\"UTF-8\">\n    <title>Prediction Result</title>\n</head>\n<body onload=\"show_alert('{{predicted_class}}')\">\n<center><h1>Predicted Class Label : <span>{{predicted_class}}</span></h1>\n    <br>\n    <a href=\"{{url_for(endpoint='homepage')}}\"><span>Return to homepage</span>.</a>\n</center>\n</body>\n</html>\n\n它是一个由预测的图像类填充的模板，该图像作为参数传递给HTML页面，类似于下面的代码：\n<span>{{predicted_class}}</span>\n\n更多关于Flask RESTful API信息可以访问：https://www.tutorialspoint.co...；本文项目的Github链接：https://github.com/ahmedfgad/...；\n作者信息Ahmed Gad，教师，专注于深度学习、机器学习、计算机视觉。\n本文由阿里云云栖社区组织翻译。文章原标题《Complete Guide to Build ConvNet HTTP-Based Application using TensorFlow and Flask RESTful Python API》，译者：海棠，审校：Uncle_LLD。原文链接\n本文为云栖社区原创内容，未经允许不得转载。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}