{"title": "简单字典树实现 - Just For Fun ", "index": "数据结构和算法,python", "content": "原文地址\n字典树介绍\n我们经常会在网上输入一些单词，一般情况下，当我们输入几个字母时，输入框中会自动弹出以这些字母开头的单词供我们选择，用户体验非常好。\n不过这种自动提示功能到底是怎么实现的呢？这就要用到我们的前缀树了，前缀树也叫字典树、Trie树。假如我们有一个简单的字典，里面包含以下几个单词：apps apple cook cookie cold，那么可以构建以下树：  \n\n图1. 简单的字典树\n当我们输入a时，程序会遍历a的子树，找出所有的单词，这里就是apps和apple了。继续输入ppl，那么只用遍历appl下面的子树，然后即得到apple。同理，输入co时，会遍历o下面的子树，取得单词cook, cookie, cold。这里的单词不一定都在叶节点上，像上例中的cook就是在其中一个子节点上。\n从上面的图中，我们可以总结出字典树的一些特征来：\n\n根节点不包含字符，除去根节点的每一个节点均包含有一个字符。\n从根节点到某一节点，路径上经过的所有节点的字符连接起来就是该节点对应的字符串。\n每个节点的所有子节点包含的字符都不相同。\n\n字典树的基本操作\n字典树有三个基本操作：插入，查找，删除：\n\n\n插入操作：向字典树中插入某个单词。将单词标记为当前单词，将根节点标记为当前节点，执行操作1：\n\n当前单词为空，将当前节点标记为单词位置，终止操作；否则取出当前单词的首字符记为X，遍历当前节点的子节点：如果X存在于子节点N，将剩余字符标记为当前单词，将N标记为当前节点，重复操作1，如果X不存在于当前节点的子节点中，那么进入操作2。\n取出当前单词的首字符记为X，新建一个节点M存储X，M的父节点为当前节点。剩余字符串记为当前单词，如果当前单词为空，将M标记为单词位置，终止操作；否则，将M标记为当前节点，重复操作2。\n\n\n\n查找操作：查询指定单词是否在字典树中。将单词标记为当前单词，将根节点标记为当前节点，执行操作1：\n当前单词为空，那么返回true，即字典树中存在该单词。否则，取出当前单词的首字符，标记为X，遍历当前节点的子节点，如果X存在于子节点N中，将N标记为当前节点，将剩余字符串标记为当前单词，重复操作1；如果X不存在于子节点中，返回false，即字典树中不存在该单词。\n\n\n删除操作：删除字典树中的某个单词。将单词标记为当前单词，将根节点标记为当前节点，执行操作1：\n当前单词为空，如果当前节点不为叶子节点，那么取消标记当前节点为单词位置，当前节点为叶子节点，删除该叶子节点即可，然后终止操作。当前单词不为空，取出当前单词的首字符记为X，遍历当前节点的子节点：如果X存在于当前节点的子节点N上，将N标记为当前节点，将剩余字符串记为当前单词，重复过程1；否则删除失败，即单词不在字典树上，终止操作。\n\n\n字典树的简单实现\n插入操作：\ndef insert(word):\n    current_word = word\n    current_node = root\n    insert_operation_1(current_word, current_node)\n\ndef insert_operation_1(current_word, current_node):\n    if current_word not empty:\n        X = current_word[0]\n\n        if X in current_node.child:\n            current_word = current_word[1:]\n            current_node = child_node\n            insert_operation_1(current_word, current_node)\n        else:\n            insert_operation_2(current_word, current_node)\n\n    else:\n        mark current_node insert_node \n\ndef insert_operation_2(current_word, current_node):\n    X = current_word[0]\n    M.value = x\n    M.father = current_node\n    current_node.child = M\n\n    current_word = current_word[1:]\n    if current_word not empty:\n        current_node = M\n        insert_operation_2(current_word, current_node)\n\n    else:\n        mark M insert_node\n\n查找操作：\ndef find(word):\n    current_word = word\n    current_node = root\n    return find_opration(current_word, current_node)\n\ndef find_opration(current_word, current_node):\n    if current_word not empty:\n        X = current_word[0]\n        if X in current_node.child_node:\n            current_word = current_word[1:]\n            current_node = child_node\n            if current_word not empty:\n                return find_opration(current_word, current_node)\n            else:\n                return current_node.isword\n        else:\n            return false\n    else:\n        return true\n\n删除操作：\ndef delete(word):\n    current_word = word\n    current_node = root\n    return delete_operation(current_word, current_node)\n\ndef delete_operation(current_word, current_node):\n    if current_word not empty:\n        X = current_word[0]\n        if X in current_node.child_node:\n            current_word = current_word[1:]\n            current_node = child_node\n            is_deleted = delete_operation(current_word, current_node)\n        else:\n            return false\n    else:\n        if current_node have child_node:\n            mark current_node no_word_node\n        else:\n            delete current_node\n        return true\n\n具体实现放在gist上，可以在这里找到。\n参考\n6天通吃树结构—— 第五天 Trie树  从Trie树（字典树）谈到后缀树  数据结构之Trie树\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "9"}