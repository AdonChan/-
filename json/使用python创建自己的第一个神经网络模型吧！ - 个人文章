{"title": "使用python创建自己的第一个神经网络模型吧！ - 个人文章 ", "index": "random,神经网络,函数,python", "content": "\n摘要： 对神经网络的工作原理感到好奇？动手实践一下吧，了解神经网络是如何工作的最好方法是自己创建一个简单神经网络。\n神经网络（NN），也被称为人工神经网络（ANN），是机器学习领域中学习算法的子集，大体上借鉴了生物神经网络的概念。目前，神经网络在计算机视觉、自然语言处理等领域应用广泛。德国资深机器学习专家Andrey Bulezyuk说到，“神经网络正在彻底改变机器学习，因为它们能够有效地模拟各种学科和行业的复杂抽象，且无需太多人工参与。”大体上，人工神经网络基本包含以下组件：\n\n接收数据并传递数据的输入层（input layer）；\n隐藏层（hidden layer）；\n输出层（output layer）；\n层与层之间的权重（weight）；\n每个隐藏层使用的激活函数（activation function）；\n\n在本文教程中，使用的是简单的Sigmoid激活函数，但注意一点，在深层神经网络模型中， sigmoid激活函数一般不作为首选，原因是其易发生梯度弥散现象。\n此外，人工神经网络有几种不同类型的神经网络，比如前馈神经网络、卷积神经网络及递归神经网络等。本文将以简单的前馈或感知神经网络为例，这种类型的人工神经网络是直接从前到后传递数据的，简称前向传播过程。\n而训练前馈神经元通常需要反向传播算法，这就需要为网络提供相应的输入和输出集。当输入数据被传输到神经元时，它会经过相应的处理，并将产生的输出传输给下一层。下图简单展示了一个神经网络结构：\n\n此外，理解神经网络如何工作的最好方法是学习如何在不使用任何工具箱的前提下从头开始构建一个。在本文中，我们将演示如何使用Python创建一个简单的神经网络。\n问题\n下表显示了我们将解决的问题：\n我们将训练神经网络，以便在提供一组新数据时可以预测出正确的输出值。\n从表中看到，输出的值始终等于输入节中的第一个值。因此，我们可以期望新情形的输出（？）值为1。\n下面让我们看看是否可以使用一些Python代码来得到相同的结果。\n创建神经网络类|NeuralNetwork Class\n我们将在Python中创建一个NeuralNetwork类来训练神经元以提供准确的预测，该类还包含其他辅助函数。我们不会将神经网络库用于创建这个简单的神经网络示例中，但会导入基本的Numpy库来协助计算。\nNumpy库是处理数据的一种基本库，它具有以下四种重要的计算方法：\n\nEXP——用于产生所述自然指数；\narray——用于生成矩阵；\ndot——用于矩阵相乘；\nrandom——用于生成随机数;\n\n应用Sigmoid函数\n我们将使用Sigmoid函数，它绘制出一个“S”形曲线，将其作为本文创建的神经网络的激活函数。\n\n此函数可以将任何值映射到0到1之间，并能帮助我们规范化输入的加权和。\n此后，我们将创建Sigmoid函数的导数，以帮助计算权重的基本调整。\n可以使用Sigmoid函数的输出来生成其导数。例如，如果输出变量是“x”，那么它的导数将是x *(1-x)。\n训练模型\n训练模型意味着我们将教导神经网络进行准确预测的阶段。每个输入都有一个权重（weights）——正或负的，这意味着具有大值正权重或大值负权重的输入将多所得到的输出有更大地影响。\n注意，模型训练最初时，每个权重的初始化都是随机数。以下是本文构建的神经网络示例问题中训练过程：\n\n1.从训练数据集中获取输入，根据它们的权重进行一些调整，并通过计算神经网络输出的方法来一层一层的传输；\n2.计算反向传播的错误率。在这种情况下，它是神经元预测得到的输出与训练数据集的预期输出之间的误差；\n3.根据得到的误差范围，使用误差加权导数公式进行一些小的权重调整；\n4.将此过程重复15,000次，在每次迭代过程中，同时处理整个训练集；\n\n在这里，我们使用“.T”函数对矩阵求偏置。因此，数字将以这种方式存储：\n\n最终，神经元的权重将针对所提供的训练数据进行优化。因此，如果神经网络的输出与期望的输出一致时，说明训练完成，可以进行准确的预测，这就是反向传播的方式。\n封装\n最后，初始化NeuralNetwork类后并运行整个程序，以下是如何在Python项目中创建神经网络的完整代码：\nimport numpy as np\n\nclass NeuralNetwork():\n    \n    def __init__(self):\n        # 设置随机数种子\n        np.random.seed(1)\n        \n        # 将权重转化为一个3x1的矩阵，其值分布为-1~1，并且均值为0\n        self.synaptic_weights = 2 * np.random.random((3, 1)) - 1\n\n    def sigmoid(self, x):\n        # 应用sigmoid激活函数\n        return 1 / (1 + np.exp(-x))\n\n    def sigmoid_derivative(self, x):\n        #计算Sigmoid函数的偏导数\n        return x * (1 - x)\n\n    def train(self, training_inputs, training_outputs, training_iterations):\n        \n        # 训练模型\n        for iteration in range(training_iterations):\n            # 得到输出\n            output = self.think(training_inputs)\n\n            # 计算误差\n            error = training_outputs - output\n            \n            # 微调权重\n            adjustments = np.dot(training_inputs.T, error * self.sigmoid_derivative(output))\n\n            self.synaptic_weights += adjustments\n\n    def think(self, inputs):\n        # 输入通过网络得到输出   \n        # 转化为浮点型数据类型\n        \n        inputs = inputs.astype(float)\n        output = self.sigmoid(np.dot(inputs, self.synaptic_weights))\n        return output\n\n\nif __name__ == \"__main__\":\n\n    # 初始化神经类\n    neural_network = NeuralNetwork()\n\n    print(\"Beginning Randomly Generated Weights: \")\n    print(neural_network.synaptic_weights)\n\n    #训练数据\n    training_inputs = np.array([[0,0,1],\n                                [1,1,1],\n                                [1,0,1],\n                                [0,1,1]])\n\n    training_outputs = np.array([[0,1,1,0]]).T\n\n    # 开始训练\n    neural_network.train(training_inputs, training_outputs, 15000)\n\n    print(\"Ending Weights After Training: \")\n    print(neural_network.synaptic_weights)\n\n    user_input_one = str(input(\"User Input One: \"))\n    user_input_two = str(input(\"User Input Two: \"))\n    user_input_three = str(input(\"User Input Three: \"))\n    \n    print(\"Considering New Situation: \", user_input_one, user_input_two, user_input_three)\n    print(\"New Output data: \")\n    print(neural_network.think(np.array([user_input_one, user_input_two, user_input_three])))\n    print(\"Wow, we did it!\")\n以下是运行代码后产生的输出：\n\n以上是我们设法创建的一个简单的神经网络。首先神经网络开始为自己分配一些随机权，此后，它使用训练样例训练自身。\n因此，如果出现新的样本输入[1,0,0]，则其输出值为0.9999584。而期望的的正确答案是1，可以说二者是非常接近了，考虑到Sigmoid函数是非线性函数，这点误差是可以接受的。\n此外，本文只使用了一层神经网络来执行简单的任务。如果我们将数千个这些人工神经网络集合在一起会发生什么情况呢？我们可以100%模仿人类思维吗？答案是肯定的，但是目前实现起来是比较困难的，只能说是十分相近。对此感兴趣的读者可以阅读与深度学习相关的资料。\n本文作者：【方向】\n阅读原文\n本文为云栖社区原创内容，未经允许不得转载。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}