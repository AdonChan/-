{"title": "Python标准库系列之模块介绍 - Python全栈之路 ", "index": "python", "content": "Python的模块其实就是封装了一个或者多个功能的代码集合，以便于重用，模块可以是一个文件也可以是一个目录，目录的形式称作包。\n模块分类\n内置模块\n内置模块可以理解成当你安装好python环境之后，直接可以使用import导入的就是内置模块，默认模块路径为：C:\\Python35\\lib，你也可以通过以下方式获取内置模块的路径：\n # 导入sys模块\n >>> import sys\n # 最后一个目录就是内置模块的路径\n >>> for n in sys.path:\n ...  print(n)\n ...\n\nC:\\Python35\\lib\\site-packages\\pip-8.1.1-py3.5.egg\nC:\\Python35\\python35.zip\nC:\\Python35\\DLLs\nC:\\Python35\\lib\nC:\\Python35\nC:\\Python35\\lib\\site-packages\n第三方模块\n第三方模块通常是开发者自己编写的模块，然后提交到python官方的库中，这样我们就可以下载安装使用了，默认安装目录为C:\\Python35\\lib\\site-packages，\n自定义模块\n自己编写的模块\n模块的导入方式\n把一个模块当做成一个整体来进行导入\nimport sys\n从一个模块中导入特定的变量或者是方法\nfrom sys import path\n调用的时候直接使用方法名path\n>>> path\n['', 'C:\\\\Python35\\\\lib\\\\site-packages\\\\pip-8.1.1-py3.5.egg', 'C:\\\\Python35\\\\python35.zip', 'C:\\\\Python35\\\\DLLs', 'C:\\\\Python35\\\\lib', 'C:\\\\Python35', 'C:\\\\Python35\\\\lib\\\\site-packages']\n给导入的模块或者方法起一个别名\nfrom sys import path as path_alias\n调用的时候使用别名path_alias\n>>> path_alias\n['', 'C:\\\\Python35\\\\lib\\\\site-packages\\\\pip-8.1.1-py3.5.egg', 'C:\\\\Python35\\\\python35.zip', 'C:\\\\Python35\\\\DLLs', 'C:\\\\Python35\\\\lib', 'C:\\\\Python35', 'C:\\\\Python35\\\\lib\\\\site-packages']\n添加默认的环境变量,当前生效\nsys.path.append(\"PATH_NAME\")\n可以使用imp模块中的reload方法重新载入某个模块的方法，例如下面的实例：\n$ cat simple.py \n#!/use/bin/env python\n\nprint('Hello, World!')\nspam = 1\n>>> import simple\nHello, World!\n>>> simple.spam\n1\n>>> simple.spam += 1\n>>> import simple\n>>> simple.spam\n2\n>>> import imp\n>>> imp.reload(simple)\nHello, World!\n<module 'simple' from '/Users/ansheng/simple.py'>\n>>> simple.spam\n1\n模块导入顺序\n\n先在当前脚本目录寻找有没有与导入模块名称相同的文件，如果有就把这个文件当作模块导入（据不完全统计，这是个坑，测试re模块没有问题，但是测试sys模块就有问题了）\n查找模块路径下面有没有对应的模块名\n如果没有找到模块名就报错\n\nimport是如何工作的？\n模块在被导入的时候会执行以下三个步骤：\n\n通过环境变量找到模块文件；\n编译成字节码文件，如果有字节码文件则导入字节码文件；\n执行模块中的代码来创建所定义的对象；\n\n以上的三个步骤只有在程序运行时，模块被第一次导入时才会进行。如果已经导入了这个模块然后再次导入的时候会跳过上面的三个步骤，它会直接提取内存中已经加载的模块对象。Python已经导入的模块会保存在sys.modules字典中。\n_X与__all__\n在模块中的所有变量以_开头的都不会被from *所导入\n$ cat simple.py \n#!/use/bin/env python\n\n_spam1 = 1\nspam2 = 1\n>>> from simple import *\n>>> dir()\n# _spam1没有被导入\n['__builtins__', '__doc__', '__name__', '__package__', 'spam2']\n相反的__all__列表里面的变量则会被from *所导入，没有在__all__列表里面的变量则不会被导入\n$ cat simple.py\n#!/use/bin/env python\n\n__all__ = ['spam2']\n\nspam1 = 1\nspam2 = 1\n>>> from simple import *\n>>> dir()\n# spam1没有被导入\n['__builtins__', '__doc__', '__name__', '__package__', 'spam2']\n注意事项\n据不完全统计，如果导入的模块的名称在当前目录下有这个文件，那么只会把当前目录下的这个文件当作模块，如下演示：\n创建一个脚本文件，名称为scripts\n[root@iZ28i253je0Z ~]# touch scripts.py\n内容为\n#!/usr/bin/env python\n# _*_ coding:utf-8 _*_\n# 导入一个模块re\nimport re\n# 输出匹配到的字符串abc\nprint(re.match('\\w+',\"abc\").group())\n执行脚本\n[root@iZ28i253je0Z ~]# python scripts.py \n# 把匹配到的结果abc输出出来\nabc\n创建一个.py文件，名称为re.py\n[root@iZ28i253je0Z ~]# touch re.py\n内容为\n#!/usr/bin/env python\n# _*_ coding:utf-8 _*_\n# 输出内容modus\nprint(\"Hello Word\")\n再次执行scripts.py脚本\n[root@iZ28i253je0Z ~]# python scripts.py \n# 先输出Hello Word\nHello Word\n# 然后再报错没有match这个方法\nTraceback (most recent call last):\n  File \"scripts.py\", line 6, in <module>\n    print(re.match('\\w+',\"abc\").group())\nAttributeError: 'module' object has no attribute 'match'\n这是为什么呢？因为python把re.py当成模块re了，继续往下看：\n更改scripts.py文件内容如下\n[root@iZ28i253je0Z ~]# cat scripts.py \n#!/usr/bin/env python\n# _*_ coding:utf-8 _*_\n\nimport re\nre.py文件内容不变，然后我们在执行脚本scripts.py\n[root@iZ28i253je0Z ~]# python scripts.py \nHello Word\n看到了吧，他会把re.py文件内的代码拿到scripts.py文件中去执行，这是个坑，最好别踩。\n导入当前目录下子目录下的文件\n[root@ansheng ~]# tree ./\n./\n├── modules\n│   ├── __init__.py\n│   ├── lib01.py\n│   └── lib02.py\n└── scripts.py\n\n1 directory, 4 files\n[root@ansheng ~]# cat scripts.py \n#!/usr/bin/env python\n# 导入modules包下面的lib01模块\nfrom modules import lib01\n# 导入modules包下面的lib02模块\nfrom modules import lib02\n[root@ansheng ~]# cat modules/__init__.py \n#!/usr/bin/env python\n[root@ansheng ~]# cat modules/lib01.py \n#!/usr/bin/env python\n# lib01.py文件会输出\"Hello lib01\"\nprint(\"Hello lib01\")\n[root@ansheng ~]# cat modules/lib02.py  \n#!/usr/bin/env python\n# lib02.py文件会输出\"Hello lib02\"\nprint(\"Hello lib02\")\n执行结果\n[root@ansheng ~]# python scripts.py\n# 会执行modules/lib02.py与modules/lib01.py文件内容\nHello lib01\nHello lib02\n包含目录下的文件时需要在目录下声明一个__init__.py文件，即使这个文件是空的也可以。\n\n原文链接\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "6"}