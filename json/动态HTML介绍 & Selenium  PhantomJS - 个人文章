{"title": "动态HTML介绍 & Selenium  PhantomJS - 个人文章 ", "index": "网页爬虫,python", "content": "JavaScript\nJavaScript 是网络上最常用也是支持者最多的客户端脚本语言。它可以收集 用户的跟踪数据,不需要重载页面直接提交表单，在页面嵌入多媒体文件，甚至运行网页游戏。\n我们可以在网页源代码的<scripy>标签里看到，比如：\n<script type=\"text/javascript\" src=\"https://statics.huxiu.com/w/mini/static_2015/js/sea.js?v=201601150944\"></script>\n\njQuery\njQuery 是一个十分常见的库,70% 最流行的网站(约 200 万)和约 30% 的其他网站(约 2 亿)都在使用。一个网站使用 jQuery 的特征,就是源代码里包含了 jQuery 入口,比如:\n<script type=\"text/javascript\" src=\"https://statics.huxiu.com/w/mini/static_2015/js/jquery-1.11.1.min.js?v=201512181512\"></script>\n\n如果你在一个网站上看到了 jQuery，那么采集这个网站数据的时候要格外小心。jQuery 可 以动态地创建 HTML 内容,只有在 JavaScript 代码执行之后才会显示。如果你用传统的方 法采集页面内容,就只能获得 JavaScript 代码执行之前页面上的内容。\nAjax\n我们与网站服务器通信的唯一方式，就是发出 HTTP 请求获取新页面。如果提交表单之后，或从服务器获取信息之后，网站的页面不需要重新刷新，那么你访问的网站就在用Ajax 技术。\nAjax 其实并不是一门语言,而是用来完成网络任务(可以认为 它与网络数据采集差不多)的一系列技术。Ajax 全称是 Asynchronous JavaScript and XML(异步 JavaScript 和 XML)，网站不需要使用单独的页面请求就可以和网络服务器进行交互 (收发信息)。\nDHTML\nAjax 一样，动态 HTML(Dynamic HTML, DHTML)也是一系列用于解决网络问题的 技术集合。DHTML 是用客户端语言改变页面的 HTML 元素(HTML、CSS，或者二者皆 被改变)。比如页面上的按钮只有当用户移动鼠标之后才出现,背景色可能每次点击都会改变，或者用一个 Ajax 请求触发页面加载一段新内容，网页是否属于DHTML，关键要看有没有用 JavaScript 控制 HTML 和 CSS 元素。\n那么，如何搞定？\n那些使用了 Ajax 或 DHTML 技术改变 / 加载内容的页面，可能有一些采集手段。但是用 Python 解决这个问题只有两种途径:\n直接从 JavaScript 代码里采集内容（费时费力）用 Python 的 第三方库运行 JavaScript，直接采集你在浏览器里看到的页面（这个可以有）。\nSelenium\nSelenium是一个Web的自动化测试工具，最初是为网站自动化测试而开发的，类型像我们玩游戏用的按键精灵，可以按指定的命令自动操作，不同是Selenium 可以直接运行在浏览器上，它支持所有主流的浏览器（包括PhantomJS这些无界面的浏览器）。\nSelenium 可以根据我们的指令，让浏览器自动加载页面，获取需要的数据，甚至页面截屏，或者判断网站上某些动作是否发生。\nSelenium 自己不带浏览器，不支持浏览器的功能，它需要与第三方浏览器结合在一起才能使用。但是我们有时候需要让它内嵌在代码中运行，所以我们可以用一个叫 PhantomJS 的工具代替真实的浏览器。\n可以从 PyPI 网站下载 Selenium库https://pypi.python.org/simpl... ，也可以用 第三方管理器 pip用命令安装：pip install selenium\nSelenium 官方参考文档：http://selenium-python.readth...\nPhantomJS\nPhantomJS 是一个基于Webkit的“无界面”(headless)浏览器，它会把网站加载到内存并执行页面上的 JavaScript，因为不会展示图形界面，所以运行起来比完整的浏览器要高效。\n如果我们把 Selenium 和 PhantomJS 结合在一起，就可以运行一个非常强大的网络爬虫了，这个爬虫可以处理 JavaScrip、Cookie、headers，以及任何我们真实用户需要做的事情。\n注意：PhantomJS 只能从它的官方网站http://phantomjs.org/download...) 下载。 因为 PhantomJS 是一个功能完善(虽然无界面)的浏览器而非一个 Python 库，所以它不需要像 Python 的其他库一样安装，但我们可以通过Selenium调用PhantomJS来直接使用。\nPhantomJS 官方参考文档：http://phantomjs.org/document...\n快速入门\nSelenium 库里有个叫 WebDriver 的 API。WebDriver 有点儿像可以加载网站的浏览器，但是它也可以像 BeautifulSoup 或者其他 Selector 对象一样用来查找页面元素，与页面上的元素进行交互 (发送文本、点击等)，以及执行其他动作来运行网络爬虫。\nIPython2 测试代码\n导入 webdriver\nfrom selenium import webdriver\n\n要想调用键盘按键操作需要引入keys包\nfrom selenium.webdriver.common.keys import Keys\n\n调用环境变量指定的PhantomJS浏览器创建浏览器对象\ndriver = webdriver.PhantomJS()\n\n如果没有在环境变量指定PhantomJS位置\ndriver = webdriver.PhantomJS(executable_path=\"./phantomjs\"))\n\nget方法会一直等到页面被完全加载，然后才会继续程序，通常测试会在这里选择 time.sleep(2)\ndriver.get(\"http://www.baidu.com/\")\n\n获取页面名为 wrapper的id标签的文本内容\ndata = driver.find_element_by_id(\"wrapper\").text\n\n打印数据内容\nprint data\n\n打印页面标题 \"百度一下，你就知道\"\nprint driver.title\n\n生成当前页面快照并保存\ndriver.save_screenshot(\"baidu.png\")\n\nid=\"kw\"是百度搜索输入框，输入字符串\"长城\"\ndriver.find_element_by_id(\"kw\").send_keys(u\"长城\")\n\nid=\"su\"是百度搜索按钮，click() 是模拟点击\ndriver.find_element_by_id(\"su\").click()\n\n获取新的页面快照\ndriver.save_screenshot(\"长城.png\")\n\n打印网页渲染后的源代码\nprint driver.page_source\n\n获取当前页面Cookie\nprint driver.get_cookies()\n\nctrl+a 全选输入框内容\ndriver.find_element_by_id(\"kw\").send_keys(Keys.CONTROL,'a')\n\nctrl+x 剪切输入框内容\ndriver.find_element_by_id(\"kw\").send_keys(Keys.CONTROL,'x')\n\n输入框重新输入内容\ndriver.find_element_by_id(\"kw\").send_keys(\"itcast\")\n\n模拟Enter回车键\ndriver.find_element_by_id(\"su\").send_keys(Keys.RETURN)\n\n清除输入框内容\ndriver.find_element_by_id(\"kw\").clear()\n\n生成新的页面快照\ndriver.save_screenshot(\"itcast.png\")\n\n获取当前url\nprint driver.current_url\n\n关闭当前页面，如果只有一个页面，会关闭浏览器\n### driver.close()\n\n关闭浏览器\ndriver.quit()\n\n页面操作\nSelenium 的 WebDriver提供了各种方法来寻找元素，假设下面有一个表单输入框：\n<input type=\"text\" name=\"user-name\" id=\"passwd-id\" />\n那么：\n\n### 获取id标签值\nelement = driver.find_element_by_id(\"passwd-id\")\n### 获取name标签值\nelement = driver.find_element_by_name(\"user-name\")\n# 获取标签名值\nelement = driver.find_elements_by_tag_name(\"input\")\n### 也可以通过XPath来匹配\nelement = driver.find_element_by_xpath(\"//input[@id='passwd-id']\")\n定位UI元素 (WebElements)\n\n关于元素的选取，有如下的API 单个元素选取\n\nfind_element_by_id\nfind_elements_by_name\nfind_elements_by_xpath\nfind_elements_by_link_text\nfind_elements_by_partial_link_text\nfind_elements_by_tag_name\nfind_elements_by_class_name\nfind_elements_by_css_selector\nBy ID\n\n<div id=\"coolestWidgetEvah\">...</div>\n实现\n\nelement = driver.find_element_by_id(\"coolestWidgetEvah\")\n------------------------ or -------------------------\nfrom selenium.webdriver.common.by import By\nelement = driver.find_element(by=By.ID, value=\"coolestWidgetEvah\")\nBy Class Name\n\n<div class=\"cheese\"><span>Cheddar</span></div><div class=\"cheese\"><span>Gouda</span></div>\n实现\n\ncheeses = driver.find_elements_by_class_name(\"cheese\")\n------------------------ or -------------------------\nfrom selenium.webdriver.common.by import By\ncheeses = driver.find_elements(By.CLASS_NAME, \"cheese\")\nBy Tag Name\n\n<iframe src=\"...\"></iframe>\n实现\n\nframe = driver.find_element_by_tag_name(\"iframe\")\n------------------------ or -------------------------\nfrom selenium.webdriver.common.by import By\nframe = driver.find_element(By.TAG_NAME, \"iframe\")\nBy Name\n\n<input name=\"cheese\" type=\"text\"/>\n实现\n\ncheese = driver.find_element_by_name(\"cheese\")\n------------------------ or -------------------------\nfrom selenium.webdriver.common.by import By\ncheese = driver.find_element(By.NAME, \"cheese\")\nBy Link Text\n\n<a href=\"http://www.google.com/search?q=cheese\">cheese</a>\n实现\n\ncheese = driver.find_element_by_link_text(\"cheese\")\n------------------------ or -------------------------\nfrom selenium.webdriver.common.by import By\ncheese = driver.find_element(By.LINK_TEXT, \"cheese\")\nBy Partial Link Text\n\n<a href=\"http://www.google.com/search?q=cheese\">search for cheese</a>>\n实现\n\ncheese = driver.find_element_by_partial_link_text(\"cheese\")\n------------------------ or -------------------------\nfrom selenium.webdriver.common.by import By\ncheese = driver.find_element(By.PARTIAL_LINK_TEXT, \"cheese\")\nBy CSS\n\n<div id=\"food\"><span class=\"dairy\">milk</span><span class=\"dairy aged\">cheese</span></div>\n实现\n\ncheese = driver.find_element_by_css_selector(\"#food span.dairy.aged\")\n------------------------ or -------------------------\nfrom selenium.webdriver.common.by import By\ncheese = driver.find_element(By.CSS_SELECTOR, \"#food span.dairy.aged\")\nBy XPath\n\n<input type=\"text\" name=\"example\" />\n<INPUT type=\"text\" name=\"other\" />\n实现\n\ninputs = driver.find_elements_by_xpath(\"//input\")\n------------------------ or -------------------------\nfrom selenium.webdriver.common.by import By\ninputs = driver.find_elements(By.XPATH, \"//input\")\n\n鼠标动作链\n有些时候，我们需要再页面上模拟一些鼠标操作，比如双击、右击、拖拽甚至按住不动等，我们可以通过导入 ActionChains 类来做到：\n示例：\n导入 ActionChains 类\nfrom selenium.webdriver import ActionChains\n\n鼠标移动到 ac 位置\nac = driver.find_element_by_xpath('element')\nActionChains(driver).move_to_element(ac).perform()\n\n\n在 ac 位置单击\nac = driver.find_element_by_xpath(\"elementA\")\nActionChains(driver).move_to_element(ac).click(ac).perform()\n\n在 ac 位置双击\nac = driver.find_element_by_xpath(\"elementB\")\nActionChains(driver).move_to_element(ac).double_click(ac).perform()\n\n在 ac 位置右击\nac = driver.find_element_by_xpath(\"elementC\")\nActionChains(driver).move_to_element(ac).context_click(ac).perform()\n\n在 ac 位置左键单击hold住\nac = driver.find_element_by_xpath('elementF')\nActionChains(driver).move_to_element(ac).click_and_hold(ac).perform()\n\n将 ac1 拖拽到 ac2 位置\nac1 = driver.find_element_by_xpath('elementD')\nac2 = driver.find_element_by_xpath('elementE')\nActionChains(driver).drag_and_drop(ac1, ac2).perform()\n\n填充表单\n我们已经知道了怎样向文本框中输入文字，但是有时候我们会碰到<select> </select>标签的下拉框。直接点击下拉框中的选项不一定可行。\n<select id=\"status\" class=\"form-control valid\" onchange=\"\" name=\"status\">\n    <option value=\"\"></option>\n    <option value=\"0\">未审核</option>\n    <option value=\"1\">初审通过</option>\n    <option value=\"2\">复审通过</option>\n    <option value=\"3\">审核不通过</option>\n</select>\n\n\nSelenium专门提供了Select类来处理下拉框。 其实 WebDriver 中提供了一个叫 Select 的方法，可以帮助我们完成这些事情：\n导入 Select 类\nfrom selenium.webdriver.support.ui import Select\n\n找到 name 的选项卡\nselect = Select(driver.find_element_by_name('status'))\n\nselect.select_by_index(1)\nselect.select_by_value(\"0\")\nselect.select_by_visible_text(u\"未审核\")\n\n以上是三种选择下拉框的方式，它可以根据索引来选择，可以根据值来选择，可以根据文字来选择。注意：\nindex 索引从 0 开始value是option标签的一个属性值，并不是显示在下拉框中的值visible_text是在option标签文本的值，是显示在下拉框的值全部取消选择怎么办呢？很简单:\nselect.deselect_all()\n\n弹窗处理\n当你触发了某个事件之后，页面出现了弹窗提示，处理这个提示或者获取提示信息方法如下：\nalert = driver.switch_to_alert()\n\n页面切换\n一个浏览器肯定会有很多窗口，所以我们肯定要有方法来实现窗口的切换。切换窗口的方法如下：\ndriver.switch_to.window(\"this is window name\")也可以使用 window_handles 方法来获取每个窗口的操作对象。例如：\nfor handle in driver.window_handles:\n    driver.switch_to_window(handle)\n\n页面前进和后退\n操作页面的前进和后退功能：\ndriver.forward()     #前进\ndriver.back()        # 后退\n\nCookies\n获取页面每个Cookies值，用法如下\nfor cookie in driver.get_cookies():\n    print \"%s -> %s\" % (cookie['name'], cookie['value'])\n\n删除Cookies，用法如下\nBy name\ndriver.delete_cookie(\"CookieName\")\n\nall\ndriver.delete_all_cookies()\n\n页面等待\n注意：这是非常重要的一部分！！\n现在的网页越来越多采用了 Ajax 技术，这样程序便不能确定何时某个元素完全加载出来了。如果实际页面等待时间过长导致某个dom元素还没出来，但是你的代码直接使用了这个WebElement，那么就会抛出NullPointer的异常。\n为了避免这种元素定位困难而且会提高产生 ElementNotVisibleException 的概率。所以 Selenium 提供了两种等待方式，一种是隐式等待，一种是显式等待。\n隐式等待是等待特定的时间，显式等待是指定某一条件直到这个条件成立时继续执行。\n显式等待\n显式等待指定某个条件，然后设置最长等待时间。如果在这个时间还没有找到元素，那么便会抛出异常了。\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\n### WebDriverWait 库，负责循环等待\nfrom selenium.webdriver.support.ui import WebDriverWait\n### expected_conditions 类，负责条件出发\nfrom selenium.webdriver.support import expected_conditions as EC\n\ndriver = webdriver.Chrome()\ndriver.get(\"http://www.xxxxx.com/loading\")\ntry:\n\n页面一直循环，直到 id=\"myDynamicElement\" 出现\n\n\n    element = WebDriverWait(driver, 10).until(\n        EC.presence_of_element_located((By.ID, \"myDynamicElement\"))\n    )\nfinally:\n    driver.quit()\n\n如果不写参数，程序默认会 0.5s 调用一次来查看元素是否已经生成，如果本来元素就是存在的，那么会立即返回。\n下面是一些内置的等待条件，你可以直接调用这些条件，而不用自己写某些等待条件了。\ntitle_is\ntitle_contains\npresence_of_element_located\nvisibility_of_element_located\nvisibility_of\npresence_of_all_elements_located\ntext_to_be_present_in_element\ntext_to_be_present_in_element_value\nframe_to_be_available_and_switch_to_it\ninvisibility_of_element_located\nelement_to_be_clickable – it is Displayed and Enabled.\nstaleness_of\nelement_to_be_selected\nelement_located_to_be_selected\nelement_selection_state_to_be\nelement_located_selection_state_to_be\nalert_is_present\n\n隐式等待\n隐式等待比较简单，就是简单地设置一个等待时间，单位为秒。\nfrom selenium import webdriver\n\ndriver = webdriver.Chrome()\ndriver.implicitly_wait(10) # seconds\ndriver.get(\"http://www.xxxxx.com/loading\")\nmyDynamicElement = driver.find_element_by_id(\"myDynamicElement\")\n\n当然如果不设置，默认等待时间为0。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}