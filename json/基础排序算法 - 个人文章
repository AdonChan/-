{"title": "基础排序算法 - 个人文章 ", "index": "python", "content": "原文链接：http://kasheemlew.github.io/2...\n简单排序\n插入排序\n想象一下插队的过程...\n\n一个人通过插队的方式排到前面，而将原本在他前面的人挤到了后面的位置。对数排序时也是这样，为了从小到大排序，需要将一个数放到前面，而将那些比它大的数挤到了后面，从而实现了排序的目的。\n\n排序过程\n\n当一个数列A开始进行排序时就已经被划分成了两个部分--有序的和无序的，由于只有一个数的数列可以被看作已经有序，所以将数列A中的第一个元素看作有序的部分(图中6)，后面的其他数看作无序的部分(图中5，3，1，8，7，2，4)\n从前到后扫描有序的部分，将无序部分中的第一个元素插入到有序的部分中合适的位置(3插到5，6的前面)\n然后将有序序列中该数后面的数依次后移一位(5，6后移一位)，形成新的有序部分(3, 5, 6)\n重复直到遍历完整个数列。\n\n效率分析\n空间复杂度\nO(n)用于存储整个数列，O(1)辅助，暂存操作数，用于插入。\n时间复杂度\n\n最好：已经有序的情况下，只需要遍历数列一次，为O(n)。\n最坏：反序情况下比较次数依次是1 + 2 + 3 + ... + (N - 1)，即(1/2)n(n-1)次。O(n^2)。\n平均：O(n^2)\n\n算法实现\n根据上述的排序过程，易用数组进行实现，这里不再赘述。但使用链表实现中每次后移的过程会大大降低排序的效率，以下两种实现可以\nC语言链表实现\nstruct LIST * InsertionSort(struct LIST * pList)\n{\n    if(pList == NULL || pList->pNext == NULL) {\n        return pList;\n    }\n    struct LIST * head = NULL; // head为有序部分的第一个元素\n    while(pList != NULL) {\n        struct LIST * current = pList;\n        pList = pList->pNext;\n        if(head == NULL || current->iValue < head->iValue) {\n            // 插入有序部分的第一个位置\n            current->pNext = head;\n            head = current;\n        } else {\n            // 插入有序部分的中间位置\n            struct LIST * p = head;\n            while(p != NULL) {\n                if(p->pNext == NULL || current->iValue < p->pNext->iValue) {\n                    current->pNext = p->pNext;\n                    p->pNext = current;\n                    break;\n                }\n                p = p->pNext;\n            }\n        }\n    }\n    return head;\n}\nPython实现\n采用从后向前遍历插入的方法，并利用Python中的切片，每次插入一个数之后不必再使用后移的方式调整有序序列的位置，而是直接拼接切片并返回。\ndef insertion_sort(alist):\n    length = len(alist)\n    if length == 1:\n        return alist\n    b = insertion_sort(alist[1:])\n    for index in range(len(b)):\n        if alist[0] <= b[index]:\n            return b[:index] + [alist[0]] + b[index:]\n    return b + [alist[0]]\n选择排序\n这次不再将最小的数放到最前面，让后面的数自动往后面移位，而是每次选择出最小的数，和排在第一个的数进行交换。从而达到将较小的数排在前面的目的。\n\n排序过程\n以从小到大排序为例:\n\n在未排序序列中找到最小元素，存放到排序序列的起始位置，\n再从剩余未排序元素中继续寻找最小元素，然后放到已排序序列的末尾。\n重复第二步，直到所有元素均排序完毕。\n\n效率分析\n空间复杂度\nO(n)用于存储整个数列，O(1)辅助，暂存操作数，用于交换。\n时间复杂度\n由于一共有n个位置要进行选择，每次选择时又要对剩下为放入合适位置的数进行便利，所以时间复杂度不分最好和最坏，依次比较(N-1)+(N-2)+ ... +1次，即(N-1+1)*N/2 = (N^2)/2, 为O(n^2)。\n算法实现\nPython实现\ndef selection_sort(alist):\n    length = len(alist)\n    for index in range(length):\n        m = index\n        for i in range(index, length):\n            if alist[i] < alist[m]:\n                m = i\n        alist[m], alist[index] = alist[index], alist[m]\n    return alist\n高效排序\n归并排序\n归并算法主要通过拆分和合并两个步骤来完成对数列的排序，将需要排序的数列拆分成尽量小的序列，然后重新合并，合并时按顺序排列，最终形成有序序列。\n\n排序过程\n迭代法\n\n申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列\n设定两个指针，最初位置分别为两个已经排序序列的起始位置\n比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置\n重复步骤3直到某一指针到达序列尾\n将另一序列剩下的所有元素直接复制到合并序列尾\n\n递归法\n\n假设序列共有n个元素：\n将序列每相邻两个数字进行归并操作，形成n/2个序列，排序后每个序列包含两个元素\n将上述序列再次归并，形成n/4个序列，每个序列包含四个元素\n重复步骤2，直到所有元素排序完毕\n\n效率分析\n以递归法为例：\n递归算法的时间由子问题的时间和合并子问题的时间两部分构成，最小子问题不需要合并，因此n=1时即为ɵ(1)。\n进而得出以下方程:T(n)所要合并的的数列为原来数列中所有的数(n个)，所以时间为cn。T(n/2)为T(n)划分出的子问题，它所处理的数列中数的个数是n/2个，故T(n/2)=2T(n/4)+cn/2，类推得到下图。\n图中树的深度显然为(logn)+1，每一层所有的问题所需要的合并时间的和都是cn，因此总时间为cn(logn)+cn，时间复杂度为O(nlogn)。\n时间复杂度：\n根据上面的推导，归并排序的时间复杂度为O(nlogn)。\n空间复杂度\n\n迭代法：O(n)存储整个数列，O(1)辅助，用于交换。\n递归法：O(n)存储整个数列，O(n)辅助，用于子问题存储子问题的序列。\n\n算法实现\nC++迭代法实现\n对于C++，可以使用模板使得函数适用于所有的类型的数据。\ntemplate<typename T>\nvoid merge_sort(T arr[], int len) {\n    T* a = arr;\n    T* b = new T[len];\n    for (int seg = 1; seg < len; seg += seg) {\n        for (int start = 0; start < len; start += seg + seg) {\n            int low = start, mid = min(start + seg, len), high = min(start + seg + seg, len);\n            int k = low;\n            int start1 = low, end1 = mid;\n            int start2 = mid, end2 = high;\n            while (start1 < end1 && start2 < end2)\n                b[k++] = a[start1] < a[start2] ? a[start1++] : a[start2++];\n            while (start1 < end1)\n                b[k++] = a[start1++];\n            while (start2 < end2)\n                b[k++] = a[start2++];\n        }\n        T* temp = a;\n        a = b;\n        b = temp;\n    }\n    if (a != arr) {\n        for (int i = 0; i < len; i++)\n            b[i] = a[i];\n        b = a;\n    }\n    delete[] b;\n}\nPython递归法实现\ndef merge_sort(alist):\n    \"\"\"合并函数\"\"\"\n    if len(alist) <= 1:\n        return alist\n    middle = len(alist)//2\n    left = merge_sort(alist[:middle])\n    right = merge_sort(alist[middle:])\n    print left + right\n    return merge(left, right)\n\ndef merge(left, right):\n    \"\"\"主排序函数\"\"\"\n    l, r = 0, 0\n    result = []\n    while l<len(left) and r<len(right):\n        if left[l] < right[r]:\n            result.append(left[l])\n            l += 1\n        else:\n            result.append(right[r])\n            r += 1\n    return result+left[l:]+right[r:]\n堆排序\n堆是什么\n堆可以看成是二叉树的一种，也可以看成是元素有优先权区别的队列。\n\n任意节点小于(或大于)它的所有后裔(树中的子节点)，最小元(或最大元)在的根上。\n堆总是一棵完全树。（每一层必须从左往右排，并且排完一层之后才能排下一层）\n\n像这样：?(左边是一个小顶堆，右边是大顶堆。)\n根据上面所说的，只有一个数的序列一定可以构成一个堆。\n排序过程\n以从小到大排为例：\n最大堆调整：将末端的子节点进行调整，使得子节点小于父节点。前面说过，只有一个数的序列一定可以构成一个堆，下面考虑三个数的情况。\n如果要让这个子二叉树成为堆，只需要将树根与较大的子节点进行交换即可(7和15交换)。如果将根中的数与子节点交换的过程看作是下沉的过程，那么它必须下沉到没有子节点比它小的位置，因为交换的过程中始终使较大的数移到上一层的位置，所以不会对其他数的排序造成影响。\n\n建立最大堆：将堆所有数据重新排序。\n堆排序：移除位在第一个数据(实际操作中将其放到数列的最后)，对其他的数继续进行堆排序。\n\n\n效率分析\n时间复杂度\n堆排序的时间主要由堆调整和建堆两部分构成。\n\n堆调整  当前节点与两个子节点各比较一次之后与较大的进行一次交换，并对被交换的子节点进行递归操作。所以有T(n)=T(n-1)+3; T(1)=3，树高h=logn，所以T(h)=3h=3O(logn)，堆调整的时间复杂度为O(logn)。\n建堆  树高h=logn。最后一层的节点没有子节点，不用进行操作。对深度为于h-1层的节点，比较2次，交换1次，这一层最多有2^(h-1)个节点，总共操作次数最多为3(1*2^(h-1))；对深度为h-2层的节点，总共有2^(h-2)个，每个节点最多比较4次，交换2次，所以操作次数最多为3(2*2^(h-2))。另a:s=3*[2^(h-1) + 2*2^(h-2)+ 3*2^(h-3) + … + h*2^0]，b:2s=3*[2^(h) + 2*2^(h-1)+ 3*2^(h-2) + … + h*2^1]，a-b得s=3*[2^h + 2^(h-1) + 2^(h-2) + … + 2 - h]=3*[2^(h+1)-2-h]，又因为2^(h+1)=n+1，所以总时间约为3n，建堆的时间复杂度O(n)。\n\n综上：堆排序的时间等于第一次建堆加上后面n-1次堆调整，由于n的减小，后面的O(log2(n))中的n也会减小，所以用小于等于号T(n) <=  O(n)  + (n - 1)*O(log2(n))，时间复杂度为O(nlogn)\n空间复杂度\nO(n)存储整个数列，O(1)辅助，用于交换。\n算法实现\nPython实现\ndef swap(array, a, b):\n    \"\"\"交换函数\"\"\"\n    temp = array[a]\n    array[a] = array[b]\n    array[b] = temp\n\ndef sift_down(array, last_index):\n    \"\"\"堆调整函数\"\"\"\n    index = 0\n    while True:\n        left_index = 2*index + 1\n        right_index = 2*index + 2\n        if left_index > last_index:\n            break\n        else:\n            if right_index > last_index:\n                next_index = left_index\n            else:\n                if array[left_index] >= array[right_index]:\n                    next_index = left_index\n                else:\n                    next_index = right_index\n        if array[next_index] <= array[index]:\n            break\n        temp = array[index]\n        array[index] = array[next_index]\n        array[next_index] = temp\n        index = next_index\n        print(\"next_index: \", next_index)\n\ndef heap_sort(array, length):\n    \"\"\"堆排序主函数\"\"\"\n    last_node = (length - 2) / 2\n    for i in range(last_node, 0, -1):\n        sift_down(array, length-1)\n\n    for i in range(length-1, 1, -1):\n        swap(array, 0, i)\n        sift_down(array, i-1)\n    swap(array, 0, 1)\n快速排序\n快速排序类似于上体育课排队的过程，总是以一个人为基准，其他人根据身高分列在他的两边。在快速排序中也有一个基准--枢轴(pivot)，其他的数根据大小排在它的两边。之所以叫快速排序，是因为快速排序在最好情况和一般情况下的时间复杂度都是最低的。\n排序过程\n\n\n从数列中挑出一个元素，称为\"基准\"（pivot），\n重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。\n递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。\n\n\n效率分析\n时间复杂度\n\n平均：，时间复杂度为O(logn)\n最好：Partition每次划分均匀，递归树的深度为logn+1，即仅需递归logn次，第一次Partiation对整个数列扫描一遍，做n次比较。然后，获得的枢轴将数组一分为二，各自还需要T（n/2）的时间。类推得到：T(n)=2T(n/2)+n; T(1)=0\n\nT(n)=2(2T（n/4）+n/2)+n=4T（n/4）+2n T(n)=4(2T(n/8)+n/4)+2n=8T(n/8)+3n所以  T（n）≤nT（1）+（log2n）×n= O(nlogn) \n最坏：每次划分只得到一个比上一次划分少一个记录的子序列，递归树除了叶节点之外的节点都只有一个子节点，每次都要与剩下的所有数进行比较。\n空间复杂度\n\n平均：O(n)存储整个数列，O(logn)辅助\n最好：O(n)存储整个数列，O(logn)辅助\n最坏：O(n)存储整个数列，O(n)辅助\n\n辅助空间来源于递归造成的栈空间的使用。\n算法实现\nPython实现\ndef Partition(r, low, high):\n    pivot = r[low]\n    while low < high:\n        while low < high and r[high] >= pivot:\n            high -= 1\n        if low < high:\n            r[low] = r[high]\n            low += 1\n        while low < high and r[low] <= pivot:\n            low += 1\n        if low < high:\n            r[high] = r[low]\n            high -= 1\n    r[low] = pivot\n    return low\n\ndef QuickSort(r, low, high):\n    if low < high:\n        pivotkey = Partition(r, low, high)\n        QuickSort(r, low, pivotkey-1)\n        QuickSort(r, pivotkey+1, high)\n分配排序\n计数排序\n计数排序与之前的算法采用的是完全不同的一种视角，它注重的是元素应该存在的位置，而不再是两个元素之间的大小关系。\n排序过程\n\n\n找出待排序的数组中最大和最小的元素\n统计数组中每个值为i的元素出现的次数，存入数组 C 的第 i 项\n对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）\n反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1\n\n效率分析\n时间复杂度\n需要将数组遍历三遍，但是这三个循环不是嵌套执行的，所以时间复杂度没有影响。平均：O(n+k)\n空间复杂度\n存放原序列和元素的计数信息：O(n+k)\n计数排序的瓶颈十分明显，对于数据范围很大的数组，需要大量时间和内存。\n算法实现\nPython实现\n下面是对一个序列中所有的字符进行排序\ndef countSort(arr):\n    output = [0 for i in range(256)]\n    count = [0 for i in range(256)]\n\n    for i in arr:\n        count[ord(i)] += 1\n\n    for i in range(256):\n        count[i] += count[i-1]\n\n    for i in range(len(arr)):\n        output[count[ord(arr[i])]-1] = arr[i]\n        count[ord(arr[i])] -= 1\n    return output\n桶排序\n排序过程\n\n设置一个定量的序列当作空桶。\n遍历序列，把元素放到对应的桶中去。\n对每个不是空的桶子进行排序。\n将桶中的元素放回到原来的序列中去。\n\n\n效率分析\n时间复杂度\n与计数排序类似，遍历和桶中的排序是并列关系，不影响时间复杂度，平均O(n+k)\n空间复杂度\n桶的个数和每个桶中元素的个数，O(n*k)\n算法实现\nC++实现\nC++中的vector是用来作桶的绝佳的材料。也可以用链表来实现。\nvoid bucketSort(float arr[], int n)\n{\n    vector<float> b[n];\n\n    for (int i=0; i<n; i++)\n    {\n       int bi = n*arr[i];\n       b[bi].push_back(arr[i]);\n    }\n\n    for (int i=0; i<n; i++)\n       sort(b[i].begin(), b[i].end());\n\n    int index = 0;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < b[i].size(); j++)\n          arr[index++] = b[i][j];\n}\n基数排序\n如果要将一副扑克牌恢复到原来有序的状态，为了将扑克牌恢复成有序的状态(就像刚买来时那样)，我们通常先挑出相同花色的牌放在一起，然后再按照牌号的大小进行排序，也就是依次按照牌的不同属性进行排序。\n\n而在基数排序中，通常将数的不同的位看作是不同的属性，也就是依次根据各个位上数字的大小进行排序。\n排序过程\n\n对数列中的数从最低位开始每次取一位进行比较，先比较个位，然后比较十位...\n根据选中的位对元素进行计数排序\n重复上述过程，直到取完所有位\n\n效率分析\n时间复杂度\n假设最大的数一共有k位，每取一位进行比较都要讲所有的数遍历一遍，因此为O(kN)\n空间复杂度\n计数列表的空间和用做中间列表的存储的空间，O(k+N)\n算法实现\nPython实现\ndef countingSort(arr, exp1):\n    \"\"\"计数排序函数\"\"\"\n    n = len(arr)\n    output = [0] * (n) # 最终的数列，先用0占位\n    count = [0] * (10) # 每个数进行计数的列表，初始化为0\n\n    for i in range(0, n):\n        index = (arr[i]/exp1)\n        count[ (index)%10 ] += 1\n    for i in range(1,10):\n        count[i] += count[i-1]\n    i = n-1\n    while i>=0:\n        index = (arr[i]/exp1)\n        output[ count[ (index)%10 ] - 1] = arr[i]\n        count[ (index)%10 ] -= 1\n        i -= 1\n\n    # 将arr修改为按这一位排序过后的顺序\n    i = 0\n    for i in range(0,len(arr)):\n        arr[i] = output[i]\n\n\ndef radixSort(arr):\n    max1 = max(arr)\n    exp = 1\n    while max1/exp > 0: # 从个位开始每次取一位，进行计数排序\n        countingSort(arr,exp)\n        exp *= 10\n其他\n冒泡排序\n冒泡排序与气泡上升的过程相似，气泡上升的过程中不断吸收空气而变大，只不过冒泡排序中的元素不会发生变化，而是较大的数与较小数交换了位置。冒泡排序是一种用时间换空间的算法。\n\n排序过程\n\n比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。\n针对所有的元素重复以上的步骤，除了最后一个。\n持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n\n效率分析\n时间复杂度\n外层循环n-1次，内层循环n-i次。内层循环总的次数用等差数列求和公式是(1+(n-1))*(n-1)/2=n*(n-1)/2≈n^2/2，外层循环赋值次数为常数设为a，内层循环赋值次数也是常数设为b，所以f(n)≈a * n + b * n^2/2，时间复杂度是O(n^2)\n空间复杂度\nO(n)存储整个数列，O(n)辅助，用于交换。\n算法实现\nPython实现\ndef bubble_sort(alist):\n    length = len(alist)\n    for index in range(length-1):\n        for i in range(0, length-index-1):\n            if alist[i] > alist[i+1]:\n                alist[i+1], alist[i] = alist[i], alist[i+1]\n    return alist\n优化: 添加标记，在排序完成时停止排序，可以使最好情况下的时间复杂度为O(n)\ndef bubble_sort_flag(alist):\n    length = len(alist)\n    for index in range(length):\n        flag = True\n        for i in range(0, length-index-1):\n            if alist[i] > alist[i+1]:\n                alist[i+1], alist[i] = alist[i], alist[i+1]\n                flag = False\n        if flag:\n            return alist\n    return alist\n希尔排序\n\nDonald Shell设计的算法，也称递减增量排序算法，利用了插入排序在对几乎已经排好序的数据操作时，效率高，可以达到线性排序的效率的特点，对算法进行了优化。希尔排序通过步长来控制调整顺序时的比较的两个数之间的间隔，在排序开始阶段使用较大的步长可以使一个元素可以一次性地朝最终位置前进一大步，然后再换用较小的步长，进行更加精确的调整。算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。\n\n排序过程\n与插入排序类似，只不过不再是按照原序列的顺行依次进行判断了，而是在无序序列中每次间隔步长个元素取元素，对其进行插入。\n步长选择\n\n希尔增量\n步长选择为n\\2并且对步长取半直到步长达到1。\nSedgewick增量\n1, 5, 19, 41, 109,...，根据而得出。\n斐波那契增量\n斐波那契数列除去0和1将剩余的数以黄金分割比的两倍的幂进行运算得到的数列：1, 9, 34, 182, 836, 4025, 19001, 90358, 428481, 2034035, 9651787, 45806244, 217378076, 1031612713,…\n效率分析\n时间复杂度\n\n平均: 根据选择的步长的不同而不同，通常为O(n^2)，但比起他时间复杂度为O(n^2)的算法更快。\n最好：序列已经有序，遍历一遍即可，为O(n)。\n最坏：O(n^2)\n\n空间复杂度\nO(n)用于存储整个数列，O(1)辅助，暂存操作数，用于插入。\n算法实现\nPython实现\ndef shell_sort(alist):\n    length = len(alist)\n    gap = length / 2\n    while gap > 0:\n        for i in range(gap, length):\n            temp = alist[i]\n            j = i\n            # 插入排序\n            while j >= gap and alist[j-gap] > temp:\n                alist[j] = alist[j-gap]\n                j -= gap\n            alist[j] = temp\n        gap = gap / 2\n    return alist\n梳排序(Comb Sort)\n梳排序的基本思想和 希尔排序 一样，都是通过在排序开始阶段用较大的步长进行排序，使得一个元素可以一次性地朝最终位置前进一大步。相对于 希尔排序 对 插入排序 进行改良，梳排序 则是 冒泡排序 的延伸。\n排序过程\n梳排序基于冒泡排序，但是没次与固定距离处的数的比较和交换,这个固定距离是待排数组长度除以1.3(一个魔数))得到近似值,下次则以上次得到的近似值再除以1.3,直到距离小至3时,以1递减。\n\n效率分析\n时间复杂度\n\n平均：ꭥ((n^2)/(2^p))，p为数据的增量。\n最好：Ɵ(nlogn)\n最坏：O(n^2)\n\n空间复杂度\nO(n)用于存储整个数列，O(1)辅助，用于交换。\n算法实现\nPython实现\ndef comb_sort(alist):\n    shrink = 1.3\n    gap = len(alist)\n\n    while True:\n        gap = int(gap / shrink)\n        i = 0\n        if gap < 1:\n            break\n        else:\n            while i + gap < length:\n                if alist[i] > alist[i+gap]:\n                    alist[i], alist[i+gap] = alist[i+gap], alist[i]\n                i += 1\n    return alist\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "5"}