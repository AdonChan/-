{"title": "几种排序算法及 Python 实现 - 个人文章 ", "index": "python,算法", "content": "插入排序\ndef insert_sort(list):\n    n = len(list)\n    for i in range(1, n):\n        key = list[i]\n        for j in range(i-1, -1, -1):\n            if list[j] > key:\n                list[j+1], list[j] = list[j], key\n            else:\n                break\n    return list\n   \nprint(insert_sort([3, 2, 5, 1, 4]))\n希尔(缩小增量)排序\n算法课没有讲希尔排序，所以记录一下其思想和复杂度分析\n该方法的基本思想是：先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的，因此希尔排序在时间效率上比前两种方法有较大提高。\n时间复杂度与步长选择有关，最坏情况下 $$ O(n^2) $$不稳定\n以 gap 替换插入排序中的 1\ndef shell_sort(list):\n    n = len(list)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n, gap):\n            key = list[i]\n            for j in range(i-gap, -1, -gap):\n                if key < list[j]:\n                    list[j+gap], list[j] = list[j], key\n                else:\n                    break\n        gap //= 2\n    return list\n快排\ndef quick_sort(list, left, right):\n    if left >= right:\n        return list\n    key = list[right]\n    high = right - 1\n    low = left\n    while low <= high:\n        if list[low] > key:\n            list[low], list[high] = list[high], list[low]\n            high -= 1\n        else:\n            low += 1\n    list[low], list[right] = list[right], list[low]\n    quick_sort(list, left, low-1)\n    quick_sort(list, low+1, right)\n    return list\nprint(quick_sort([3, 2, 5, 1, 4, 6, 8, 7], 0, 7))\n堆排序\ndef adjust_heap(list, i, n):\n    lchild = 2 * i + 1\n    rchild = 2 * i + 2\n    max = i\n    if lchild < n and list[lchild] > list[max]:\n        max = lchild\n    if rchild < n and list[rchild] > list[max]:\n        max = rchild\n    if max != i:\n        list[i], list[max] = list[max], list[i]\n        adjust_heap(list, max, n)\n        \ndef build_heap(list, n):\n    for i in range(int(n/2)-1, -1, -1):\n        adjust_heap(list, i, n)\n\ndef heap_sort(list):\n    build_heap(list, len(list))\n    for i in range(len(list)-1, -1, -1):\n        list[0], list[i] = list[i], list[0]\n        adjust_heap(list, 0, i)\n    return list\nlist = [3, 2, 5, 1, 4, 6, 8, 7]\nprint(heap_sort(list))\n归并排序\n自顶向下的递归实现：$$T(n)=2T\\left(\\frac{n}{2}\\right)+O(n)$$$$\\Rightarrow T(n)=O(n\\log n)$$\ndef merge(list1, list2):\n    res = []\n    n, m = len(list1), len(list2)\n    i, j = 0, 0\n    while i < n and j < m:\n        if list1[i] < list2[j]:\n            res.append(list1[i])\n            i += 1\n        else:\n            res.append(list2[j])\n            j += 1\n    res += list1[i:]\n    res += list2[j:]\n    return res\n\ndef merge_sort(list):\n    n = len(list)\n    if n <= 1:\n        return list\n    left = merge_sort(list[:n//2])\n    right = merge_sort(list[n//2:])\n    return merge(left, right)\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}