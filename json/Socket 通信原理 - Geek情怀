{"title": "Socket 通信原理 - Geek情怀 ", "index": "python,socket,网络编程", "content": "什么是 Socket？\nSocket 的中文翻译过来就是“套接字”。套接字是什么，我们先来看看它的英文含义：插座。\nSocket 就像一个电话插座，负责连通两端的电话，进行点对点通信，让电话可以进行通信，端口就像插座上的孔，端口不能同时被其他进程占用。而我们建立连接就像把插头插在这个插座上，创建一个 Socket 实例开始监听后，这个电话插座就时刻监听着消息的传入，谁拨通我这个“IP 地址和端口”，我就接通谁。\n实际上，Socket 是在应用层和传输层之间的一个抽象层，它把 TCP/IP 层复杂的操作抽象为几个简单的接口，供应用层调用实现进程在网络中的通信。Socket 起源于 UNIX，在 UNIX 一切皆文件的思想下，进程间通信就被冠名为文件描述符（file descriptor），Socket 是一种“打开—读/写—关闭”模式的实现，服务器和客户端各自维护一个“文件”，在建立连接打开后，可以向文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。\n另外我们经常说到的Socket 所在位置如下图：\n\nSocket 通信过程\nSocket 保证了不同计算机之间的通信，也就是网络通信。对于网站，通信模型是服务器与客户端之间的通信。两端都建立了一个 Socket 对象，然后通过 Socket 对象对数据进行传输。通常服务器处于一个无限循环，等待客户端的连接。\n一图胜千言，下面是面向连接的 TCP 时序图：\n\n客户端过程：\n客户端的过程比较简单，创建 Socket，连接服务器，将 Socket 与远程主机连接（注意：只有 TCP 才有“连接”的概念，一些 Socket 比如 UDP、ICMP 和 ARP 没有“连接”的概念），发送数据，读取响应数据，直到数据交换完毕，关闭连接，结束 TCP 对话。\nimport socket\nimport sys\n\nif __name__ == '__main__':\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # 创建 Socket 连接\n    sock.connect(('127.0.0.1', 8001))  # 连接服务器\n    while True:\n        data = input('Please input data:')\n        if not data:\n            break\n        try:\n            sock.sendall(data)\n        except socket.error as e:\n            print('Send Failed...', e)\n            sys.exit(0)\n        print('Send Successfully')\n\n        res = sock.recv(4096)  # 获取服务器返回的数据，还可以用 recvfrom()、recv_into() 等\n        print(res)\n    sock.close()\n\nsock.sendall(data)这里也可用 send() 方法：不同在于 sendall() 在返回前会尝试发送所有数据，并且成功时返回 None，而 send() 则返回发送的字节数量，失败时都抛出异常。\n\n服务端过程：\n咱再来聊聊服务端的过程，服务端先初始化 Socket，建立流式套接字，与本机地址及端口进行绑定，然后通知 TCP，准备好接收连接，调用 accept() 阻塞，等待来自客户端的连接。如果这时客户端与服务器建立了连接，客户端发送数据请求，服务器接收请求并处理请求，然后把响应数据发送给客户端，客户端读取数据，直到数据交换完毕。最后关闭连接，交互结束。\nimport socket\nimport sys\n\nif __name__ == '__main__':\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # 创建 Socket 连接（TCP）\n    print('Socket Created')\n\n    try:\n        sock.bind(('127.0.0.1', 8001))  # 配置 Socket，绑定 IP 地址和端口号\n    except socket.error as e:\n        print('Bind Failed...', e)\n        sys.exit(0)\n\n    sock.listen(5)  # 设置最大允许连接数，各连接和 Server 的通信遵循 FIFO 原则\n\n    while True:  # 循环轮询 Socket 状态，等待访问\n        conn, addr = sock.accept()\n        try:\n            conn.settimeout(10)  # 如果请求超过 10 秒没有完成，就终止操作\n\n            # 如果要同时处理多个连接，则下面的语句块应该用多线程来处理\n            while True:  # 获得一个连接，然后开始循环处理这个连接发送的信息\n                data = conn.recv(1024)\n                print('Get value ' + data, end='\\n\\n')\n                if not data:\n                    print('Exit Server', end='\\n\\n')\n                    break\n                conn.sendall('OK')  # 返回数据\n        except socket.timeout:  # 建立连接后，该连接在设定的时间内没有数据发来，就会引发超时\n            print('Time out')\n\n        conn.close()  # 当一个连接监听循环退出后，连接可以关掉\n    sock.close()\n\nconn, addr = sock.accept()调用 accept() 时，Socket 会进入waiting状态。客户端请求连接时，方法建立连接并返回服务器。accept() 返回一个含有两个元素的元组 (conn, addr)。第一个元素 conn 是新的 Socket 对象，服务器必须通过它与客户端通信；第二个元素 addr 是客户端的 IP 地址及端口。\n\n\ndata = conn.recv(1024)接下来是处理阶段，服务器和客户端通过 send() 和 recv() 通信（传输数据）。服务器调用 send()，并采用字符串形式向客户端发送信息，send() 返回已发送的字符个数。服务器调用 recv() 从客户端接收信息。调用 recv() 时，服务器必须指定一个整数，它对应于可通过本次方法调用来接收的最大数据量。recv() 在接收数据时会进入blocked状态，最后返回一个字符串，用它表示收到的数据。如果发送的数据量超过了 recv() 所允许的，数据会被截短。多余的数据将缓冲于接收端，以后调用 recv() 时，会继续读剩余的字节，如果有多余的数据会从缓冲区删除（以及自上次调用 recv() 以来，客户端可能发送的其它任何数据）。传输结束，服务器调用 Socket 的 close() 关闭连接。\n\n从 TCP 连接的视角看 Socket 过程：\nTCP 三次握手的 Socket 过程：\n\n\n服务器调用 socket()、bind()、listen() 完成初始化后，调用 accept() 阻塞等待；\n客户端 Socket 对象调用 connect() 向服务器发送了一个 SYN 并阻塞；\n服务器完成了第一次握手，即发送 SYN 和 ACK 应答；\n客户端收到服务端发送的应答之后，从 connect() 返回，再发送一个 ACK 给服务器；\n服务器 Socket 对象接收客户端第三次握手 ACK 确认，此时服务端从 accept() 返回，建立连接。\n\n接下来就是两个端的连接对象互相收发数据。\nTCP 四次挥手的 Socket 过程：\n\n\n某个应用进程调用 close() 主动关闭，发送一个 FIN；\n另一端接收到 FIN 后被动执行关闭，并发送 ACK 确认；\n之后被动执行关闭的应用进程调用 close() 关闭 Socket，并也发送一个 FIN；\n接收到这个 FIN 的一端向另一端 ACK 确认。\n\n总结：\n上面的代码简单地演示了 Socket 的基本函数使用，其实不管有多复杂的网络程序，这些基本函数都会用到。上面的服务端代码只有处理完一个客户端请求才会去处理下一个客户端的请求，这样的服务器处理能力很弱，而实际中服务器都需要有并发处理能力，为了达到并发处理，服务器就需要 fork 一个新的进程或者线程去处理请求。\n\n                ", "mainLikeNum": ["24 "], "mainBookmarkNum": "74"}