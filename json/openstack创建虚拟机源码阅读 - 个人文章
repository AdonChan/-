{"title": "openstack创建虚拟机源码阅读 - 个人文章 ", "index": "python,源码分析,openstack", "content": "标签： openstack nova 源码阅读\n\n在openstack中,虚拟机的创建无疑是非常重要的,了解虚拟机创建流程并阅读nova模块关于创建虚拟机的源码对opensatck开发有很很大帮助,本篇文章将以openstack queens版本为基础.讲解创建虚拟机的源码.由于nova模块代码复杂,而且阅读源码所需知识较多,所以侧重于流程逻辑,源码阅读可能不够详尽指出.\nnova模块结构\n\n\nDB: 用于存储nova服务相关数据的SQL数据库，通常为MySQL\nAPI：接收HTTP请求的组件,处理请求并通过oslo.messaging队列或HTTP与其他组件通信\nScheduler: 决定虚拟机在哪个主机运行\nNetwork: 管理IP转发,桥接和vlans\nCompute: 管理虚拟机和虚拟机管理器直接的通信\nConductor: 处理需要协同的请求(创建/重建),作为数据库代理,或者处理对象转换\n\n创建虚拟机流程\n为了简便,这里省略了认证过程,实际上一个请求发送过来,还要经过认证和鉴权等过程,确保该用户有权限创建虚拟机.在openstack的wiki中给出创建一个虚拟的workflow,图有点大,但对于每个组件的工作内容写的非常详细我们可以把创建流程分成几个部分\n处理请求\n用户发送一个创建虚拟机的请求,Nova-Api接收到请求后,Nova-Api负责激活扩展插件,检查虚拟机名称,接收注入文件,提取新虚拟机的网络设置,检查配置和镜像等工作.然后Nova-Api将处理好的参数集以JSON文件通过HTTP请求发送给Nova的Compute－Api.然后向用户发送带有虚拟机预留ID的相应（这时的相应码202,提示虚拟机创建成功,但实际上虚拟机还未真正创建成功)Compute-Api在接收到请求后将会检查创建政策,进一步检查虚拟机,网络,镜像和配额,然后正式建立虚拟机的配置.接着在数据库中生成虚拟机的相应记录,而后通过消息队列发送请求让scheduler选择一个host来创建虚拟机.\n虚拟机调度和资源准备\nscheduler接收到消息后根据消息中filters对所有host进行过滤,最后选出某个host,然后跟新数据库,并通过消息队列向被选定的host发送创建虚拟机消息被选定的host接收到队列的消息后在数据库中更新虚拟机和任务的状态,然后通过nova network-api为虚拟机创建或获取网络.接着通过nova volume-api为虚拟机创建新的卷,决定虚拟机的块设备映射,并将卷挂载到虚拟机上此时虚拟机的调度和资源准备都以完成.\n在hypervisor上运行虚拟机\n被选定的host获取镜像,建立块设备映射,最后生成libvirt.xml最后执行hypervisor的spawn()方法,至此,虚拟机已经在host上运行了.最后一步是跟新虚拟机和任务的状态.\n源码阅读\n下面将根据虚拟机创建时调用的模块顺序阅读代码\nNova-Api\nNova-Api将处理不同类型的请求写成了各种controler类,而处理创建虚拟机的类被称为ServerControler\n# nova/api/openstack/compute/servers.py\nclass ServersController(wsgi.Controller):\n    \n    # 为了简明,省略了很多用于检查的装饰器\n    @wsgi.response(202)\n    def create(self, req, body):\n         \"\"\"Creates a new server for a given user.\"\"\"\n        context = req.environ['nova.context']\n        server_dict = body['server']\n        password = self._get_server_admin_password(server_dict)\n        name = common.normalize_name(server_dict['name'])\n        description = name\n        # create方法干的是些从请求中提取并检查参数的脏活\n        # 省略...\n        try:\n            # 依然是构建参数的代码...\n            \n            # 调用compute_api创建虚拟机\n            (instances, resv_id) = self.compute_api.create(context,\n                            inst_type,\n                            image_uuid,\n                            display_name=name,\n                            display_description=description,\n                            availability_zone=availability_zone,\n                            forced_host=host, forced_node=node,\n                            metadata=server_dict.get('metadata', {}),\n                            admin_password=password,\n                            requested_networks=requested_networks,\n                            check_server_group_quota=True,\n                            supports_multiattach=supports_multiattach,\n                            **create_kwargs)\n        # 错误处理...\ncompute-api\n# nova/compute/api.py\nclass API(base.Base):\n    def create(self, context, instance_type,\n               image_href, kernel_id=None, ramdisk_id=None,\n               min_count=None, max_count=None,\n               display_name=None, display_description=None,\n               key_name=None, key_data=None, security_groups=None,\n               availability_zone=None, forced_host=None, forced_node=None,\n               user_data=None, metadata=None, injected_files=None,\n               admin_password=None, block_device_mapping=None,\n               access_ip_v4=None, access_ip_v6=None, requested_networks=None,\n               config_drive=None, auto_disk_config=None, scheduler_hints=None,\n               legacy_bdm=True, shutdown_terminate=False,\n               check_server_group_quota=False, tags=None,\n               supports_multiattach=False):\n        \"\"\"准备实例创建工作，然后将实例信息发送至scheduler，\n        由scheduler计算host上创建和在DB创建记录。\n        \"\"\"\n        # preparation\n        \n        # 为了简介,所有参数简略为args和kwargs\n        self_create_instance(*args, **kwargs)\n        \n    def _create_instance(self, context, instance_type,\n               image_href, kernel_id, ramdisk_id,\n               min_count, max_count,\n               display_name, display_description,\n               key_name, key_data, security_groups,\n               availability_zone, user_data, metadata, injected_files,\n               admin_password, access_ip_v4, access_ip_v6,\n               requested_networks, config_drive,\n               block_device_mapping, auto_disk_config, filter_properties,\n               reservation_id=None, legacy_bdm=True, shutdown_terminate=False,\n               check_server_group_quota=False, tags=None,\n               supports_multiattach=False):\n        \"\"\"核查所有参数\"\"\"\n        # verifying\n        pass\n        \n        # 获取镜像信息\n        if image_href:\n            # if image_href is provied, get image via glance api\n            image_id, boot_meta = self._get_image(context, image_href)\n        else:\n            # if image_href is not proved, get image metadata from bdm\n            image_id = None\n            boot_meta = self._get_bdm_image_metadata(\n                context, block_device_mapping, legacy_bdm)\n        \n        # 继续检查参数\n        \n        # 由于block device mapping有两种版本,为了兼容,需要检查并在必要时转换\n         block_device_mapping = self._check_and_transform_bdm(context,\n            base_options, instance_type, boot_meta, min_count, max_count,\n            block_device_mapping, legacy_bdm)\n        \n        # go on checking\n        \n        # 为了支持cell特性,参见cell wiki\n        # https://docs.openstack.org/nova/ocata/cells.html\n        if CONF.cells.enable:\n            # 创建instance模型对象\n            # 检查quota\n            \n            # 调用rpc api将消息发送到队列\n            self.compute_task_api.build_instance(*args, **kwargs)\n        \n        else:\n            compute_task_api.schedule_and_build_instances(*args, **kwargs)\n        \n        \n        return instances, reservation_id\n调度和消息传递代码\nnova组件之间可以通过rpc api以消息队列通信,而最后的真正执行的任务的类都在manager.py文件中定义.这里我们方便理解省略调度代码\n# nova/conductor/api.py\nclass ComputeTaskAPI(object):\n    def schedule_and_build_instance(self, *args, **kwargs):\n        # very simple method\n        # call rpc api only\n        self.conductor_compute_rpc_api.schedule_and_build_instance(*args, **kwargs)\n\n# nova/conductor/rpcapi.py\nclass ComputeTaskAPI(object):\n    def schedule_and_build_instance(self, *args, **kwargs):\n        # 构建参数和api版本检查\n        # 最后将其发送到消息队列\n        cctxt.cast(context, 'schedule_and_build_instance', **kwargs)\nmanager代码\n# nova/compute/manager.py\nclass ComputeManager(object):\n    @wrap_exception()\n    @reverts_task_state\n    @wrap_instance_fault\n    def build_and_run_instance(self, *args, **kwargs):\n        # 给资源加锁,避免竞争\n        @utils.synchronized(instance.uuid)\n        def _locked_do_build_and_run_instance(*args, **kwargs):\n            with self._build_semaphore:\n                try:\n                    result = self._do_build_and_run_instance(*args, **kwargs)\n                # handle exceptions\n                pass\n        # 由于创建虚拟机的工作可能会持续很长时间,为了避免进程阻塞\n        # 将这个任务分发给某个worker\n        utils.spawn_n(_locked_do_build_and_run_instance,\n        context, instance, ...)\n\n    def _do_build_and_run_instance(self, *args, **kwargs):\n        # 更新虚拟机和任务状态\n        # 解码注入文件\n        try:\n            with timeutils.StopWatch() as timer:\n                self._build_and_run_instance(*args)\n        # handle exceptions\n    def _build_and_run_instance(self, *args, **kwargs):\n        # 获取 image ref\n        try:\n            scheduler_hints = self._get_scheduler_hints(filter_properties, request_spec)\n            rt = self._get_resource_tracker()\n            with rt.instance_claime(context, instance, node, limits):\n                # 获取群组策略和镜像metadata\n\n                # 通过调用_build_resources创建network和volume\n                with self._build_resources(*args) as resources:\n                    # handle vm and task state\n                    # spawn instance on hypervisor\n                    with timeuitls.StopWatch() as time:\n                        # 通过driver创建xml,然后真正运行虚拟机\n                        self.driver.spawn(*args, **kwargs)\n        # handle exceptions\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}