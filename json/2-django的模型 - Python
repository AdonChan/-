{"title": "2-django的模型 - Python ", "index": "django,python", "content": "2-django的模型\n概述：Django对各种数据库都提供了很好的支持，Django为这些数据库提供了统一的调用接口API，程序员可以根据自己的业务需求选择不同的数据库\nORM简介\n概述：对象-关系-映射\n作用： 根据类生成表结构；将对象、列表的操作转换成对应的SQL语句；将SQL语句查询到的结果转换为对象或者列表   \n优点：极大的减轻开发人员的工作量，不需要面对因数据库的变更而导致代码无效在修改代码， 防止sql注入攻击\n图解：\n定义模型\n模型、属性、表、字段之间的关系：一个模型在数据库中对应一张表，在模型中定义的属性对应该模型对照表中的一个字段\n创建模型类\n班级类\nclass Grade(models.Model):\n    name     = models.CharField(max_length=20)\n    boyNum   = models.IntegerField()\n    girlNum  = models.IntegerField()\n    isDelete = models.BooleanField(default=False)\n    def __str__(self):\n        return self.name\n学生类\nclass Student(models.Model):\n    name     = models.CharField(max_length=20)\n    sex      = models.BooleanField()\n    age      = models.IntegerField()\n    contend = models.CharField(max_length=40)\n    #  关联类名的小写或直接类名 Grade\n    grade    = models.ForeignKey(\"grade\")\n    isDelete = models.BooleanField(default=False)\n    def __str__(self):\n        return self.name\n字段类型和字段选项\n字段类型        \n        ·AutoField\n            ·一个根据实际ID自动增长的IntegerField，通常不指定如果不指定，一个主键字段将自动添加到模型中\n\n        ·CharField(max_length=字符长度)\n            ·字符串，默认的表单样式是 TextInput\n\n        ·TextField\n            ·大文本字段，一般超过4000使用，默认的表单控件是Textarea\n\n        ·IntegerField\n            ·整数\n\n        ·DecimalField(max_digits=None, decimal_places=None)\n            ·使用python的Decimal实例表示的十进制浮点数\n            ·参数说明\n                ·DecimalField.max_digits\n                    ·位数总数\n                ·DecimalField.decimal_places\n                    ·小数点后的数字位数\n\n        ·FloatField\n            ·用Python的float实例来表示的浮点数\n\n        ·BooleanField\n            ·true/false 字段，此字段的默认表单控制是CheckboxInput\n\n        ·NullBooleanField\n            ·支持null、true、false三种值\n\n        ·DateField(auto_now=False, auto_now_add=False)\n            ·使用Python的datetime.date实例表示的日期\n            ·参数说明\n                ·DateField.auto_now\n                    ·每次保存对象时，自动设置该字段为当前时间，用于\"最后一次修改\"的时间戳，它总是使用当前日期，                        默认为false\n                ·DateField.auto_now_add\n                    ·当对象第一次被创建时自动设置当前时间，用于创建的时间戳，它总是使用当前日期，默认为false\n            ·说明\n                ·该字段默认对应的表单控件是一个TextInput. 在管理员站点添加了一个JavaScript写的日历控件，和一                    个“Today\"的快捷按钮，包含了一个额外的invalid_date错误消息键\n            ·注意\n                ·auto_now_add, auto_now, and default 这些设置是相互排斥的，他们之间的任何组合会发生错误的结果\n\n        ·TimeField\n            ·使用Python的datetime.time实例表示的时间，参数同DateField\n\n        ·DateTimeField\n            ·使用Python的datetime.datetime实例表示的日期和时间，参数同DateField\n\n        ·FileField\n            ·一个上传文件的字段\n\n        ·ImageField\n            ·继承了FileField的所有属性和方法，但对上传的对象进行校验，确保它是个有效的image\n\n字段选项\n        ·概述\n            ·通过字段选项，可以实现对字段的约束\n            ·在字段对象时通过关键字参数指定\n\n        ·null\n            ·如果为True，Django 将空值以NULL存储到数据库中，默认值是 False\n\n        ·blank\n            ·如果为True，则该字段允许为空白，默认值是 False\n\n        ·注意\n            ·null是数据库范畴的概念，blank是表单验证证范畴的\n\n        ·db_column\n            ·字段的名称，如果未指定，则使用属性的名称\n\n        ·db_index\n            ·若值为 True, 则在表中会为此字段创建索引\n\n        ·default\n            ·默认值\n\n        ·primary_key\n            ·若为 True, 则该字段会成为模型的主键字段\n\n        ·unique\n            ·如果为 True, 这个字段在表中必须有唯一值\n\n\n模型之间的关系\n模型关系\n        ·分类\n            ·ForeignKey：一对多，将字段定义在多的端中\n            ·ManyToManyField：多对多，将字段定义在两端中\n            ·OneToOneField：一对一，将字段定义在任意一端中\n\n        ·用一访问多\n            ·格式\n                对象.模型类小写_set\n            ·示例\n                grade.students_set\n\n        ·用一访问一\n            ·格式\n                ·对象.模型类小写\n            ·示例\n                ·grade.students\n\n        ·访问id\n            ·格式\n                ·对象.属性_id\n            ·示例\n                ·student.sgrade_id\n元选项\n在模型类中定义一个Meta类，用于设置元信息\nclass Student(models.Model):\n    name     = models.CharField(max_length=20)\n    sex      = models.BooleanField()\n    age      = models.IntegerField()\n    contend = models.CharField(max_length=40)\n    #                            关联类名的小写\n    grade    = models.ForeignKey(\"grade\")\n    isDelete = models.BooleanField(default=False)\n    def __str__(self):\n        return self.name\n    class Meta():\n        db_table = \"students\"\n        ordering = [\"-id\"]\n属性\n\ndb_table: 定义数据表名，推荐使用类名小写，并且添加复数\nordering: 规定对象的默认排序字段 ; ordering = [\"id\"]: 正序; ordering = [\"-id\"]: 倒序;\n\n注意：排序会增加数据库的开销\n模型成员\nobjects对象\n概述： 是Manager类型的对象，用于与数据库进行交互； 当定义模型时没有指定管理器，则Django会为模型提供一个名为objects的管理器\n自定义模型管理器\nclass Student(models.Model):\n    #自定义模型管理器\n    myobject = models.Manager()\n    \n    name     = models.CharField(max_length=20)\n    sex      = models.BooleanField()\n    age      = models.IntegerField()\n    contend = models.CharField(max_length=40)\n    #                            关联类名的小写\n    grade    = models.ForeignKey(\"grade\")\n    isDelete = models.BooleanField(default=False)\n    def __str__(self):\n        return self.name\n    class Meta():\n        db_table = \"students\"\n        ordering = [\"-id\"]\n注意: 如果为模型指定了管理器，那么Django不再为模型类提供名为objects的管理器\n自定义模型管理器类\nclass StudentManager(models.Manager):\n    def get_queryset(self):\n        return super(StudentManager, self).get_queryset().filter(isDelete=False)\nclass Student(models.Model):\n    #自定义模型管理器\n    objects = StudentManager()\nget_queryset获取查询集(数据集)，自定义管理器类调用父类中的get_queryset方法后在进行过滤\n创建对象\n当创建对象时，Django不会对数据库进行读写操作。调用save()方法才与数据库进行交互，将对象存储到数据库中。__init__方法已经在基类models.Model中使用，在自定义模型类中无法使用\n在模型类中增加一个类方法:\nclass Student(models.Model):\n    #自定义模型管理器\n    objects = StudentManager()\n\n    name     = models.CharField(max_length=20)\n    sex      = models.BooleanField()\n    age      = models.IntegerField()\n    contend = models.CharField(max_length=40)                        \n    grade    = models.ForeignKey(Grade)\n    isDelete = models.BooleanField(default=False)\n    def __str__(self):\n        return self.name\n    class Meta():\n        db_table = \"students\"\n        ordering = [\"-id\"]\n   \n    #类方法，类可以直接调用  创建对象可以直接写 Student.create('ray',1,18,....)\n    @classmethod \n    def create(cls, name, sex, age, contend, grade):\n        return cls(name=name, sex=sex, age=age, contend=contend, grade=grade)\n在自定义模型器类中增加一个方法\nclass StudentManager(models.Manager):\n    def get_queryset(self):\n        return super(StudentManager, self).get_queryset().filter(isDelete=False)\n    def create(self, name, sex, age, contend, grade):\n        obj = self.model()\n        obj.name = name\n        obj.sex = sex\n        obj.age = age\n        obj.contend = contend\n        obj.grade = grade\n        return obj\n查询数据\n查询集：表示从数据库中获取的对象集合，查询集可以含有一个或者多个过滤器\n过滤器：基于所给的参数限制查询集的结果，得到新的查询集\n从SQL的角度，查询集合select语句等价，过滤器就像where和limit子句相似\n查询集\n在管理器上调用过滤器方法或者是其他数据查询集上调用过滤器方法得到新的查询集\n查询集经过过滤器筛选得到新的查询集，因此可以使用链式语法结构\n惰性查询：创建查询集不会带来任何的数据库访问，直到调用数据时，才会访问数据库\n什么时候对查询集求值？ 迭代、序列化、与if合用\n返回查询集的方法\nall()\n返回查询集的方法\ndef students(request):\n    stus = Student.objects.all()\n    return render(request, 'students.html', {\"stus\":stus})\nfilter()\n作用：将符合条件的数据过滤进来\n使用：filter(键1=值1, 键2=值2)；filter(键1=值1, 键2=值2)\ndef students(request):\n    stus = Student.objects.filter(age=20)\n    return render(request, 'students.html', {\"stus\":stus})\nexclude()\n作用: 将符合条件的数据过滤出去\ndef students(request):\n    stus = Student.objects.exclude(age=20)\n    return render(request, 'students.html', {\"stus\":stus})\norder_by()\n作用:排序\ndef students(request):\n    stus = Student.objects.order_by(\"age\")\n    return render(request, 'students.html', {\"stus\":stus})\ndef students(request):\n    stus = Student.objects.order_by(\"-age\")\n    return render(request, 'students.html', {\"stus\":stus})\nvalues()\n作用: 一个对象构成一个字典，然后构成一个列表返回\ndef students(request):\n    stus = Student.objects.values()\n    print(stus)\n    return render(request, 'students.html', {\"stus\":stus})\n返回单个值的方法\nget()\n作用: 返回单个满足条件的对象\ndef students(request):\n    #   pk代表主键\n    try:\n        stus = [Student.objects.get(age=20)]\n    except Student.DoesNotExist as e:\n        pass\n    except Student.MultipleObjectsReturned as e:\n        pass\n    return render(request, 'students.html', {\"stus\":stus})\n注意: 如果多条数据被返回，会引发 “类名.MultipleObjectsReturned” 异常;数据不存在会报 \"类名.DoesNotExist\" 异常\ncount()\n返回当前查询的总条数\nfirst()\n返回查询集中的第一个对象\nlast()\n返回查询集中的最后一个对象\nexists()\n判断查询集中是否有数据，如果有返回True，否则返回False\ndef students(request):\n    stus = Student.objects.filter(age=20)\n    if stus.exists():\n        return render(request, 'students.html', {\"stus\":stus})\n    else:\n        return HttpResponse(\"没有学生数据\")\n限制查询集\n查询集返回列表，可以使用下标的方式进行限制，等同于SQL中的limit和offset子句\n注意: 不支持负数索引; 使用下标后返回一个新的查询集，不会立即执行查询字段查询\ndef students(request):\n    stus = Student.objects.all()[5:10]#[0:5)\n    return render(request, 'students.html', {\"stus\":stus})\n字段查询\n概述\n实现where语句，作为filter()、exclude()、get()的参数\n语法 : 属性名称__比较运算符=值 (注意：里面有两个下划线)\n外键: 使用 “属性名_id” 表示原始的外键值\n转义: like语句中使用%，可以直接使用\n比较运算符\nexact: 表示判断相当，大小写敏感\ncontains: 是否包含，大小写敏感\n# 找描述中带有\"ray\"的所有学生\ndef students(request):\n    stus = Student.objects.filter(contend__icontains=\"sunck\")\n    return render(request, 'students.html', {\"stus\":stus})\nstartswith、endswith: 以value开头、结尾，大小写敏感\n# 找描述以ray开头的所有学生\ndef students(request):\n    stus = Student.objects.filter(contend__startswith=\"ray\")\n    return render(request, 'students.html', {\"stus\":stus})\niexact、icontains、istartswith、iendswith: 不区分大小写\nisnull, isnotnull : 是否为空, 是否为非空\nin : 包含在范围之内\n# 找id为2,5,8,9的学生\ndef students(request):\n    stus = Student.objects.filter(pk__in=[2,5,8,9])\n    return render(request, 'students.html', {\"stus\":stus})\ngt, gte, lt, lte\n# 找年龄大于等于20的所有学生\ndef students(request):\n    stus = Student.objects.filter(age__gte=20)\n    return render(request, 'students.html', {\"stus\":stus})\nyear、month、day、week_day、hour、minute、second： 对日期类型的属性进行运算\n跨关联关系的查询\n处理join查询：\n语法：关联的模型类名小写__属性名__比较运算符=值\n注意: __比较运算符 没有，表示等于; 可以反向使用，即关联的两个模型中都可以使用\n# 描述中带有ray的学生属于那些班级\ndef students(request):\n    grades = Grade.objects.filter(student__contend__contains=\"ray\")\n    print(grades)\n    stus = Student.objects.all()\n    return render(request, 'students.html', {\"stus\":stus})\n查询的快捷方式： pk pk表示主键，默认主键是id\n聚合函数\n注意： 使用aggregate()函数返回聚合函数的值\n函数： Avg、Count、Max、Min、Sum\n# 求所有人的年龄的和\nfrom django.db.models import Sum\ndef students(request):\n    age = Student.objects.aggregate(Sum(\"age\"))\n    print(\"***********\", age)\n    stus = Student.objects.all()\n    return render(request, 'students.html', {\"stus\":stus})\nF对象\n作用: 可以使模型中的A字段与B字段进行比较，如果A字段出现在等号的左侧，那么B字段使用F对象写在等号右侧\n# 找男生个数多于女生个数的班级\nfrom django.db.models import F\ndef students(request):\n    grades = Grade.objects.filter(boyNum__gt=F(\"girlNum\"))\n    print(grades)\n    stus = Student.objects.all()\n    return render(request, 'students.html', {\"stus\":stus})\nF对象可以进行数学运算\nfrom django.db.models import F\ndef students(request):\n    grades = Grade.objects.filter(boyNum__gt=F(\"girlNum\")*2)\n    print(grades)\n    stus = Student.objects.all()\n    return render(request, 'students.html', {\"stus\":stus})\nF对象还可以进行关联查询 模型类小写__属性名\n# 没有被删除的学生的班级\nfrom django.db.models import F\ndef students(request):\n    grades = Grade.objects.filter(isDelete=F(\"student__isDelete\"))\n    print(grades)\n    stus = Student.objects.all()\n    return render(request, 'students.html', {\"stus\":stus})\n对于data/time字段，可以进行timedelta()进行运算\nQ对象\n逻辑与\n# 年龄大于等于20且小于等于50的学生\ndef students(request):\n    stus = Student.objects.filter(age__gte=20,age__lte=50)\n    return render(request, 'students.html', {\"stus\":stus})\ndef students(request):\n    stus = Student.objects.filter(age__gte=20).filter(age__lte=50)\n    return render(request, 'students.html', {\"stus\":stus})\n\nfrom django.db.models import Q\ndef students(request):\n    stus = Student.objects.filter(Q(age__gte=20) & Q(age__lte=50))\n    return render(request, 'students.html', {\"stus\":stus})\n逻辑或\n# 获取年龄小于20或者年龄大于50的学生\nfrom django.db.models import Q\ndef students(request):\n    stus = Student.objects.filter(Q(age__lt=20) | Q(age__gt=50))\n    return render(request, 'students.html', {\"stus\":stus})\n逻辑非\n# 获取年龄不大于等于20的学生\ndef students(request):\n    stus = Student.objects.filter(age__lt=20)\n    return render(request, 'students.html', {\"stus\":stus})\n\nfrom django.db.models import Q\ndef students(request):\n    stus = Student.objects.filter(~Q(age__gte=20))\n    return render(request, 'students.html', {\"stus\":stus})\n注意： 过滤器函数中可以混合使用Q对象和关键字参数，所有参数条件都将and在一起，Q对象必须位于关键字参数的前面\ndef students(request):\n    stus = Student.objects.all()[5:10]#[0:5)\n    return render(request, 'students.html', {\"stus\":stus})\n模型关系\n1-1\n使用场景: 表的字段太多，需要拆分\n# 人\nclass Person(models.Model):\n    name = models.CharField(max_length=20)\n    age  = models.IntegerField()\n    # 关系存放在哪张表都可以\n    # 绑定身份证与人的一对一关系，默认情况下当删身份证时绑定的人也可以删除，通过on_delete属性设置\n    idCard = models.OneToOneField(IDCard)\n# 身份证\nclass IDCard(models.Model):\n    sex = models.BooleanField()\n    num = models.CharField(max_length=20)\n主表从表： 声明关系的表为从表\n级联数据获取：\n从获取主：\n\n关系是直接声明的，是一个显性的属性\n获取pk为1的人的身份证号\nper = Person.objects.get(pk=1)   print(per.idCard.num)\n\n主获取从：\n\n关系字段是隐性属性，对象.关系模型类名的小写\n获取身份证号是1的人的姓名\ncard = IDCard.objects.get(pk=1) print(card.person.name)\n\n\n1-n\n一对多，也就是外键。\n主表从表: 声明关系的表为从表(ForeignKey)。\n级联数据获取:\n\n从获取主: 关系是直接声明的，是一个显性的属性\n主获取从: 关系字段是隐性属性，对象.模型类小写_set\n\n#找到1班的所有学生\ngrade = Grade.objects.get(pk=1)\nprint(grade.student_set.all())\nm-n\n原理: 底层是通过两个外键实现，两个外键存在于另一张关系表中\n#多对多\nclass Buyer(models.Model):\n    name = models.CharField(max_length=20)\n    level = models.IntegerField()\nclass Product(models.Model):\n    name = models.CharField(max_length=20)\n    price = models.IntegerField()\n    #关系形成\n    buyers = models.ManyToManyField(Buyer)\n形成关系\ndef ptob(reqeust, p, b):\n    product = Product.objects.get(pk=p)\n    buyer   = Buyer.objects.get(pk=b)\n    #产生关联\n    product.buyers.add(buyer)\n    return HttpResponse(\"购买成功\")\n数据级联获取\n从获取主\n\n对象.显性属性，得到的是一个数据集合，可以进行过滤\n已知一件商品，获取该商品所有的购买者\nproduct = Product.objects.get(pk=1) print(product.buyers.all())\n\n主获取从:\n\n隐性属性 对象.关联类名小写_set 得到的是一个数据集合，可以进行过滤\n已知一个购买者，获取他所买的所有商品\nbuyer = Buyer.objects.get(pk=1) print(buyer.product_set.all())\n\n模型继承\n使用最原始的python类的继承方式\nclass Animal(models.Model):\n    name = models.CharField(max_length=20)\n    age  = models.IntegerField()\nclass Cat(Animal):\n    weight = models.IntegerField()\nclass Dog(Animal):\n    height = models.IntegerField()\n注意: 默认继承方式不是很合理\n\n父类也会对应一张表\n默认在父类中定义的字段会存在父类表中，子类的数据通过外键关联父表中数据，子类只有特殊的数据在子表中\n效率比较低\n\nDjango中的数据库模块提供了一个非常不错的功能，就是支持models的面向对象，可以在Meta类中指定是否抽象，然后继承\nclass Animal(models.Model):\n    name = models.CharField(max_length=20)\n    age  = models.IntegerField()\n    class Meta():\n        # 让该类抽象，抽象的父类不会再生产数据表\n        # 子类会继承父类中的通用数据，复制到子表中\n        abstract = True\nclass Cat(Animal):\n    weight = models.IntegerField()\nclass Dog(Animal):\n    height = models.IntegerField()\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "1"}