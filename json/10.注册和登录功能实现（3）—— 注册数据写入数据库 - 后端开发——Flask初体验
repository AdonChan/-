{"title": "10.注册和登录功能实现（3）—— 注册数据写入数据库 - 后端开发——Flask初体验 ", "index": "python,flask", "content": "现在数据获取到了，提示也有了，我们需要把注册的数据写入到数据库，这一步很简单，直接使用之前提到过的方法，但是我们不能直接把明文密码写入到数据库中，那样做是十分不安全的，我们需要将其加密之后再写进去，具体是用到werkzeug.security中的generate_password_hash这个函数，将字符串变成hash值。我们可以在User模型中重写__init__函数(或__setattr__)，当传入password自动调用generate_password_hash进行加密，如：\nclass Users(db.Model):\n    __tablename__ = 'users_info'\n    id = db.Column(db.Integer, primary_key=True, autoincrement=True)\n    username = db.Column(db.String(32), nullable=False)\n    password = db.Column(db.String(100), nullable=False)\n    register_time = db.Column(db.DateTime, nullable=False, default=datetime.now())\n    avatar_path = db.Column(db.String(256), nullable=False, default='images/doraemon.jpg')\n    \n    def __init__(self, *args, **kwargs):\n        self.username = kwargs.get('username')\n        self.password = generate_password_hash(kwargs.get('password'))\n这样每添加一个新用户，在init的时候就自动把密码转为hash值了，但是后续我们还得增加修改密码的功能，所以就直接简单点，在收到POST数据的时候就把密码加密，然后存入数据库中，此时注册的视图函数代码如下：\nfrom flask import Flask, render_template, request, flash, redirect, url_for\nfrom models import db, Users\nfrom werkzeug.security import generate_password_hash\nfrom exts import validate\nimport config\n\n...\n\n@app.route('/register/', methods=['GET', 'POST'])\ndef register():\n    if request.method == 'GET':\n        return render_template('register.html')\n    else:\n        username = request.form.get('username')\n        password1 = request.form.get('password1')\n        password2 = request.form.get('password2')\n        message = validate(username, password1, password2)\n        flash(message)\n        if '成功' in message:\n            new_user = Users(username=username, password=generate_password_hash(password1))\n            db.session.add(new_user)\n            db.session.commit()\n            return redirect(url_for('login'))\n        else:\n            return render_template('register.html')\n这里获取登录或注册成功的状态，使用了上一篇文章结尾说的方法，简化了代码量。\n实际上更简单的方法是，我们直接对传入的{{ message }}进行判断，如果带有'成功'字符串，就显示蓝色，否则就显示红色。上文主要是为了说明@app.context_processor这个装饰器，以及session和g对象的区别。\n那么同样的，登录的验证过程，就不能直接去拿数据库加密过的哈希和原始的密码对比了，我们用werkzeug.security的check_password_hash方法，它能验证哈希值是否与原始的密码是匹配的，然后修改validate函数如下：\nfrom models import Users\nfrom werkzeug.security import check_password_hash\n\n\ndef validate(username, password1, password2=None):\n    user = Users.query.filter(Users.username == username).first()\n    if password2:\n        if user:\n            return '用户名已经存在'\n        else:\n            if len(username) < 4:\n                return '用户名长度至少4个字符'\n            elif password1 != password2:\n                return '两次密码不一致'\n            elif len(password1) < 6:\n                return '密码长度至少6个字符'\n            else:\n                return '注册成功，请登录'\n    else:\n        if user:\n            if check_password_hash(user.password, password1):\n                return '登录成功'\n            else:\n                return '密码错误'\n        else:\n            return '用户名不存在'\n登录页面的视图函数如下：\n@app.route('/login/', methods=['GET', 'POST'])\ndef login():\n    if request.method == 'GET':\n        return render_template('login.html')\n    else:\n        username = request.form.get('username')\n        password = request.form.get('password')\n        message = validate(username, password)\n        if '成功' in message:\n            return redirect(url_for('home'))\n        else:\n            flash(message)\n            return render_template('login.html')\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "1"}