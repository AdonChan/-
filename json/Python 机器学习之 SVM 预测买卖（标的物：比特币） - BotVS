{"title": "Python 机器学习之 SVM 预测买卖（标的物：比特币） - BotVS ", "index": "python", "content": "Python入门简单策略 sklearn 机器学习库的使用\n\n什么是 SVM ？\n支持向量机/support vector machine (SVM)。\n当然首先看一下wiki.\nSupport Vector Machines are learning models used for classification: which individuals in a population belong where? So… how do SVM and the mysterious “kernel” work?\n\n好吧，故事是这样子的：\n在很久以前的情人节，大侠要去救他的爱人，但魔鬼和他玩了一个游戏。\n魔鬼在桌子上似乎有规律放了两种颜色的球，说：“你用一根棍分开它们？要求：尽量在放更多球之后，仍然适用。”\n\n于是大侠这样放，干的不错？\n\n然后魔鬼，又在桌上放了更多的球，似乎有一个球站错了阵营。\n\nSVM就是试图把棍放在最佳位置，好让在棍的两边有尽可能大的间隙。\n\n现在即使魔鬼放了更多的球，棍仍然是一个好的分界线。\n\n然后，在SVM 工具箱中有另一个更加重要的 trick。 魔鬼看到大侠已经学会了一个trick，于是魔鬼给了大侠一个新的挑战。\n\n现在，大侠没有棍可以很好帮他分开两种球了，现在怎么办呢？当然像所有武侠片中一样大侠桌子一拍，球飞到空中。然后，凭借大侠的轻功，大侠抓起一张纸，插到了两种球的中间。\n\n现在，从魔鬼的角度看这些球，这些球看起来像是被一条曲线分开了。\n\n再之后，无聊的大人们，把这些球叫做 「data」，把棍子 叫做 「classifier」, 最大间隙trick 叫做「optimization」， 拍桌子叫做「kernelling」, 那张纸叫做「hyperplane」。\n参考：\nPlease explain Support Vector Machines (SVM) like I am a 5 year old. : MachineLearning\nSupport Vector Machines explained well\nhttps://www.youtube.com/watch...\n\n[以上例子引用自 网络，侵删]\n\n一个 SVM 应用于 bitcoin trading 的 DEMO\n回测系统自带的库有实现语言 Python 2\nnumpy pandas TA-Lib scipy statsmodels sklearn cvxopt hmmlearn pykalman arch matplotlib\n\n实盘需要在托管者所在机器安装策略需要的库\nOK , Talk is cheap, Show code to you!\nfrom sklearn import svm\nimport numpy as np\n\ndef main():\n    preTime = 0\n    n = 0\n    success = 0\n    predict = None\n    pTime = None\n    marketPosition = 0\n    initAccount = exchange.GetAccount()\n    Log(\"Running...\")\n    while True:\n        r = exchange.GetRecords()\n        if len(r) < 60:\n            continue\n        bar = r[len(r)-1]\n        if bar.Time > preTime:\n            preTime = bar.Time\n            if pTime is not None and r[len(r)-2].Time == pTime:\n                diff = r[len(r)-2].Close - r[len(r)-3].Close\n                if diff > SpreadVal:\n                    success += 1 if predict == 0 else 0\n                elif diff < -SpreadVal:\n                    success += 1 if predict == 1 else 0\n                else:\n                    success += 1 if predict == 2 else 0\n                pTime = None\n                LogStatus(\"预测次数\", n, \"成功次数\", success, \"准确率:\", '%.3f %%' % round(float(success) * 100 / n, 2))\n        else:\n            Sleep(1000)\n            continue\n        inputs_X, output_Y = [], []\n        sets = [None, None, None]\n        for i in xrange(1, len(r)-2, 1):\n            inputs_X.append([r[i].Open, r[i].Close])\n            Y = 0\n            diff = r[i+1].Close - r[i].Close\n            if diff > SpreadVal:\n                Y = 0\n                sets[0] = True\n            elif diff < -SpreadVal:\n                Y = 1\n                sets[1] = True\n            else:\n                Y = 2\n                sets[2] = True\n            output_Y.append(Y)\n        if None in sets:\n            Log(\"样本不足, 无法预测 ...\")\n            continue\n        n += 1\n        clf = svm.LinearSVC()\n        clf.fit(inputs_X, output_Y)\n        predict = clf.predict(np.array([bar.Open, bar.Close]).reshape((1, -1)))\n        pTime = bar.Time\n        \n        Log(\"预测当前Bar结束:\", bar.Time, ['涨', '跌', '横'][predict])\n        if marketPosition == 0:\n            if predict == 0:\n                exchange.Buy(initAccount.Balance/2)\n                marketPosition = 1\n            elif predict == 1:\n                exchange.Sell(initAccount.Stocks/2)\n                marketPosition = -1\n        else:\n            nowAccount = exchange.GetAccount()\n            if marketPosition > 0 and predict != 0:\n                exchange.Sell(nowAccount.Stocks - initAccount.Stocks)\n                nowAccount = exchange.GetAccount()\n                marketPosition = 0\n            elif marketPosition < 0 and predict != 1:\n                while True:\n                    dif = initAccount.Stocks - nowAccount.Stocks\n                    if dif < 0.01:\n                        break\n                    ticker = exchange.GetTicker()\n                    exchange.Buy(ticker.Sell + (ticker.Sell-ticker.Buy)*2, dif)\n                    while True:\n                        Sleep(1000)\n                        orders = exchange.GetOrders()\n                        for order in orders:\n                            exchange.CancelOrder(order.Id)\n                        if len(orders) == 0:\n                            break\n                    nowAccount = exchange.GetAccount()\n                marketPosition = 0\n            if marketPosition == 0:\n                LogProfit(_N(nowAccount.Balance - initAccount.Balance, 4), nowAccount)\n                \n小样本测试 预测对的概率是 三分之一， 是不是很有趣！（预测情况分三种 涨、跌、横盘）原文链接 ： https://www.botvs.com/strateg...\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}