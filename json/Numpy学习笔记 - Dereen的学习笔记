{"title": "Numpy学习笔记 - Dereen的学习笔记 ", "index": "python", "content": "numpy是一个在Python中做科学计算的基础库，重在数值计算，也是大部分PYTHON科学计算库的基础库，多用于在大型、多维数组上执行数值运算。\n数组的定义\nimport numpy as np\n# numpy数组的定义方法\na = np.arange(1, 6， 2)\nb = np.array([1, 3, 5])\nc = np.array(range(1, 6， 2))\n\n# 这样产生的a,b,c三个结果是一样的，均为[1, 3, 5]\n# 这里看一下数组的类型和数组元素的类型的定义和修改，type（a）表示的是数组a的类型，a.dtype则表示的是数组a中元素的类型。\nIn [1]: import numpy as np\nIn [2]: a = np.array([1, 2, 3])\nIn [3]: print(a, type(a), a.dtype)\n          [1 2 3] <class 'numpy.ndarray'> int32\nIn [4]: a = np.array([1, 2, 3], dtype = \"float64\")\nIn [5]: print(a, type(a), a.dtype)\n          [1. 2. 3.] <class 'numpy.ndarray'> float64\nIn [6]: a = a.astype(\"int64\")\nIn [7]: print(a, type(a), a.dtype)\n          [1 2 3] <class 'numpy.ndarray'> int64\n\n#要保留固定位数的小数需要用到np.round()\nIn [1]: import random\nIn [2]: import numpy as np\nIn [3]: \"%.2f\"%random.random()\nOut[3]: '0.56'\nIn [4]: round(random.random(), 2)\nOut[4]: 0.73\nIn [5]: a = np.round(np.array([random.random() for i in range(10)]), 2)\nIn [6]: a\nOut[6]: array([0.7 , 0.95, 0.6 , 0.03, 0.27, 0.96, 0.17, 0.48, 0.3 , 0.23])\nIn [7]: np.round(a, 1)\nOut[7]: array([0.7, 1. , 0.6, 0. , 0.3, 1. , 0.2, 0.5, 0.3, 0.2])\n数组的形状\n以下的代码是在Jupyter Notebook中完成的：\n# 数组的形状\nIn [1]: import numpy as np\nIn [2]: a = np.array([[[1,2,3],[4,5,6]],[[7,8,9],[10,11,12]]])\nIn [3]: a\nOut[3]: array([[[ 1, 2, 3],\n                [ 4, 5, 6]],\n                [[ 7, 8, 9],\n                [10, 11, 12]]])\nIn [4]: a.shape\nOut[4]: (2, 2, 3)\n# 上面元组中的元素个数即是这个数组的维数，例如这个就是个三维数组，他一共有 2 块，每块有 2 行， 3 列，即（2， 2， 3）\nIn [5]: a.reshape((3, 4))\nOut[5]: array([[ 1, 2, 3, 4],\n               [ 5, 6, 7, 8],\n               [ 9, 10, 11, 12]])\nIn [6]: a.reshape((12,))\nOut[6]: array([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\nIn [7]: a\nOut[7]: array([[[ 1, 2, 3],\n                  [ 4, 5, 6]],\n                [[ 7, 8, 9],\n                [10, 11, 12]]])\n# 从这里看以看出a.reshape并不能改变a的形状和维度，如果需要改变a的维度和形状，需要重新对a进行赋值，如下↓：\nIn [8]: a = a.reshape((4,3))\nIn [9]: a\nOut[9]: array([[ 1, 2, 3],\n               [ 4, 5, 6],\n               [ 7, 8, 9],\n               [10, 11, 12]])\n# 计算一个二维数组的元素个数，可以使用如下的方法，shape[0]是这个二维数组的行数，shape[1]即是这个数组的列数。\nIn [10]: a.shape[0] * a.shape[1]\nOut[10]: 12\n# 所以将一个二维数组变为一维数组便有了如下的方法：\nIn [11]: a = a.reshape((a.shape[0] * a.shape[1],))\nIn [12]: a\nOut[12]: array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12])\n# 当然一个现成简单的方法是使用flatten这个函数\nIn [13]: a.flatten()\nOut[13]: array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12])\n数组的计算\n# 数组直接对一个数进行加减乘除，产生的结果是数组中的每个元素都会加减乘除这个数。\nIn [14]: a * 2\nOut[14]: array([[ 2, 4, 6],\n                [ 8, 10, 12],\n                [14, 16, 18],\n                [20, 22, 24]])\nIn [15]: a / 0\n    D:\\Anaconda3\\lib\\site-packages\\ipykernel\\__main__.py:1: RuntimeWarning: divide by zero           encountered in true_divide\n      if __name__ == '__main__':\nOut[15]: array([[inf, inf, inf],\n                [inf, inf, inf],\n                [inf, inf, inf],\n                [inf, inf, inf]])\n# 接下来我们看一下数组与数组之间的计算\nIn [17]: b = np.arange(12,24).reshape((4,3))\nIn [18]: b\nOut[18]: array([[12, 13, 14],\n                [15, 16, 17],\n                [18, 19, 20],\n                [21, 22, 23]])\nIn [19]: a + b\nOut[19]: array([[13, 15, 17],\n                [19, 21, 23],\n                [25, 27, 29],\n                [31, 33, 35]])\nIn [20]: c = np.array([1,2,3])\nIn [21]: a+c\nOut[21]: array([[ 2, 4, 6],\n                [ 5, 7, 9],\n                [ 8, 10, 12],\n                [11, 13, 15]])\nIn [22]: d = np.arange(10,14).reshape((4,1))\nIn [23]: d\nOut[23]: array([[10],\n                [11],\n                [12],\n                [13]])\nIn [24]: a + d\nOut[24]: array([[11, 12, 13],\n                [15, 16, 17],\n                [19, 20, 21],\n                [23, 24, 25]])\n# 从上面可以看出，和线性代数中不同的是，m*n列的m行的一维数组或者n列的一维数组也是可以计算的。\n\n# 要求数组中所有元素的和或者每行或者每列的和应该怎么做？我们可以使用np.sum()函数\nIn [17]: c = a + d\nIn [18]: c\nOut[18]: array([[11, 12, 13],\n               [15, 16, 17],\n               [19, 20, 21],\n               [23, 24, 25]])\nIn [19]: np.sum(c)\nOut[19]: 216\nIn [20]: np.sum(c, axis = 0)\nOut[20]: array([68, 72, 76])\nIn [21]: np.sum(c, axis = 1)\nOut[21]: array([36, 48, 60, 72])\n\n这是为什么呢？这里要提到numpy的广播原则：\n如果两个数组的后缘维度(从末尾开始算起的维度)的轴长度相符或其中一方的长度为1，则认为它们是广播兼容的。广播会在缺失维度和(或)轴长度为1的维度上进行。\n在上面的代码中，a的维度是（4，3），c的维度是（1，3）；d的维度是（4，1）。所以假设有两个数组，第一个的维度是（x_1, y_1, z_1），另一个数组的维度是（x_2, y_2, z_2），要判断这两个数组能不能进行计算，可以用如下方法来判断：\nif z_1 == z_2 or z_1 == 1 or z_2 == 1:\n    if y_1 == y_2 or y_1 == 1 or y_2 == 1:\n        if x_1 == x_2 or x_1 == 1 or x_2 == 1:\n            可以运算\n        else:\n            不可以运算\n    else:\n        不可以运算\nelse:\n    不可以运算\n这里需要注意：（3，3，2）和（3，2）是可以运算的，因为对于二维数组（3，2）也可以表示为（1，3，2），套用上述的规则是完全适用的，同理：（4，2，5，4）和（2，1，4）也是可以进行运算的。\n轴(axis)\n在numpy中可以理解为方向,使用0,1,2...数字表示,对于一个一维数组,只有一个0轴,对于2维数组(shape(2,2)),有0轴和1轴,对于三维数组(shape(2,2, 3)),有0,1,2轴。\n二维数组的轴如下图所示：\n\n三维数组的轴：\n\nnumpy读数据\n使用如下语句来读取CSV文件：`np.loadtxt(fname,dtype=np.float,delimiter=None,skiprows=0,usecols=None,unpack=False)`\n数组转置：（两种方法）\n\n.transpose()\n.swapaxes(1， 0)\n\n取数组中的值\nimport numpy as np\n\nus_file_path = \"./youtube_video_data/US_video_data_numbers.csv\"\nuk_file_path = \".\\youtube_video_data\\GB_video_data_numbers.csv\"\n\nt1 = np.loadtxt(us_file_path, delimiter=\",\", dtype=\"int64\")\nprint(t1)\n\nprint(\"*\" * 100)\n# 取行\n# print(t1[2])\n# print(t1[2,])\n\n# 取连续的多行\n# print(t1[2:])\n# print(t1[2: ,])\n\n# 取不连续的多行\n# print(t1[[2, 9, 3]])\n# print(t1[[2, 9, 3],])\n\n# 取列\n# print(t1[:,2])\n\n# 取连续的多列\n# print(t1[:,2:])\n\n# 取不连续的多列\n# print(t1[:, [0, 2]])\n\n# 取元素\n# print(t1[1, 3])\n\n# 取连续多行和多列\n# print(t1[1:4, 1:4])\n\n# 取多个不相邻的点（0，1）， （2， 2）， （2， 3）\n# print(t1[[0, 1, 2], [2, 2, 3]])\nnumpy中数值修改\n# 取值然后赋值即可\nIn [1]: import numpy as np\n\nIn [2]: t2 = np.arange(24).reshape(4, 6)\n\nIn [3]: t2\nOut[3]:\narray([[ 0,  1,  2,  3,  4,  5],\n       [ 6,  7,  8,  9, 10, 11],\n       [12, 13, 14, 15, 16, 17],\n       [18, 19, 20, 21, 22, 23]])\n\nIn [4]: t2<10\nOut[4]:\narray([[ True,  True,  True,  True,  True,  True],\n       [ True,  True,  True,  True, False, False],\n       [False, False, False, False, False, False],\n       [False, False, False, False, False, False]])\n\nIn [5]: t2[t2<10] = 3\n\nIn [6]: t2\nOut[6]:\narray([[ 3,  3,  3,  3,  3,  3],\n       [ 3,  3,  3,  3, 10, 11],\n       [12, 13, 14, 15, 16, 17],\n       [18, 19, 20, 21, 22, 23]])\n\nIn [7]: np.where(t2<10, 0, 10)\nOut[7]:\narray([[ 0,  0,  0,  0,  0,  0],\n       [ 0,  0,  0,  0, 10, 10],\n       [10, 10, 10, 10, 10, 10],\n       [10, 10, 10, 10, 10, 10]])\nclip操作\nt.clip(10, 12)\n# 这句话的意思是将数组t中小于10的数变为10，大于12的数变为12\n拼接操作和换行换列操作\nIn [12]: a = np.arange(12).reshape(4,3)\n\nIn [13]: b = np.arange(12,24).reshape(4,3)\n\nIn [14]: a\nOut[14]:\narray([[ 0,  1,  2],\n       [ 3,  4,  5],\n       [ 6,  7,  8],\n       [ 9, 10, 11]])\n\nIn [15]: b\nOut[15]:\narray([[12, 13, 14],\n       [15, 16, 17],\n       [18, 19, 20],\n       [21, 22, 23]])\n# 竖直拼接\nIn [17]: np.vstack((a,b))\nOut[17]:\narray([[ 0,  1,  2],\n       [ 3,  4,  5],\n       [ 6,  7,  8],\n       [ 9, 10, 11],\n       [12, 13, 14],\n       [15, 16, 17],\n       [18, 19, 20],\n       [21, 22, 23]])\n# 水平拼接\nIn [18]: np.hstack((a,b))\nOut[18]:\narray([[ 0,  1,  2, 12, 13, 14],\n       [ 3,  4,  5, 15, 16, 17],\n       [ 6,  7,  8, 18, 19, 20],\n       [ 9, 10, 11, 21, 22, 23]])\n\n# 两行互换\nOut[21]: 0\n\nIn [22]: a[[0,1],:] = a[[1,0],:]\n\nIn [23]: a\nOut[23]:\narray([[ 0,  1,  2],\n       [ 3,  4,  5],\n       [ 6,  7,  8],\n       [ 9, 10, 11]])    \n将一维行向量转置为一维列向量的办法：.reshape(-1， 1）\n构造全为0或1的包含n个元素的一维向量的方法：\n# 列向量\nnp.zeros((n, 1))\nnp.ones((n, 1))\n# 行向量\nnp.zeros((1, n))\nnp.ones((1, n))\nnumpy生成全0矩阵、全1矩阵、单位矩阵的方法以及求每行/列最大最小值的方法。\nIn [1]: import numpy as np\nIn [2]: np.zeros((4, 3))\nOut[2]: array([[0., 0., 0.],\n               [0., 0., 0.],\n               [0., 0., 0.],\n               [0., 0., 0.]])\nIn [3]: np.ones((4, 3))\nOut[3]: array([[1., 1., 1.],\n               [1., 1., 1.],\n               [1., 1., 1.],\n               [1., 1., 1.]])\nIn [5]: a = np.eye(4)\nIn [6]: a\nOut[6]: array([[1., 0., 0., 0.],\n               [0., 1., 0., 0.],\n               [0., 0., 1., 0.],\n               [0., 0., 0., 1.]])\nIn [7]: np.argmax(a, axis = 0)\nOut[7]: array([0, 1, 2, 3], dtype=int64)\nIn [8]: np.argmin(a, axis = 1)\nOut[8]: array([1, 0, 0, 0], dtype=int64)\nnumpy生成随机数的方法\nnp.random.后加下列参数（.seed()的使用方法是先进行np.random.seed(s)再进行上述操作）\n\n\n参数\n解释\n\n\n\n.rand(d0, d1, ..., dn)\n创建d0-dn维度的均匀分布的随机数数组，浮点数，范围0-1\n\n\n.randn(d0, d1, ..., dn)\n创建d0-dn维度的标准正态分布随机数，浮点数，平均数0，标准差1\n\n\n.randint(low, high, (shape))\n从给定上下限范围内随机取整数，形状是shape\n\n\n.uniform(low, high, (size))\n产生具有均匀分布的数组(浮点数)，low起始值，high结束值，size形状\n\n\n.normal(loc, scale, (size))\n从指定正态分布中随机抽取样本，分布中心是loc（概率分布的均值），标准差是scale，形状是size\n\n\n.seed(s)\n随机数种子，s是给定的种子值。因为计算机生成的是伪随机数，所以通过设定相同的随机数种子，可以每次生成相同的随机数\n\n\n\nnumpy数组的复制\n\n\na = b[:]：视图的操作，会创建新的对象a，但是a的数据完全由b保管，改变b同时会引起a的改变；\n\na = b.copy()：复制，a和b互不影响。\n\nIn [1]: import numpy as np\nIn [2]: a = np.random.randint(0, 20, (4, 4))\nIn [3]: a\nOut[3]: array([[ 1, 6, 5, 2],\n               [ 8, 12, 13, 8],\n               [19, 13, 9, 1],\n               [ 8, 2, 5, 5]])\nIn [4]: b = a[0:2,0:2]\nIn [5]: b\nOut[5]: array([[ 1, 6, 5],\n               [ 8, 12, 13],\n               [19, 13, 9]])\nIn [6]: a[0, 0] = 0\nIn [7]: a\nOut[7]: array([[ 0, 6, 5, 2],\n               [ 8, 12, 13, 8],\n               [19, 13, 9, 1],\n               [ 8, 2, 5, 5]])\nIn [8]: b\nOut[8]: array([[ 0, 6, 5],\n               [ 8, 12, 13],\n               [19, 13, 9]])\nnan和inf\nnan(NAN,Nan):not a number表示不是一个数字，inf表示无穷大，-inf表示负无穷大。\n什么时候numpy中会出现nan：当我们读取本地的值的类型为float的文件，有缺失的时候；或者当做了一个不合适的计算(比如无穷大(inf)减去无穷大)的时候，这个地方的值就会变成nan。\n指定nan或者inf的方法：a[:] = np.nan;a[:] = np.inf\n关于nan需要注意的地方：\n\n两个nan是不相等的\n利用（1）中的特性可以统计出一个数组中包含nan的个数\n\nIn [1]: import numpy as np\n# 创建一个不含0的5阶非0方阵\nIn [2]: a = np.random.randint(1, 20, (5, 5))\nIn [3]: a\nOut[3]: array([[12, 11, 2, 16, 16],\n               [19, 9, 7, 19, 8],\n               [14, 1, 2, 11, 12],\n               [ 5, 13, 15, 5, 13],\n               [ 6, 12, 4, 13, 6]])\n# np.count_nonzero()这个函数用来统计数组中的非0值得个数\nIn [4]: np.count_nonzero(a)\nOut[4]: 25\n# 将数组的第3行全部变为0\nIn [5]: a[2,:] = 0\nIn [6]: a\nOut[6]: array([[12, 11, 2, 16, 16],\n[19, 9, 7, 19, 8],\n[ 0, 0, 0, 0, 0],\n[ 5, 13, 15, 5, 13],\n[ 6, 12, 4, 13, 6]])\nIn [8]: np.count_nonzero(a)\n# count_nonzero()的结果从25变为20\nOut[8]: 20\n# 因为nan的数值类型是float，而我们生成的数组类型为int，所以先把数组的类型转化为float\nIn [10]: a = a.astype(float)\n# 将下面3个元素的值变为nan\nIn [11]: a[[1, 2, 3],[0, 3, 4]] = np.nan\nIn [12]: a\nOut[12]: array([[12., 11., 2., 16., 16.],\n                [nan, 9., 7., 19., 8.],\n                [ 0., 0., 0., nan, 0.],\n                [ 5., 13., 15., 5., nan],\n                [ 6., 12., 4., 13., 6.]])\n# 因为np.nan！=np.nan，所以在值为nan的位置会出现True，其他位置则会出现false\nIn [13]: a!=a\nOut[13]: array([[False, False, False, False, False],\n                [ True, False, False, False, False],\n                [False, False, False, True, False],\n                [False, False, False, False, True],\n                [False, False, False, False, False]])\n# 与a!=a等价的还有一种方法即np.isnan(a)他的结果也是上述这个数组\nIn [15]: np.count_nonzero(a!=a)\n# 于是np.count_nonzero(a!=a)又可以写为np.count_nonzero(np.isnan(a))\nOut[15]: 3\nIn [16]: (a!=a).astype(int)\n# True的值即为1，False的值为0，所以non_zero()函数可以统计一个数组中包含nan的个数\nOut[16]: array([[0, 0, 0, 0, 0],\n                [1, 0, 0, 0, 0],\n                [0, 0, 0, 1, 0],\n                [0, 0, 0, 0, 1],\n                [0, 0, 0, 0, 0]])\n那么我们为什么要统计数组中nan的个数？\nnumpy中常用统计函数\n\n\n类型\n函数\n\n\n\n求和\nt.sum(axis=None)\n\n\n均值\nt.mean(a,axis=None)  受离群点的影响较大\n\n\n中值\nnp.median(t,axis=None)\n\n\n最大值\nt.max(axis=None)\n\n\n最小值\nt.min(axis=None)\n\n\n极值\nnp.ptp(t,axis=None) 即最大值和最小值之差\n\n\n标准差\nt.std(axis=None)\n\n\n\n那么如何将数组中值为nan 的元素换为该列/行的均值？\nimport numpy as np\n\n\ndef fill_ndarray(t):\n    for i in range(t.shape[1]):\n        temp_col = t[:, i]          # 当前列\n        nan_num = np.count_nonzero(np.isnan(temp_col))          # 计算当前列中nan的个数\n        if nan_num != 0:\n            # 计算均值\n            temp_non_nan_col = temp_col[temp_col == temp_col]\n            temp_col_mean = temp_non_nan_col.mean()\n            # 替换当前列中nan为均值\n            temp_col[np.isnan(temp_col)] = temp_col_mean\n    return t\n\n\na = np.arange(12).reshape(4, 3).astype(float)\n\na[2, 1:3] = np.nan\n\nprint(a)\nprint(\"*\" * 100)\nprint(fill_ndarray(a))\n\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "1"}