{"title": "Python之迭代器（iterator） - 盐字 ", "index": "python,迭代器,python-迭代器", "content": "迭代器（iterator）\n\n一个表示数据流的对象。反复调用迭代器的__next__()方法（或给它传递内建函数（built-in function）next()）来返回在该流中的后继项。当没有可用数据时，产生一个StopInteration异常。此时，迭代器对象被耗尽，之后再调用 __next__()方法只会再次产生StopInteration异常。迭代器要求包含一个__iter__()方法，用于返回迭代器对象本身，因此每一个迭代器也都是可迭代的，这可被用于大多数接受可迭代（对象）的场景。一个值得注意的例外是试图多重迭代传递的代码。一个容器对象（比如说list），每次给它传递iter()函数或使用for循环时，产生一个新的迭代器。在一个迭代器中如此尝试，通过上一个迭代的传递，同样会产生耗尽的迭代器对象，这使它看起来像是一个空容器。\n\n来自：Glossary — Python 3.4.2 documentation中的 iterator 部分\n\n迭代器类型（Iterator Types）\n\nPython支持一个容器之上的迭代的的概念。这由两个截然不同的方法实现，它们被用于让用户定义的类（user-defined classes）支持迭代。序列（Sequences），总是支持迭代方法，下面会详细描述。\n\n在容器对象中需要定义一个方法来提供迭代支持：\n\ncontainer.__iter__()\n返回一个迭代器对象。此对象要求能支持下面描述的迭代协议。如果一个容器支持不同类型的迭代，额外的方法可被提供，来为这些不同类型请求指定的迭代器。（一个对象支持多种形式的迭代的，就像树结构支持广度优先和深度优先遍历一样。）该方法对应于Python/C API中的Python对象的类型结构的tp_iter槽（slot）。\n\n迭代器对象本身要求支持以下组成迭代器协议的两个方法：\n\niterator.__iter__()\n返回迭代器对象本身。这是必需的，以让它可以在容器和迭代器中使用for语句和in语句。该方法对应于Python/C API中的Python对象的类型结构的tp_iter槽。\n\niterator.__next__()\n从容器中返回下一项。如果没有，引发StopIteration异常。该方法对应于Python/C API中的Python对象的类型结构的tp_iternext槽。\n\nPython定义了多种迭代器对象来支持在通用的和特定的序列类型、字典和其他特定的形式之上的迭代。这些特定类型处于迭代器协议实现之外的东西，并不重要。\n\n一旦一个迭代器的__next__()方法引发StopIteration，在子序列调用中也必须这样做。不遵守这个属性的实现被认为是失效的。\n\n来自：4. Built-in Types — Python 3.4.2 documentation中的 Iterator Types 部分\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "3"}