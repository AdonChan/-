{"title": "生成器进化到协程 Part 1 - 夜雨秋灯录 ", "index": "生成器,协程,python", "content": "前言\n这篇文章大部分来自 David Beazley 在 PyCon 2014 的 PPT 《Generators: The Final Frontier》。这个PPT很长而且非常烧脑，建议在阅读前应了解 Python 的生成器与携程相关知识，推荐《流畅的 Python》。\n\nDavid Beazley 的博客\n\nPPT 下载链接\n\n\n生成器（generator）\n使用 yield 来定义一个生成器\ndef countdown(n):\n    while n > 0:\n        yield n\n        n -= 1\n    \nc = countdown(10)\nc\n<generator object countdown at 0x0000021F5EAB9F10>\n生成器可用于迭代\nfor x in countdown(10):\n    print('倒数：', x)\n倒数： 10\n倒数： 9\n倒数： 8\n倒数： 7\n倒数： 6\n倒数： 5\n倒数： 4\n倒数： 3\n倒数： 2\n倒数： 1\n可以通过 next() 来一步步地让生成器 yield 一个值，直到函数迭代器结束并抛出 StopIteration。如果你对这一头雾水，建议阅读《Fluent Python》14.4 章。这里 for 其实相当于不断地调用 next 并处理 StopIteration\nc = countdown(3)\n\n# next(c)\n3\n# next(c)\n2\n# next(c)\n1\n把生成器当作管道\n你可以嵌套生成器，这会导致类似于 Unix 命令行管道的效果\ndef add_A(seq):\n    for item in seq:\n        yield item + '-A'\n\ndef add_B(seq):\n    for item in seq:\n        yield item + '-B'\n\ndef add_C(seq):\n    for item in seq:\n        yield item + '-C'\n        \nseq = ['apple', 'banana', 'orange']\n\nstacked_generator = add_C(add_B(add_A(seq)))\n\nfor item in stacked_generator:\n    print(item)\napple-A-B-C\nbanana-A-B-C\norange-A-B-C\n可以看到，我们为 seq 里的每项都依次添加了一个 tag。\nyield 可以接受传值\nyield 的作用是向调用者返回一个值，调用者其实也可以向生成器传值。\ndef receiver():\n    while True:\n        received_item = yield\n        print('收到：', received_item)\n\ndef caller():\n    recv = receiver()\n    next(recv) # 使生成器前进到 yield\n    for i in 'abcd':\n        recv.send(i)\n        \ncaller()\n收到： a\n收到： b\n收到： c\n收到： d\n那 send 函数的返回值是什么呢？\ndef receiver():\n    call_times = 0\n    while True:\n        item = yield call_times\n        print('收到：', item)\n        call_times += 1\n        \ndef caller():\n    recv = receiver()\n    next(recv)\n    for i in 'abcd':\n        ret_value = recv.send(i)\n        print('返回值: ', ret_value)\n        \ncaller()\n收到： a\n返回值:  1\n收到： b\n返回值:  2\n收到： c\n返回值:  3\n收到： d\n返回值:  4\n所以 send 可以向生成器传值的同时会让生成器前进到下一个 yield 语句，并将 yield 右侧的值作为返回值。\n生成器 101\n\n\nyield 用于定义生成器函数\n只要 yield 存在该函数必定是一个生成器\n调用该函数返回一个生成器\n\n让一个生成器前进\n使用 next 使一个生成器前进到下一个 yield 语句处，并将产出值（yielded value）作为其返回值。使用 gen.__next__()效果相同。\n注意：这是一个新创建的生成器唯一允许的操作。\ndef generator():\n    yield 'a'\n    yield 'b'\n    \ngen = generator()\n\n# next(gen)\n'a'\n# next(gen)\n'b'\n给生成器传值\n可以通过调用生成器的 send 方法来向生成器传值，这将让生成器从上次暂停的 yield 前进到下个 yield，并将产出值作为 send 的返回值。\ndef generator():\n    item = yield 'a'\n    print(item)\n    another_item = yield 'b'\n    \ngen = generator()\nprint(next(gen))\nprint(gen.send(1))\na\n1\nb\n关闭一个生成器\n通过调用生成器 close 方法可以生成器在 yield 语句处抛出 GeneratorExit。这时仅允许 return，如果没有捕捉这个错误，生成器会静默关闭，不抛出错误。\ndef generator():\n    times = 0\n    while True:\n        yield times\n        times += 1\n            \ngen = generator()\nprint(next(gen))\nprint(next(gen))\ngen.close() # 不会抛出错误\n0\n1\n抛出错误\n调用生成器的 throw 方法可以在 yield 处抛出某个特定类型的错误，如果生成器内部可以捕捉这个错误，那生成器将前进到下个 yield 语句处，并将产出值作为 throw 的返回值，否则中止生成器。throw 的函数签名如下：\nthrow(typ, [,val, [,tb]])\n其中 tyb 是某错误类型，val是错误信息，tb 为 traceback。更多信息可以参考官方的PEP0342\ndef generator():\n    try:\n        yield 'apple'\n    except RuntimeError as e:\n        print('捕捉到：', e)\n    yield 'banana'\n    \n\ngen = generator()\nprint(next(gen))\nprint(gen.throw(RuntimeError, '运行错误'))\napple\n捕捉到： 运行错误\nbanana\n生成器返回值\n如果在生成器函数中加上 return 那在运行到 return 时将会把返回值作为 StopIteration 的值传递出去。这个是 Python3 的特性，Python2 生成器不能返回某个值。\ndef generator():\n    yield\n    return 'apple'\n    \ng = generator()\nnext(g)\ntry:\n    next(g)\nexcept StopIteration as e:\n    print(e)\napple\n生成器委托\n使用 yield from 可以帮你对一个生成器不断调用 next 函数，并返回生成器的返回值。言下之意是你可以在生成器里调用生成器。\ndef generator():\n    yield 'a'\n    yield 'b'\n    return 'c'\n    \ndef func():\n    result = yield from generator()\n    print(result)\n调用 func 结果是返回一个生成器\n# func()\n<generator object func at 0x0000021F5EB0F990>\n\n# next(func())\n'a'\n另外一个例子\ndef chain(x, y):\n    yield from x\n    yield from y\n    \na = [1, 2, 3]\nb = [4, 5, 6]\n\nfor i in chain(a, b):\n    print(i, end=' ')\n1 2 3 4 5 6 \nc = [7, 8, 9]\nfor i in chain(a, chain(b, c)):\n    print(i, end=' ')\n1 2 3 4 5 6 7 8 9 \nPart 1总结\n生成器定义\ndef generator():\n    ...\n    yield\n    ...\n    return result\n生成器操作\ngen = generator()\n\n# 使一个生成器前进\nnext(gen)\n\n# 传递一个值\ngen.send(item)\n\n# 中止生成器\ngen.close()\n\n# 抛出错误\ngen.throw(exc, val, tb)\n\n# 委托\nresult = yield from gen\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}