{"title": "flask源码分析，run函数启动分析 - 个人文章 ", "index": "python", "content": "对flask背后运行机制感兴趣，参考网上资料，结合源码分析run函数运行时的机制，主要整理出函数调用栈。以flask0.1分析\n首先Flask官方文档经典示例 hello.py\nfrom flask import Flask\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef hello():\n    return \"Hello World!\"\n\nif __name__ == \"__main__\":\n    app.run() \n现在来分析app.run()启动时发生了什么？ # 代码只列出用到的函数，去掉注释等flask.py\nclass Flask(object):\n\n  def run(self, host='localhost', port=5000, **options):\n       \n        from werkzeug import run_simple\n        if 'debug' in options:\n            self.debug = options.pop('debug')\n        options.setdefault('use_reloader', self.debug)\n        options.setdefault('use_debugger', self.debug)\n        return run_simple(host, port, self, **options)\n\n   \n\nrun函数导入from werkzeug import run_simple  运行run_simple(host, port, self, **options)\nwerkzeug/serving.py\ndef run_simple(hostname, port, application, use_reloader=False, extra_files=None, threaded=False, processes=1):\n    \n    def inner():\n        srv = make_server(hostname, port, application, threaded,\n                          processes)\n        try:\n            srv.serve_forever()\n        except KeyboardInterrupt:\n            pass\n    inner()\nrun_simple函数主要运行inner(),inner调用make_server（）返回类，然后调用返回类的serve_forever()。先来看看make_server（）\nwerkzeug/serving.py\nddef make_server(host, port, app=None, threaded=False, processes=1):\n    \n    if threaded and processes > 1:\n        raise ValueError(\"cannot have a multithreaded and \"\n                         \"multi process server.\")\n    elif threaded:\n        class handler(BaseRequestHandler):\n            multithreaded = True\n        class server(ThreadingMixIn, WSGIServer):\n            pass\n    elif processes > 1:\n        class handler(BaseRequestHandler):\n            multiprocess = True\n            max_children = processes - 1\n        class server(ForkingMixIn, WSGIServer):\n            pass\n    else:\n        handler = BaseRequestHandler\n        server = WSGIServer\n    srv = server((host, port), handler)\n    srv.set_app(app)\n    return srv\nmake_server(hostname, port, application, threaded, processes) 传入的都是默认参数，起作用的代码是\nelse:\n        handler = BaseRequestHandler\n        server = WSGIServer\n    srv = server((host, port), handler)\n    srv.set_app(app)\n    return srv\n可以看出srv = server((host, port), handler)  ,其实就是srv = WSGIServer((host, port), BaseRequestHandler)，返回类就是WSGIServer ，绑定BaseRequestHandler。先看WSGIServer \nwsgiref/simple_server.py\nclass WSGIServer(HTTPServer):\n  def __init__=  标准库 BaseHTTPServer.py  class HTTPServer(SocketServer.TCPServer) : #WSGIServer继承HTTPServer的__init__函数，它自己没有 ，这句是我加的方便理解 ，下同\n\n  def set_app(self,application):    #这个就是make_server函数中调用的 set_app\n        self.application = application\n  def get_app(self):            #\n        return self.application\n\n标准库 BaseHTTPServer.py  \nclass HTTPServer(SocketServer.TCPServer) \n  def __init__=  标准库 SocketServer.py class TCPServer(BaseServer):\n\n\n标准库 SocketServer.py \nclass TCPServer(BaseServer):\n   def __init__(self, server_address, RequestHandlerClass, bind_and_activate=True):\n        BaseServer.__init__(self, server_address, RequestHandlerClass)\n        self.socket = socket.socket(self.address_family,\n                                    self.socket_type)\n        if bind_and_activate:         # 这里调用socket.socket绑定端口\n            try:\n                self.server_bind()\n                self.server_activate()\n            except:\n                self.server_close()\n                raise\n\nclass BaseServer:\n    def __init__(self, server_address, RequestHandlerClass):\n        self.server_address = server_address\n        self.RequestHandlerClass = RequestHandlerClass\n        self.__is_shut_down = threading.Event()\n        self.__shutdown_request = False\n\n    def serve_forever(self, poll_interval=0.5):    #这个就是run_simple中调用的serve_forever\n        \n        self.__is_shut_down.clear()\n        try:\n            while not self.__shutdown_request:\n                \n                r, w, e = _eintr_retry(select.select, [self], [], [],\n                                       poll_interval)\n                if self in r:\n                    self._handle_request_noblock()   #调用serve_forever时调用_handle_request_noblock\n        finally:\n            self.__shutdown_request = False\n\n            self.__is_shut_down.set()\n    def _handle_request_noblock(self):   \n       \n        try:\n            request, client_address = self.get_request()\n        except socket.error:\n            return\n        if self.verify_request(request, client_address):\n            try:\n                self.process_request(request, client_address)  #继续\n            except:\n                self.handle_error(request, client_address)\n                self.shutdown_request(request)\n\n    def process_request(self, request, client_address):\n        \n        self.finish_request(request, client_address)   #继续\n        self.shutdown_request(request)\n\n    def finish_request(self, request, client_address):\n        self.RequestHandlerClass(request, client_address, self)    # #继续 并参见 werkzeug/serving.py  make_server()    \n调用serve_forever后到了self.RequestHandlerClass(request, client_address, self)  ，根据前面的代码可知RequestHandlerClass 就是werkzeug/serving.py中的BaseRequestHandler，继续\nclass BaseRequestHandler(WSGIRequestHandler):\n    def __init__=  标准库 wsgiref/simple_server.py class WSGIRequestHandler(BaseHTTPRequestHandler): #这句跟前面一样继承父类   \n    \n\nwsgiref/simple_server.py\n\nclass WSGIRequestHandler(BaseHTTPRequestHandler):\n    def __init__=  标准库 BaseHTTPServer.py class BaseHTTPRequestHandler(SocketServer.StreamRequestHandler): #继续父类\n\nBaseHTTPServer.py\nclass BaseHTTPRequestHandler(SocketServer.StreamRequestHandler):\n    def __init__=  标准库 SocketServer.py  class StreamRequestHandler(BaseRequestHandler):  #继续父类\n\n\nSocketServer.py\n\nclass StreamRequestHandler(BaseRequestHandler):\n #继续父类\n\nclass BaseRequestHandler:\n\n    def __init__(self, request, client_address, server):\n        self.request = request\n        self.client_address = client_address\n        self.server = server\n        self.setup()\n        try:\n            self.handle()   # 运行  参见 werkzeug/serving.py  class BaseRequestHandler.handle\n        finally:\n            self.finish()\n最后运行了self.handle()  参见 werkzeug/serving.py  class BaseRequestHandler.handle前面有，再贴下看看\nclass BaseRequestHandler(WSGIRequestHandler):\n   def handle(self):     #1、调用的就是这个handle，覆盖了父类的handle \n        self.raw_requestline = self.rfile.readline()\n        if self.parse_request():\n            self.get_handler().run(self.server.get_app())  #2、调用 get_handler()后，还继续调用 run（） ，get_app就是wsgiref/simple_server.py中WSGIServer类定义的函数   \n\n    def get_handler(self):  # 3、看看它返回了什么\n        handler = self._handler_class\n        if handler is None:\n            class handler(ServerHandler):  #4、新建一个类 返回的就是这个类 ，继承ServerHandler\n              '''   \n                  5、直接从其他文件copy出所需代码，也就是handler的父类\n                   wsgiref/simple_server.py  class ServerHandler(SimpleHandler): 继续父类 \n                   wsgiref/handlers.py  \n                       class SimpleHandler(BaseHandler):\n                          def __init__(self,stdin,stdout,stderr,environ,multithread=True, multiprocess=False ):\n                              self.stdin = stdin\n                              self.stdout = stdout\n                              self.stderr = stderr\n                              self.base_env = environ\n                              self.wsgi_multithread = multithread\n                              self.wsgi_multiprocess = multiprocess\n                       class BaseHandler:  #6、调用的就是这个类的run函数\n                                  def run(self, application):\n                                    try:\n                                        self.setup_environ()\n                                        self.result = application(self.environ, self.start_response)   #7、调用app，也就是app=Flask() Flask类的 __call__\n                                        self.finish_response()\n                                    except:\n                                          try:\n                                               self.handle_error()\n                                          except:\n                                             # If we get an error handling an error, just give up already!\n                                             self.close()\n                                             raise   # ...and let the actual server figure it out.\n\n\n                 '''\n                wsgi_multithread = self.multithreaded                      \n                wsgi_multiprocess = self.multiprocess\n            self._handler_class = handler\n\n        rv = handler(self.rfile, self.wfile, self.get_stderr(),\n                     self.get_environ())\n        rv.request_handler = self\n        return rv\n\n \n可以看出最后调用的是application(self.environ, self.start_response)  这个application就是开始的app = Flask(__name__)，调用类就是调用类的__call__ 函数 ，继续贴一下源码\nclass Flask(object):\n\n   def __call__(self, environ, start_response):\n        return self.wsgi_app(environ, start_response)\n\n   def wsgi_app(self, environ, start_response):\n        \n        with self.request_context(environ):\n            rv = self.preprocess_request()\n            if rv is None:\n                rv = self.dispatch_request()\n            response = self.make_response(rv)\n            response = self.process_response(response)\n            return response(environ, start_response)\nOK，大功告成，最后调用wsgi_app(self, environ, start_response)函数，这个就是返回响应的主函数了！！\n从整个流程中，flask利用WSGIServer类启动监听端口并绑定，BaseRequestHandler类接收、返回相应的信息！完全符合WSGI要求。剩余的工作就太过于底层，不好深入分析了。也画了调用流程图，不过太大不好传，如果有需要可以继续交流！\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}