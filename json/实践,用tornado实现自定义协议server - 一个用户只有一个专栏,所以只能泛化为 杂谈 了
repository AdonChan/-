{"title": "实践,用tornado实现自定义协议server - 一个用户只有一个专栏,所以只能泛化为 杂谈 了 ", "index": "python,tornado", "content": "前言\n\n俗话说\"光说不练假把式\",上一篇文里都只是光看着别人的源码说,貌似有点纸上谈兵的意思.\n所以这次写一个简单的,自己定义协议的server.\n既可以熟悉Future和coroutine的用法,又可以在去除了复杂的http协议后,了解tornado的工作原理.\n代码不多,加上空行和import也就200行不到.在github上的源码点这里\n\n目标\n\n\n1.定义一个简单的协议,达到远程调用的效果,并且是个长连接的协议(类似websock)\n2.模仿tornado的框架模式开发这个server框架,让用户代码开发方便,并且支持coroutine\n\n3.为了省去客户端的开发,客户端使用telnet \n\n协议\n\n\n1.客户端连接成后,以换行符分割每次通信内容\n2.第一次通信内容是需要执行handler名称,第二次通信的内容是该handler的方法名\n3.对于客户端的主动close,需等待此连接所有的异步操作完成后才关闭连接\n最后运行方式如下图:\n\n\n\n源码说明\n\n总览\n\n因为想让代码尽量少,所以委托模式没有严格按照设计模式的规范写,直接忽略掉了interface的定义.严格来说是需要定义interface和判断传入参数的类型的(泛华)\n这是类的实例关系图(也不知道是不是这样画...)\n\nMyServer和MyApplication的实例常驻.一个连接进来后就会创建图中其他的实例各一个.\n\n异步说明\n\n\n1.为了达到目标中的第一点,需要一个while循环,读取了客户端数据后,执行handler,\n立即继续读取下一条客户端数据.直到客户端关闭操作,引发StreamClosedError才退出循环\n2.为了达到目标中的第二点,判断handler的返回值,如果类型是Future则yield处理,因为本方法有@gen.coroutine,所以yield就代表异步操作是在gen.Runner中执行的.\n3.为了达到目标中的第三点,需要记录每一个异步操作,并且异步操作完成后移除.当客户端主动关闭连接时,需判断是否还有future未完成.所以close代码中给每个future加上done_callback,用以检查关闭\n\n详情见代码 MyServerConnection._server_request_loop\n\n@gen.coroutine\n    def _server_request_loop(self, delegate):\n        try:\n            #get request adepter\n            request_delegate = delegate.on_request(self)\n            while True:\n\n                try:\n                    message_future = self.stream.read_until_regex(b\"\\n\\r?\")\n                    message = yield message_future\n                    message = self._parse_data(message)\n\n                except (iostream.StreamClosedError, \n                        iostream.UnsatisfiableReadError):\n                    app_log.error(' close the connect')\n                    self.close()\n                    return\n\n                except Exception:\n\n                    gen_log.error(\"Uncaught exception\", exc_info=True)\n                    self.close()\n                    return\n\n                ret = request_delegate.on_message(message)\n                #如果是异步执行的方法,保存future,用于确保close时,所有future都已完成\n                if isinstance(ret, Future):\n                    ret.add_done_callback(lambda f:self._serving_futures.remove(f))\n                    self._serving_futures.append(ret)\n\n        finally:\n            delegate.on_close(self)\n\n\n    def close(self):\n\n        def mayby_close(f):\n            futures = self._serving_futures+self._pending_writes\n            app_log.error(futures)\n            if not any(futures):\n                self.stream.close()\n\n        pending_futrues = self._serving_futures+self._pending_writes\n        if any(pending_futrues):\n            map(lambda f:f.add_done_callback(mayby_close),pending_futrues)\n        else:\n            self.stream.close()\n\n\n关于@coroutine\n\n其实用@coroutine的时候只需要记住几点就行了\n* 1.被包装的函数(方法),返回值是Future,\n* 2.被包装的函数走完最后一行代码后,返回的Future的callback就会被运行(因为在Runner中引发了StopIteration错误,被set_result了)\n* 3.被包装的函数是在gen.Runner中运行的,而Runner是在ioloop(callback那块)中运行的\n\n总结\n\n代码非常简单,因为tornado为我们提供了异步的库(tornado真强大,协程好厉害!!),并且是单进程的编程,不需要考虑锁,写起来就更轻松了.\n最后附上程序效果图\n\n废话\n\n这只是个吃饱撑着的程序,一点实际作用都没啊(好想被拍死!).吃饱撑着的原因是我还没下决心去找工作...工作太难找啦(哭~~)!!!!好想被带走.................\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "9"}