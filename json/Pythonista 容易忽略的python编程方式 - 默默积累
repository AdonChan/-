{"title": "Pythonista 容易忽略的python编程方式 - 默默积累 ", "index": "python", "content": "Python 之禅\n\n\n  The Zen of Python, by Tim Peters\n  Beautiful is better than ugly.\n  优美胜于丑陋（Python以编写优美的代码为目标）\n  Explicit is better than implicit.\n  明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）\n  Simple is better than complex.\n  简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）\n  Complex is better than complicated.\n  复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）\n  Flat is better than nested.\n  扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）\n  Sparse is better than dense.\n  间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题）\n  Readability counts.\n  可读性很重要（优美的代码是可读的）\n  Special cases aren\"t special enough to break the rules.\n  Although practicality beats purity.\n  即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上）\n  Errors should never pass silently.\n  Unless explicitly silenced.\n  不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写except:pass风格的代码）\n  In the face of ambiguity, refuse the temptation to guess.\n  当存在多种可能，不要尝试去猜测\n  There should be one-- and preferably only one --obvious way to do it.\n  而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法）\n  Although that way may not be obvious at first unless you\"re Dutch.\n  虽然这并不容易，因为你不是 Python 之父（这里的Dutch是指Guido）\n  Now is better than never.\n  Although never is often better than right now.\n  做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量）\n  If the implementation is hard to explain, it\"s a bad idea.\n  If the implementation is easy to explain, it may be a good idea.\n  如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准）\n  Namespaces are one honking great idea -- let\"s do more of those!\n  命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召）\n\n\n1、python编程空格和缩进\n\n\n  \n  1、每次缩进使用4个空格\n  2、不要使用Tab，更不要Tab和空格混用\n  3、两个方法之间使用一个空行，两个Class之间使用两个空行\n  4、添加一个空格在字典、列表、序列、参数列表中的“，“后，以及在字典中的”：“之后，而不是之前\n  5、在赋值和比较两边放置一个空格（参数列表中除外）\n  6、紧随括号后面或者参数列表前一个字符不要存在空格\n\n\n2、使用如下方式交换pyhton的值\n\nb, a = a, b\n\n# 其他例子\n\nIn [1]: people = [\"David\", \"Pythonista\", \"15145551234\"]\nIn [2]: name, title, phone = people\nIn [3]: name\nOut[3]: \"David\"\nIn [4]: title\nOut[4]: \"Pythonista\"\nIn [5]: phone\nOut[5]: \"15145551234\"\n\n这种语法在For循环中非常实用：\n\nIn [6]: people = [[\"David\", \"Pythonista\", \"15145551234\"], [\"Wu\", \"Student\", \"15101365547\"]]\nIn [7]: for name, title, phone in people:\n...: print name, phone\n...:\nDavid 15145551234\nWu 15101365547\n\nPS：在使用这种语法时，需要确保左边的变量个数和右边tuple的个数一致，否则，Python会抛出ValueError异常。\n\n\n3、合并字符串的值\nresult = \",\".join(colors)\n这样的效率要比使用for循环进行拼接的效率高，当list元素越多的时候，约明显\n\n4、使用关键字in\n当要判断一个key是否在字典中的时候，\n\nd = {\"a\": 1, \"b\": 2}\nif \"c\" in d:\nprint True\n# DO NOT USE\nif d.has_key(\"c\"):\nprint True\nfor key in d:\nprint key\n# DO NOT USE\nfor key in d.keys():\nprint key\n\n\nPython的dict对象是对KEY做过hash的，而keys()方法会将dict中所有的KEY作为一个list对象；所以，直接使用in的时候执行效率会比较快，代码也更简洁。\n\n5、字典\ndict是Python内置的数据结构，在写Python程序时会经常用到。这里介绍一下它的get方法和defaultdict方法。\na、get\n在获取dict中的数据时，我们一般使用index的方式，但是如果KEY不存在的时候会抛出KeyError。这时候你可以使用get方法，使用方法：dict.get(key, default=None)，可以避免异常。例如：\n\nd = {\"a\": 1, \"b\": 2}\nprint d.get(\"c\") # None\nprint d.get(\"c\", 14) # 14\n\n\nb、fromkeys\ndict本身有个fromkeys方法，可以通过一个list生成一个dict，不过得提供默认的value，例如：\n\n# ⽤序列做 key,并提供默认value\n>>> dict.fromkeys([\"a\", \"b\", \"c\"], 1)\n# {\"a\": 1, \"c\": 1, \"b\": 1}请输入代码\n\n\nc、有些情况下，我们需要给dict的KEY一个默认值，你可以这样写：\n\nequities = {}\nfor (portfolio, equity) in data:\nequities.setdefault(portfolio, []).append(equity)\n\n\nsetdefault方法相当于\"get, or set & get\"，或者相当于\"set if necessary, then get\"\n\n6、defaultdict\ndefaultdict()和namedtuple()是collections模块里面2个很实用的扩展类型。一个继承自dict系统内置类型,一个继承自tuple系统内置类型.\n\n7、字典操作\n在Python中，你可以使用zip方法将两个list组装成一个dict，其中一个list的值作为KEY，另外一个list的值作为VALUE：\n\n>>> given = [\"John\", \"Eric\", \"Terry\", \"Michael\"]\n>>> family = [\"Cleese\", \"Idle\", \"Gilliam\", \"Palin\"]\n>>> pythons = dict(zip(given, family))\n>>> print pythons\n{\"John\": \"Cleese\", \"Michael\": \"Palin\", \"Eric\": \"Idle\", \"Terry\": \"Gilliam\"}\n\n\n相反的，你可以使用dict的keys()和values()方法来获取KEY和VALUE的列表：\n\n>>> pythons.keys()\n[\"John\", \"Michael\", \"Eric\", \"Terry\"]\n>>> pythons.values()\n[\"Cleese\", \"Palin\", \"Idle\", \"Gilliam\"]\n\n\n8、python的True\n在Python中，判断一个变量是否为True的时候，你可以这样做：\n\n\n  \n  False          True\n  False (== 0)    True (== 1)\n  \"\" (空字符串)   除 \"\" 之外的字符串(\" \", \"anything\")\n  0, 0.0  除 0 之外的数字(1, 0.1, -1, 3.14)\n  [], (), {}, set()   非空的list，tuple，set和dict ([0], (None,), [\"\"])\n  None    大部分的对象，除了明确指定为False的对象\n\n\n对于自己声明的class，如果你想明确地指定它的实例是True或False，你可以自己实现class的nonzero或len方法。当你的class是一个container时，你可以实现len方法，如下：\n\nclass MyContainer(object):\n    def __init__(self, data):\n        self.data = data\n    def __len__(self):\n    \"\"\" Return my length. \"\"\"\n        return len(self.data)\n\n\n如果你的class不是container，你可以实现nonzero方法，如下：\n\nclass MyClass(object):\n    def __init__(self, value):\n        self.value = value\n    def __nonzero__(self):\n    \"\"\" Return my truth value (True or False). \"\"\"\n        # This could be arbitrarily complex:\n        return bool(self.value)\n\n\n在Python 3.x中，nonzero方法被bool方法替代。考虑到兼容性，你可以在class定义中加上以下的代码：\n\n__bool__ = __nonzero__\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "3"}