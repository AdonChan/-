{"title": "Flask Web Development —— Web表单（上） - young ", "index": "python,flask,wtforms", "content": "第二章中介绍的request对象公开了所有客户端发送的请求信息。特别是request.form可以访问POST请求提交的表单数据。\n\n尽管Flask的request对象提供的支持足以处理web表单，但依然有许多任务会变得单调且重复。表单的HTML代码生成和验证提交的表单数据就是两个很好的例子。\n\nFlask-WTF扩展使得处理web表单能获得更愉快的体验。该扩展是一个封装了与框架无关的WTForms包的Flask集成。\n\nFlask-WTF和它的依赖集可以通过pip来安装：\n\n(venv) $ pip install flask-wtf\n\n\n1、跨站请求伪造（CSRF）保护\n\n默认情况下，Flask-WTF保护各种形式对跨站请求伪造（CSRF）攻击。一个CSRF攻击发生在一个恶意网站发送请求给受害者登录的其他网站。\n\n为了实现CSRF保护，Flask-WTF需要应用程序去配置一个加密密钥。Flask-WTF使用这个密钥去生成加密令牌用于验证请求表单数据的真实性。示例4-1展示如何配置加密密钥。\n\n示例4-1. hello.py：Flask-WTF配置\n\napp = Flask(__name__)\napp.config['SECRET_KEY'] = 'hard to guess string'\n\n\napp.config字典通常是框架、扩展或应用程序自身存放配置变量的地方，可以使用标准字典语法添加配置值到app.config中。配置对象提供方法来从文件或环境导入配置值。\n\nSECRET_KEY配置变量作为Flask和一些第三方扩展的通用加密密钥。加密的强度取决于这个变量的值。给你构建的每个应用程序选择不同的密钥，并确保这个字符串不被其他任何人知道。\n\n\n  注：为了提高安全性，密钥应该存储在一个环境变量中，而不是嵌入到代码中。这个会在第7章中描述。\n\n\n2、表单类\n\n使用Flask-WTF时，每个web表单是由继承自Form类的子类来展现的。该类在表单中定义了一组表单域，每个都表示为一个对象。每个表单域都可以连接到一个或多个validators；validators是一个用于检查用户提交的输入是否合法的函数。\n\n示例4-2展示了一个拥有文本框和提交按钮的简单web表单。\n\n示例4-2. hello.py：表单类定义\n\nfrom flask.ext.wtf import Form\nfrom wtforms import StringField, SubmitField \nfrom wtforms.validators import Required\n\nclass NameForm(Form):\n    name = StringField('What is your name?', validators=[Required()]) \n    submit = SubmitField('Submit')\n\n\n表单中的域被定义为类的变量，且每个类的变量都指定一个表单域类型对象。在上一个示例中，NameForm表单有一个name文本框和submit提交按钮。StringField类表示一个type=\"text\"属性的<input>标签。SubmitField类表示一个type=\"submit\"属性的<input>标签。表单域构造函数的第一个参数是一个label，在渲染表单到HTML时会使用。\n\nStringField构造函数包含可选参数validators，它定义了一组检查来验证用户提交的数据。Required()验证确保提交的表单域不为空。\n\n\n  注：Flask-WTF扩展定义了表单基类，所以它从flask.ext.wtf导入。表单域、验证都是直接从WTForms包中导入。\n\n\n表格4-1展示了一组WTForms支持的标准表单域。\n\n表格4-1. WTForms标准HTML表单域\n\n\n\n表格4-2展示了一组WTForms内建验证。\n\n表格4-2. WTForms验证\n\n\n\n3、HTML渲染的表单\n\n表单域是可调用的，调用时从模板渲染它们到HTML。假设视图函数传递一个参数名为form的NameForm实例给模板，模板就会生成一个简单的HTML表单，如下所示：\n\n<form method=\"POST\">\n    {{ form.name.label }} {{ form.name() }} \n    {{ form.submit() }}\n</form>\n\n\n当然，结果是什么都没有。为了改变表单的外观显示，任何发送给该表单域的参数会被转换为HTML表单域属性；例如，你可以给定表单域id或class属性，然后定义CSS样式：\n\n<form method=\"POST\">\n    {{ form.name.label }} {{ form.name(id='my-text-field') }} \n    {{ form.submit() }}\n</form>\n\n\n即使有HTML属性，努力用这种方式渲染表单是非常重要的，所以最好是尽可能的使用Bootstrap自带的一系列表单样式。Flask-Bootstrap使用Bootstrap的预定义表单样式来提供高级的帮助函数来渲染整个Flask-WTF表单，这些操作都只需要一个调用即可完成。使用Flask-Bootstrap，上一个表单可以像下面这样来渲染：\n\n{% import \"bootstrap/wtf.html\" as wtf %}\n{{ wtf.quick_form(form) }}\n\n\nimport指令和常规的Python脚本一样的作用并且允许模板元素被导入并在许多模板中使用。被导入的bootstrap/wtf.html文件，定义了帮助函数使用Bootstrap来渲染Flask-WTF表单。wtf.quick_form()函数传入Flask-WTF表单对象并使用默认Bootstrap样式渲染它。示例4-3展示了完整的hello.py模板。\n\n示例4-3. templates/index.html：使用Flask-WTF和Flask-Bootstrap渲染表单\n\n{% extends \"base.html\" %}\n{% import \"bootstrap/wtf.html\" as wtf %}\n\n{% block title %}Flasky{% endblock %}\n\n{% block page_content %}\n\n\n<div class=\"page-header\">\n    <h1>Hello, {% if name %}{{ name }}{% else %}Stranger{% endif %}!</h1>\n</div>\n\n\n{{ wtf.quick_form(form) }}\n{% endblock %}\n\n\n目前模板的内容区有两块。第一块是类为page-header的div输出一个问候语。这里使用了模板条件判断语句。在Jinja2中格式为{% if variable %}...{% else %}...{% endif %}。如果判断条件为True则渲染if和else之间的内容。如果判断条件为False则渲染else和endif之间的内容。示例模板会渲染字符串“Hello, Stranger!”当name模板参数未定义的时候。第二块内容使用wtf.quick_form()函数渲染NameForm对象。\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "24"}