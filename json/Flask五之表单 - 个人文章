{"title": "Flask五之表单 - 个人文章 ", "index": "sqlserver,centos,linux,flask,python", "content": "五、表单\n1、Flask-WTF 扩展\nFlask-WTF 及其依赖可使用 pip 安装：\n(venv) $ pip install flask-wtf\n2、跨站请求伪造保护\n【设置密钥】\napp = Flask(__name__)\napp.config['SECRET_KEY'] = 'hard to guess string'\napp.config 字典可用来存储框架、 扩展和程序本身的配置变量。\n3、表单类\n创建表单的三个步骤：\n\n定义Form的子类\n在类里添加字段\n在字段里添加验证函数\n\n# Form 基类由 Flask-WTF 扩展定义\nfrom flask_wtf import FlaskForm\n# 字段直接从 WTForms 包中导入\nfrom wtforms import StringField,SubmitField\n# 验证函数直接从 WTForms 包中导入\nfrom wtforms.validators import DataRequired,Length\n\nclass NameForm(Form):\n    name = StringField('Input your name:',validators=[DataRequired()])\n    submit = SubmitField('Submit')\n与其他扩展的使用方法不同之处在于：①不是实例化，而是继承②还需要从wtforms当中导入字段和验证函数\n 【注意】 Form 基类由 Flask-WTF 扩展定义，所以从 flask_wtf 中导入。字段和验证函数却可以直接从 WTForms 包中导入。\n4、把表单渲染成HTML\n表单字段是可调用的，在模板中调用后会渲染成 HTML。假设视图函数把一个 NameForm 实例通过参数 form传入模板，在模板中可以生成一个简单的表单，如下所示：\n<form method=\"POST\">\n{{ form.hidden_tag() }}\n{{ form.name.label }} {{ form.name() }}\n{{ form.submit() }}\n</form>\n可以使用Bootstrap 中预先定义好的表单样式渲染整个 Flask-WTF 表单，使用 Flask-Bootstrap，上述表单可使用下面的方式渲染：\n{% import \"bootstrap/wtf.html\" as wtf %}\n{{ wtf.quick_form(form) }}\n具体渲染方式如下：【form.html】\n{% extends \"base.html\" %}\n{% import \"bootstrap/wtf.html\" as wtf %}\n{% block title %}Flasky{% endblock %}\n{% block page_content %}\n<div class=\"page-header\">\n    <h1>\n        Hello, {% if name %}{{ name }}{% else %}Stranger{% endif %}!\n    </h1>\n</div>\n{{ wtf.quick_form(form) }}\n{% endblock %}\n模板的内容区现在有两部分。第一部分是页面头部，显示欢迎消息。这里用到了一个模板条件语句。 Jinja2中的条件语句格式为 {% if condition %}...{% else %}...{% endif %}。如果条件的计算结果为 True，那么渲染 if 和 else 指令之间的值。如果条件的计算结果为False，则渲染else 和 endif 指令之间的值。在这个例子中，如果没有定义模板变量 name，则会渲染字符串“Hello,Stranger!”。内容区的第二部分使用 wtf.quick_form() 函数渲染NameForm 对象。\n5、在视图函数中处理表单\n视图函数 index() 不仅要渲染表单，还要接收表单中的数据。\n@app.route('/form/',methods = ['GET','POST'])\ndef form():\n    name = None\n    form = NameForm()\n    if form.validate_on_submit():\n        name = form.name.data\n        form.name.data = ''\n    return render_template('form.html',form = form, name = name)\n6、重定向和用户会话\n上面的视图函数存在一个可用性问题。用户输入名字后提交表单，然后点击浏览器\n的刷新按钮，会看到一个莫名其妙的警告，要求在再次提交表单之前进行确认：\n\n之所以出现这种情况，是因为刷新页面时浏览器会重新发送之前已经发送过的最后\n一个请求。如果这个请求是一个包含表单数据的 POST 请求，刷新页面后会再次提\n交表单。大多数情况下，这并不是理想的处理方式。很多用户都不理解浏览器发出\n的这个警告。基于这个原因， 最好别让 Web 程序把 POST 请求作为浏览器发送的\n最后一个请求。\n这种需求的实现方式是， 使用**重定向**作为 POST 请求的响应，而不是使用常规\n响应。这个技巧称为 Post/ 重定向 /Get 模式。\n\n程序可以把数据存储在** 用户会话 **中，在请求之间“记住”数据。用户会话是一\n种私有存储，存在于每个连接服务器的客户端中。 我们在请求与响应中介绍过用户\n会话，它是请求上下文中的变量，名为 ** session **，像标准的 Python 字典一\n样操作。\n\nfrom flask import session\n@app.route('/form2/',methods = ['GET','POST'])\ndef form2():\n    form = NameForm()\n    if form.validate_on_submit():\n        session['name'] = form.name.data\n        # 这里也不需要设置form.name.data = ''，\n        # 因为已经重定向到别的url去了，下次再到这个界面会自动初始化为''\n        return redirect(url_for('hello'))\n    return render_template('form.html',form = form, name = session.get('name'))\n7、Flash消息\n请求完成后，有时需要让用户知道状态发生了变化。这里可以使用确认消息、警告或者\n错误提醒。一个典型例子是，用户提交了有一项错误的登录表单后，服务器发回的响应\n重新渲染了登录表单，并在表单上面显示一个消息，提示用户用户名或密码错误。\n通过Flask 的核心特性，** flash()函数 **可实现这种效果\nfrom flask import flash\n@app.route('/form3/',methods = ['GET','POST'])\ndef form3():\n    form = NameForm()\n    if form.validate_on_submit():\n        old_name = session.get('name')\n        if old_name is not None and old_name != form.name.data :\n            flash('you have changed your name')\n        session['name'] = form.name.data\n        return redirect(url_for('hello'))\n    return render_template('form.html',form = form, name = session.get('name'))\n仅调用 flash() 函数并不能把消息显示出来，程序使用的模板要渲染这些消息。\n最好在基模板中渲染 Flash消息，因为这样所有页面都能使用这些消息。 Flask \n把 get_flashed_messages() 函数开放给模板，用来获取并渲染消息。\n【base.html】\n{% block content %}\n<div class=\"container\">\n    {% for message in get_flashed_messages() %}\n    <div class=\"alert alert-warning\">\n        <button type=\"button\" class=\"close\" data-dismiss=\"alert\">&times;</button>\n        {{ message }}\n    </div>\n    {% endfor %}\n    {% block page_content %}{% endblock %}\n</div>\n{% endblock %}\n在这个示例中，使用 Bootstrap 提供的警报 CSS 样式渲染警告消息。 【注意】 在模板中使用循环是因为在之前的请求循环中每次调用 flash() 函数时都会生成一个消息，所以可能有多个消息在排队等待显示。 get_flashed_messages() 函数获取的消息在下次调用时不会再次返回，因此 Flash消息只显示一次，然后就消失了。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "3"}