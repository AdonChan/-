{"title": "Python数据分析入门之pandas总结基础（一） - michael翔的IT私房菜 ", "index": "pandas,机器学习,数据挖掘,数据分析,python", "content": "一. Series\nSeries: pandas的长枪(数据表中的一列或一行,观测向量,一维数组...)\n\nSeries1 = pd.Series(np.random.randn(4))\n\nprint Series1,type(Series1) \n\nprint Series1.index\n\nprint Series1.values\n\n输出结果：\n\n0   -0.676256\n\n1    0.533014\n\n2   -0.935212\n\n3   -0.940822\n\ndtype: float64 <class 'pandas.core.series.Series'>\n\nInt64Index([0, 1, 2, 3], dtype='int64')\n\n[-0.67625578  0.53301431 -0.93521212 -0.94082195]\n\nnp.random.randn()   正态分布相关。函数说明\nSeries⽀持过滤的原理就如同NumPy\n\nprint Series1>0 \n\nprint Series1[Series1>0]\n\n输出结果如下：\n\n0 0.030480\n\n1 0.072746\n\n2 -0.186607\n\n3 -1.412244\n\ndtype: float64 <class 'pandas.core.series.Series'>\n\nInt64Index([0, 1, 2, 3], dtype='int64')\n\n[ 0.03048042 0.07274621 -0.18660749 -1.41224432]\n\n我发现，逻辑表达式，获得的值就是True或者False。要先取得值，还是要X[y]的形式。\n当然也支持广播Broadcasting\n什么是broadcasting,暂时我也不太清楚，看个栗子：\n\nprint Series1*2 \n\nprint Series1+5\n\n输出结果如下：\n0 0.06096\n\n1 1 0.145492 \n\n2 -0.373215 \n\n3 -2.824489 \n\ndtype: float64 \n\n0 5.030480 \n\n1 5.072746 \n\n2 4.813393 \n\n3 3.587756 \n\ndtype: float64\n\n以及Universal Function\nnumpy.frompyfunc(out,nin,nout)    返回的是一个函数，nin是输入的参数个数，nout是函数返回的对象的个数函数说明\n在序列上就使用行标，而不是创建1个2列的数据表，能够轻松辨别哪是数据，哪是元数据\n这句话的意思，我的理解是序列尽量是一列，不用去创建2列，这样子，使用index就能指定数据了`\n\nSeries2 = pd.Series(Series1.values,index=['norm_'+unicode(i) for i in xrange(4)])\n\nprint Series2,type(Series2)\n\nprint Series2.index\n\nprint type(Series2.index)\n\nprint Series2.values\n\n输出结果如下，可以看到，它是通过修改了index值的样式，并没有创建2列。\n\nnorm_0   -0.676256\n\nnorm_1    0.533014\n\nnorm_2   -0.935212\n\nnorm_3   -0.940822\n\ndtype: float64 <class 'pandas.core.series.Series'>\n\nIndex([u'norm_0', u'norm_1', u'norm_2', u'norm_3'], dtype='object')\n\n<class 'pandas.core.index.Index'>\n\n[-0.67625578  0.53301431 -0.93521212 -0.94082195]\n\n虽然行是有顺序的，但是仍然能够通过行级的index来访问到数据：\n（当然也不尽然像Ordered Dict，因为⾏索引甚⾄可以重复，不推荐重复的行索引不代表不能用）\n\nprint Series2[['norm_0','norm_3']]\n\n可以看到，读取数据时，确实要采用X[y]的格式。这里X[[y]]是因为，它要读取两个数据，指定的是这两个数据的index值，将index值存放进list中，然后读取。输出结果如下：\n\nnorm_0   -0.676256\n\nnorm_3   -0.940822\n\ndtype: float64\n\n再比如：\n\nprint 'norm_0' in Series2\n\nprint 'norm_6' in Series2\n\n输出结果：\n\nTrue\n\nFalse\n\n逻辑表达式的输出结果，布尔型值。\n从Key不重复的Ordered Dict或者从Dict来定义Series就不需要担心行索引重复：\n\nSeries3_Dict = {\"Japan\":\"Tokyo\",\"S.Korea\":\"Seoul\",\"China\":\"Beijing\"}\n\nSeries3_pdSeries = pd.Series(Series3_Dict)\n\nprint Series3_pdSeries\n\nprint Series3_pdSeries.values\n\nprint Series3_pdSeries.index\n\n输出结果：\n\nChina Beijing\n\nJapan Tokyo\n\nS.Korea Seoul\n\ndtype: object\n\n['Beijing' 'Tokyo' 'Seoul']\n\nIndex([u'China', u'Japan', u'S.Korea'], dtype='object')\n\n通过上面的输出结果就知道了，输出结果是无序的，和输入顺序无关。 \n想让序列按你的排序⽅式保存？就算有缺失值都毫无问题\n\nSeries4_IndexList = [\"Japan\",\"China\",\"Singapore\",\"S.Korea\"]\n\nSeries4_pdSeries = pd.Series( Series3_Dict ,index = Series4_IndexList)\n\nprint Series4_pdSeries\n\nprint Series4_pdSeries.values\n\nprint Series4_pdSeries.index\n\nprint Series4_pdSeries.isnull()\n\nprint Series4_pdSeries.notnull()\n\n上面这样的输出就会按照list中定义的顺序输出结果。\n\n整个序列级别的元数据信息：name\n当数据序列以及index本身有了名字，就可以更方便的进行后续的数据关联啦！\n\n这里我感觉就是列名的作用。下面举例：\n\nprint Series4_pdSeries.name\n\nprint Series4_pdSeries.index.name\n\n很显然，输出的结果都是None，因为我们还没指定name嘛！\n\nSeries4_pdSeries.name = \"Capital Series\"\n\nSeries4_pdSeries.index.name = \"Nation\"\n\nprint Series4_pdSeries\n\n输出结果：\n\nNation\n\nJapan Tokyo\n\nChina Beijing\n\nSingapore NaN\n\nS.Korea Seoul\n\nName: Capital Series, dtype: object\n\n\"字典\"？不是的，⾏index可以重复，尽管不推荐。\n\nSeries5_IndexList = ['A','B','B','C']\n\nSeries5 = pd.Series(Series1.values,index = Series5_IndexList)\n\nprint Series5\n\nprint Series5[['B','A']]\n\n输出结果：\n\nA 0.030480\n\nB 0.072746\n\nB -0.186607\n\nC -1.412244\n\ndtype: float64\n\nB 0.072746\n\nB -0.186607\n\nA 0.030480\n\ndtype: float64\n\n我们可以看出，Series['B']输出了两个值，所以index值尽量不要重复呀！\n二. DataFrame\nDataFrame：pandas的战锤(数据表，⼆维数组)\nSeries的有序集合，就像R的DataFrame一样方便。\n仔细想想，绝大部分的数据形式都可以表现为DataFrame。\n从NumPy二维数组、从文件或者从数据库定义：数据虽好，勿忘列名\n\ndataNumPy = np.asarray([('Japan','Tokyo',4000),('S.Korea','Seoul',1300),('China','Beijing',9100)])\n\nDF1 = pd.DataFrame(dataNumPy,columns=['nation','capital','GDP'])\n\nDF1\n\n这里DataFrame中的columns应该就是列名的意思。现在看print的结果，是不是很舒服啊！Excel的样式嘛\n等长的列数据保存在一个字典里（JSON）：很不幸，字典key是无序的\n\ndataDict = {'nation':['Japan','S.Korea','China'],'capital':['Tokyo','Seoul','Beijing'],'GDP':[4900,1300,9100]}\n\nDF2 = pd.DataFrame(dataDict)\n\nDF2\n\n输出结果可以发现，无序的！\nGDP    capital    nation\n\n0    4900    Tokyo    Japan\n1    1300    Seoul    S.Korea\n2    9100    Beijing    China\nPS:由于懒得截图放过来，这里没有了边框线。\n从另一个DataFrame定义DataFrame：啊，强迫症犯了！\n\nDF21 = pd.DataFrame(DF2,columns=['nation','capital','GDP'])\n\nDF21\n\n很明显，这里是利用DF2定义DF21，还通过指定cloumns改变了列名的顺序。\n\nDF22 = pd.DataFrame(DF2,columns=['nation','capital','GDP'],index = [2,0,1])\n\nDF22\n\n很明显，这里定义了columns的顺序，还定义了index的顺序。\n\nnation capital GDP\n\n2 China Beijing 9100\n\n0 Japan Tokyo 4900\n\n1 S.Korea Seoul 1300\n\n从DataFrame中取出列？两种方法（与JavaScript完全一致！）\nOMG，囧，我竟然都快忘了js语法了，现在想起了，但是对象的属性既可以obj.x也可以obj[x]。\n\n'.'的写法容易与其他预留关键字产生冲突\n'[ ]'的写法最安全。\n\n从DataFrame中取出行？（至少）两种⽅法：\n方法1和方法2：\n\nprint DF22[0:1] #给出的实际是DataFrame\n\nprint DF22.ix[0] #通过对应Index给出⾏,**ix**好爽。\n\n输出结果：\n\n nation  capital   GDP\n\n2  China  Beijing  9100\n\nnation     Japan\n\ncapital    Tokyo\n\nGDP         4900\n\nName: 0, dtype: object\n\n方法3 像NumPy切片一样的终极招式：iloc  ：\n\nprint DF22.iloc[0,:]    #第一个参数是第几行，第二个参数是列。这里呢，就是第0行，全部列\n\nprint DF22.iloc[:,0]    #根据上面的描述，这里是全部行，第0列\n\n输出结果，验证一下：\n\nnation       China\n\ncapital    Beijing\n\nGDP           9100\n\nName: 2, dtype: object\n\n2      China\n\n0      Japan\n\n1    S.Korea\n\nName: nation, dtype: object\n\n动态增加列列，但是无法用\".\"的方式，只能用\"[]\"\n举个栗子说明一下就明白了：\n\nDF22['population'] = [1600,130,55]\n\nDF22\n\n输出结果：\n\nnation    capital    GDP    population\n\n2    China    Beijing    9100    1600\n\n0    Japan    Tokyo    4900    130\n\n1    S.Korea    Seoul    1300    55\n\n三. Index：行级索引\nIndex：pandas进⾏数据操纵的鬼牌（行级索引）\n⾏级索引是：\n\n元数据\n可能由真实数据产生，因此可以视作数据\n可以由多重索引也就是多个列组合而成\n可以和列名进行交换，也可以进行堆叠和展开，达到Excel透视表效果\n\nIndex有四种...哦不，很多种写法，⼀些重要的索引类型包括：\n\npd.Index（普通）\nInt64Index（数值型索引）\nMultiIndex（多重索引，在数据操纵中更详细描述）\nDatetimeIndex（以时间格式作为索引）\nPeriodIndex （含周期的时间格式作为索引）\n\n直接定义普通索引，长得就和普通的Series⼀样\n\nindex_names = ['a','b','c']\n\nSeries_for_Index = pd.Series(index_names)\n\nprint pd.Index(index_names)\n\nprint pd.Index(Series_for_Index)\n\n输出结果：\n\nIndex([u'a', u'b', u'c'], dtype='object')\n\nIndex([u'a', u'b', u'c'], dtype='object')\n\n可惜Immutable，牢记！  不可变！举例如下：此处挖坑啊。不明白……\n\nindex_names = ['a','b','c'] \n\nindex0 = pd.Index(index_names) \n\nprint index0.get_values() \n\nindex0[2] = 'd'\n\n输出结果如下：\n\n['a' 'b' 'c']\n\n---------------------------------------------------------------------------\n\nTypeError                                 Traceback (most recent call last)\n\n<ipython-input-36-f34da0a8623c> in <module>()\n\n      2 index0 = pd.Index(index_names)\n\n      3 print index0.get_values()\n\n----> 4 index0[2] = 'd'\n\n\n\nC:\\Anaconda\\lib\\site-packages\\pandas\\core\\index.pyc in __setitem__(self, key, value)\n\n   1055 \n\n   1056     def __setitem__(self, key, value):\n\n-> 1057         raise TypeError(\"Indexes does not support mutable operations\")\n\n   1058 \n\n   1059     def __getitem__(self, key):\n\n\n\nTypeError: Indexes does not support mutable operations\n\n扔进去一个含有多元组的List，就有了MultiIndex\n可惜，如果这个List Comprehension改成小括号，就不对了。\n\nmulti1 = pd.Index([('Row_'+str(x+1),'Col_'+str(y+1)) for x in xrange(4) for y in xrange(4)])\n\nmulti1.name = ['index1','index2']\n\nprint multi1\n\n输出结果：\n\nMultiIndex(levels=[[u'Row_1', u'Row_2', u'Row_3', u'Row_4'], [u'Col_1', u'Col_2', u'Col_3', u'Col_4']],\n\n           labels=[[0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3], [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]])\n\n对于Series来说，如果拥有了多重Index，数据，变形！\n下列代码说明：\n\n二重MultiIndex的Series可以unstack()成DataFrame\nDataFrame可以stack成拥有⼆重MultiIndex的Series\n\n\ndata_for_multi1 = pd.Series(xrange(0,16),index=multi1)\n\ndata_for_multi1\n\n输出结果：\n\nRow_1  Col_1     0\n\n       Col_2     1\n\n       Col_3     2\n\n       Col_4     3\n\nRow_2  Col_1     4\n\n       Col_2     5\n\n       Col_3     6\n\n       Col_4     7\n\nRow_3  Col_1     8\n\n       Col_2     9\n\n       Col_3    10\n\n       Col_4    11\n\nRow_4  Col_1    12\n\n       Col_2    13\n\n       Col_3    14\n\n       Col_4    15\n\ndtype: int32\n\n看到输出结果，好像明白了点，有点类似Excel汇总一样。不过，日后还得查点资料\n二重MultiIndex的Series可以unstack()成DataFrame\n\ndata_for_multi1.unstack()\n\n\nDataFrame可以stack成拥有⼆重MultiIndex的Series\n\ndata_for_multi1.unstack().stack()\n\n输出结果：\n\nRow_1  Col_1     0\n\n       Col_2     1\n\n       Col_3     2\n\n       Col_4     3\n\nRow_2  Col_1     4\n\n       Col_2     5\n\n       Col_3     6\n\n       Col_4     7\n\nRow_3  Col_1     8\n\n       Col_2     9\n\n       Col_3    10\n\n       Col_4    11\n\nRow_4  Col_1    12\n\n       Col_2    13\n\n       Col_3    14\n\n       Col_4    15\n\ndtype: int32\n\n非平衡数据的例子：\n\nmulti2 = pd.Index([('Row_'+str(x+1),'Col_'+str(y+1)) for x in xrange(5) for y in xrange(x)])\n\nmulti2\n\n输出结果：\n\nMultiIndex(levels=[[u'Row_2', u'Row_3', u'Row_4', u'Row_5'], [u'Col_1', u'Col_2', u'Col_3', u'Col_4']],\n\n           labels=[[0, 1, 1, 2, 2, 2, 3, 3, 3, 3], [0, 0, 1, 0, 1, 2, 0, 1, 2, 3]])\n\n\ndata_for_multi2 = pd.Series(np.arange(10),index = multi2) data_for_multi2\n\n输出结果：\n\nRow_2  Col_1    0\n\nRow_3  Col_1    1\n\n       Col_2    2\n\nRow_4  Col_1    3\n\n       Col_2    4\n\n       Col_3    5\n\nRow_5  Col_1    6\n\n       Col_2    7\n\n       Col_3    8\n\n       Col_4    9\n\ndtype: int32\n\nDateTime标准库如此好⽤，你值得拥有\n\nimport datetime\n\ndates = [datetime.datetime(2015,1,1),datetime.datetime(2015,1,8),datetime.datetime(2015,1,30)]\n\npd.DatetimeIndex(dates)\n\n输出结果：\n\nDatetimeIndex(['2015-01-01', '2015-01-08', '2015-01-30'], dtype='datetime64[ns]', freq=None, tz=None)\n如果你不仅需要时间格式统一，时间频率也要统一的话\n\nperiodindex1 = pd.period_range('2015-01','2015-04',freq='M')\n\nprint periodindex1\n\n输出结果：\n\nPeriodIndex(['2015-01', '2015-02', '2015-03', '2015-04'], dtype='int64', freq='M')\n\n月级精度和日级精度如何转换？\n有的公司统⼀以1号代表当月，有的公司统一以最后1天代表当⽉，转化起来很麻烦，可以asfreq\n\nprint periodindex1.asfreq('D',how='start')\n\nprint periodindex1.asfreq('D',how='end')\n\n输出结果：\n\nPeriodIndex(['2015-01-01', '2015-02-01', '2015-03-01', '2015-04-01'], dtype='int64', freq='D')\n\nPeriodIndex(['2015-01-31', '2015-02-28', '2015-03-31', '2015-04-30'], dtype='int64', freq='D')\n\n最后的最后，我要真正把两种频率的时间精度匹配上？\n\nperiodindex_mon = pd.period_range('2015-01','2015-03',freq='M').asfreq('D',how='start')\n\nperiodindex_day = pd.period_range('2015-01-01','2015-03-31',freq='D')\n\nprint periodindex_mon\n\nprint periodindex_day\n\n输出结果：\n\nPeriodIndex(['2015-01-01', '2015-02-01', '2015-03-01'], dtype='int64', freq='D')\n\nPeriodIndex(['2015-01-01', '2015-01-02', '2015-01-03', '2015-01-04',\n\n             '2015-01-05', '2015-01-06', '2015-01-07', '2015-01-08',\n\n             '2015-01-09', '2015-01-10', '2015-01-11', '2015-01-12',\n\n             '2015-01-13', '2015-01-14', '2015-01-15', '2015-01-16',\n\n             '2015-01-17', '2015-01-18', '2015-01-19', '2015-01-20',\n\n             '2015-01-21', '2015-01-22', '2015-01-23', '2015-01-24',\n\n             '2015-01-25', '2015-01-26', '2015-01-27', '2015-01-28',\n\n             '2015-01-29', '2015-01-30', '2015-01-31', '2015-02-01',\n\n             '2015-02-02', '2015-02-03', '2015-02-04', '2015-02-05',\n\n             '2015-02-06', '2015-02-07', '2015-02-08', '2015-02-09',\n\n             '2015-02-10', '2015-02-11', '2015-02-12', '2015-02-13',\n\n             '2015-02-14', '2015-02-15', '2015-02-16', '2015-02-17',\n\n             '2015-02-18', '2015-02-19', '2015-02-20', '2015-02-21',\n\n             '2015-02-22', '2015-02-23', '2015-02-24', '2015-02-25',\n\n             '2015-02-26', '2015-02-27', '2015-02-28', '2015-03-01',\n\n             '2015-03-02', '2015-03-03', '2015-03-04', '2015-03-05',\n\n             '2015-03-06', '2015-03-07', '2015-03-08', '2015-03-09',\n\n             '2015-03-10', '2015-03-11', '2015-03-12', '2015-03-13',\n\n             '2015-03-14', '2015-03-15', '2015-03-16', '2015-03-17',\n\n             '2015-03-18', '2015-03-19', '2015-03-20', '2015-03-21',\n\n             '2015-03-22', '2015-03-23', '2015-03-24', '2015-03-25',\n\n             '2015-03-26', '2015-03-27', '2015-03-28', '2015-03-29',\n\n             '2015-03-30', '2015-03-31'],\n\n            dtype='int64', freq='D')\n\n粗粒度数据＋reindex＋ffill/bfill\n\n\nfull_ts = pd.Series(periodindex_mon,index=periodindex_mon).reindex(periodindex_day,method='ffill')\n\nfull_ts\n\n\n关于索引，⽅便的操作有？\n前⾯描述过了，索引有序，重复，但⼀定程度上⼜能通过key来访问，也就是说，某些集合操作都是可以⽀持的。\n\nindex1 = pd.Index(['A','B','B','C','C'])\n\nindex2 = pd.Index(['C','D','E','E','F'])\n\nindex3 = pd.Index(['B','C','A'])\n\nprint index1.append(index2)\n\nprint index1.difference(index2)\n\nprint index1.intersection(index2)\n\nprint index1.union(index2) # Support unique-value Index well\n\nprint index1.isin(index2)\n\nprint index1.delete(2)\n\nprint index1.insert(0,'K') # Not suggested\n\nprint index3.drop('A') # Support unique-value Index well\n\nprint index1.is_monotonic,index2.is_monotonic,index3.is_monotonic\n\nprint index1.is_unique,index2.is_unique,index3.is_unique\n\n输出结果：\n\nIndex([u'A', u'B', u'B', u'C', u'C', u'C', u'D', u'E', u'E', u'F'], dtype='object')\n\nIndex([u'A', u'B'], dtype='object')\n\nIndex([u'C', u'C'], dtype='object')\n\nIndex([u'A', u'B', u'B', u'C', u'C', u'D', u'E', u'E', u'F'], dtype='object')\n\n[False False False  True  True]\n\nIndex([u'A', u'B', u'C', u'C'], dtype='object')\n\nIndex([u'K', u'A', u'B', u'B', u'C', u'C'], dtype='object')\n\nIndex([u'B', u'C'], dtype='object')\n\nTrue True False\n\nFalse False True\n\n参考：\n\nS1EP3_Pandas.pdf 不知道什么时候存到电脑里的资料，今天发现了它。感谢作者的资料。\nPython数据分析入门之pandas总结基础（二）\n\n欢迎来Michael翔的博客查看完成版。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "20"}