{"title": "合并两个已排序的链表 - leetcode ", "index": "leetcode,算法,python", "content": "合并两个已排序的链表\nMerge Two Sorted Lists\n\n合并两个已排序的链表，新链表中的每个节点必须是来自输入的两个链表的节点（即不能构造新的节点），返回新链表的头部。\nMerge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.\n\nexample 1\ninput: 1->2->4, 3->8\noutput: 1->2->3->4->8\n\n思路\n\nhead指向输入两个链表中头节点较小值，作为新链表的头部\ntail指向新链表表尾，初始状态head = tail\na扫描l1，b扫描l2，比较a和b节点内值的大小，将较小的加入tail之后，a和b中较小的向后移动一个节点，较大的不动，tail向后移动一个节点保证任意时候指向都是新链表尾部\nl1和l2其中一个已经遍历完，若另一个还有元素，添加到tail之后\n\n代码\n# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution(object):\n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if None in (l1, l2):\n            return l1 or l2\n        head = tail = l1 if l1.val <= l2.val else l2\n        a = l1 if l1.val > l2.val else l1.next\n        b = l2 if l1.val <= l2.val else l2.next\n        while a and b:\n            if a.val <= b.val:\n                tail.next = a\n                tail, a = tail.next, a.next\n            else:\n                tail.next = b\n                tail, b = tail.next, b.next\n        tail.next = a or b\n        return head\n本题以及其它leetcode题目代码github地址: github地址\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}