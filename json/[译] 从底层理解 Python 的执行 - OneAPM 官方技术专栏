{"title": "[译] 从底层理解 Python 的执行 - OneAPM 官方技术专栏 ", "index": "python", "content": "原文链接： Understanding Python execution from inside: A Python assembly tracer\n\n以下为译文\n\n\n最近我在学习 Python 的运行模型。我对 Python 的一些内部机制很是好奇，比如 Python 是怎么实现类似 YIELDVALUE、YIELDFROM 这样的操作码的；对于 递推式构造列表(List Comprehensions)、生成器表达式(generator expressions)以及其他一些有趣的 Python 特性是怎么编译的；从字节码的层面来看，当异常抛出的时候都发生了什么事情。翻阅 CPython 的代码对于解答这些问题当然是很有帮助的，但我仍然觉得以这样的方式来做的话对于理解字节码的执行和堆栈的变化还是缺少点什么。GDB 是个好选择，但是我懒，而且只想使用一些比较高阶的接口写点 Python 代码来完成这件事。\n\n所以呢，我的目标就是创建一个字节码级别的追踪 API，类似 sys.setrace 所提供的那样，但相对而言会有更好的粒度。这充分锻炼了我编写 Python 实现的 C 代码的编码能力。我们所需要的有如下几项，在这篇文章中所用的 Python 版本为 3.5。\n\n\n一个新的 Cpython 解释器操作码\n一种将操作码注入到 Python 字节码的方法\n一些用于处理操作码的 Python 代码\n\n一个新的 Cpython 操作码\n\n新操作码：DEBUG_OP\n\n这个新的操作码 DEBUG_OP 是我第一次尝试写 CPython 实现的 C 代码，我将尽可能的让它保持简单。 我们想要达成的目的是，当我们的操作码被执行的时候我能有一种方式来调用一些 Python 代码。同时，我们也想能够追踪一些与执行上下文有关的数据。我们的操作码会把这些信息当作参数传递给我们的回调函数。通过操作码能辨识出的有用信息如下：\n\n\n堆栈的内容\n执行 DEBUG_OP 的帧对象信息\n\n所以呢，我们的操作码需要做的事情是：\n\n\n找到回调函数\n创建一个包含堆栈内容的列表\n调用回调函数，并将包含堆栈内容的列表和当前帧作为参数传递给它\n\n听起来挺简单的，现在开始动手吧！声明：下面所有的解释说明和代码是经过了大量段错误调试之后总结得到的结论。首先要做的是给操作码定义一个名字和相应的值，因此我们需要在 Include/opcode.h中添加代码。\n\n    /** My own comments begin by '**' **/  \n    /** From: Includes/opcode.h **/  \n\n    /* Instruction opcodes for compiled code */  \n\n    /** We just have to define our opcode with a free value  \n        0 was the first one I found **/  \n    #define DEBUG_OP                0  \n\n    #define POP_TOP                 1  \n    #define ROT_TWO                 2  \n    #define ROT_THREE               3  \n\n\n这部分工作就完成了，现在我们去编写操作码真正干活的代码。\n\n实现 DEBUG_OP\n\n在考虑如何实现DEBUG_OP之前我们需要了解的是 DEBUG_OP 提供的接口将长什么样。 拥有一个可以调用其他代码的新操作码是相当酷眩的，但是究竟它将调用哪些代码捏？这个操作码如何找到回调函数的捏？我选择了一种最简单的方法：在帧的全局区域写死函数名。那么问题就变成了，我该怎么从字典中找到一个固定的 C 字符串？为了回答这个问题我们来看看在 Python 的 main loop 中使用到的和上下文管理相关的标识符 enter 和 exit。\n\n我们可以看到这两标识符被使用在操作码 SETUP_WITH 中：\n\n    /** From: Python/ceval.c **/  \n    TARGET(SETUP_WITH) {  \n    _Py_IDENTIFIER(__exit__);  \n    _Py_IDENTIFIER(__enter__);  \n    PyObject *mgr = TOP();  \n    PyObject *exit = special_lookup(mgr, &PyId___exit__), *enter;  \n    PyObject *res;  \n\n\n现在，看一眼宏 _Py_IDENTIFIER 定义\n\n/** From: Include/object.h **/\n\n/********************* String Literals ****************************************/\n/* This structure helps managing static strings. The basic usage goes like this:\n   Instead of doing\n\n       r = PyObject_CallMethod(o, \"foo\", \"args\", ...);\n\n   do\n\n       _Py_IDENTIFIER(foo);\n       ...\n       r = _PyObject_CallMethodId(o, &PyId_foo, \"args\", ...);\n\n   PyId_foo is a static variable, either on block level or file level. On first\n   usage, the string \"foo\" is interned, and the structures are linked. On interpreter\n   shutdown, all strings are released (through _PyUnicode_ClearStaticStrings).\n\n   Alternatively, _Py_static_string allows to choose the variable name.\n   _PyUnicode_FromId returns a borrowed reference to the interned string.\n   _PyObject_{Get,Set,Has}AttrId are __getattr__ versions using _Py_Identifier*.\n*/\ntypedef struct _Py_Identifier {\n    struct _Py_Identifier *next;\n    const char* string;\n    PyObject *object;\n} _Py_Identifier;\n\n#define _Py_static_string_init(value) { 0, value, 0 }\n#define _Py_static_string(varname, value)  static _Py_Identifier varname = _Py_static_string_init(value)\n#define _Py_IDENTIFIER(varname) _Py_static_string(PyId_##varname, #varname)\n\n\n嗯，注释部分已经说明得很清楚了。通过一番查找，我们发现了可以用来从字典找固定字符串的函数 _PyDict_GetItemId，所以我们操作码的查找部分的代码就是长这样滴。\n\n     /** Our callback function will be named op_target **/  \n    PyObject *target = NULL;  \n    _Py_IDENTIFIER(op_target);  \n    target = _PyDict_GetItemId(f->f_globals, &PyId_op_target);  \n    if (target == NULL && _PyErr_OCCURRED()) {  \n        if (!PyErr_ExceptionMatches(PyExc_KeyError))  \n            goto error;  \n        PyErr_Clear();  \n        DISPATCH();  \n    }  \n\n\n为了方便理解，对这一段代码做一些说明：\n\n\nf 是当前的帧，f->f_globals 是它的全局区域\n如果我们没有找到 op_target，我们将会检查这个异常是不是 KeyError\ngoto error; 是一种在 main loop 中抛出异常的方法\nPyErr_Clear() 抑制了当前异常的抛出，而 DISPATCH() 触发了下一个操作码的执行\n\n下一步就是收集我们想要的堆栈信息。\n\n    /** This code create a list with all the values on the current   stack **/  \n    PyObject *value = PyList_New(0);  \n    for (i = 1 ; i <= STACK_LEVEL(); i++) {  \n        tmp = PEEK(i);  \n        if (tmp == NULL) {  \n            tmp = Py_None;  \n        }  \n        PyList_Append(value, tmp);  \n    }  \n\n\n最后一步就是调用我们的回调函数！我们用 call_function 来搞定这件事，我们通过研究操作码 CALL_FUNCTION 的实现来学习怎么使用 call_function 。\n\n    /** From: Python/ceval.c **/  \n    TARGET(CALL_FUNCTION) {  \n        PyObject **sp, *res;  \n        /** stack_pointer is a local of the main loop.  \n            It's the pointer to the stacktop of our frame **/  \n        sp = stack_pointer;  \n        res = call_function(&sp, oparg);  \n        /** call_function handles the args it consummed on the stack     for us **/  \n        stack_pointer = sp;  \n        PUSH(res);  \n        /** Standard exception handling **/  \n        if (res == NULL)  \n            goto error;  \n        DISPATCH();  \n    }  \n\n\n有了上面这些信息，我们终于可以捣鼓出一个操作码DEBUG_OP的草稿了：\n\n    TARGET(DEBUG_OP) {  \n        PyObject *value = NULL;  \n        PyObject *target = NULL;  \n        PyObject *res = NULL;  \n        PyObject **sp = NULL;  \n        PyObject *tmp;  \n        int i;  \n        _Py_IDENTIFIER(op_target);  \n\n        target = _PyDict_GetItemId(f->f_globals, &PyId_op_target);  \n        if (target == NULL && _PyErr_OCCURRED()) {  \n            if (!PyErr_ExceptionMatches(PyExc_KeyError))  \n                goto error;  \n            PyErr_Clear();  \n            DISPATCH();  \n        }  \n        value = PyList_New(0);  \n        Py_INCREF(target);  \n        for (i = 1 ; i <= STACK_LEVEL(); i++) {  \n            tmp = PEEK(i);  \n            if (tmp == NULL)  \n                tmp = Py_None;  \n            PyList_Append(value, tmp);  \n        }  \n\n        PUSH(target);  \n        PUSH(value);  \n        Py_INCREF(f);  \n        PUSH(f);  \n        sp = stack_pointer;  \n        res = call_function(&sp, 2);  \n        stack_pointer = sp;  \n        if (res == NULL)  \n            goto error;  \n        Py_DECREF(res);  \n        DISPATCH();  \n    }\n\n\n在编写 CPython 实现的 C 代码方面我确实没有什么经验，有可能我漏掉了些细节。如果您有什么建议还请您纠正，我期待您的反馈。\n\n编译它，成了！\n\n一切看起来很顺利，但是当我们尝试去使用我们定义的操作码 DEBUG_OP 的时候却失败了。自从 2008 年之后，Python 使用预先写好的 goto(你也可以从 这里获取更多的讯息)。故，我们需要更新下 goto jump table，我们在 Python/opcode_targets.h 中做如下修改。\n\n    /** From: Python/opcode_targets.h **/  \n    /** Easy change since DEBUG_OP is the opcode number 1 **/  \n    static void *opcode_targets[256] = {  \n        //&&_unknown_opcode,  \n        &&TARGET_DEBUG_OP,  \n        &&TARGET_POP_TOP,  \n        /** ... **/  \n\n\n这就完事了，我们现在就有了一个可以工作的新操作码。唯一的问题就是这货虽然存在，但是没有被人调用过。接下来，我们将DEBUG_OP注入到函数的字节码中。\n\n在 Python 字节码中注入操作码 DEBUG_OP\n\n有很多方式可以在 Python 字节码中注入新的操作码：\n\n\n使用 peephole optimizer， Quarkslab就是这么干的\n在生成字节码的代码中动些手脚\n在运行时直接修改函数的字节码(这就是我们将要干的事儿)\n\n为了创造出一个新操作码，有了上面的那一堆 C 代码就够了。现在让我们回到原点，开始理解奇怪甚至神奇的 Python！\n\n我们将要做的事儿有：\n\n\n得到我们想要追踪函数的 code object\n重写字节码来注入 DEBUG_OP\n将新生成的 code object 替换回去\n\n和 code object 有关的小贴士\n\n如果你从没听说过 code object，这里有一个简单的介绍网路上也有一些相关的文档可供查阅，可以直接 Ctrl+F 查找 code object\n\n还有一件事情需要注意的是在这篇文章所指的环境中 code object 是不可变的：\n\n    Python 3.4.2 (default, Oct  8 2014, 10:45:20)  \n    [GCC 4.9.1] on linux  \n    Type \"help\", \"copyright\", \"credits\" or \"license\" for more      information.  \n    >>> x = lambda y : 2  \n    >>> x.__code__  \n    <code object <lambda> at 0x7f481fd88390, file \"<stdin>\", line 1>      \n    >>> x.__code__.co_name  \n    '<lambda>'  \n    >>> x.__code__.co_name = 'truc'  \n    Traceback (most recent call last):  \n      File \"<stdin>\", line 1, in <module>  \n    AttributeError: readonly attribute  \n    >>> x.__code__.co_consts = ('truc',)  \n    Traceback (most recent call last):  \n      File \"<stdin>\", line 1, in <module>  \n    AttributeError: readonly attribute  \n\n\n但是不用担心，我们将会找到方法绕过这个问题的。\n\n使用的工具\n\n为了修改字节码我们需要一些工具：\n\n\n\ndis模块用来反编译和分析字节码\ndis.BytecodePython 3.4新增的一个特性，对于反编译和分析字节码特别有用\n一个能够简单修改 code object 的方法\n\n用 dis.Bytecode 反编译 code object 能告诉我们一些有关操作码、参数和上下文的信息。\n\n    # Python3.4  \n    >>> import dis  \n    >>> f = lambda x: x + 3  \n    >>> for i in dis.Bytecode(f.__code__): print (i)  \n    ...  \n    Instruction(opname='LOAD_FAST', opcode=124, arg=0, argval='x',       argrepr='x', offset=0, starts_line=1, is_jump_target=False)  \n    Instruction(opname='LOAD_CONST', opcode=100, arg=1, argval=3,        argrepr='3', offset=3, starts_line=None, is_jump_target=False)  \n    Instruction(opname='BINARY_ADD', opcode=23, arg=None,            argval=None, argrepr='', offset=6, starts_line=None,     is_jump_target=False)  \n    Instruction(opname='RETURN_VALUE', opcode=83, arg=None,       argval=None, argrepr='', offset=7, starts_line=None,    is_jump_target=False)  \n\n\n为了能够修改 code object，我定义了一个很小的类用来复制 code object，同时能够按我们的需求修改相应的值，然后重新生成一个新的 code object。\n\n    class MutableCodeObject(object):  \n        args_name = (\"co_argcount\", \"co_kwonlyargcount\",  \"co_nlocals\", \"co_stacksize\", \"co_flags\", \"co_code\",  \n                      \"co_consts\", \"co_names\", \"co_varnames\",     \"co_filename\", \"co_name\", \"co_firstlineno\",  \n                       \"co_lnotab\", \"co_freevars\", \"co_cellvars\")  \n\n        def __init__(self, initial_code):  \n            self.initial_code = initial_code  \n            for attr_name in self.args_name:  \n                attr = getattr(self.initial_code, attr_name)  \n                if isinstance(attr, tuple):  \n                    attr = list(attr)  \n                setattr(self, attr_name, attr)  \n\n        def get_code(self):  \n            args = []  \n            for attr_name in self.args_name:  \n                attr = getattr(self, attr_name)  \n                if isinstance(attr, list):  \n                    attr = tuple(attr)  \n                args.append(attr)  \n            return self.initial_code.__class__(*args)  \n\n\n这个类用起来很方便，解决了上面提到的 code object 不可变的问题。\n\n    >>> x = lambda y : 2  \n    >>> m = MutableCodeObject(x.__code__)  \n    >>> m  \n    <new_code.MutableCodeObject object at 0x7f3f0ea546a0>  \n    >>> m.co_consts  \n    [None, 2]  \n    >>> m.co_consts[1] = '3'  \n    >>> m.co_name = 'truc'  \n    >>> m.get_code()  \n    <code object truc at 0x7f3f0ea2bc90, file \"<stdin>\", line 1>  \n\n\n测试我们的新操作码\n\n我们现在拥有了注入 DEBUG_OP 的所有工具，让我们来验证下我们的实现是否可用。我们将我们的操作码注入到一个最简单的函数中：\n\n    from new_code import MutableCodeObject  \n\n    def op_target(*args):  \n        print(\"WOOT\")  \n        print(\"op_target called with args <{0}>\".format(args))  \n\n    def nop():  \n       pass  \n\n    new_nop_code = MutableCodeObject(nop.__code__)  \n    new_nop_code.co_code = b\"\\x00\" + new_nop_code.co_code[0:3] +  b\"\\x00\" + new_nop_code.co_code[-1:]  \n    new_nop_code.co_stacksize += 3  \n\n    nop.__code__ = new_nop_code.get_code()  \n\n    import dis  \n    dis.dis(nop)  \n    nop()  \n\n\n    # Don't forget that ./python is our custom Python implementing       DEBUG_OP  \n    hakril@computer ~/python/CPython3.5 % ./python proof.py  \n      8           0 <0>  \n                  1 LOAD_CONST               0 (None)  \n                  4 <0>  \n                  5 RETURN_VALUE  \n    WOOT  \n    op_target called with args <([], <frame object at  0x7fde9eaebdb0>)>  \n    WOOT  \n    op_target called with args <([None], <frame object at   0x7fde9eaebdb0>)>  \n\n\n看起来它成功了！有一行代码需要说明一下 new_nop_code.co_stacksize += 3\n\n\nco_stacksize 表示 code object 所需要的堆栈的大小\n操作码DEBUG_OP往堆栈中增加了三项，所以我们需要为这些增加的项预留些空间\n\n现在我们可以将我们的操作码注入到每一个 Python 函数中了！\n\n重写字节码\n\n正如我们在上面的例子中所看到的那样，重写 Pyhton 的字节码似乎 so easy。为了在每一个操作码之间注入我们的操作码，我们需要获取每一个操作码的偏移量，然后将我们的操作码注入到这些位置上(把我们操作码注入到参数上是有坏处大大滴)。这些偏移量也很容易获取，使用 dis.Bytecode，就像这样。\n\n    def add_debug_op_everywhere(code_obj):  \n         # We get every instruction offset in the code object  \n        offsets = [instr.offset for instr in dis.Bytecode(code_obj)]   \n        # And insert a DEBUG_OP at every offset  \n        return insert_op_debug_list(code_obj, offsets)  \n\n    def insert_op_debug_list(code, offsets):  \n         # We insert the DEBUG_OP one by one  \n        for nb, off in enumerate(sorted(offsets)):  \n            # Need to ajust the offsets by the number of opcodes          already inserted before  \n            # That's why we sort our offsets!  \n            code = insert_op_debug(code, off + nb)  \n        return code  \n\n    # Last problem: what does insert_op_debug looks like?  \n\n\n基于上面的例子，有人可能会想我们的 insert_op_debug 会在指定的偏移量增加一个\"\\x00\"，这尼玛是个坑啊！我们第一个 DEBUG_OP 注入的例子中被注入的函数是没有任何的分支的，为了能够实现完美一个函数注入函数 insert_op_debug 我们需要考虑到存在分支操作码的情况。\n\nPython 的分支一共有两种：\n\n\n绝对分支：看起来是类似这样子的 Instruction_Pointer = argument(instruction)\n相对分支：看起来是类似这样子的 Instruction_Pointer += argument(instruction)\n相对分支总是向前的\n\n\n\n我们希望这些分支在我们插入操作码之后仍然能够正常工作，为此我们需要修改一些指令参数。以下是其逻辑流程：\n\n\n对于每一个在插入偏移量之前的相对分支而言\n如果目标地址是严格大于我们的插入偏移量的话，将指令参数增加 1\n如果相等，则不需要增加 1 就能够在跳转操作和目标地址之间执行我们的操作码DEBUG_OP\n如果小于，插入我们的操作码的话并不会影响到跳转操作和目标地址之间的距离\n\n\n对于 code object 中的每一个绝对分支而言\n如果目标地址是严格大于我们的插入偏移量的话，将指令参数增加 1\n如果相等，那么不需要任何修改，理由和相对分支部分是一样的\n如果小于，插入我们的操作码的话并不会影响到跳转操作和目标地址之间的距离\n\n\n\n下面是实现：\n\n    # Helper  \n    def bytecode_to_string(bytecode):  \n        if bytecode.arg is not None:  \n            return struct.pack(\"<Bh\", bytecode.opcode, bytecode.arg)   \n        return struct.pack(\"<B\", bytecode.opcode)  \n\n    # Dummy class for bytecode_to_string  \n    class DummyInstr:  \n        def __init__(self, opcode, arg):  \n            self.opcode = opcode  \n            self.arg = arg  \n\n    def insert_op_debug(code, offset):  \n        opcode_jump_rel = ['FOR_ITER', 'JUMP_FORWARD', 'SETUP_LOOP',      'SETUP_WITH', 'SETUP_EXCEPT', 'SETUP_FINALLY']  \n        opcode_jump_abs = ['POP_JUMP_IF_TRUE', 'POP_JUMP_IF_FALSE',     'JUMP_ABSOLUTE']  \n        res_codestring = b\"\"  \n        inserted = False  \n        for instr in dis.Bytecode(code):  \n            if instr.offset == offset:  \n                res_codestring += b\"\\x00\"  \n                inserted = True  \n            if instr.opname in opcode_jump_rel and not inserted:     #relative jump are always forward  \n                if offset < instr.offset + 3 + instr.arg: # inserted     beetwen jump and dest: add 1 to dest (3 for size)  \n                     #If equal: jump on DEBUG_OP to get info before      exec instr  \n                    res_codestring +=     bytecode_to_string(DummyInstr(instr.opcode, instr.arg + 1))  \n                    continue  \n            if instr.opname in opcode_jump_abs:  \n                if instr.arg > offset:  \n                    res_codestring +=      bytecode_to_string(DummyInstr(instr.opcode, instr.arg + 1))  \n                    continue  \n            res_codestring += bytecode_to_string(instr)  \n        # replace_bytecode just replaces the original code co_code  \n        return replace_bytecode(code, res_codestring)  \n\n\n让我们看一下效果如何：\n\n    >>> def lol(x):  \n    ...     for i in range(10):  \n    ...         if x == i:  \n    ...             break  \n\n    >>> dis.dis(lol)  \n    101           0 SETUP_LOOP              36 (to 39)  \n                  3 LOAD_GLOBAL              0 (range)  \n                  6 LOAD_CONST               1 (10)  \n                  9 CALL_FUNCTION            1 (1 positional, 0    keyword pair)  \n                 12 GET_ITER  \n            >>   13 FOR_ITER                22 (to 38)  \n                 16 STORE_FAST               1 (i)  \n\n    102          19 LOAD_FAST                0 (x)  \n                 22 LOAD_FAST                1 (i)  \n                 25 COMPARE_OP               2 (==)  \n                 28 POP_JUMP_IF_FALSE       13  \n\n    103          31 BREAK_LOOP  \n                 32 JUMP_ABSOLUTE           13  \n                 35 JUMP_ABSOLUTE           13  \n            >>   38 POP_BLOCK  \n            >>   39 LOAD_CONST               0 (None)  \n                 42 RETURN_VALUE  \n    >>> lol.__code__ = transform_code(lol.__code__,        add_debug_op_everywhere, add_stacksize=3)  \n\n\n    >>> dis.dis(lol)  \n    101           0 <0>  \n                  1 SETUP_LOOP              50 (to 54)  \n                  4 <0>  \n                  5 LOAD_GLOBAL              0 (range)  \n                  8 <0>  \n                  9 LOAD_CONST               1 (10)  \n                 12 <0>  \n                 13 CALL_FUNCTION            1 (1 positional, 0   keyword pair)  \n                 16 <0>  \n                 17 GET_ITER  \n            >>   18 <0>  \n\n    102          19 FOR_ITER                30 (to 52)  \n                 22 <0>  \n                 23 STORE_FAST               1 (i)  \n                 26 <0>  \n                 27 LOAD_FAST                0 (x)  \n                 30 <0>  \n\n    103          31 LOAD_FAST                1 (i)  \n                 34 <0>  \n                 35 COMPARE_OP               2 (==)  \n                 38 <0>  \n                 39 POP_JUMP_IF_FALSE       18  \n                 42 <0>  \n                 43 BREAK_LOOP  \n                 44 <0>  \n                 45 JUMP_ABSOLUTE           18  \n                 48 <0>  \n                 49 JUMP_ABSOLUTE           18  \n            >>   52 <0>  \n                 53 POP_BLOCK  \n            >>   54 <0>  \n                 55 LOAD_CONST               0 (None)  \n                 58 <0>  \n                 59 RETURN_VALUE  \n\n     # Setup the simplest handler EVER  \n    >>> def op_target(stack, frame):  \n    ...     print (stack)  \n\n    # GO  \n    >>> lol(2)  \n    []  \n    []  \n    [<class 'range'>]  \n    [10, <class 'range'>]  \n    [range(0, 10)]  \n    [<range_iterator object at 0x7f1349afab80>]  \n    [0, <range_iterator object at 0x7f1349afab80>]  \n    [<range_iterator object at 0x7f1349afab80>]  \n    [2, <range_iterator object at 0x7f1349afab80>]  \n    [0, 2, <range_iterator object at 0x7f1349afab80>]  \n    [False, <range_iterator object at 0x7f1349afab80>]  \n    [<range_iterator object at 0x7f1349afab80>]  \n    [1, <range_iterator object at 0x7f1349afab80>]  \n    [<range_iterator object at 0x7f1349afab80>]  \n    [2, <range_iterator object at 0x7f1349afab80>]  \n    [1, 2, <range_iterator object at 0x7f1349afab80>]  \n    [False, <range_iterator object at 0x7f1349afab80>]  \n    [<range_iterator object at 0x7f1349afab80>]  \n    [2, <range_iterator object at 0x7f1349afab80>]  \n    [<range_iterator object at 0x7f1349afab80>]  \n    [2, <range_iterator object at 0x7f1349afab80>]  \n    [2, 2, <range_iterator object at 0x7f1349afab80>]  \n    [True, <range_iterator object at 0x7f1349afab80>]  \n    [<range_iterator object at 0x7f1349afab80>]  \n    []  \n    [None]  \n\n\n甚好！现在我们知道了如何获取堆栈信息和 Python 中每一个操作对应的帧信息。上面结果所展示的结果目前而言并不是很实用。在最后一部分中让我们对注入做进一步的封装。\n\n增加 Python 封装\n\n正如您所见到的，所有的底层接口都是好用的。我们最后要做的一件事是让 op_target 更加方便使用(这部分相对而言比较空泛一些，毕竟在我看来这不是整个项目中最有趣的部分)。\n\n首先我们来看一下帧的参数所能提供的信息，如下所示：\n\n\nf_code当前帧将执行的 code object\nf_lasti当前的操作(code object 中的字节码字符串的索引)\n\n经过我们的处理我们可以得知 DEBUG_OP 之后要被执行的操作码，这对我们聚合数据并展示是相当有用的。\n\n新建一个用于追踪函数内部机制的类：\n\n\n改变函数自身的 co_code\n设置回调函数作为 op_debug 的目标函数\n\n一旦我们知道下一个操作，我们就可以分析它并修改它的参数。举例来说我们可以增加一个 auto-follow-called-functions 的特性。\n\n    def op_target(l, f, exc=None):  \n        if op_target.callback is not None:  \n            op_target.callback(l, f, exc)  \n\n    class Trace:  \n        def __init__(self, func):  \n            self.func = func  \n\n        def call(self, *args, **kwargs):  \n             self.add_func_to_trace(self.func)  \n            # Activate Trace callback for the func call  \n            op_target.callback = self.callback  \n            try:  \n                res = self.func(*args, **kwargs)  \n            except Exception as e:  \n                res = e  \n            op_target.callback = None  \n            return res  \n\n        def add_func_to_trace(self, f):  \n            # Is it code? is it already transformed?  \n            if not hasattr(f ,\"op_debug\") and hasattr(f, \"__code__\"):  \n                f.__code__ = transform_code(f.__code__,    transform=add_everywhere, add_stacksize=ADD_STACK)  \n                f.__globals__['op_target'] = op_target  \n                f.op_debug = True  \n\n        def do_auto_follow(self, stack, frame):  \n            # Nothing fancy: FrameAnalyser is just the wrapper that  gives the next executed instruction  \n            next_instr = FrameAnalyser(frame).next_instr()  \n            if \"CALL\" in next_instr.opname:  \n                arg = next_instr.arg  \n                f_index = (arg & 0xff) + (2 * (arg >> 8))  \n                called_func = stack[f_index]  \n\n                # If call target is not traced yet: do it  \n                if not hasattr(called_func, \"op_debug\"):  \n                    self.add_func_to_trace(called_func)  \n\n\n现在我们实现一个 Trace 的子类，在这个子类中增加 callback 和 doreport 这两个方法。callback 方法将在每一个操作之后被调用。doreport 方法将我们收集到的信息打印出来。\n\n这是一个伪函数追踪器实现：\n\n    class DummyTrace(Trace):  \n        def __init__(self, func):  \n            self.func = func  \n            self.data = collections.OrderedDict()  \n            self.last_frame = None  \n            self.known_frame = []  \n            self.report = []  \n\n        def callback(self, stack, frame, exc):  \n             if frame not in self.known_frame:  \n                self.known_frame.append(frame)  \n                self.report.append(\" === Entering New Frame {0} ({1})     ===\".format(frame.f_code.co_name, id(frame)))  \n                self.last_frame = frame  \n            if frame != self.last_frame:  \n                self.report.append(\" === Returning to Frame {0}     {1}===\".format(frame.f_code.co_name, id(frame)))  \n                self.last_frame = frame  \n\n            self.report.append(str(stack))  \n            instr = FrameAnalyser(frame).next_instr()  \n            offset = str(instr.offset).rjust(8)  \n            opname = str(instr.opname).ljust(20)  \n            arg = str(instr.arg).ljust(10)  \n            self.report.append(\"{0}  {1} {2} {3}\".format(offset,    opname, arg, instr.argval))  \n            self.do_auto_follow(stack, frame)  \n\n        def do_report(self):  \n            print(\"\\n\".join(self.report))  \n\n\n这里有一些实现的例子和使用方法。格式有些不方便观看，毕竟我并不擅长于搞这种对用户友好的报告的事儿。\n\n\n\n例1自动追踪堆栈信息和已经执行的指令\n\n例2上下文管理\n\n递推式构造列表(List Comprehensions)的追踪示例。\n\n\n\n例3伪追踪器的输出\n\n例4输出收集的堆栈信息\n\n总结\n\n这个小项目是一个了解 Python 底层的良好途径，包括解释器的 main loop，Python 实现的 C 代码编程、Python 字节码。通过这个小工具我们可以看到 Python 一些有趣构造函数的字节码行为，例如生成器、上下文管理和递推式构造列表。\n\n这里是这个小项目的完整代码。更进一步的，我们还可以做的是修改我们所追踪的函数的堆栈。我虽然不确定这个是否有用，但是可以肯定是这一过程是相当有趣的。\n\n\n本文作者系OneAPM工程师编译整理。想阅读更多技术文章，请访问OneAPM官方技术博客。\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "27"}