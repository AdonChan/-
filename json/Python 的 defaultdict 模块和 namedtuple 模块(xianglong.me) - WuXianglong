{"title": "Python 的 defaultdict 模块和 namedtuple 模块(xianglong.me) - WuXianglong ", "index": "python", "content": "在Python中有一些内置的数据类型，比如int, str, list, tuple, dict等。Python的collections模块在这些内置数据类型的基础上，提供了几个额外的数据类型：namedtuple, defaultdict, deque, Counter, OrderedDict等，其中defaultdict和namedtuple是两个很实用的扩展类型。defaultdict继承自dict，namedtuple继承自tuple。\n\n一、defaultdict\n\n1. 简介\n\n在使用Python原生的数据结构dict的时候，如果用d[key]这样的方式访问，当指定的key不存在时，是会抛出KeyError异常的。但是，如果使用defaultdict，只要你传入一个默认的工厂方法，那么请求一个不存在的key时， 便会调用这个工厂方法使用其结果来作为这个key的默认值。\n\ndefaultdict在使用的时候需要传一个工厂函数(function_factory)，defaultdict(function_factory)会构建一个类似dict的对象，该对象具有默认值，默认值通过调用工厂函数生成。\n\n2. 示例\n\n下面给一个defaultdict的使用示例：\n\nIn [1]: from collections import defaultdict\n\nIn [2]: s = [('xiaoming', 99), ('wu', 69), ('zhangsan', 80), ('lisi', 96), ('wu', 100), ('yuan', 98), ('xiaoming', 89)]\n\nIn [3]: d = defaultdict(list)\n\nIn [4]: for k, v in s:\n   ...:     d[k].append(v)\n   ...:     \n\nIn [5]: d\nOut[5]: defaultdict(<type 'list'>, {'lisi': [96], 'xiaoming': [99, 89], 'yuan': [98], 'zhangsan': [80], 'wu': [69, 100]})\n\nIn [6]: for k, v in d.items():\n   ...:     print '%s: %s' % (k, v)\n   ...:     \nlisi: [96]\nxiaoming: [99, 89]\nyuan: [98]\nzhangsan: [80]\nwu: [69, 100]\n\n\n对Python比较熟悉的同学可以发现defaultdict(list)的用法和dict.setdefault(key, [])比较类似，上述代码使用setdefault实现如下：\n\ns = [('xiaoming', 99), ('wu', 69), ('zhangsan', 80), ('lisi', 96), ('wu', 100), ('yuan', 98), ('xiaoming', 89)]\nd = {}\n\nfor k, v in s:\n    d.setdefault(k, []).append(v)\n\n\n3. 原理\n\n从以上的例子中，我们可以基本了defaultdict的用法，下面我们可以通过help(defaultdict)了解一下defaultdict的原理。通过Python console打印出的help信息来看，我们可以发现defaultdict具有默认值主要是通过missing方法实现的，如果工厂函数不为None，则通过工厂方法返回默认值，具体如下：\n\ndef __missing__(self, key):\n    # Called by __getitem__ for missing key\n    if self.default_factory is None:\n        raise KeyError((key,))\n    self[key] = value = self.default_factory()\n    return value\n\n\n从上面的说明中，我们可以发现一下几个需要注意的地方：\n\n\nmissing方法是在调用getitem方法发现KEY不存在时才调用的，所以，defaultdict也只会在使用d[key]或者d.getitem(key)的时候才会生成默认值；如果使用d.get(key)是不会返回默认值的，会出现KeyError；\n\ndefaultdict主要是通过missing方法实现，所以，我们也可以通过实现该方法来生成自己的defaultdict，代码入下\n\nIn [1]: class MyDefaultDict(dict):\n   ...:     def __missing__(self, key):\n   ...:         self[key] = 'default'\n   ...:         return 'default'\n   ...:     \n\nIn [2]: my_default_dict = MyDefaultDict()\n\nIn [3]: my_default_dict\nOut[3]: {}\n\nIn [4]: print my_default_dict['test']\ndefault\n\nIn [5]: my_default_dict\nOut[5]: {'test': 'default'}\n\n\n\n4. 版本\n\ndefaultdict是在Python 2.5之后才加入的功能，在旧版本的Python中是不支持这个功能的，不过，知道了它的原理，我们可以自己实现一个defaultdict。\n\n# http://code.activestate.com/recipes/523034/\ntry:\n    from collections import defaultdict\nexcept:\n    class defaultdict(dict):\n\n        def __init__(self, default_factory=None, *a, **kw):\n            if (default_factory is not None and\n                not hasattr(default_factory, '__call__')):\n                raise TypeError('first argument must be callable')\n            dict.__init__(self, *a, **kw)\n            self.default_factory = default_factory\n\n        def __getitem__(self, key):\n            try:\n                return dict.__getitem__(self, key)\n            except KeyError:\n                return self.__missing__(key)\n\n        def __missing__(self, key):\n            if self.default_factory is None:\n                raise KeyError(key)\n            self[key] = value = self.default_factory()\n            return value\n\n        def __reduce__(self):\n            if self.default_factory is None:\n                args = tuple()\n            else:\n                args = self.default_factory,\n            return type(self), args, None, None, self.items()\n\n        def copy(self):\n            return self.__copy__()\n\n        def __copy__(self):\n            return type(self)(self.default_factory, self)\n\n        def __deepcopy__(self, memo):\n            import copy\n            return type(self)(self.default_factory, copy.deepcopy(self.items()))\n\n        def __repr__(self):\n            return 'defaultdict(%s, %s)' % (self.default_factory, dict.__repr__(self))\n\n\n二、namedtuple\n\nnamedtuple主要用来产生可以使用名称来访问元素的数据对象，通常用来增强代码的可读性，在访问一些tuple类型的数据时尤其好用。其实，在大部分时候你应该使用namedtuple替代tuple，这样可以让你的代码更容易读懂，更加pythonic。举个例子：\n\nfrom collections import namedtuple\n\n# 变量名和namedtuple中的第一个参数一般保持一致，但也可以不一样\nStudent = namedtuple('Student', 'id name score')\n# 或者 Student = namedtuple('Student', ['id', 'name', 'score'])\n\nstudents = [(1, 'Wu', 90), (2, 'Xing', 89), (3, 'Yuan', 98), (4, 'Wang', 95)]\n\nfor s in students:\n    stu = Student._make(s)\n    print stu\n\n# Output:\n# Student(id=1, name='Wu', score=90)\n# Student(id=2, name='Xing', score=89)\n# Student(id=3, name='Yuan', score=98)\n# Student(id=4, name='Wang', score=95)\n\n\n在上面的例子中，Student就是一个namedtuple，它和tuple的使用方法一样，可以通过index直接取，而且是只读的。这种方式比tuple容易理解多了，可以很清楚的知道每个值代表的含义。\n\nOver!\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "7"}