{"title": "在 Odoo 中生成唯一不重复的序列号 - TNK技术小栈 ", "index": "后台开发,网站开发,odoo,python", "content": "\n最近在做的项目中有一个需求是要让某个字段值根据记录产生的日期和一定的组合规则按顺序生成一个序列号，这个序列号不可重复，这原本是一个很常见的需求，没有多想就写好了。由于没有考虑到并发的情况，到后面测试的时候才发现一个比较严重的问题，如果用户同时操作产生的记录，生成的序列号会出现重复。\n经过讨论和思考后有几种解决方案，一是在数据库表层加锁，一是采用类似 redis 的消息队列，还有就是通过文件锁达到数据库排他锁的目的，鉴于时间和项目当前的情况，最后采用了通过文件锁实现这个需求。\n其实除了以上几种方式，Odoo 本身就有一个模型（ir.sequence）是用于生成序列的，可以很方便地实现这个需求，因为之前一直没有接触过这个模块，还是在项目之后的阶段同事使用到了并且告诉我之后才知道原来有这么个好东西的存在。在这里我将会把我原本通过文件锁实现的方式和通过 Odoo 自带的ir.sequence实现的方式都记录下来。\n给文件加锁 - fcntl\nfcntl是 Python 标准库里的一个模块，用来对文件进行加锁的操作。在实现中主要用到的是下面这个函数：\ndef flock(fd, operation):\n  \"\"\"\n  flock(fd, operation)\n\n  Perform the lock operation op on file descriptor fd. See the Unix \n  manual page for flock(2) for details. (On some systems, this function is\n  emulated using fcntl().)\n  \"\"\"\n  pass\n其中fd是文件描述符，operation为锁的操作，总共有4种：\n\nfcntl.LOCK_EX - 排他锁\nfcntl.LOCK_NB - 非阻塞锁\nfcntl.LOCK_SH - 共享锁\nfcntl.LOCK_UN - 解锁\n\n关于fcntl的其他具体内容请查看 官方标准库文档 。\n下面来看一下具体的实现，在给出代码之前，先描述一下需求，假设模型中有一个字段sn用于存储按一定规则生成的序列号，序列号的组成规则如下：\n\n固定的前缀SN\n\n取记录生成的日期组成的6位数字%y%m%d，如2017年12月8日取值为171208\n最后是3位的流水号，从001开始递增\n生成的序列号不能有重复\n最后的3位流水号每天自动重置，从001开始递增（这个需求涉及到一些扩展，故此文将不实现这一需求）\n\n需求很简单，也很清楚了，下面就上代码开始具体的实现。首先创建一个模块demo_sequence：\n./odoo-bin scaffold demo_sequence\n然后在模块的目录下创建数据文件目录data/，在目录下创建一个data.xml文件，在后面会用到；继续在模块目录下创建静态文件目录static/，在目录下创建一个空文件SN.LOCK用作加锁的文件对象。完成之后的目录结构如下：\ndemo_sequence\n├── __init__.py\n├── __manifest__.py\n├── controllers\n│   ├── __init__.py\n│   └── controllers.py\n├── data\n│   └── data.xml\n├── demo\n│   └── demo.xml\n├── models\n│   ├── __init__.py\n│   └── models.py\n├── security\n│   └── ir.model.access.csv\n├── static\n│   └── SN.LOCK\n└── views\n├── templates.xml\n└── views.xml\n模型的创建和视图的编写，这里将跳过不说，具体的代码将在后面给出。先创建一个给文件加锁的函数：\ndef _file_lock(flag=fcntl.LOCK_EX):\n  FILE_PATH = get_module_resource('demo_sequence', 'static/SN.LOCK')\n  file = open(FILE_PATH)\n  fcntl.flock(file.fileno(), flag)\n  _logger.info('Acquire Lock')\n  return file\n然后重写模型的create()方法：\n@api.model\ndef create(self, vals):\n  file = _file_lock()\n  sn_prefix = 'SN' + datetime.date.today().strftime(\"%y%m%d\")\n  obj = self.env['demo_sequence.fcntl'].search_read([('sn', '=like', sn_prefix + '%')], limit=1, order='sn DESC')\n  # 今天已经有序列号，在最新的序列号上递增\n  if obj and obj[0]['sn'].startswith(sn_prefix):\n  sn_suffix = int(obj[0]['sn'][-3:]) + 1\n  vals['sn'] = sn_prefix + str(sn_suffix).zfill(3) # 补0\n  else:\n  vals['sn'] = sn_prefix + '001'\n\n  res = super(DemoSequence, self).create(vals)\n  # 关闭文件将自动解锁\n  file.close()\n  return res\n利用fcntl给文件加锁后再生成序列号写入数据库，以达到序列号不重复的目的，就这么点代码就搞定了，不过还有更简单的方式，就是利用 Odoo 自带的ir.sequence模型产生序列号。\n生成唯一标识 - ir.sequence\n在模型ir.sequence中是这样描述的：\nThe sequence model allows to define and use so-called sequence objects. Such objects are used to generate unique identifiers in a transaction-safeway.\n我们可以利用它生成唯一的标识，下面就看一下怎么用ir.sequence实现前面所说的需求。\n打开data/data.xml并添加以下代码：\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<odoo>\n  <data noupdate=\"1\">\n    <record id=\"seq_demo_sequence_sn\" model=\"ir.sequence\">\n      <field name=\"name\">Demo Sequence SN</field>\n      <field name=\"code\">demo_sequence.sequence</field>\n      <field name=\"prefix\">SN%(y)s%(month)s%(day)s</field>\n      <field name=\"padding\">3</field>\n    </record>\n  </data>\n</odoo>\n这里的参数实际上不止这几个，在实现需求的前提下这几个就够用了，分别说明一下各个参数的作用：\n\nname - 名字，随便叫什么都行\ncode - 调用生成编码的 Key，需保证唯一性\nprefix - 前缀，可以是固定的字面量也可以是组合参数\npadding - 序列递增的位数\n\n注：记得将data/data.xml加入到__manifest__.py的data列表中\n接下来就是调用得到按规则生成的序列号，同样重写模型的create()方法：\n@api.model\ndef create(self, vals):\n  vals['sn'] = self.env['ir.sequence'].next_by_code('demo_sequence.sequence')\n  return super(DemoSequence2, self).create(vals)\n可以看到只需要一行代码就可以得到一个唯一的序列号，比前面用fcntl给文件加锁的方式简单了几个级别。这里的调用就用到了前面定义中所写的code。\n在实际项目中所使用到的两种方式都已经在这里记录下来了，官方的东西确实是个好东西，回头看看自己写的东西，毕竟 too young，可惜官方的文档好像并没有相关的记录（抑或是我没找到？），多翻翻官方实现的功能模块源码，才是精进 Odoo 之道。\n源码下载\n以上出现的所有代码均可在仓库 ruter/TNK-Odoo-Demo 中 查看并下载 。\n\n注：本文转自我的个人博客「TNK」，发布于 2017-12-08，通过原文地址可以访问到我的博客原文。\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "3"}