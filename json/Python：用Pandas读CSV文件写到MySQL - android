{"title": "Python：用Pandas读CSV文件写到MySQL - android ", "index": "mysql,python", "content": "汇总一下，自己最近在使用Python读写CSV存数据库中遇到的各种问题。 上代码：\nreload(sys)\nsys.setdefaultencoding('utf-8')\nhost = '127.0.0.1'\nport = 3306\ndb = 'world'\nuser = 'root'\npassword = '123456'\n\ncon = MySQLdb.connect(host=host,charset=\"utf8\",port=port,db=db,user=user,passwd=password)\ntry:\n    df = pd.read_sql(sql=r'select * from city', con=con)\n    df.to_sql('test',con=con,flavor='mysql')\nexcept Exception as e:\n    print(e.message)\n\n不出意外的话会打印出一句：database flavor MySQL is not supported 在stackoverflow上找到了答案：The flavor ‘mysql’ is deprecated in pandas version 0.19.\n我们换一种方式：\nreload(sys)\nsys.setdefaultencoding('utf-8')\nhost = '127.0.0.1'\nport = 3306\ndb = 'world'\nuser = 'root'\npassword = '123456'\n\nengine = create_engine(str(r\"mysql+mysqldb://%s:\" + '%s' + \"@%s/%s\") % (user, password, host, db))\n\ntry:\n    df = pd.read_sql(sql=r'select * from city', con=engine)\n    df.to_sql('test',con=engine,if_exists='append',index=False)\nexcept Exception as e:\n    print(e.message)\n\n运行下，ok,可以存入了index参数表示是否把DataFrame的index当成一列来存储，一般来说是不需要的，所以赋值为False\n现在看似问题都解决了，但是还有一个小问题。 假如我有一个含有中文的csv文件（本人Window）: name age class 小明 15 一年级 小张 18 三年级\nengine = create_engine(str(r\"mysql+mysqldb://%s:\" + '%s' + \"@%s/%s\") % (user, password, host, db))\n\ntry:\n    df = pd.read_csv(r'C:\\Users\\xx\\Desktop\\data.csv')\n    print(df)\n    df.to_sql('test', con=engine, if_exists='append', index=False)\nexcept Exception as e:\n    print(e.message)\n\n打印处理以后乱码了。我们在读csv时候最好指定编码，我的本地GBK：\ndf = pd.read_csv(r'C:\\Users\\xx\\Desktop\\data.csv',encoding='gbk')\n\n我们可以正常的打印信息了，但是又报错了，错误如下：\nUnicodeEncodeError: 'latin-1' codec can't encode characters in position 0-1: ordinal not in range(256)\n还是编码问题，原因呢，我们存到数据库时候没有指定编码。解决这个问题时候也是被坑了一把，网上说什么的都有。过程就不说了，看代码：\nengine = create_engine(str(r\"mysql+mysqldb://%s:\" + '%s' + \"@%s/%s?charset=utf8\") % (user, password, host, db))\n\n解决了\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "4"}