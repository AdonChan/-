{"title": "Python中Mock的示例 - 带着大馒头写代码 ", "index": "python,mock", "content": "一些常用的mock示例\n先简单定义个类，方便举例：\nclass Person:\n    def __init__(self):\n        self.__age = 10\n        \n    def get_fullname(self, first_name, last_name):\n        return first_name + ' ' + last_name\n        \n    def get_age(self):\n        return self.__age\n        \n    @staticmethod\n    def get_class_name():\n        return Person.__name__\n这个类里有两个成员方法，一个有参数，一个无参数。还有一个静态方法\n\nmock成员方法\n1. 使用Mock类，返回固定值\nclass PersonTest(TestCase):\n    def test_should_get_age(self):\n        p = Person()\n        \n        # 不mock时，get_age应该返回10\n        self.assertEqual(p.get_age(), 10)\n        \n        # mock掉get_age方法，让它返回20\n        p.get_age = Mock(return_value=20)\n        self.assertEqual(p.get_age(), 20)\n    \n    def test_should_get_fullname(self):\n        p = Person()\n        \n        # mock掉get_fullname，让它返回'James Harden'\n        p.get_fullname = Mock(return_value='James Harden')\n        self.assertEqual(p.get_fullname(), 'James Harden')\n2. 校验参数个数，再返回固定值\n上面的例子你也许已经注意到了，调用p.get_fullname时没有给任何的参数，但是依然可以工作。如果想校验参数需要用create_autospec模块方法替代Mock类。\nclass PersonTest(TestCase):\n    def test_should_get_fullname(self):\n        p = Person()\n        \n        p.get_fullname = create_autospec(p.get_fullname, return_value='James Harden')\n        \n        # 随便给两个参数，依然会返回mock的值\n        self.assertEqual(p.get_fullname('1', '2'), 'James Harden') \n        \n        # 如果参数个数不对，会报错TypeError: missing a required argument: 'last_name'\n        p.get_fullname('1')\n3. 使用side_effect, 依次返回指定值\nclass PersonTest(TestCase):\n    def test_should_get_age(self):\n        p = Person()\n        \n        p.get_age = Mock(side_effect=[10, 11, 12])\n\n        self.assertEqual(p.get_age(), 10)\n        self.assertEqual(p.get_age(), 11)\n        self.assertEqual(p.get_age(), 12)\n4. 根据参数不同，返回不同的值\nclass PersonTest(TestCase):\n    def test_should_get_fullname(self):\n        p = Person()\n        \n        values = {('James', 'Harden'): 'James Harden', ('Tracy', 'Grady'): 'Tracy Grady'}\n        p.get_fullname = Mock(side_effect=lambda x, y: values[(x, y)])\n        \n        self.assertEqual(p.get_fullname('James', 'Harden'), 'James Harden')\n        self.assertEqual(p.get_fullname('Tracy', 'Grady'), 'Tracy Grady')\n5. 抛出异常\nclass PersonTest(TestCase):\n    def test_should_raise_exception(self):\n        p = Person()\n        \n        p.get_age = Mock(side_effect=TypeError('integer type'))\n        # 只要调就会抛出异常\n        self.assertRaises(TypeError, p.get_age)\n6. 检验是否调用\nclass PersonTest(TestCase):\n    def test_should_validate_method_calling(self):\n        p.get_fullname = Mock(return_value='James Harden')\n\n        # 没调用过\n        p.get_fullname.assert_not_called()  # Python 3.5\n\n        p.get_fullname('1', '2')\n\n        # 调用过任意次数\n        p.get_fullname.assert_called() # Python 3.6\n        # 只调用过一次, 不管参数\n        p.get_fullname.assert_called_once() # Python 3.6\n        # 只调用过一次，并且符合指定的参数\n        p.get_fullname.assert_called_once_with('1', '2')\n\n        p.get_fullname('3', '4')\n        # 只要调用过即可，必须指定参数\n        p.get_fullname.assert_any_call('1', '2')\n\n        # 重置mock，重置之后相当于没有调用过\n        p.get_fullname.reset_mock()\n        p.get_fullname.assert_not_called()\n        \n        # Mock对象里除了return_value, side_effect属性外，\n        # called表示是否调用过，call_count可以返回调用的次数\n        self.assertEqual(p.get_fullname.called, False)\n        self.assertEqual(p.get_fullname.call_count, 0)\n        \n        p.get_fullname('1', '2')\n        p.get_fullname('3', '4')\n        self.assertEqual(p.get_fullname.called, True)\n        self.assertEqual(p.get_fullname.call_count, 2)\nmock静态方法\n静态方法和模块方法需要使用patch来mock。\n1. 在测试方法参数中得到Mock对象\nclass PersonTest(TestCase):\n    # 以字符串的形式列出静态方法的路径，在测试的参数里会自动得到一个Mock对象\n    @patch('your.package.module.Person.get_class_name')\n    def test_should_get_class_name(self, mock_get_class_name):\n        mock_get_class_name.return_value = 'Guy'\n\n        self.assertEqual(Person.get_class_name(), 'Guy')\n2. 在patch中设置Mock对象\nclass PersonTest(TestCase):\n    mock_get_class_name = Mock(return_value='Guy')\n\n    # 在patch中给出定义好的Mock的对象，好处是定义好的对象可以复用\n    @patch('your.package.module.Person.get_class_name', mock_get_class_name)\n    def test_should_get_class_name(self):\n        self.assertEqual(Person.get_class_name(), 'Guy')\n3. 使用patch.object\nclass PersonTest(TestCase):\n    mock_get_class_name = Mock(return_value='Guy')\n\n    # 使用patch.object来mock，好处是Person类不是以字符串形式给出的\n    @patch.object(Person, 'get_class_name', mock_get_class_name)\n    def test_should_get_class_name(self, ):\n        self.assertEqual(Person.get_class_name(), 'Guy')\n4. 使用with控制作用域\nclass PersonTest(TestCase):\n    # 作用域之外，依然返回真实值\n    def test_should_get_class_name(self, ):\n        mock_get_class_name = Mock(return_value='Guy')\n        with patch('your.package.module.Person.get_class_name', mock_get_class_name):\n            self.assertEqual(Person.get_class_name(), 'Guy')\n\n        self.assertEqual(Person.get_class_name(), 'Person')\nmock链式调用\n在django里，我们经常需要mock数据库，而访问数据库时经常是链式调用，看个例子。\ndef get_person(name):\n    return Person.objects.filter(name=name).order_by('age')\n有个模块方法，返回数据库中所有指定name的人员，并按age排序\nmock掉整个数据库访问\n@patch('your.package.module.Person.objects.filter')\ndef test_should_get_person(self, mock_filter):\n    # 先得到一个filter的Mock对象，再在return_value中设置一个Mock对象，此时不需要自己再创建\n    mock_filter.return_value.order_by.return_value = None\n    \n    self.assertIsNone(get_person())\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "5"}