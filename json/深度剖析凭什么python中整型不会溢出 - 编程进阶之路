{"title": "深度剖析凭什么python中整型不会溢出 - 编程进阶之路 ", "index": "c,python", "content": "前言\n本次分析基于 CPython 解释器，python3.x版本\n在python2时代，整型有 int 类型和 long 长整型，长整型不存在溢出问题，即可以存放任意大小的整数。在python3后，统一使用了长整型。这也是吸引科研人员的一部分了，适合大数据运算，不会溢出，也不会有其他语言那样还分短整型，整型，长整型...因此python就降低其他行业的学习门槛了。\n那么，不溢出的整型实现上是否可行呢？\n不溢出的整型的可行性\n尽管在 C 语言中，整型所表示的大小是有范围的，但是 python 代码是保存到文本文件中的，也就是说，python代码中并不是一下子就转化成 C 语言的整型的，我们需要重新定义一种数据结构来表示和存储我们新的“整型”。\n怎么来存储呢，既然我们要表示任意大小，那就得用动态的可变长的结构，显然，数组的形式能够胜任:\n[longintrepr.h]\nstruct _longobject {\n    PyObject_VAR_HEAD\n    int *ob_digit;\n};\n\n长整型的保存形式\n长整型在python内部是用一个 int 数组( ob_digit[n] )保存值的. 待存储的数值的低位信息放于低位下标, 高位信息放于高下标.比如要保存 123456789 较大的数字,但我们的int只能保存3位(假设):\nob_digit[0] = 789;\nob_digit[1] = 456;\nob_digit[2] = 123;\n低索引保存的是地位，那么每个 int  元素保存多大的数合适？有同学会认为数组中每个int存放它的上限(2^31 - 1)，这样表示大数时，数组长度更短，更省空间。但是，空间确实是更省了，但操作会代码麻烦，比方大数做乘积操作，由于元素之间存在乘法溢出问题，又得多考虑一种溢出的情况。\n怎么来改进呢？在长整型的 ob_digit 中元素理论上可以保存的int类型有 32 位，但是我们只保存 15 位，这样元素之间的乘积就可以只用 int 类型保存即可, 结果做位移操作就能得到尾部和进位 carry 了，定义位移长度为  15：\n#define PyLong_SHIFT  15\n#define PyLong_BASE ((digit)1 << PyLong_SHIFT)\n#define PyLong_MASK ((digit)(PyLong_BASE - 1))\nPyLong_MASK 也就是 0b111111111111111 ,通过与它做位运算 与 的操作就能得到低位数。\n有了这种存放方式，在内存空间允许的情况下，我们就可以存放任意大小的数字了。\n\n长整型的运算\n加法与乘法运算都可以使用我们小学的竖式计算方法，例如对于加法运算:\n\n\n \n \nob_digit[2]\n\nob_digit[1]\n\nob_digit[0]\n\n\n\n\n加数a\n \n23\n934\n543\n\n\n加数b\n+\n \n454\n632\n\n\n结果z\n \n24\n389\n175\n\n\n\n为方便理解，表格展示的是数组中每个元素保存的是 3 位十进制数，计算结果保存在变量z中，那么 z 的数组最多只要 size_a + 1 的空间（两个加数中数组较大的元素个数 + 1），因此对于加法运算，可以这样来处理:\n[longobject.c]\nstatic PyLongObject * x_add(PyLongObject *a, PyLongObject *b) {\n    int size_a = len(a), size_b = len(b);\n    PyLongObject *z;\n    int i;\n    int carry = 0; // 进位\n    \n    // 确保a是两个加数中较大的一个\n    if (size_a < size_b) {\n        // 交换两个加数\n        swap(a, b);\n        swap(&size_a, &size_b);\n    }\n    \n    z = _PyLong_New(size_a + 1);  // 申请一个能容纳size_a+1个元素的长整型对象\n    for (i = 0; i < size_b; ++i) {\n        carry += a->ob_digit[i] + b->ob_digit[i];\n        z->ob_digit[i] = carry & PyLong_MASK;   // 掩码\n        carry >>= PyLong_SHIFT;                 // 移除低15位, 得到进位\n    }\n    for (; i < size_a; ++i) {                   // 单独处理a中高位数字\n        carry += a->ob_digit[i];\n        z->ob_digit[i] = carry & PyLong_MASK;\n        carry >>= PyLong_SHIFT;\n    }\n    z->ob_digit[i] = carry;\n    return long_normalize(z);                   // 整理元素个数\n    \n}\n这部分的过程就是，先将两个加数中长度较长的作为第一个加数，再为用于保存结果的 z 申请空间，两个加数从数组从低位向高位计算，处理结果的进位，将结果的低 15 位赋值给 z 相应的位置。最后的 long_normalize(z) 是一个整理函数，因为我们 z 申请了 a_size + 1 的空间，但不意味着 z 会全部用到，因此这个函数会做一些调整，去掉多余的空间，数组长度调整至正确的数量，若不方便理解，附录将给出更利于理解的python代码。\n竖式计算不是按个位十位来计算的吗，为什么这边用整个元素？\n竖式计算方法适用与任何进制的数字，我们可以这样来理解，这是一个 32768 (2的15次方) 进制的，那么就可以把数组索引为 0 的元素当做是 “个位”，索引 1 的元素当做是 “十位”。\n乘法运算\n乘法运算一样可以用竖式的计算方式，两个乘数相乘，存放结果的 z 的元素个数为 size_a + size_b 即可：\n\n\n \n操作\n \n \nob_digit[2]\n\nob_digit[1]\n\nob_digit[0]\n\n\n\n\n乘数a\n \n \n \n23\n934\n543\n\n\n乘数b\n*\n \n \n \n454\n632\n\n\n结果z\n \n \n15\n126\n631\n176\n\n\n \n \n10\n866\n282\n522\n \n\n\n结果z\n \n10\n881\n409\n153\n176\n\n\n\n这里需要主意的是，当乘数 b 用索引 i 的元素进行计算时，结果 z 也是从 i 索引开始保存。先创建 z 并初始化为 0，这 z 上做累加操作，加法运算则可以利用前面的 x_add 函数：\n// 为方便理解，会与cpython中源码部分稍有不同\nstatic PyLongObject * x_mul(PyLongObject *a, PyLongObject *b)\n{\n    int size_a = len(a), size_b = len(b);\n    PyLongObject *z = _PyLong_New(size_a + size_b);\n    memset(z->ob_digit, 0, len(z) * sizeof(int)); // z 的数组清 0\n    \n    for (i = 0; i < size_b; ++i) {\n        int carry = 0;          // 用一个int保存元素之间的乘法结果\n        int f = b->ob_digit[i]; // 当前乘数b的元素\n        \n        // 创建一个临时变量，保存当前元素的计算结果，用于累加\n        PyLongObject *temp = _PyLong_New(size_a + size_b);\n        memset(temp->ob_digit, 0, len(temp) * sizeof(int)); // temp 的数组清 0\n        \n        int pz = i; // 存放到临时变量的低位\n        \n        for (j = 0; j < size_a; ++j) {\n            carry = f * a[j] + carry;\n            temp[pz] = carry & PyLong_MASK;  // 取低15位\n            carry = carry >> PyLong_SHIFT;  // 保留进位\n            pz ++;\n        }\n        if (carry){     //  处理进位\n            carry += temp[pz];\n            temp[pz] = carry & PyLong_MASK;\n            carry = carry >> PyLong_SHIFT;\n        }\n        if (carry){\n            temp[pz] += carry & PyLong_MASK;\n        }\n        temp = long_normalize(temp);\n        z = x_add(z, temp);\n    }\n    \n    return z\n    \n}\n这大致就是乘法的处理过程，竖式乘法的复杂度是n^2，当数字非常大的时候（数组元素个数超过 70 个）时，python会选择性能更好，更高效的 Karatsuba multiplication 乘法运算方式，这种的算法复杂度是 3nlog3≈3n1.585，当然这种计算方法已经不是今天讨论的内容了。有兴趣的小伙伴可以去了解下。\n总结\n要想支持任意大小的整数运算，首先要找到适合存放整数的方式，本篇介绍了用 int 数组来存放，当然也可以用字符串来存储。找到合适的数据结构后，要重新定义整型的所有运算操作，本篇虽然只介绍了加法和乘法的处理过程，但其实还需要做很多的工作诸如减法，除法，位运算，取模，取余等。\npython代码以文本形式存放，因此最后，还需要一个将字符串形式的数字转换成这种整型结构:\n[longobject.c]\nPyObject * PyLong_FromString(const char *str, char **pend, int base)\n{\n}\n这部分不是本篇的重点，有兴趣的同学可以看看这个转换的过程。\n参考\nlongobject.c\n附录\n\n# 例子中的表格中，数组元素最多存放3位整数，因此这边设置1000\n# 对应的取低位与取高位也就变成对 1000 取模和取余操作\nPyLong_SHIFT = 1000\nPyLong_MASK = 999\n\n# 以15位长度的二进制\n# PyLong_SHIFT = 15\n# PyLong_MASK = (1 << 15) - 1\n\ndef long_normalize(num):\n    \"\"\"\n    去掉多余的空间，调整数组的到正确的长度\n    eg: [176, 631, 0, 0]  ==>  [176, 631]\n    :param num:\n    :return:\n    \"\"\"\n    end = len(num)\n    while end >= 1:\n        if num[end - 1] != 0:\n            break\n        end -= 1\n\n    num = num[:end]\n    return num\n\ndef x_add(a, b):\n    size_a = len(a)\n    size_b = len(b)\n    carry = 0\n\n    # 确保 a 是两个加数较大的，较大指的是元素的个数\n    if size_a < size_b:\n        size_a, size_b = size_b, size_a\n        a, b = b, a\n\n    z = [0] * (size_a + 1)\n    i = 0\n    while i < size_b:\n        carry += a[i] + b[i]\n        z[i] = carry % PyLong_SHIFT\n        carry //= PyLong_SHIFT\n        i += 1\n\n    while i < size_a:\n        carry += a[i]\n        z[i] = carry % PyLong_SHIFT\n        carry //= PyLong_SHIFT\n        i += 1\n    z[i] = carry\n\n    # 去掉多余的空间，数组长度调整至正确的数量\n    z = long_normalize(z)\n\n    return z\n\n\ndef x_mul(a, b):\n    size_a = len(a)\n    size_b = len(b)\n    z = [0] * (size_a + size_b)\n\n    for i in range(size_b):\n        carry = 0\n        f = b[i]\n\n        # 创建一个临时变量\n        temp = [0] * (size_a + size_b)\n        pz = i\n        for j in range(size_a):\n            carry += f * a[j]\n            temp[pz] = carry % PyLong_SHIFT\n            carry //= PyLong_SHIFT\n            pz += 1\n\n        if carry:    # 处理进位\n            carry += temp[pz]\n            temp[pz] = carry % PyLong_SHIFT\n            carry //= PyLong_SHIFT\n            pz += 1\n\n        if carry:\n            temp[pz] += carry % PyLong_SHIFT\n        temp = long_normalize(temp)\n        z = x_add(z, temp)   # 累加\n\n    return z\n\n\na = [543, 934, 23]\nb = [632, 454]\nprint(x_add(a, b))\nprint(x_mul(a, b))\n\n                ", "mainLikeNum": ["16 "], "mainBookmarkNum": "10"}