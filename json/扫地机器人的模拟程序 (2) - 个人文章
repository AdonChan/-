{"title": "扫地机器人的模拟程序 (2) - 个人文章 ", "index": "python", "content": "上一篇文章中介绍了地图模块，接着来看主模块和动作模块\n主模块\n思路：主模块由一个Robot类构成，其调用各子模块，且其属性可用于保存信息这些信息，除了之前地图模块中的coordinate_list和impassable_coordinate_list之外，还包括：\n\n初始坐标\n现所在坐标\n移动路径\n\n代码：\nclass Robot(object):\n    def __init__(self):\n        from map import coordinate_list, impassable_coordinate_list\n        self.coordinate_list = coordinate_list\n        self.impassable_coordinate_list = impassable_coordinate_list\n        self.start_coordinate = (0, 0)\n        self.current_coordinate = self.start_coordinate\n        self.path_log = []\n        self.path_log.append(self.start_coordinate)\n\n\nrobot = Robot()\n\nif __name__ == '__main__':\n    pass\n动作模块\n思路：\n\n所谓移动，在模拟程序里就是更新 现所在坐标 和 移动路径\n考虑到先做出来，简化基本动作就只有往上下左右移动\n\n代码:\nimport numpy as np\n\n\ndef move_up(self):\n    self.current_coordinate = tuple(np.array(self.current_coordinate) + np.array([0, 1]))\n    print('up')\n    self.path_log.append(self.current_coordinate)\n\n\ndef move_down(self):\n    self.current_coordinate = tuple(np.array(self.current_coordinate) + np.array([0, -1]))\n    print('down')\n    self.path_log.append(self.current_coordinate)\n\n\ndef move_left(self):\n    self.current_coordinate = tuple(np.array(self.current_coordinate) + np.array([-1, 0]))\n    print('left')\n    self.path_log.append(self.current_coordinate)\n\n\ndef move_right(self):\n    self.current_coordinate = tuple(np.array(self.current_coordinate) + np.array([1, 0]))\n    print('right')\n    self.path_log.append(self.current_coordinate)\n这里用了numpy，其实不用numpy也可以，但考虑到后期复杂寻路逻辑还是会处理数组，先用起来练下手，代码也显得简洁一些?之后在main中添加方法:\n    ...\n    from motion import *\n    Robot.move_up = move_up\n    Robot.move_down = move_down\n    Robot.move_left = move_left\n    Robot.move_right = move_right\n感知模块\n思路：之前提到过先让机器人根据完善的地图来实现部分功能，然后再逐步改善，先让感知模块根据地图来“感知”具体来说，如果某坐标不在coordinate_list中，或者在impassable_coordinate_list中，那么就不能通行，返回False，代码也比较简单:\ndef judge_up_passable(self):\n    x, y = self.current_coordinate\n    up_coordinate = (x, y + 1)\n    if up_coordinate not in self.coordinate_list or (up_coordinate in self.impassable_coordinate_list):\n        return False\n    else:\n        return True\n\ndef judge_down_passable(self):\n    x, y = self.current_coordinate\n    down_coordinate = (x, y - 1)\n    if down_coordinate not in self.coordinate_list or (down_coordinate in self.impassable_coordinate_list):\n        return False\n    else:\n        return True\n\n\ndef judge_left_passable(self):\n    x, y = self.current_coordinate\n    left_coordinate = (x - 1, y)\n    if left_coordinate not in self.coordinate_list or (left_coordinate in self.impassable_coordinate_list):\n        return False\n    else:\n        return True\n\n\ndef judge_right_passable(self):\n    x, y = self.current_coordinate\n    right_coordinate = (x + 1, y)\n    if right_coordinate not in self.coordinate_list or (right_coordinate in self.impassable_coordinate_list):\n        return False\n    else:\n        return True\n之后在main中添加方法:\n    ...\n    from sensor import *\n    Robot.judge_up_passable = judge_up_passable\n    Robot.judge_down_passable = judge_down_passable\n    Robot.judge_left_passable = judge_left_passable\n    Robot.judge_right_passable = judge_right_passable\n测试\n之后可以在main后面添加测试代码:\n    # 移动测试\n    print(robot.current_coordinate)\n    robot.move_up()\n    print(robot.current_coordinate)\n    print(robot.path_log)\n\n    # 感应测试\n    print(robot.judge_up_passable())\n    robot.current_coordinate = (0, 0)\n    robot.impassable_coordinate_list.append((0, 1))\n    print(robot.judge_up_passable())\n获得的结果应该是(0, 0)up(0, 1)[(0, 0), (0, 1)]TrueFalse\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}