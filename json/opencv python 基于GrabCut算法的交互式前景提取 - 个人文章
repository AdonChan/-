{"title": "opencv python 基于GrabCut算法的交互式前景提取 - 个人文章 ", "index": "opencv-python,opencv,python", "content": "Interactive Foreground Extraction using GrabCut Algorithm \nmask, bgdModel, fgdModel = cv2.grabCut(img, mask, rect, bgdModel, fgdModel, iterCount[, mode])\n\nimg：输入图像\nmask ：蒙版图像，指定哪些区域是背景，前景或可能的背景/前景等.它是由下面的标志，cv2.GC_BGD，cv2.GC_FGD，cv2.GC_PR_BGD，cv2.GC_PR_FGD，或简单地将0，1，2，3传递给图像。\nrect ：矩形的坐标，包含了前景对象的格式(x，y，w，h)\nbdgModel, fgdModel ：算法内部使用的数组,只需要创建两个大小为（1,65）的np.float64类型的0数组.\niterCount ：算法运行的迭代次数.\nmode ：cv2.GC_INIT_WITH_RECT或cv2.GC_INIT_WITH_MASK，或者组合起来决定我们是画矩形还是最后的触点.\n\nimport numpy as np\nimport cv2\nfrom matplotlib import pyplot as plt\n\nimg = cv2.imread('messi5.jpg')\nmask = np.zeros(img.shape[:2],np.uint8)\n\nbgdModel = np.zeros((1,65),np.float64)\nfgdModel = np.zeros((1,65),np.float64)\n\nrect = (50,50,450,290)\ncv2.grabCut(img,mask,rect,bgdModel,fgdModel,5,cv2.GC_INIT_WITH_RECT)\n\nmask2 = np.where((mask==2)|(mask==0),0,1).astype('uint8')\nimg = img*mask2[:,:,np.newaxis]\n\nplt.imshow(img),plt.colorbar(),plt.show()\n\n梅西少了头发，我们会有1像素的修补（确定前景）,与此同时，有些地方的地面已经出现了我们不想要的画面，还有一些标志,我们需要移除它们.在那里我们提供了0像素的修补(当然是背景).\n# newmask is the mask image I manually labelled\nnewmask = cv2.imread('newmask.png',0)\n\n# wherever it is marked white (sure foreground), change mask=1\n# wherever it is marked black (sure background), change mask=0\nmask[newmask == 0] = 0\nmask[newmask == 255] = 1\n\nmask, bgdModel, fgdModel = cv2.grabCut(img,mask,None,bgdModel,fgdModel,5,cv2.GC_INIT_WITH_MASK)\n\nmask = np.where((mask==2)|(mask==0),0,1).astype('uint8')\nimg = img*mask[:,:,np.newaxis]\nplt.imshow(img),plt.colorbar(),plt.show()\n\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}