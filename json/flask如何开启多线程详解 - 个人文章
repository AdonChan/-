{"title": "flask如何开启多线程详解 - 个人文章 ", "index": "flask,python", "content": "在我之前写的《flask中current_app、g、request、session源码的深究和理解》一文中解释了flask如何支持多线程主要通过两个类来实现,LocalStack和Local,在Local中有两个属性,__storage__和__ident_func__,后者用来获取线程id,从而区分不同线程发来的请求\n这次要说的是flask如何开启多线程\n先从app.run()这个方法看起\ndef run(self, host=None, port=None, debug=None, **options):\n    from werkzeug.serving import run_simple\n    if host is None:\n        host = '127.0.0.1'\n    if port is None:\n        server_name = self.config['SERVER_NAME']\n        if server_name and ':' in server_name:\n            port = int(server_name.rsplit(':', 1)[1])\n        else:\n            port = 5000\n    if debug is not None:\n        self.debug = bool(debug)\n    options.setdefault('use_reloader', self.debug)\n    options.setdefault('use_debugger', self.debug)\n    try:\n        run_simple(host, port, self, **options)  #会进入这个函数\n    finally:\n        # reset the first request information if the development server\n        # reset normally.  This makes it possible to restart the server\n        # without reloader and that stuff from an interactive shell.\n        self._got_first_request = False\n\n经过判断和设置后进入run_simple()这个函数,看下源码\ndef run_simple(hostname, port, application, use_reloader=False,\n           use_debugger=False, use_evalex=True,\n           extra_files=None, reloader_interval=1,\n           reloader_type='auto', threaded=False,\n           processes=1, request_handler=None, static_files=None,\n           passthrough_errors=False, ssl_context=None):\n\"\"\"Start a WSGI application. Optional features include a reloader,\nmultithreading and fork support.\n\nThis function has a command-line interface too::\n\n    python -m werkzeug.serving --help\n\n.. versionadded:: 0.5\n   `static_files` was added to simplify serving of static files as well\n   as `passthrough_errors`.\n\n.. versionadded:: 0.6\n   support for SSL was added.\n\n.. versionadded:: 0.8\n   Added support for automatically loading a SSL context from certificate\n   file and private key.\n\n.. versionadded:: 0.9\n   Added command-line interface.\n\n.. versionadded:: 0.10\n   Improved the reloader and added support for changing the backend\n   through the `reloader_type` parameter.  See :ref:`reloader`\n   for more information.\n\n:param hostname: The host for the application.  eg: ``'localhost'``\n:param port: The port for the server.  eg: ``8080``\n:param application: the WSGI application to execute\n:param use_reloader: should the server automatically restart the python\n                     process if modules were changed?\n:param use_debugger: should the werkzeug debugging system be used?\n:param use_evalex: should the exception evaluation feature be enabled?\n:param extra_files: a list of files the reloader should watch\n                    additionally to the modules.  For example configuration\n                    files.\n:param reloader_interval: the interval for the reloader in seconds.\n:param reloader_type: the type of reloader to use.  The default is\n                      auto detection.  Valid values are ``'stat'`` and\n                      ``'watchdog'``. See :ref:`reloader` for more\n                      information.\n:param threaded: should the process handle each request in a separate\n                 thread?\n:param processes: if greater than 1 then handle each request in a new process\n                  up to this maximum number of concurrent processes.\n:param request_handler: optional parameter that can be used to replace\n                        the default one.  You can use this to replace it\n                        with a different\n                        :class:`~BaseHTTPServer.BaseHTTPRequestHandler`\n                        subclass.\n:param static_files: a list or dict of paths for static files.  This works\n                     exactly like :class:`SharedDataMiddleware`, it's actually\n                     just wrapping the application in that middleware before\n                     serving.\n:param passthrough_errors: set this to `True` to disable the error catching.\n                           This means that the server will die on errors but\n                           it can be useful to hook debuggers in (pdb etc.)\n:param ssl_context: an SSL context for the connection. Either an\n                    :class:`ssl.SSLContext`, a tuple in the form\n                    ``(cert_file, pkey_file)``, the string ``'adhoc'`` if\n                    the server should automatically create one, or ``None``\n                    to disable SSL (which is the default).\n\"\"\"\nif not isinstance(port, int):\n    raise TypeError('port must be an integer')\nif use_debugger:\n    from werkzeug.debug import DebuggedApplication\n    application = DebuggedApplication(application, use_evalex)\nif static_files:\n    from werkzeug.wsgi import SharedDataMiddleware\n    application = SharedDataMiddleware(application, static_files)\n\ndef log_startup(sock):\n    display_hostname = hostname not in ('', '*') and hostname or 'localhost'\n    if ':' in display_hostname:\n        display_hostname = '[%s]' % display_hostname\n    quit_msg = '(Press CTRL+C to quit)'\n    port = sock.getsockname()[1]\n    _log('info', ' * Running on %s://%s:%d/ %s',\n         ssl_context is None and 'http' or 'https',\n         display_hostname, port, quit_msg)\n\ndef inner():\n    try:\n        fd = int(os.environ['WERKZEUG_SERVER_FD'])\n    except (LookupError, ValueError):\n        fd = None\n    srv = make_server(hostname, port, application, threaded,\n                      processes, request_handler,\n                      passthrough_errors, ssl_context,\n                      fd=fd)\n    if fd is None:\n        log_startup(srv.socket)\n    srv.serve_forever()\n\nif use_reloader:\n    # If we're not running already in the subprocess that is the\n    # reloader we want to open up a socket early to make sure the\n    # port is actually available.\n    if os.environ.get('WERKZEUG_RUN_MAIN') != 'true':\n        if port == 0 and not can_open_by_fd:\n            raise ValueError('Cannot bind to a random port with enabled '\n                             'reloader if the Python interpreter does '\n                             'not support socket opening by fd.')\n\n        # Create and destroy a socket so that any exceptions are\n        # raised before we spawn a separate Python interpreter and\n        # lose this ability.\n        address_family = select_ip_version(hostname, port)\n        s = socket.socket(address_family, socket.SOCK_STREAM)\n        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        s.bind(get_sockaddr(hostname, port, address_family))\n        if hasattr(s, 'set_inheritable'):\n            s.set_inheritable(True)\n\n        # If we can open the socket by file descriptor, then we can just\n        # reuse this one and our socket will survive the restarts.\n        if can_open_by_fd:\n            os.environ['WERKZEUG_SERVER_FD'] = str(s.fileno())\n            s.listen(LISTEN_QUEUE)\n            log_startup(s)\n        else:\n            s.close()\n\n    # Do not use relative imports, otherwise \"python -m werkzeug.serving\"\n    # breaks.\n    from werkzeug._reloader import run_with_reloader\n    run_with_reloader(inner, extra_files, reloader_interval,\n                      reloader_type)\nelse:\n    inner()  #默认会执行\n\n还是经过一系列判断后默认会进入inner()函数,这个函数定义在run_simple()内,属于闭包,inner()中会执行make_server()这个函数,看下源码:\ndef make_server(host=None, port=None, app=None, threaded=False, processes=1,\n            request_handler=None, passthrough_errors=False,\n            ssl_context=None, fd=None):\n\"\"\"Create a new server instance that is either threaded, or forks\nor just processes one request after another.\n\"\"\"\nif threaded and processes > 1:\n    raise ValueError(\"cannot have a multithreaded and \"\n                     \"multi process server.\")\nelif threaded:\n    return ThreadedWSGIServer(host, port, app, request_handler,\n                              passthrough_errors, ssl_context, fd=fd)\nelif processes > 1:\n    return ForkingWSGIServer(host, port, app, processes, request_handler,\n                             passthrough_errors, ssl_context, fd=fd)\nelse:\n    return BaseWSGIServer(host, port, app, request_handler,\n                          passthrough_errors, ssl_context, fd=fd)\n\n看到这也很明白了,想要配置多线程或者多进程,则需要设置threaded或processes这两个参数,而这两个参数是从app.run()中传递过来的:app.run(**options) ---> run_simple(threaded,processes) ---> make_server(threaded,processes)默认情况下flask是单线程,单进程的,想要开启只需要在run中传入对应的参数:app.run(threaded=True)即可.从make_server中可知,flask提供了三种server:ThreadedWSGIServer,ForkingWSGIServer,BaseWSGIServer,默认情况下是BaseWSGIServer以线程为例,看下ThreadedWSGIServer这个类:\nclass ThreadedWSGIServer(ThreadingMixIn, BaseWSGIServer):  #继承自ThreadingMixIn, BaseWSGIServer\n\"\"\"A WSGI server that does threading.\"\"\"\nmultithread = True\ndaemon_threads = True\n\n\nThreadingMixIn = socketserver.ThreadingMixIn\nclass ThreadingMixIn:\n\"\"\"Mix-in class to handle each request in a new thread.\"\"\"\n\n# Decides how threads will act upon termination of the\n# main process\ndaemon_threads = False\n\ndef process_request_thread(self, request, client_address):\n    \"\"\"Same as in BaseServer but as a thread.\n\n    In addition, exception handling is done here.\n\n    \"\"\"\n    try:\n        self.finish_request(request, client_address)\n        self.shutdown_request(request)\n    except:\n        self.handle_error(request, client_address)\n        self.shutdown_request(request)\n\ndef process_request(self, request, client_address):\n    \"\"\"Start a new thread to process the request.\"\"\"\n    t = threading.Thread(target = self.process_request_thread,\n                         args = (request, client_address))\n    t.daemon = self.daemon_threads\n    t.start()\n\nprocess_request就是对每个请求产生一个新的线程来处理最后写一个非常简单的应用来验证以上说法:\nfrom flask import Flaskfrom flask import _request_ctx_stack\napp = Flask(__name__)\n@app.route('/')def index():\nprint(_request_ctx_stack._local.__ident_func__())\nwhile True:\n    pass\nreturn '<h1>hello</h1>'\n\napp.run()  #如果需要开启多线程则app.run(threaded=True)\n_request_ctx_stack._local.__ident_func__()对应这get_ident()这个函数,返回当前线程id,为什么要在后面加上while True这句呢,我们看下get_ident()这个函数的说明:Return a non-zero integer that uniquely identifies the current thread amongst other threads that exist simultaneously. This may be used to identify per-thread resources. Even though on some platforms threads identities may appear to be allocated consecutive numbers starting at 1, this behavior should not be relied upon, and the number should be seen purely as a magic cookie. A thread's identity may be reused for another thread after it exits.\n关键字我已经加粗了,线程id会在线程结束后重复利用,所以我在路由函数中加了这个死循环来阻塞请求以便于观察到不同的id,这就会产生两种情况:1.没开启多线程的情况下,一次请求过来,服务器直接阻塞,并且之后的其他请求也都阻塞2.开启多线程情况下,每次都会打印出不同的线程id\n结果:\n第一种情况\n\nRunning on http://127.0.0.1:5000/ (Press CTRL+C to quit)\n139623180527360\n\n\n第二种情况\n\nRunning on http://127.0.0.1:5000/ (Press CTRL+C to quit)\n140315469436672140315477829376140315486222080140315316901632140315105163008140315096770304140315088377600\n\n结果显而易见综上所述:flask支持多线程,但默认没开启,其次app.run()只适用于开发环境,生产环境下可以使用uWSGI,Gunicorn等web服务器\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}