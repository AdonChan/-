{"title": "Blender下用Python实现模型文件导入、渲染和动画生成 - A new beginning ", "index": "python", "content": "为了让数值计算的结果能够有更好的渲染效果，这段时间一直在用Blender这个开源软件来处理计算结果。\n因为是处理大量数据的计算结果，所以不得不考虑用Python编写脚本来实现批量处理，编写过程中，Google帮我解决了大部分实现过程中的障碍，下面是完整的实现过程：\n\n\n将计算结果的mesh文件导入到Blender中；\nimport bpy \nimport os \n\n# folder path to save rendered image\nin_dir = \"E:\\\\SPH\\\\Paper 01\\\\D18\\\\\"\nlst = os.listdir(in_dir)\n\n# folder path for importing data files\nin_dir_ply = \"E:\\\\SPH\\\\Paper 01\\\\D18\\\\Ply_batch\\\\\"\nlst_ply = os.listdir(in_dir_ply)\n\n# folder path to save rendered animation\nout_dir = \"E:\\\\SPH\\\\Paper 01\\\\D18\\\\test.avi\"\n\n# Filter file list by valid file types.\ncandidates = []\ncandidates_name = []\nc = 0\nfor item in lst_ply:\n    fileName, fileExtension = os.path.splitext(lst_ply[c])\n    if fileExtension == \".ply\":\n        candidates.append(item)\n        candidates_name.append(fileName)\n    c = c + 1\n\nfile = [{\"name\":i} for i in candidates]   \nn = len(file)\nprint(n) \n\n# To import mesh.ply in batches\nfor i in range (0,n):\n    bpy.ops.import_mesh.ply(filepath=candidates[n], files=[file[n]], directory=in_dir_ply, filter_glob=\"*.ply\")\n    bpy.data.objects[candidates_name[i]].hide = True\n    bpy.data.objects[candidates_name[i]].hide_render = True\n\n\n在Blender中进行批量渲染并保存成图片文件；（这里用到了提前制作好的材质文件“Material.001”）\n# Set file_format for render images\nbpy.data.scenes[\"Scene\"].render.image_settings.file_format = 'PNG'\n\n# To render and save rendered images\nfor i in range (0,n):\n    bpy.data.objects[candidates_name[i]].hide = False    #objects must be visible to use modifier\n    bpy.data.objects[candidates_name[i]].hide_render = False    #objects must be renderable to export render image\n    bpy.context.scene.objects.active = bpy.data.objects[candidates_name[i]] #get object\n    bpy.ops.object.modifier_add(type='PARTICLE_SYSTEM')    #add modifier as particle_system\n    bpy.data.objects[candidates_name[i]].particle_systems['ParticleSystem'].settings = bpy.data.particles['ParticleSettings'] #assign particle settings to object's particle system\n    bpy.data.objects[candidates_name[i]].data.materials.append(bpy.data.materials[\"Material.001\"])    #assign existed material to active object.\n    bpy.data.scenes[\"Scene\"].render.filepath = '//%02d'%(i)    #set save filepath\n    bpy.ops.render.render( write_still=True )    #render and save\n    bpy.data.objects[candidates_name[i]].hide = True    #hide again for next image rendering\n    bpy.data.objects[candidates_name[i]].hide_render = True    #hide again for next image rendering\n\n\n在Blender的Video Sequence Editor (VSE)中插入上一步生成的渲染后的图片文件；\n# Active VSE to generate rendering animation\nbpy.data.scenes[\"Scene\"].render.use_sequencer = True\n\n# Filter file list by valid file types.\nre_image = []\nre_image_name = []\nc = 0\nfor item in lst:\n    fileName, fileExtension = os.path.splitext(lst[c])\n    if fileExtension == \".png\":\n        re_image.append(item)\n        re_image_name.append(fileName)\n    c = c + 1\n\n# Create the sequencer data\nbpy.context.scene.sequence_editor_create()\n\n# Add strip into VSE by importing new image\nfor i in range (0,n):\n    bpy.context.scene.sequence_editor.sequences.new_image(\n        name=re_image[i],\n        filepath=os.path.join(in_dir, re_image[i]),\n        channel=1, frame_start=i)\n\n\n在Blender中生成并保存动画文件。\n# Resolution settings for animation\nresx = 720; #1920 \nresy = 480; #1080 \nbpy.data.scenes[\"Scene\"].render.resolution_x = resx \nbpy.data.scenes[\"Scene\"].render.resolution_y = resy \nbpy.data.scenes[\"Scene\"].render.resolution_percentage = 100 \n\nbpy.data.scenes[\"Scene\"].frame_end = n \nbpy.data.scenes[\"Scene\"].render.image_settings.file_format = 'AVI_JPEG' \nbpy.data.scenes[\"Scene\"].render.filepath = out_dir\nbpy.ops.render.render( animation=True )\n\n\n\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "1"}