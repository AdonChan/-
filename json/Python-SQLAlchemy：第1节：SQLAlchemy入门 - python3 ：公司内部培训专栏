{"title": "Python-SQLAlchemy：第1节：SQLAlchemy入门 - python3 ：公司内部培训专栏 ", "index": "python", "content": "下一篇文章：Python-SQLAlchemy：第2节：查询条件设置\n\nSQLAlchemy是Python编程语言下的一款开源软件。提供了SQL工具包及对象关系映射（ORM）工具，SQLAlchemy使用MIT许可证发行。它采用简单的Python语音，为高效和高性能的数据库访问设计，实现了完整的企业级持久模型。SQLAlchemy非常关注数据库的量级和性能。\n本节通过一套例子分析SQLAlchemy的使用方法。\n使用SQLAlchemy至少需要3部分代码，它们分别是定义表、定义数据库连接、进行增、删、改、查等逻辑操作。\n定义表的实例：\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy import Column,Integer,String\n\nBase=declarative_base()\n\nclass Accout(Base):\n    __tablename__=u'accout'\n\n    id=Column(Integer,primary_key=True)\n    user_namr=Column(String(50),nullable=False)\n    password=Column(String(200),nullable=False)\n    title=Column(String(50))\n    salary=Column(Integer)\n\n    def is_active(self):\n        #假设所有\n        return True\n\n    def get_id(self):\n        #返回账号ID，用方法返回属性值提高了表的封装性。\n        return self.id\n\n    def is_authenticated(self):\n        #假设已经通过验证\n        return True\n\n    def is_anonymous(self):\n        #具有登陆名和密码的账号不是匿名用户\n        return False\n\n解析定义表的代码如下：\n\nSQLAlchemy表之前必须必须引入sqlalchemy.ext.declarative_base，并定义一个它的实例Base。所有表必须继承自Base。本例中定义了一个账户表类Account。\n通过__tablename__属性定义了表在数据库中实际的名称account。\n引入sqlalchemy包中的Column、Integer、String类型，因为需要用它们定义表中的列。本例在Account表中定义了5个列，分别是整型id和salary，以及字符串类型的user_name、password、title。\n在定义列时可以通过给Column传送参数定义约束。本例中通过primary_key参数将id列定义主键，通过nullable参数将user__name和password定义非空。\n在表中还可以自定义其他函数。本例中定义了用户验证时常用的几个函数：is__activite()、get__id()、is__authenticate()和is_anonymous()。\n\n定义数据库连接的示例代码如下：\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import scoped_session,sessionmaker\nfrom contextlib import contextmanager\n\ndb_connect_string='mysql://v_user:v_pase@localhost:3306/test_database?charset=utf8'\n\nssl_args={\n    'ssl':{\n        'cert':'/home/ssl/client-cert.pem',\n        'key':'/home/shouse/ssl/client-key.pem',\n        'ca':'/home/shouse/ssl/ca-cert.pem'\n    }\n}\nengine=create_engine(db_connect_string,connect_args=ssl_args)\nSessionType=scoped_session(sessionmaker(bind=engine,expire_on_commit=False))\ndef GetSession():\n    return SessionType()\n\n@contextmanager\ndef session_scope():\n    session=GetSession()\n    try:\n        yield session\n        session.commit()\n    except:\n        session.rollback()\n        raise\n    finally:\n        session.close()\n\n\n解析此连接数据部分的代码如下：\n\n引入数据库和会话引擎：sqlalchemy.create_engine、sqlalchemy.orm.scoped_session、sqlalchemy.orm.sessionmaker。\n定义连接数据库需要用到的数据库字符串。本例连接MySQL数据库，字符串格式为[databse_type]://[user_name]:[password]@[domain]:[port]/[database]?[parameters]。本例中除了必须的连接信息，还传入了charset参数，指定用utf-8编码方式解码数据库中的字符串。\n用create_engine建立数据库引擎，如果数据库开启了SSL链路，则在此处需要传入ssl客户端证书的文件路径。\n用scoped_session(sessionmaker(bind=engine))建立会话类型SessionType，并定义函数GetSession()用以创建SessionType的实例。\n\n至此，已经可以用GetSession()函数创建数据库会话并进行数据库操作了。但为了使之后的数据库操作的代码能够自动进行事务处理，本例中定义了上下文函数session_scope()。在Python中定义上下文函数的方法是为其加入contextlib包中的contextmanager装饰器。在上下文函数中执行如下逻辑：在函数开始时建立数据库会话，此时会自动建立一个数据库事务：当发生异常时回滚（rollback）事务；当退出时关闭（close）连接。在关闭连接时会自动进行事务提交（commit）操作。\n进行数据库操作的代码：\nfrom sqlalchemy import or_,orm\ndef InsertAccount(user,passwd,title,salary): #新增操作\n    with session_scope() as session:\n        account=orm.Account(user_name=user,passwd=passwd,title=title,salary=salary)\n        session.add(account)\n\ndef GetAccount(id=None,user_name=None): #查询操作\n    with session_scope() as session:\n        return session.query(orm.Account).filter(\n            or_(orm.Account.id==id,orm.Account.user_name=user_name)\n        ).first()\n\ndef DeleteAccount(user_name): #删除操作\n    with session_scope() as session:\n        account=GetAccount(user_name=user_name)\n        if account:\n            session.delete(account)\n\ndef UpdateAccount(id,user_name,password,title,salary):  #更新操作\n    with session_scope() as session:\n        account=session.query(orm.Account).filter(orm.Account.id==id).first()\n        if not account:return\n        account.user_name=user_name\n        account.password=password\n        account.salary=salary\n        account.title=title\n\n\nInsertAccount(\"Mark\",\"123\",\"Manager\",3000)  #调用新增操作\nInsertAccount(\"帅哥\",\"456\",\"Boss\",2000)  #调用新增操作\nGetAccount(2) #调用查询操作\nDeleteAccount(\"Mark\")\nUpdateAccount(1,\"admin\",\"none\",\"System admin\",2500)\n\n本例演示了数据库中最常用的4种基于记录的操作：新增、查找、删除、更新。对此部分代码的解析如下：\n\n用import语句引入数据表(Account)所在的包orm。引入多条件查询时使用or_。\n每个函数中都通过with语句启用上下文函数session_scope()，通过它获取到session对象，并自动开启新事物。\n在InsertAccount中，通过新建一个表Account实例，并通过session.add将其添加到数据库中。由于上下文函数退出时会自动提交事务，所以无需显示的调用session.commit()使新增生效。\n在GetAccount中通过query语句进行查询，查询条件由filter设置，多个查询条件可以用or_或and_连接。\n在DeleteAccount中通过GetAccount查询该对象，如果查询到了，则直接调用session.delete()将该对象删除。\n在InsertAccount()中通过query根据id查询记录，如果查询到了，则通过设置对象的属性实现对记录的修改。\n查询语句的结果是一个对象集合。查询语句后面的first()函数用于提取该集合中的第一个对象，如果用all()函数替换first()函数，查询则会返回该集合。\n\n主流数据库的连接方式\nSQLAlchemy这样的orm数据库操作方式可以对业务开发者屏蔽不同数据库之间的差异，这样当需要进行数据库迁移时（比如MySQL迁移到SQLite），则只需要更换数据库连接字符串。\n下表列出了SQLAlchemy连接主流数据库时的数据库字符串的编写方法：\n\n\n数据库\n连接字符串\n\n\n\nMicrosoft SQLServer\n'mssql+pymssql://[user]:[pass]@[domain]:[port]/[dbname]'\n\n\nMySQL\n'mysql://[user]:[pass]@[domain]:[port]/[dbname]'\n\n\nOracle\n'oracle://[user]:[pass]@[domain]:[port/[dbname]]'\n\n\nPostgreSQL\n'postgresql://[user]:[pass]@[domain]:[port]/[dbname]'\n\n\nSQLite\n'sqlite://[file_pathname]'\n\n\n\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "1"}