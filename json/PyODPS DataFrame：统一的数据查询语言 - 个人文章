{"title": "PyODPS DataFrame：统一的数据查询语言 - 个人文章 ", "index": "mysql,数据库,python", "content": "摘要： 前几天，PyODPS发布了0.7版本，这篇文章给大家介绍下PyODPS新版本带来的重要特性。 之前也有若干篇文章介绍过了，我们PyODPS DataFrame是延迟执行的，在调用立即执行的方法，比如execute、persist等之前，都只是构建了表达式。\n点此查看原文：http://click.aliyun.com/m/41051/\n前几天，PyODPS发布了0.7版本，这篇文章给大家介绍下PyODPS新版本带来的重要特性。\n之前也有若干篇文章介绍过了，我们PyODPS DataFrame是延迟执行的，在调用立即执行的方法，比如execute、persist等之前，都只是构建了表达式。而真正的执行根据具体的输入数据，来决定执行的后端。\n比如，我们可以根据输入是pandas DataFrame（本地数据），还是MaxCompute Table（MaxCompute数据）来决定是在本地执行，还是在MaxComput上执行。\nIn [1]: import pandas as pd\n\nIn [2]: pd_df = pd.DataFrame({'a': range(3)})\n\nIn [3]: from odps.df import DataFrame\n\nIn [4]: df = DataFrame(pd_df)  # 本地数据\n\nIn [5]: df.a.sum()\n|==========================================|   1 /  1  (100.00%)         0s\n3\n\nIn [6]: %load_ext odps\n\nIn [7]: %enter\nOut[7]: <odps.inter.Room at 0x105951990>\n\nIn [8]: df = DataFrame(o.get_table('pyodps_iris'))  # MaxCompute数据\n\nIn [9]: df.sepal_width.sum()\n|==========================================|   1 /  1  (100.00%)        15s\n458.10000000000014\n数据库执行\n来到了0.7版本，我们的后端武器库进一步扩充，现在我们支持Postgresql和MySQL，原则上我们支持所有的主流数据库，但我们只在这两个数据库上做了测试。\n我们的数据库执行后端使用 sqlalchemy 实现，想要执行还需要对应数据库的driver。\n现在，如果DataFrame输入的数据是sqlalchemy Table，那么我们就可以使用数据库后端来执行。\nIn [24]: mysql_engine = sqlalchemy.create_engine('mysql://root:123@localhost/movielens') \n\nIn [25]: metadata = sqlalchemy.MetaData(bind=mysql_engine)   # 需要绑定engine\n\nIn [26]: table = sqlalchemy.Table('top_users', metadata, extend_existing=True, autoload=True)\n\nIn [27]: top_users = DataFrame(table)\n\nIn [28]: top_users.age.sum()\n|==========================================|   1 /  1  (100.00%)         0s\n763\n对于postgresql也是一样。 值得注意的是，现在还有部分DataFrame操作，比如自定义函数尚未支持数据库后端 。\n可以看到，PyODPS DataFrame就是一个统一的数据查询语言，用户不需要改写一行代码，就可以根据输入让数据在MaxCompute、本地和数据库上执行，由于DataFrame框架的灵活性，我们甚至还可以扩展出非SQL执行后端的支持。\nJOIN或者UNION数据库和MaxCompute数据\n过去 一篇文章 提到过，我们可以join或者union本地和MaxCompute上的数据，这样的典型场景就是，比如我有个本地excel文件，我可以轻松读取成本地DataFrame，然后直接就可以和MaxCompute数据进行操作，省去了一大堆麻烦的过程。\n现在，我们也同样可以join 数据库和MaxCompute上的数据，试想，有一堆用户数据是在数据库中进行处理，然后我们无需经过同步数据等繁琐的过程，我们就可以直接join 数据库和MaxCompute上的数据，这是何其方便的事情。\n比如：\nIn [29]: ratings = o.get_table('movielens_ratings').to_df()\n\nIn [32]: female_top_users = top_users[top_users.sex == 'F']  # MySQL中的数据\n\nIn [33]: ratings.join(female_top_users).rating.mean()\n|==========================================|   1 /  1  (100.00%)        14s\n2.9451170298627924\n总结\n我们PyODPS一直处在快速迭代的过程中，我们所有所做的努力，都是为了让大家以更好的体验来进行数据分析和机器学习。尽管我们很努力，但精力毕竟有限，难免会有bug，会有功能不完善。希望大家能给我们提issue，能贡献代码就更好啦。\n项目文档：http://pyodps.readthedocs.io项目地址：https://github.com/aliyun/ali...提issue：https://github.com/aliyun/ali...\n钉钉扫码：\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}