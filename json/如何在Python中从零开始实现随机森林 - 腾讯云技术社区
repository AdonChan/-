{"title": "如何在Python中从零开始实现随机森林 - 腾讯云技术社区 ", "index": "树形结构,程序员,深度学习,机器学习,python", "content": "欢迎大家前往云+社区，获取更多腾讯海量技术实践干货哦~\n决策树可能会受到高度变异的影响，使得结果对所使用的特定测试数据而言变得脆弱。\n根据您的测试数据样本构建多个模型（称为套袋）可以减少这种差异，但是树本身是高度相关的。\n随机森林是套袋（方法）的延伸，除了基于多个测试数据样本构建树木之外，它还限制了可用于构建树木的特征，使得树木间具有差异。这反过来可以提升算法的表现。\n在本教程中，您将了解如何在Python中从头开始实现随机森林算法。\n完成本教程后，您将知道：\n\n套袋决策树和随机森林算法的区别。\n如何构造更多方差的袋装决策树。\n如何将随机森林算法应用于预测建模问题。\n\n让我们开始吧。\n2017年1月更新：将cross_validation_split（）中fold_size的计算更改为始终为整数。修复了Python 3的问题。2017年2月更新：修复了build_tree中的错误。2017年8月更新：修正了基尼计算中的一个错误，增加了群组大小（基于迈克尔！）。\n\n如何在Python中从头开始实现随机森林 图片来自 InspireFate Photography，保留部分权利。\n描述\n本节简要介绍本教程中使用的随机森林算法和Sonar数据集。\n随机森林算法\n决策树涉及从数据集中（利用）贪婪选择选取最佳分割点过程中的每一步。\n如果不精简（该算法），此算法容易使决策树出现高方差。这种高方差（结果）可以通过创建包含测试数据集中（多个）不同的实例（问题的不同观点）的多重树，接着将实例所有的可能结果结合，这种方法简称为bootstrap聚合或套袋。\n套袋的局限性在于，它使用相同的贪婪算法来创建每棵树，这意味着在每棵树中可能会选择相同或非常相似的分割点，使得不同的树非常相似（树将被关联）。这反过来又使他们的预测相似，从而缩减了最初寻求的差异。\n我们可以通过贪婪算法在创建树时在每个分割点评估的特征（行）来限制决策树不同。这被称为随机森林算法。\n像装袋一样，测试数据集的多个样本在被采集后，接着在每个样本上训练不同的树。不同之处在于在每一点上，拆分是在数据中进行并添加到树中的，且只考虑固定的属性子集。\n对于分类问题，我们将在本教程中讨论的问题的类型——分割中输入特点数的平方根值对为分割操作考虑的属性个数的限制。\nnum_features_for_split = sqrt(total_input_features)\n\n这一小变化的结果是树之间变得更加不同（不关联），作为结果会有更加多样化的预测，这样的结果往往好于一个单独的树或者单独套袋得到的结果。\n声纳数据集\n我们将在本教程中使用的数据集是Sonar数据集。\n这是一个描述声纳声音从不同曲面反弹后返回（数据）的数据集。输入的60个变量是声呐从不同角度返回的力度值。这是一个二元分类问题，需要一个模型来区分金属圆柱中的岩石。这里有208个观察对象。\n这是一个很好理解的数据集。所有变量都是连续的且范围一般是0到1。输出变量是“Mine”字符串中的“M”和“rock”中的“R”，需要转换为整数1和0。\n通过预测在数据集（“M”或“mines”）中观测数最多的类，零规则算法可以达到53％的准确度。\n您可以在UCI Ｍachine Learning repository了解关于此数据集的更多信息。\n下载免费的数据集，并将其放置在工作目录中，文件名为sonar.all-data.csv。\n教程\n本教程分为2个步骤。\n\n计算分割。\n声纳数据集案例研究。\n\n这些步骤为您需要将随机森林算法应用于自己的预测建模问题奠定了基础。\n1.计算分割\n在决策树中，通过利用最低成本找到指定属性和该属性的值方法来确定分割点。\n对于分类问题，这个成本函数通常是基尼指数，它计算分割点创建的数据组的纯度。基尼指数为0是完美纯度，其中在两类分类问题的情况下，将类别值完全分成两组。\n在决策树中找到最佳分割点涉及到为每个输入的变量评估训练数据集中每个值的成本。\n对于装袋和随机森林，这个程序是在测试数据集的样本上执行的，并且是可替换的。更换取样意味着同一行（数据）会不止一次的被选择并将其添加到取样中。\n我们可以优化随机森林的这个程序。我们可以创建一个输入属性样本来考虑，而不是在搜索中枚举输入属性的所有值。\n这个输入属性的样本可以随机选择而不需要替换，这意味着每个输入属性在查找具有最低成本的分割点的过程中只被考虑一次。\n下面是实现此过程的函数名称get_split（）。它将数据集和固定数量的输入要素作为输入参数进行评估，此数据集可能是实际测试数据集的一个样本。\nhelper函数test_split（）用于通过候选分割点拆分数据集，gini_index（）用于根据创建的行组来计算给定拆分的花费。\n我们可以看到，通过随机选择特征索引并将其添加到列表（称为特征）来创建特征列表，然后枚举该特征列表并且将测试数据集中的特定值评估作为分割点。\n# Select the best split point for a dataset\ndef get_split(dataset, n_features):\n    class_values = list(set(row[-1] for row in dataset))\n    b_index, b_value, b_score, b_groups = 999, 999, 999, None\n    features = list()\n    while len(features) < n_features:\n        index = randrange(len(dataset[0])-1)\n        if index not in features:\n            features.append(index)\n    for index in features:\n        for row in dataset:\n            groups = test_split(index, row[index], dataset)\n            gini = gini_index(groups, class_values)\n            if gini < b_score:\n                b_index, b_value, b_score, b_groups = index, row[index], gini, groups\n    return {'index':b_index, 'value':b_value, 'groups':b_groups}\n\n现在我们知道如何修改决策树算法以便与随机森林算法一起使用，我们可以将它与一个bagging实现一起使用，并将其应用于现实生活中的数据集。\n2.声纳数据集案例研究\n在本节中，我们将把随机森林算法应用到声纳数据集。\n该示例假定数据集的CSV副本位于当前工作目录中，文件名为sonar.all-data.csv。\n首先加载数据集，将字符串值转换为数字，并将输出列从字符串转换为0和1的整数值。这可以通过使用帮助器函数load_csv（），str_column_to_float（）和str_column_to_int（）来加载和预备数据集。\n我们将使用k-fold交叉验证来估计未知数据的学习模型的性能。这意味着我们将构建和评估k个模型，并将性能估计为平均模型误差。分类准确性将用于评估每个模型。这些工具或是算法在cross_validation_split（），accuracy_metric（）和evaluate_algorithm（）辅助函数中提供。\n我们也将使用适合套袋包括辅助功能分类和回归树（CART）算法的实现）test_split（拆分数据集分成组，gini_index（）来评估分割点，我们修改get_split（）函数中讨论在前一步中，to_terminal（），split（）和build_tree（）用于创建单个决策树，预测（）使用决策树进行预测，subsample（）创建训练数据集的子采样，以及bagging_predict（）用决策树列表进行预测。\n开发了一个新的函数名称random_forest（），首先根据训练数据集的子样本创建一个决策树列表，然后使用它们进行预测。\n正如我们上面所说的，随机森林和袋装决策树之间的关键区别是对树的创建方式中的一个小的改变，这里是在get_split（）函数中。\n完整的例子如下所示。\n# Random Forest Algorithm on Sonar Dataset\nfrom random import seed\nfrom random import randrange\nfrom csv import reade\nfrom math import sqrt\n \n# Load a CSV file\ndef load_csv(filename):\n    dataset = list()\n    with open(filename, 'r') as file:\n        csv_reader = reader(file)\n        for row in csv_reader:\n            if not row:\n                continue\n            dataset.append(row)\n    return dataset\n \n# Convert string column to float\ndef str_column_to_float(dataset, column):\n    for row in dataset:\n        row[column] = float(row[column].strip())\n \n# Convert string column to intege\ndef str_column_to_int(dataset, column):\n    class_values = [row[column] for row in dataset]\n    unique = set(class_values)\n    lookup = dict()\n    for i, value in enumerate(unique):\n        lookup[value] = i\n    for row in dataset:\n        row[column] = lookup[row[column]]\n    return lookup\n \n# Split a dataset into k folds\ndef cross_validation_split(dataset, n_folds):\n    dataset_split = list()\n    dataset_copy = list(dataset)\n    fold_size = int(len(dataset) / n_folds)\n    for i in range(n_folds):\n        fold = list()\n        while len(fold) < fold_size:\n            index = randrange(len(dataset_copy))\n            fold.append(dataset_copy.pop(index))\n        dataset_split.append(fold)\n    return dataset_split\n \n# Calculate accuracy percentage\ndef accuracy_metric(actual, predicted):\n    correct = 0\n    for i in range(len(actual)):\n        if actual[i] == predicted[i]:\n            correct += 1\n    return correct / float(len(actual)) * 100.0\n \n# Evaluate an algorithm using a cross validation split\ndef evaluate_algorithm(dataset, algorithm, n_folds, *args):\n    folds = cross_validation_split(dataset, n_folds)\n    scores = list()\n    for fold in folds:\n        train_set = list(folds)\n        train_set.remove(fold)\n        train_set = sum(train_set, [])\n        test_set = list()\n        for row in fold:\n            row_copy = list(row)\n            test_set.append(row_copy)\n            row_copy[-1] = None\n        predicted = algorithm(train_set, test_set, *args)\n        actual = [row[-1] for row in fold]\n        accuracy = accuracy_metric(actual, predicted)\n        scores.append(accuracy)\n    return scores\n \n# Split a dataset based on an attribute and an attribute value\ndef test_split(index, value, dataset):\n    left, right = list(), list()\n    for row in dataset:\n        if row[index] < value:\n            left.append(row)\n        else:\n            right.append(row)\n    return left, right\n \n# Calculate the Gini index for a split dataset\ndef gini_index(groups, classes):\n    # count all samples at split point\n    n_instances = float(sum([len(group) for group in groups]))\n    # sum weighted Gini index for each group\n    gini = 0.0\n    for group in groups:\n        size = float(len(group))\n        # avoid divide by zero\n        if size == 0:\n            continue\n        score = 0.0\n        # score the group based on the score for each class\n        for class_val in classes:\n            p = [row[-1] for row in group].count(class_val) / size\n            score += p * p\n        # weight the group score by its relative size\n        gini += (1.0 - score) * (size / n_instances)\n    return gini\n \n# Select the best split point for a dataset\ndef get_split(dataset, n_features):\n    class_values = list(set(row[-1] for row in dataset))\n    b_index, b_value, b_score, b_groups = 999, 999, 999, None\n    features = list()\n    while len(features) < n_features:\n        index = randrange(len(dataset[0])-1)\n        if index not in features:\n            features.append(index)\n    for index in features:\n        for row in dataset:\n            groups = test_split(index, row[index], dataset)\n            gini = gini_index(groups, class_values)\n            if gini < b_score:\n                b_index, b_value, b_score, b_groups = index, row[index], gini, groups\n    return {'index':b_index, 'value':b_value, 'groups':b_groups}\n \n# Create a terminal node value\ndef to_terminal(group):\n    outcomes = [row[-1] for row in group]\n    return max(set(outcomes), key=outcomes.count)\n \n# Create child splits for a node or make terminal\ndef split(node, max_depth, min_size, n_features, depth):\n    left, right = node['groups']\n    del(node['groups'])\n    # check for a no split\n    if not left or not right:\n        node['left'] = node['right'] = to_terminal(left + right)\n        return\n    # check for max depth\n    if depth >= max_depth:\n        node['left'], node['right'] = to_terminal(left), to_terminal(right)\n        return\n    # process left child\n    if len(left) <= min_size:\n        node['left'] = to_terminal(left)\n    else:\n        node['left'] = get_split(left, n_features)\n        split(node['left'], max_depth, min_size, n_features, depth+1)\n    # process right child\n    if len(right) <= min_size:\n        node['right'] = to_terminal(right)\n    else:\n        node['right'] = get_split(right, n_features)\n        split(node['right'], max_depth, min_size, n_features, depth+1)\n \n# Build a decision tree\ndef build_tree(train, max_depth, min_size, n_features):\n    root = get_split(train, n_features)\n    split(root, max_depth, min_size, n_features, 1)\n    return root\n \n# Make a prediction with a decision tree\ndef predict(node, row):\n    if row[node['index']] < node['value']:\n        if isinstance(node['left'], dict):\n            return predict(node['left'], row)\n        else:\n            return node['left']\n    else:\n        if isinstance(node['right'], dict):\n            return predict(node['right'], row)\n        else:\n            return node['right']\n \n# Create a random subsample from the dataset with replacement\ndef subsample(dataset, ratio):\n    sample = list()\n    n_sample = round(len(dataset) * ratio)\n    while len(sample) < n_sample:\n        index = randrange(len(dataset))\n        sample.append(dataset[index])\n    return sample\n \n# Make a prediction with a list of bagged trees\ndef bagging_predict(trees, row):\n    predictions = [predict(tree, row) for tree in trees]\n    return max(set(predictions), key=predictions.count)\n \n# Random Forest Algorithm\ndef random_forest(train, test, max_depth, min_size, sample_size, n_trees, n_features):\n    trees = list()\n    for i in range(n_trees):\n        sample = subsample(train, sample_size)\n        tree = build_tree(sample, max_depth, min_size, n_features)\n        trees.append(tree)\n    predictions = [bagging_predict(trees, row) for row in test]\n    return(predictions)\n \n# Test the random forest algorithm\nseed(2)\n# load and prepare data\nfilename = 'sonar.all-data.csv'\ndataset = load_csv(filename)\n# convert string attributes to integers\nfor i in range(0, len(dataset[0])-1):\n    str_column_to_float(dataset, i)\n# convert class column to integers\nstr_column_to_int(dataset, len(dataset[0])-1)\n# evaluate algorithm\nn_folds = 5\nmax_depth = 10\nmin_size = 1\nsample_size = 1.0\nn_features = int(sqrt(len(dataset[0])-1))\nfor n_trees in [1, 5, 10]:\n    scores = evaluate_algorithm(dataset, random_forest, n_folds, max_depth, min_size, sample_size, n_trees, n_features)\n    print('Trees: %d' % n_trees)\n    print('Scores: %s' % scores)\n    print('Mean Accuracy: %.3f%%' % (sum(scores)/float(len(scores))))\n\n使用k值5进行交叉验证，给定每个倍数值为208/5 = 41.6或者在每次迭代中刚好超过40个记录被计算。\n构建深度树的最大深度为10，每个节点的最小训练行数为1。训练数据集样本的创建大小与原始数据集相同，这是随机森林算法的默认期望值。\n在每个分割点处考虑的特征的数量被设置为sqrt（num_features）或者sqrt（60）= 7.74被保留为7个特征。\n对一套有着3种不同数量的树木（示例）进行评测在此过程中进行比较，结果表明随着更多树木的添加，（处理）技能也随之提升。\n运行该示例将打印每个折叠的分数和每个配置的平均分数。\nTrees: 1\nScores: [56.09756097560976, 63.41463414634146, 60.97560975609756, 58.536585365853654, 73.17073170731707]\nMean Accuracy: 62.439%\n \nTrees: 5\nScores: [70.73170731707317, 58.536585365853654, 85.36585365853658, 75.60975609756098, 63.41463414634146]\nMean Accuracy: 70.732%\n \nTrees: 10\nScores: [82.92682926829268, 75.60975609756098, 97.5609756097561, 80.48780487804879, 68.29268292682927]\nMean Accuracy: 80.976% \n\n扩展\n本节列出了您可能有兴趣探索的关于本教程的扩展。\n\n\n算法优化。发现教程中使用的配置有一些试验和错误，但没有进行优化。尝试更多的树木，不同数量的特征，甚至不同的树形配置来提高性能。\n\n更多的问题。将该技术应用于其他分类问题，甚至将其应用于回归，具有新的成本函数和结合树预测的新方法。\n\n你有没有尝试这些扩展？ 在下面的评论中分享你的经验。\n评论\n在本教程中，您了解了如何从头开始实现随机森林算法。\n具体来说，你了解到：\n\n随机森林和Bagged决策树的区别。\n如何更新决策树的创建以适应随机森林过程。\n如何将随机森林算法应用于现实世界的预测建模问题。\n\n翻译人：一只懒惰的小白，该成员来自云+社区翻译社原文链接：https://machinelearningmaster...原文作者：Jason Brownlee\n相关阅读\n教程从头开始在Python中实现k最近邻居Python NLTK 自然语言处理入门与例程浅谈用Python计算文本BLEU分数\n\n此文已由作者授权云加社区发布，转载请注明文章出处\n\n                ", "mainLikeNum": ["5 "], "mainBookmarkNum": "8"}