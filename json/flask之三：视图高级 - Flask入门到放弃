{"title": "flask之三：视图高级 - Flask入门到放弃 ", "index": "css,html,python", "content": "视图高级\n\napp.route和app.add_url_rule\n\napp.add_url_rule\napp.add_url_rule('/list/',endpoint='myweb',view_func=my_list)\n这个方法是用来添加url与视图函数的映射。如果没有填写endpoint那么会默认使用view_func的名字来作为endpoint。因此在使用url_for的时候，就要看在映射的时候有没有传递endpoint参数，如果传递了，那么就使用endpoint指定的字符串。付过没有使用的话就使用view_func定义的名字。\n\napp.route(rule,**options)装饰器\n这个装饰器的底层就是用add_url_rule来实现url与视图函数映射的。\n小例子如下：\nfrom flask import Flask,url_for\napp = Flask(__name__)\napp.config.update({\n    'DEBUG':True,\n    'TEMPLATES_AUTO_RELOAD':True\n})\n@app.route('/',endpoint='index')\ndef hello_world():\n    print(url_for('myweb'))\n    return 'Hello World!'\ndef my_list():\n    return 'list page!'\napp.add_url_rule('/list/',endpoint='myweb',view_func=my_list)\n#请求上下文的定义，结合url_for\nwith app.test_request_context():\n    print(url_for('index'))\nif __name__ == '__main__':\n    app.run()\n类视图\n之前我们接触的视图都是函数，所以一般简称视图函数。其实视图也可以基于类来实现，类视图的好处是支持继承，但是类视图不能跟函数视图一样，写完类视图还需要通过app.add_url_rule(url_rule,view_func)来进行注册。以下将对两种类视图进行讲解\n标准视图\n\n标准类视图必须继承自flask.views.View\n\n必须实现dispatch_request方法，以后请求过来以后，会执行这个方法。这个方法的返回值就相当于是之前的函数视图一样，也必须返回Request或者子类的对象（字符串或者元组）。\n必须是通过app.add_url_rule(rule,endpoint,view_func)来做url映射。\n\nview_func这个参数，要使用as_view这个方法来转换\n\n如果指定了endpoint，那么在使用url_for反转的时候，就要使用endpoint指定的那个值，如果没有指定那个值，就使用as_view中指定的视图名字来作为反转。\n类视图有以下的好处，可以将一些共性的东西抽取出来放到父视图中，子视图直接继承就可以了，但是也不是说所有的视图都要使用类视图，这个要根据实际情况来定。\n\n小例子：\nfrom flask import Flask,views,url_for\napp = Flask(__name__)\nclass ListView(views.View):\n    def dispatch_request(self):\n        return 'list view'\n#app.add_url_rule('/list/',endpoint='list',view_func=ListView.as_view('list'))\napp.add_url_rule('/list/',view_func=ListView.as_view('list'))\nwith app.test_request_context():\n    print(url_for('list'))\n@app.route('/')\ndef hello_world():\n    return 'Hello World!'\nif __name__ == '__main__':\n    app.run(debug=True)\n类视图的小例子：\nfrom flask import Flask,url_for,views,jsonify,render_template\n\napp = Flask(__name__)\napp.config.update({\n    'DEBUG':True,\n    'TEMPLATES_AUTO_RELOAD':True\n})\n\n#自定义封装,返回json数据\nclass JSONView(views.View):\n    def get_data(self):\n        raise NotImplementedError\n    def dispatch_request(self):\n        return jsonify(self.get_data())\n\nclass ListView(JSONView):\n    def get_data(self):\n        return {\n            'username':'wanghui',\n            'password':123456,\n        }\n\napp.add_url_rule('/list/',endpoint='my_list',view_func=ListView.as_view('list'))\n#有几个视图，需要返回相同的变量(广告页面)\nclass ADSView(views.View):\n    def __init__(self):\n        super(ADSView, self).__init__()\n        self.context = {\n            'ads':\"今年过节不收礼，收礼只收脑白金\"\n        }\nclass RegistView(ADSView):\n    def dispatch_request(self):\n        self.context.update({'username':'abcd'})\n        return render_template('register.html',**self.context)\nclass LoginView(ADSView):\n    def dispatch_request(self):\n        return render_template('login.html',**self.context)\n# class LoginView(views.View):\n#     def dispatch_request(self):\n#         return render_template('login.html',ads=\"今年过节不收礼，收礼只收脑白金\")\n# class RegistView(views.View):\n#     def dispatch_request(self):\n#         return render_template('register.html',ads=\"今年过节不收礼，收礼只收脑白金\")\napp.add_url_rule('/login/',view_func=LoginView.as_view('login'))\napp.add_url_rule('/regist/',view_func=RegistView.as_view('regist'))\n\n@app.route('/')\ndef hello():\n    return \"heello\"\nif __name__ == '__main__':\n    app.run()\n基于调度方法的视图\n\n根据请求方法来执行不同的方法的，如果用户发送的是get请求，就会执行这个类的get方法；如果用户发起的是post方法，就会执行这个类的post方法。其他的方法类似，这种方法使得代码更加简洁，使得执行get请求的代码放在get方法中，post请求的代码放在posy方法中。就不需要跟之前的request.method == 'POST'来搞了。\n小例子\npy\n\nfrom flask import Flask,views,render_template,request\n\napp = Flask(__name__)\n\nclass LoginView(views.MethodView):\n    def __render(self,error=None):\n        return render_template('login.html',error=error)\n    def get(self,error=None):\n        # return render_template('login.html',error=error)\n        return self.__render()\n    def post(self):\n        username = request.form.get('username')\n        password = request.form.get('password')\n        if username == 'wanghui' and password == '111111':\n            return 'login success'\n        else:\n            # return render_template('login.html',error=\"username or password error，retry!\")\n            # return self.get(error=\"username or password error，retry!\")\n            return self.__render(error=\"username or password error，retry!\")\n\napp.add_url_rule('/login/',view_func=LoginView.as_view('login'))\n\n@app.route('/')\ndef hello_world():\n    return 'Hello World!'\n\nif __name__ == '__main__':\n    app.run(debug=True,port=9090)\nlogin.html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>login</title>\n</head>\n<body>\n<form action=\"\" method=\"post\">\n    <table>\n        <tr>\n            <td>用户名</td>\n            <td><input type=\"text\" name=\"username\"></td>\n        </tr>\n        <tr>\n            <td>密码</td>\n            <td><input type=\"password\" name=\"password\"></td>\n        </tr>\n        <tr>\n            <td></td>\n            <td><input type=\"submit\" value=\"立即登陆\"></td>\n        </tr>\n    </table>\n    {% if error %}\n        <p style=\"color: red;\">{{ error }}</p>\n\n    {% endif %}\n</form>\n</body>\n</html>\n类视图上面使用装饰器\n\n两种类型的装饰器\n如果使用的是函数视图， 那么定义的装饰器必须放在app.route下面，否则起不到任何作用\n\n类视图的装饰器，需要重写类视图的decorators类属性，里面装的就是所有的装饰器\n小例子：\nfrom flask import Flask,request,views\nfrom functools import wraps\n\napp = Flask(__name__)\n\n#定义装饰器\ndef login_required(func):\n    @wraps(func)\n    def wrapper(*args,**kwargs):\n        username = request.args.get('username')\n        if username and username == 'wanghui':\n            return func(*args,**kwargs)\n        else:\n            return \"请先登录\"\n    return wrapper\n\n\n@app.route('/settings/')\n@login_required\ndef settings():\n    return '这是设置页面'\n\n#这样请求就行http://127.0.0.1:9091/settings/?username=wanghui\n\n#类视图添加装饰器\nclass ProfileView(views.View):\n    decorators = [login_required]\n    def dispatch_request(self):\n        return \"这是个人中心\"\napp.add_url_rule('/profile/',view_func=ProfileView.as_view('profile'))\n蓝图\n将大型项目分层解耦，实现模块化，结构更加清晰。可以将相同的模块放在同一个蓝图下，同一个文件夹中。方便管理。\n基本语法：\n在蓝图文件中导入Blueprint\nfrom flask import Blueprint\nuser_bp = Blueprint('user',__name__)    #相当于是定义`app = Flask(__name__)`\n在主app文件中注册蓝图\nfrom blueprints.user import user_bp\napp.regist_blueprint(user_bp)   #实现注册蓝图\n如果想要某个蓝图下的所有URL的时候有个前缀，那么可以在定义蓝图的时候加上url_prefix\n\nfrom flask import Blueprint\nuser_bp = Blueprint('user',__name__，url_prefix='/user') \n# 特别注意斜杠\n蓝图中的模板文件\n\n蓝图模板文件查找：\n\n如果项目中的templates文件夹中存在对应的模板文件，就可以直接使用\n如果项目中的templates文件夹中存在相应的模板文件，那么就在定义蓝图的指定路径中查找，可以设置相对路径，就要在蓝图文件相同路径下的文件夹。\n\n\n\nfrom flask import Blueprint,render_template\nnews_bp = Blueprint('news',__name__,url_prefix='/news',template_folder='news')\n@news_bp.route('/list/')\ndef news_list():\n    return render_template('news_list.html')\n\n蓝图中的静态文件查找：\n\n在模板文件中，加载静态文件，如果使用url_for('static')，那么只会在app指定的静态文件夹目录下查找静态文件\n如果在加载静态文件的时候置顶了蓝图的名字，比如url_for('news.static')，那么会到蓝图指定的static_folder下查找静态文件。\n\n\nurl_for反转蓝图注意事项\n\n注意url_for到蓝图中的视图函数的时候，要反转蓝图中的视图函数为url，那么就用该在使用url_for的时候使用url_for('news.news_list')不然就找不到这个endpoint。\n即使在同一个蓝图中，反转视图函数，也要制定蓝图的名字\n\n子域名实现\n\n使用蓝图技术\n在创建蓝图对象的时候要使用subdomain来指定这个子域名\n\nfrom flask import Blueprint\ncms_bp = Blueprint('cms',__name__,subdomain='cms')\n需要在app文件中配置app.config['SERVER_NAME']='baidu.com'来指定跟域名\napp.config['SERVER_NAME'] = 'crop.com:9099'\n修改hosts文件配置解析\n127.0.0.1 crop.com\n127.0.0.1 cms.crop.com\n5.访问\ncms.crop.com：9099\n综合实例代码\n目录结构\nblue_print_e\n├── blue_print_e.py\n├── blueprints\n│ ├── bok.py\n│ ├── cms.py\n│ ├── movie.py\n│ ├── news_css\n│ │ └── news_list.css\n│ ├── news.py\n│ ├── news_tmp\n│ │ └── news_list.html\n│ └── user.py\n├── static\n│ └── news_list.css\n└── templates\n    ├── index.html\n    └── news_list.html\n主app文件blue_print_e.py \n\nfrom flask import Flask,url_for,render_template\nfrom blueprints.user import user_bp\nfrom blueprints.news import news_bp\nfrom blueprints.cms import cms_bp\n\napp = Flask(__name__)\napp.config['SERVER_NAME'] = 'crop.com:9099'\n\napp.register_blueprint(user_bp)\napp.register_blueprint(news_bp)\napp.register_blueprint(cms_bp)\n# ip地址不能有子域名\n@app.route('/')\ndef hello_world():\n    print(url_for('news_tmp.news_list'))     #使用蓝图名字.视图函数的名字\n    return render_template('index.html')\nif __name__ == '__main__':\n    app.run(debug=True,port=9099)\nblueprints/news.py\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nfrom flask import Blueprint,render_template,url_for\n\nnews_bp = Blueprint('news_tmp',__name__,url_prefix='/news_tmp',template_folder='news_tmp',static_folder='news_css')\n\n@news_bp.route('/list/')\ndef news_list():\n    print(url_for('news.news_detail'))\n    return render_template('news_list.html')\n\n@news_bp.route('/detail')\ndef news_detail():\n    return \"详情页面\"\nblueprints/user.py\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nfrom flask import Blueprint\n\nuser_bp = Blueprint('user',__name__,url_prefix='/user')\n@user_bp.route('/profile/')\ndef profile():\n    return \"个人中心\"\n\n@user_bp.route('/settings/')\ndef settings():\n    return \"设置页面\"\nblueprint/cms.py\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nfrom flask import Blueprint\ncms_bp = Blueprint('cms',__name__,subdomain='cms')\n@cms_bp.route('/')\ndef index():\n    return 'cms index'\nblueprints/news_css/\nbody {\n    color: fuchsia;\n    font-size: 90px;\n    background: red;\n}\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}