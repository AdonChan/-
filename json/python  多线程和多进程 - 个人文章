{"title": "python  多线程和多进程 - 个人文章 ", "index": "python", "content": "官方文档：multiprocessing is a package that supports spawning processes using an API similar to the threading module. The multiprocessing package offers both local and remote concurrency, effectively side-stepping the Global Interpreter Lock by using subprocesses instead of threads。\n总的来说是对补救Python多线程在多核操作系统中的一副良药。更多的推荐大家使用multiprocessing 模块。\n一些简单使用技巧见介绍\nhttp://blog.csdn.net/dutsoft/...\n廖雪峰python教程之多进程其中最大的区别在于 多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享\n运行环境 Python2.7 ，windows\nimport time, threading\n\n# 假定这是你的银行存款:\nbalance = 0\n\ndef change_it(n):\n    # 先存后取，结果应该为0:\n    global balance\n    balance = balance + n\n    balance = balance - n\n\ndef run_thread(n):\n    for i in range(100000):\n        change_it(n)\n\nt1 = threading.Thread(target=run_thread, args=(5,))\nt2 = threading.Thread(target=run_thread, args=(8,))\nt1.start()\nt2.start()\nt1.join()\nt2.join()\nprint(balance)\n运行的结果会是一个随机数，就是因为Python的多线程是不安全的，线程之间的调度会影响到其他线程的结果。\n#coding=utf-8\nimport time, threading\nlock = threading.Lock()\n# 假定这是你的银行存款:\nbalance = 0\n\ndef change_it(n):\n    # 先存后取，结果应该为0:\n    global balance\n    balance = balance + n\n    balance = balance - n\n\ndef run_thread(n):\n    for i in range(100000):\n        lock.acquire()\n        try:\n            change_it(n)\n        finally:\n            lock.release()\n\nt1 = threading.Thread(target=run_thread, args=(5,))\nt2 = threading.Thread(target=run_thread, args=(8,))\nt1.start()\nt2.start()\nt1.join()\nt2.join()\nprint(balance)\n运行的结果是预想的0\n另外再web服务器中会大量使用多进程的方式，gunicorn，uwsgi等\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}