{"title": "python(3.x) 实现AES 加解密 - Ethan Sun的技术博客 ", "index": "python,cryptography", "content": "首先 安装cryptography\nsudo pip3 install cryptography\n确认安装的是2.1.x版本 (1.x版本的api是不一样的).\n文件头部的声明为:\n# coding: utf-8\n\nimport os\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives import padding\nimport base64\n\n# 128bits block size\naes_block_size = 16\n我们可以生成一个随机的密钥:\ndef get_random_key_readable(key_size=256):\n    '''\n    get random key for symmetric encryption\n    with key_size bits\n    :param key_size: bit length of the key\n    :return: bytes key\n    '''\n    # length for urandom\n    ulen = int(key_size/8/4*3)\n    key = base64.b64encode(os.urandom(ulen))\n    return key\n注意要使用密码学安全的随机方法os.urandom.这里生成的是str而不是bytes, 为了可读性.\n采用AES CBC 加密:\ndef aes_cbc_encrypt(message, key):\n    '''\n    use AES CBC to encrypt message, using key and init vector\n    :param message: the message to encrypt\n    :param key: the secret\n    :return: bytes init_vector + encrypted_content\n    '''\n    iv_len = 16\n    assert type(message) in (str,bytes)\n    assert type(key) in (str,bytes)\n    if type(message) == str:\n        message = bytes(message, 'utf-8')\n    if type(key) == str:\n        key = bytes(key, 'utf-8')\n    backend = default_backend()\n    iv = os.urandom(iv_len)\n    cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=backend)\n    encryptor = cipher.encryptor()\n    padder = padding.PKCS7(128).padder()\n    padded_data = padder.update(message) + padder.finalize()\n    enc_content = encryptor.update(padded_data) + encryptor.finalize()\n    return iv + enc_content\n内容加密前需要padding到128bit(16bytes)的整数倍长度才可. cryptography有对应padding方法.初始向量为16bit长度. 返回初始向量+加密数据.\n解密方法为:\ndef aes_cbc_decrypt(content, key):\n    '''\n    use AES CBC to decrypt message, using key\n    :param content: the encrypted content using the above protocol\n    :param key: the secret\n    :return: decrypted bytes\n    '''\n    assert type(content) == bytes\n    assert type(key) in (bytes, str)\n    if type(key) == str:\n        key = bytes(key, 'utf-8')\n    iv_len = 16\n    assert len(content) >= (iv_len + 16)\n    iv = content[:iv_len]\n    enc_content = content[iv_len:]\n    backend = default_backend()\n    cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=backend)\n    unpadder = padding.PKCS7(128).unpadder()\n    decryptor = cipher.decryptor()\n    dec_content = decryptor.update(enc_content) + decryptor.finalize()\n    real_content = unpadder.update(dec_content) + unpadder.finalize()\n    return real_content\n我们可以随机生成一些message测试下加解密:\nimport random\n\nimport unittest\nimport time\nfrom app.libs.crypto_enc import *\nfrom app.libs.crypto_sign import *\n\n\nclass TestAESEnc(unittest.TestCase):\n\n    def test_aes_enc_dec(self):\n        key = get_random_key_readable()\n        print('start test_aes_enc_dec')\n        total_len = 0\n        s = time.time()\n        for i in range(100):\n            mlen = random.randint(1, 1024*1024)\n            total_len += mlen\n            message = os.urandom(mlen)\n            enc = aes_cbc_encrypt(message, key)\n            dec = aes_cbc_decrypt(enc, key)\n            self.assertEqual(message, dec, 'aes message len {} is not equal'.format(mlen))\n        e = time.time()\n        print('total_len', total_len)\n        print('total_time', e - s)\n        print('speed', total_len / (e - s))\n\nif __name__ == '__main__':\n    unittest.main()\n注意这里的速度测试是不准的, 因为包含了urandom的时间, 而这个方法比较耗时.但是仍然可以看到, AES的加解密速度是极快的.\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "1"}