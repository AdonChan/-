{"title": " leetcode-394-Decode String - 个人文章 ", "index": "python", "content": "原题： Given an encoded string, return it's decoded string. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer. You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won't be input like 3a or 2[4]. Examples:\ns = \"3[a]2[bc]\", return \"aaabcbc\".\ns = \"3[a2[c]]\", return \"accaccacc\".\ns = \"2[abc]3[cd]ef\", return \"abcabccdcdcdef\".\n核心是理解题意，总结规律，属于哪一类题目。 此题的规律在于 嵌套组合(数字+字母), 而且从dp的角度看，每消除一个底层【】，就会形成一个新的底层【】。  所以规律是 解决 最里侧的【】。如此往复。   完成从内往外层层解决【】，需要保持字符串的记忆。stack可以完成。 再加上列表操作和字符串追加的小技巧。  应用：栈的操作，保持一个字符串的状态，并可以从后往前进行处理。  记忆时间的先后顺序， stack可以完成。 动态规划也可以。  思考问题可以从前往后考虑解决办法，也可以从后往前考虑，如果不能线性找到解决整体的办法，就采用动态规划的思想，找到解决局部问题的方法。\n正则解法：\nimport re\nclass Solution:\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        pattern=re.compile('(\\d+)\\[([a-zA-Z]+)\\]')\n        while '[' in s:\n            result_tmp=pattern.search(s)\n            print(result_tmp.groups())\n            # if result_tmp:\n            #     for freq,dst in result_tmp.group():\n            freq,dst = result_tmp.groups()\n            dst_str=dst*int(freq)\n            # print(dst)\n            s=pattern.sub(dst_str,s)\n            # print(dst,s)\n        return s\nif __name__=='__main__':\n    s = \"3[a]2[bc]\"\n    s = \"3[a2[c]]\"\n    s='3[a]2[bc]'\n    s='3[a]2[b4[F]c]'\n    s=\"2[ab3[cd]]4[xy]\"\n    st=Solution()\n    out=st.decodeString(s)\n    print(out)\n\n栈队列解法：\nclass Solution:\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        stack=[[1,'']]\n        final_str=''\n        num=''\n        for char_iter in s:\n            if char_iter.isdigit():\n                num+=char_iter\n                # stack.append([char_iter,''])\n            elif char_iter=='[':\n                stack.append([int(num),''])\n                num=''\n            elif char_iter.isalpha():\n                stack[-1][-1]+=char_iter\n            elif char_iter==']':\n                # print(stack)\n                freq_chars=stack.pop()\n                # print(freq_chars)\n                str_tmp=freq_chars[1]*int(freq_chars[0])\n                stack[-1][-1]+=str_tmp\n            else:\n                stack[0][-1]+=str_tmp\n        # print(final_str)\n        # print(stack)\n        return stack[0][1]\n\n\nif __name__=='__main__':\n    s = \"3[a]2[bc]\"\n    s = \"3[a2[c]]\"\n    s='3[a]2[bc]'\n    s='3[a]2[b4[F]c]'\n    s=\"2[ab3[cd]]4[xy]\"\n    s='\"2[abc]3[cd]ef\"'\n    s=\"100[leetcode]\"\n    st=Solution()\n    out=st.decodeString(s)\n    print(out)\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}