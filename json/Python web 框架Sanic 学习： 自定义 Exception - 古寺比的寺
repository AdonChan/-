{"title": "Python web 框架Sanic 学习： 自定义 Exception - 古寺比的寺 ", "index": "python,异常处理", "content": "Sanic 是一个和类Flask 的基于Python3.5+的web框架，它使用了 Python3 异步特性，有远超 flask 的性能。\n编写 RESTful API 的时候，我们会定义特定的异常错误类型，比如我定义的错误返回值格式为：\n{\n  \"error_code\": 0,\n  \"message\": \"string\",\n  \"text\": \"string\"\n}\n不同的错误信息指定不同的 http 状态码。\nsanic 提供了几种常用的 exception：\n\nNotFound(404)\nForbidden(403)\nServerError(500)\nInvalidUsage(400)\nUnauthorized(401)\nRequestTimeout(408)\nPayloadTooLarge(413)\n\n这些 exception 继承自 SanicException 类：\nclass SanicException(Exception):\n\n    def __init__(self, message, status_code=None):\n        super().__init__(message)\n\n        if status_code is not None:\n            self.status_code = status_code\n从上述代码可以看出，这些异常只能指定 message 和 status_code 参数，那我们可不可以自定义 exception 然后在自定义的 exception 中增加参数呢？下面的代码是按照这个思路修改后的代码：\nclass ApiException(SanicException):\n\n    def __init__(self, code, message=None, text=None, status_code=None):\n        super().__init__(message)\n        self.error_code = code\n        self.message = message\n        self.text = text\n\n        if status_code is not None:\n            self.status_code = status_code\n使用后我得到一个结果如下：\n\n从结果可以发现，除了 http 状态码使我想要的其它全错，连 content-type 都是 text/plain; charset=utf-8，为什么会这样呢，我们定义的参数code 和 text 去了哪里？\n翻开 sanic handler 的代码https://github.com/channelcat/sanic/blob/master/sanic/handlers.py我找到了答案：\ndef default(self, request, exception):\n        self.log(format_exc())\n        if issubclass(type(exception), SanicException):\n            # 如果是 SanicException 类，返回格式是定义好的，\n            # response 处理方法用的是 text\n            return text(\n                'Error: {}'.format(exception),\n                status=getattr(exception, 'status_code', 500),\n                headers=getattr(exception, 'headers', dict())\n            )\n        elif self.debug:\n            html_output = self._render_traceback_html(exception, request)\n\n            response_message = (\n                'Exception occurred while handling uri: \"{}\"\\n{}'.format(\n                    request.url, format_exc()))\n            log.error(response_message)\n            return html(html_output, status=500)\n        else:\n            return html(INTERNAL_SERVER_ERROR_HTML, status=500)\n从源码可以看出，如果response 结果是 SanicException 类，response 处理方法会改用text，响应内容格式为 Error: status_code。\n看来直接使用自定义异常类的方法不能满足我们上边定义的 json 格式（需要有 error_code、message 和 text）数据的要求。那我们能不能自定义 异常处理方法呢？答案当然是可以。\n下面介绍两种自定义异常处理的方法：\n使用 response.json\n这种方法比较简单，既然 sanic 异常处理是把错误信息使用 response.text() 方法返回，那我们改成 response.json() 不就可以了么。sanic response 提供了 json 的响应对象。可以使用 response.json 定义一个错误处理方法：\ndef json_error(error_code, message, text, status_code):\n    return json(\n        {\n            'error_code': error_code,\n            'message': message,\n            'text': text\n        },\n        status=status_code)\n这样我们只需要在需要抛出异常的地方 return json_error(code, msg, text, status_code)。\n使用这种方法有一点需要注意：\n\ndef get_account():\n    ...\n    if account:\n        return account\n    else:\n        # 如果用户没找到 返回错误信息\n        return json_error(code, msg, text, status_code)\n    \n@app.route(\"/\")\nasync def test(request):\n    account = get_account()\n    return text('Hello world!')\n这段代码中，如果我们没有找到用户信息，json_error 的返回结果会赋值给 account，并不会抛出异常，如果需要抛出异常，我们需要在 test 方法中检查 account 的结果，如果包含 account 是 response.json 对象， 直接 return， 更正后的代码如下：\n@app.route(\"/\")\nasync def test(request):\n    account = get_account()\n    if isinstance(account, response.json):\n        return account\n    return text('Hello world!')\n这样虽然简单，但是会增加很多不必要的判断，那有没有方法可以直接抛出异常呢？这时就可以使用 sanic 提供的 @app.exception 装饰器了。\n使用 Handling exceptions\nsanic 提供了一个 @app.exception装饰器，使用它可以覆盖默认的异常处理方法。它的使用方法也很简单：\nfrom sanic.response import text\nfrom sanic.exceptions import NotFound\n\n@app.exception(NotFound)\ndef ignore_404s(request, exception):\n    return text(\"Yep, I totally found the page: {}\".format(request.url))\n这个装饰器允许我们传入一个需要捕获的异常的列表，然后，就可以在自定义方法中返回任意的响应数据了。\n以下自定义的异常处理类：\nerror_codes = {\n    'invalid_token': ('Invalid token', '无效的token'),\n}\n\ndef add_status_code(code):\n    \"\"\"\n    Decorator used for adding exceptions to _sanic_exceptions.\n    \"\"\"\n    def class_decorator(cls):\n        cls.status_code = code\n        return cls\n    return class_decorator\n\n\nclass MetisException(SanicException):\n\n    def __init__(self, code, message=None, text=None, status_code=None):\n        super().__init__(message)\n        self.error_code = code\n        _message, _text = error_codes.get(code, (None, None))\n        self.message = message or _message\n        self.text = text or _text\n\n        if status_code is not None:\n            self.status_code = status_code\n\n@add_status_code(404)\nclass NotFound(MetisException):\n    pass\n\n@add_status_code(400)\nclass BadRequest(MetisException):\n    pass\n\n# 使用 app.exception 捕获异常，返回自定义响应数据\n@app.exception(Unauthorized, NotFound, BadRequest)\ndef json_error(request, exception):\n    return json(\n        {\n            'error_code': exception.error_code,\n            'message': exception.message,\n            'text': exception.text\n        },\n        status=exception.status_code)\n参考链接\n\nSanic Exceptions\nMetis\n\n\n最后，感谢女朋友支持。\n\n\n欢迎关注(April_Louisa)\n请我喝芬达\n\n\n\n\n\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "4"}