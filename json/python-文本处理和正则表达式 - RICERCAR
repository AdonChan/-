{"title": "python-文本处理和正则表达式 - RICERCAR ", "index": "文本处理,正则表达式,python", "content": "【未完成初稿】这周在工作中遇到很多需要从一段字符中增删查改的工作，第一遍用自己写的脚本去做，结果是可重用性不高，而且效率也不太好。其中也用到了python中的正则表达式部分re,后来就想能不能将我遇到的这类问题全部用正则去解决，具体就是python的re模块。答案目前还不知道，在还没遇到更多的问题之前，还是不要轻易下结论。这篇文章就当作一个备忘录，用来记录遇到的文本处理问题，其解决的办法，重点是正则表达式能做到的，因为它总比我们自己写的快嘛。\n这篇文章分为几个部分：1，遇到的文本处理的问题2，正则能够解决的和不能解决的3，正则的基本知识4，python中re正则模块的学习5，结合一些实例，用正则完整分析一个问题6，有哪些不用正则也可以很好解决的7，回顾和思考8，资源其中第1,2,5,6,7可能要不断更新的。\n\n1，遇到的文本处理的问题\n1.1 将一个字符串中的所有中文标点符号替换为英文的。1.2 将字符串中某些词替换为另外一个词1.3 删除字符串中的某些词\n2，正则能够解决的和不能解决的\n3，正则的基本知识\n[注]这部分引用了正则表达式 - 语法正则表达式30分钟入门教程3.1 正则是什么\n正则表达式(regular expression)描述了一种字符串匹配的模式，可以用来检查一个串是否含有某种子串、将匹配的子串做替换或者从某个串中取出符合某个条件的子串等。\n3.2 一个简单的例子  \n从一段英语文字中找到单词hi,咋一看很简单，如果是在python中你可能只需要用str.find('hi')就可以找到它的第一个位置了，但除非你的句子中没有hight,shift...包含hi的词，除非你不把Hi、HI也当成hi,除非...  \n使用正则表达式只要用\\bhi\\b就可以表达这个意思。首先，正则表达式会自动帮我们忽略大小写，然后，\\b是正则表达式规定的一个特殊代码，代表着单词的开头或结尾，也就是单词的分界处，代表着hi这个词前后都被空格、逗号等等分割。\n也就是说当我们要处理一段文本得到我们想要的东西的时候，要求太多，我们以为理所当然的事情计算机不会，我们需要用一套机制告诉它我们认为理所应当的规则，这就是正则表达式，它高度抽象、非常不好写。所以我们需要一个工具下载Regex Tester帮助我们，大概是这样的：\n3.3 怎样写正则表达式\n正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为\"元字符\"）组成的文字模式。\n正常的英语都是以a-z 26个字母组成的，而正则语句是由普通字符和元字符组成的，其中：  \n普通字符：所有大写和小写字母、所有数字、所有标点符号和一些其他符号。  元字符：按功能分类，它包括 非打印字符、特殊字符、限定符、定位符、\n非打印字符\n\n\n字符\n      描述\n   \n\ncx\n      匹配由x指明的控制字符。例如， cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。\n   \n\nf\n      匹配一个换页符。等价于 x0c 和 cL。\n   \n\nn\n      匹配一个换行符。等价于 x0a 和 cJ。\n   \n\nr\n      匹配一个回车符。等价于 x0d 和 cM。\n   \n\ns\n      匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ fnrtv]。\n   \n\nS\n      匹配任何非空白字符。等价于 1。\n   \n\nt\n      匹配一个制表符。等价于 x09 和 cI。\n   \n\nv\n      匹配一个垂直制表符。等价于 x0b 和 cK。\n   \n\n\n   \n\n特殊字符\n\n\n特别字符\n      描述\n   \n\n$\n      匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 'n' 或 'r'。要匹配 $ 字符本身，请使用 $。\n   \n\n( )\n      标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。\n   \n\n*\n      匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 *。\n   \n\n+\n      匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。\n   \n\n.\n\n   \n\n[\n      标记一个中括号表达式的开始。要匹配 [，请使用 [。\n   \n\n?\n      匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。\n   \n\n|\n5789536e17c4d1581d5e6e1dc5484afa163\n\n      将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'n' 匹配换行符。序列 '\\' 匹配 \"\"，而 '(' 则匹配 \"(\"。\n   \n\n^\n      匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 ^。\n   \n\n{\n      标记限定符表达式的开始。要匹配 {，请使用 {。\n   \n\n|\n      指明两项之间的一个选择。要匹配 |，请使用 |。\n   \n\n\n   \n\n\n限定符   限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有*或+或?或{n}或{n,}或{n,m}共6种。  \n正则表达式的限定符有：\n\n\n\n字符\n      描述\n   \n\n*\n      匹配前面的子表达式零次或多次。例如，zo 能匹配 \"z\" 以及 \"zoo\"。 等价于{0,}。\n   \n\n+\n      匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 \"zo\" 以及 \"zoo\"，但不能匹配 \"z\"。+ 等价于 {1,}。\n   \n\n?\n      匹配前面的子表达式零次或一次。例如，\"do(es)?\" 可以匹配 \"do\" 或 \"does\" 中的\"do\" 。? 等价于 {0,1}。\n   \n\n{n}\n      n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 \"Bob\" 中的 'o'，但是能匹配 \"food\" 中的两个 o。\n   \n\n{n,}\n      n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 \"Bob\" 中的 'o'，但能匹配 \"foooood\" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。\n   \n\n{n,m}\n      m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，\"o{1,3}\" 将匹配 \"fooooood\" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。\n   \n\n\n   \n\n定位符   定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。定位符用来描述字符串或单词的边界，^和$分别指字符串的开始与结束，b描述单词的前或后边界，B表示非单词边界。\n\n\n\n   \n\n字符\n      描述\n   \n\n^\n      匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 n 或 r 之后的位置匹配。\n   \n\n$\n      匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 n 或 r 之前的位置匹配。\n   \n\nb\n      匹配一个字边界，即字与空格间的位置。\n   \n\nB\n      非字边界匹配。\n   \n\n\n   \n\n4，python中re正则模块的学习\n正则在python中是通过re模块实现的。文档下面给出re核心函数和方法\n   **`re` 模块的函数                              描述**\n\ncomplie(pattern,flags=0)           对正则表达式模式 pattern 进行编译，flags 是可选标志符，并返回一个 regex 对象\n\nmatch(pattern,string,flags=0)      用pattern匹配字符串 string,成功返回匹配对象，否则返回None\n\nsearch(pattern,string,flags=0)     在字符串 string 中查找正则表达式模式 pattern 的第一次出现，匹配成功，返回一个匹配对象；否则返回 None\n\nfindall(pattern,string[,flags])    在字符串 string 中查找正则表达式模式 pattern 的所有(非重复)出现；返回一个匹配对象的列表\n\nfinditer(pattern,string,[,flags])  和 findall()相同，但返回的不是列表而是迭代器；对于每个匹配，该迭代器返回一个匹配对象\n\nsplit(pattern,string,max=0)        根据正则表达式 pattern 中的分隔符把字符 string 分割为一个列表，返回成功匹配的列表，最多分割 max 次(默认是分割所有匹配的地方)。\n\nsub(pattern,repl,string,max=0)     把字符串 string 中所有匹配正则表达式 pattern 的地方替换成字符串 repl,如果 max 的值没有给出， 则对所有匹配的地方进行替换。\n\ngroup(num=0)                       返回全部匹配对象(或指定编号是 num 的子组)\n\ngroups()                           返回一个包含全部匹配的子组的元组(如果没成功匹配，就返回一个空元组)\n\n1. 使用 compile()编译正则表达式为什么要编译：正则表达式模式使用前必须先被编译成 regex 对象，也就是说每次使用都要编译一次，那还不如先编译，然后随时用起来，省时省空间。  \n原本是这样：\nresult1=re.match(pattern,string1)\nresult2=re.match(pattern,string2)\nresult3=re.match(pattern,string3)\n...\n现在是这样：\nprog = re.compile(pattern)\nresult1 = prog.match(string1)\nresult2 = prog.match(string2)\nresult3 = prog.match(string3)\n... \n结果是不用每次都要将pattern作为参数放入函数中去了，大大节省时间。\n2. 用 match()匹配字符串\n简单：\nm = re.match('foo', 'foo') # pattern matches string ，模式匹配字符串\nif m is not None: # show match if successful 如果成功，显示匹配\n    m.group()#group()返回全部对象 'foo'\n\nm = re.match('foo', 'bar')# pattern does not match string 模式不匹配字符串\nm#None\nm = re.match('foo', 'food on the table') # match succeeds # 匹配成功\nm.group()#'foo'\n\n+正则：\n3. 用search()匹配字符串\n其实，你要搜索的模式出现在一个字符串中间的机率要比出现在字符串开头的机率更大一些。\n这正是 search()派上用场的时候。search 和 match 的工作方式一样，不同之处在于 search 会检查参数字符串任意位置的地方给定正则表达式模式的匹配情况。如果搜索到成功的匹配，会返回一个匹配对象，否则返回 None。\n\n现在我们来举例说明 match()和 search()之间的区别。我们用字符串\"foo\"去匹配“seafood”:\nm = re.match('foo', 'seafood') # no match 匹配失败\nm#None\nm = re.search('foo', 'seafood') # use search() instead 改用 search()\nif m is not None: m.group()\n'foo'#匹配成功\n\n4. 用findall()匹配字符串\n它用于非重叠地查找某字符串中一个正则表达式模式出\n现的情况。findall()和 search()相似之处在于二者都执行字符串搜索，但 findall()和 match()与search()不同之处是，findall()总返回一个列表。如果 findall()没有找到匹配的部分，会返回空列表；如果成功找到匹配部分，则返回所有匹配部分的列表(按从左到右出现的顺序排列)。\n\nre.findall('car', 'carry the barcardi to the car')\n['car', 'car', 'car']\n\n\n5. 用 split()分割(分隔模式)\nre 模块和正则表达式对象的方法 split()与字符串的 split()方法相似， 前者是根据正则表达式模式分隔字符串，后者是根据固定的字符串分割,因此与后者相比，显著提升了字符分割的能力。  \n\nre.split(':', 'str1:str2:str3')\n['str1', 'str2', 'str3']\n\n6. 用 sub()[和 subn()]进行搜索和替换\n二者几乎是一样的，都是将某字符串中所有匹配正则表达式模式的部分进行替换。用来替换的部分通常是一个字符串，但也可能是一个函数，该函数返回一个用来替换的字符串。subn()和 sub()一样，但它还返回一个表示替换次数的数字，替换后的字符串和表示替换次数的数字作为一个元组的元素返回。\n\n re.sub('l','L','hello')\n\n heLLo\n\n\n5，结合一些实例，用正则完整分析一个问题\n实例1：\n前几天处理了一个小问题,问题描述如下：问题：字符串s有两种内容，一种是'客车',一种是'4排5座SUV',如果是'客车'原样返回，如果是  '4排5座SUV',则将字符串'4排5座SUV'中的'5座'单独提取出来，这个问题很简单先用if语句解决'客车',在查看'4排5座SUV'中文和英文的字符长度，用切片选出来就行，解决如下:\ntry:\n    if s=='客车':\n        return s\n    else:\n        return s[3:6]\nexcept:\n        return ''\n\n其实用正则可以轻松解决：\nimport re\nsplit=re.compile('\\d座|客车')\ntry:\n    result=split.search(s).group()\nexcept:\n    result=''\n\n使用正则的好处：1,不需要先知道要匹配字符的位置如[3:6],如果要匹配很多条结果用切片法肯定很乱。2,更加灵活，如果出现'￥%……4排5座SUV'也可以成功匹配3,预先编译，更高效\n6，有哪些不用正则也可以很好解决的\n7，回顾和思考\n8，资源\n12个优秀资源助你迅速掌握正则表达式\n\n fnrtv ↩\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "10"}