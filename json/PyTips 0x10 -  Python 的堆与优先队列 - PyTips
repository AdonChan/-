{"title": "PyTips 0x10 -  Python 的堆与优先队列 - PyTips ", "index": "pytips,python3.5,python", "content": "项目地址：https://git.io/pytips\nPython 中内置的 heapq 库和 queue 分别提供了堆和优先队列结构，其中优先队列 queue.PriorityQueue 本身也是基于 heapq 实现的，因此我们这次重点看一下 heapq。\n堆（Heap）是一种特殊形式的完全二叉树，其中父节点的值总是大于子节点，根据其性质，Python 中可以用一个满足 heap[k] <= heap[2*k+1] and heap[k] <= heap[2*k+2] 的列表来实现（heapq 也确实是这么做的）。堆可以用于实现调度器（例见：Python 3.5 之协程），更常用的是优先队列（例如：ImageColorTheme）。\nheapq 提供了下面这些方法：\nimport heapq\nprint(heapq.__all__)\n['heappush', 'heappop', 'heapify', 'heapreplace', 'merge', 'nlargest', 'nsmallest', 'heappushpop']\n\n由于 Heap 是通过列表实现的，我们可以直接用列表创建：\nfrom heapq import *\nheap = []\nheappush(heap, 3)\nheappush(heap, 2)\nheappush(heap, 1)\nprint(heap)\n[1, 3, 2]\n\npop 或 sort 前要确保 heapify\n或者通过 heapify 将普通列表转化为 Heap：\nheap = list(reversed(range(5)))\nprint(\"List: \", heap)\nheapify(heap)\nprint(\"Heap: \", heap)\nList:  [4, 3, 2, 1, 0]\nHeap:  [0, 1, 2, 4, 3]\n\n每次从 Heap 中 pop 出来的元素都是最小的（因而可以据此实现堆排序）：\nheap = [5,4,3,2,1]\nheapify(heap)\nprint(heappop(heap))\nprint(heappop(heap))\nprint(heappop(heap))\n1\n2\n3\n\n优先队列\nqueue.PriorityQueue 实际上只是对 heapq 的简单封装，直接使用其 heappush/heappop 方法：\nfrom queue import PriorityQueue as PQueue\npq = PQueue()\npq.put((5 * -1, 'Python'))\npq.put((4 * -1, 'C'))\npq.put((3 * -1, 'Js'))\nprint(\"Inside PriorityQueue: \", pq.queue) # 内部存储\nwhile not pq.empty():\n    print(pq.get()[1])\nInside PriorityQueue:  [(-5, 'Python'), (-4, 'C'), (-3, 'Js')]\nPython\nC\nJs\n\n由于 heapq 是最小堆，而通常 PriorityQueue 用在较大有限制的排前面，所以需要给 priority * -1。\nsorted 一定是 Heap，反之未必\n需要注意的是，虽然 Heap 通过 List 实习，但未经过 heapify() 处理的仍然是一个普通的 List，而 heappush 和 heappop 操作每次都会对 Heap 进行重新整理。此外，一个 Heap 列表不一定是正确排序的，但是经过 list.sort() 的列表一定是 Heap：\nimport random\nlst = [random.randrange(1, 100) for _ in range(5)]\nlst.sort()\nprint(\"List: \", lst)\nprint(\"Poped: \", heappop(lst))\nheappush(lst, 4)\nprint(\"Heap: \", lst)\nList:  [24, 55, 81, 83, 87]\nPoped:  24\nHeap:  [4, 55, 81, 87, 83]\n\n最大/最小的 N 个数\nHeap 还提供了 nsmallest 和 nlargest 方法用于取出前 n 个最大/最小数：\nheap = [random.randrange(1, 1000) for _ in range(1000)]\nheapify(heap)\nprint(\"N largest: \", nlargest(10, heap))\nprint(\"N smallest: \", nsmallest(10, heap))\nprint(len(heap))  # 不原地修改\nN largest:  [999, 999, 998, 994, 992, 991, 990, 988, 985, 982]\nN smallest:  [1, 1, 1, 2, 4, 5, 5, 6, 6, 9]\n1000\n\n合并（排序）\nmerge 方法用于将两个 Heap 进行合并：\nheapA = sorted([random.randrange(1, 100) for _ in range(3)])\nheapB = sorted([random.randrange(1, 100) for _ in range(3)])\n\nmerged = []\nfor i in merge(heapA, heapB):\n    merged.append(i)\nprint(merged)\n[5, 29, 66, 66, 70, 99]\n\n最后两个方法 heapreplace 和 heappushpop 分别相当于：\nlstA = [1,2,3,4,5]\nlstB = [1,2,3,4,5]\n\npoped = heapreplace(lstA, 0)\nprint(\"lstA: \", lstA, \"poped: \", poped)\n\n# is equal to...\npoped = heappop(lstB)\nheappush(lstB, 0)\nprint(\"lstB: \", lstA, \"poped: \", poped)\n\nprint(\"*\"*30)\n\npoped = heappushpop(lstA, 9)\nprint(\"lstA: \", lstA, \"poped: \", poped)\n\n# is equal to...\nheappush(lstB, 9)\npoped = heappop(lstB)\nprint(\"lstB: \", lstB, \"poped: \", poped)\nlstA:  [0, 2, 3, 4, 5] poped:  1\nlstB:  [0, 2, 3, 4, 5] poped:  1\n******************************\nlstA:  [2, 4, 3, 9, 5] poped:  0\nlstB:  [2, 4, 3, 5, 9] poped:  0\n\n这两个方法的执行效率要比分开写的方法高，但要注意 heapreplace 要取代的值是否比 heap[0] 大，如果不是，可以用更有效的方法：\nitem = 0\nlstA = [1,2,3,4,5]\nif item < lstA[0]:\n    # replace\n    poped = lstA[0]\n    lstA[0] = item\n    print(\"lstA: \", lstA, \"poped: \", poped)\nlstA:  [0, 2, 3, 4, 5] poped:  1\n\n\n欢迎关注公众号 PyHub！\n\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "10"}