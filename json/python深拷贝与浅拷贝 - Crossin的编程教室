{"title": "python深拷贝与浅拷贝 - Crossin的编程教室 ", "index": "python", "content": "之前关于 Python 的作用域、赋值、参数传递，我们接连谈了几篇文章：\n\n全菊变量和菊部变量\n关于函数参数传递，80%人都错了\n可变对象与不可变对象\n\n今天我们依然要就相关话题继续下去。\n首先是上次最后的思考题：\n\n\nm = [1, 2, [3]]\nn = m[:]\nn[1] = 4\nn[2][0] = 5\nprint(m)\n\n\nm 的结果是什么？\n\n正确答案是 [1, 2, [5]] ，这次比上次好点，有 35% 的正确率。\n当时我留了个提示，说和浅拷贝、深拷贝有关，现在我们就来具体说一说。\n假设有这样一个 list 变量 m，其中有 4 个元素（别被嵌套迷惑了）：\n\n\nm = [1, 2, [3, 4], [5, [6, 7]]]\n\n\n为了更直观的表示，我来画个图：\n\n现在我们想要再来“复制”一个同样的变量。也许第一个闪过脑中的念头就是：\n\n\nn = m\n\n\n但看了前面的文章后你应该知道，这样的 赋值只相当于增加了一个标签，并没有新的对象产生 ：\n\n用 id 验证下就知道， m 和 n 仍然是同一个东西 。那么他们内部的元素自然也是一样的，对其中一个进行修改，另一个也会跟着变：\n\n\nm = [1, 2, [3, 4], [5, [6, 7]]]\nprint('m:', id(m))\nprint([id(i) for i in m])\nn = m\nprint('n:', id(n))\nprint([id(i) for i in n])\nprint(n is m)\nprint(n[0] is m[0])\nprint(n[2] is m[2])\nn[0] = -1\nprint(m)\nn[2][1] = -1\nprint(m)\n\n\n输出\n\n\nm: 4564554888\n[4556507504, 4556507536, 4564554760, 4564555016]\nn: 4564554888\n[4556507504, 4556507536, 4564554760, 4564555016]\nTrue\nTrue\nTrue\n[-1, 2, [3, 4], [5, [6, 7]]]\n[-1, 2, [3, -1], [5, [6, 7]]]\n\n\n因此有人将此操作称为“ 旧瓶装旧酒 ”，只是多贴了一层标签，这不能达到我们的目的。要得到一个对象的“拷贝”，我们需要用到 copy 方法：\n\n\nfrom copy import copy\nm = [1, 2, [3, 4], [5, [6, 7]]]\nprint('m:', id(m))\nprint([id(i) for i in m])\nn = copy(m)\nprint('n:', id(n))\nprint([id(i) for i in n])\nprint(n is m)\nprint(n[0] is m[0])\nprint(n[2] is m[2])\nn[0] = -1\nprint(m)\nn[2][1] = -1\nprint(m)\n\n\n输出\n\n\nm: 4340253832\n[4333009264, 4333009296, 4340253704, 4340253960]\nn: 4340268104\n[4333009264, 4333009296, 4340253704, 4340253960]\nFalse\nTrue\nTrue\n[1, 2, [3, 4], [5, [6, 7]]]\n[1, 2, [3, -1], [5, [6, 7]]]\n\n\n从结果中可以看出， n 和 m 已不是同一个对象 ，对于某个元素的重新赋值不会影响原对象。但是，它们 内部的元素全都是一样的 ，所以对一个可变类型元素的修改，则仍然会反应在原对象中。\n\n（其实这里1、2也是指向同一个对象，但作为不可变对象来说，它们互不影响，直观上的感受就相当于是复制了一份，故简化如图上所示）\n这种复制方法叫做 浅拷贝 （ shallow copy ），又被人形象地称作“ 新瓶装旧酒 ”，虽然产生了新对象，但里面的内容还是来自同一份。\n如果要彻底地产生一个和原对象完全独立的复制品，得使用 深拷贝 （ deep copy ）：\n\n\nfrom copy import deepcopy\nm = [1, 2, [3, 4], [5, [6, 7]]]\nprint('m:', id(m))\nprint([id(i) for i in m])\nn = deepcopy(m)\nprint('n:', id(n))\nprint([id(i) for i in n])\nprint(n is m)\nprint(n[0] is m[0])\nprint(n[2] is m[2])\nn[0] = -1\nprint(m)\nn[2][1] = -1\nprint(m)\n\n\n输出\n\n\nm: 4389131400\n[4381886832, 4381886864, 4389131272, 4389131528]\nn: 4389131208\n[4381886832, 4381886864, 4389131656, 4389145736]\nFalse\nTrue\nFalse\n[1, 2, [3, 4], [5, [6, 7]]]\n[1, 2, [3, 4], [5, [6, 7]]]\n\n\n此时， 对新对象中元素做任何改动都不会影响原对象 。新对象中的子列表，无论有多少层，都是新的对象，有不同的地址。\n\n按照前面的比喻，深拷贝就是“ 新瓶装新酒 ”。\n你可能会注意到一个细节：n 中的前两个元素的地址仍然和 m 中一样。这是由于它们是 不可变对象，不存在被修改的可能，所以拷贝和赋值是一样的 。\n于是，深拷贝也可以理解为，不仅是对象自身的拷贝，而且对于对象中的每一个子元素，也都进行同样的拷贝操作。这是一种 递归 的思想。\n不过额外要说提醒一下的是， 深拷贝的实现过程并不是完全的递归 ，否则如果对象的某级子元素是它自身的话，这个过程就死循环了。实际上， 如果遇到已经处理过的对象，就会直接使用其引用，而不再重复处理 。听上去有点难懂是不是？想想这个例子大概就会理解了：\n\n\nfrom copy import deepcopy\nm = [1, 2]\nm.append(m)\nprint(m, id(m), id(m[2]))\nn = deepcopy(m)\nprint(n, id(n), id(n[2]))\n\n\n输出\n\n\n[1, 2, [...]] 4479589576 4479589576\n[1, 2, [...]] 4479575048 4479575048\n\n\n最后，还是给各位留个思考：\n\n\nfrom copy import deepcopy\na = [3, 4]\nm = [1, 2, a, [5, a]]\nn = deepcopy(m)\nn[3][1][0] = -1\nprint(n)\n\n\n深拷贝后的 n，修改了其中一个元素值，会是怎样的效果？\n思考一下输出会是什么？\n然后自己在电脑上或者我们的在线编辑器 Crossin的编程教室 - 在线Python编辑器 里输入代码运行下看看结果，再想想为什么。\n欢迎留言给出你的解释。\n════\n其他文章及回答：\n如何自学Python | 新手引导 | 精选Python问答 | Python单词表 | 人工智能 | 嘻哈 | 爬虫 | 我用Python | 高考 | requests | AI平台\n欢迎搜索及关注： Crossin的编程教室\n\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "1"}