{"title": "python-八大算法 - python技术的魅力 ", "index": "算法,python", "content": "排序算法总结\n排序算法\n平均时间复杂度\n冒泡排序O(n2)\n选择排序O(n2)\n插入排序O(n2)\n希尔排序O(n1.5)\n快速排序O(N*logN)\n归并排序O(N*logN)\n堆排序O(N*logN)\n基数排序O(d(n+r))\n一. 冒泡排序(BubbleSort)\n基本思想：两个数比较大小，较大的数下沉，较小的数冒起来。\n过程：比较相邻的两个数据，如果第二个数小，就交换位置。从后向前两两比较，一直到比较最前两个数据。最终最小数被交换到起始的位置，这样第一个最小数的位置就排好了。继续重复上述过程，依次将第2.3...n-1个最小数排好位置。冒泡排序\n平均时间复杂度：O(n2)\npython代码实现：\ndef bubble_sort(lists):\n    # 冒泡排序\n    count = len(lists)\n    for i in range(0, count):\n        for j in range(i + 1, count):\n            if lists[i] > lists[j]:\n                lists[i], lists[j] = lists[j], lists[i]\n    return lists\n二. 选择排序(SelctionSort)\n基本思想：第1趟，在待排序记录r1 ~ r[n]中选出最小的记录，将它与r1交换；第2趟，在待排序记录r2 ~ r[n]中选出最小的记录，将它与r2交换；以此类推，第i趟在待排序记录r[i] ~ r[n]中选出最小的记录，将它与r[i]交换，使有序序列不断增长直到全部排序完毕。\n过程：选择排序\n平均时间复杂度：O(n2)\npython代码实现：\ndef select_sort(lists):\n    # 选择排序\n    count = len(lists)\n    for i in range(0, count):\n        min = i\n        for j in range(i + 1, count):\n            if lists[min] > lists[j]:\n                min = j\n        lists[min], lists[i] = lists[i], lists[min]\n    return lists\n三. 插入排序(Insertion Sort)\n基本思想：在要排序的一组数中，假定前n-1个数已经排好序，现在将第n个数插到前面的有序数列中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。\n过程：插入排序相同的场景\n平均时间复杂度：O(n2)\npython代码实现：\n# 插入排序\nlist1 = [42, 20, 17, 13, 28, 14, 23, 15]\ndef insert_sort(lists):\n    # 列表长度\n    count = len(lists)\n    for i in range(1, count):   # 100 1-99 0-99\n        key = lists[i]  # i指列表下表\n        j = i - 1\n        while j >= 0:\n            if lists[j] > key:\n                lists[j + 1] = lists[j]\n                lists[j] = key\n            j -= 1\n    return lists\n\nprint('插入排序结果：', insert_sort(list1))\n四. 希尔排序(Shell Sort)\n前言：数据序列1： 13-17-20-42-28 利用插入排序，13-17-20-28-42. Number of swap:1;数据序列2： 13-17-20-42-14 利用插入排序，13-14-17-20-42. Number of swap:3;如果数据序列基本有序，使用插入排序会更加高效。\n基本思想：在要排序的一组数中，根据某一增量分为若干子序列，并对子序列分别进行插入排序。然后逐渐将增量减小,并重复上述过程。直至增量为1,此时数据序列基本有序,最后进行插入排序。\n过程：希尔排序\n平均时间复杂度：\npython代码实现：\nlist2 = [59, 20, 17, 13, 28, 14, 23, 83]\n# 希尔排序\ndef shell_sort(lists):\n    count = len(lists)\n    # 增量缩减值 2倍\n    step = 2\n    # 初始增量值\n    group = int(count / step)\n    # print(group)\n    while group > 0:\n        for i in range(0, group):\n            j = i + group\n            while j < count:\n                k = j - group\n                key = lists[j]\n                while k >= 0:\n                    if lists[k] > key:\n                        lists[k + group] = lists[k]\n                        lists[k] = key\n                    k -= group\n                j += group\n        group = int(group / step)\n    return lists\n\nprint('希尔排序结果：', shell_sort(list2))\n五. 快速排序(Quicksort)\n通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。\n基本思想：（分治）先从数列中取出一个数作为key值；将比这个数小的数全部放在它的左边，大于或等于它的数全部放在它的右边；对左右两个小数列重复第二步，直至各区间只有1个数。\n辅助理解：挖坑填数\n平均时间复杂度：O(N*logN)\npython代码实现：\ndef quick_sort(lists, left, right):\n    # 快速排序\n    if left >= right:\n        return lists\n    key = lists[left]\n    low = left\n    high = right\n    while left < right:\n        while left < right and lists[right] >= key:\n            right -= 1\n        lists[left] = lists[right]\n        while left < right and lists[left] <= key:\n            left += 1\n        lists[right] = lists[left]\n    lists[right] = key\n    quick_sort(lists, low, left - 1)\n    quick_sort(lists, left + 1, high)\n    return lists\n六. 归并排序(Merge Sort)\n归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。\n归并过程为：比较a[i]和a[j]的大小，若a[i]≤a[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素a[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。\n平均时间复杂度：O(NlogN)归并排序的效率是比较高的，设数列长为N，将数列分开成小数列一共要logN步，每步都是一个合并有序数列的过程，时间复杂度可以记为O(N)，故一共为O(N*logN)。\npython代码实现：\ndef merge(left, right):\n    i, j = 0, 0\n    result = []\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result += left[i:]\n    result += right[j:]\n    return result\n \ndef merge_sort(lists):\n    # 归并排序\n    if len(lists) <= 1:\n        return lists\n    num = len(lists) / 2\n    left = merge_sort(lists[:num])\n    right = merge_sort(lists[num:])\n    return merge(left, right)\n七. 堆排序(HeapSort)\n基本思想：图示： （88,85,83,73,72,60,57,48,42,6）\nHeap Sort\n平均时间复杂度：O(NlogN)由于每次重新恢复堆的时间复杂度为O(logN)，共N - 1次重新恢复堆操作，再加上前面建立堆时N / 2次向下调整，每次调整时间复杂度也为O(logN)。二次操作时间相加还是O(N * logN)。\npython代码实现：\ndef adjust_heap(lists, i, size):\n    lchild = 2 * i + 1\n    rchild = 2 * i + 2\n    max = i\n    if i < size / 2:\n        if lchild < size and lists[lchild] > lists[max]:\n            max = lchild\n        if rchild < size and lists[rchild] > lists[max]:\n            max = rchild\n        if max != i:\n            lists[max], lists[i] = lists[i], lists[max]\n            adjust_heap(lists, max, size)\n \ndef build_heap(lists, size):\n    for i in range(0, (size/2))[::-1]:\n        adjust_heap(lists, i, size)\n \ndef heap_sort(lists):\n    size = len(lists)\n    build_heap(lists, size)\n    for i in range(0, size)[::-1]:\n        lists[0], lists[i] = lists[i], lists[0]\n        adjust_heap(lists, 0, i)\n八. 基数排序(RadixSort)\n BinSort 基本思想：BinSort想法非常简单，首先创建数组A[MaxValue]；然后将每个数放到相应的位置上（例如17放在下标17的数组位置）；最后遍历数组，即为排序后的结果。\n图示： BinSort 问题： 当序列中存在较大值时，BinSort 的排序方法会浪费大量的空间开销。\n RadixSort 基本思想： 基数排序是在BinSort的基础上，通过基数的限制来减少空间的开销。过程：过程1过程2\n（1）首先确定基数为10，数组的长度也就是10.每个数34都会在这10个数中寻找自己的位置。（2）不同于BinSort会直接将数34放在数组的下标34处，基数排序是将34分开为3和4，第一轮排序根据最末位放在数组的下标4处，第二轮排序根据倒数第二位放在数组的下标3处，然后遍历数组即可。\npython代码实现：\ndef adjust_heap(lists, i, size):\n    lchild = 2 * i + 1\n    rchild = 2 * i + 2\n    max = i\n    if i < size / 2:\n        if lchild < size and lists[lchild] > lists[max]:\n            max = lchild\n        if rchild < size and lists[rchild] > lists[max]:\n            max = rchild\n        if max != i:\n            lists[max], lists[i] = lists[i], lists[max]\n            adjust_heap(lists, max, size)\n \ndef build_heap(lists, size):\n    for i in range(0, (size/2))[::-1]:\n        adjust_heap(lists, i, size)\n \ndef heap_sort(lists):\n    size = len(lists)\n    build_heap(lists, size)\n    for i in range(0, size)[::-1]:\n        lists[0], lists[i] = lists[i], lists[0]\n        adjust_heap(lists, 0, i)\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "10"}