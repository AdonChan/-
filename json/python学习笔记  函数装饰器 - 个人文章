{"title": "python学习笔记  函数装饰器 - 个人文章 ", "index": "python3.x,python", "content": "函数装饰器\n函数装饰器用于在源码中“标记”函数， 以某种方式增强函数的行为，这是一个强大的功能。\n函数装饰器是一个可调用对象，其参数是另外一个函数，即被装饰函数。装饰器可能处理被装饰函数，然后将其返回，或者将其替换成另一个函数或可调用对象。\n函数装饰器的一个重要特性就是，它们在被装饰的函数定义之后立即运行。\nregistry = []\n\ndef register(func):\n    print('running register(%s)' % func)\n    registry.append(func)\n    return func\n\n@register\ndef f1():\n    print('running f1()')\n\n@register\ndef f2():\n    print('running f2()')\n\ndef f3():\n    print('running f3()')\n\ndef main():\n    print('running main()')\n    print('registry ->', registry)\n    f1()\n    f2()\n    f3()\n\nif __name__ == '__main__':\n    main()\n\n\n运行结果：\nrunning register(<function f1 at 0x0000022DC2D23620>)\nrunning register(<function f2 at 0x0000022DC2D236A8>)\nrunning main()\nregistry -> [<function f1 at 0x0000022DC2D23620>, <function f2 at 0x0000022DC2D236A8>]\nrunning f1()\nrunning f2()\nrunning f3()\n\n可以看到，被装饰的 f1() 和 f2() 首先被运行，随后才运行main()中的语句。\n被装饰函数运行时，其本身的内容（示例中print语句）并没有被执行，而是运行了装饰器函数中的print语句；这就是装饰器的作用，替代被装饰函数，同时装饰器也可以调用外界自由变量（registry），从而引出一个重要概念：\n闭包\n实例中registry变量和register函数组合的共同体，被成称为闭包。\n该例中有两个不太寻常的地方：\n\n装饰器函数和被装饰函数定义在一个模块之中；一般来说，两者应该定义在不同的模块；\nregister装饰器返回的函数与通过参数传入的相同；实际上，大部分装饰器会在内部定义一个函数，然后将其返回。\n\n实现一个简单的装饰器\n# clockdeco.py 输出被装饰函数的运行时间\nimport time\n\n\ndef clock(func):\n    def clocked(*args):\n        t0 = time.perf_counter()\n        result = func(*args)\n        elapsed = time.perf_counter() - t0\n        name = func.__name__\n        arg_str = ','.join(repr(arg) for arg in args)\n        print('[%0.8fs] %s(%s) -> %r' % (elapsed, name, arg_str, result))\n        return result\n    return clocked\n\n简单运用：\n# clockdeco_demo.py \nimport time\nfrom clockdeco import clock\n\n@clock\ndef snooze(seconds):\n    time.sleep(seconds)\n\n@clock\ndef factorial(n):\n    return 1 if n < 2 else n*factorial(n-1)\n\ndef main():\n    print('*' * 40, 'Calling snooze(.123)')\n    snooze(.123)\n    print('*' * 40, 'Calling factorial(6)')\n    print('6! =', factorial(6))\n\nif __name__ == '__main__':\n    main()\n\n运行结果：\n**************************************** Calling snooze(.123)\n[0.12240868s] snooze(0.123) -> None\n**************************************** Calling factorial(6)\n[0.00000068s] factorial(1) -> 1\n[0.00020317s] factorial(2) -> 2\n[0.00039755s] factorial(3) -> 6\n[0.00053638s] factorial(4) -> 24\n[0.00062375s] factorial(5) -> 120\n[0.00067319s] factorial(6) -> 720\n6! = 720\n\n运行过程中，首先输出装饰器函数中的内容：\n\n被装饰函数运行时间长度；\n函数名称和实际参数\n计算结果\n\n然后得到最终的计算结果。可见，装饰器函数的优先级较高\n当然，该实例中的装饰器具有几个缺点：\n\n不支持关键字参数\n遮盖了被装饰函数的__name__和__doc__属性\n\n下面的例子对其做出改进：\n# clockdeco2.py\nimport time\nimport functools\n\n\ndef clock(func):\n    @functools.wraps(func)\n    def clocked(*args, **kwargs):\n        t0 = time.time()\n        result = func(*args, **kwargs)\n        elapsed = time.time() - t0\n        name = func.__name__\n        arg_lst = []\n        if args:\n            arg_lst.append(','.join(repr(arg) for arg in args))\n        if kwargs:\n            pairs = ['%s=%r' % (k, w) for k, w in sorted(kwargs.items())]\n            arg_lst.append(', '.join(pairs))\n        arg_str = ', '.join(arg_lst)\n        print('[%0.8fs] %s(%s) -> %r ' % (elapsed, name, arg_str, result))\n        return result\n    return clocked\n\n\n运用：\n# clockdeco_demo.py\nimport time\nfrom clockdeco2 import clock\n\n@clock\ndef snooze(seconds):\n    time.sleep(seconds)\n\n@clock\ndef factorial(n):\n    return 1 if n < 2 else n*factorial(n-1)\n\ndef main():\n    print('*' * 40, 'Calling snooze(.123)')\n    snooze(.123)\n    print('*' * 40, 'Calling factorial(6)')\n    print('6! =', factorial(6))\n\nif __name__ == '__main__':\n    main()\n\n运行结果：\n**************************************** Calling snooze(.123)\n[0.12328553s] snooze(0.123) -> None\n**************************************** Calling factorial(6)\n[0.00000000s] factorial(1) -> 1\n[0.00000000s] factorial(2) -> 2\n[0.00000000s] factorial(3) -> 6\n[0.00099683s] factorial(4) -> 24\n[0.00099683s] factorial(5) -> 120\n[0.00099683s] factorial(6) -> 720\n6! = 720\n\n改进后的clockdeco2.py中，使用functools.wraps装饰器把相关属性从func复制到clocked中，此外，这个新版本还能正确处理关键字参数。functools.wraps是标准库中的装饰器，它可以用于装饰一个函数，但是对于被装饰函数本身的功能没有任何影响，它的功能只是传递函数内置参数。\n参数化clock装饰器\n# clockdeco_param.py\nimport time\n\n\nDEFAULT_FMT = '[{elapsed:0.8f}s] {name}({args}) -> {result}'\n\ndef clock(fmt=DEFAULT_FMT):\n    def decorate(func):\n        def clocked(*_args):\n            t0 = time.time()\n            _result = func(*_args)\n            elapsed = time.time() - t0\n            name = func.__name__\n            args = ','.join(repr(arg) for arg in _args)\n            result = repr(_result)\n            print(fmt.format(**locals()))\n            return _result\n        return clocked\n    return decorate\n\n\ndef clock 是参数化装饰器工厂函数\ndecorate(func)  是真正的装饰器\nclocked 包装被装饰的函数\n\n示例1：\n# clockdeco_param_demo.py\nimport time\nfrom clockdeco_param import clock\n\n@clock()\ndef snooze(seconds):\n    time.sleep(seconds)\n\nfor i in range(3):\n    snooze(.123)\n\n运行结果：\n[0.12367034s] snooze(0.123) -> None\n[0.12367010s] snooze(0.123) -> None\n[0.12366986s] snooze(0.123) -> None\n\n示例2：\n# clockdeco_param_demo.py\nimport time\nfrom clockdeco_param import clock\n\n@clock('{name}:{elapsed}s')\ndef snooze(seconds):\n    time.sleep(seconds)\n\nfor i in range(3):\n    snooze(.123)\n\n运行结果：\nsnooze:0.12366843223571777s\nsnooze:0.12369871139526367s\nsnooze:0.12366509437561035s\n\n示例3：\n# clockdeco_param_demo.py\nimport time\nfrom clockdeco_param import clock\n\n@clock('{name}({args}) dt={elapsed:0.3f}s')\ndef snooze(seconds):\n    time.sleep(seconds)\n\nfor i in range(3):\n    snooze(.123)\n\n运行结果：\nsnooze(0.123) dt=0.124s\nsnooze(0.123) dt=0.124s\nsnooze(0.123) dt=0.124s\n\n分析三个示例可以看出，当装饰器clock的参数不同时，被装饰函数运行所得结果也会不同。\npython中参数化装饰器的用意在于将更多的参数传送给装饰器，因为装饰器的第一个参数一定是被装饰函数。\n备忘装饰器  functools.lru_cache\nfunctools.lru_cache和functools.wraps一样，也是一个python内置装饰器，它的功能是将耗时的函数结果保存起来，避免传图相同的参数造成重复计算，从而节省代码运行时间。\n下面以斐波那契数列写一个案例:\n\n使用functools.lru_cache\nimport functoolsfrom clockdeco import clock\n@functools.lru_cache()@clockdef fibonacci(n):\nif n < 2:\n    return  n\nreturn fibonacci(n-2) + fibonacci(n-1)\n\nif __name__=='__main__':\nprint(fibonacci(30))\n\n\n运行结果：\n[0.00000000s] fibonacci(0) -> 0\n[0.00000068s] fibonacci(1) -> 1\n......\n[0.00000271s] fibonacci(29) -> 514229\n[0.00542815s] fibonacci(30) -> 832040\n832040\n\n多次运行，计算fibonacci(30)大概耗时0.005秒左右\n作为对比：\nimport functools\nfrom clockdeco import clock\n\n\n@clock\ndef fibonacci(n):\n    if n < 2:\n        return  n\n    return fibonacci(n-2) + fibonacci(n-1)\n\nif __name__=='__main__':\n    print(fibonacci(30))\n\n运行结果：\n.......\n[156.42139917s] fibonacci(28) -> 317811\n[230.80184171s] fibonacci(29) -> 514229\n[368.52227404s] fibonacci(30) -> 832040\n832040\n\n嗯……陷入沉思，虽然笔记本渣渣配置，但是运行了6分钟，差距太大\n总结\n\n函数装饰器就是用来装饰函数的函数，并使用内置函数替代被装饰函数\n被装饰函数在定义时就运行，无需显示调用\n内置装饰器functools.wraps可以为被装饰函数赋值内置属性\n参数化装饰器可以接受不同参数并适用于被装饰函数，显示不同的作用，相当于装饰器中的定制化\n参数化的装饰器嵌套层次较深，逻辑相对复杂\n内置装饰器functools.lru_cache采用缓存机制，存储需要多次调用的函数值，从而降低代码运行时间\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}