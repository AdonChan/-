{"title": "Django搭建个人博客：使用Form表单类发表新文章 - Django搭建个人博客 ", "index": "form,python,django", "content": "前面我们已经学会如何用Markdown语法书写文章了。\n但是还有问题呀。之前写文章都是在后台中进行的，万一有别的普通用户也要发表文章怎么办？万一我想拓展些后台中没有的提交验证功能又怎么办？\n本章即讲述如何在前台中提交新的文章，以便满足开发者各种各样的特殊需求。\nForms表单类\n在HTML中，表单是在 <form>...</form> 中的一些元素，它允许访客做类似输入文本、选择选项、操作对象或空间等动作，然后发送这些信息到服务端。一些表单界面元素（文本框或复选框）非常简单并内置在HTML中，而其他会复杂些：像弹出日期选择等操作控件。\n处理表单是一件挺复杂的事情。想想看Django的admin，许多不同类型的数据可能需要在一张表单中准备显示，渲染成HTML，使用方便的界面进行编辑，传到服务器，验证和清理数据，然后保存或跳过进行下一步处理。\nDjango的表单功能可以简化上述工作的大部分内容，并且也能比大多数程序员自己编写代码去实现来的更安全。\nDjango表单系统的核心组件是 Form类，它能够描述一张表单并决定它如何工作及呈现。\n要使用Form类也很简单，需要在article/中创建forms.py文件，并写入如下代码：\narticle/forms.py\n\n# 引入表单类\nfrom django import forms\n# 引入文章模型\nfrom .models import ArticlePost\n\n# 写文章的表单类\nclass ArticlePostForm(forms.ModelForm):\n    class Meta:\n        # 指明数据模型来源\n        model = ArticlePost\n        # 定义表单包含的字段\n        fields = ('title', 'body')\n代码中ArticlePostForm类继承了Django的表单类forms.ModelForm，并在类中定义了内部类class Meta（之前提到过，还记得吗），指明了数据模型的来源，以及表单中应该包含数据模型的哪些字段。\n在ArticlePost模型中，created和updated字段为自动生成，不需要填入；author字段暂时固定为id=1的管理员用户，也不用填入；剩下的title和body就是表单需要填入的内容了。\n接下来，改写article/views.py，添加一个视图函数以处理写文章的请求：\narticle/views.py\n\n...\n\n# 引入redirect重定向模块\nfrom django.shortcuts import render, redirect\n# 引入HttpResponse\nfrom django.http import HttpResponse\n# 引入刚才定义的ArticlePostForm表单类\nfrom .forms import ArticlePostForm\n# 引入User模型\nfrom django.contrib.auth.models import User\n\n...\n\n# 写文章的视图\ndef article_create(request):\n    # 判断用户是否提交数据\n    if request.method == \"POST\":\n        # 将提交的数据赋值到表单实例中\n        article_post_form = ArticlePostForm(data=request.POST)\n        # 判断提交的数据是否满足模型的要求\n        if article_post_form.is_valid():\n            # 保存数据，但暂时不提交到数据库中\n            new_article = article_post_form.save(commit=False)\n            # 指定数据库中 id=1 的用户为作者\n            new_article.author = User.objects.get(id=1)\n            # 将新文章保存到数据库中\n            new_article.save()\n            # 完成后返回到文章列表\n            return redirect(\"article:article_list\")\n        # 如果数据不合法，返回错误信息\n        else:\n            return HttpResponse(\"表单内容有误，请重新填写。\")\n    # 如果用户请求获取数据\n    else:\n        # 创建表单类实例\n        article_post_form = ArticlePostForm()\n        # 赋值上下文\n        context = { 'article_post_form': article_post_form }\n        # 返回模板\n        return render(request, 'article/create.html', context)\n分析一下上面的代码。当视图函数接收到一个客户端的request请求时，首先根据request.method判断用户是要提交数据（POST）、还是要获取数据（GET）：\n\n\n如果用户是提交数据，将POST给服务器的表单数据赋于article_post_form实例。\n\n然后使用Django内置的方法.is_valid()判断提交的数据是否满足模型的要求。\n\n如果满足要求，保存表单中的数据（但是commit=False暂时不提交到数据库，因为author还未指定），并指定author为id=1的管理员用户。然后提交到数据库，并通过redirect返回文章列表。redirect可通过url地址的名字，反向解析到对应的url。\n如果不满足要求，则返回一个字符串\"表单内容有误，请重新填写。\"，告诉用户出现了什么问题。\n\n\n\n如果用户是获取数据，则返回一个空的表单类对象，提供给用户填写。\n\n其实逻辑并不复杂，不明白的读者请逐句理解。\n这里特别提醒Django中的缩进不能够空格和tab键混用，否则会报错。由于不同的编辑器对tab的显示不尽相同，因此你应该坚持使用空格键缩进。\n写好视图之后，就需要写模板文件了。在templates/article/中创建create.html：\ntemplates/article/create.html\n\n<!-- extends表明此页面继承自 base.html 文件 -->\n{% extends \"base.html\" %} {% load staticfiles %}\n<!-- 写入 base.html 中定义的 title -->\n{% block title %} 写文章 {% endblock title %}\n<!-- 写入 base.html 中定义的 content -->\n{% block content %}\n<!-- 写文章表单 -->\n<div class=\"container\">\n    <div class=\"row\">\n        <div class=\"col-12\">\n            <br>\n            <!-- 提交文章的表单 -->\n            <form method=\"post\" action=\".\">\n                <!-- Django中需要POST数据的地方都必须有csrf_token -->\n                {% csrf_token %}\n                <!-- 文章标题 -->\n                <div class=\"form-group\">\n                    <!-- 标签 -->\n                    <label for=\"title\">文章标题</label>\n                    <!-- 文本框 -->\n                    <input type=\"text\" class=\"form-control\" id=\"title\" name=\"title\">\n                </div>\n                <!-- 文章正文 -->\n                <div class=\"form-group\">\n                    <label for=\"body\">文章正文</label>\n                    <!-- 文本区域 -->\n                    <textarea type=\"text\" class=\"form-control\" id=\"body\" name=\"body\" rows=\"12\"></textarea>\n                </div>\n                <!-- 提交按钮 -->\n                <button type=\"submit\" class=\"btn btn-primary\">完成</button>\n            </form>\n        </div>\n    </div>\n</div>\n{% endblock content %}\nhtml文件还是一如既往的长。再重复一次，看不懂html文件语法也没有关系，先照着抄一遍，以后再慢慢理解，不影响目前Django的学习。\n对其中的新内容进行审视：\n\n\n<form>..</form>标签中的内容就是需要提交的表单。method=\"post\"指定了表单提交的方式为POST（与视图函数中的request.method相联系）；action=\".\"指定了表单提交的地址为默认的当前url。\n关于{% csrf_token %}，它是Django中一个与网络安全相关的中间件验证。目前我们暂时不去深究它的实现，只需要知道表单中必须包含它就可以了，否则将会得到一个403错误。\n\n<input>和<textarea>标签中的name=''属性指定了当前文本框提交的数据的名称，它必须与表单类中的字段名称对应，否则服务器无法将字段和数据正确的对应起来。\n\n最后老规矩，在article/urls.py中增加一个写文章的url地址：\narticle/urls.py\n\nurlpatterns = [\n    ...\n    \n    # 写文章\n    path('article-create/', views.article_create, name='article_create'),\n]\n大功告成了，不要着急，先喝口水，万一有bug又得忙活半天了。如果报错也不要慌张，开发过程一定是曲折的，耐心看看Django给出的错误提示，线索就在其中。\n保存修改并运行服务器，地址栏中输入：http://127.0.0.1:8000/article/article-create/，看到如下界面：\n\n很好，似乎正常工作起来了。接着随便输入些Markdown语法的文章，测试功能是否正常：\n\n点击完成按钮后，页面会回到文章列表：\n\n刚才提交的文章神奇的出现在列表中了。\n点击阅读本文按钮，进入文章详情页面：\n\n出现了具有Markdown语法的一篇优美的文章。\n使用Django编写博客是不是非常有成就感呢？\n别激动，还有一些收尾工作需要做。\n优化写文章入口\n与之前类似，我们需要在导航栏中设置一个写文章的入口，优化使用体验。\n将下列代码加入到templates/header.html中：\n<li class=\"nav-item\">\n    <a class=\"nav-link\" href=\"{% url 'article:article_create' %}\">写文章</a>\n</li>\n读者是否清楚，上面的代码应该放置在什么位置呢？\n保存后刷新浏览器界面，导航栏有了如下变化：\n\n点击写文章按钮，就可以进入写新文章的页面了，从此再也不用手动输入繁琐的url地址了。\n世界是多么的美好。\n总结\n本章学习了使用Django的表单类，完成了提交新文章的基本功能。当然目前暂时还没有真正将文章和登录的用户关联起来；等到学习了用户管理的知识，再回头来处理这部分的内容。\n下一章继续学习如何删除一篇文章。\n\n有疑问请在杜赛的个人网站留言，我会尽快回复。\n或Email私信我：dusaiphoto@foxmail.com\n项目完整代码：Django_blog_tutorial\n\n\n转载请告知作者并注明出处。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}