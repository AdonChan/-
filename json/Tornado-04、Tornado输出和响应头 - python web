{"title": "Tornado-04、Tornado输出和响应头 - python web ", "index": "ubuntu,tornado,python", "content": "Tornado输出和响应头\n\n1、输出\n在上一篇文章03、Tornado的输入与输出 对write有了初步的了解这篇文章我们先来深入了解一下write首先我们在上一次的tornado文件夹下新建一个lesson3文件夹实际上，write并没有直接把数据返回给前端，而是先写到缓存区，函数结束之后才会返回到前端。我们验证如下：新建start1.py文件 添加完基本的代码后加入以下代码\nclass FlushHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.write('11111111111' + '<br>')\n        self.write('22222222222' + '<br>')\n        self.write('There comes a flush' + '<br>')\n        self.flush()\n        import time\n        time.sleep(5)\n        self.write('33333333333' + '<br>')\n        self.write('There no flush' + '<br>')\n        self.write('The function is almost over!')\n\n\n\n\n\n这里我们可以很明显看到，在有无self.flush()的时候，结果是不一样的。如果有的话，就可以先看到前面的输出，没有的话，要等到函数执行完才能够一起打印出来 。self.flush()就是将当前输出缓冲区刷新到网页。\n除了上面的self.flush()之外，还有self.finish()需要我们注意，它就类似于函数里面的return,一旦执行，后面就不能再执行self.write,函数原型：\nRequestHandler.finish(chunk = None)\n在finish函数调用完后，调用write函数会报错\nself.finish()\nself.write('en~~~~')\n\n报错内容：RuntimeError: Cannot write() after finish()\n将给定的HTTP错误发送到浏览器\n函数原型：\nRequestHandler.send_error(status_code = 500，**kwargs)\n\n如果flush()已经被调用，则不可能发送错误，因此该方法将简单地终止响应。如果输出已写入但尚未刷新，则将其丢弃并替换为错误页面。\n覆盖write_error()以自定义返回的错误页面。传递附加的关键字参数添加下面的Handler\nclass ErrorHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.send_error(404)\n        # self.flush()\n        self.send_error(404)  #如果已经执行 self.flush() 则不会显示错误\n\n\n\n覆盖以实现自定义错误页面\n函数原型：\nRequestHandler.write_error(status_code，** kwargs )\nwrite_error可以调用write，render，set_header等，以产生输出。在ErrorHandler中添加以下代码\ndef write_error(self, status_code, **kwargs):  # 重写write_error方法\n    self.write(\"---%d----\\n\"%status_code)\n\n\n通过重写write_error方法，可以实现自定义的输出错误。\n设置响应的状态代码\nRequestHandler.set_status(status_code，reason = None)\n\n参数：\n\nstatus_code（int） - 响应状态码。\nreason（string） - 描述状态代码的人类可读原因短语。self.set_status(404,'error')\n\n\n2.响应头的设置\n以谷歌浏览器为例：按下F12，可以打开浏览器自带的控制台，我们选择Network，这里我们可以看到浏览器在页面上没有看到的信息。打开之后刷新一下，选择之后就可以看到:General,Respnse Headers和Request Headers\nGeneral:是请求中基本信息，Respnse Headers是相应信息，Request Headers是请求信息，在服务器端可以设置给浏览器的相应信息。添加以下代码\n(r'/header',HeadersHandler),\n\nclass HeadersHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.write('headers')\n        self.set_header('hujing',18)\n        self.set_header('changsha','hunan')\n\n\n函数原型：\nRequestHandler.set_header(name, value)\n\n如果值不是字符串，我们将其转换为字符串。然后将所有标题值编码为UTF-8\nself.set_header可以设置自己的需要的响应头\n添加给定的响应头和值\n函数原型：\nRequestHandler.add_header(*name*, *value*)\n\n不同set_header，add_header可能会多次调用以返回相同键的多个值。相同的键set_header只能返回一个值\nself.set_header('hujing','20')  #这里只会显示hujing:20 覆盖了前面的hujing:18\nself.add_header('hujing','19')  \nself.add_header('changsha','0731')  \nself.add_header('changsha','0321') \n\n撤消先前的set_header调用\n有添加，就会有删除，函数原型：\nRequestHandler.clear_header(name)\n\nself.clear_header('changsha')\n\n3.相应头的执行顺序\nclass IndexHandler(tornado.web.RequestHandler):\n    def set_default_headers(self):\n        print(' ---set_default_headers---:设置header'+'<br>')\n\n    def initialize(self):\n        print(' ---initialize---:初始化'+'<br>')\n\n    def prepare(self):\n        print(' ---prepare---：准备工作'+'<br>')\n\n    def get(self):\n        self.write(' ---get---：处理get请求'+'<br>')\n\n    def post(self):\n        self.write(' ---post---：处理post请求'+'<br>')\n\n    def write_error(self, status_code, **kwargs):\n        print(' ---write_error---：处理错误'+'<br>')\n\n    def on_finish(self):\n        print(' ---on_finish---：结束，释放资源'+'<br>')\n\n以上便是是一个响应在后台的执行顺序。可以根据需求来实现自己需要的内容。\n本文章源码总和\nimport tornado.httpserver\nimport tornado.ioloop\nimport tornado.options\nimport tornado.web\nfrom tornado.options import define, options\n\ndefine('port', default=9000, help='run port', type=int)\n\n\nclass FlushHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.write('11111111111' + '<br>')\n        self.write('22222222222' + '<br>')\n        self.write('There comes a flush' + '<br>')\n        self.flush()\n        import time\n        time.sleep(5)\n        self.write('33333333333' + '<br>')\n        self.write('There no flush' + '<br>')\n        self.write('The function is almost over!')\n\n\nclass ErrorHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.send_error(404)\n        # self.set_status(404, 'error')\n\n    def write_error(self, status_code, **kwargs):  # 重写write_error方法\n        self.write(\"--%d--\\n\" % status_code)\n\n\nclass HeadersHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.write('headers')\n        self.set_header('hujing', 18)\n        self.set_header('changsha', 'hunan')\n        self.set_header('hujing', '20')  # 1\n        self.add_header('hujing', '19')  # 2\n        self.add_header('changsha', '0731')  # 3\n        self.add_header('changsha', '0321')  # 4\n\n\nif __name__ == '__main__':\n    tornado.options.parse_command_line()\n    print(options.port)  # 打印端口到terminal\n    app = tornado.web.Application(\n        handlers=[\n            (r'/flush', FlushHandler),\n            (r'/error', ErrorHandler),\n            (r'/header', HeadersHandler),\n        ],\n        template_path='templates',\n\n    )\n    http_server = tornado.httpserver.HTTPServer(app)\n    http_server.listen(options.port)\n    tornado.ioloop.IOLoop.instance().start()\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}