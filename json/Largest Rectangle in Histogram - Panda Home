{"title": "Largest Rectangle in Histogram - Panda Home ", "index": "python,leetcode", "content": "Problem\n\nGiven n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.\nAbove is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].\nThe largest rectangle is shown in the shaded area, which has area = 10 unit.\n\nFor example,\nGiven height = [2,1,5,6,2,3],\nreturn 10.\n\nSolution\n\n暴力穷举法\n\n最简单的自然是暴力法，即穷举左端坐标和右端坐标，计算两个坐标之间矩形的最大面积，再从所有的面积中得出最大的即为解。但是该方法至少需要两个for循环来遍历每一种左右端的组合，时间复杂度为O($n^2$)。以下是该方法的代码，解是对的，但在leetcode上会超时。\n\nclass Solution:\n    # @param height, a list of integer\n    # @return an integer\n    def largestRectangleArea(self, height):\n        length = len(height)\n        max_area = -1\n        for i in range(length):\n            for j in range(i + 1, length):\n                h = min(height[i: j])\n                area = h * (j - i)\n                if max_area < area:\n                    max_area = area\n        return max_area\n\n\n利用栈减小时间复杂度\n\n可以考虑，计算一个矩形的面积时，比如图\n中的斜线部分，其两侧的高度一定是低于矩形所在的矩形条的高度的，因此可以通过维护一个栈来得出左端左边及右端坐标和矩形的高度，每一个矩形条只进栈一次，这样时间复杂度为O(n)。\n1. 算法从左向右遍历每个矩形，以当前遍历的位置为右端坐标，如果栈为空或者当前矩形不低于栈顶的矩形，则将当前的位置坐标压栈，因为此时的坐标一定不是右边界（指要计算的面积右边的一个矩形条，不包含在要计算的面积中），例如图中，加入当前坐标为3，高度为6，栈顶坐标的高度为5，那么当前矩形条不可能作为右边界，将其压栈。\n2. 如果当前位置的矩形低于栈顶的矩形条，那么当前位置可以作为一个矩形的边界，则从这个位置开始向左遍历，对每个高度大于右边界的矩形条作为左边界计算一次面积，直到高度小于右边界或栈为空。\n3. 在遍历过一遍之后，如果栈不为空，则以栈中的每个坐标作为左边界计算一次面积，结合步骤2得出最大面积。\nAccepted code如下：\n\nclass Solution:\n    # @param height, a list of integer\n    # @return an integer\n    def largestRectangleArea(self, height):\n        max_area = 0\n        i = 0\n        n = len(height)\n        stack = []\n        while i < n:\n            if len(stack) == 0 or height[i] >= height[stack[-1]]:\n                stack.append(i)\n                i += 1\n            else:\n                top = stack.pop()\n                area_with_top = height[top] * (i if len(stack) == 0 else i - stack[-1] - 1)\n                if max_area < area_with_top:\n                    max_area = area_with_top\n\n        while len(stack) != 0:\n            top = stack.pop()\n            area_with_top = height[top] * (i if len(stack) == 0 else i - stack[-1] - 1)\n            if max_area < area_with_top:\n                max_area = area_with_top\n\n        return max_area\n\n\n这个方法并不是提供一个准确的找出最大的矩形的算法，而是通过试验那些“可能”成为最大的矩形的面积，再从其中找出最大的。而最大的矩形一定满足两个边界的高度小于该矩形的高度这个条件（如果不满足的话，边界也可以被添加进来计算而不破坏矩形的形状，此时不为最大），因此找出所有这样的矩形就一定可以在其中找出面积最大的矩形。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}