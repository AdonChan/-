{"title": "Essential_SQLAlchemy2th学习笔记之Core模块 - 倚楼听风雨 ", "index": "python,sqlalchemy", "content": "SQL Expression Language对原生SQL语言进行了简单的封装两大模块SQLAlchemy Core and ORM：\n\nCore：提供执行SQL Expression Language的接口\nORM\n\n安装：SQLAlchemy及相关数据库驱动pip install sqlalchemy pymysql \n连接到数据库\n数据库连接字符串格式:请参考这里\nmysql://username:password@hostname/database\npostgresql://username:password@hostname/database\nsqlite:////absolute/path/to/database\noracle://scott:tiger@127.0.0.1:1521/orcl\n比如SQLite如下：\nfrom sqlalchemy import create_engine\nengine = create_engine('sqlite:///cookies.db')\nengine2 = create_engine('sqlite:///:memory:')\nengine3 = create_engine('sqlite:////home/cookiemonster/cookies.db')\nengine4 = create_engine('sqlite:///c:\\\\Users\\\\cookiemonster\\\\cookies.db')\n注意：create_engine函数返回以一个engine实例，但是不会立即获取数据库连接，直到在engine上进行操作如查询时才会去获取connection\n关于MySQL空闲连接8小时自动关闭的解决方案：传入 pool_recycle=3600参数\nfrom sqlalchemy import create_engine\nengine = create_engine('mysql+pymysql://cookiemonster:chocolatechip@mysql01.monster.internal/cookies', pool_recycle=3600)\ncreate_engine其余的一些参数：\n\necho：是否log打印执行的sql语句及其参数。默认为False\nencoding:默认utf-8\nisolation_level:隔离级别\npool_recycle：指定连接回收间隔，这对于MySQL连接的8小时机制特别重要。默认-1\n\n获取连接\nfrom sqlalchemy import create_engine\nengine = create_engine('mysql+pymysql://cookiemonster:chocolatechip' \\\n'@mysql01.monster.internal/cookies', pool_recycle=3600)\nconnection = engine.connect()\nSchema and Types\n四种类型集合：• Generic• SQL standard• Vendor specific• User defined\nSQLAlchemy定义了很多generic types以兼容不同数据库。这些类型都定义在sqlalchemy.types模块中，为了方便也可以从sqlalchemy直接导入这些类型。类型对应表如下：\n\n\nSQLAlchemy\nPython\nSQL\n\n\n\nBigInteger\nint\nBIGINT\n\n\nBoolean\nbool\nBOOLEAN or SMALLINT\n\n\nDate\ndatetime.date\nDATE (SQLite: STRING)\n\n\nDateTime\ndatetime.datetime\nDATETIME (SQLite: STRING)\n\n\nEnum\nstr\nENUM or VARCHAR\n\n\nFloat\nfloat or Decimal\nFLOAT or REAL\n\n\nInteger\nint\nINTEGER\n\n\nInterval\ndatetime.timedelta\nINTERVAL or DATE from epoch\n\n\nLargeBinary\nbyte\nBLOB or BYTEA\n\n\nNumeric\ndecimal.Decimal\nNUMERIC or DECIMAL\n\n\nUnicode\nunicode\nUNICODE or VARCHAR\n\n\nText\nstr\nCLOB or TEXT\n\n\nTime\ndatetime.time\nDATETIME\n\n\n\n如果这些类型不能满足你，比如有些数据库支持json类型，那么你需要用到sqlalchemy.dialects模块中对应数据库的类型。比如from sqlalchemy.dialects.postgresql import JSON\nMetadata & Table & Column\nMetadata为了快速访问数据库。可以看作是很多Table对象的集合，还有一些关于engin,connection的信息。可以通过MetaData.tables访问这些表对象字典定义表对象之前需要先实例化Metadata:\nfrom sqlalchemy import MetaData\nmetadata = MetaData()\nTable对象构建如下：第一个参数为名称，第二个参数为Metadata对象，后续参数为Column对象. Column对象参数为,名称，类型，及其余等\nfrom sqlalchemy import Table, Column, Integer, Numeric, String, ForeignKey\ncookies = Table('cookies', metadata,\nColumn('cookie_id', Integer(), primary_key=True),\nColumn('cookie_name', String(50), index=True),\nColumn('cookie_recipe_url', String(255)),\nColumn('cookie_sku', String(55)),\nColumn('quantity', Integer()),\nColumn('unit_cost', Numeric(12, 2))\n)\nfrom datetime import datetime\nfrom sqlalchemy import DateTime\nusers = Table('users', metadata,\nColumn('user_id', Integer(), primary_key=True),\nColumn('username', String(15), nullable=False, unique=True),\nColumn('email_address', String(255), nullable=False),\nColumn('phone', String(20), nullable=False),\nColumn('password', String(25), nullable=False),\nColumn('created_on', DateTime(), default=datetime.now),\nColumn('updated_on', DateTime(), default=datetime.now, onupdate=datetime.now)\n注意：这里default,onupdate属性是一个callable对象而不是直接值，比如datetime.now(),因为这样的话，就永远是这个值，而不是每个实例实例化、更新时的时间了。比较有用的就是onupdate,每次更新时都会调用该方法或函数。\n键和约束(Keys and Constraints)键和约束既可以像上面那样通过kwargs定义在Column中，也可以在之后通过对象添加。相关类定义在基础的 sqlalchemy模块中，比如最常用的三个：from sqlalchemy import PrimaryKeyConstraint, UniqueConstraint, CheckConstraint\nPrimaryKeyConstraint('user_id', name='user_pk'),它也支持同时定义多个形成联合主键。\nUniqueConstraint('username', name='uix_username')\nCheckConstraint('unit_cost >= 0.00', name='unit_cost_positive')\n索引(Index)\nfrom sqlalchemy import Index\nIndex('ix_cookies_cookie_name', 'cookie_name')\n这个定义需要放置在Table构造器中。也可以在之后定义，比如Index('ix_test', mytable.c.cookie_sku, mytable.c.cookie_name))\n关联关系和外键约束(Relationships and ForeignKeyConstraints)\nfrom sqlalchemy import ForeignKey\norders = Table('orders', metadata,\nColumn('order_id', Integer(), primary_key=True),\nColumn('user_id', ForeignKey('users.user_id')),\nColumn('shipped', Boolean(), default=False)\n)\nline_items = Table('line_items', metadata,\nColumn('line_items_id', Integer(), primary_key=True),\nColumn('order_id', ForeignKey('orders.order_id')),\nColumn('cookie_id', ForeignKey('cookies.cookie_id')),\nColumn('quantity', Integer()),\nColumn('extended_cost', Numeric(12, 2))\n)\n注意：这里ForeignKey用的是字符串参数(这些字符串对应的是数据库中的表名.列名)，而非引用。这样隔离了模块间相互依赖我们也可以使用：ForeignKeyConstraint(['order_id'], ['orders.order_id'])\n创建或持久化表模式(Persisting the Tables)通过示例代码我们知道所有的Table定义，以及额外的模式定义都会与一个metadata对象关联。我们可以通过这个metadata对象来创建表：\nmetadata.create_all(engine)\n注意：默认情况下create_all不会重新创建已有表，所以它可以安全地多次调用，而且也非常友好地与数据库迁移库如Ablembic集成而不需要你进行额外手动编码。\n本节代码完整如下：\nfrom datetime import datetime\nfrom sqlalchemy import (MetaData, Table, Column, Integer, Numeric, String,\nDateTime, ForeignKey, create_engine)\nmetadata = MetaData()\ncookies = Table('cookies', metadata,\nColumn('cookie_id', Integer(), primary_key=True),\nColumn('cookie_name', String(50), index=True),\nColumn('cookie_recipe_url', String(255)),\nColumn('cookie_sku', String(55)),\nColumn('quantity', Integer()),\nColumn('unit_cost', Numeric(12, 2))\n)\nusers = Table('users', metadata,\nColumn('user_id', Integer(), primary_key=True),\nColumn('customer_number', Integer(), autoincrement=True),\nColumn('username', String(15), nullable=False, unique=True),\nColumn('email_address', String(255), nullable=False),\nColumn('phone', String(20), nullable=False),\nColumn('password', String(25), nullable=False),\nColumn('created_on', DateTime(), default=datetime.now),\nColumn('updated_on', DateTime(), default=datetime.now, onupdate=datetime.now)\n)\norders = Table('orders', metadata,\nColumn('order_id', Integer(), primary_key=True),\nColumn('user_id', ForeignKey('users.user_id'))\n)\nline_items = Table('line_items', metadata,\nColumn('line_items_id', Integer(), primary_key=True),\nColumn('order_id', ForeignKey('orders.order_id')),\nColumn('cookie_id', ForeignKey('cookies.cookie_id')),\nColumn('quantity', Integer()),\nColumn('extended_cost', Numeric(12, 2))\n)\nengine = create_engine('sqlite:///:memory:')\nmetadata.create_all(engine)\nSQLAlchemy-Core模块\n插入数据：\nins = cookies.insert().values(\ncookie_name=\"chocolate chip\",\ncookie_recipe_url=\"http://some.aweso.me/cookie/recipe.html\",\ncookie_sku=\"CC01\",\nquantity=\"12\",\nunit_cost=\"0.50\"\n)\nprint(str(ins))\n当然你也可以这么做：\nfrom sqlalchemy import insert\nins = insert(cookies).values(\ncookie_name=\"chocolate chip\",\ncookie_recipe_url=\"http://some.aweso.me/cookie/recipe.html\",\ncookie_sku=\"CC01\",\nquantity=\"12\",\nunit_cost=\"0.50\"\n)\n上述编译成预编译语句如下：\nINSERT INTO cookies\n(cookie_name, cookie_recipe_url, cookie_sku, quantity, unit_cost)\nVALUES\n(:cookie_name, :cookie_recipe_url, :cookie_sku, :quantity, :unit_cost)\n实际过程会是如下ins对象内部会调用compile()方法编译成上述语句，然后将参数存储到ins.compile().params字典中。接下来我们通过前面获取的connection对象执行statement：\nresult = connection.execute(ins)\n当然你也可以这么查询：\nins = cookies.insert()\nresult = connection.execute(\nins,\ncookie_name='dark chocolate chip',\ncookie_recipe_url='http://some.aweso.me/cookie/recipe_dark.html',\ncookie_sku='CC02',\nquantity='1',\nunit_cost='0.75'\n)\nresult.inserted_primary_key\n批量插入：\ninventory_list = [\n{\n'cookie_name': 'peanut butter',\n'cookie_recipe_url': 'http://some.aweso.me/cookie/peanut.html',\n'cookie_sku': 'PB01',\n'quantity': '24',\n'unit_cost': '0.25'\n},\n{\n'cookie_name': 'oatmeal raisin',\n'cookie_recipe_url': 'http://some.okay.me/cookie/raisin.html',\n'cookie_sku': 'EWW01',\n'quantity': '100',\n'unit_cost': '1.00'\n}\n]\nresult = connection.execute(ins, inventory_list)\n注意：一定要确保所有字典参数拥有相同的keys\n查询\nfrom sqlalchemy.sql import select\ns = select([cookies])\nrp = connection.execute(s)\nresults = rp.fetchall()\n当然我们也可以使用字符串来代替:\ns = select(\"\"\"SELECT cookies.cookie_id, cookies.cookie_name,\ncookies.cookie_recipe_url, cookies.cookie_sku, cookies.quantity,\ncookies.unit_cost FROM cookies\"\"\")\nconnection.execute返回的rp变量是一个ResultProxy对象(它是DBAPI中cursor对象的封装)。\n我们也可以这样写：\nfrom sqlalchemy.sql import select\ns = cookies.select()\nrp = connection.execute(s)\nresults = rp.fetchall()\nResultProxy使得查询结果可以通过index,name,or Column object访问列数据。例如：\nfirst_row = results[0]\nfirst_row[1] #游标列索引从1开始,by index\nfirst_row.cookie_name # by name\nfirst_row[cookies.c.cookie_name] #by Column object.\n你也可以迭代ResultProxy,如下：\nrp = connection.execute(s)\nfor record in rp:\nprint(record.cookie_name)\nResultProxy其余可用来获取结果集的方法\n\nfirst()\nfetchone()\nfetchall()\nscalar():Returns a single value if a query results in a single record with one column.\nkeys() 获取列名\n\n关于选择ResultProxy上述的方法的建议：1、使用first()而不是fetchone()来获取单条记录，因为fetchone()调用之后仍然保留着打开的connections共后续使用，如果不小心的话很容易引起问题。2、使用迭代方式获取所有结果，而不是fetchall(),更加省内存。3、使用scalar()获取单行单列结果时需要注意，如果返回多于一行，它会抛出异常。\n控制返回列的数目\ns = select([cookies.c.cookie_name, cookies.c.quantity])\nrp = connection.execute(s)\nprint(rp.keys())\nresult = rp.first()\n排序\ns = select([cookies.c.cookie_name, cookies.c.quantity])\ns = s.order_by(cookies.c.quantity)\nrp = connection.execute(s)\nfor cookie in rp:\nprint('{} - {}'.format(cookie.quantity, cookie.cookie_name))\n\n#倒序desc\nfrom sqlalchemy import desc\ns = select([cookies.c.cookie_name, cookies.c.quantity])\ns = s.order_by(desc(cookies.c.quantity))\n限制返回结果集的条数\ns = select([cookies.c.cookie_name, cookies.c.quantity])\ns = s.order_by(cookies.c.quantity)\ns = s.limit(2)\nrp = connection.execute(s)\nprint([result.cookie_name for result in rp])\n内置SQL函数\n在sqlalchemy.sql.func模块中\n#sum\nfrom sqlalchemy.sql import func\ns = select([func.sum(cookies.c.quantity)])\nrp = connection.execute(s)\nprint(rp.scalar())\n\n#count\ns = select([func.count(cookies.c.cookie_name)])\nrp = connection.execute(s)\nrecord = rp.first()\nprint(record.keys())\nprint(record.count_1) #字段名是自动生成的，<func_name>_<position>，可以设置别名的，看下面\n\n#设置别名\ns = select([func.count(cookies.c.cookie_name).label('inventory_count')])\nrp = connection.execute(s)\nrecord = rp.first()\nprint(record.keys())\nprint(record.inventory_count)\n\n过滤\n#where\ns = select([cookies]).where(cookies.c.cookie_name == 'chocolate chip')\nrp = connection.execute(s)\nrecord = rp.first()\nprint(record.items()) #调用row对象的items()方法。\n\n#like\ns = select([cookies]).where(cookies.c.cookie_name.like('%chocolate%'))\nrp = connection.execute(s)\nfor record in rp.fetchall():\n    print(record.cookie_name)\n可以在where中使用的子句元素\n\nbetween(cleft, cright)\nconcat(column_two) Concatenate column with column_two\ndistinct()\nin_([list])\nis_(None) Find where the column is None (commonly used for Null checks with None)\ncontains(string) Find where the column has string in it (case-sensitive)\nendswith(string) Find where the column ends with string (case-sensitive)\nlike(string) Find where the column is like string (case-sensitive)\nstartswith(string) Find where the column begins with string (case-sensitive)\nilike(string) Find where the column is like string (this is not case-sensitive)\n\n当然还包括一系列的notxxx方法，比如notin_(),唯一的例外是isnot()\n操作符\n\n+，-，*,/,%\n==,!=,<,>,<=,>=\nAND,OR,NOT,由于python关键字的原因，使用and_(),or_(),not_()来代替\n\n+号还可以用于字符串拼接：\ns = select([cookies.c.cookie_name, 'SKU-' + cookies.c.cookie_sku])\nfor row in connection.execute(s):\nprint(row)\nfrom sqlalchemy import cast\ns = select([cookies.c.cookie_name,\n    cast((cookies.c.quantity * cookies.c.unit_cost),\n        Numeric(12,2)).label('inv_cost')])\nfor row in connection.execute(s):\n    print('{} - {}'.format(row.cookie_name, row.inv_cost))\n注意：cast是另外一个函数，允许我们进行类型转换，上述转换是将数字转换为货币形式，和print('{} - {:.2f}'.format(row.cookie_name, row.inv_cost)).这个行为一致。\nfrom sqlalchemy import and_, or_, not_\ns = select([cookies]).where(\n    and_(\n        cookies.c.quantity > 23,\n        cookies.c.unit_cost < 0.40\n    )\n)\nfor row in connection.execute(s):\n    print(row.cookie_name)\n\n\nfrom sqlalchemy import and_, or_, not_\ns = select([cookies]).where(\n    or_(\n        cookies.c.quantity.between(10, 50),\n        cookies.c.cookie_name.contains('chip')\n    )\n)\nfor row in connection.execute(s):\n    print(row.cookie_name)\n\nupdate\nfrom sqlalchemy import update\nu = update(cookies).where(cookies.c.cookie_name == \"chocolate chip\")\nu = u.values(quantity=(cookies.c.quantity + 120))\nresult = connection.execute(u)\nprint(result.rowcount)\ns = select([cookies]).where(cookies.c.cookie_name == \"chocolate chip\")\nresult = connection.execute(s).first()\nfor key in result.keys():\n    print('{:>20}: {}'.format(key, result[key]))\ndelete\nfrom sqlalchemy import delete\nu = delete(cookies).where(cookies.c.cookie_name == \"dark chocolate chip\")\nresult = connection.execute(u)\nprint(result.rowcount)\n\ns = select([cookies]).where(cookies.c.cookie_name == \"dark chocolate chip\")\nresult = connection.execute(s).fetchall()\nprint(len(result))\njoins\njoin()，outerjoin()函数，select_from()函数\ncolumns = [orders.c.order_id, users.c.username, users.c.phone,\n           cookies.c.cookie_name, line_items.c.quantity,\n           line_items.c.extended_cost]\ncookiemon_orders = select(columns)\ncookiemon_orders = cookiemon_orders.select_from(orders.join(users).join(\n    line_items).join(cookies)).where(users.c.username ==\n                                     'cookiemon')\nresult = connection.execute(cookiemon_orders).fetchall()\nfor row in result:\n    print(row)\n\n最终产生的SQL语句如下：\nSELECT orders.order_id, users.username, users.phone, cookies.cookie_name,\nline_items.quantity, line_items.extended_cost FROM users JOIN orders ON\nusers.user_id = orders.user_id JOIN line_items ON orders.order_id =\nline_items.order_id JOIN cookies ON cookies.cookie_id = line_items.cookie_id\nWHERE users.username = :username_1\nouterjoin\ncolumns = [users.c.username, func.count(orders.c.order_id)]\nall_orders = select(columns)\nall_orders = all_orders.select_from(users.outerjoin(orders))\nall_orders = all_orders.group_by(users.c.username)\nresult = connection.execute(all_orders).fetchall()\nfor row in result:\n    print(row)\n表别名函数alias()\n>>> manager = employee_table.alias('mgr')\n>>> stmt = select([employee_table.c.name],\n            ... and_(employee_table.c.manager_id==manager.c.id,\n            ... manager.c.name=='Fred'))\n>>> print(stmt)\nSELECT employee.name\nFROM employee, employee AS mgr\nWHERE employee.manager_id = mgr.id AND mgr.name = ?\n分组\ncolumns = [users.c.username, func.count(orders.c.order_id)]\nall_orders = select(columns)\nall_orders = all_orders.select_from(users.outerjoin(orders))\nall_orders = all_orders.group_by(users.c.username)\nresult = connection.execute(all_orders).fetchall()\nfor row in result:\n    print(row)\nchaining\ndef get_orders_by_customer(cust_name, shipped=None, details=False):\n    columns = [orders.c.order_id, users.c.username, users.c.phone]\n    joins = users.join(orders)\n    if details:\n        columns.extend([cookies.c.cookie_name, line_items.c.quantity,\n            line_items.c.extended_cost])\n        joins = joins.join(line_items).join(cookies)\n    cust_orders = select(columns)\n    cust_orders = cust_orders.select_from(joins)\n\n    cust_orders = cust_orders.where(users.c.username == cust_name)\n    if shipped is not None:\n        cust_orders = cust_orders.where(orders.c.shipped == shipped)\n    result = connection.execute(cust_orders).fetchall()\n    return result\n执行原生SQL\n返回的还是ResultProxy对象1、完全采用原始SQL\nresult = connection.execute(\"select * from orders\").fetchall()\nprint(result)\n2、部分采用原始SQL，text()函数\nfrom sqlalchemy import text\nstmt = select([users]).where(text(\"username='cookiemon'\"))\nprint(connection.execute(stmt).fetchall())\n异常\nSQLALchemy定义了很多异常。我们通过关心：AttributeErrors，IntegrityErrors.等为了进行相关试验与说明，请先执行下面这些语句\nfrom datetime import datetime\nfrom sqlalchemy import (MetaData, Table, Column, Integer, Numeric, String,\n                        DateTime, ForeignKey, Boolean, create_engine,\n                        CheckConstraint)\nmetadata = MetaData()\ncookies = Table('cookies', metadata,\n                Column('cookie_id', Integer(), primary_key=True),\n                37\n                Column('cookie_name', String(50), index=True),\n                Column('cookie_recipe_url', String(255)),\n                Column('cookie_sku', String(55)),\n                Column('quantity', Integer()),\n                Column('unit_cost', Numeric(12, 2)),\n                CheckConstraint('quantity > 0', name='quantity_positive')\n                )\nusers = Table('users', metadata,\n              Column('user_id', Integer(), primary_key=True),\n              Column('username', String(15), nullable=False, unique=True),\n              Column('email_address', String(255), nullable=False),\n              Column('phone', String(20), nullable=False),\n              Column('password', String(25), nullable=False),\n              Column('created_on', DateTime(), default=datetime.now),\n              Column('updated_on', DateTime(),\n                     default=datetime.now, onupdate=datetime.now)\n              )\norders = Table('orders', metadata,\n               Column('order_id', Integer()),\n               Column('user_id', ForeignKey('users.user_id')),\n               Column('shipped', Boolean(), default=False)\n               )\nline_items = Table('line_items', metadata,\n                   Column('line_items_id', Integer(), primary_key=True),\n                   Column('order_id', ForeignKey('orders.order_id')),\n                   Column('cookie_id', ForeignKey('cookies.cookie_id')),\n                   Column('quantity', Integer()),\n                   Column('extended_cost', Numeric(12, 2))\n                   )\nengine = create_engine('sqlite:///:memory:')\nmetadata.create_all(engine)\nconnection = engine.connect()\n\nfrom sqlalchemy import select, insert\nins = insert(users).values(\nusername=\"cookiemon\",\nemail_address=\"mon@cookie.com\",\nphone=\"111-111-1111\",\npassword=\"password\"\n)\nresult = connection.execute(ins)\ns = select([users.c.username])\nresults = connection.execute(s)\nfor result in results:\nprint(result.username)\nprint(result.password) #此处包AttributeError异常\n在违反约束的情况下会出现IntegrityError异常。比如违反唯一性约束等。\ns = select([users.c.username])\nconnection.execute(s).fetchall()\n[(u'cookiemon',)]\nins = insert(users).values(\n    username=\"cookiemon\",\n    email_address=\"damon@cookie.com\",\n    phone=\"111-111-1111\",\n    password=\"password\"\n)\nresult = connection.execute(ins) #此处报IntegrityError, UNIQUE constraint failed: users.username\n#异常处理\ntry:\n    result = connection.execute(ins)\nexcept IntegrityError as error:\n    print(error.orig.message, error.params)\n所有的SQLAlchemy异常处理方式都是上面那种思路，通过[SQLAlchemyError](http://docs.sqlalchemy.org/en/latest/core/exceptions.html)可以获取到的信息由如下：\n\norig ：The DBAPI exception object.\nparams：The parameter list being used when this exception occurred.\nstatement ：The string SQL statement being invoked when this exception occurred.\n\n事务Transactions\nfrom sqlalchemy.exc import IntegrityError\n\n\ndef ship_it(order_id):\n    s = select([line_items.c.cookie_id, line_items.c.quantity])\n    s = s.where(line_items.c.order_id == order_id)\n    transaction = connection.begin() #开启事务\n    cookies_to_ship = connection.execute(s).fetchall()\n    try:\n        for cookie in cookies_to_ship:\n            u = update(cookies).where(cookies.c.cookie_id == cookie.cookie_id)\n            u = u.values(quantity=cookies.c.quantity - cookie.quantity)\n            result = connection.execute(u)\n        u = update(orders).where(orders.c.order_id == order_id)\n        u = u.values(shipped=True)\n        result = connection.execute(u)\n        print(\"Shipped order ID: {}\".format(order_id))\n        transaction.commit() #提交事务\n    except IntegrityError as error:\n        transaction.rollback()   #事务回滚\n        print(error)\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "5"}