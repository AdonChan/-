{"title": "Python gRPC 入门 - 古寺比的寺 ", "index": "python,grpc,rpc", "content": "gRPC 一开始由 google 开发，是一款语言中立、平台中立、开源的远程过程调用(RPC)系统。 本文通过一个简单的 Hello World 例子来向您介绍 gRPC 。\ngRPC 是什么？\ngRPC 也是基于以下理念：定义一个服务，指定其能够被远程调用的方法（包含参数和返回类型）。在服务端实现这个接口，并运行一个 gRPC 服务器来处理客户端调用。在客户端拥有一个存根能够像服务端一样的方法。\n在 gRPC 里客户端应用可以像调用本地对象一样直接调用另一台不同的机器上服务端应用的方法，使得我们能够更容易地创建分布式应用和服务。\n\ngRPC 客户端和服务端可以在多种环境中运行和交互，并且可以用任何 gRPC 支持的语言来编写。\ngRPC 支持 C++ Java Python Go Ruby C# Node.js PHP Dart 等语言\ngRPC 默认使用 protocol buffers，这是 Google 开源的一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。\n安装 Google Protocol Buffer\n方法一（建议使用）\n参考文档：gRPC Python Quickstart\n1. 安装 gRPC\n\npython -m pip install grpcio\n# 或者\nsudo python -m pip install grpcio\n\n# 在 El Capitan OSX 系统下可能会看到以下报错\n\n$ OSError: [Errno 1] Operation not permitted: '/tmp/pip-qwTLbI-uninstall/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/six-1.4.1-py2.7.egg-info'\n\n# 可以使用以下命令\npython -m pip install grpcio --ignore-installed\n2. 安装 gRPC tools\nPython gPRC tools 包含 protocol buffer 编译器和用于从 .proto 文件生成服务端和客户端代码的插件\npython -m pip install grpcio-tools\n方法二：\n在 github 页面protobuf Buffers可以下载二进制源码，下载后执行以下命令安装：\ntar -zxvf protobuf-all-3.5.1.tar\ncd protobuf-all-3.5.1\n./configure\nmake\nmake install\n\n>> protoc --version\nlibprotoc 3.5.1  # 安装成功\n因为是要使用 Protobuf + Python 测试，所以还要安装 python运行环境。protobuf Buffers python 文档\n# 打开 python 目录\ncd python\npython setup.py install  # 安装 python 运行环境\nProtobuf 基本使用\n定义一个消息类型\n先来看一个非常简单的例子。假设你想定义一个“搜索请求”的消息格式，每一个请求含有一个查询字符串、你感兴趣的查询结果所在的页数，以及每一页多少条查询结果。可以采用如下的方式来定义消息类型的.proto文件了：\nsyntax = \"proto3\";  // 声明使用 proto3 语法\n\nmessage SearchRequest {\n  string query = 1;  // 每个字段都要指定数据类型\n  int32 page_number = 2; // 这里的数字2 是标识符，最小的标识号可以从1开始，最大到2^29 - 1, or 536,870,911。不可以使用其中的[19000－19999]\n  int32 result_per_page = 3; // 这里是注释，使用 //\n}\n\n文章的第一行指定了你正在使用 proto3 语法：如果不指定，编译器会使用 proto2。这个指定语法必须是文件的非空非注释的第一行。\n\nSearchRequest消息格式有三个字段，在消息中承载的数据分别对应于每一个字段。其中每个字段都有一个名字和一种类型。\n向.proto文件添加注释，可以使用C/C++/java风格的双斜杠(//) 语法格式。\n在消息体中，每个字段都有唯一的一个数字标识符。这些标识符用来在消息的二进制格式中识别各个字段，一旦开始使用就不能再改变。\n\n[1,15]之内的标识号在编码的时候会占用一个字节。[16,2047]之内的标识号则占用2个字节。所以应该为那些频繁出现的消息元素保留 [1,15]之内的标识号。切记：要为将来有可能添加的、频繁出现的标识号预留一些标识号。\n指定字段规则\n所指定的消息字段修饰符必须是如下之一：\n\nsingular：一个格式良好的消息应该有0个或者1个这种字段（但是不能超过1个）。\n\nrepeated：在一个格式良好的消息中，这种字段可以重复任意多次（包括0次）。重复的值的顺序会被保留。\n在proto3中，repeated的标量域默认情况虾使用packed。\nmessage Test4 {\n  repeated int32 d = 4 [packed=true];\n}\n\n\n数值类型\n一个标量消息字段可以含有一个如下的类型——该表格展示了定义于.proto文件中的类型，以及与之对应的、在自动生成的访问类中定义的类型：\n\n\n.proto Type\nNotes\nC++ Type\nJava Type\nPython Type[2]\nGo Type\nRuby Type\n\n\n\ndouble\n \ndouble\ndouble\nfloat\nfloat64\nFloat\n\n\nfloat\n \nfloat\nfloat\nfloat\nfloat32\nFloat\n\n\nint32\n使用变长编码，对于负值的效率很低，如果你的域有可能有负值，请使用sint64替代\nint32\nint\nint\nint32\nFixnum 或者 Bignum（根据需要）\n\n\nuint32\n使用变长编码\nuint32\nint\nint/long\nuint32\nFixnum 或者 Bignum（根据需要）\n\n\nuint64\n使用变长编码\nuint64\nlong\nint/long\nuint64\nBignum\n\n\nsint32\n使用变长编码，这些编码在负值时比int32高效的多\nint32\nint\nint\nint32\nFixnum 或者 Bignum（根据需要）\n\n\nsint64\n使用变长编码，有符号的整型值。编码时比通常的int64高效。\nint64\nlong\nint/long\nint64\nBignum\n\n\nfixed32\n总是4个字节，如果数值总是比总是比228大的话，这个类型会比uint32高效。\nuint32\nint\nint\nuint32\nFixnum 或者 Bignum（根据需要）\n\n\nfixed64\n总是8个字节，如果数值总是比总是比256大的话，这个类型会比uint64高效。\nuint64\nlong\nint/long\nuint64\nBignum\n\n\nsfixed32\n总是4个字节\nint32\nint\nint\nint32\nFixnum 或者 Bignum（根据需要）\n\n\nsfixed64\n总是8个字节\nint64\nlong\nint/long\nint64\nBignum\n\n\nbool\n \nbool\nboolean\nbool\nbool\nTrueClass/FalseClass\n\n\nstring\n一个字符串必须是UTF-8编码或者7-bit ASCII编码的文本。\nstring\nString\nstr/unicode\nstring\nString (UTF-8)\n\n\nbytes\n可能包含任意顺序的字节数据。\nstring\nByteString\nstr\n[]byte\nString (ASCII-8BIT)\n\n\n\n默认值\n当一个消息被解析的时候，如果被编码的信息不包含一个特定的singular元素，被解析的对象锁对应的域被设置位一个默认值，对于不同类型指定如下：\n\n对于strings，默认是一个空string\n对于bytes，默认是一个空的bytes\n对于bools，默认是false\n对于数值类型，默认是0\n对于枚举，默认是第一个定义的枚举值，必须为0;\n对于消息类型（message），域没有被设置，确切的消息是根据语言确定的，详见generated code guide对于可重复域的默认值是空（通常情况下是对应语言中空列表）。\n\n\n嵌套类型\n你可以在其他消息类型中定义、使用消息类型，在下面的例子中，Result消息就定义在SearchResponse消息内，如：\nmessage SearchResponse {\n  message Result {\n    string url = 1;\n    string title = 2;\n    repeated string snippets = 3;\n  }\n  repeated Result results = 1;\n}\n在 message SearchResponse 中，定义了嵌套消息 Result，并用来定义SearchResponse消息中的results域。\nProtobuf 文件编译\n从.proto文件生成了什么？\n当用protocol buffer编译器来运行.proto文件时，编译器将生成所选择语言的代码，这些代码可以操作在.proto文件中定义的消息类型，包括获取、设置字段值，将消息序列化到一个输出流中，以及从一个输入流中解析消息。\n\n对C++来说，编译器会为每个.proto文件生成一个.h文件和一个.cc文件，.proto文件中的每一个消息有一个对应的类。\n对Java来说，编译器为每一个消息类型生成了一个.java文件，以及一个特殊的Builder类（该类是用来创建消息类接口的）。\n对Python来说，有点不太一样——Python编译器为.proto文件中的每个消息类型生成一个含有静态描述符的模块，，该模块与一个元类（metaclass）在运行时（runtime）被用来创建所需的Python数据访问类。\n对go来说，编译器会位每个消息类型生成了一个.pd.go文件。\n对于Ruby来说，编译器会为每个消息类型生成了一个.rb文件。\njavaNano来说，编译器输出类似域java但是没有Builder类\n对于Objective-C来说，编译器会为每个消息类型生成了一个pbobjc.h文件和pbobjcm文件，.proto文件中的每一个消息有一个对应的类。\n对于C#来说，编译器会为每个消息类型生成了一个.cs文件，.proto文件中的每一个消息有一个对应的类。\n\nPython gRPC 示例\n编译\n这里我们用Python 编译一下，看得到什么：\n// 文件名 hello.proto\nsyntax = \"proto3\";\n\npackage hello;\n\n// The greeting service definition.\nservice Greeter {\n  // Sends a greeting\n  rpc SayHello (HelloRequest) returns (HelloReply) {}\n}\n\n// The request message containing the user's name.\nmessage HelloRequest {\n  string name = 1;\n}\n\n// The response message containing the greetings\nmessage HelloReply {\n  string message = 1;\n}\n使用以下命令编译:\npython -m grpc_tools.protoc -I./ --python_out=. --grpc_python_out=. ./hello.proto\n生成了两个文件：\n\n\nhello_pb2.py 此文件包含生成的 request(HelloRequest) 和 response(HelloReply) 类。\n\nhello_pb2_grpc.py 此文件包含生成的 客户端(GreeterStub)和服务端(GreeterServicer)的类。\n\n源码地址为https://github.com/grpc/grpc/blob/master/examples/protos/helloworld.proto\n虽然现在已经生成了服务端和客户端代码，但是我们还需要手动实现以及调用的方法。\n创建服务端代码\n创建和运行 Greeter 服务可以分为两个部分：\n\n实现我们服务定义的生成的服务接口：做我们的服务的实际的“工作”的函数。\n运行一个 gRPC 服务器，监听来自客户端的请求并传输服务的响应。\n\n在当前目录，打开文件 greeter_server.py，实现一个新的函数：\nfrom concurrent import futures\nimport time\n\nimport grpc\n\nimport hello_pb2\nimport hello_pb2_grpc\n\n_ONE_DAY_IN_SECONDS = 60 * 60 * 24\n\n\nclass Greeter(hello_pb2_grpc.GreeterServicer):\n    # 工作函数\n    def SayHello(self, request, context):\n        return hello_pb2.HelloReply(message='Hello, %s!' % request.name)\n\n\ndef serve():\n    # gRPC 服务器\n    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))\n    hello_pb2_grpc.add_GreeterServicer_to_server(Greeter(), server)\n    server.add_insecure_port('[::]:50051')\n    server.start()  # start() 不会阻塞，如果运行时你的代码没有其它的事情可做，你可能需要循环等待。\n    try:\n        while True:\n            time.sleep(_ONE_DAY_IN_SECONDS)\n    except KeyboardInterrupt:\n        server.stop(0)\n\nif __name__ == '__main__':\n    serve()\n更新客户端代码\n在当前目录，打开文件 greeter_client.py，实现一个新的函数：\nfrom __future__ import print_function\n\nimport grpc\n\nimport hello_pb2\nimport hello_pb2_grpc\n\n\ndef run():\n    channel = grpc.insecure_channel('localhost:50051')\n    stub = hello_pb2_grpc.GreeterStub(channel)\n    response = stub.SayHello(hello_pb2.HelloRequest(name='goodspeed'))\n    print(\"Greeter client received: \" + response.message)\n\n\nif __name__ == '__main__':\n    run()\n对于返回单个应答的 RPC 方法（\"response-unary\" 方法），gRPC Python 同时支持同步（阻塞）和异步（非阻塞）的控制流语义。对于应答流式 RPC 方法，调用会立即返回一个应答值的迭代器。调用迭代器的 next() 方法会阻塞，直到从迭代器产生的应答变得可用。\n运行代码\n首先运行服务端代码\npython greeter_server.py\n然后运行客户端代码\npython greeter_client.py\n# output\n\nGreeter client received: Hello, goodspeed!\n源码地址: https://github.com/grpc/grpc/tree/master/examples/python\n参考链接\n\ngRPC 官方文档中文版\nProtobuf3语言指南\nGoogle Protocol Buffer 的使用和原理\ngRPC Python Quickstart\n\n\n最后，感谢女朋友支持和包容，比❤️\n也可以在公号输入以下关键字获取历史文章：公号&小程序 | 设计模式 | 并发&协程\n\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "2"}