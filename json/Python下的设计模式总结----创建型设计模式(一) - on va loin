{"title": "Python下的设计模式总结----创建型设计模式(一) - on va loin ", "index": "设计模式,python", "content": "最近在学习设计模式,而开发的语言中比较中意的就是python了,在这里总结下.\n设计模式一般分为三大类:构造型,结构型,行为型\n先从创建型设计模式开始,创建型设计模式包括:单例模式,抽象工厂模式,工厂方法模式,生成器模式,惰性初始化模式,对象池模式,原型模式.\n单例模式\n单例模式的定义是:保证一个类仅有一个实例,并提供一个它的全局访问点.先来看看14年前(没写错)的前辈介绍的单例模式例程\nfrom __future__ import print_function\n\n\nclass Borg:\n    __shared_state = {}\n\n    def __init__(self):\n        self.__dict__ = self.__shared_state\n        self.state = \"Init\"\n\n    def __str__(self):\n        return self.state\n\n\nclass YourBorg(Borg):\n    pass\n\n\nif __name__ == '__main__':\n    rm1 = Borg()\n    rm2 = Borg()\n\n    rm1.state = 'Idle'\n    rm2.state = \"Running\"\n\n    print('rm1:{0}'.format(rm1))\n    print('rm2:{0}'.format(rm2))\n\n    rm2.state = 'Zombie'\n\n    print('rm1:{0}'.format(rm1))\n    print('rm2:{0}'.format(rm2))\n\n    print('rm1 id:{0}'.format(id(rm1)))\n    print('rm2 id:{0}'.format(id(rm2)))\n\n    rm3 = YourBorg()\n\n    print('rm1:{0}'.format(rm1))\n    print('rm2:{0}'.format(rm2))\n    print('rm3:{0}'.format(rm3))\n\n\n# Output\n# rm1:Running\n# rm2:Running\n# rm1:Zombie\n# rm2:Zombie\n# rm1 id:140609170593696\n# rm2 id:140609170593624\n# rm1:Init\n# rm2:Init\n# rm3:Init\n简单解释下,需要get的点是下面这段代码\n    __shared_state = {}\n    \n    def __init__(self):\n        self.__dict__ = self.__shared_state\n        self.state = \"Init\"\nself.__dict__是对象的字典表示.将对象的属性设为全局静态变量.根据输出结果,rm1和rm2俨然是一个实例.然而打印出来的rm1,rm2的变量id是不一致的,所以rm1,rm2并不是同一个实例.但是却有同样的状态和行为.但从结果上来看,确实实现了单例模式的要求.(虽然有种走捷径的感觉)\n下面看看另一个版本的,其实就是换个形式,原理还是建多个实例,表现一致.其他部分的代码和上面的一致.\nclass Borg(object):\n    __state = {}\n\n    def __new__(cls, *p, **k):\n        self = object.__new__(cls, *p, **k)\n        self.__dict__ = cls.__state\n        return self\n\n    def __init__(self):\n        self.state = \"Init\"\n单例模式的创建有很多种方式.这里有讨论链接描述\n升级版,通过__metaclass__实现.这个版本中同一个id说明是同一个对象.\nclass Singleton(type):\n\n    def __init__(self, name, bases, dict):\n        super(Singleton, self).__init__(name, bases, dict)\n        self._instance = None\n\n    def __call__(self, *args, **kw):\n        if self._instance is None:\n            self._instance = super(Singleton, self).__call__(*args, **kw)\n        return self._instance\n\n\nclass MyClass(object):\n    __metaclass__ = Singleton\n\n\none = MyClass()\ntwo = MyClass()\n\ntwo.a = 3\nprint one.a\n# 3\nprint id(one)\n# 139798461922256\n\nprint id(two)\n# 139798461922256\n\nprint one == two\n# True\n\nprint one is two\n# True\n还可以通过装饰器来实现.这是第一个方法的高级版本,更pythonic,更elegant的方法.这个例子中,单例类本身不知道自己是单例的,应为他本身(自己的代码)就不是单例的.\ndef singleton(cls, *args, **kw):\n    instances = {}\n\n    def _singleton():\n        if cls not in instances:\n            instances[cls] = cls(*args, **kw)\n        return instances[cls]\n    return _singleton\n\n\n@singleton\nclass MyClass(object):\n    a = 1\n\n    def __init__(self, x=0):\n        self.x = x\n\n\none = MyClass()\ntwo = MyClass()\n\ntwo.a = 3\nprint one.a\n# 3\n\nprint id(one)\n# 140630714076048\n\nprint id(two)\n# 140630714076048\n\nprint one == two\n# True\n\nprint one is two\n# True\n\none.x = 1\n\nprint one.x\n# 1\n\nprint two.x\n# 1\n好东西留到最后,来个超级无敌版的\nclass Singleton:\n    \"\"\"\n    A non-thread-safe helper class to ease Implementing singletons.\n    This should be used as a decorator -- not a metaclass -- to the\n    class that should be singleton.\n\n    The decorated class can define one `__init__` function that\n    takes onelythe `self` argument. Other than that, there are no\n    restrictions that apply to the decorated class.\n\n    To get the singleton instances, use the `instances` method. Trying\n    to use `__call__` will result in a `TypeError` being raised.\n\n    Limitations: The decorated class cannot be inherited from.\n    \"\"\"\n\n    def __init__(self, decorated):\n        self._decorated = decorated\n\n    def instance(self):\n        \"\"\"\n        Return the singleton instance. Upon this first call, it creates\n        a new instance of decorated class and calls its `__init__` method.\n        On all subsequent calls, the already created instance is returned.\n        \"\"\"\n        try:\n            return self._instance\n        except AttributeError:\n            self._instance = self._decorated()\n            return self._instance\n\n    def __call__(self):\n        raise TypeError('Singletons must be accessed through `instance()`.')\n\n    def __instancecheck(self, inst):\n        return isinstance(inst, self._decorated)\n\n\n@Singleton\nclass Foo:\n    def __init__(self):\n        print \"Foo created\"\n\n\n# f = Foo()\n# TypeError: Singletons must be accessed through `instance()`.\n\nf = Foo.instance()\ng = Foo.instance()\n# Foo created\n\nprint f is g\n# True\n关于python的单例模式,各家说法不一.可以根据不同的需求,使用不同的方式,适合的才是最好的.\n参考文字:https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA)\nhttp://ginstrom.com/scribbles/2007/10/08/design-patterns-python-style/\nhttp://code.activestate.com/recipes/66531/\nhttp://blog.csdn.net/ghostfromheaven/article/details/7671853\nhttp://stackoverflow.com/questions/31875/is-there-a-simple-elegant-way-to-define-singletons-in-python/31887#31887\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "4"}