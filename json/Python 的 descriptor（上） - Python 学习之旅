{"title": "Python 的 descriptor（上） - Python 学习之旅 ", "index": "property,descriptor,python3.x,python", "content": "Python 在 2.2 版本中引入了descriptor（描述符）功能，也正是基于这个功能实现了新式类(new-styel class)的对象模型，同时解决了之前版本中经典类 (classic class) 系统中出现的多重继承中的 MRO(Method Resolution Order) 问题，另外还引入了一些新的概念，比如 classmethod, staticmethod, super, Property 等。因此理解 descriptor 有助于更好地了解 Python 的运行机制。\n那么什么是 descriptor 呢？\n简而言之：descriptor 就是一类实现了__get__(), __set__(), __delete__()方法的对象。\nOrz...如果你瞬间顿悟了，那么请收下我的膝盖；O_o!...如果似懂非懂,那么恭喜你！说明你潜力很大,咱们可以继续挖掘：\n引言\n对于陌生的事物，一个具体的栗子是最好的学习方式，首先来看这样一个问题：假设我们给一次数学考试创建一个类，用于记录每个学生的学号、数学成绩、以及提供一个用于判断是否通过考试的check 函数：\nclass MathScore():\n    \n    def __init__(self, std_id, score):\n        self.std_id = std_id\n        self.score = score\n\n    def check(self):\n        if self.score >= 60:\n            return 'pass'\n        else:\n            return 'failed'            \n\n很简单一个示例，看起来运行的不错：\nxiaoming = MathScore(10, 90)\n\nxiaoming.score\nOut[3]: 90\n\nxiaoming.std_id\nOut[4]: 10\n\nxiaoming.check()\nOut[5]: 'pass'\n但是会有一个问题，比如手一抖录入了一个负分数，那么他就得悲剧的挂了：\nxiaoming = MathScore(10, -90)\n\nxiaoming.score\nOut[8]: -90\n\nxiaoming.check()\nOut[9]: 'failed'\n这显然是一个严重的问题，怎么能让一个数学 90+ 的孩子挂科呢，于是乎一个简单粗暴的方法就诞生了：\nclass MathScore():\n    \n    def __init__(self, std_id, score):\n        self.std_id = std_id\n        if score < 0:\n            raise ValueError(\"Score can't be negative number!\")\n        self.score = score\n\n    def check(self):\n        if self.score >= 60:\n            return 'pass'\n        else:\n            return 'failed'                     \n\n上面再类的初始化函数中增加了负数判断，虽然不够优雅，甚至有点拙劣，但这在实例初始化时确实工作的不错：\nxiaoming = MathScore(10, -90)\n\nTraceback (most recent call last):\n\n  File \"<ipython-input-12-6faad631790d>\", line 1, in <module>\n    xiaoming = MathScore(10, -90)\n\n  File \"C:/Users/xu_zh/.spyder2-py3/temp.py\", line 14, in __init__\n    raise ValueError(\"Score can't be negative number!\")\n\nValueError: Score can't be negative number!\nOK, 但我们还无法阻止实例对 score 的赋值操作，毕竟修改成绩也是常有的事：\nxiaoming = MathScore(10, 90)\n\nxiaoming = -10    # 无法判断出错误\n对于大多数童鞋，这个问题 so easy 的啦：将 score 变为私有，从而禁止 xiaoming.score 这样的直接调用，增加一个 get_score 和 set_score 用于读写：\nclass MathScore():\n    \n    def __init__(self, std_id, score):\n        self.std_id = std_id\n        if score < 0:\n            raise ValueError(\"Score can't be negative number!\")\n        self.__score = score\n\n    def check(self):\n        if self.__score >= 60:\n            return 'pass'\n        else:\n            return 'failed'            \n        \n    def get_score(self):\n        return self.__score\n    \n    def set_score(self, value):\n        if value < 0:\n            raise ValueError(\"Score can't be negative number!\")\n        self.__score = value\n\n这确实是种常见的解决方法，但是不得不说这简直丑爆了：\n调用成绩再也不能使用 xiaoming.score 这样自然的方式，需要使用 xiaoming.get_score() ，这看起来像口吃在说话！还有那反人类的下划线和括号...那应该只出现在计算机之间窃窃私语之中...赋值也无法使用 xiaoming.score = 80， 而需使用  xiaoming.set_score(80)， 这对数学老师来说，太 TM 不自然了 !!!\n作为一门简洁优雅的编程语言，Python 是不会坐视不管的，于是其给出了 Property 类：\nProperty 类\n先不管 Property 是啥，咱先看看它是如何简洁优雅的解决上面这个问题的：\nclass MathScore():\n    \n    def __init__(self, std_id, score):\n        self.std_id = std_id\n        if score < 0:\n            raise ValueError(\"Score can't be negative number!\")\n        self.__score = score\n\n    def check(self):\n        if self.__score >= 60:\n            return 'pass'\n        else:\n            return 'failed'            \n        \n    def __get_score__(self):\n        return self.__score\n    \n    def __set_score__(self, value):\n        if value < 0:\n            raise ValueError(\"Score can't be negative number!\")\n        self.__score = value\n        \n    score = property(__get_score__, __set_score__)\n与上段代码相比，主要是在最后一句实例化了一个 property 实例，并取名为 score， 这个时候，我们就能如此自然的对 instance.__score 进行读写了：\nxiaoming = MathScore(10, 90)\n\nxiaoming.score\nOut[30]: 90\n\nxiaoming.score = 80\n\nxiaoming.score\nOut[32]: 80\n\nxiaoming.score = -90\nTraceback (most recent call last):\n\n  File \"<ipython-input-33-aed7397ed552>\", line 1, in <module>\n    xiaoming.score = -90\n\n  File \"C:/Users/xu_zh/.spyder2-py3/temp.py\", line 28, in __set_score__\n    raise ValueError(\"Score can't be negative number!\")\n\nValueError: Score can't be negative number!\nWOW~~一切工作正常！嗯，那么问题来了：它是怎么工作的呢？先看下 property 的参数：\nclass property(fget=None, fset=None, fdel=None, doc=None)  #拷贝自 Python 官方文档\n\n它的工作方式：\n\n实例化 property 实例（我知道这是句废话）；\n调用 property 实例（比如xiaoming.score）会直接调用 fget，并由 fget 返回相应值；\n对 property 实例进行赋值操作（xiaoming.score = 80）则会调用 fset，并由 fset 定义完成相应操作；\n删除 property 实例（del xiaoming），则会调用 fdel 实现该实例的删除；\ndoc 则是该 property 实例的字符说明；\nfget/fset/fdel/doc 需自定义，如果只设置了fget，则该实例为只读对象；\n\n这看起来和本篇开头所说的 descriptor 的功能非常相似，让我们回顾一下 descriptor：\n“descriptor 就是一类实现了__get__(), __set__(), __delete__()方法的对象。”\n@~@ 如果你这次又秒懂了，那么请再次收下我的膝盖 Orz...\n另外，Property 还有个装饰器语法糖 @property，其所实现的功能与 property() 完全一样：\nclass MathScore():\n    \n    def __init__(self, std_id, score):\n        self.std_id = std_id\n        if score < 0:\n            raise ValueError(\"Score can't be negative number!\")\n        self.__score = score\n\n    def check(self):\n        if self.__score >= 60:\n            return 'pass'\n        else:\n            return 'failed'            \n    \n    @property    \n    def score(self):\n        return self.__score\n    \n    @score.setter\n    def score(self, value):    #注意方法名称要与上面一致，否则会失效\n        if value < 0:\n            raise ValueError(\"Score can't be negative number!\")\n        self.__score = value\n我们知道了 property 实例的工作方式了，那么问题又来了：它是怎么实现的？事实上 Property 确实是基于 descriptor 而实现的，下面进入我们的正题 descriptor 吧！\ndescriptor 描述符\n照样先不管 descriptor 是啥，咱们还是先看栗子，对于上面 Property 实现的功能，我们可以通过自定义的 descriptor 来实现：\nclass NonNegative():\n    \n    def __init__(self):\n        pass\n\n    def __get__(self, ist, cls):\n        return 'descriptor get: ' + str(ist._MathScore__score)  #这里加上字符描述便于看清调用\n\n    def __set__(self, ist, value):\n        if value < 0:\n            raise ValueError(\"Score can't be negative number!\")\n        print('descriptor set:', value)\n        ist.__score = value\n        \nclass MathScore():\n    \n    score = NonNegative()    \n\n    def __init__(self, std_id, score):\n        self.std_id = std_id\n        if score < 0:\n            raise ValueError(\"Score can't be negative number!\")\n        self.__score = score\n        \n    def check(self):\n        if self.__score >= 60:\n            return 'pass'\n        else:\n            return 'failed'           \n\n我们新定义了一个 NonNegative 类，并在其内实现了__get__、__set__方法，然后在 MathScore 类中实例化了一个 NonNegative 的实例 score，注意！！！重要的事情说三遍：score 实例是 MathScore 的类属性！！！类属性！！！类属性！！！这个 Mathscore.score 属性同上面 Property 的 score 实例的功能是一样的，只不过 Mathscore.score 调用的 get、set 并不定义在 Mathscore 内，而是定义在 NonNegative 类中，而 NonNegative 类就是一个 descriptor 对象！\n纳尼？ NonNegative 类的定义中可没见到半个 “descriptor” 的字样，怎么就成了 descriptor 对象？？？\n淡定！ 重要的事情这里只说一遍：任何实现 __get__，__set__ 或 __delete__ 方法中一至多个的类，就是 descriptor 对象。所以 NonNegative 自然是一个 descriptor 对象。\n那么 descriptor 对象与普通类比有什么特别之处呢？ 先不急，来看看上端代码的效果：\nxiaoming = MathScore(10, 90)\n\nxiaoming.score\nOut[67]: 'descriptor get: 90'\n\nxiaoming.score = 80\ndescriptor set: 80\n\nwangerma = MathScore(11, 70)\n\nwangerma.score\nOut[70]: 'descriptor get: 70'\n\nwangerma.score = 60\nOut[70]: descriptor set: 60\n\nwangerma.score\nOut[73]: 'descriptor get: 60'\n\nxiaoming.score\nOut[74]: 'descriptor get: 80'\n\nxiaoming.score = -90\n\nValueError: Score can't be negative number!\n可以发现，MathScore.score 虽然是一个类属性，但它却可以通过实例的进行赋值，且面对不同的 MathScore 实例 xiaoming、wangerma 的赋值和调用，并不会产生冲突！因此看起来似乎更类似于 MathScore 的实例属性，但与实例属性不同的是它并不通过 MathScore 实例的读写方法操作值，而总是通过 NonNegative 实例的 __get__ 和 __set__ 对值进行操作，那么它是怎么做到这点的？\n注意看 __get__、__set__ 的参数\n def __get__(self, ist, cls):  #self：descriptor 实例本身（如 Math.score），ist：调用 score 的实例（如 xiaoming）,cls：descriptor 实例所在的类（如MathScore）\n        ...\n\n    def __set__(self, ist, value):  #score 就是通过这些传入的 ist 、cls 参数，实现对 MathScore 及其具体实例属性的调用和改写的\n        ...\nOK, 现在我们基本搞清了 descriptor 实例是如何实现对宿主类的实例属性进行模拟的。事实上 Property 实例的实现方式与上面的 NonNegative 实例类似。那么我们既然有了 Propery，为什么还要去自定义 descriptor 呢？\n答案在于：更加逼真的模拟实例属性（想想 MathScore.__init__里面那恶心的判断语句），还有最重要的是：代码重用！！！\n简而言之：通过单个 descriptor 对象，可以更加逼真的模拟实例属性，并且可以实现对宿主类实例的多个实例属性进行操作。\nO.O! 如果你又秒懂了，那么你可以直接跳到下面写评论了...\n看个栗子：假如不仅要判断学生的分数是否为负数，而且还要判学生的学号是否为负值，使用 property 的实现方式是这样子的：\nclass MathScore():\n    \n    def __init__(self, std_id, score):\n        if std_id < 0:\n            raise ValueError(\"Can't be negative number!\")\n        self.__std_id = std_id\n        if score < 0:\n            raise ValueError(\"Can't be negative number!\")\n        self.__score = score\n\n    def check(self):\n        if self.__score >= 60:\n            return 'pass'\n        else:\n            return 'failed'            \n    \n    @property    \n    def score(self):\n        return self.__score\n    \n    @score.setter\n    def score(self, value):\n        if value < 0:\n            raise ValueError(\"Can't be negative number!\")\n        self.__score = value\n    \n    @property\n    def std_id(self):\n        return self.__std_id\n\n    @std_id.setter\n    def std_id(self, idnum):\n        if idnum < 0:\n            raise ValueError(\"Can't be negative nmuber!\")\n        self.__std_id = idnum\nProperty 实例最大的问题是：\n\n无法影响宿主类实例的初始化，所以咱必须在__init__ 加上那丑恶的 if ...\n单个 Property 实例仅能针对宿主类实例的单个属性，如果需要对多个属性进行控制，则必须定义多个 Property 实例， 这真是太蛋疼了！\n\n但是自定义 descriptor 可以很好的解决这个问题，看下实现：\nclass NonNegative():\n    \n    def __init__(self):\n        self.dic = dict()\n\n    def __get__(self, ist, cls):\n        print('Description get', ist)\n        return self.dic[ist]\n\n    def __set__(self, ist, value):\n        print('Description set', ist, value)\n        if value < 0:\n            raise ValueError(\"Can't be negative number!\")\n        self.dic[ist] = value\n        \nclass MathScore():\n    \n    score = NonNegative()    \n    std_id = NonNegative()    \n    \n    def __init__(self, std_id, score):\n        #这里并未创建实例属性 std_id 和 score, 而是调用 MathScore.std_id 和 MathScore.score\n        \n        self.std_id = std_id\n        self.score = score  \n        \n    def check(self):\n        if self.score >= 60:\n            return 'pass'\n        else:\n            return 'failed'     \n\n哈哈~！ MathScore.__init__ 内终于没了 if ，代码也比上面的简洁不少，但是功能一个不少，且实例之间不会相互影响：\nzhangsan = MathScore(12, 50)\nDescription set <__main__.MathScore object at 0x0000022E47C46D68> 12\nDescription set <__main__.MathScore object at 0x0000022E47C46D68> 50\n\nlisi = MathScore(13, 90)\nDescription set <__main__.MathScore object at 0x0000022E47C46160> 13\nDescription set <__main__.MathScore object at 0x0000022E47C46160> 90\n\nwangerma = MathScore(-13, 70)\nDescription set <__main__.MathScore object at 0x0000022E47C46DD8> -13\n\n\nValueError: Can't be negative number!\n\n\nzhangsan.score\nDescription get <__main__.MathScore object at 0x0000022E47C46D68>\nOut[116]: 50\n\nzhangsan.score = 80\nDescription set <__main__.MathScore object at 0x0000022E47C46D68> 80\n\nlisi.score\nDescription get <__main__.MathScore object at 0x0000022E47C46160>\nOut[118]: 90\n事实上，MathScore 多个实例的同一个属性，都是通过单个 MathScore 类的相应类属性（也即 NonNegative 实例）操作的，这同 property 一致，但它又是怎么克服 Property 的两个不足的呢？秘诀有三个：\n\nProperty 实例本质上是借助类属性，变向对实例属性进行操作，而 NonNegative 实例则是完全通过类属性模拟实例属性，因此实例属性其实根本不存在；\nNonNegative 实例使用字典记录每个 MathScore 实例及其对应的属性值，其中 key 为 MathScore 实例名：比如 score 实例就是使用 dic = {‘Zhangsan’:50, ‘Lisi’:90} 记录每个实例对应的 score 值，从而确保可以实现对 MathScore 实例属性的模拟；\nMathScore 通过在__init__内直接调用类属性，从而实现对实例属性初始化赋值的模拟，而 Property 则不可能，因为 Property 实例（也即MathScore的类属性）是真实的操作 MathScore 实例传入的实例属性以达到目的，但如果在初始化程序中传入的不是实例属性，而是类属性（也即 Property 实例本身），则会陷入无限递归（PS：想一下如果将前一个property 实例实现中的self.__score 改成这里的 self.score 会发生什么）。\n\n这三点看的似懂非懂，没关系，来个比喻：\n每个 descriptor 实例（MathScore.score 和 MathScore.std_id）都是类作用域里的一个篮子，篮子里放着写着每个 MathScore 实例名字的盒子（‘zhangsan’，’lisi‘），同一个篮子里的盒子只记录同样属性的值（比如score篮子里的盒子只记录分数值），当 MathScore 的实例对相应属性进行操作时，则找到对应的篮子，取出标有该实例名字的盒子，并对其进行操作。\n因此，实例对应的属性，压根不在实例自己的作用域内，而是在类作用域的篮子里，只不过我们可以通过 xiaoming.score 这样的方式进行操作而已，所以其实际的调用的逻辑是这样的：下图右侧的实例分别通过红线和黑线对score和std_id 进行操作，他们首先通过类调用相应的类属性，然后类属性通过对应的 descriptor 实例作用域对操作进行处理，并返回给类属性相应结果，最后让实例感知到。\n\n看到这里，很多童鞋可能不淡定了，因为大家都知道在 Python 中采取 xiaoming.score = 10 这样的赋值方式，如果 xiaoming 没有 score 这样的实例属性，必定会自动创建该实例属性，怎么会去调用 MathScore 的 score 呢？\n首先，要鼓掌！！！ 给想到这点的童鞋点赞！！！其实上面在说 Property 的时候这个问题就产生了。\n其次，Python 为了实现 discriptor 确实对属性的调用顺序做出了相应的调整，这些将会“Python 的 descriptor（下）”中介绍。\n参考资料\n1、如何理解 Python 的 Descriptor？2、python中基于descriptor的一些概念（上） 3、python中基于descriptor的一些概念（下） 4、descriptor 的官方文档5、Python描述符（descriptor）解密6、class property 的官方文档\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "19"}