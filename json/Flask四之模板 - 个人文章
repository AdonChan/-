{"title": "Flask四之模板 - 个人文章 ", "index": "sqlite,centos,linux,django,python", "content": "四、模板\nFMTV\nF：form表单\nM：Model模型（数据库）\nT：Template模板\nV：view视图（路由）\n\n1、渲染模板\n模板是一个包含响应文本的文件，其中包含用占位变量表示的动态部分，其具体值\n只在请求的上下文中才能知道。 使用真实值替换变量，再返回最终得到的响应字符\n串，这一过程称为渲染。可以使用 render_template() 方法来渲染模板。你需要做\n的一切就是将模板名和你想作为关键字的参数传入模板的变量。\nFlask 会在 templates 文件夹里寻找模板。所以，如果你的应用是个模块，这个文\n件夹应该与模块同级；如果它是一个包，那么这个文件夹作为包的子目录:\n模板：\n/application.py\n/templates\n    /hello.html\n包：\n/application\n    /__init__.py\n    /templates\n        /hello.html\n\n 【hello.html】 \n<h1>Hello World!</h1>\n\n\nfrom flask import render_template\n@app.route('/hellotemplate/')\ndef hellotemplate():\n    return render_template('hello.html')\n 模板引擎 Flask使用了一个名为 Jinja2 的强大模板引擎\n\n{% ... %} Jinja语句，例如判断、循环语句\n{{ ... }} 变量，会显示在浏览器中\n{# ... #} 注释，不会输出到浏览器中\n\n2、变量规则\n在模板中使用的 {{ name }} 结构表示一个变量，它是一种特殊的占位符，告诉模板引擎这个位置的值从渲染模板时使用的数据中获取。 【helloname.html】 \n<h1>Hello, {{ name }}!</h1>\n\n@app.route('/hellotemplate/<name>')\ndef helloname(name):\n    return render_template('helloname.html',name = name)\n可以使用过滤器修改变量，过滤器名添加在变量名之后，中间使用竖线分隔。\n3、控制结构\n1、条件控制语句【if.html】\n{% if name %}\nhello, {{name}}\n{% else %}\nhello, world!\n{% endif %}\n2、 for 循环【for.html】\n<ol>\n    {% for a in range(10) %}\n    <li>a</li>\n    {% endfor %}\n</ol>\n\n@app.route('/for/')\ndef fortemplate():\n    return render_template('for.html')\n3、Jinja2 还支持宏（macro） 。宏类似于 Python 代码中的函数（def）。【macro.html】\n{% macro myprint(A) %}\nthis is {{ A }}\n{% endmacro %}\n\n{{ myprint(A) }}\n\n\n@app.route('/macro/<a>')\ndef macrotamplate(a):\n    return render_template('macro.html',A = a)\n为了重复使用宏，我们可以将其保存在单独的文件中，然后在需要使用的模板中导入：【macro2.html】\n{% from 'macro.html' import myprint %}\n{{ myprint(A) }}\n\n@app.route('/macro2/<a>')\ndef macro2template(a):\n    return render_template('macro2.html',A = a)\n4、包含（include）【include.html】\n{% include 'macro.html' %}\n\n\n@app.route('/include/<a>')\ndef includetemplate(a):\n    return render_template('include.html',A = a)\n 【注意】 包含进来的文件里的所有变量也包含进来了，需要在视图函数中指定\n4、模板继承\n首先，创建一个名为 base.html 的基模板：【base.html】\n<html>\n<head>\n    {% block head %}\n    <title>\n        {% block title %}\n        {% endblock %}\n        - My Application\n    </title>\n    {% endblock %}\n</head>\n\n<body>\n{% block body %}\n{% endblock %}\n</body>\n\n</html>\nblock 标签定义的元素可在衍生模板中修改。下面这个示例是基模板的衍生模板：【extend.html】\n% extends \"base.html\" %}\n{% block title %}Index{% endblock %}\n{% block head %}\n{{ super() }}\n<h1>super</h1>\n{% endblock %}\n{% block body %}\n<h1>Hello, World!</h1>\n{% endblock %}\nextends 指令声明这个模板衍生自 base.html。在 extends 指令之后，基模板中的\n3个块被重新定义，模板引擎会将其插入适当的位置。如果想添加内容到在父模板\n内已经定义的块，又不想失去父模板里的内容，可以使用super函数\n5、使用Flask-Bootstrap\nFlask-Bootstrap 使用 pip安装：\n(venv) $ pip install flask-bootstrap\nFlask 扩展一般都在创建程序实例后就初始化。初始化 Flask-Bootstrap 之后，就可以在程序中使用一个包含所有 Bootstrap 文件的基模板。【boootstrap.html】\n{% extends \"bootstrap/base.html\" %}\n\n{% block title %}Flasky{% endblock %}\n\n{% block navbar %}\n<div class=\"navbar navbar-inverse\" role=\"navigation\">\n    <div class=\"container\">\n        <div class=\"navbar-header\">\n            <button type=\"button\" class=\"navbar-toggle\"\n                    data-toggle=\"collapse\" data-target=\".navbar-collapse\">\n                <span class=\"sr-only\">Toggle navigation</span>\n                <span class=\"icon-bar\"></span>\n                <span class=\"icon-bar\"></span>\n                <span class=\"icon-bar\"></span>\n            </button>\n            <a class=\"navbar-brand\" href=\"/\">Flasky</a>\n        </div>\n        <div class=\"navbar-collapse collapse\">\n            <ul class=\"nav navbar-nav\">\n                <li><a href=\"/\">Home</a></li>\n            </ul>\n        </div>\n    </div>\n</div>\n{% endblock %}\n\n{% block content %}\n<div class=\"container\">\n    <div class=\"page-header\">\n        <h1>Hello, {{ name }}!</h1>\n    </div>\n</div>\n{% endblock %}\nJinja2 中的 extends 指令从 Flask-Bootstrap 中导入 bootstrap/base.html，从而\n实现模板继承。\n\nFlask-Bootstrap 中的基模板提供了一个网页框架，引入了 Bootstrap 中的所有 CSS \n和JavaScript 文件。基模板中定义了可在衍生模板中重定义的块。 block 和 endblock \n指令定义的块中的内容可添加到基模板中。\n上面这个 boootstrap.html 模板定义了 3 个块，分别名为 title、 navbar 和 content。\n这些块都是基模板提供的， 可在衍生模板中重新定义。 title 块的作用很明显，其中\n的内容会出现在渲染后的 HTML 文档头部，放在 <title> 标签中。 navbar 和 content \n这两个块分别表示页面中的导航条和主体内容。在这个模板中， navbar 块使用 Bootstrap \n组件定义了一个简单的导航条。content 块中有个<div> 容器，其中包含一个页面头部。\n之前版本的模板中的欢迎信息，现在就放在这个页面头部。\nfrom flask_bootstrap import Bootstrap\nbootstrap = Bootstrap(app)\n@app.route('/bootstrap/<name>')\ndef bootstraptemplate(name):\n    return render_template('boootstrap.html',name = name)\n 【注意】  很多块都是 Flask-Bootstrap 自用的，如果直接重定义可能会导致一些问题。例如， Bootstrap 所需的文件在 styles 和 scripts 块中声明。如果程序需要向已经有内容的块中添加新内容，必须使用Jinja2 提供的 super() 函数。例如，如果要在衍生模板中添加新的 JavaScript 文件，需要这么定义 scripts 块：\n{% block scripts %}\n{{ super() }}\n<script type=\"text/javascript\" src=\"my-script.js\"></script>\n{% endblock %}\n6、自定义错误页面\n【templates/404.html】\n<h1> Page is not Found </h1>\n@app.errorhandler(404)\ndef page_not_found(e):\n    return render_template('404.html'), 404\n【templates/base.html： 包含导航条的程序基模板】\n{% extends \"bootstrap/base.html\" %}\n\n{% block title %}Flasky{% endblock %}\n\n{% block head %}\n{{ super() }}\n<link rel=\"shortcut icon\" href=\"{{ url_for('static', filename='favicon.ico') }}\" type=\"image/x -icon\">\n<link rel=\"icon\" href=\"{{ url_for('static', filename='favicon.ico') }}\" type=\"image/x -icon\">\n{% endblock %}\n\n{% block navbar %}\n<div class=\"navbar navbar-inverse\" role=\"navigation\">\n    <div class=\"container\">\n        <div class=\"navbar-header\">\n            <button type=\"button\" class=\"navbar-toggle\" data-toggle=\"collapse\" data-target=\".navbar-collapse\">\n                <span class=\"sr-only\">Toggle navigation</span>\n                <span class=\"icon-bar\"></span>\n                <span class=\"icon-bar\"></span>\n                <span class=\"icon-bar\"></span>\n            </button>\n            <a class=\"navbar-brand\" href=\"/\">Flasky</a>\n        </div>\n        <div class=\"navbar-collapse collapse\">\n            <ul class=\"nav navbar-nav\">\n                <li><a href=\"/\">Home</a></li>\n            </ul>\n        </div>\n    </div>\n</div>\n{% endblock %}\n\n{% block content %}\n<div class=\"container\">\n{% block page_content %}{% endblock %}\n</div>\n{% endblock %}\n\n{% block scripts %}\n{{ super() }}\n{{ moment.include_moment() }}\n{% endblock %}\n这个模板的 content 块中只有一个 <div> 容器，其中包含了一个名为 page_content 的新的空块，块中的内容由衍生模板定义。\n【templates/404.html：使用模板继承机制自定义 404 错误页面】\n{% extends \"base.html\" %}\n{% block title %}Flasky - Page Not Found{% endblock %}\n{% block page_content %}\n<div class=\"page-header\">\n<h1>Not Found</h1>\n</div>\n{% endblock %}\ntemplates/boootstrap.html 现在可以通过继承这个基模板来简化内容：【 templates/boootstrap.html： 使用模板继承机制简化页面模板】\n{% extends \"base.html\" %}\n{% block title %}Flasky{% endblock %}\n{% block page_content %}\n<div class=\"page-header\">\n<h1>Hello, {{ name }}!</h1>\n</div>\n{% endblock %}\n7、静态文件\n默认设置下， Flask 在程序根目录中名为 static 的子目录中寻找静态文件。如果需要，可在static 文件夹中使用子文件夹存放文件。给静态文件生成 URL ，使用特殊的 'static' 端点名:【westeros.html】\n<img src = \"{{url_for('static',filename = 'westeros.jpg')}}\">\n@app.route('/westeros/')\ndef westeros():\n    return render_template('westeros.html')\n这个文件应该存储在文件系统上的 static/westeros.jpg 。\n8、使用Flask-Moment本地化日期和时间\nlask-Moment 是一个 Flask 程序扩展，能把moment.js 集成到 Jinja2 模板中。 Flask-Moment 可以使用 pip 安装：\n(venv) $ pip install flask-moment\n这个扩展的初始化方法和Bootstrap一样，以程序实例app为参数：\nfrom flask_moment import Moment\nmoment = Moment(app)\n除了 moment.js， Flask-Moment 还依赖 jquery.js。要在 HTML 文档的某个地方引入这两个库，可以直接引入，这样可以选择使用哪个版本，也可使用扩展提供的辅助函数，从内容分发网络（Content Delivery Network， CDN）中引入通过测试的版本。 Bootstrap 已经引入了 jquery.js， 因此只需引入 moment.js即可。【base.html中增加了】\n{% block scripts %}\n{{ super() }}\n{{ moment.include_moment() }}\n{% endblock %}\n【moment.html】\n{% extends \"base.html\" %}\n{% block page_content %}\n<div class=\"page-header\">\n<h1>Hello World!</h1>\n</div>\n<p>The local date and time is {{moment(current_time).format('LLL')}}.</p>\n<p>That was {{moment(current_time).fromNow(refresh = true)}}.</p>\n{% endblock %}\n把变量current_time 传入模板进行渲染\nfrom datetime import datetime\n@app.route('/moment/')\ndef momenttemplate():\nreturn render_template('moment.html',current_time = datetime.utcnow())\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "2"}