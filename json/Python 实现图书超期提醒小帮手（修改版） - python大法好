{"title": "Python 实现图书超期提醒小帮手（修改版） - python大法好 ", "index": "数据采集,python3.5,python2.7,python爬虫,python", "content": "一、实现目的\n本来就很喜欢逛图书馆，时不时去借本书（注：借的都没看过），但我这个学期突然发现了问题，每本书都可以借两个月，但不幸的是我最近一学期借的书全部超期，一天一毛钱，我心疼这钱啊！！！灵机一动，为什么不写个脚本来通知自己图书超期呢？说了这么多废话，我们就进入主题吧！！！\n二、模拟登录图书馆管理系统\n我们可以先看一下登录页面（很多学校这些管理系统页面就是很low）：\n\n两种方式去模拟登录图书馆：\n1. 构造登录表单进行模拟登录\n这种方式模拟登录似乎是很可靠的，但有时候就是在验证码获取上很困难，如果简单的网站，有的会利用当前时间戳来构造验证码，这种就很容易从网页上观察出来，但比如我们这次要模拟登录的网站似乎是不能这样做，因为它是使用JavaScript标准库里的Math函数直接随机生成的验证码链接，可以从下面图片上观察验证码处的代码：\n\n日了个狗，它使用Math.random()函数返回 [0-1) 的浮点值伪随机数（大于等于0，小于1），刚开始我以为python的math.random()函数生成的随机数和JavaScript的有区别，后来试了一下，呵呵，原来两个函数生成的随机数都是[0-1)而且都是16位小数点的。那样子我们就可以模拟登录了。首先，在模拟登录先，我们应该在浏览器上模拟登录一次，观察页面变化情况,刚开始时页面只有login.php页面的：\n然后我们输入验证码后再观察一下，页面立刻被转向redr_info.php,同时还有redr_verify.php页面出现\n然后看看我们的redr_info.php里面的东西，唉，怎么这个页面是GET请求呢？？那验证登录请求的POST页面在哪里去了呢？？带着疑问看看redr_verify.php,光是看这个页面的命名就觉得这是个验证登录的页面：果然，POST请求在这里，那我们就可以构造登录表单通过这个页面来模拟登录了。前期工作准备得差不多了，开始找这个redr_verify.php的post提交部分的内容了，我们从登录页面应该也可以知道我们需要提交学号、密码、验证码这三个。我们可以去redr_verify.php下看看我们POST表单提交的数据我们只需要填写前面四项就可以了，第四项是什么呢，我回到登录页面看了一下，就是下面图片的选择，然后贴代码吧\nimport subprocess\nimport sys\nimport os\n\nsession = requests.Session()\nsession.headers = {\n    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.82 Safari/537.36'\n}\n\n\ndef login(name, password):\n    random_num = random.random()  # 生成随机数，构造获取验证码的链接\n    url = 'http://210.38.102.131:86/reader/captcha.php?' + str(random_num)\n\n    get_captcha = session.get(url).content\n    with open('captcha.png', 'wb') as f:\n        f.write(get_captcha)\n        f.close()\n\n    '''\n        这段代码是为了方便我们打开图片，它可以直接打开图片\n        我们就不用去文件夹里去找,里面是判断使用什么系统，\n        不同系统打开方式有点差异，可以找python文档了解这部分内容\n    '''\n    if sys.platform.find('darwin') >= 0:\n        subprocess.call(['open', 'captcha.png'])\n    elif sys.platform.find('linux') >= 0:\n        subprocess.call(['xdg-open', 'captcha.png'])\n    else:\n        os.startfile('captcha.png')\n\n    input_captcha = input('请输入验证码：')\n    input_captcha = str(input_captcha)\n    \n    # 构造登录表单，里面就是我们上面提及的四项\n    post_data = {\n        'number': name,\n        'passwd': password,\n        'captcha': input_captcha,\n        'select': 'cert_no'\n    }\n\n    login_url = 'http://210.38.102.131:86/reader/redr_verify.php'\n    html = session.post(login_url, data=post_data).content\n\n    book_hist_url = 'http://210.38.102.131:86/reader/book_hist.php'\n    content = session.get(book_hist_url).content.decode('utf-8')\n    print(content)\n这就模拟登录成功了，好吧！我们换用一种比这个更简单的方式模拟登录吧！\n2. 通过Cookie登录图书馆\nCookie，指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密）。\n这里我们使用Requests库来进行模拟登录过程，在这之前我们还有个问题，怎么获取Cookie呢？？如果你使用的是谷歌浏览器，那你可以通过按F12就可以看到下图里面有个Cookie的内容，这就是你要的东西：\n\n再上个图分析一下，希望大家能有耐心读下去：\n\n通过图片我们知道可以获取借阅日期和应还日期，获取日期后根据应还日期和当前日期比较，就可以得出是否超期的结果。不多说，先贴代码再说：\nimport requests\nsession = requests.Session()    # 会话对象让你能够跨请求保持某些参数,它也会在同一个Session实例发出的所有请求之间保持cookie\nsession.headers = {\n    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.84 Safari/537.36',\n    'Cookie': 'ASP.NET_SessionId=1qri0rmoylpyrs45rurzme55; Hm_lvt_ed06d5e5f94d85932b82e4aac94d0c68=1467535679,1469713840; Hm_lpvt_ed06d5e5f94d85932b82e4aac94d0c68=1469713840; PHPSESSID=ev339udv0rrhqg6tfdvfukqos1'\n}\n上述代码使用了requests的会话对象来保存Cookie, 如果我们需要跳转到其它页面，我们不用每次都模拟登录，因为cookie已经保存了我们的登录状态。\n会不会有人疑问，不是要说模拟登录的吗？？怎么没有这过程呢？？\n其实我们上面代码中的Cookie已经保存了我们的登录状态，相当于我们已经模拟登录过了，这样子模拟登录是不是简单多了，但缺点是我们需要手动在登录页面输入一遍，然后再从登录页面找到cookie粘贴到代码中来\n三、获取所借书籍信息\n\n通过分析页面，我们可以使用BeautifulSoup来提取我们需要的内容，我们需要的是书籍的条形码、题名和作者、借阅日期、应还日期，其实我们只需要应还日期就行，但为了以后需要，先获取书籍的所有信息并保存进数据库里面：\n\n定义了一个数据库操作的函数，方便以后调用\ndef get_mysql():\n    conn = pymysql.connect(host = 'localhost', user = 'root', passwd = '2014081029', db = 'mysql', charset = 'utf8')    # user为数据库的名字，passwd为数据库的密码，一般把要把字符集定义为utf8，不然存入数据库容易遇到编码问题\n    cur = conn.cursor()    # 获取操作游标\n    cur.execute('use book')   # 使用book这个数据库\n    return (cur, conn)\n定义一个函数来获取图书信息并保存：\ndef get_book_name(book_url):\n    html = session.get(book_url, cookies = cookie, headers = headers).content.decode('utf-8')\n    soup = BeautifulSoup(html, 'lxml')\n    book_bar = []    # 书籍的条形码列表,用来判断要存入数据库的书籍是否已经存在\n\n    cur, conn = get_mysql()\n    sql = 'select * from book_list;'\n    cur.execute(sql)\n    rows = cur.fetchall()\n    for row in rows:\n        book_bar.append(row[1])\n\n    book_list = []    # 这个是我测试时使用的，作用是把每本书籍的信息列表放在这个列表中\n    book_every = []  # 一本书籍的所有信息列表\n    for book_time in soup.find_all('td', class_=\"whitetext\"):\n        print(book_time.get_text().strip())  # 移除字符串头尾指定的字符（默认为空格）\n        pattern = re.compile(r'\\s')\n        content = re.sub(pattern, r'', book_time.get_text())  # 目的也是匹配任何空白符并去除，貌似对空行去除没影响\n\n        if content != '':\n            book_every.append(content)\n            if len(book_every) == 7:\n                book_list.append(book_every)\n                if book_every[0] not in book_bar:\n                    sql = 'insert book_list(条形码, 题名和作者, 借阅日期, 应还日期, 续借量, 馆藏地, 附件) value(' + \"\\'\" \\\n                          + book_every[0] + \"\\',\" + \"\\'\" + book_every[1] + \"\\',\" + \"\\'\" + book_every[2] + \"\\',\" + \"\\'\" \\\n                          + book_every[3] + \"\\',\" + \"\\'\" + book_every[4] + \"\\',\" + \"\\'\" + book_every[5] + \"\\',\" + \"\\'\" \\\n                          + book_every[6] + \"\\'\" + ');'\n                try:\n\n                    cur.execute(sql)\n                    conn.commit()\n                except:\n                    conn.rollback()\n                book_every = []\n\n    print(book_list)\n接下来我们分析一下上面代码中没有注释的代码，首先我们先把处理后的信息加入book_every列表中，然后从页面源代码（tp9.png）中我们可以知道，一本书信息中只需要前面7项内容，因此我们使用一个判断语句：\nif len(book_every) == 7:\n    book_list.append(book_every)\n    if book_every[0] not in book_title:\n        sql = 'insert book_list(条形码, 题名和作者, 借阅日期, 应还日期, 续借量, 馆藏地, 附件) value(' + \"\\'\" \\\n                          + book_every[0] + \"\\',\" + \"\\'\" + book_every[1] + \"\\',\" + \"\\'\" + book_every[2] + \"\\',\" + \"\\'\" \\\n                          + book_every[3] + \"\\',\" + \"\\'\" + book_every[4] + \"\\',\" + \"\\'\" + book_every[5] + \"\\',\" + \"\\'\" \\\n                          + book_every[6] + \"\\'\" + ');'\n        try:\n            cur.execute(sql)\n            conn.commit()       \n        except:\n            conn.rollback()   # 如果存入数据库失败，执行回滚操作\n    book_every = []   \n也就是说，如果判断出book_every已经达到7项内容，就执行存入数据库的操作，然后在把book_every重置为空列表\n四、发送邮件提醒功能\n先贴上代码：\ndef send_message():\n    day_num = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    day_num1 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    sql = 'select * from book_list;'\n    cur, conn = get_mysql()\n    cur.execute(sql)\n    rows = cur.fetchall()\n    local_time = time.strftime(\"%Y-%m-%d\", time.localtime())  # 获取当前时间\n    local_time = str(local_time)\n    times = re.split(r'-', local_time)\n    year = times[0]\n\n    number = 0\n    while(True):\n        for i in rows:\n            print(i[4])\n            pattern = re.split(r'-', i[4])\n            if times[1] == pattern[1]:\n                day = int(times[2]) - int(pattern[2])\n                if day > 0:\n                    print('已经超期了%d天' % day)\n                    number += 1\n                    send_email(day, number, i[2])\n            elif times[1] > pattern[1]:\n                if (year % 4 == 0 and year % 100 != 0) or year % 400 == 0:\n                    extend_day = day_num1[int(pattern[1]) - 1] - int(pattern[2]) + times[2]\n                    print('已经超期了%d天' % extend_day)\n                    number += 1\n                    send_email(day, number, i[2])\n                else:\n                    extend_day = day_num[int(pattern[1]) - 1] - int(pattern[2]) + times[2]\n                    print('已经超期了%d天' % extend_day)\n                    number += 1\n                    send_email(day, number, i[2])\n\n            else:\n                print('还没有超期的书籍')\n\n            print(pattern[2])\n        time.sleep(3600 * 24)\n方案一\n我们来分析代码吧，首先我们判断是否超期是根据当前时间和应还日期的相加减得到的，所以我们考虑到：\n\n如果应还日期是上个月，这里我们就要进行月份的相加减，因为闰年和平年的月份不一样，所以我们定义了day_num和day_num1两个列表来表示闰年和平年的月份天数。\n然后我们使用月份当做判断条件来比较超期天数\n\n月份判断,如果当前月份等于应还月份，就执行下面操作，注意里面已经包含发送邮件函数，下面会贴出发送邮件函数，大家也许会想，为什么没有判断年份，因为我一般借书不会超期这么久，所以没有加上这个判断\n            if times[1] == pattern[1]:\n                day = int(times[2]) - int(pattern[2])\n                if day > 0:\n                    print('已经超期了%d天' % day)\n                    number += 1\n                    send_email(day, number, i[2])\n然后是当前月份大于应还月份时，这时候就有闰年和平年的判断了\n            elif times[1] > pattern[1]:\n                if (year % 4 == 0 and year % 100 != 0) or year % 400 == 0:\n                    extend_day = day_num1[int(pattern[1]) - 1] - int(pattern[2]) + times[2]\n                    print('已经超期了%d天' % extend_day)\n                    number += 1\n                    send_email(day, number, i[2])\n下面贴出发送邮件的代码：\ndef send_email(day, number, title):\n    from_addr = '15602200534@163.com'\n    password = '就不告诉你'\n    to_addr = '673411814@qq.com'\n    smtp_server = 'smtp.163.com'\n\n    text = 'Hello ,郭伟匡, 告诉你一个不好的消息,赶紧带上你的书,去图书馆交钱吧！你有一本叫《%s》的书籍超期了' \\\n           ',而且已经超期了%d天了,总共有%d书超期了！！！' % (title, day, number)\n    msg = MIMEText(text, 'plain', 'utf-8')\n    msg['From'] = format_addr('图书馆的通知<%s>' % from_addr)\n    msg['To'] = format_addr('管理员<%s>' % to_addr)\n    msg['Subject'] = Header('来着郭伟匡的问候......', 'utf-8').encode()\n\n    server = smtplib.SMTP(smtp_server, 25)\n    server.set_debuglevel(1)\n    server.login(from_addr, password)\n    server.sendmail(from_addr, [to_addr], msg.as_string())\n    server.quit()\n方案二\n其实我们还有一种最简单的判断相差日期的方法，那就是使用python提供的datetime模块，就利用方案一里面的东西来说吧\n    local_time = time.strftime(\"%Y-%m-%d\", time.localtime())  # 获取当前时间\n    local_time = str(local_time)\n    times = re.split(r'-', local_time)\n我们通过split分离出年月日后，就可以很简单得使用datetime进行日期相加减了，我们datetime相加减日期的用法如下：\n    d1 = datetime.datetime(2016, 4, 3)\n    d2 = datetime.datetime(2016, 6, 23)\n    print((d2 - d1).days)\n打印结果就是相差天数，这样在判断日期方面就变得十分简单了，所以方案二显然比方案一好得多了\n关于发送邮件的知识。。。我靠，0:22了，还没洗澡呢，下次有空再补上这部分知识，还是贴出廖雪峰网站关于这方面的知识吧 廖雪峰网站关于SMTP发送邮件。\n差点忘了把发送邮件的截图发出来：\n\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "17"}