{"title": "Web安全 - 预防前端渗透的编码技巧 - 互相帮助，相互学习 ", "index": "python,chrome,java,html,javascript", "content": "前端攻击主要包括XSS（跨站脚本攻击）、CSRF（跨站请求伪造）、SQL注入。“Noodles”的技术周刊 中有详细解释。\n一、XSS&SQL注入\n\n它们的发生是在用户恶意输入和抓包修改情况下，由于前后端没有做字符过滤，导致恶意代码的执行。\n1、XSS&SQL注入编码技巧\n前端的转义是必不可少的，为了防止抓包修改参数值，我们重点放在后端。网上有个XSSProject，地址为：http://yunjiechao-163-com.ite...，其中封装好了一些功能，特别方便。。。\n也可以用下面的代码：\n/**\n * \n * XSS过滤\n * @author Alex\n *\n */\npublic class XSSFilter implements Filter{\n\n    public void doFilter(ServletRequest arg0, ServletResponse arg1,\n            FilterChain arg2) throws IOException, ServletException {\n        // TODO Auto-generated method stub\n        HttpServletRequest request = (HttpServletRequest) arg0;\n        HttpServletResponse response = (HttpServletResponse) arg1;\n        XssAndSqlHttpServletRequestWrapper xssRequest = new XssAndSqlHttpServletRequestWrapper(request);//采用包装器过滤掉恶意字符\n        arg2.doFilter(xssRequest, response);          \n    }\n\n}\n/**\n * \n * XSS包装器\n * @author Alex\n *\n */\npublic class XssAndSqlHttpServletRequestWrapper extends HttpServletRequestWrapper {  \n   \n    private Logger log = Logger.getLogger(getClass());\n    private HttpServletRequest orgRequest = null;  \n      \n    public XssAndSqlHttpServletRequestWrapper(HttpServletRequest request) {  \n        super(request);  \n        orgRequest = request;  \n    }  \n  \n    @Override  \n    public String getParameter(String name) { \n        String value = null;\n        try {\n            //不过滤菜单\n            if(!name.equals(\"menuHtml\")){//自己的菜单，无视掉\n                value = super.getParameter(xssEncode(name));\n                if (value != null) {  \n                    value = URLDecoder.decode(value, Constant.UTF);//处理中文乱码\n                    value = xssEncode(value);  \n                }  \n            }else{\n                value = super.getParameter(name);\n            }\n        } catch (UnsupportedEncodingException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n            log.error(e.getMessage());\n        }\n        return value;  \n    }  \n  \n    @Override  \n    public String getHeader(String name) {//请求头也可能插入\n        String value = null;\n        try {\n            value = super.getHeader(xssEncode(name));  \n            if (value != null) {  \n                value = xssEncode(value);  \n            } \n        } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n            log.error(e.getMessage());\n        }\n        return value;  \n    }  \n  \n    private static String xssEncode(String s) {//替换成中文字符 \n        if (s == null || s.isEmpty()) {  \n            return s;  \n        }else{  \n            s = stripXSSAndSql(s);  \n        }  \n        StringBuilder sb = new StringBuilder(s.length() + 16);  \n        for (int i = 0; i < s.length(); i++) {  \n            char c = s.charAt(i);  \n            switch (c) {  \n            case '>':  \n                sb.append(\"＞\");// 转义大于号  \n                break;  \n            case '<':  \n                sb.append(\"＜\");// 转义小于号  \n                break;  \n            case '\\'':  \n                sb.append(\"＇\");// 转义单引号  \n                break;  \n            case '\\\"':  \n                sb.append(\"＂\");// 转义双引号  \n                break;  \n            case '&':  \n                sb.append(\"＆\");// 转义&  \n                break;  \n            case '#':  \n                sb.append(\"＃\");// 转义#  \n                break;  \n            default:  \n                sb.append(c);  \n                break;  \n            }  \n        }  \n        return sb.toString();  \n    }  \n  \n    public HttpServletRequest getOrgRequest() {  \n        return orgRequest;  \n    }  \n  \n    public static HttpServletRequest getOrgRequest(HttpServletRequest req) {  \n        if (req instanceof XssAndSqlHttpServletRequestWrapper) {  \n            return ((XssAndSqlHttpServletRequestWrapper) req).getOrgRequest();  \n        }  \n        return req;  \n    }  \n  \n    public static String stripXSSAndSql(String value) {  \n        if (value != null) {  \n            // Avoid anything between script tags  \n            Pattern scriptPattern = Pattern.compile(\"<[\\r\\n| | ]*script[\\r\\n| | ]*>(.*?)</[\\r\\n| | ]*script[\\r\\n| | ]*>\", Pattern.CASE_INSENSITIVE);  \n            value = scriptPattern.matcher(value).replaceAll(\"\");  \n            // Avoid anything in a src=\"http://www.yihaomen.com/article/java/...\" type of e-xpression  \n            scriptPattern = Pattern.compile(\"src[\\r\\n| | ]*=[\\r\\n| | ]*[\\\\\\\"|\\\\\\'](.*?)[\\\\\\\"|\\\\\\']\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL);  \n            value = scriptPattern.matcher(value).replaceAll(\"\");  \n            // Remove any lonesome </script> tag  \n            scriptPattern = Pattern.compile(\"</[\\r\\n| | ]*script[\\r\\n| | ]*>\", Pattern.CASE_INSENSITIVE);  \n            value = scriptPattern.matcher(value).replaceAll(\"\");  \n            // Remove any lonesome <script ...> tag  \n            scriptPattern = Pattern.compile(\"<[\\r\\n| | ]*script(.*?)>\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL);  \n            value = scriptPattern.matcher(value).replaceAll(\"\");  \n            // Avoid eval(...) expressions  \n            scriptPattern = Pattern.compile(\"eval\\\\((.*?)\\\\)\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL);  \n            value = scriptPattern.matcher(value).replaceAll(\"\");  \n            // Avoid e-xpression(...) expressions  \n            scriptPattern = Pattern.compile(\"e-xpression\\\\((.*?)\\\\)\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL);  \n            value = scriptPattern.matcher(value).replaceAll(\"\");  \n            // Avoid javascript:... expressions  \n            scriptPattern = Pattern.compile(\"javascript[\\r\\n| | ]*:[\\r\\n| | ]*\", Pattern.CASE_INSENSITIVE);  \n            value = scriptPattern.matcher(value).replaceAll(\"\");  \n            // Avoid vbscript:... expressions  \n            scriptPattern = Pattern.compile(\"vbscript[\\r\\n| | ]*:[\\r\\n| | ]*\", Pattern.CASE_INSENSITIVE);  \n            value = scriptPattern.matcher(value).replaceAll(\"\");  \n            // Avoid onload= expressions  \n            scriptPattern = Pattern.compile(\"onload(.*?)=\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL);  \n            value = scriptPattern.matcher(value).replaceAll(\"\");  \n        }  \n        return value;  \n    }  \n  \n} \nweb.xml中添加\n    <filter>\n        <filter-name>XSSFilter</filter-name>\n        <filter-class>com.xxx.filter.XSSFilter</filter-class>\n    </filter>\n    <filter-mapping>\n        <filter-name>XSSFilter</filter-name>\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\n2、举例\n用Python的flask框架演示，代码很简单，顺便演示下flask模板的注入\n服务端代码：\n#!/usr/bin/python\n# -*- coding: UTF-8 -*-\n\nfrom flask import Flask, request, render_template_string, render_template, make_response\n\napp = Flask(__name__)\n\n@app.route('/hello-injection')\ndef hello_inject():\n    person = {'name': 'asd', 'secret': 'aaaaaaaaaaa'}\n    if request.args.get('name'):\n        person['name'] = request.args.get('name')\n        template = '''<h2>Hello %s</h2>''' % person['name']\n    return render_template_string(template, person=person)\n\ndef get_user_file(f_name):\n    with open(f_name) as f:\n        return f.readlines()\napp.jinja_env.globals['get_user_file'] = get_user_file\n\nif __name__ == \"__main__\":\n    app.run(debug=True)\n运行好后，访问如下几个地址：\n（1）模板字符串中字符串拼接或替换引发的安全隐患\nhttp://127.0.0.1:5000/hello-injection?name=ForrestX386.{{person.secret}}，页面显示：Hello ForrestX386.aaaaaaaaaaa，秘钥aaaaaaaaaaa被泄漏。\nhttp://127.0.0.1:5000/hello-injection?name=ForrestX386.{{get_user_file('E:\\ssd.txt')}}，显示ssd.txt文件中的内容。\n原因：Jinja2在模板渲染的时候将person['name']的值替换掉{{person['name']}}, 而不会对person['name']内容进行二次渲染(这样即使`person['name']中含有{{}}也不会进行渲染，而只是把它当做普通字符串)。\n（2）render_template_string 的安全隐患\n我们知道Flask render_template函数在模板渲染（使用Jinja2模板引擎）的时候，会自动对模板（常见的模板后缀才进行自动HTML转码，比如.html,.htm等，不常见的模板后缀是不会进行HTML自动编码的，下面会介绍到）内容进行HTML实体编码，从而避免XSS漏洞的发生，但是Flask中的render_template_string 函数却不会对要渲染的模板字符串进行自动HTML实体编码，存在XSS安全隐患\nhttp://127.0.0.1:5000/hello-injection?name=ForrestX386.<script>alert(1)</script>，如果Chrome没有显示弹出，请设置：\n\n上图的设置会取消浏览器的xss-auditor启动（一种浏览器内建的xss防御模块，可阻止大多数反射型xss）。如果不想使用上图的方式启动，可以将服务端代码改为：\n@app.route('/hello-injection')\ndef hello_inject():\n    person = {'name': 'asd', 'secret': 'aaaaaaaaaaa'}\n    if request.args.get('name'):\n        person['name'] = request.args.get('name')\n        template = '''<h2>Hello %s</h2>''' % person['name']\n        response = make_response(person['name'])\n        response.headers['X-XSS-Protection'] = '0' # xss auditor关闭\n    return response\n将xss-auditor关闭可以弹出。如果开启呢？还能弹出吗？修改成以下代码：\n@app.route('/hello-injection')\ndef hello_inject():\n    person = {'name': 'asd', 'secret': 'aaaaaaaaaaa'}\n    if request.args.get('name'):\n        person['name'] = request.args.get('name')\n        template = '''<h2>Hello %s</h2>''' % person['name']\n        response = make_response(person['name'].replace('>', '>;'))\n        response.headers['X-XSS-Protection'] = '1' # xss auditor开启\n    return response\n竟然可以弹出。。。这里介绍下auditor的：\n通常情况下，我们都会对用户提交的数据进行一些处理，如果这些处理导致和提交的内容不一样了，但是仍然可以执行，比如像本例一样。那么xss auditor 就无能为力了。不过xss auditor本身的智能度也挺高，像字符编码，大小写变化这种变化依然躲不过xss auditor。\n二、CSRF\n\n1、Referer\n\n在过滤器或拦截器中判读请求头的Referer值，如果同域名就可以继续访问，否则请求被拦截。\nString referer = request.getHeader(\"Referer\");\nif(referer.startsWith(\"http://www.xxx.com\")){\n    chain.doFilter(request, response);\n}else{\n    return ;\n}\n弊端：有些网站或用户会停用Referer，所以上面这种方式会导致正常用户也不能访问系统。\n2、Token\n\n这种方式用的最多，是将Token作为每次请求的参数来验证请求是否有效。\n弊端：黑客可通过发送用户链接，盗取Token值。\n3、JWT\n\n为何用JWT？\n白话意思是用户的信息可放在客户端保存，代替之前服务器session的保存方式。为了契合前后分离的说法。所以请不要认为JWT可以预防CSRF，这是一种错误的理解！\n目前存储JWT的方式有以下几种：1、Cookie存取优点：不易遭受XSS（可设置HttpOnly）弊端：易遭受CSRF。2、LocalStorage优点：不产生CSRF、存储量大缺点：易遭受XSS、难清除（Android机很难清除）3、\nYOU stick the (JWT) token in the Authorization HTTP header of a request.\n这是http://stackoverflow.com/描述的一种方法。\n总结起来就是各有优缺点。个人觉得CSRF较难防御，看个人轻重程度了。\n下面是代码：\n其中有些是自己项目的逻辑，请需修改。\n/**\n * \n * @author Alex\n *\n */\npublic class JWTFilter implements Filter{\n    \n    private Logger log = Logger.getLogger(getClass());\n    \n    public void destroy() {\n        // TODO Auto-generated method stub\n        \n    }\n\n    public void doFilter(ServletRequest arg0, ServletResponse arg1,\n            FilterChain arg2) throws IOException, ServletException {\n        // TODO Auto-generated method stub\n        HttpServletRequest request = (HttpServletRequest) arg0;\n        HttpServletResponse response = (HttpServletResponse) arg1;\n        AttributePrincipal principal = (AttributePrincipal) request.getUserPrincipal();\n        try {\n            String jwt = null;\n            Cookie[] cookies = request.getCookies();\n            for(Cookie cookie:cookies){\n                if(cookie.getName().equals(\"jwt\")){\n                    jwt = cookie.getValue();\n                    break;\n                }\n            }\n            String referer = request.getHeader(\"Referer\");\n            String userName = (String) principal.getName();\n            if(referer!=null&&referer.indexOf(\"/XXX/login\")!=-1&&jwt==null){//登录时设置JWT及判断Cookie中有无JWT\n                jwt = JWTWrapper.createJWT(userName);//userName单点登录用户名\n                response.addHeader(\"Set-Cookie\", \"jwt=\"+jwt+\";Path=/;HttpOnly\");//防止JS获取Cookie\n            }else{\n                int judge = JWTWrapper.judgeJWT(jwt, userName);//判断JWT是否过期\n                if(judge==-1){//被篡改\n                    return ;\n                }else if(judge==0){//过期或将要过期\n                    String jwt_new = JWTWrapper.createJWT(userName);\n                    response.addHeader(\"Set-Cookie\", \"jwt=\"+jwt_new+\";Path=/;HttpOnly\");\n                }\n            }\n            arg2.doFilter(request, response);\n        } catch (Exception e) {\n            // TODO: handle exception\n            e.printStackTrace();\n            log.error(e.getMessage());\n        }\n    }\n\n    public void init(FilterConfig arg0) throws ServletException {\n        // TODO Auto-generated method stub\n        \n    }\n\n}\n/**\n * \n * JWT包装器\n * @author Alex\n *\n */\npublic class JWTWrapper {\n\n    private static String iss = \"XXX\";//签发者\n    private static Long exp_add = Long.valueOf(30*60*1000);//过期时间半小时\n    private static String des_key = \"XXXXXXX\";//des密钥\n    \n    /**\n     * 创建JWT\n     * @param aud    接收方\n     */\n    public static String createJWT(String aud){\n        String jwt = null;\n        try {\n            Long iat = System.currentTimeMillis();//签发时间，应该用秒\n            \n            String header = \"{\\\"typ\\\":\\\"JWT\\\",\\\"alg\\\":\\\"DES\\\"}\";//头部\n            String payload = \"{\\\"iss\\\":\\\"\"+iss+\"\\\",\\\"aud\\\":\\\"\"+aud+\"\\\",\\\"iat\\\":\"+iat+\",\\\"exp\\\":\"+(iat+exp_add)+\"}\";//载荷\n            String signature = null;//签名\n            \n            header = Base64.encodeBase64URLSafeString(header.getBytes(Constant.UTF));\n            payload = Base64.encodeBase64URLSafeString(payload.getBytes(Constant.UTF));\n            \n            signature = DesUtil.encrypt(header+\".\"+payload, des_key);//可用其它加密\n            \n            jwt = header+\".\"+payload+\".\"+signature;\n        } catch (Exception e) {\n            // TODO: handle exception\n            e.printStackTrace();\n            System.out.println(e.getMessage());\n        }\n        return jwt;\n    }\n    \n    /**\n     * 验证JWT\n     * @param jwt    \n     * @param aud    接收方\n     * @return\n     */\n    public static int judgeJWT(String jwt,String aud){\n        int judge = -1;//-1：篡改的JWT\n        try {\n            if(jwt!=null&&jwt.indexOf(\".\")!=-1){//分割JWT\n                String[] strs = jwt.split(\"\\\\.\");\n                String signature_new = strs[0]+\".\"+strs[1]+\".\"+DesUtil.encrypt(strs[0]+\".\"+strs[1], des_key);//签名\n                \n                if(signature_new.startsWith(jwt)){//未被篡改\n                    String payload = new String(Base64.decodeBase64(strs[1]), Constant.UTF);//载荷\n                    JSONObject JO = JSONObject.fromObject(payload);\n                    if(JO.getString(\"iss\").equals(iss)&&JO.getString(\"aud\").equals(aud)){\n                        Long exp = JO.getLong(\"exp\");\n                        \n                        Long iat = System.currentTimeMillis();//签发时间\n                        if(exp>iat&&(exp-iat)>1*60*1000){//过期时间>1分钟\n                            judge = 1;//正常，不需更新JWT\n                        }else{\n                            judge = 0;//JWT过期或将要过期\n                        }\n                    }\n                }\n            }\n        } catch (Exception e) {\n            // TODO: handle exception\n            e.printStackTrace();\n            System.out.println(e.getMessage());\n        }\n        return judge;\n    }\n    \n}\n\n先这样吧，不太会写文章，希望大家海涵。\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "9"}