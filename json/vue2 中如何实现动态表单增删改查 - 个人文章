{"title": "vue2 中如何实现动态表单增删改查 - 个人文章 ", "index": "python,javascript,vue.js", "content": "最近项目中遇到的需求是要操作大量的表单，之前的项目中有做过这方的研究，只不过是用jquery来操作。\n项目A\n先简单说说以前项目A中的应用场景，可能有小伙伴儿也遇到相同的需求。A项目是公司的OA系统中有的项目，是用java的jsp渲染的页面，需求是要改成：嵌入APP中显示，前后端分离， 后端返回的内容，还不能修改， 只是后端同事做了下接口处理，返回给前端的是一大堆的表单数据。\n每个表单都有多个字段表示它的属性：\n\n是否可编辑\n表单类型 （text, textarea, select, radio, checkbox, hidden等 ）\n与之联动的其他表单\n。。。之前的方案就是各个表单类型和字段属性进行判断，调用不同的UI组件(如时间日历选择器等)\n\n项目B\n现在遇到的项目，展示类型少很多，第一个想到的就是同样的方法，不过这次使用的是Vue的双向绑定。\n以下是我在python后端项目中的经验，如果没有兴趣可以直接看最后的动态表单部分\n1  python 后端项目中如何引入Vue\n项目B用的是python的jinjia2的模板， 同样都是 {{}} 去解析数据，这种情况下怎么办呢？\n{% raw %}\n<script type=\"text/x-template\" id=\"dialog-wrap\">\n<div class=\"ms-dialog-wrap\" v-show=\"visible\">\n  <div class=\"ms-dialog-inner\">\n    <div class=\"ms-dialog-title\">{{title}}</div>\n    <div class=\"ms-dialog-body\">\n      <div class=\"ms-dialog-content\">\n        <slot></slot>\n      </div>\n      <div class=\"ms-dialog-actions\">\n        <a class=\"ms-button\" @click=\"cancelAction\">取消</a>\n        <a class=\"ms-button ms-success\" @click=\"confirmSuccess\">确定</a>\n      </div>\n    </div>\n  </div>\n  <div class=\"ms-overlayer\" @click=\"cancelAction\"></div>\n</div>\n</script>\n{% endraw %}\njinjia2中使用  raw  可以阻止解析内部的代码，这样就可以引入我们的vue模板了，这里是我写的一个dialog弹框的组件2 定义组件这里以dialog弹窗组件为例子，直接上代码\n// dialog弹框\nVue.component('ms-dialog', {\n  name: 'ms-dialog',\n  template: '#dialog-wrap',\n  data: function () {\n    return {\n    }\n  },\n  props: {\n    title: String,\n    value: {\n      type: Boolean,\n      required: false\n    }\n  },\n  computed: {\n    visible: function () {\n      return this.value\n    }\n  },\n  watch: {\n    visible: function (newVal) {\n      if (newVal) {\n        document.addEventListener('wheel', this.disabledScroll, false)\n      } else {\n        document.removeEventListener('wheel', this.disabledScroll, false)\n      }\n    }\n  },\n  methods: {\n    confirmSuccess: function () {\n      this.$emit('confirm-success')\n    },\n    cancelAction: function () {\n      this.$emit('input', false)\n    },\n    disabledScroll: function (e) {\n      e.preventDefault()\n    }\n  },\n  beforeDestroy: function () {\n    document.removeEventListener('scroll', this.disabledScroll, false)\n  }\n})\n动态表单组件\n一般的需求是：\n\n一个列表，可以实现列表的动态添加，删除。\n列表中的每一项是动态的表单，表单个数不确定，\n有提交功能，提交或者可以保存整个表单\n保存的表单，通过接口调回后，回填表单，还可以再次修改、增加、删除等\n\n1 如何生成动态表单\n<template v-for=\"item in lists\">\n      <div class=\"list-item\" v-if=\"list.type === 'input'\">\n        <label>用户名</label>\n        <input type=\"text\" v-model=\"item.value\" :value=\"list.defaultValue\" class=\"form-control\">\n      </div>\n      <div class=\"list-item\" v-if=\"list.type === 'input'\">\n        <label>密码</label>\n        <input type=\"text\" v-model=\"item.value\" :value=\"list.defaultValue\" class=\"form-control\">\n      </div>\n      <div class=\"list-item\" v-if=\"list.type === 'textarea'\">\n        <label>说明</label>\n        <textarea rows=\"3\" v-model=\"item.value\" :value=\"list.defaultValue\" class=\"form-control\"></textarea>\n      </div>\n      <div class=\"list-item\" v-if=\"list.type === 'select'\">\n        <label>性别</label>\n        <select v-model=\"list.value\" :value=\"list.defaultValue\">\n            <option v-for=\"sub in list.source\" :value=\"sub.value\">{{sub.label}}</option>\n        </select>\n      </div>\n</template>\n我们的与后端商量好的数据格式可以是这样的；\nlists:  [{\n  type: 'input',\n  defaultValue: 'tom',\n  value: 'tom'\n}, {\n  type: 'input',\n  defaultValue: '123456',\n  value: '123456'\n}, {\n  type: 'textarea',\n  defaultValue: '123456',\n  value: '123456'\n}, {\n  type: 'select',\n  defaultValue: '0',\n  value: '0',\n  source: [{\n    value: '1',\n    label: '男'\n  }， {\n    value: '1,\n    label: '女'\n  }]\n}]\n这样一个动态模板就生成了，其他更多类型都可以定义。这份模板数据，一般是需要缓存的。因为接下来的 添加操作也需要这份数据。\n添加操作\n上面的template只是其中一个动态列表。\n<div v-for=\"book in books\">\n    <template v-for=\"item in book.lists\">\n      ......\n    </template>\n</div>\n<div class=\"actions\">\n<button @click=\"add\"></button>\n</div>\nadd的方法一般是：\nmethods: {\n add:  function () {\n   this.books.push({\n    lists:  [{\n      type: 'input',\n      defaultValue: 'tom',\n      value: 'tom'\n    }, {\n      type: 'input',\n      defaultValue: '123456',\n      value: '123456'\n    }, {\n      type: 'textarea',\n      defaultValue: '123456',\n      value: '123456'\n    }, {\n      type: 'select',\n      defaultValue: '0',\n      value: '0',\n      source: [{\n        value: '1',\n        label: '男'\n      }， {\n        value: '1,\n        label: '女'\n      }]\n    }]\n })\n },\n这里需要注意的是，如果这份模板的数据，你是通过在data属性中定义的字段去缓存的，那有可能遇到的是你通过添加操作之后的表单的值会，会随着其中的某个表单的值一起联动。具体原因，猜测是这里的数据已经是变成响应式的了， 又或者你 通过实例化后的值去缓存这份模板数据，可能结果还是这样。具体代码可能是这样的：\nvar vm = new Vue({\n    data: {\n        books: [],\n        cacheTemplate: null\n    },\n    methods: {\n        getForms: function (argument) {\n            this.$http.post(url, paras).then(res => {\n                // 此处缓存了这份模板数据，cacheTemplate中的数据已经变成响应式的了\n                this.cacheTemplate = res.body.data\n                this.books.push(res.body.data) // 创建第一动态表单列表\n\n                // 或者你是这是定义的的, 此时data中没有cacheTemplate这个值， \n                // 这样定义按理说是非响应式的，但实际情况并非如此，在项目中发现它还是会影响其他表单\n                vm.cacheTemplate = res.body.data\n                this.books.push(res.body.data) // 创建第一动态表单列表\n            }, res => {\n\n            })\n        },\n        add: function () {\n            // 此处你会发现你新创建的表单的值会影响其他表单\n            // log出来this.cacheTemplate你会发现里面的值已经发生了变换\n            this.books.push(this.cacheTemplate)\n        }\n    }\n})\n这里this.cacheTemplate的值为什么会发生变换，没有搞明白， 猜测原因可能是变成响应式了，vue中会实时监控跟踪，对vue原理理解好的小伙伴可以评论告诉我原因。下面说下我的解决方法:  我不管你是不是响应式的，因为是对象，你才能监控到变换，那我把你变成字符串不就好了。直接上代码：\nvar vm = new Vue({\n    data: {\n        books: [],\n        cacheTemplate: null\n    },\n    methods: {\n        getForms: function (argument) {\n            this.$http.post(url, paras).then(res => {\n                // 此处同样缓存了这份模板数据，不同的是把它变成了字符串\n                this.cacheTemplate = JOSN.stringify(res.body)\n                this.books.push(res.body) // 创建第一动态表单列表\n            }, res => {\n\n            })\n        },\n        add: function () {\n            // 此处转化成json对象，你发现this.cacheTemplate中的值是没有变换的。\n            var cacheTemplate = JSON.parse(this.cacheTemplate)\n            this.books.push(cacheTemplate)\n        }\n    }\n})\n这样其他表单值变换的时候都不会影响到我这份模板的数据，问题解决了。如果觉得本文不错的话，欢迎点赞。如有问题， 大家一起交流和学习\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "3"}