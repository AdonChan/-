{"title": "[零基础学python]编写类之四再论继承 - 易水禾 ", "index": "零基础,python", "content": "在上一讲代码的基础上，做进一步修改，成为了如下程序，请看官研习这个程序：\n\n#!/usr/bin/env python\n#coding:utf-8\n\nclass Person:\n    def __init__(self, name, email):\n        self.name = name\n        self.email = email\n\nclass Programmer(Person):\n    def __init__(self, name,email,lang, system, website):\n        Person.__init__(self,name,email)\n        self.lang = lang\n        self.system = system\n        self.website = website\n\nclass Pythoner(Programmer):\n    def __init__(self,name,email):\n        Programmer.__init__(self,name,email,\"python\",\"Ubuntu\",\"qiwsir.github.io\")\n\nif __name__==\"__main__\":\n    writer = Pythoner(\"qiwsir\",\"qiwsir@gmail.com\")\n    print \"name=\",writer.name\n    print \"lang=\",writer.lang\n    print \"email=\",writer.email\n    print \"system=\",writer.system\n    print \"website=\",writer.website\n\n#运行结果\n\nname= qiwsir\nlang= python\nemail= qiwsir@gmail.com\nsystem= Ubuntu\nwebsite= qiwsir.github.io\n\n\n对结果很满意，再看程序中的继承关系：Pythoner <-- Programmer <-- Person，从上面的过程中不难看出，继承能够减少代码重复，是的代码更简练。另外，在继承的时候，也可以在函数中对参数进行默认赋值。\n\n为了能够突出继承问题的探究，还是用那种简单的类来做实验。\n\n多余的B\n\n#!/usr/bin/env python\n#coding:utf-8\n\nclass A:\n    def __init__(self):\n        print \"aaa\"\n\nclass B(A):\n    pass\n\nif __name__==\"__main__\":\n    a = A()\n    b = B()\n\n#运行结果\n\naaa\naaa\n\n\nB继承A，没有任何修改地继承，B就可以不用写任何东西了，或者说B本质上就是一个多余。在真实的编程过程中，没有这样写的，这里仅仅是为了向看官展示一下继承的含义罢了。\n\n##首个继承有效\n\n#!/usr/bin/env python\n#coding:utf-8\n\nclass A:\n    def __init__(self):\n        print \"aaa\"\n\nclass B:\n    def __init__(self):\n        print \"bbb\"\n\nclass C1(A,B):\n    pass\n\nclass C2(B,A):\n    pass\n\nif __name__==\"__main__\":\n    print \"A--->\",\n    a = A()\n    print \"B--->\",\n    b = B()\n    print \"C1(A,B)--->\",\n    c1 = C1()\n    print \"C2(B,A)--->\",\n    c2 = C2()\n\n#运行结果\n\nA---> aaa\nB---> bbb\nC1(A,B)---> aaa\nC2(B,A)---> bbb\n\n\n列位看官是否注意了，类C1继承了两个类A，B；类C2也继承了两个类，只不过书写顺序有点区别(B,A)。从运行结果可以看出，当子类继承多个父类的时候，对于构造函数__init__()，只有第一个能够被继承，第二个就等掉了。所以，一般情况下，不会在程序中做关于构造函数的同时多个继承，不过可以接力继承，就如同前面那个比较真实的代码一样。\n\n其它方法的继承\n\n#!/usr/bin/env python\n#coding:utf-8\n\nclass A:\n    def __init__(self):\n        print \"aaa\"\n    def amethod(self):\n        print \"method a\"\n\nclass B(A):\n    def __init__(self):\n        print \"bbb\"\n\n\nif __name__==\"__main__\":\n    print \"A--->\"\n    a = A()\n    a.amethod()\n    print \"B--->\"\n    b = B()\n    b.amethod()\n\n#运行结果\n\nA--->\naaa\nmethod a\nB--->\nbbb\nmethod a\n\n\n为了说明白上面的情况，还是画了一张图，不过，我画完之后，就后悔了，看这张图好像更糊涂了。怎么着也画了，还是贴出来，如果能够协助理解更好了。\n\n\n\nA的实例和调用，就不多说了。重点看B，类B继承了A，同时，B在构造函数中自己做了规定，也就是B的构造函数是按照B的意愿执行，不执行A的内容，但是，A还有一个amethod(self)方法，B则继承了这个方法。当通过类B的实例调用这个方法的时候，就能够成功了：b.amethod()\n\n这就是方法的继承和调用方法。\n\n所谓继承，就是从下到上一级一级地找相应的继承对象，找到了就继承之。如果有同名的怎么办？按照什么顺序找呢？\n\n应用网上的一段：\n\n在Python中，可以進行多重繼承，這個時候要注意搜尋的順序，是從子類別開始，接著是同一階層父類別由左至右搜尋，再至更上層同一階層父類別由左至右搜尋，直到達到頂層為止。\n\n代码举例：\n\nclass A(object):\n    def method1(self):\n        print('A.method1')\n\n    def method2(self):\n        print('A.method2')\n\nclass B(A):\n    def method3(self):\n        print('B.method3')\n\nclass C(A):\n    def method2(self):\n        print('C.method2')\n\n    def method3(self):\n        print('C.method3')\n\nclass D(B, C):\n    def method4(self):\n        print('C.method4')\n\nd = D()\nd.method4() # 在 D 找到，C.method4\nd.method3() # 以 D->B 順序找到，B.method3\nd.method2() # 以 D->B->C 順序找到，C.method2\nd.method1() # 以 D->B->C->A 順序找到，A.method1\n\n\n务必请真正的学习者要对照每个类的每个方法，依次找到相应的输出结果。从而理解继承的顺序。学习，就要点滴积累。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "4"}