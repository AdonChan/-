{"title": "利用python进行识别相似图片（一） - 肥兔子de碎碎语 ", "index": "图像识别,图像检索,pillow,python", "content": "文章简介\n在网上看到python做图像识别的相关文章后，真心感觉python的功能实在太强大，因此将这些文章总结一下，建立一下自己的知识体系。当然了，图像识别这个话题作为计算机科学的一个分支，不可能就在本文简单几句就说清，所以本文只作基本算法的科普向。\n如有错误，请多包涵和多多指教。\n参考的文章和图片来源会在底部一一列出。\n以及本篇文章所用的代码都会在底下给出github地址。\n安装相关库\npython用作图像处理的相关库主要有openCV(C++编写，提供了python语言的接口)，PIL,但由于PIL很早就停了，所以不支持python3.x,所以建议使用基于PIL的pillow,本文也是在python3.4和pillow的环境下进行实验。\npillow下载地址PIL的下载地址openCV的官网\n至于opencv，在做人脸识别的时候会用到，但本文不会涉及到，在本专栏的后续中会谈及openCV的人脸识别和基于此的python图片爬虫，有兴趣的朋友可以关注本专栏。\n相关背景\n要识别两张相似图像，我们从感性上来谈是怎么样的一个过程？首先我们会区分这两张相片的类型，例如是风景照，还是人物照。风景照中，是沙漠还是海洋，人物照中，两个人是不是都是国字脸，还是瓜子脸（还是倒瓜子脸……哈哈……）。\n那么从机器的角度来说也是这样的，先识别图像的特征，然后再相比。\n很显然，在没有经过训练的计算机(即建立模型)，那么计算机很难区分什么是海洋，什么是沙漠。但是计算机很容易识别到图像的像素值。\n因此，在图像识别中，颜色特征是最为常用的。（其余常用的特征还有纹理特征、形状特征和空间关系特征等）\n其中又分为\n\n直方图\n颜色集\n颜色矩\n聚合向量\n相关图\n\n直方图计算法\n这里先用直方图进行简单讲述。\n先借用一下恋花蝶的图片，\n从肉眼来看，这两张图片大概也有八成是相似的了。\n在python中可以依靠Image对象的histogram()方法获取其直方图数据，但这个方法返回的结果是一个列表，如果想得到下图可视化数据，需要另外使用 matplotlib，这里因为主要介绍算法思路，matplotlib的使用这里不做介绍。\n\n是的，我们可以明显的发现，两张图片的直方图是近似重合的。所以利用直方图判断两张图片的是否相似的方法就是，计算其直方图的重合程度即可。\n计算方法如下：\n\n其中gi和si是分别指两条曲线的第i个点。\n最后计算得出的结果就是就是其相似程度。\n不过，这种方法有一个明显的弱点，就是他是按照颜色的全局分布来看的，无法描述颜色的局部分布和色彩所处的位置。\n也就是假如一张图片以蓝色为主，内容是一片蓝天，而另外一张图片也是蓝色为主，但是内容却是妹子穿了蓝色裙子，那么这个算法也很可能认为这两张图片的相似的。\n缓解这个弱点有一个方法就是利用Image的crop方法把图片等分，然后再分别计算其相似度，最后综合考虑。\n图像指纹与汉明距离\n在介绍下面其他判别相似度的方法前，先补充一些概念。第一个就是图像指纹\n图像指纹和人的指纹一样，是身份的象征，而图像指纹简单点来讲，就是将图像按照一定的哈希算法，经过运算后得出的一组二进制数字。\n说到这里，就可以顺带引出汉明距离的概念了。\n假如一组二进制数据为101，另外一组为111，那么显然把第一组的第二位数据0改成1就可以变成第二组数据111，所以两组数据的汉明距离就为1\n简单点说，汉明距离就是一组二进制数据变成另一组数据所需的步骤数，显然，这个数值可以衡量两张图片的差异，汉明距离越小，则代表相似度越高。汉明距离为0，即代表两张图片完全一样。\n如何计算得到汉明距离，请看下面三种哈希算法\n平均哈希法(aHash)\n此算法是基于比较灰度图每个像素与平均值来实现的\n一般步骤\n\n1.缩放图片，可利用Image对象的resize(size)改变，一般大小为8*8，64个像素值。\n\n2.转化为灰度图转灰度图的算法。\n\n1.浮点算法：Gray=Rx0.3+Gx0.59+Bx0.11\n2.整数方法：Gray=(Rx30+Gx59+Bx11)/100\n3.移位方法：Gray =(Rx76+Gx151+Bx28)>>8;\n4.平均值法：Gray=（R+G+B）/3;\n5.仅取绿色：Gray=G；\n\n\n\n在python中，可用Image的对象的方法convert('L')直接转换为灰度图\n\n3.计算平均值：计算进行灰度处理后图片的所有像素点的平均值。\n4.比较像素灰度值：遍历灰度图片每一个像素，如果大于平均值记录为1，否则为0.\n5.得到信息指纹：组合64个bit位，顺序随意保持一致性。\n\n最后比对两张图片的指纹，获得汉明距离即可。\n感知哈希算法(pHash)\n平均哈希算法过于严格，不够精确，更适合搜索缩略图，为了获得更精确的结果可以选择感知哈希算法，它采用的是DCT（离散余弦变换）来降低频率的方法\n一般步骤：\n\n缩小图片：32 * 32是一个较好的大小，这样方便DCT计算\n转化为灰度图：把缩放后的图片转化为256阶的灰度图。（具体算法见平均哈希算法步骤）\n计算DCT:DCT把图片分离成分率的集合\n缩小DCT：DCT计算后的矩阵是32 * 32，保留左上角的8 * 8，这些代表的图片的最低频率\n计算平均值：计算缩小DCT后的所有像素点的平均值。\n进一步减小DCT：大于平均值记录为1，反之记录为0.\n得到信息指纹：组合64个信息位，顺序随意保持一致性。\n\n最后比对两张图片的指纹，获得汉明距离即可。\n这里给出别人的DCT的介绍和计算方法(离散余弦变换的方法)\nDCT的维基百科luoweifu的博客\ndHash算法\n相比pHash，dHash的速度要快的多，相比aHash，dHash在效率几乎相同的情况下的效果要更好，它是基于渐变实现的。\n步骤：\n\n缩小图片：收缩到9*8的大小，以便它有72的像素点\n转化为灰度图：把缩放后的图片转化为256阶的灰度图。（具体算法见平均哈希算法步骤）\n计算差异值：dHash算法工作在相邻像素之间，这样每行9个像素之间产生了8个不同的差异，一共8行，则产生了64个差异值\n获得指纹：如果左边的像素比右边的更亮，则记录为1，否则为0.最后比对两张图片的指纹，获得汉明距离即可。\n\n总结\n这几种算法是识别相似图像的基础，显然，有时两图中的人相似比整体的颜色相似更重要，所以我们有时需要进行人脸识别，然后在脸部区进行局部哈希，或者进行其他的预处理再进行哈希，这里涉及其他知识本文不作介绍。\n下一次将讲述利用opencv和以训练好的模型来进行人脸识别。\n本文算法的实现在下面，点一下下面的连接就好\n我的github仓库\n各位亲，走过路过给一个star鼓励一下呗，当然也欢迎提意见。\n本文参考文章和图片来源\nwbj0110的文章赖勇浩的文章\n下一篇地址利用python进行识别相似图片（二）\n\n                ", "mainLikeNum": ["18 "], "mainBookmarkNum": "104"}