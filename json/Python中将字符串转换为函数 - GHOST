{"title": "Python中将字符串转换为函数 - GHOST ", "index": "python", "content": "这个问题的来源是在看python中的装饰器的时候，例子里给了这样一段代码：\n\n#-*- coding: UTF-8 -*- \nimport time    \ndef foo():\n    print 'in foo()'  \n# 定义一个计时器，传入一个，并返回另一个附加了计时功能的方法 \n\ndef timeit(func):\n    # 定义一个内嵌的包装函数，给传入的函数加上计时功能的包装\n    def wrapper():\n        start = time.clock()\n        func()\n        end =time.clock()\n        print 'used:', end - start\n\n    # 将包装后的函数返回\n    return wrapper   \nfoo = timeit(foo) \nfoo() \n\n\n上述代码实现了一个装饰器，但没有处理foo()函数带参数以及返回值的情况。为了改进这段代码，首先要理解的是python中参数传递*和**的问题。\n\n如果在函数定义时候，按照如下定义的：\n\n#代码段1\ndef foo(*a):\n    pass\n\n\n或者\n\n#代码段2\ndef foo(**a):\n    pass\n\n\n这种定义方法相当与C语言中的不定参数，在定义的时候，函数将被传入的参数是未知的，运行的时候，代码段1 的代码 参数将会一tuple的形式组织起来，传入函数; 代码段2 的代码，参数将会以dictionary的形式传入\n\n*和**除了在定义函数的时候有用，它的另一个功能就是对tuple和dict进行展开。\n\n于是我们便可以利用这个运算符对最开始的代码进行改进：\n\n#-*- coding: UTF-8 -*-\nimport time\ndef foo(a):\n    print ' in foo() %s'%a\n    return 100\n\ndef foo2():\n    print ' in foo2()'\n    return\n\n\n#定义定时器，传入一个，并返回另一个附加了计时功能的方法\n\ndef timeit(func):  \n    #定义一个内嵌的包装函数，给传入的函数加上计时的包装\n    def wrapper(*args,**args2):   ######1#########\n        start = time.clock()\n        res=func(*args,**args2)  #########2###########\n        end = time.clock()\n        print 'used:',end - start\n        return res\n\n    return wrapper\n\na=1\nfoo = timeit(foo)\nprint foo(a)\nfoo2 = timeit(foo2)\nfoo2()\n\n\n\n\n相比于原代码，主要更改是标号的两行。 第一行在函数定义的时候，参数里添加了一个不定参数，以便接受原函数的参数，第二行利用了*运算符的第二个功能，将参数展开，传递给原函数。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}