{"title": "peewee爬坑 - 个人文章 ", "index": "nginx,mongodb,virtualenv,svn,python", "content": "peewee update_time字段爬坑\nSQLalchemy中BaseModel定义:\n# -*- coding:utf-8 -*-\nfrom datetime import datetime\nfrom sqlalchemy import Column, DateTime\nclass BaseModel(object):\n    \"\"\"模型基类，为每个模型补充创建时间与更新时间\"\"\"\n\n    create_time = Column(DateTime, default=datetime.now)  # 记录的创建时间\n    update_time = Column(DateTime, default=datetime.now, onupdate=datetime.now)  # 记录的更新时间\n\npeewee中的BaseModel定义:\n# -*- coding: utf-8 -*-\nfrom datetime import datetime\nfrom peewee import Model, CharField\nimport peewee_async  # peewee_async异步操作MySQL\nfrom configs import config\n\n# 数据库连接池\ndb = peewee_async.PooledMySQLDatabase(\n    config.get('mysql_db'), host=config.get('mysql_host'), port=config.get('mysql_port'),\n    user=config.get('user'), password=config.get('pwd'),\n    min_connections=10,\n    max_connections=50\n\n)\n\n\nclass BaseModel(Model):\n    \"\"\"模型基类，为每个模型补充创建时间与更新时间\"\"\"\n    create_time = DateTimeField(default=datetime.now, verbose_name='创建时间')  # 记录的创建时间\n    update_time = DateTimeField(default=datetime.now, verbose_name='更新时间')  # 记录的更新时间\n\n    def save(self, *args, **kwargs):\n        \"\"\"覆写save方法, update_time字段自动更新, 实例对象需要在update成功之后调用save()\"\"\"\n        if self._get_pk_value() is None:\n            # this is a create operation, set the date_created field\n            self.create_time = datetime.now().strftime(\n                \"%Y-%m-%d %H:%M:%S\")\n        self.update_time = datetime.now().strftime(\n            \"%Y-%m-%d %H:%M:%S\")\n        return super(BaseModel, self).save(*args, **kwargs)\n\n很明显sqlalchemy定义的update_time字段的onupdate=datetime.now会在模型类的实例对象更新的时候自动更新该字段的值；而peewee的update_time字段并没有onupdate这个选项，从而无法实现自动的更新时间，故而在BaseModel中覆写了save方法，其他模型类继承BaseModel，那么子类的实例对象在update成功之后调用对象的save方法可以达到更新update_time字段值的目的。代码示例：\nclass User(BaseModel):\n    \"\"\"用户\"\"\"\n\n    # 1 基本信息\n    user_name= CharField(max_length=16, unique=True, null=False, verbose_name='用户名')\n    \n    class Meta:\n        database = db\n        db_table = 'user'\n\n在视图函数更新数据:\n# 更新\ntry:\n    async with db.atomic_async():\n        user.user_name= new_user_name\n        await self.application.manager.update(user, only=['user_name'])\nexcept Exception as err:\n    self.application.logger.error(err)\n    db.rollback()\nelse:\n    # update_time\n    user.save()  # 只有调用save() update_time字段的值才会在MySQL改变\nNOTE：项目使用的tornado5.1，使用了async+await语法；数据库迁移管理peewee-migrate，peewee文档：http://docs.peewee-orm.com/en...， peewee-async文档：https://peewee-async.readthed...\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}