{"title": "数据科学 第 3 章： 9 累计与分组 groupby - xiaomPythonlearning ", "index": "python", "content": "本节学习groupby \n引用激励数据，连接数据库jili表（代码省略）数字简单计算本节内容前面是运用sum/mean等函数对数字简单计算\njili.mean() #求均值\njili.mean(axis = 'columns') #求每行的均值\njili.sum()  #求和\ngroupby：切片计算\ngroupby的过程：分割：把dataframe按指定的键分为若干组应用：对每个组应用函数，通常为累计、转换或过滤组合：将每组1的结果合并成一个输出数组。\njili.groupby('dep')  #聚合后没有用函数，会返回一个dataframe\njili.groupby('dep').sum()   #用函数后会显示计算结果\n\n# 组合dep 之后，切片oldrate，查看group的和。这里是字符，所以显示了group的所有值\njili.groupby('dep')['group'].sum()\n\n#组合dep 之后，切片oldrate，查看oldrate的和\njili.groupby('dep')['oldrate'].sum()\n\n# 对每个可以计算的字段进行了描述性统计，中间有省略\n# unstack是上一节索引中的内容，是把多重索引转换为行，具体可以看下面没有用unstack的对比。\njili.groupby('dep').describe().unstack()\n\n#对groupby之后的结果，切片allbones字段，进行描述性统计\njili.groupby('dep')['allbones'].describe()\n\ngroupby：4 种计算方法\n1、aggregate：在groupby之后聚合的值上计算\n计算方法。如 sum，count，max，std\n2、filter：在原来的每个值上做计算，但是在groupby之后做计算\n切片 注意filter切片器中一定要有计算方法（summean之类的），否则会报错。\n# aggregate可以设定计算方法\njili.groupby('dep').aggregate(['min','max'])\n\n# filter对allbones列进行了切片，如果dep的allbones均值小于9000，则不显示. \n# 二部的均值低于9000，所以结果中没有二部数据。\njili.groupby('dep').filter(lambda x:x['allbones'].mean() >9000)\n\n3、transform：在原来的每个值上做计算，但是在groupby之后做计算\n转换，把原来的值换为计算后的值\njili.groupby('dep').transform(lambda x:x -x.mean()).head(3)  \n# x -x.mean()是减取本列的均值\n\ndef fun(x):\n    x['allbones'] = x['newbones']-x['oldbones']\n    return x\njili.groupby('dep').apply(fun)\n4、apply：\n把计算的结果运用到原数据（看下图）\n5、高级用法\n#组合为两层\njili.groupby(['dep','group']).mean()\n\n#组合为两层后，只选allbones的值，然后再转换行列\njili.groupby(['dep','group'])['allbones'].sum().unstack()\n\n以上就是groupby的用法，之前跟着视频学过，但看书的话更详细，下节是透视表，拜拜。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}