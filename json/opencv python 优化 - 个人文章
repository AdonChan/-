{"title": "opencv python 优化 - 个人文章 ", "index": "opencv-python,opencv,python", "content": "Performance Measurement and Improvement Techniques\n1使用OpenCV测量性能\ncv2.getTickCount：函数返回参考事件（如机器开启时刻）到调用此函数的时钟周期数. 因此，如果在函数执行之前和之后调用它，则会获得用于执行函数的时钟周期数.cv2.getTickFrequency:函数返回时钟周期的频率，或每秒钟的时钟周期数.\n如果要在几秒内找到执行时间：代码:\nimport cv2\n\ne1 = cv2.getTickCount()\n# your code execution\ne2 = cv2.getTickCount()\ntime = (e2 - e1)/ cv2.getTickFrequency()\nprint(time)\n\n输出：\n9.909108700445166e-06\n2 OpenCV中的默认优化\n许多OpenCV功能都使用SSE2，AVX等进行了优化，当然它也包含未经优化的代码。 因此，如果我们的系统支持这些功能，我们应该利用它们（几乎所有现代处理器都支持它们）.编译时默认启用它， 因此，OpenCV运行优化代码（如果已启用），否则运行未优化代码。 您可以使用cv2.useOptimized（）来检查它是否已启用/禁用，并使用cv2.setUseOptimized（）来启用/禁用它.\n代码：\n# check if optimization is enabled\ncv2.useOptimized()\n\n输出：True\n\n# Disable it\ncv2.setUseOptimized(False)\ncv2.useOptimized()\n\n输出：False\n性能优化技术\n有几种技术和编码方法可以利用Python和Numpy的最大性能。 此处仅注明相关的内容，并提供重要来源的链接。 这里要注意的主要是，首先尝试以简单的方式实现算法。 一旦工作，对其进行分析，找到瓶颈并进行优化。\n\n尽可能避免在Python中使用循环，尤其是双循环/三循环等。它们本身就很慢。\n尽可能最大程度地保存算法/代码，因为Numpy和OpenCV针对向量运算进行了优化。\nExploit缓存一致性。\n除非需要，否则不要复制数组。 尝试使用视图。 阵列复制是一项昂贵的操作。\n\n即使在完成所有这些操作之后，如果您的代码仍然很慢，或者使用大型循环是不可避免的，请使用其他库（如Cython）来加快速度。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}