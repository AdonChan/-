{"title": "[From Nand to Tetris] 第8章 虚拟机项目 python 实现 - Alan's Lab ", "index": "编译原理,操作系统,虚拟机,python", "content": "[From Nand to Tetris] 第8章 虚拟机项目 python 实现\n为防闲逛至此的看官不知所云： From Nand to Tetris 是一个在线课程，目标是指导学生从 Nand 逻辑门开始从头到尾完成一整套计算机系统。\n好像撸串一样的爽快：------芯片--硬件---编译原理---操作系统---应用程序------>\n这里提供的是第八章的作业，以供半路摔进坑里的同学们扶一下。。。\n人家老师确实是不希望扩散答案，不过我做的过程中遇到很多坑，搞半天后发现全是些脑残原因，实在是浪费时间，希望卡壳的同学们能以增进效率为目的适当参考答案。毕竟学习这种东西，有没有学到手只有自己知道。。。\n注释不多，因为代码相当 self-explanatory ，就是书上那些，没自由发挥什么。\n如果你是闲逛进来，而且对这块内容有兴趣的话，强烈建议点开上面的课程链接试试，我是真心非常喜欢这门课，请收下我的安利。。。\n另外还有第六章的作业答案：第6章 汇编器项目 python 实现\n# _*_ coding: utf-8 _*_\n\nimport sys\nimport os\nimport glob\n\n\nclass C_TYPE:\n    '''Command Type'''\n    C_ARITHMETIC, C_PUSH, C_POP, C_LABEL, C_GOTO, C_IF, C_FUNCTION, C_RETURN, C_CALL = range(9)\n\n\nclass Parser:\n\n    def __init__(self, fname):\n        self.finput = open(fname, 'rU')\n        self.current = None\n        self.commandPart = []\n        self.cType = -1\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.finput.close()\n\n    def has_more_commands(self):\n\n        self.current = self.finput.readline()\n\n        while self.current == '\\n' or self.current[:2] == '//':\n            self.current = self.finput.readline()\n\n        return self.current != ''\n\n    def advance(self):\n        self.commandPart = self.current.strip().split(' ')[:3]\n\n        if self.commandPart[0] == 'add' or\\\n                self.commandPart[0] == 'sub' or\\\n                self.commandPart[0] == 'neg' or\\\n                self.commandPart[0] == 'eq' or\\\n                self.commandPart[0] == 'gt' or\\\n                self.commandPart[0] == 'lt' or\\\n                self.commandPart[0] == 'and' or\\\n                self.commandPart[0] == 'or' or\\\n                self.commandPart[0] == 'not':\n            self.cType = C_TYPE.C_ARITHMETIC\n        elif self.commandPart[0] == 'push':\n            self.cType = C_TYPE.C_PUSH\n        elif self.commandPart[0] == 'pop':\n            self.cType = C_TYPE.C_POP\n        elif self.commandPart[0] == 'label':\n            self.cType = C_TYPE.C_LABEL\n        elif self.commandPart[0] == 'goto':\n            self.cType = C_TYPE.C_GOTO\n        elif self.commandPart[0] == 'if-goto':\n            self.cType = C_TYPE.C_IF\n        elif self.commandPart[0] == 'function':\n            self.cType = C_TYPE.C_FUNCTION\n        elif self.commandPart[0] == 'call':\n            self.cType = C_TYPE.C_CALL\n        elif self.commandPart[0] == 'return':\n            self.cType = C_TYPE.C_RETURN\n\n    def command_type(self):\n        return self.cType\n\n    def arg1(self):\n        if self.command_type() == C_TYPE.C_ARITHMETIC:\n            return self.commandPart[0]\n        return self.commandPart[1]\n\n    def arg2(self):\n        return self.commandPart[2]\n\n\nclass CodeWriter:\n\n    def __init__(self, fname):\n        self.foutput = open(fname, 'w')\n        self.uniqueFlag = 0  # 用于构造唯一的标签，每次使用后加1\n        self.currentFile = '' # 当前处理的文件的名字\n        self.currentFunc = '' # 当前处理的函数的名字\n\n    def set_file_name(self, fname):\n        self.currentFile = fname\n\n    def write_arithmetic(self, command):\n        if command == 'add':\n            self.foutput.write('@SP\\nM=M-1\\nA=M\\nD=M\\n@SP\\nM=M-1\\nA=M\\nM=M+D\\n@SP\\nM=M+1\\n')\n        elif command == 'sub':\n            self.foutput.write('@SP\\nM=M-1\\nA=M\\nD=M\\n@SP\\nM=M-1\\nA=M\\nM=M-D\\n@SP\\nM=M+1\\n')\n        elif command == 'neg':\n            self.foutput.write('@SP\\nM=M-1\\nA=M\\nM=-M\\n@SP\\nM=M+1\\n')\n        elif command == 'eq':\n            self.foutput.write('@SP\\nM=M-1\\nA=M\\nD=M\\n@SP\\nM=M-1\\nA=M\\nD=M-D\\n@RET_TRUE'+str(self.uniqueFlag)+'\\n'\n                               'D;JEQ\\nD=0\\n@END'+str(self.uniqueFlag)+'\\n0;JMP\\n(RET_TRUE'+str(self.uniqueFlag)+')\\n'\n                               'D=-1\\n(END'+str(self.uniqueFlag)+')\\n@SP\\nA=M\\nM=D\\n@SP\\nM=M+1\\n')\n            self.uniqueFlag += 1\n        elif command == 'gt':\n            self.foutput.write('@SP\\nM=M-1\\nA=M\\nD=M\\n@SP\\nM=M-1\\nA=M\\nD=M-D\\n@RET_TRUE'+str(self.uniqueFlag)+'\\n'\n                               'D;JGT\\nD=0\\n@END'+str(self.uniqueFlag)+'\\n0;JMP\\n(RET_TRUE'+str(self.uniqueFlag)+')\\n'\n                               'D=-1\\n(END'+str(self.uniqueFlag)+')\\n@SP\\nA=M\\nM=D\\n@SP\\nM=M+1\\n')\n            self.uniqueFlag += 1\n        elif command == 'lt':\n            self.foutput.write('@SP\\nM=M-1\\nA=M\\nD=M\\n@SP\\nM=M-1\\nA=M\\nD=M-D\\n@RET_TRUE'+str(self.uniqueFlag)+'\\n'\n                               'D;JLT\\nD=0\\n@END'+str(self.uniqueFlag)+'\\n0;JMP\\n(RET_TRUE'+str(self.uniqueFlag)+')\\n'\n                               'D=-1\\n(END'+str(self.uniqueFlag)+')\\n@SP\\nA=M\\nM=D\\n@SP\\nM=M+1\\n')\n            self.uniqueFlag += 1\n        elif command == 'and':\n            self.foutput.write('@SP\\nM=M-1\\nA=M\\nD=M\\n@SP\\nM=M-1\\nA=M\\nM=M&D\\n@SP\\nM=M+1\\n')\n        elif command == 'or':\n            self.foutput.write('@SP\\nM=M-1\\nA=M\\nD=M\\n@SP\\nM=M-1\\nA=M\\nM=M|D\\n@SP\\nM=M+1\\n')\n        elif command == 'not':\n            self.foutput.write('@SP\\nM=M-1\\nA=M\\nM=!M\\n@SP\\nM=M+1\\n')\n\n    def write_push_pop(self, command, segment, index):\n        if command == C_TYPE.C_PUSH:\n            if segment == 'constant':\n                self.foutput.write('@'+index+'\\nD=A\\n@SP\\nA=M\\nM=D\\n@SP\\nM=M+1\\n')\n            elif segment == 'local':\n                self.foutput.write('@LCL\\nD=M\\n@'+index+'\\nA=A+D\\nD=M\\n@SP\\nA=M\\nM=D\\n@SP\\nM=M+1\\n')\n            elif segment == 'argument':\n                self.foutput.write('@ARG\\nD=M\\n@'+index+'\\nA=A+D\\nD=M\\n@SP\\nA=M\\nM=D\\n@SP\\nM=M+1\\n')\n            elif segment == 'this':\n                self.foutput.write('@THIS\\nD=M\\n@'+index+'\\nA=A+D\\nD=M\\n@SP\\nA=M\\nM=D\\n@SP\\nM=M+1\\n')\n            elif segment == 'that':\n                self.foutput.write('@THAT\\nD=M\\n@'+index+'\\nA=A+D\\nD=M\\n@SP\\nA=M\\nM=D\\n@SP\\nM=M+1\\n')\n            elif segment == 'pointer':\n                self.foutput.write('@'+str(int(index)+3)+'\\nD=M\\n@SP\\nA=M\\nM=D\\n@SP\\nM=M+1\\n')\n            elif segment == 'temp':\n                self.foutput.write('@'+str(int(index)+5)+'\\nD=M\\n@SP\\nA=M\\nM=D\\n@SP\\nM=M+1\\n')\n            elif segment == 'static':\n                self.foutput.write('@'+self.currentFile+'.'+index+'\\nD=M\\n@SP\\nA=M\\nM=D\\n@SP\\nM=M+1\\n')\n        elif command == C_TYPE.C_POP:\n            if segment == 'local':\n                self.foutput.write('@LCL\\nD=M\\n@'+index+'\\nD=A+D\\n@R13\\nM=D\\n@SP\\nM=M-1\\nA=M\\nD=M\\n@R13\\nA=M\\nM=D\\n')\n            elif segment == 'argument':\n                self.foutput.write('@ARG\\nD=M\\n@'+index+'\\nD=A+D\\n@R13\\nM=D\\n@SP\\nM=M-1\\nA=M\\nD=M\\n@R13\\nA=M\\nM=D\\n')\n            elif segment == 'this':\n                self.foutput.write('@THIS\\nD=M\\n@'+index+'\\nD=A+D\\n@R13\\nM=D\\n@SP\\nM=M-1\\nA=M\\nD=M\\n@R13\\nA=M\\nM=D\\n')\n            elif segment == 'that':\n                self.foutput.write('@THAT\\nD=M\\n@'+index+'\\nD=A+D\\n@R13\\nM=D\\n@SP\\nM=M-1\\nA=M\\nD=M\\n@R13\\nA=M\\nM=D\\n')\n            elif segment == 'pointer':\n                self.foutput.write('@SP\\nM=M-1\\nA=M\\nD=M\\n@'+str(int(index)+3)+'\\nM=D\\n')\n            elif segment == 'temp':\n                self.foutput.write('@SP\\nM=M-1\\nA=M\\nD=M\\n@'+str(int(index)+5)+'\\nM=D\\n')\n            elif segment == 'static':\n                self.foutput.write('@SP\\nM=M-1\\nA=M\\nD=M\\n@'+self.currentFile+'.'+index+'\\nM=D\\n')\n\n    def write_label(self, label):\n        self.foutput.write('('+self.currentFunc+'$'+label+')\\n') # 构造 (funcName$label) 格式的标记，网站上没提，但书里有\n\n    def write_init(self):\n        self.foutput.write('@256\\nD=A\\n@SP\\nM=D\\n')\n        self.write_call('Sys.init', 0)\n\n    def write_goto(self, label):\n        self.foutput.write('@'+self.currentFunc+'$'+label+'\\n0;JMP\\n')\n\n    def write_if(self, label):\n        self.foutput.write('@SP\\nM=M-1\\nA=M\\nD=M\\n@'+self.currentFunc+'$'+label+'\\nD;JNE\\n')\n\n    def write_call(self, function_name, num_args):\n        self.foutput.write('@RETURN_ADDRESS'+str(self.uniqueFlag)+'\\nD=A\\n@SP\\nA=M\\nM=D\\n@SP\\nM=M+1\\n'\n                           '@LCL\\nD=M\\n@SP\\nA=M\\nM=D\\n@SP\\nM=M+1\\n'\n                           '@ARG\\nD=M\\n@SP\\nA=M\\nM=D\\n@SP\\nM=M+1\\n'\n                           '@THIS\\nD=M\\n@SP\\nA=M\\nM=D\\n@SP\\nM=M+1\\n'\n                           '@THAT\\nD=M\\n@SP\\nA=M\\nM=D\\n@SP\\nM=M+1\\n'\n                           '@SP\\nD=M\\n@'+str(int(num_args)+5)+'\\nD=D-A\\n@ARG\\nM=D\\n'\n                           '@SP\\nD=M\\n@LCL\\nM=D\\n'\n                           '@'+function_name+'\\n0;JMP\\n'\n                           '(RETURN_ADDRESS'+str(self.uniqueFlag)+')\\n')\n        self.uniqueFlag += 1\n\n    def write_return(self):\n        self.foutput.write('@LCL\\nD=M\\n@R13\\nM=D\\n'\n                           '@5\\nA=D-A\\nD=M\\n@R14\\nM=D\\n'\n                           '@SP\\nM=M-1\\nA=M\\nD=M\\n@ARG\\nA=M\\nM=D\\n'\n                           '@ARG\\nD=M+1\\n@SP\\nM=D\\n'\n                           '@R13\\nA=M-1\\nD=M\\n@THAT\\nM=D\\n'\n                           '@R13\\nA=M-1\\nA=A-1\\nD=M\\n@THIS\\nM=D\\n'  # 蠢萌蠢萌的减n次1，比下一句还省一条指令。。。\n                           '@R13\\nD=M\\n@3\\nA=D-A\\nD=M\\n@ARG\\nM=D\\n'\n                           '@R13\\nD=M\\n@4\\nA=D-A\\nD=M\\n@LCL\\nM=D\\n'\n                           '@R14\\nA=M\\n0;JMP\\n')\n\n    def write_function(self, function_name, num_locals):\n        self.currentFunc = function_name\n        commandsInitLocals = ''\n        for i in range(int(num_locals)):\n            commandsInitLocals += '@LCL\\nD=M\\n@'+str(i)+'\\nA=A+D\\nM=0\\n'\n        self.foutput.write('('+function_name+')\\n'+commandsInitLocals)\n\n    def close(self):\n        self.foutput.close()\n\n\ndef process_vm_file(fpath):\n    '''\n    处理一个 .vm 文件\n\n    fpath: 待处理 .vm 文件的绝对路径\n    '''\n    parser = Parser(fpath)\n    writer.set_file_name(os.path.basename(fpath.strip('.vm')))\n    while parser.has_more_commands():\n        parser.advance()\n        if parser.command_type() == C_TYPE.C_PUSH or parser.command_type() == C_TYPE.C_POP:\n            writer.write_push_pop(parser.command_type(), parser.arg1(), parser.arg2())\n        elif parser.command_type() == C_TYPE.C_ARITHMETIC:\n            writer.write_arithmetic(parser.arg1())\n        elif parser.command_type() == C_TYPE.C_LABEL:\n            writer.write_label(parser.arg1())\n        elif parser.command_type() == C_TYPE.C_GOTO:\n            writer.write_goto(parser.arg1())\n        elif parser.command_type() == C_TYPE.C_IF:\n            writer.write_if(parser.arg1())\n        elif parser.command_type() == C_TYPE.C_CALL:\n            writer.write_call(parser.arg1(), parser.arg2())\n        elif parser.command_type() == C_TYPE.C_FUNCTION:\n            writer.write_function(parser.arg1(), parser.arg2())\n        elif parser.command_type() == C_TYPE.C_RETURN:\n            writer.write_return()\n\n# main program\nif os.path.isfile(sys.argv[1]) and sys.argv[1].endswith('.vm'):  # 参数为 .vm 文件，只翻译一个文件\n    writer = CodeWriter(os.path.splitext(sys.argv[1])[0]+'.asm')\n    writer.write_init()\n    process_vm_file(sys.argv[1])\nelif os.path.isdir(sys.argv[1]): # 参数为文件夹，将文件夹中所有文件翻译为 hack 汇编\n    writer = CodeWriter(sys.argv[1]+'/'+os.path.basename(sys.argv[1])+'.asm')\n    writer.write_init()\n    for f in glob.glob(sys.argv[1] + '/*.vm'):\n        process_vm_file(f)\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "3"}