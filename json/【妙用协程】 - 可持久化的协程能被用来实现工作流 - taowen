{"title": "【妙用协程】 - 可持久化的协程能被用来实现工作流 - taowen ", "index": "workflow,coroutine,python", "content": "常规版本的Python的generator是不可以被持久化保存的。但是stackless和pypy这两个修改版本的Python解释器可以。下面这段代码演示了如何把一个执行中的函数持久化保存，然后过段时间再把函数从上次执行到的地方原样拉起。从效果上来说，有点类似于Vmware虚拟机的snapshot的功能：\n\nimport cPickle as pickle\n\ndef generator_can_be_used_as_workflow():\n    yield 'do something'\n    is_approved = yield 'ask boss for permission'\n    if is_approved:\n        yield 'do another after approved'\n    else:\n        yield 'do another after rejected'\n\nworkflow = generator_as_workflow_engine()\nprint(workflow.next())\nprint(workflow.next())\n# boss is not available now\npersisted_workflow = pickle.dumps(workflow)\nprint('persisted workflow is like this: [%s ...]' % persisted_workflow.replace('\\n', ' ')[:150])\n# several hours later, boss come back\nworkflow = pickle.loads(persisted_workflow)\nprint(workflow.send(True)) # I approve\n\n\n这段代码的输出是\n\ndo something\nask boss for permission\npersisted workflow is like this: [cstackless._wrap generator p1 (tRp2 (cstackless._wrap frame p3 (cstackless._wrap code p4 (I0 I1 I1 I99 S'd\\x01\\x00V\\x01d\\x02\\x00V}\\x00\\x00|\\x00\\x00r\\x ...]\ndo another after approved\n\n\n利用这个原理，我们可以把一个需要运行很长时间的流程用协程的方式来实现。在流程被阻塞的时候（比如需要审批老板不在）把协程持久化成string入库，等流程不再阻塞的时候把协程重新从数据库里拉起来继续执行。优点自然是轻量简单随意强大，缺点也是随意强大导致流程状态不可被外部直接解读和操作，也无法实现运行中的流程实例的代码升级。所以，这种工作流用在电子政务，或者办公自动化等强人机交互的领域（需要极高的灵活性）是不合适的。在运维的发布变更这样的场合下，主要是调度系统与系统，机器与机器这样比较固定且相对短暂的流程还是比较方便的。\n\nps：webwork使用的RIFE，是我所知最早的使用协程的流程引擎\n\n下面是一段演示用pypy的greenlet，控制流程前进和回退的例子：\n\nimport greenlet\nif '__main__' == __name__:\n    root = greenlet.getcurrent()\n\n    def g():\n        print('enter g')\n        mystack = 'special-g-stack'\n        greenlet.getcurrent().parent.switch()\n        print('leave g')\n\n    def f():\n        greenlet_g = greenlet.greenlet(g)\n        greenlet_g.switch()\n        root.switch()\n        print('a')\n        greenlet_g.switch()\n        root.switch()\n        print('b')\n        root.switch()\n        print('c')\n\n    f_greenlet = greenlet.greenlet(f)\n    f_greenlet.switch()\n    f_greenlet_v1 = pickle.dumps(f_greenlet)\n    print('is greenlet g also pickled? %s' % ('special-g-stack' in f_greenlet_v1))\n    f_greenlet = pickle.loads(f_greenlet_v1)\n    f_greenlet.switch()\n    f_greenlet_v2 = pickle.dumps(f_greenlet)\n    f_greenlet.switch()\n    f_greenlet_v3 = pickle.dumps(f_greenlet)\n    pickle.loads(f_greenlet_v1).switch()\n    pickle.loads(f_greenlet_v3).switch()\n\n\n输出是：\n\nenter g\nis greenlet g also pickled? True\na\nleave g\nb\na\nleave g\nc\n\n\n通过loads不同版本的流程状态，可以在各个阶段里来回切换。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "2"}