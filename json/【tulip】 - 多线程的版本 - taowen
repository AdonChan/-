{"title": "【tulip】 - 多线程的版本 - taowen ", "index": "multi-thread,python", "content": "上次的网络编程的例子，改写成多线程的是这样：\n\nimport socket\nimport thread\n\ndef main():\n    listen_sock = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM, proto=socket.IPPROTO_IP)\n    listen_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    listen_sock.bind(('0.0.0.0', 9090))\n    listen_sock.listen(0)\n    while True:\n        conn_sock, client_addr = listen_sock.accept()\n        thread.start_new(serve, (conn_sock, client_addr))\n\ndef serve(conn_sock, client_addr):\n    print('connected from %s:%s' % client_addr)\n    input = conn_sock.recv(8192)\n    while 'done' != input.strip():\n        conn_sock.sendall(input)\n        input = conn_sock.recv(8192)\n    conn_sock.sendall('bye!\\n')\n    conn_sock.close()\n\nmain()\n\n\n变成多线程之后，就可以有多个客户端同时连接到服务器并同时进行服务了。最重要的是每个线程，对应了一个“serve”函数的执行。所以函数执行就是有一个函数的栈，栈上有一个函数的参数和局部变量。最重要的一个局部变量就是conn_sock，有了这个socket就可以和对应的客户端进行对话。\n机器都有一个ESP的寄存器指向函数的栈顶所在的内存地址。一个cpu核只有一个ESP寄存器。有多个线程同时执行的时候，每个线程的状态是由操作系统内核负责保存在内存中的。当这个线程被调度为执行状态的时候，ESP寄存器被切换为当前线程的栈顶位置，然后继续执行这个线程的后面的指令。服务器可以支持多个客户端，就有两个关键的问题要解决：\n\n\n保存每个客户端的服务状态（最起码要保存对应这个客户端的socket）\n一个全局scheduler来负责I/O，在需要的时候把客户端对应的状态切换为“当前活跃”状态。在线程调用了阻塞的I/O操作时，操作系统内核就把线程给挂起了，同时在映射表里记录一个对应关系，哪个I/O阻塞的fd对应的是哪个线程在等待它。等I/O阻塞条件满足了，对应的线程就会被查表得到然后被唤醒。\n\n在多线程的实现中。每个客户端的状态就是保存在线程对应函数的栈上的，而全局的scheduler就是内核的线程scheduler。这种实现方式最大的缺点是线程的栈是创建时预先分配的很大的一块区域，大量线程会耗费过度内存。并且内核的线程scheduler在切换多个线程的时候，线程切换的开销是比较大。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}