{"title": "[零基础学Python]深入变量和引用对象 - 易水禾 ", "index": "python", "content": "今天是2014年8月4日，这段时间灾祸接连发生，显示不久前昆山的工厂爆炸，死伤不少，然后是云南地震，也有死伤。为所有在灾难中受伤害的人们献上祷告。\n\n在《永远强大的函数》那一讲中，老齐我（http://qiwsir.github.io）已经向看官们简述了一下变量，之后我们就一直在使用变量，每次使用变量，都要有一个操作，就是赋值。本讲再次提及这个两个事情，就是要让看官对变量和赋值有一个知其然和知其所以然的认识。当然，最后能不能达到此目的，主要看我是不是说的通俗易懂了。如果您没有明白，就说明我说的还不够好，可以联系我，我再为您效劳。\n\n变量和对象\n\n在《learning python》那本书里面，作者对变量、对象和引用的关系阐述的非常明了。我这里在很大程度上是受他的启发。感谢作者Mark Lutz先生的巨著。\n\n应用《learning python》中的一个观点：变量无类型，对象有类型\n\n在python中，如果要使用一个变量，不需要提前声明，只需要在用的时候，给这个变量赋值即可。这里特别强调，只要用一个变量，就要给这个变量赋值。\n\n所以，像这样是不行的。\n\n>>> x\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nNameError: name 'x' is not defined\n\n\n反复提醒：一定要注意看报错信息。如果光光地写一个变量，而没有赋值，那么python认为这个变量没有定义。赋值，不仅仅是给一个非空的值，也可以给一个空值，如下，都是允许的\n\n>>> x = 3\n>>> lst = []\n>>> word = \"\"\n>>> my_dict = {}\n\n\n在前面讲述中，我提出了一个类比，就是变量通过一根线，连着对象（具体就可能是一个int/list等），这个类比被很多人接受了，算是我老齐的首创呀。那么，如果要用一种严格的语言来描述，变量可以理解为一个系统表的元素，它拥有过指向对象的命名空间。太严肃了，不好理解，就理解我那个类比吧。变量就是存在系统中的一个东西，这个东西有一种能力，能够用一根线与某对象连接，它能够钓鱼。\n\n对象呢？展开想象。在机器的内存中，系统分配一个空间，这里面就放着所谓的对象，有时候放数字，有时候放字符串。如果放数字，就是int类型，如果放字符串，就是str类型。\n\n接下来的事情，就是前面说的变量用自己所拥有的能力，把对象和自己连接起来（指针连接对象空间），这就是引用。引用完成，就实现了赋值。\n\n\n\n看到上面的图了吧，从图中就比较鲜明的表示了变量和对象的关系。所以，严格地将，只有放在内存空间中的对象（也就是数据）才有类型，而变量是没有类型的。这么说如果还没有彻底明白，就再打一个比喻：变量就好比钓鱼的人，湖水里就好像内存，里面有好多鱼，有各种各样的鱼，它们就是对象。钓鱼的人（变量）的任务就是用某种方式（鱼儿引诱）把自己和鱼通过鱼线连接起来。那么，鱼是有类型的，有鲢鱼、鲫鱼、带鱼（带鱼也跑到湖水了了，难道是淡水带鱼？呵呵，就这么扯淡吧，别较真），钓鱼的人（变量）没有这种类型，他钓到不同类型的鱼。\n\n这个比喻太烂了。凑合着理解吧。看官有好的比喻，别忘记分享。\n\n同一个变量可以同时指向两个对象吗？绝对不能脚踩两只船。如果这样呢？\n\n>>> x = 4\n>>> x = 5\n>>> x\n5\n\n\n变量x先指向了对象4，然后指向对象5，当后者放生的时候，自动跟第一个对象4接触关系。再看x，引用的对象就是5了。那么4呢？一旦没有变量引用它了，它就变成了孤魂野鬼。python是很吝啬的，它绝对不允许在内存中存在孤魂野鬼。凡是这些东西都被看做垃圾，而对垃圾，python有一个自动的收回机制。\n\n在网上找了一个图示说明，很好，引用过来（来源：http://www.linuxidc.com/Linux/2012-09/69523.htm）\n\n>>> a = 100         #完成了变量a对内存空间中的对象100的引用\n\n\n如下图所示：\n\n\n\n然后，又操作了：\n\n>>> a = \"hello\"\n\n\n如下图所示：\n\n\n\n原来内存中的那个100就做为垃圾被收集了。而且，这个收集过程是python自动完成的，不用我们操心。\n\n那么，python是怎么进行垃圾收集的呢？在Quora上也有人问这个问题，我看那个回答很精彩，做个链接，有性趣的读一读吧。Python (programming language): How does garbage collection in Python work?\n\nis和==的效果\n\n以上过程的原理搞清楚了，下面就可以深入一步了。\n\n>>> l1 = [1,2,3]\n>>> l2 = l1 \n\n\n这个操作中，l1和l2两个变量，引用的是一个对象，都是[1,2,3]。何以见得？如果通过l1来修改[1,2,3]，l2引用对象也修改了，那么就证实这个观点了。\n\n>>> l1[0] = 99      #把对象变为[99,2,3]\n>>> l1              #变了\n[99, 2, 3]\n>>> l2　            #真的变了吔\n[99, 2, 3]\n\n\n再换一个方式：\n\n>>> l1 = [1,2,3]\n>>> l2 = [1,2,3]\n>>> l1[0] = 99\n>>> l1\n[99, 2, 3]\n>>> l2\n[1, 2, 3]\n\n\nl1和l2貌似指向了同样的一个对象[1,2,3]，其实，在内存中，这是两块东西，互不相关。只是在内容上一样。就好像是水里长的一样的两条鱼，两个人都钓到了，当不是同一条。所以，当通过l1修改引用对象的后，l2没有变化。\n\n进一步还能这么检验：\n\n>>> l1\n[1, 2, 3]\n>>> l2\n[1, 2, 3]\n>>> l1 == l2    #两个相等，是指内容一样\nTrue\n>>> l1 is l2    #is 是比较两个引用对象在内存中的地址是不是一样\nFalse　         #前面的检验已经说明，这是两个东东\n\n>>> l3 = l1　　 #顺便看看如果这样，l3和l1应用同一个对象\n>>> l3\n[1, 2, 3]\n>>> l3 == l1\nTrue\n>>> l3 is l1    #is的结果是True\nTrue\n\n\n某些对象，有copy函数，通过这个函数得到的对象，是一个新的还是引用到同一个对象呢？看官也可以做一下类似上面的实验，就晓得了。比如：\n\n>>> l1\n[1, 2, 3]\n>>> l2 = l1[:]\n>>> l2\n[1, 2, 3]\n>>> l1[0] = 22\n>>> l1\n[22, 2, 3]\n>>> l2\n[1, 2, 3]\n\n>>> adict = {\"name\":\"qiwsir\",\"web\":\"qiwsir.github.io\"}\n>>> bdict = adict.copy()\n>>> bdict\n{'web': 'qiwsir.github.io', 'name': 'qiwsir'}\n>>> adict[\"email\"] = \"qiwsir@gmail.com\"\n>>> adict\n{'web': 'qiwsir.github.io', 'name': 'qiwsir', 'email': 'qiwsir@gmail.com'}\n>>> bdict\n{'web': 'qiwsir.github.io', 'name': 'qiwsir'}\n\n\n不过，看官还有小心有点，python不总按照前面说的方式出牌，比如小数字的时候\n\n>>> x = 2\n>>> y = 2\n>>> x is y\nTrue\n>>> x = 200000\n>>> y = 200000\n>>> x is y      #什么道理呀，小数字的时候，就用缓存中的.\nFalse\n\n>>> x = 'hello'\n>>> y = 'hello'\n>>> x is y\nTrue\n>>> x = \"what is you name?\"\n>>> y = \"what is you name?\"\n>>> x is y      #不光小的数字，短的字符串也是\nFalse\n\n\n赋值是不是简单地就是等号呢？从上面得出来，=的作用就是让变量指针指向某个对象。不过，还可以再深入一些。走着瞧吧。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "3"}