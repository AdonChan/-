{"title": "Python学习之路14-生成数据 - VPointer ", "index": "python,matplotlib,数据可视化", "content": "《Python编程：从入门到实践》笔记。从本篇起将用三篇的篇幅介绍如何用Python进行数据可视化。\n1. 前言\n从本篇开始，我们将用三篇的篇幅来初步介绍如何使用Python来进行数据可视化操作。本篇的内容包括：\n\n绘制简单的折线图；\n随机漫步；\n使用Pygal模拟掷骰子。\n\n在正式开始之前，需要安装两个扩展包：matplotlib和pygal。Python中安装第三方库的方式已在上一个项目中介绍过了，这里不再赘述。\n2. 绘制简单的折线图\n2.1 简单的折线图\n首先我们绘制一个简单的折线图，代码保存到mpl_squares.py文件中：\nimport matplotlib.pyplot as plt\n\n# 输入数据, x轴\ninput_values = [1, 2, 3, 4, 5]\n# 输出数据, y轴\nsquares = [1, 4, 9, 16, 25]\n# linewidth表示线条的粗细\nplt.plot(input_values, squares, linewidth=5)\n\n# 设置图标标题，并给坐标轴加上标签\nplt.title(\"Square Numbers\", fontsize=24)\nplt.xlabel(\"Value\", fontsize=14)\nplt.ylabel(\"Square of Value\", fontsize=14)\n\n# 设置刻度标记的大小\nplt.tick_params(axis=\"both\", labelsize=14)\n\nplt.show()\nmatplotlib.pyplot.plot()函数可以只传入一个squares参数，表示y轴的值，此时将从x轴0点处开始一一对应。有时这样很简便，但在此例中图标将不正确，所以我们传入了input_values列表，将其与squares列表一一对应。\n代码从第10行到15行都可以省了，这些代码只是让图表的信息更全。最终的结果如下：\n\n2.2 生成散点图\n我们使用matplotlib.pyplot中的scatter()函数来生成散点图，将代码保存到scatter_squares.py文件中：\nimport matplotlib.pyplot as plt\n\nx_values = list(range(1, 1001))\ny_values = [x ** 2 for x in x_values]\n\n# s表示点的大小，edgecolor表示点的轮廓的颜色,c表示数据点的颜色(可以使用RGB颜色)\n# plt.scatter(x_values, y_values, s=4, edgecolor=\"none\", c=\"red\")\n\n# 使用渐变色, 给c赋值了一个y值列表，并使用参数cmap告诉pylot使用哪个颜色来映射\nplt.scatter(x_values, y_values, s=40, edgecolor=\"none\", c=y_values, cmap=plt.cm.Blues)\n\n# 设置图表标题并给坐标轴加上标签\nplt.title(\"Square Number\", fontsize=24)\nplt.xlabel(\"Value\", fontsize=14)\nplt.ylabel(\"Square of Value\", fontsize=14)\n\n# 设置刻度的大小\nplt.tick_params(axis=\"both\", which=\"major\", labelsize=14)\n\n# 每个坐标轴的取值范围\nplt.axis([0, 1100, 0, 1100000])\n\n# 第一个参数是路径名，第二个参数指定将图表多余的空白区域裁减掉。\nplt.savefig(\"squares.png\", bbox_inches=\"tight\")\n\nplt.show()\n我们使用了列表生成式来生成y轴的数据，并使用渐变色来绘制图像，matplotlib.pyplot.cm.Blues是matplotlib自带的渐变色，它和c的每一个值对应。通过pyplot的axis()函数来设置每个轴的取值范围。最后将图像保存到本地。生成的图像如下：\n\n3. 随机漫步\n随机漫步指的是：每次行走都完全随机，没有明确的方向，结果是由一系列随机决策决定的。在自然界、物理学、生物学、化学和经济领域，随机漫步都有其实际用途。\n使用Python生成随机漫步数据，再使用matplotlib将这些数据绘制出来。首先创建RandomWalk类，代码保存到random_walk.py文件中：\nfrom random import choice\n\nclass RandomWalk:\n    \"\"\"一个生成随机漫步数据的类\"\"\"\n\n    def __init__(self, num_points=5000):\n        \"\"\"初始化随机漫步的属性\"\"\"\n        self.num_points = num_points\n\n        # 所有随机漫步都始于(0, 0)，这两个列表用于存储随机漫步数据\n        self.x_values = [0]\n        self.y_values = [0]\n\n    def fill_walk(self):\n        \"\"\"计算随机漫步包含的所有点\"\"\"\n\n        # 不断漫步，直到列表到达指定的长度\n        while len(self.x_values) < self.num_points:\n            # 决定前进方向以及沿这个方向前进的距离\n            # 通过choice从给定值中随机选取\n            x_direction = choice([1, -1])  # 正向还是负向\n            x_distance = choice([0, 1, 2, 3, 4])  # 移动的距离\n            x_step = x_direction * x_distance\n\n            y_direction = choice([1, -1])\n            y_distance = choice([0, 1, 2, 3, 4])\n            y_step = y_direction * y_distance\n\n            # 拒绝原地踏步\n            if x_step == 0 and y_step == 0:\n                continue\n\n            # 计算下一个点的坐标\n            next_x = self.x_values[-1] + x_step\n            next_y = self.y_values[-1] + y_step\n\n            self.x_values.append(next_x)\n            self.y_values.append(next_y)\n下面的代码用于生成随机漫步图像，代码保存到rw_visual.py文件中：\nimport matplotlib.pyplot as plt\nfrom random_walk import RandomWalk\n\nwhile True:\n    rw = RandomWalk(50000)\n    rw.fill_walk()\n\n    # 设置绘图窗口的尺寸\n    plt.figure(figsize=(10, 6))\n\n    # 绘制随机漫步的图像\n    point_number = list(range(rw.num_points))\n    plt.scatter(rw.x_values, rw.y_values, s=1, c=point_number,\n                edgecolors=\"none\", cmap=plt.cm.Blues)\n\n    # 突出起点和终点\n    plt.scatter(0, 0, c=\"green\", edgecolors=\"none\", s=100)\n    plt.scatter(rw.x_values[-1], rw.y_values[-1], c=\"red\", edgecolors=\"none\",\n                s=100)\n\n    # 隐藏坐标轴\n    plt.axes().get_xaxis().set_visible(False)\n    plt.axes().get_yaxis().set_visible(False)\n\n    plt.show()\n\n    if input(\"Make another walk?(y/n)\") == \"n\":\n        break\n程序通过一个循环类多次绘制随机漫步图；通过pyplot的figure()函数来设置图像的尺寸，figsize的单位是英寸；通过渐变色来绘制图像的路径，颜色由浅到深，并且我们将起点（绿色）和终点（红色）显著标出；最后隐藏坐标轴。最终的图像如下（每次运行的效果都不同）：\n\n4. 使用Pygal模拟掷骰子\n首先我们需要创建一个骰子类Dice，将其保存到dice.py中：\nfrom random import randint\n\nclass Dice:\n    \"\"\"表示一个骰子类\"\"\"\n    def __init__(self, num_sides=6):\n        \"\"\"骰子默认为6面\"\"\"\n        self.num_sides = num_sides\n\n    def roll(self):\n        \"\"\"返回一个位于1和骰子面数之间的随机值\"\"\"\n        return randint(1, self.num_sides)\n可以自行设定骰子的面数。下面是掷两个骰子50000次，统计俩骰子点数之和的分布的模拟，最后生成了一个矢量文件.svg文件，它能在浏览器中打开，代码如下：\nimport pygal\nfrom dice import Dice\n\ndice_1 = Dice()\ndice_2 = Dice(10)\n\n# 掷骰子多次，并将结果存储在一个列表中\nresults = []\nfor roll_num in range(50000):\n    results.append(dice_1.roll() + dice_2.roll())\n\n# 分析结果\nfrequences = []\n# 能够模拟掷任何双骰子的情况，不管这些骰子有多少面\nmax_result = dice_1.num_sides + dice_2.num_sides\nfor value in range(2, max_result + 1):\n    # 统计每个结果的频数\n    frequences.append(results.count(value))\n\n# 对结果进行可视化\n# 创建条形图\nhist = pygal.Bar()\n\nhist.title = \"Result of rolling a D6 and a D10 50000 times.\"\n# 创建x轴上的刻度\nhist.x_labels = [str(value) for value in range(2, max_result + 1)]\nhist.x_title = \"Result\"\nhist.y_title = \"Frequency of Result\"\n\n# 给这组数据起个名字，并加到图表中\nhist.add(\"D6 + D10\", frequences)\n# 将图像渲染为svg文件，矢量图\nhist.render_to_file(\"dice_visual.svg\")\n注意，frequences中的数据依次与hist.x_labels对应。下面是最终结果：\n\nPygal让这个图表具有交互性：如果你将鼠标指向该图中的任何数据条，将看到它的具体数据。\n5. 小结\n本篇主要讲述了：\n\n如何生成数据集以及如何对其进行可视化；\n如何使用matplotlib创建简单的图表；\n如果使用散点图来探索随机漫步过程；\n如何使用Pygal创建直方图，以及如何使用直方图来探索同时掷两个面数不同的骰子的结果。\n\n\n迎大家关注我的微信公众号\"代码港\" & 个人网站 www.vpointer.net ~\n\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "2"}