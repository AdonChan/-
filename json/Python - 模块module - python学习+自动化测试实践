{"title": "Python - 模块module - python学习+自动化测试实践 ", "index": "python", "content": "\n一、什么是模块\nPython中，一个.py文件就称之为一个模块。那么使用模块有什么好处呢？\n（1）提高了代码的可维护性。（2）代码不必从零开始，当一个模块编写完毕后，就可以被其他地方应用。（3）可以避免函数名和变量名冲突，相同的函数名和变量可以存放在不同的模块中，但是要注意尽量不要与内置函数名字冲突。   Python所有的内置函数：https://docs.python.org/3/lib...\n\n为避免模块名冲突，python又引入了按目录来阻止模块冲突的方法，称为包(python package)。一个abc.py的文件就是一个名字为abc的模块，一个xyz.py的文件就是一个名字为xyz的模块。假如abc和xyz这两个模块名字与其他模块冲突了，于是我们可以通过不同的包来组织模块，避免模块冲突。则可为：\n↓ mycompany      # 按目录存放\n     _init_.py   # 模块名：mycompany\n     abc.py      # 模块名：mycompany.abc\n     xyz.py      # 模块名：mycompany.xyz\n引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。每一个包目录下都会有一个_init_.py的文件，这个文件是必须存在的，否则python就把这个目录当成普通目录，而不是一个包。_init_.py可以是空文件，也可以有python代码，因为_init_.py本身就是一个模块。\n二、使用Python自带模块\nPython内置了很多非常有用的模块，只要安装完毕，这些模块就可以通过import立刻导入使用。例如下列小程序：以自建的sys模块，编写一个hello的模块hello.py 。\n# !/usr/bin/env python    # -1-\n# -*-coding:utf-8 -*-     # -2- \n_author_ = 'xionglp'      # 使用_author_变量把作者写进去\n\nimport sys   \n\ndef test(): \n    args = sys.argv  \n    if len(args) == 1: \n        print ('hello,world!') \n    elif len(args) ==2: \n        print('hello,%s ！'% args[1]) \n    else: \n        print('too many arguments!') \nif __name__ == '__main__':\n    test()\n说明：\n\n注释 # -1- ：让该.py文件直接在unix/linux/mac上运行\n注释 # -2- ：.py文件使用标准UTF-8 编码\n\nimport sys：导入sys模块。之后便可以利用sys这个变量，访问sys模块的所有功能。sys模块有一个argv变量，用list存储了命令行的所有参数。argv至少有一个元素，因为第一个参数永远是该.py文件的名称。\n当在命令行运行hello.py文件时，python解释器就把一个特殊变量__name__置为__main__。如果在其他地方导入该模块时，if判断将失败，即if仅在此模块单独运行时生效。因此这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。\n\n在交互式环境（cmd）中导入该模块：\n>>> import hello                         \n>>> hello.test()                   \nhello, world! \n三、安装使用第三方模块\n除了Python自己的包，还可以安装安装第三方模块。第三方包安装是通过包管理工具pip完成的。一般来说，第三方库都会在Python官方的pypi.python.org网站注册。所以要安装一个第三方库，必须先知道该库的名称，可以在官网或者pypi上搜索。比如Pillow的名称叫Pillow，因此，安装Pillow的命令就是：pip install Pillow\n\n步骤1：找到安装Python路径中的easy_install.exe，例如：D:PythonScripts\n步骤2：打开cmd，输入安装命令：easy_install.exe pip （pip安装成功）\n步骤3：在cmd下执行pip，输入命令：pip install pillow \n\n\n如下：\n安装成功后便可以使用Pillow了。其他常用的第三方库还有：MySQL的驱动、用于科学计算的NumPy库等等。\npip升级：在使用pip进行安装时，有时候会提示pip的版本太低，需要upgrade。提示会给出要执行的语句，按照提示执行就行。执行命令：python –m pip install –upgrade pip\n四、模块搜索路径\n我们也可以导入自己写入的模块。当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错，例如：\n\n默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中：\n>>>import sys\n>>>sys.path\n如果我们要添加自己的搜索目录，有两种方法：\n法一：直接修改sys.path，添加要搜索的目录，这种方法是在运行时修改，运行结束后失效。\n>>> import sys\n>>> sys.path.append('/Users/xionglp/my_py_scripts')\n法二：设置环境变量PYTHONPATH，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响。\n\n【补充点能量】if __name__ ==\"__main__\":\n\n\n__name__：为系统变量，有两个取值。当模块是被调用执行时，取值为模块的名字；当模块是直接执行时，则该变量取值为__name__。\n\nif __name__ == \"__main__\"实现的功能：可以让模块既可以导入到别的模块中用，也可以自己执行。\n\n英文解释说：make a script both importable and executeable\n\n例如：新建模块atest.py\n# !/usr/bin/env python3\n# -*- coding:utf-8 -*-\n'a test module'\ndef addFunc(a, b):\n    return a + b\nprint('a_test_module\\'s result is ', addFunc(1, 1))\n新建模块anothertest.py\n# !/usr/bin/env python3\n# -*- coding :utf-8 -*-\n'another test module'\nimport  atest\nprint('调用another test module模块执行的结果时：',atest.addFunc(12,23))\n运行：\nD:\\Python_project>python atest.py\na_test_module's result is  2\nD:\\Python_project>python anothertest.py\na_test_module's result is  2\n调用another test module模块执行的结果时： 35\n说明：当运行anothertest.py的时候，先运行了atest.py，再运行anothertest.py。若不希望出现atest的内容，python提供了一个系统变量：__name__。可以把被调用的测试代码写在if语句里，当调用该module时，此时的__name__取值为该模块的名字，所以if判断为假，不执行后续代码如下：\nif __name__ == '__main__':`\n       print ('atest的计算结果：',addFunc(1,1))\n则运行结果为：\nD:\\Python_project>python anothertest.py\n调用another test module模块执行的结果时： 35\n此时我们就得到了预期结果，不输出多余的结果。\n\n❤ thanks for watching, keep on updating...\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}