{"title": "python开发第三篇--文件的基本操作和初识函数 - python学习 ", "index": "python", "content": "文件的基本操作\n编码\n1.不同编码之间的二进制是不能互相识别的。2.对于文件的存储，及传输 不能是unicode的编码。\nbytes:内部编码格式（非unicode）\nstr：内部编码格式（unicode）\n文件的基本操作流程\n\n计算机系统分为：计算机硬件，操作系统，应用程序三部分。\n我们用python或其他语言编写的应用程序若想要把数据永久保存下来，必须要保存于硬盘中，这就涉及到应用程序要操作硬件，众所周知，应用程序是无法直接操作硬件的，这就用到了操作系统。操作系统把复杂的硬件操作封装成简单的接口给用户/应用程序使用，其中文件就是操作系统提供给应用程序来操作硬盘虚拟概念，用户或应用程序通过操作文件，可以将自己的数据永久保存下来。\n有了文件的概念，我们无需再去考虑操作硬盘的细节，只需要关注操作文件的流程：\n\n#1. 打开文件，得到文件句柄并赋值给一个变量\nf=open('a.txt','r',encoding='utf-8') #默认打开模式就为r\n#2. 通过句柄对文件进行操作\ndata=f.read()\n#3. 关闭文件\nf.close()\n打开一个文件包含两部分资源：操作系统级打开的文件+应用程序的变量。在操作完毕一个文件时，必须把与该文件的这两部分资源一个不落地回收，回收方法为：\nf.close() #回收操作系统级打开的文件\n文件编码\nf=open(...)是由操作系统打开文件，那么如果我们没有为open指定编码，那么打开文件的默认编码很明显是操作系统说了算了，操作系统会用自己的默认编码去打开文件，在windows下是gbk，在linux下是utf-8。\n#这就用到了上节课讲的字符编码的知识：若要保证不乱码，文件以什么方式存的，就要以什么方式打开\nf=open('a.txt','r',encoding='utf-8')\n文件的打开方式\n文件句柄 = open（‘文件路径’，‘模式’）\n#1. 打开文件的模式有(默认为文本模式)：\nr ，只读模式[默认模式，文件必须存在，不存在则抛出异常]\nw，只写模式[不可读；不存在则创建；存在则清空内容]\na， 只追加写模式[不可读；不存在则创建；存在则只追加内容]\n#2. 对于非文本文件，我们只能使用b模式，\"b\"表示以字节的方式操作（而所有文件也都是以字节的形式存储的，使用这种模式无需考虑文本文件的字符编码、图片文件的jgp格式、视频文件的avi格式）\nrb \nwb\nab\n注：以b方式打开时，读取到的内容是字节类型，写入时也需要提供字节类型，不能指定编码\n#3,‘+’模式（就是增加了一个功能）\nr+， 读写[可读,可写]\nw+，写读[可写,可读]\na+， 写读[可写,可读]\n#4，以bytes类型操作的读写，写读，写读模式\nr+b， 读写[可读,可写]\nw+b，写读[可写,可读]\na+b， 写读[可写,可读]\n文件的操作方法\nread（3）：\n　　1. 文件打开方式为文本模式时，代表读取3个字符　　2. 文件打开方式为b模式时，代表读取3个字节\n其余的文件内光标移动都是以字节为单位的如：seek，tell，truncate\n注意：\n　　1. seek有三种移动方式0，1，2，其中1和2必须在b模式下进行，但无论哪种模式，都是以bytes为单位移动的　　2. truncate是截断文件，所以文件的打开方式必须可写，但是不能用w或w+等方式打开，因为那样直接清空文件了，所以truncate要在r+或a或a+等模式下测试效果。\n其他方法：\ndef readable(self, *args, **kwargs): # real signature unknown\n        是否可读\n        pass\ndef readline(self, *args, **kwargs): # real signature unknown\n        仅读取一行数据\n        pass\ndef seek(self, *args, **kwargs): # real signature unknown\n        指定文件中指针位置\n        pass\ndef flush(self, *args, **kwargs): # real signature unknown\n        刷新文件内部缓冲区\n        pass\nfor循环：循环文件句柄，可以保证内存中每次只有一行\n    with open(\"userinfo\",encoding=\"utf-8\",mode=\"r\") as f:\n        for line in f:\n文件的修改\n文件的数据是存放于硬盘上的，因而只存在覆盖、不存在修改这么一说，我们平时看到的修改文件，都是模拟出来的效果，具体的说有两种实现方式：方式一：将硬盘存放的该文件的内容全部加载到内存，在内存中是可以修改的，修改完毕后，再由内存覆盖到硬盘（word，vim，nodpad++等编辑器）\n全部读入内存,如果文件很大,会很卡\nimport os  # 调用系统模块\nwith open('a.txt') as read_f,open('.a.txt.swap','w') as write_f:\n    data=read_f.read() #全部读入内存,如果文件很大,会很卡\n    data=data.replace('alex','SB') #在内存中完成修改\n    write_f.write(data) #一次性写入新文件\nos.remove('a.txt')  #删除原文件\nos.rename('.a.txt.swap','a.txt')   #将新建的文件重命名为原文件\n循环文件句柄，可以保证内存中每次只有一行\nimport os\nwith open('a.txt') as read_f,open('.a.txt.swap','w') as write_f:\n    for line in read_f:\n        line=line.replace('alex','SB')\n        write_f.write(line)\nos.remove('a.txt')\nos.rename('.a.txt.swap','a.txt') \n初识函数\n函数的定义：\n函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。函数能提高应用的模块性，和代码的重复利用率。你已经知道Python提供了许多内建函数，比如print()，len()等。但你也可以自己创建函数，这被叫做用户自定义函数。\n函数的定义与调用\n第一个函数：\n#函数定义\ndef mylen():\n    \"\"\"计算s1的长度\"\"\"\n    s1 = \"hello world\"\n    length = 0\n    for i in s1:\n        length = length+1\n    print(length)\n\n#函数调用  \nmylen()\n格式：\n\n定义：def 关键词开头，空格之后接函数名称和圆括号()，最后还有一个\":\"。\n\n　　　def 是固定的，不能变，他就是定义函数的关键字。\n\n　　　空格 为了将def关键字和函数名分开，必须空(四声)，当然你可以空2格、3格或者你想空多少都行，但正常人还是空1格。\n\n　　　函数名：函数名只能包含字符串、下划线和数字且不能以数字开头。虽然函数名可以随便起，但我们给函数起名字还是要尽量简短，并能表达函数功能\n\n　　　括号：是必须加的，先别问为啥要有括号，总之加上括号就对了！\n\n注释：每一个函数都应该对功能和参数进行相应的说明，应该写在函数下面第一行。以增强代码的可读性。\n\n调用：就是 函数名() 要记得加上括号\n函数的返回值return\n咱们用len()方法时，得到的结果会赋值给一个变量，然后得到结果：\nstr_len = len('hello,world')\nprint(str_len)\n但是咱们写的这个函数，并不会得到这样的结果，如何让他和len函数一样，有返回值呢？那就是在函数的最后加上一个return，return 后面写你需要的返回值就可以了。\n#函数定义\ndef mylen():\n    \"\"\"计算s1的长度\"\"\"\n    s1 = \"hello world\"\n    length = 0\n    for i in s1:\n        length = length+1\n    return length\n#函数调用\nstr_len = mylen()\nprint('str_len : %s'%str_len)\n\nreturn关键字的作用：1.return 是一个关键字。2.返回值有几种情况：分别是没有返回值、返回一个值、返回多个值。\n没有返回值None\n\n不写return的情况下，会默认返回一个None。\n#函数定义\ndef mylen():\n    \"\"\"计算s1的长度\"\"\"\n    s1 = \"hello world\"\n    length = 0\n    for i in s1:\n        length = length+1\n    print(length)\n\n#函数调用\nstr_len = mylen()\n#因为没有返回值，此时的str_len为None\nprint('str_len : %s'%str_len)\n只写return，后面不写其他内容，也会返回None，但是遇到return会终止整个函数。\ndef ret_demo():\n    print(111)\n    return #只写return\n    print(222)\n\nret = ret_demo()\nprint(ret)\n返回一个值，只需要在return写上内容\n#函数定义\ndef mylen():\n    \"\"\"计算s1的长度\"\"\"\n    s1 = \"hello world\"\n    length = 0\n    for i in s1:\n        length = length+1\n    return length\n\n#函数调用\nstr_len = mylen()\nprint('str_len : %s'%str_len)\n返回多个值,可以是任意多个数据类型的值。返回的多个值会被组织成元组被返回，也可以用多个值来接收。\ndef ret_demo1():\n    '''返回多个值''' \n    return 1,2,3,4\ndef ret_demo2():\n    '''返回多个任意类型的值'''\n    return 1,['a','b'],3,4  #返回多个值\n\nret1 = ret_demo1()\nprint(ret1)\nret2 = ret_demo2()\nprint(ret2)\n函数的参数\n\n实参和形参\n\n实参，*在执行的时候代表打散1.位置参数，按照顺序一一对应2.关键字参数，不用按照顺序，一一对应3.混合参数（包括关键字参数，和位置参数），关键字参数的位置必须在位置参数的后边，一一对应\n\n形参1.位置参数，按照顺序2.默认参数，默认参数必须在位置参数的后边3.动态参数，又叫万能参数，*在函数定义的时候聚合\n*args:接收的所有位置参数，放到一个元组里\n**kwargs:接收的所有关键字参数，放到一个字典里\n形参的顺序：位置参数--->args--->默认参数---->*kargs\n\n\n\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "1"}