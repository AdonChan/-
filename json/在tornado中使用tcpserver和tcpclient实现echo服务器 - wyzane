{"title": "在tornado中使用tcpserver和tcpclient实现echo服务器 - wyzane ", "index": "python,tornado", "content": "本文主要介绍了在tornado框架中,使用tcpserver,tcpclient,struct.pack(),struct.unpack实现简单echo服务器的过程。\n在网络通信中，需要发送二进制流数据；struct.pack()函数负责数据组包，即将数据按照规定的传输协议组合起来；struct.unpack()函数负责数据拆包，即按照规定的协议将数据拆分开来。\n不多说，具体实现代码咱们来看一下。\ntcp客户端代码如下:\n# coding=utf-8\n\n\nimport struct\nimport logging\n\nfrom tornado import ioloop, gen\nfrom tornado.tcpclient import TCPClient\n\n\n\"\"\"\ntcpclient-struct.pack()组包\n发送数据包格式:消息头+消息体\n消息头:消息发送者(4字节)+消息接收者(4字节)+消息类型(1字节)+消息体中数据长度(4字节)\n消息体:待发送数据\nstruct.unpack()拆包\n接收数据包格式:消息头+消息体\n消息头:消息发送者(4字节)+消息类型(1字节)+消息体中数据长度(4字节)\n消息体:待接收数据\n\"\"\"\n\n\nlogging.basicConfig(level=logging.DEBUG)\nlogger = logging.getLogger(__name__)\n\n\nclass ChatClient(object):\n    def __init__(self, host, port):\n        self.host = host\n        self.port = port\n\n    @gen.coroutine\n    def start(self):\n        self.stream = yield TCPClient().connect(self.host, self.port)\n        while True:\n            yield self.send_message()\n            yield self.receive_message()\n\n    @gen.coroutine\n    def send_message(self):\n        # 待发送数据\n        msg = input(\"输入:\")\n        bytes_msg = bytes(msg.encode(\"utf-8\"))\n        # 消息发送者\n        chat_id = 10000000\n        # 消息接收者\n        receive_id = 10000001\n        # 消息类型 1-文本 2-图片 3-语音 4-视频 等\n        msg_type = 1\n\n        binary_msg = struct.pack(\"!IIBI\"+str(len(msg))+\"s\", chat_id, receive_id, msg_type, len(msg), bytes_msg)\n        # 发送数据\n        yield self.stream.write(binary_msg)\n\n    @gen.coroutine\n    def receive_message(self):\n        \"\"\"\n        接收数据\n        :return:\n        \"\"\"\n        try:\n            logger.debug(\"receive data ...\")\n            # 消息发送者 4字节\n            sender = yield self.stream.read_bytes(4, partial=True)\n            sender = struct.unpack('!I', sender)[0]\n            logger.debug(\"sender:%s\", sender)\n\n            # 消息类型 1字节\n            msg_type = yield self.stream.read_bytes(1, partial=True)\n            msg_type = struct.unpack('!B', msg_type)[0]\n            logger.debug(\"msg_type:%s\", msg_type)\n\n            # 消息长度 4字节\n            msg_len = yield self.stream.read_bytes(4, partial=True)\n            msg_len = struct.unpack('!I', msg_len)[0]\n            logger.debug(\"msg_len:%s\", msg_len)\n\n            # 真实数据\n            data = yield self.stream.read_bytes(msg_len, partial=True)\n            data = struct.unpack(\"!\" + str(msg_len) + \"s\", data)\n            logger.debug(\"data:%s\", data)\n        except Exception as e:\n            logger.error(\"tcp client exception:%s\", e)\n\n\ndef main():\n    c1 = ChatClient(\"127.0.0.1\", 8888)\n    c1.start()\n    ioloop.IOLoop.instance().start()\n\n\nif __name__ == '__main__':\n    main()\n    \n    \n    \ntcp服务端代码:\n# coding=utf-8\n\n\nimport struct\nimport logging\n\nfrom tornado.tcpserver import TCPServer\nfrom tornado.netutil import bind_sockets\nfrom tornado.iostream import StreamClosedError\nfrom tornado import gen\nfrom tornado.ioloop import IOLoop\n\n\n\"\"\"\ntcpserver-struct.unpack()拆包\n接收数据包格式:消息头+消息体\n消息头:消息发送者(4字节)+消息接收者(4字节)+消息类型(1字节)+消息体中数据长度(4字节)\n消息体:待接收数据\nstruct.pack()组包\n转发数据包格式:消息头+消息体\n消息头:消息发送者(4字节)+消息类型(1字节)+消息体中数据长度(4字节)\n消息体:待发送数据\n\"\"\"\n\n\nlogging.basicConfig(level=logging.DEBUG)\nlogger = logging.getLogger(__name__)\n\n\nclass ChatServer(TCPServer):\n\n    PORT = 8888\n    clients = dict()\n\n    @gen.coroutine\n    def handle_stream(self, stream, address):\n        \"\"\"\n        数据拆包并解析\n        :param stream:\n        :param address:\n        :return:\n        \"\"\"\n        logger.debug(\"%s已上线\", address)\n        ChatServer.clients[address] = stream\n        while True:\n            try:\n                # !表示使用大端方式解析数据\n                # 消息发送者 4字节\n                sender = yield stream.read_bytes(4, partial=True)\n                sender = struct.unpack('!I', sender)[0]\n                logger.debug(\"sender:%s\", sender)\n\n                # 消息接收者 4字节\n                receiver = yield stream.read_bytes(4, partial=True)\n                receiver = struct.unpack('!I', receiver)[0]\n                logger.debug(\"receiver:%s\", receiver)\n\n                # 消息类型 1字节\n                msg_type = yield stream.read_bytes(1, partial=True)\n                msg_type = struct.unpack('!B', msg_type)[0]\n                logger.debug(\"msg_type:%s\", msg_type)\n\n                # 消息长度 4字节\n                msg_len = yield stream.read_bytes(4, partial=True)\n                msg_len = struct.unpack('!I', msg_len)[0]\n                logger.debug(\"msg_len:%s\", msg_len)\n\n                if msg_type == 1:\n                    # 文本信息处理\n                    logger.debug(\"text message ...\")\n                    self.handle_text_stream(stream, sender, msg_len)\n                elif msg_type == 2:\n                    logger.debug(\"picture message ...\")\n                    self.handle_pic_stream(stream, sender, msg_len)\n\n            except StreamClosedError:\n                logger.debug(\"%s已下线\", address)\n                del ChatServer.clients[address]\n                break\n\n    @gen.coroutine\n    def handle_text_stream(self, stream, sender, msg_len):\n        \"\"\"\n        处理文本数据\n        :param stream:\n        :param send_to:\n        :param msg_len:\n        :return:\n        \"\"\"\n        data = yield stream.read_bytes(msg_len, partial=True)\n        data = struct.unpack(\"!\"+str(msg_len)+\"s\", data)\n        logger.debug(\"data:%s\", data)\n        try:\n            # 打包数据,数据格式:数据发送者+数据类型+数据长度+数据体\n            binary_msg = struct.pack(\"!IBI\" + str(msg_len) + \"s\", sender, 1, msg_len, data[0])\n            # 发送数据\n            yield stream.write(binary_msg)\n            logger.debug(\"=\"*25)\n        except KeyError:\n            # 将离线消息保存到数据库\n            pass\n\n    @gen.coroutine\n    def handle_pic_stream(self, stream, sender, msg_len):\n        pass\n\n\nif __name__ == '__main__':\n    sockets = bind_sockets(ChatServer.PORT)\n    server = ChatServer()\n    server.add_sockets(sockets)\n    IOLoop.current().start()\n    \n以上就是具体的代码实现，如有错误，欢迎大家与我交流指正，谢谢！\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}