{"title": "Python进阶笔记 - 个人文章 ", "index": "python", "content": "\n列表生成式\n函数的参数类型\nlambda函数\nmap, reduce, filter, sorted函数\neval, exec, join, zip函数\nitertools中的函数\ncopy与deepcopy函数\n模块\nos、sys模块\n迭代器\n生成器\n迭代器\n\n参考网站：\n\nPython3教程： https://www.python-course.eu/...\n\nPython之函数参数的使用：https://blog.csdn.net/jclian9...\n\n廖雪峰Python教程: https://www.liaoxuefeng.com/w...\n\nPython之浅谈exec函数： https://blog.csdn.net/jclian9...\n\nPython官网的itertools说明： https://docs.python.org/3.6/l...\n\nPython-copy()与deepcopy()区别: https://blog.csdn.net/qq_3290...\n\ncopy模块官网：https://docs.python.org/3.5/l...\n\n\n列表生成式\n列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。一般是利用原有的数据结构来生成新的列表。\n# 利用range()生成[1,2,...,9,10]\nlist(range(1,11))\n\n# 生成[1x1, 2x2, 3x3, ..., 10x10]\n[x * x for x in range(1, 11)]\n# 可以通过占位符_代表列表中的元素\n[_*_ for _ in range(1,11)]\n\n# 筛选出仅偶数的平方, 在for循环后加上if判断语句\n[x * x for x in range(1, 11) if x % 2 == 0]\n# 利用占位符简化\n[_*_ for _ in range(1, 11) if not _%2]\n\n# 两层循环，三层循环，....\n[m + n for m in 'ABC' for n in 'XYZ']\n[x+y+z for x in  'ab' for y in 'cd' for z in 'ef']\n\n# 遍历字典，生成列表\nd = {'x': 'A', 'y': 'B', 'z': 'C' }\n[k + '=' + v for k, v in d.items()]\n函数的参数类型\n在Python中定义函数，其参数类型有：\n\n位置参数\n默认参数\n可变参数\n关键字参数\n\n这4种参数都可以一起使用，或者只用其中某些，但是请注意，参数定义的顺序必须是：位置参数、默认参数、可变参数和关键字参数。\n可变参数以*开头，允许传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。关键字参数以**开头，允许传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个dict。若默认参数与可变参数放在一起，则接受完默认参数后，其后参数为可变参数。\n位置参数\n位置参数指定名称的必须放在未指定名称的后面\ndef person(name,age,city):\n    s = \"info: name=%s, age=%s, city=%s\"%(name,age,city)\n    return s\n\nprint(person('Jack', 25, 'NY'))\nprint(person(name='Jack', age=25, city='NY'))\nprint(person('Jack', 25, city='NY'))\n# 下面的参数使用有误，位置参数指定名称的必须放在未指定名称的后面\nprint(person(name='Jack', 25, 'NY'))\n默认参数\n默认参数必须放在非默认参数的后面,可以该表默认参数的值\ndef person(name, city, age=18):\n    s = \"info: name=%s, age=%s, city=%s\"%(name,age,city)\n    return s\n\nprint(person('Jack', 'NY'))\nprint(person('Jack', 'NY', 20))\n可变参数\n可变参数以*开头，允许传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。函数参数的长度是可以变化的， 例如内置的sum, min, max等\ndef var_sum(*args):\n    sum = 0\n    for i in args:\n        sum += i\n\n    return sum\n\nprint(var_sum(1,2,3))\nprint(var_sum(1,2,3,4))\n# 利用*号来分解参数\nprint(var_sum(*[1,2,3,4,5]))\n若位置参数或默认参数与可变参数放在一起，则接受完位置参数或默认参数后，其后参数为可变参数。\ndef var_sum(a, *args):\n    sum = 0\n    for i in args:\n        sum += i\n\n    print('a is %s, sum is %s'%(a,sum))\n\nvar_sum(1,2)\nvar_sum(1,2,3)\n关键字参数\n关键字参数以**开头，允许传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个dict。\ndef test_args(**kwargs):\n    print('-'*20)\n    for key in kwargs:\n        print('key:', key, ',value:', kwargs[key])\n\n    print()\n\ntest_args(a=1,b=2)\ntest_args(a=1,b=2,c=3)\nlambda函数\nlambda函数即为匿名函数，用关键字lambda表示，冒号（：）前面的为参数，后面为返回值,不用写return.\n如：\nlambda x: x*x\n匿名函数有个限制，就是只能有一个表达式，一般一行代码，不用写return，返回值就是该表达式的结果。\n用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数，即函数也是变量，此为函数式编程(functional programming)思想。\nf = lambda x: x*x\nf(5)\nmap, reduce, filter, sorted函数\nmap函数\nmap()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。\n可以直接作用于for循环的对象统称为可迭代对象：Iterable.\n举例说明，比如我们有一个函数f(x)=x^2，要把这个函数作用在一个list [1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map()实现如下：\n# map函数： 一一映射\ndef f(x):\n    return x * x\n\nr = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])\nlist(r)\n\n# 利用lambda简化上述代码\n\nlist(map(lambda x: x*x, range(1, 11)))\n\n再例如： 把list所有数字转为字符串：\nlist(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))\nreduce函数\nreduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，一个是函数，一个是Iterable. reduce把结果继续和序列的下一个元素做累积计算，其效果就是：\nreduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)\n比方说对一个序列求和，就可以用reduce实现：\n# 导入reduce, 这很重要\nfrom functools import reduce\n\ndef add(x, y):\n    return x + y\n\nreduce(add, [1, 3, 5, 7, 9])\n\n# 利用lambda函数简化\nreduce(lambda x,y: x+y, range(1,10,2))\n作业： 利用reduce将序列[1, 3, 5, 7, 9]转化为整数13579.\nmap, reduce的一个复杂例子：\n将字符串列表['1', '3', '5', '7', '9']转化为整数13579\nfrom functools import reduce\n\na = ['1', '3', '5', '7', '9']\nt = reduce(lambda x,y: 10*x+y, map(int, a))\nprint(t)\nfilter函数\nPython内建的filter()函数用于过滤序列。\n和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。\n例如，在一个list中，删掉偶数，只保留奇数，可以这么写：\nlist(filter(lambda x: x%2 == 1, [1, 2, 4, 5, 6, 9, 10, 15]))\nsorted函数\nPython内置的sorted()函数就可以对list进行排序。\nsorted([36, 5, -12, 9, -21])\n此外，sorted()函数还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序：\nsorted([36, 5, -12, 9, -21], key=abs)\nsorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)\n\n高阶函数，就是让函数的参数能够接收别的函数。map, reduce, filter, sorted都是高阶函数。\njoin, zip, eval, exec函数\njoin函数\nPython中的join函数有两个，分别为: join()和os.path.join()，具体作用如下：\n\njoin()：    连接字符串数组。将字符串、元组、列表中的元素以指定的字符(分隔符)连接生成一个新的字符串\nos.path.join()：  将多个路径组合后返回\n\n字符串中的join()函数的使用方法：\n'sep'.join(seq)\nsep：分隔符。可以为空。 seq：要连接的元素序列。 返回一个新的字符串。\nseq = ['hello','good','boy','Dido']\n\nprint(' '.join(seq))\nprint('*'.join(seq))\nzip函数\nzip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。\n如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。\n# basic use of zip\nx = [1, 2, 3]\ny = [4, 5, 6]\nzipped = zip(x, y)\nprint(list(zipped))\n\n# zip for loops\nfor i,j in zip(x,y):\n    print(i, \"->\", j)\n\n# unzip the list\na = [(1,2,3), (3,4,5)]\nx2, y2, z2 = zip(*a)\nprint(x2)\nprint(y2)\nprint(z2)\n\n# transpose a matrix\nmtx = [(1, 2),\n       (3, 4),\n       (5, 6)]\nprint(list(zip(*mtx)))\n\n# clustering a data series into n-length groups idiom\nseq = range(1, 10)\nprint(list(zip(*[iter(seq)]*3)))\n\n# dict and zip\nkeys = ['spam', 'eggs']\nvals = [42, 1729]\nd = dict(zip(keys, vals))\nprint(d)\n\neval函数\neval函数用来计算字符串表达式的值\nt = eval(\"23\")\nprint(t)\nprint(type(t))\n\nprint(eval(\"(1+2)*(3+4)\"))\nexec函数\nexec()是Python的内置函数，不同于eval()函数只能执行计算数学表达式的结果的功能，exec()能够动态地执行复杂的Python代码，能够十分强大。\n简单例子：\n# 执行简单的Python语句\ni = 12\nj = 13\nexec(\"answer=i*j\")\nprint(\"Answer is %s\"%answer)\n\n# 执行复杂的Python语句\nfunc = \"def fact(n):\\n\\treturn 1 if n==1 else n*fact(n-1)\"\nexec(func)\na = fact(5)\nprint(a)\nexec函数还可以执行储存在其他文件中的Python代码，例如位于E盘的eg.txt,如下：\ndef fact(n):\n    if n==1:\n        return 1\n    else:\n        return n*fact(n-1)\nt = fact(6)\nprint(t)\n利用exec函数执行eg.txt中的代码：\nwith open('E://eg.txt', 'r') as f:\n    s = f.read()\n\nexec(s)\n还可以在exec()函数中加入参数,参数的传递可以写成字典(dict)形式。\nx = 10\n\nexpr = \"\"\"\nz = 30\nsum = x + y + z\nprint(sum)\n\"\"\"\n\ndef func():\n    y = 20\n    exec(expr)\n    exec(expr, {'x': 1, 'y': 2})\n    exec(expr, {'x': 1, 'y': 2}, {'y': 3, 'z': 4})\n\nfunc()\n输出结果为：\n60 33 34\nitertools模块中的函数\nPython的内建模块itertools提供了非常有用的用于操作迭代对象的函数。\nitertools模块提供的全部是处理迭代功能的函数，它们的返回值不是list，而是Iterator，只有用for循环迭代的时候才真正计算。\n无穷迭代器\n\n\nIterator\nArguments\nResults\nExample\n\n\n\ncount()\nstart, [step]\nstart, start+step, start+2*step, ...\ncount(10) --> 10 11 12 13 14 ...\n\n\ncycle()\np\np0, p1, ... plast, p0, p1, ...\ncycle('ABCD') --> A B C D A B C D ...\n\n\nrepeat()\nelem [,n]\nelem, elem, elem, ... endlessly or up to n times\nrepeat(10, 3) --> 10 10 10\n\n\n\n“有限”迭代器\n\n\nIterator\nArguments\nResults\nExample\n\n\n\naccumulate()\np [,func]\np0, p0+p1, p0+p1+p2, ...\naccumulate([1,2,3,4,5]) --> 1 3 6 10 15\n\n\nchain()\np, q, ...\np0, p1, ... plast, q0, q1, ...\nchain('ABC', 'DEF') --> A B C D E F\n\n\nchain.from_iterable()\niterable\np0, p1, ... plast, q0, q1, ...\nchain.from_iterable(['ABC', 'DEF']) --> A B C D E F\n\n\ncompress()\ndata, selectors\n(d[0] if s[0]), (d[1] if s[1]), ...\ncompress('ABCDEF', [1,0,1,0,1,1]) --> A C E F\n\n\ndropwhile()\npred, seq\nseq[n], seq[n+1], starting when pred fails\ndropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1\n\n\nfilterfalse()\npred, seq\nelements of seq where pred(elem) is false\nfilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8\n\n\ngroupby()\niterable[, keyfunc]\nsub-iterators grouped by value of keyfunc(v)\n \n\n\nislice()\nseq, [start,] stop [, step]\nelements from seq[start:stop:step]\nislice('ABCDEFG', 2, None) --> C D E F G\n\n\nstarmap()\nfunc, seq\nfunc(seq[0]), func(seq[1]), ...\nstarmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000\n\n\ntakewhile()\npred, seq\nseq[0], seq[1], until pred fails\ntakewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4\n\n\ntee()\nit, n\nit1, it2, ... itn splits one iterator into n\n \n\n\nzip_longest()\np, q, ...\n(p[0], q[0]), (p[1], q[1]), ...\nzip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-\n\n\n\ngroupby()函数\ngroupby()把迭代器中相邻的重复元素挑出来放在一起：\nfor key, group in itertools.groupby('AAABBBCCAAA'):\n     print(key, list(group))\n\nA ['A', 'A', 'A']\nB ['B', 'B', 'B']\nC ['C', 'C']\nA ['A', 'A', 'A']\n实际上挑选规则是通过函数完成的，只要作用于函数的两个元素返回的值相等，这两个元素就被认为是在一组的，而函数返回值作为组的key。\n另一个例子\n# 按身高归类\nfrom itertools import *\n\ndef height_class(h):\n    if h>180:\n        return 'tall'\n    elif h<160:\n        return 'short'\n    else:\n        return 'middle'\n\nfriends = [191, 158, 159, 165, 170, 177, 181, 182, 190]\n\nfor m,n in groupby(friends,key = height_class):\n    print(m)\n    print(list(n))\n作业： 对于一组身高的数据（list），利用上面代码给出的身高标准，将所以的tall, short, middle归为一类。注意与groupby()函数的区别。\ntee()函数\n把一个迭代器分为n个迭代器, 返回一个元组.默认是两个\nfrom itertools import *\na = \"hello\"\nc, d, e = tee(iter(a), 3)\nfor i, j, k in zip(c, d, e):\n    print(i, j, k)\n组合生成器\n\n\nIterator\nArguments\nResults\n\n\n\nproduct()\np, q, ... [repeat=1]\ncartesian product, equivalent to a nested for-loop\n\n\npermutations()\np[, r]\nr-length tuples, all possible orderings, no repeated elements\n\n\ncombinations()\np, r\nr-length tuples, in sorted order, no repeated elements\n\n\ncombinations_with_replacement()\np, r\nr-length tuples, in sorted order, with repeated elements\n\n\nproduct('ABCD', repeat=2)\n \nAA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD\n\n\npermutations('ABCD', 2)\n \nAB AC AD BA BC BD CA CB CD DA DB DC\n\n\ncombinations('ABCD', 2)\n \nAB AC AD BC BD CD\n\n\ncombinations_with_replacement('ABCD', 2)\n \nAA AB AC AD BB BC BD CC CD DD\n\n\n\ncopy与deepcopy函数\ncopy: 浅拷贝(shallow copy), deepcopy: 深拷贝(deep copy).\n\n我们寻常意义的复制就是深复制，即将被复制对象完全再复制一遍作为独立的新个体单独存在。所以改变原有被复制对象不会对已经复制出来的新对象产生影响。\n而浅复制并不会产生一个独立的对象单独存在，他只是将原有的数据块打上一个新标签，所以当其中一个标签被改变的时候，数据块就会发生变化，另一个标签也会随之改变。这就和我们寻常意义上的复制有所不同了。\n对于简单的 object，用 shallow copy 和 deep copy 没区别\n复杂的 object， 如 list 中套着 list 的情况，shallow copy 中的 子list，并未从原 object 真的「独立」出来。也就是说，如果你改变原 object 的子 list 中的一个元素，你的 copy 就会跟着一起变。这跟我们直觉上对「复制」的理解不同。\n\n例子：\nfrom copy import copy, deepcopy\n\n#origin 里边有三个元素：1,2,[3, 4]\norigin = [1, 2, [3, 4]]\n\n# cop1为浅拷贝，cop2为深拷贝\ncop1 = copy(origin)\ncop2 = deepcopy(origin)\n\n# cop1是否与cop2内容相同\nprint(cop1 == cop2)\n# cop1是否与cop2为同一个引用\nprint(cop1 is cop2)\n\n# 改变origin中嵌套列表中的元素\norigin[2][0] = \"hey\"\n\n# 查看输出\nprint(origin)\nprint(cop1)\nprint(cop2)\n\n# 改变origin中嵌套列表中的元素\norigin[1] = \"hello\"\n\n# 查看输出\nprint(origin)\nprint(cop1)\nprint(cop2)\n输出结果：\nTrueFalse[1, 2, ['hey', 4]][1, 2, ['hey', 4]][1, 2, [3, 4]][1, 'hello', ['hey', 4]][1, 2, ['hey', 4]][1, 2, [3, 4]]\n模块\n在Python中，一个Python文件就是一个模块。\n模块让你能够有逻辑地组织你的 Python 代码段。\n把相关的代码分配到一个模块里能让你的代码更好用，更易懂。\n模块能定义函数，类和变量，模块里也能包含可执行的代码。\n一个简单的模块例子：\nhello.py\ndef say_hello(name):\n    s = 'hello, %s!'%name\n    return s\n使用模块：\n\nimport module\nfrom module import ...\n\nimport hello\n\nprint(hello.say_hello(\"Lee\"))\n\nfrom hello import say_hello\n\nprint(say_hello(\"Jack\"))\nos、sys模块\nos模块\nos模块包含普遍的操作系统功能。\nos常用方法及属性\nos.sep 可以取代操作系统特定的路径分隔符。windows下为 “\\”os.name字符串指示你正在使用的平台。比如对于Windows，它是'nt'，而对于Linux/Unix用户，它是'posix'。\nos.getcwd() 函数得到当前工作目录，即当前Python脚本工作的目录路径。\nos.getenv() 获取一个环境变量，如果没有返回none\nos.putenv(key, value) 设置一个环境变量值\nos.listdir(path) 返回指定目录下的所有文件和目录名。\nos.remove(path) 函数用来删除一个文件。\nos.system(command) 函数用来运行shell命令。\nos.linesep 字符串给出当前平台使用的行终止符。例如，Windows使用'rn'，Linux使用'n'而Mac使用'r'。\nos.curdir: 返回当前目录（'.')\nos.chdir(dirname): 改变工作目录到dirname\nos.path常用方法：\nos.path.isfile()和os.path.isdir()函数分别检验给出的路径是一个文件还是目录。\nos.path.existe()函数用来检验给出的路径是否真地存在\nos.path.getsize(name):获得文件大小，如果name是目录返回0L\nos.path.abspath(name):获得绝对路径os.path.normpath(path):规范path字符串形式\nos.path.split(path) ：将path分割成目录和文件名二元组返回。\nos.path.splitext():分离文件名与扩展名\nos.path.join(path,name):连接目录与文件名或目录;使用“”连接os.path.basename(path):返回文件名os.path.dirname(path):返回文件路径\nsys模块\nsys模块提供了一系列有关Python运行环境的变量和函数。\nsys模块的常用方法\nsys.argv: 实现从终端向程序传递参数。\nsys.exit([arg]): 程序中间的退出，arg=0为正常退出。\nsys.getdefaultencoding(): 获取系统当前编码，一般默认为ascii。\nsys.setdefaultencoding(): 设置系统默认编码，执行dir（sys）时不会看到这个方法，在解释器中执行不通过，可以先执行reload(sys)，在执行 setdefaultencoding('utf8')，此时将系统默认编码设置为utf8。（见设置系统默认编码 ）\nsys.getfilesystemencoding(): 获取文件系统使用编码方式，Windows下返回'mbcs'，mac下返回'utf-8'.\nsys.path: 获取指定模块搜索路径的字符串集合，可以将写好的模块放在得到的某个路径下，就可以在程序中import时正确找到。\nsys.platform: 获取当前系统平台。\nsys.stdin, sys.stdout, sys.stderr: stdin , stdout , 以及stderr 变量包含与标准I/O 流对应的流对象. 如果需要更好地控制输出,而print 不能满足你的要求, 它们就是你所需要的. 你也可以替换它们, 这时候你就可以重定向输出和输入到其它设备( device ), 或者以非标准的方式处理它们\n生成器\n通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。\n所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。\n创建generator的办法：\n\n把一个列表生成式的[]改成()\nyield关键字\n\n将列表的[]改成()的例子：\n# 列表生成式\nL = [x * x for x in range(10)]\nprint(type(L))\n\n# 创建生成器\ng = (x * x for x in range(10))\nprint(type(g))\n\n# 获取下一个返回值\n# 当没有更多元素时，会抛出StopIteration错误\nprint(next(g))\nprint(next(g))\nprint(next(g))\n\n# for循环\nfor n in g:\n    print(n)\n通过yield创建生成器\n# 普通方法生成斐波拉契数列\n# 前几个斐波拉契数\ndef fib1(max):\n    n, a, b = 0, 0, 1\n    while n < max:\n        print(b)\n        a, b = b, a + b\n        n = n + 1\n    return 'done'\n\nfib1(6)\n\n# 通过yield创建生成器\n# 注意yield的执行流程\ndef fib2(max):\n    n, a, b = 0, 0, 1\n    while n < max:\n        yield b\n        a, b = b, a + b\n        n = n + 1\n    return 'done'\n\n# 将生成器函数赋值给变量f\nf = fib2(6)\nprint(type(f))\nfor n in f:\n    print(n)\ngenerator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。\ngenerator执行流程的理解：\ndef odd():\n    print('step 1')\n    yield 1\n    print('step 2')\n    yield(3)\n    print('step 3')\n    yield(5)\n\no = odd()\n\nprint(next(o))\nprint(next(o))\nprint(next(o))\n迭代器\n可以直接作用于for循环的数据类型有以下几种：\n\n集合数据类型，如list、tuple、dict、set、str等；\ngenerator，包括生成器和带yield的generator function。\n\n这些可以直接作用于for循环的对象统称为可迭代对象：==Iterable==。\n可以使用isinstance()判断一个对象是否是Iterable对象：\nfrom collections import Iterable\n\n# 判断空列表是否为Iterable对象\n# True\nprint(isinstance([], Iterable))\n\n# 判断空集合是否为Iterable对象\n# True\nprint(isinstance({}, Iterable))\n\n# 判断字符是否为Iterable对象\n# True\nprint(isinstance('abc', Iterable))\n\n# 判断生成器是否为Iterable对象\n# True\nprint(isinstance((x for x in range(10)), Iterable))\n\n# 判断数字否为Iterable对象\n# False\nprint(isinstance(100, Iterable))\n可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。\n可以使用isinstance()判断一个对象是否是Iterator对象：\nfrom collections import Iterator\n\n# 判断生成器是否为Iterator对象\n# True\nprint(isinstance((x for x in range(10)), Iterator))\n\n# 判断空列表是否为Iterator对象\n# False\nprint(isinstance([], Iterator))\n\n# 判断空集合是否为Iterator对象\n# False\nprint(isinstance({}, Iterator))\n\n# 判断字符串是否为Iterator对象\n# False\nprint(isinstance('abc', Iterator))\n生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。\n把list、dict、str等Iterable变成Iterator可以使用iter()函数。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}