{"title": "Python 3 学习笔记之——变量作用域、模块和包 - 个人文章 ", "index": "python", "content": "1. 变量作用域\n\n\nPython 中，程序的变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。Python 的作用域一共有4种，分别是：\n\nL （Local） 局部作用域\nE （Enclosing） 闭包函数外的函数中\nG （Global） 全局作用域\nB （Built-in） 内建作用域\n\n\n以 L –> E –> G –>B 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内建中找。\n\nx = int(2.9)  # 内建作用域\n \ng_count = 0  # 全局作用域\n\ndef outer():\n    o_count = 1  # 闭包函数外的函数中\n    def inner():\n        i_count = 2  # 局部作用域\nPython 中只有模块（module）、类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 if/elif/else/、try/except、for/while等）是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问。\n2. 全局变量和局部变量\n定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。\ntotal = 0 # 这是一个全局变量\n\ndef sum( arg1, arg2 ):\n    #返回2个参数的和.\"\n    total = arg1 + arg2 # total在这里是局部变量.\n    print (\"函数内是局部变量 : \", total)\n    return total\n \n#调用sum函数\nsum( 10, 20 )\nprint (\"函数外是全局变量 : \", total)\n\n当内部作用域想修改外部作用域的变量时，就要用到 global 和 nonlocal 关键字了。\n修改全局变量\n\nnum = 1\ndef fun1():\n    global num  # 需要使用 global 关键字声明\n    print(num) \n    num = 123\n    print(num)\nfun1()\nprint(num)\n\n>>>\n1\n123\n123\n修改嵌套作用域中的变量\ndef outer():\n    num = 10\n    def inner():\n        nonlocal num   # nonlocal关键字声明\n        num = 100\n        print(num)\n    inner()\n    print(num)\nouter()\n\n>>>\n100\n100\n3. 模块\nimport module_name\n\n当 Python 解释器遇到 import 语句时，会在 Python 的搜索路径中依次去寻找所引入的模块。\n搜索路径被存储在 sys 模块中的 path 变量，sys.path 输出是一个列表，其中第一项是空串 ''，代表当前目录，亦即我们执行 Python 解释器的目录（对于脚本的话就是运行的脚本所在的目录）。\n因此如果在当前目录下存在与要引入模块同名的文件，就会把要引入的模块屏蔽掉，这也就是我们自己的模块名不能和 Python 标准模块名重名的原因。\n一个模块只会被导入一次，不管你执行了多少次 import ，这样可以防止导入模块被一遍又一遍地执行。\n\nfrom module_name import function_name\nPython 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中。\nfrom module_name import *\n把一个模块的所有内容全都导入到当前的命名空间。\n\nname 属性\n一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用 name 属性来使该程序块仅在该模块自身运行时执行。\nif __name__ == '__main__':\n   print('程序自身在运行')\nelse:\n   print('我来自另一模块')\n每个模块都有一个__name__属性，当其值是'__main__'时，表明该模块自身在运行，否则是被引入。\ndir() 函数\n内置的函数 dir() 可以找到模块内定义的所有名称，以一个字符串列表的形式返回。\n4. 包\n\n包是一种管理 Python 模块命名空间的形式，采用\"点模块名称\"。比如一个模块的名称是 A.B， 那么他表示一个包 A 中的子模块 B 。\n不妨假设你想设计一套统一处理声音文件和数据的模块（或者称之为一个\"包\"）。\n现存很多种不同的音频文件格式（基本上都是通过后缀名区分的，例如： .wav，:file:.aiff，:file:.au，），所以你需要有一组不断增加的模块，用来在不同的格式之间转换。\n并且针对这些音频数据，还有很多不同的操作（比如混音，添加回声，增加均衡器功能，创建人造立体声效果），所以你还需要一组怎么也写不完的模块来处理这些操作。\n这里给出了一种可能的包结构（在分层的文件系统中）:\n\n\n\n注意当使用 from package import item 这种形式的时候，对应的 item 既可以是包里面的子模块（子包），或者包里面定义的其他名称，比如函数，类或者变量。\nimport 语法会首先把 item 当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。如果还没找到，恭喜，一个:exc:ImportError 异常被抛出了。\n反之，如果使用形如 import item.subitem.subsubitem 这种导入形式，除了最后一项，都必须是包，而最后一项则可以是模块或者是包，但是不可以是类，函数或者变量的名字。\nfrom package import  导入语句遵循如下规则：如果包定义文件 init__.py 存在一个叫做 __all 的列表变量，那么在使用 from package import  的时候就把这个列表中的所有名字作为包内容导入。\n如果 all 真的没有定义，那么使用 from sound.effects import * 这种语法的时候，就不会导入包 sound.effects 里的任何子模块。他只是把包 sound.effects 和它里面定义的所有内容导入进来（可能运行__init__.py里定义的初始化代码）。\n\n参考资料 菜鸟教程\n获取更多精彩，请关注「seniusen」! \n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}