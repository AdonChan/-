{"title": "Python和SQL Server 2017的强大功能 - 个人文章 ", "index": "python,sqlserver", "content": "Python和SQL Server 2017的强大功能\nPython是SQL Server 2017的新功能。它主要是为了允许在SQLServer中使用基于Python的机器学习，但是它可以与任何Python库或框架一起使用。为了提供可能的例子，Hitendra展示了如何安全地使用该功能来提供智能应用程序缓存，其中SQLServer可以自动指示数据何时更改以触发缓存刷新。\nMS SQL Server 2017已经通过启用SQL服务器通过“使用Python的机器学习服务”在TSQL中执行Python脚本，添加到其高级分析扩展，现在称为“机器学习服务”。这基本上提供了一种数据库程序员可以直接从Python传递数据的方法。这样做的有用性不仅限于为数据分析提供机器学习功能，因为Python具有许多易于使用的模块和框架来解决许多问题，例如使用数据结构执行大量计算工作，用于分析的图形处理，网络操作，数据库操作，网络操作或基于本地/网络的文件系统操作。显然，其中许多在中间件方面做得最好，但是在数据库系统中，有时候直接与外部系统通信，而不是依靠外部进程通过轮询数据源来执行任务更方便。如果在数据库或数据层中有一个这样的解决方案，并且不提供任何安全性问题时，这不是问题。\n在这里，我们将尝试演示在Advanced Analytics Extension中使用Python的示例，显示数据库如何触发外部进程来对作为参数提供的数据执行活动。这是为了考虑安全性，数据可靠性和事务响应时间的问题。\nPython的用例\n通过从SQL调用Python脚本而不是依赖于中间件，可以更容易地完成某些任务。特别是在数据库中事件发起任务的情况下。任务可能包括\n\n通过TCP / HTTP / SOAP向网络系统发送数据或从基于网络的系统接收数据。\n利用本地平台资源，如文件系统，网络或GPU。\n通过使用通用数据格式（如JSON，XML或YAML）构建一个或多个系统之间的实时集成。\n通过与外部应用程序通信生成数据或文件。\n\n当然也难免存在一些潜在的缺点\n\n如果您使用Python需要互联网访问，那么存在必须保持安全的数据可能会被意外地通过互联网共享的风险。任何互联网访问必须由网络仔细监管。\n允许通过“启用外部脚本执行”在服务器上执行Python脚本来暴露安全风险。\n相同服务器上的资源密集型Python脚本可能会影响大型OLTP系统上正在进行的事务的性能。\n\n衡量这些优点和缺点，似乎有时候Python可以发挥有用的作用，如果可以最小化风险。作为一个例子，让我们考虑一下我们如何使用Python构建数据缓存系统供应用层使用。\n缓存示例解决方案\n缓存数据可以提高应用程序的性能。以缓存的存储开销为代价，当遇到与数据库的聊天网络通信以及数据库面临重复查询时资源消耗高的情况下，我们可以获得有用的性能提升。当我们构建缓存基础架构时，我们面临着什么时候刷新缓存的内容的常见问题。我们倾向于在一定时间间隔之后采用重建缓存的简单解决方案。然而，这是非常低效的。当数据更改时刷新缓存更好，只刷新改变的内容。在创建，更新或删除数据时，我们可以实时接近实时。有许多工具和框架可用于解决刷新问题，但是它们受到如何确定数据发生变化以及何时发生更改的问题。数据库是最好的所有能够做到这一点。\n对于我们这里提供的缓存系统，我们将把自己限制在微软堆栈中，以防止Python本身。\n\n\nMicrosoft SQL Server 2017（CPT）\n\n服务代理隔离事务数据库。\nPython执行脚本，可以通过HTTP更新缓存（Python 3.5可执行文件与Anaconda发行版中的库）\n\n\n\n.Net 4.5.2\n\nASP.Net MVC为我们的示例Web UI\nASP.Net WebAPI封装缓存存储为我们的示例解决方案。\n\n\n\n以下是我们的示例解决方案缓存系统的图示：\n\nWebApplication提供用于读取和更新数据的用户界面。\n我们示例缓存存储解决方案中的RESTful.Cache应用程序是使用ASP.Net WebAPI2构建的，其内容类型为JSON。 HTTP-GET操作从本地缓存（静态集合）传送数据。\n\nMS SQL Server 2017（CPT）是一个数据库服务器\n\nTransDB OLTP数据库，处理事务繁忙。\nCacher执行Python脚本执行的代理数据库，启用了启用“外部脚本启用”选项的脚本执行。 请参阅Microsoft.Doc：启用外部脚本的服务器配置选项。\nService Broker是SQL服务器的可靠消息传递框架，有助于桥接Cacher-Agent和TransDB。 可以处理Cacher-Agent接收到的消息来更新缓存。\n\n\nPython是使用SQL 2017（CPT）的数据库系统的集成脚本语言\n\n解决方案的架构\n在我们的解决方案中，我们将在RESTful.Cache应用程序中缓存实体“产品类型名称”，并且WebApplication将具有创建新产品类型条目并从RESTful.Cache读取的功能。\n条件\n除此之外，还有一些先决条件和一些我们需要考虑的信息。\n\n存储CacheDB的SQL实例必须安装“具有Python的机器学习服务”\n要在CacheDB中使用TSQL执行Python脚本，应运行SQL Service MSSQLLaunchpad或SQL Server Launchpad。 请参阅Microsoft.Net：Microsoft机器学习服务\n\n使用SP_Configure启用外部脚本执行，请参阅Microsoft.Doc：启用外部脚本的服务器配置选项\n\n\nsp_configure 'external scripts enabled', 1; \nRECONFIGURE;\n\nTransDB和Cacher托管的环境应该在其实例上创建一个Service Broker端点，如果这两个端点独立托管在两个不同的SQL实例上，那么每个实例应该有自己的端点。\nTransDB和Cacher数据库应该启用代理。 请参阅Microsoft.Technet：如何：激活数据库中的Service Broker消息传递.aspx)\n\nALTER DATABASE TransDB SET ENABLE_BROKER;\nGO\n\n\nALTER DATABASE CacheDB SET ENABLE_BROKER;  GO\n.NET应用程序\nWebApplication有两个主要的MVC动作; 一个使用HTTP动词POST更新TransDB中的一个新实体，另一个使用HTTP动词GET从缓存返回产品类型列表的操作。\n\nRESTful.Cache有两种操作方法，一种是使用HTTP动词POST更新新添加的实体产品类型的缓存，另一种用于从本地缓存获取所有缓存的产品类型。\n\n对于我们的示例解决方案，这两个应用程序都在IIS中托管在各个应用程序池标识下，以保护应用程序安全 但是对于实际的系统实现，托管环境可以是内部网或互联网环境中的单个Web服务器。\n\nRESTful.Cache授权规则只有两个服务帐户来处理HTTP请求，即\n\nabc  WebApp_SVC和abc  CacherAgent_SVC。 abc  CacherAgent_SVC服务帐户允许SQL中的Python脚本通过HTTP到达应用程序来刷新缓存。\nabc  WebApp_SVC用户用于具有授权规则模式的WebApplication，以允许访问RESTful.Cache应用程序。\nSQL数据库和服务代理\nOLTP数据库TransDB有几个对象，包括表，存储过程和Service Broker对象。\n\nCacheIntegrationError表。\n有关Service Broker的更多信息，请访问Microsoft.DOC：SQL Server Service Broker\n\n对于我们的示例解决方案，TransDB是创建新的ProductType记录时创建更新缓存消息的源数据库，执行操作的消息，它具有UpdateMessage消息类型，CacheIntegration合同将CacheSource服务发送到目标数据库。该服务具有CacheQueue，由Service Broker组件用于执行可靠的消息传递。 ToCacheTarget路由具有将消息传递到其目标的信息。\n为了消除任何增加事务处理时间的机会以及避免事务数据库中其余数据的任何安全风险，我们将通过使用我们的示例解决方案中名为Cacher数据库的代理数据库来解除缓存更新过程。 Service Broker消息传递基础设施将有助于连接TransDB和Cacher数据库，基于事件的消息处理将使我们能够更新驻留在基于网络的系统上的缓存存储。 Cacher数据库正在扮演代理角色，以便在更新消息到达时执行缓存刷新。它通过执行Python脚本更新缓存。\n\nCacher数据库具有：\n\nCacheLog和CacheIntegrationError表，以跟踪缓存何时被刷新，并且具有在缓存刷新过程中可能发生的任何错误的记录。\n\nPerformCacheUpdate过程通过Service Broker从TransDB接收传入消息。如果消息的类型是UpdateMessage，那么它将执行另一个过程UpdateWebCache，执行Python脚本执行。\n\nUpdateWebCache过程的执行结果保存在表变量中，然后在消息对话结束时插入到CacheLog表中。\n当接收到的消息具有错误或结束消息类型时，过程也会结束会话，并且在错误类型上，将异常日志写入CacheIntegrationError表中。\n\n\nUpdateWebCache过程从作为参数传递的传入XML消息中提取Id和Name，并将这些值嵌入到Python脚本文本中。脚本执行结果集是类型为UpddateCacheLog的结构化表。\n\n\nCacher的Service Broker对象，主要是UpdateMessage消息类型和CacheIntegration契约与TransDB的相同，CacheQueue有一个称为PerfomCacheUpdate的激活过程，一个名为CacheTarget的服务，该路由具有有关TransDB服务CacheService和端点地址的信息。\n对于我们的示例解决方案，数据库队列的最大队列读取器设置为1。 如果需要，可以增加这一点，例如，如果数据修改很高，并且您需要增加缓存刷新率。\n服务代理端点\n对于我们的解决方案，数据库托管在同一个实例上，因此两者都使用相同的Service Broker Endpoint来发送和接收消息。\n\n但是，如果我们要在单个实例上托管数据库，那么每个SQL实例的服务帐户都应该有一个Service Broker端点。 并且这两个SQL实例都应该有权限允许将消息发送到对方的端点。 连接的授权和授予可以通过以下TSQL命令集完成。 请注意，在消息传递基础结构中，有一个发送方，另一方是接收方，正如所提到的，如果SQL实例是发送方和接收方的一部分，则每个实例都应该有自己的进程标识。 下图显示了每个SQL Server在其自身身份下运行的方式。\n\n这是用于在Cacher数据库的SQL实例中授权和授予端点连接到TransDB的SQL实例服务帐户[identity]的SQL代码。\n    ALTER AUTHORIZATION ON ENDPOINT::ServiceBrokerEndpoint TO [abc\\TransDB_SVC]\n  GO\n  GRANT CONNECT ON ENDPOINT::ServiceBrokerEndpoint TO [abc\\TransDB_SVC]\n  GO\n\n同样，这里是用于授权和授予端点连接到Cache SQL数据库SQL实例服务帐户[identity]的代码。\nALTER AUTHORIZATION ON ENDPOINT::ServiceBrokerEndpoint TO [abc\\CacherAgent_SVC]\n  GO\n  GRANT CONNECT ON ENDPOINT::ServiceBrokerEndpoint TO [abc\\CacherAgent_SVC]\n  GO\n\nPython脚本\n这是Python脚本文本，在TSQL变量@UpdateCache中保存为字符串。 它具有具有逻辑的UpdateCache方法，通过传递具有作为输入参数接收的Name和Id字段的数据对象来对RESTful.Cache执行HTTP POST调用。 它接收一个JSON对象，并将其作为方法的输出结果返回给调用者。\n在脚本结束时，返回的对象被转换为数组，因此可以将其结构化为SQL结果。\nDECLARE @UpdateCache NVARCHAR(MAX) = N'\nimport pandas as PND #data structure package\ndef UpdateCache(name,id):\n  import requests as HTTP #http request package\n  #Perfom HTTP POST to update cache\n  httpRequest = HTTP.post( http://localhost/RESTful.Cache/ProductType/UpdateCache ,{ Name :name, Id :id}) \n  cacheLog = httpRequest.json()\n  return cacheLog\n \n#Update cache and build log element\nlog = [UpdateCache( '+ @Name+' ,'+ CAST(@Id as VARCHAR(10)) +')]\n#Return data frame i.e. table structure from SQL\nOutputDataSet = PND.DataFrame(data=log)\n';\n\n在SQL Server中使用Python脚本时，有一些值得注意的事情。\n\n我们可以编写一个连续的脚本或将它们分组到我们在这个解决方案中所做的方法中。或者，我们可以创建一个内联类或创建一个包，并在命令提示符下使用PIP命令在python中导入它们。\n在这个MST的CPT版本中，import语句只能在它放置的范围内导入包，因此我们可以注意到ImportCache中存在导入请求import语句，并且import语句导入熊猫存在于脚本的顶部在脚本的最后。\n方法UpdateCache的输出对象立即转换为数组，这样pandas.DataFrame可以将对象转换成数据结构，SQL Server可以轻松地将其解释为具有行和列的表。\n分配给OutputDataSet对象的数据结构在SQL Server的TSQL执行上下文中可用。\n最后一行程序dbo.UpdateWebCache，WITH RESULT SETS（AS TYPE dbo.UpdateCacheLog）;具有用户定义的表类型dbo.UpdateCacheLog，它有助于保持底层列的顺序，并避免在从接收的数据结构生成结果集的过程中发生任何不匹配。另一种方法是在Python和结果集中构建映射列结构。\n\n数据库安全\nTransDB是一个OLTP数据库，我们不希望对系统发生任何安全漏洞，因此，通过我们的示例解决方案，这种数据库可以托管在未安装“机器学习服务”的SQL实例上。 Cacher是能够到达基于网络的系统的代理，因此可以保留在安装机器学习服务的SQL实例上。 两个SQL实例都可以具有单独的服务帐户身份，该身份已被授权仅连接到特定端口的Service Broker端点。 安全认证通信的另一种方法是使用证书。 对于Service Broker端点授权，请参阅Microsoft.Technet：如何：通过使用证书（Transact-SQL）允许服务代理程序网络访问.aspx)以获取更多详细信息。\n所有组件放在一起\n放置所有组件后，我们的WebApplication允许我们创建一个新的ProductType，并通过RESTful HTTP调用从刷新的缓存中列出相同的产品类型。 在墙后面有管理数据的组件，高速缓存对前端应用程序是不可见的。\n\n结论\n诸如电子商务，医疗电子治理等应用可以从良好的缓存实现中受益。通过扩展我们熟悉的技术的使用，我们可以获得易于维护的解决方案，而无需学习新框架或功能的成本。\n我们的示例解决方案符合我们所需要的\n\n当通过其中一个OLTP事务创建或修改数据时，系统刷新基于网络的缓存系统进行读取访问。\n它能够使用异步事件来刷新缓存，靠近实时。这不会影响原始交易的表现。\n它可以通过HTTP在事务和缓存系统之间绘制一条安全线，以保持数据在OLTP数据库中的安全。\n它具有最小的监控功能;一个缓存日志和异常日志，可以进一步加强构建管理控制台。\n使用Service Broker消息组件，解决方案足够灵活，可以在异步消息处理发生时触发或到达基于网络的系统。换句话说，数据库与SQL Service Broker消息集成在一起，并且基于接收到的数据，执行一个动作来获取或发送数据到外部数据层以外的系统。\n通过使用服务代理消息隔离外部系统触发专用数据库内的事件有助于保护OLTP数据库的事务和数据。\n\nThe source code for this project is available here in githib.https://github.com/hi10p/SQL17Python\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "2"}