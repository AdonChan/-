{"title": "使用机器学习识别出拍卖场中作弊的机器人用户 - Lancelot's Desert ", "index": "python,机器学习", "content": "Human or Robot\n本项目为kaggle上Facebook举行的一次比赛，地址见数据来源，完整代码见我的github,欢迎来玩~\n代码\n\n数据探索——Data_Exploration.ipynb\n数据预处理&特征工程——Feature_Engineering.ipynb & Feature_Engineering2.ipynb\n模型设计及评测——Model_Design.ipynb\n\n项目数据来源\nkaggle\n项目所需额外工具包\n\nnumpy\npandas\nmatplotlib\nsklearn\nxgboost\nlightgbm\nmlxtend: 含有聚和算法Stacking 项目整体运行时间预估为60min左右，在Ubuntu系统，8G内存，运行结果见所提交的jupyter notebook文件\n\n\n由于文章内容过长，所以分为两篇文章，总共包含四个部分\n\n数据探索\n数据预处理及特征工程\n模型设计\n评估及总结\n\n数据探索\nimport numpy as np\nimport pandas as pd\n%matplotlib inline\nfrom IPython.display import display\ndf_bids = pd.read_csv('bids.csv', low_memory=False)\ndf_train = pd.read_csv('train.csv')\ndf_test = pd.read_csv('test.csv')\ndf_bids.head()\n\n\n\n      bid_id\n      bidder_id\n      auction\n      merchandise\n      device\n      time\n      country\n      ip\n      url\n    \n\n\n0\n      0\n      8dac2b259fd1c6d1120e519fb1ac14fbqvax8\n      ewmzr\n      jewelry\n      phone0\n      9759243157894736\n      us\n      69.166.231.58\n      vasstdc27m7nks3\n    \n\n1\n      1\n      668d393e858e8126275433046bbd35c6tywop\n      aeqok\n      furniture\n      phone1\n      9759243157894736\n      in\n      50.201.125.84\n      jmqlhflrzwuay9c\n    \n\n2\n      2\n      aa5f360084278b35d746fa6af3a7a1a5ra3xe\n      wa00e\n      home goods\n      phone2\n      9759243157894736\n      py\n      112.54.208.157\n      vasstdc27m7nks3\n    \n\n3\n      3\n      3939ac3ef7d472a59a9c5f893dd3e39fh9ofi\n      jefix\n      jewelry\n      phone4\n      9759243157894736\n      in\n      18.99.175.133\n      vasstdc27m7nks3\n    \n\n4\n      4\n      8393c48eaf4b8fa96886edc7cf27b372dsibi\n      jefix\n      jewelry\n      phone5\n      9759243157894736\n      in\n      145.138.5.37\n      vasstdc27m7nks3\n    \n\n\ndf_train.head()\n# df_train.dtypes\n\n\n\n      bidder_id\n      payment_account\n      address\n      outcome\n    \n\n\n0\n      91a3c57b13234af24875c56fb7e2b2f4rb56a\n      a3d2de7675556553a5f08e4c88d2c228754av\n      a3d2de7675556553a5f08e4c88d2c228vt0u4\n      0.0\n    \n\n1\n      624f258b49e77713fc34034560f93fb3hu3jo\n      a3d2de7675556553a5f08e4c88d2c228v1sga\n      ae87054e5a97a8f840a3991d12611fdcrfbq3\n      0.0\n    \n\n2\n      1c5f4fc669099bfbfac515cd26997bd12ruaj\n      a3d2de7675556553a5f08e4c88d2c2280cybl\n      92520288b50f03907041887884ba49c0cl0pd\n      0.0\n    \n\n3\n      4bee9aba2abda51bf43d639013d6efe12iycd\n      51d80e233f7b6a7dfdee484a3c120f3b2ita8\n      4cb9717c8ad7e88a9a284989dd79b98dbevyi\n      0.0\n    \n\n4\n      4ab12bc61c82ddd9c2d65e60555808acqgos1\n      a3d2de7675556553a5f08e4c88d2c22857ddh\n      2a96c3ce94b3be921e0296097b88b56a7x1ji\n      0.0\n    \n\n\n异常数据检测\n# 查看各表格中是否存在空值\nprint 'Is there any missing value in bids?',df_bids.isnull().any().any()\nprint 'Is there any missing value in train?',df_train.isnull().any().any()\nprint 'Is there any missing value in test?',df_test.isnull().any().any()\nIs there any missing value in bids? True\nIs there any missing value in train? False\nIs there any missing value in test? False\n\n\n整个对三个数据集进行空值判断，发现用户数据训练集和测试集均无缺失数据，而在竞标行为数据集中存在缺失值的情况，下面便针对bids数据进一步寻找缺失值\n# nan_rows = df_bids[df_bids.isnull().T.any().T]\n# print nan_rows\npd.isnull(df_bids).any()\nbid_id         False\nbidder_id      False\nauction        False\nmerchandise    False\ndevice         False\ntime           False\ncountry         True\nip             False\nurl            False\ndtype: bool\n\nmissing_country = df_bids['country'].isnull().sum().sum()\nprint 'No. of missing country: ', missing_country\nnormal_country = df_bids['country'].notnull().sum().sum()\nprint 'No. of normal country: ', normal_country\nNo. of missing country:  8859\nNo. of normal country:  7647475\n\n\nimport matplotlib.pyplot as plt\nlabels = ['unknown', 'normal']\nsizes = [missing_country, normal_country]\nexplode = (0.1, 0)\nfig1, ax1 = plt.subplots()\nax1.pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%', shadow=True, startangle=90)\nax1.axis('equal')\nplt.title('Distribution of missing countries vs. normal countries')\nplt.show()\n\n综合上述的分析可以发现，在竞标行为用户的country一栏属性中存在很少一部分用户行为是没有country记录的，在预处理部分可以针对这部分缺失数据进行填充操作，有两种思路：\n\n针对原始行为数据按照用户分组后，看看每个对应的用户竞标时经常所位于的国家信息，对缺失值填充常驻国家\n针对原始行为数据按照用户分组后，按时间顺序对每组用户中的缺失值前向或后向填充相邻的国家信息\n\n# 查看各个数据的记录数\n# 看看数据的id是否是唯一标识\nprint df_bids.shape[0]\nprint len(df_bids['bid_id'].unique())\nprint df_train.shape[0]\nprint len(df_train['bidder_id'].unique())\nprint df_test.shape[0]\nprint len(df_test['bidder_id'].unique())\n7656334\n7656334\n2013\n2013\n4700\n4700\n\n\n# 简单统计各项基本特征（类别特征）的数目（除去时间）\nprint 'total bidder in bids: ', len(df_bids['bidder_id'].unique())\nprint 'total auction in bids: ', len(df_bids['auction'].unique())\nprint 'total merchandise in bids: ', len(df_bids['merchandise'].unique())\nprint 'total device in bids: ', len(df_bids['device'].unique())\nprint 'total country in bids: ', len(df_bids['country'].unique())\nprint 'total ip in bids: ', len(df_bids['ip'].unique())\nprint 'total url in bids: ', len(df_bids['url'].unique())\ntotal bidder in bids:  6614\ntotal auction in bids:  15051\ntotal merchandise in bids:  10\ntotal device in bids:  7351\ntotal country in bids:  200\ntotal ip in bids:  2303991\ntotal url in bids:  1786351\n\n\n由上述基本特征可以看到：\n\n竞标行为中的用户总数少于训练集+测试集的用户数，也就是说并不是一一对应的，接下来验证下竞标行为数据中的用户是否完全来自训练集和测试集\n商品类别和国家的种类相对其他特征较少，可以作为天然的类别特征提取出来进行处理，而其余的特征可能更多的进行计数统计\n\nlst_all_users = (df_train['bidder_id'].unique()).tolist() + (df_test['bidder_id'].unique()).tolist()\nprint 'total bidders of train and test set',len(lst_all_users)\nlst_bidder = (df_bids['bidder_id'].unique()).tolist()\nprint 'total bidders in bids set',len(lst_bidder)\nprint 'Is bidders in bids are all from train+test set? ',set(lst_bidder).issubset(set(lst_all_users))\ntotal bidders of train and test set 6713\ntotal bidders in bids set 6614\nIs bidders in bids are all from train+test set?  True\n\n\nlst_nobids = [i for i in lst_all_users if i not in lst_bidder]\nprint 'No. of bidders never bid: ',len(lst_nobids)\nlst_nobids_train = [i for i in lst_nobids if i in (df_train['bidder_id'].unique()).tolist()]\nlst_nobids_test = [i for i in lst_nobids if i in (df_test['bidder_id'].unique()).tolist()]\nprint 'No. of bidders never bid in train set: ',len(lst_nobids_train)\nprint 'No. of bidders never bid in test set: ',len(lst_nobids_test)\nNo. of bidders never bid:  99\nNo. of bidders never bid in train set:  29\nNo. of bidders never bid in test set:  70\n\n\ndata_source = ['train', 'test']\ny_pos = np.arange(len(data_source))\nnum_never_bids = [len(lst_nobids_train), len(lst_nobids_test)]\nplt.bar(y_pos, num_never_bids, align='center', alpha=0.5)\nplt.xticks(y_pos, data_source)\nplt.ylabel('bidders no bids')\nplt.title('Source of no bids bidders')\nplt.show()\n\nprint df_train[(df_train['bidder_id'].isin(lst_nobids_train)) & (df_train['outcome']==1.0)]\nEmpty DataFrame\nColumns: [bidder_id, payment_account, address, outcome]\nIndex: []\n\n\n由上述计算可知存在99个竞标者无竞标记录，其中29位来自训练集，70位来自测试集，而且这29位来自训练集的竞标者未被标记为机器人用户，所以可以针对测试集中的这70位用户后续标记为人类或者取平均值处理\n# check the partition of bots in train\nprint (df_train[df_train['outcome'] == 1].shape[0]*1.0) / df_train.shape[0] * 100,'%'\n5.11674118231 %\n\n\n训练集中的标记为机器人的用户占所有用户数目约5%\ndf_train.groupby('outcome').size().plot(labels=['Human', 'Robot'], kind='pie', autopct='%.2f', figsize=(4, 4), \n                                        title='Distribution of Human vs. Robots', legend=True)\n\n<matplotlib.axes._subplots.AxesSubplot at 0x7f477135c5d0>\n\n\n由上述训练集中的正负例分布可以看到本数据集正负例比例失衡，所以后续考虑使用AUC（不受正负例比例影响）作为评价指标，此外尽量采用Gradient Boosting族模型来进行训练\n数据预处理与特征工程\nimport numpy as np\nimport pandas as pd\nimport pickle\n%matplotlib inline\nfrom IPython.display import display\nbids = pd.read_csv('bids.csv')\ntrain = pd.read_csv('train.csv')\ntest = pd.read_csv('test.csv')\n处理缺失数据\n针对前面数据探索部分所发现的竞标行为数据中存在的国家属性缺失问题，考虑使用针对原始行为数据按照用户分组后，按时间顺序对每组用户中的缺失值前向或后向填充相邻的国家信息的方法来进行缺失值的填充处理\ndisplay(bids.head())\n\n\n\n      bid_id\n      bidder_id\n      auction\n      merchandise\n      device\n      time\n      country\n      ip\n      url\n    \n\n\n0\n      0\n      8dac2b259fd1c6d1120e519fb1ac14fbqvax8\n      ewmzr\n      jewelry\n      phone0\n      9759243157894736\n      us\n      69.166.231.58\n      vasstdc27m7nks3\n    \n\n1\n      1\n      668d393e858e8126275433046bbd35c6tywop\n      aeqok\n      furniture\n      phone1\n      9759243157894736\n      in\n      50.201.125.84\n      jmqlhflrzwuay9c\n    \n\n2\n      2\n      aa5f360084278b35d746fa6af3a7a1a5ra3xe\n      wa00e\n      home goods\n      phone2\n      9759243157894736\n      py\n      112.54.208.157\n      vasstdc27m7nks3\n    \n\n3\n      3\n      3939ac3ef7d472a59a9c5f893dd3e39fh9ofi\n      jefix\n      jewelry\n      phone4\n      9759243157894736\n      in\n      18.99.175.133\n      vasstdc27m7nks3\n    \n\n4\n      4\n      8393c48eaf4b8fa96886edc7cf27b372dsibi\n      jefix\n      jewelry\n      phone5\n      9759243157894736\n      in\n      145.138.5.37\n      vasstdc27m7nks3\n    \n\n\n# pd.algos.is_monotonic_int64(bids.time.values, True)[0]\nprint 'Is the time monotonically non-decreasing? ', pd.Index(bids['time']).is_monotonic\nIs the time monotonically non-decreasing?  False\n\n\n# bidder_group = bids.sort_values(['bidder_id', 'time']).groupby('bidder_id')\nbids['country'] = bids.sort_values(['bidder_id', 'time']).groupby('bidder_id')['country'].ffill()\nbids['country'] = bids.sort_values(['bidder_id', 'time']).groupby('bidder_id')['country'].bfill()\ndisplay(bids.head())\n\n\n\n      bid_id\n      bidder_id\n      auction\n      merchandise\n      device\n      time\n      country\n      ip\n      url\n    \n\n\n0\n      0\n      8dac2b259fd1c6d1120e519fb1ac14fbqvax8\n      ewmzr\n      jewelry\n      phone0\n      9759243157894736\n      us\n      69.166.231.58\n      vasstdc27m7nks3\n    \n\n1\n      1\n      668d393e858e8126275433046bbd35c6tywop\n      aeqok\n      furniture\n      phone1\n      9759243157894736\n      in\n      50.201.125.84\n      jmqlhflrzwuay9c\n    \n\n2\n      2\n      aa5f360084278b35d746fa6af3a7a1a5ra3xe\n      wa00e\n      home goods\n      phone2\n      9759243157894736\n      py\n      112.54.208.157\n      vasstdc27m7nks3\n    \n\n3\n      3\n      3939ac3ef7d472a59a9c5f893dd3e39fh9ofi\n      jefix\n      jewelry\n      phone4\n      9759243157894736\n      in\n      18.99.175.133\n      vasstdc27m7nks3\n    \n\n4\n      4\n      8393c48eaf4b8fa96886edc7cf27b372dsibi\n      jefix\n      jewelry\n      phone5\n      9759243157894736\n      in\n      145.138.5.37\n      vasstdc27m7nks3\n    \n\n\nprint 'Is there any missing value in bids?',bids.isnull().any().any()\n# pickle.dump(bids, open('bids.pkl', 'w'))\nIs there any missing value in bids? True\n\n\nmissing_country = bids['country'].isnull().sum().sum()\nprint 'No. of missing country: ', missing_country\nnormal_country = bids['country'].notnull().sum().sum()\nprint 'No. of normal country: ', normal_country\nNo. of missing country:  5\nNo. of normal country:  7656329\n\n\nnan_rows = bids[bids.isnull().T.any().T]\nprint nan_rows\n          bid_id                              bidder_id auction  \\\n1351177  1351177  f3ab8c9ecc0d021ebc81e89f20c8267bn812w   jefix   \n2754184  2754184  88ef9cfdbec4c9e33f6c2e0b512e7a01dp2p2   cc5fs   \n2836631  2836631  29b8af2fea3881ef61911612372dac41vczqv   jqx39   \n3125892  3125892  df20f216cbb0b0df5a7b2e94b16a7853iyw9g   jqx39   \n5153748  5153748  5e05ec450e2dd64d7996a08bbbca4f126nzzk   jqx39   \n\n              merchandise    device              time country  \\\n1351177  office equipment   phone84  9767200789473684     NaN   \n2754184            mobile  phone150  9633363947368421     NaN   \n2836631           jewelry   phone72  9634034894736842     NaN   \n3125892   books and music  phone106  9635755105263157     NaN   \n5153748            mobile  phone267  9645270210526315     NaN   \n\n                      ip              url  \n1351177   80.211.119.111  g9pgdfci3yseml5  \n2754184     20.67.240.88  ctivbfq55rktail  \n2836631  149.210.107.205  vasstdc27m7nks3  \n3125892      26.23.62.59  ac9xlqtfg0cx5c5  \n5153748     145.7.194.40  0em0vg1f0zuxonw  \n\n\n# print bids[bids['bid_id']==1351177]\nnan_bidder = nan_rows['bidder_id'].values.tolist()\n# print nan_bidder\nprint bids[bids['bidder_id'].isin(nan_bidder)]\n          bid_id                              bidder_id auction  \\\n1351177  1351177  f3ab8c9ecc0d021ebc81e89f20c8267bn812w   jefix   \n2754184  2754184  88ef9cfdbec4c9e33f6c2e0b512e7a01dp2p2   cc5fs   \n2836631  2836631  29b8af2fea3881ef61911612372dac41vczqv   jqx39   \n3125892  3125892  df20f216cbb0b0df5a7b2e94b16a7853iyw9g   jqx39   \n5153748  5153748  5e05ec450e2dd64d7996a08bbbca4f126nzzk   jqx39   \n\n              merchandise    device              time country  \\\n1351177  office equipment   phone84  9767200789473684     NaN   \n2754184            mobile  phone150  9633363947368421     NaN   \n2836631           jewelry   phone72  9634034894736842     NaN   \n3125892   books and music  phone106  9635755105263157     NaN   \n5153748            mobile  phone267  9645270210526315     NaN   \n\n                      ip              url  \n1351177   80.211.119.111  g9pgdfci3yseml5  \n2754184     20.67.240.88  ctivbfq55rktail  \n2836631  149.210.107.205  vasstdc27m7nks3  \n3125892      26.23.62.59  ac9xlqtfg0cx5c5  \n5153748     145.7.194.40  0em0vg1f0zuxonw  \n\n\n在对整体数据的部分用户缺失国家的按照各个用户分组后在时间上前向和后向填充后，仍然存在5个用户缺失了国家信息，结果发现这5个用户是仅有一次竞标行为，下面看看这5个用户还有什么特征\nlst_nan_train = [i for i in nan_bidder if i in (train['bidder_id'].unique()).tolist()]\nlst_nan_test = [i for i in nan_bidder if i in (test['bidder_id'].unique()).tolist()]\nprint 'No. of bidders 1 bid in train set: ',len(lst_nan_train)\nprint 'No. of bidders 1 bid in test set: ',len(lst_nan_test)\nNo. of bidders 1 bid in train set:  1\nNo. of bidders 1 bid in test set:  4\n\n\nprint train[train['bidder_id']==lst_nan_train[0]]['outcome']\n546    0.0\nName: outcome, dtype: float64\n\n\n由于这5个用户仅有一次竞标行为，而且其中1个用户来自训练集，4个来自测试集，由训练集用户的标记为人类，加上行为数太少，所以考虑对这5个用户的竞标行为数据予以舍弃，特别对测试集的4个用户后续操作类似之前对无竞标行为的用户，预测值填充最终模型的平均预测值\nbid_to_drop = nan_rows.index.values.tolist()\n# print bid_to_drop\nbids.drop(bids.index[bid_to_drop], inplace=True)\nprint 'Is there any missing value in bids?',bids.isnull().any().any()\npickle.dump(bids, open('bids.pkl', 'w'))\nIs there any missing value in bids? False\n\n\n统计基本的计数特征\n根据前面的数据探索，由于数据集大部分由类别数据或者离散型数据构成，所以首先针对竞标行为数据按照竞标者分组统计其各项属性的数目，比如使用设备种类，参与竞标涉及国家，ip种类等等\n# group by bidder to do some statistics\nbidders = bids.groupby('bidder_id')\n# pickle.dump(bids, open('bidders.pkl', 'w'))\n# print bidders['device'].count()\ndef feature_count(group):\n    dct_cnt = {}\n    dct_cnt['devices_c'] = group['device'].unique().shape[0]\n    dct_cnt['countries_c'] = group['country'].unique().shape[0]\n    dct_cnt['ip_c'] = group['ip'].unique().shape[0]\n    dct_cnt['url_c'] = group['url'].unique().shape[0]    \n    dct_cnt['auction_c'] = group['auction'].unique().shape[0]\n    dct_cnt['auc_mean'] = np.mean(group['auction'].value_counts())    # bids_c/auction_c\n#     dct_cnt['dev_mean'] = np.mean(group['device'].value_counts())    # bids_c/devices_c\n    dct_cnt['merch_c'] = group['merchandise'].unique().shape[0]\n    dct_cnt['bids_c'] = group.shape[0]\n    dct_cnt = pd.Series(dct_cnt)\n    return dct_cnt\ncnt_bidder = bidders.apply(feature_count)\ndisplay(cnt_bidder.describe())\n# cnt_bidder.to_csv('cnt_bidder.csv')\n# print cnt_bidder[cnt_bidder['merch_c']==2]\n\n\n\n      auc_mean\n      auction_c\n      bids_c\n      countries_c\n      devices_c\n      ip_c\n      merch_c\n      url_c\n    \n\n\ncount\n      6609.000000\n      6609.000000\n      6609.000000\n      6609.000000\n      6609.000000\n      6609.000000\n      6609.000000\n      6609.000000\n    \n\nmean\n      6.593493\n      57.850810\n      1158.470117\n      12.733848\n      73.492359\n      544.507187\n      1.000151\n      290.964140\n    \n\nstd\n      30.009242\n      131.814053\n      9596.595169\n      22.556570\n      172.171106\n      3370.730666\n      0.012301\n      2225.912425\n    \n\nmin\n      1.000000\n      1.000000\n      1.000000\n      1.000000\n      1.000000\n      1.000000\n      1.000000\n      1.000000\n    \n\n25%\n      1.000000\n      2.000000\n      3.000000\n      1.000000\n      2.000000\n      2.000000\n      1.000000\n      1.000000\n    \n\n50%\n      1.677419\n      10.000000\n      18.000000\n      3.000000\n      8.000000\n      12.000000\n      1.000000\n      5.000000\n    \n\n75%\n      4.142857\n      47.000000\n      187.000000\n      12.000000\n      57.000000\n      111.000000\n      1.000000\n      36.000000\n    \n\nmax\n      1327.366667\n      1726.000000\n      515033.000000\n      178.000000\n      2618.000000\n      111918.000000\n      2.000000\n      81376.000000\n    \n\n\n特征相关性\n在对竞标行为数据按照用户分组后，对数据集中的每一个产品特征构建一个散布矩阵（scatter matrix），来看看各特征之间的相关性\n# 对于数据中的每一对特征构造一个散布矩阵\npd.scatter_matrix(cnt_bidder, alpha = 0.3, figsize = (16,10), diagonal = 'kde');\n\n在针对竞标行为数据按照竞标用户进行分组基本统计后由上表可以看出，此时并未考虑时间戳的情形下，有以下基本结论：\n\n由各项统计的最大值与中位值，75%值的比较可以看到除了商品类别一项，其他的几项多少都存在一些异常数值，或许可以作为异常行为进行观察\n各特征的倾斜度很大，考虑对特征进行取对数的操作，并再次输出散布矩阵看看相关性。\n商品类别计数这一特征的方差很小，而且从中位数乃至75%的统计来看，大多数用户仅对同一类别商品进行拍卖，而且因为前面数据探索部分发现商品类别本身适合作为类别数据，所以考虑分多个类别进行单独统计，而在计数特征中舍弃该特征。\n\ncnt_bidder.drop('merch_c', axis=1, inplace=True)\ncnt_bidder = np.log(cnt_bidder)\npd.scatter_matrix(cnt_bidder, alpha = 0.3, figsize = (16,10), diagonal = 'kde');\n\n由上面的散布矩阵可以看到，个行为特征之间并没有表现出很强的相关性，虽然其中的ip计数和竞标计数，设备计数在进行对数操作处理之后表现出轻微的正相关性，但是由于是在做了对数操作之后才体现，而且从图中可以看到并非很强的相关性，所以保留这三个特征。\n针对前述的异常行为，先从原train数据集中的机器人、人类中分别挑选几个样本进行追踪观察他们在按照bidders分组后的统计结果，对比看看\ncnt_bidder.to_csv('cnt_bidder.csv')\n# trace samples,first 2 bots, last 2 humen\nindices = ['9434778d2268f1fa2a8ede48c0cd05c097zey','aabc211b4cf4d29e4ac7e7e361371622pockb',\n           'd878560888b11447e73324a6e263fbd5iydo1','91a3c57b13234af24875c56fb7e2b2f4rb56a']\n\n# build a DataFrame for the choosed indices\nsamples = pd.DataFrame(cnt_bidder.loc[indices], columns = cnt_bidder.keys()).reset_index(drop = True)\nprint \"Chosen samples of training dataset:(first 2 bots, last 2 humen)\"\ndisplay(samples)\nChosen samples of training dataset:(first 2 bots, last 2 humen)\n\n\n\n\n\n      auc_mean\n      auction_c\n      bids_c\n      countries_c\n      devices_c\n      ip_c\n      url_c\n    \n\n\n0\n      3.190981\n      5.594711\n      8.785692\n      4.174387\n      6.011267\n      8.147578\n      7.557995\n    \n\n1\n      2.780432\n      4.844187\n      7.624619\n      2.639057\n      3.178054\n      5.880533\n      1.609438\n    \n\n2\n      0.287682\n      1.098612\n      1.386294\n      1.098612\n      1.386294\n      1.386294\n      0.000000\n    \n\n3\n      0.287682\n      2.890372\n      3.178054\n      1.791759\n      2.639057\n      2.995732\n      0.000000\n    \n\n\n使用seaborn来对上面四个例子的热力图进行可视化，看看percentile的情况\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# look at percentile ranks\npcts = 100. * cnt_bidder.rank(axis=0, pct=True).loc[indices].round(decimals=3)\nprint pcts\n\n# visualize percentiles with heatmap\nsns.heatmap(pcts, yticklabels=['robot 1', 'robot 2', 'human 1', 'human 2'], annot=True, linewidth=.1, vmax=99, \n            fmt='.1f', cmap='YlGnBu')\nplt.title('Percentile ranks of\\nsamples\\' feature statistics')\nplt.xticks(rotation=45, ha='center');\n                                       auc_mean  auction_c  bids_c  \\\nbidder_id                                                            \n9434778d2268f1fa2a8ede48c0cd05c097zey      94.9       94.6    97.0   \naabc211b4cf4d29e4ac7e7e361371622pockb      92.4       87.2    92.3   \nd878560888b11447e73324a6e263fbd5iydo1      39.8       30.4    30.2   \n91a3c57b13234af24875c56fb7e2b2f4rb56a      39.8       60.2    53.0   \n\n                                       countries_c  devices_c  ip_c  url_c  \nbidder_id                                                                   \n9434778d2268f1fa2a8ede48c0cd05c097zey         95.4       95.6  96.7   97.4  \naabc211b4cf4d29e4ac7e7e361371622pockb         77.3       63.8  84.8   50.3  \nd878560888b11447e73324a6e263fbd5iydo1         48.8       38.7  34.2   13.4  \n91a3c57b13234af24875c56fb7e2b2f4rb56a         63.7       56.8  56.2   13.4  \n\n\n\n由上面的热力图对比可以看到，机器人的各项统计指标除去商品类别上的统计以外，均比人类用户要高，所以考虑据此设计基于基本统计指标规则的基准模型，其中最显著的特征差异应该是在auc_mean一项即用户在各个拍卖场的平均竞标次数，不妨先按照异常值处理的方法来找出上述基础统计中的异常情况\n设计朴素分类器\n由于最终目的是从竞标者中寻找到机器人用户，而根据常识，机器人用户的各项竞标行为的操作应该比人类要频繁许多，所以可以从异常值检验的角度来设计朴素分类器，根据之前针对不同用户统计的基本特征计数情况，可以先针对每一个特征找出其中的疑似异常用户列表，最后整合各个特征生成的用户列表，认为超过多个特征异常的用户为机器人用户。\n# find the outliers for each feature\nlst_outlier = []\nfor feature in cnt_bidder.keys():\n    # percentile  25th\n    Q1 = np.percentile(cnt_bidder[feature], 25)\n    # percentile  75th\n    Q3 = np.percentile(cnt_bidder[feature], 75)\n    step = 1.5 * (Q3 - Q1)    \n    # show outliers\n    # print \"Data points considered outliers for the feature '{}':\".format(feature)\n    display(cnt_bidder[~((cnt_bidder[feature] >= Q1 - step) & (cnt_bidder[feature] <= Q3 + step))])\n    lst_outlier += cnt_bidder[~((cnt_bidder[feature] >= Q1 - step) & (cnt_bidder[feature] <= Q3 + step))].index.values.tolist()\n再找到各种特征的所有可能作为‘异常值’的用户id之后，可以对其做一个基本统计，进一步找出其中超过某几个特征值均异常的用户，经过测试，考虑到原始train集合里bots用户不到5%，所以最终确定以不低于1个特征值均异常的用户作为异常用户的一个假设，由此与train集合里的用户进行交叉，可以得到一个用户子集，可以作为朴素分类器的一个操作方法。\n# print len(lst_outlier)\nfrom collections import Counter\nfreq_outlier = dict(Counter(lst_outlier))\nperhaps_outlier = [i for i in freq_outlier if freq_outlier[i] >= 1]\nprint len(perhaps_outlier)\n214\n\n\n# basic_pred = test[test['bidder_id'].isin(perhaps_outlier)]['bidder_id'].tolist()\ntrain_pred = train[train['bidder_id'].isin(perhaps_outlier)]['bidder_id'].tolist()\nprint len(train_pred)\n76\n\n\n设计评价指标\n根据前面数据探索知本实验中的数据集的正负例比例约为19:1，有些失衡，所以考虑使用auc这种不受正负例比例影响的评价指标作为衡量标准，现针对所涉及的朴素分类器在原始训练集上的表现得到一个基准得分\nfrom sklearn.metrics import roc_auc_score\ny_true = train['outcome']\nnaive_pred = pd.DataFrame(columns=['bidder_id', 'prediction'])\nnaive_pred['bidder_id'] = train['bidder_id']\nnaive_pred['prediction'] = np.where(naive_pred['bidder_id'].isin(train_pred), 1.0, 0.0)\nbasic_pred = naive_pred['prediction']\nprint roc_auc_score(y_true, basic_pred)\n0.54661464952\n\n\n在经过上述对基本计数特征的统计之后，目前尚未针对非类别特征：时间戳进行处理，而在之前的数据探索过程中，针对商品类别和国家这两个类别属性，可以将原始的单一特征转换为多个特征分别统计，此外，在上述分析过程中，我们发现针对用户分组可以进一步对于拍卖场进行分组统计。\n\n对时间戳进行处理\n针对商品类别、国家转换为多个类别分别进行统计\n按照用户-拍卖场进行分组进一步统计\n\n对时间戳进行处理\n主要是分析各个竞标行为的时间间隔，即统计竞标行为表中在同一拍卖场的各个用户之间的竞标行为间隔\n然后针对每个用户对其他用户的时间间隔计算\n\n时间间隔均值\n时间间隔最大值\n时间间隔最小值\n\nfrom collections import defaultdict\n\ndef generate_timediff():    \n    bids_grouped = bids.groupby('auction')\n    bds = defaultdict(list)\n    last_row = None\n\n    for bids_auc in bids_grouped:\n        for i, row in bids_auc[1].iterrows():\n            if last_row is None:\n                last_row = row\n                continue\n\n            time_difference = row['time'] - last_row['time']\n            bds[row['bidder_id']].append(time_difference)\n            last_row = row\n\n    df = []\n    for key in bds.keys():\n        df.append({'bidder_id': key, 'mean': np.mean(bds[key]),\n                   'min': np.min(bds[key]), 'max': np.max(bds[key])})\n\n    pd.DataFrame(df).to_csv('tdiff.csv', index=False)\ngenerate_timediff()\n由于内容长度超过限制，后续内容请移步使用机器学习识别出拍卖场中作弊的机器人用户(二)\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "4"}