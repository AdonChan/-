{"title": "ansible2.0  playbook api运维应用 ", "index": "ansible ansible2.0", "content": "写在前面：\nansible是一个非常棒的运维工具，可以远程批量执行命令、上传文件等自动化运维操作，由于要搞配置管理，初始化等批量操作，而自己对ansible相对熟悉,因此选择了ansible playbook。不过在调用playbook api的过程中，发现原始api并不能满足我的需求，网络上多数文档还是1.0版本，因此下载了2.0源码查看，重写了部分类。因此这里总结学习，也给有相同需求的朋友参考\nansible-playbook使用\n一、ansible-playbook简单介绍\nplaybook字面意思看就是剧本，其实也很形象，ansible-playbook就是事先定义好很多task(任务)放在.yml文件中，执行的时候就像剧本一样，依次往下演(执行)\n#/tmp/xx.yml\n\n---\n- hosts: all    #hosts中指定\n\n  tasks:\n    - name: \"ls /tmp\"         #- name:任务名称,下面是任务过程\n      shell: 'ls /tmp/'\nansible-playbook执行:\n\n二、ansible-playbook api介绍\nansible-playbook api由ansible官方提供接口，用于在python代码中更灵活的使用，但官方只提供了ansible-api的参考文档,且2.0以后变化较大，api编写更复杂，但更为灵活\n官方参考: http://docs.ansible.com/ansib...\n一个基本的ansible-playbook api调用\n# -*- coding:utf-8 -*-\n# 描述:\n# V1 WZJ 2016-12-20\nfrom collections import namedtuple\nfrom ansible.parsing.dataloader import DataLoader\nfrom ansible.vars import VariableManager\nfrom ansible.inventory import Inventory\nfrom ansible.executor.playbook_executor import PlaybookExecutor\n\n# 用来加载解析yaml文件或JSON内容,并且支持vault的解密\nloader = DataLoader()\n    \n# 管理变量的类，包括主机，组，扩展等变量，之前版本是在 inventory中的\nvariable_manager = VariableManager()\n\n# 根据inventory加载对应变量,此处host_list参数可以有两种格式：\n# 1: hosts文件(需要),\n# 2: 可以是IP列表,此处使用IP列表\ninventory = Inventory(loader=loader, variable_manager=variable_manager,host_list=['172.16.1.121'])\nvariable_manager.set_inventory(inventory)\n\n# 设置密码,需要是dict类型\npasswords=dict(conn_pass='your password')\n\n# 初始化需要的对象\nOptions = namedtuple('Options',\n                     ['connection',\n                      'remote_user',\n                      'ask_sudo_pass',\n                      'verbosity',\n                      'ack_pass', \n                      'module_path', \n                      'forks', \n                      'become', \n                      'become_method', \n                      'become_user', \n                      'check',\n                      'listhosts', \n                      'listtasks', \n                      'listtags',\n                      'syntax',\n                      'sudo_user',\n                      'sudo'])\n# 初始化需要的对象\noptions = Options(connection='smart', \n                       remote_user='root',\n                       ack_pass=None,\n                       sudo_user='root',\n                       forks=5,\n                       sudo='yes',\n                       ask_sudo_pass=False,\n                       verbosity=5,\n                       module_path=None,  \n                       become=True, \n                       become_method='sudo', \n                       become_user='root', \n                       check=None,\n                       listhosts=None,\n                       listtasks=None, \n                       listtags=None, \n                       syntax=None)\n\n# playbooks就填写yml文件即可,可以有多个,以列表形式\nplaybook = PlaybookExecutor(playbooks=['/tmp/xx.yml'],inventory=inventory,\n              variable_manager=variable_manager,\n              loader=loader,options=options,passwords=passwords)\n# 开始执行\nplaybook.run()\n执行上面脚本：\n\n可以发现,这个api调用执行虽然成功了，但是并没有什么详细输出(这个跟一个名叫CallbackBase的类有关)\n重写palybook api\n1 为什么重写？在实际应用中，有许多地方是不太满足需求的1.比如inventory有host group(主机组)的概念，但是默认都放在all组里面去了，导致在编写yml的时候，无法对不同IP组进行不同的操作2.console输出结果有时候需要自定义3.调用api需要更为灵活\n当然除了以上需求外，还有一些其它意义，比如阅读源码有助于熟悉ansible的工作方式，也提升自己的脚本能力\n注意：所谓重写只是在源码的基础上继承并修改了部分代码，有可能导致ansible不稳定的情况，另外只有在有中文注释的地方才是重写内容\n2 ansible源码文件简单介绍源码下载地址：https://github.com/ansible/an...\n其实ansible我们所用到的源码都在lib里面，而需要关注的也主要是三个文件夹和一些类:\n\n用于解析和聚合host,group等环境变量: lib/ansible/inventory/__init__.py 中 Inventory 类\n用于console输出: lib/ansible/plugins/callback/default.py 中 CallbackModule 类\n用于playbook的解析工作: lib/executor/playbook_executor.py 中 PlaybookExecutor 类\nplaybook底层用到的任务队列：lib/executor/task_queue_manager.py 中 TaskQueueManager 类\n\n几个重写的类的树状图：\n一、Inventory类重写\n1.修改可以为IP传入group name2.额外的自定义参数，如：{\"test\":1000}\n# -*- coding:utf-8 -*-\n# 描述:\n# V1 WZJ 2016-12-20 Inventory重写封装api基本功能\nimport fnmatch\n\nfrom ansible.compat.six import string_types, iteritems\n\nfrom ansible import constants as C\nfrom ansible.errors import AnsibleError\n\nfrom ansible.inventory.dir import InventoryDirectory, get_file_parser\nfrom ansible.inventory.group import Group\nfrom ansible.inventory.host import Host\nfrom ansible.module_utils._text import to_bytes, to_text\nfrom ansible.parsing.utils.addresses import parse_address\nfrom ansible.plugins import vars_loader\nfrom ansible.utils.vars import combine_vars\nfrom ansible.utils.path import unfrackpath\n\ntry:\n    from __main__ import display\nexcept ImportError:\n    from ansible.utils.display import Display\n    display = Display()\n\nHOSTS_PATTERNS_CACHE = {}\nfrom ansible.inventory import Inventory\nclass YunweiInventory(Inventory):\n    '''重写Inventory'''\n    def __init__(self, loader, variable_manager, group_name, ext_vars=None,host_list=C.DEFAULT_HOST_LIST):\n\n        # the host file file, or script path, or list of hosts\n        # if a list, inventory data will NOT be loaded\n        # self.host_list = unfrackpath(host_list, follow=False)\n        # 传入的hosts\n        self.host_list  = host_list\n        # 传入的项目名也是组名\n        self.group_name = group_name\n        # 传入的外部变量,格式为字典\n        self.ext_vars   = ext_vars\n        # caching to avoid repeated calculations, particularly with\n        # external inventory scripts.\n\n        self._vars_per_host    = {}\n        self._vars_per_group   = {}\n        self._hosts_cache      = {}\n        self._pattern_cache    = {}\n        self._group_dict_cache = {}\n        self._vars_plugins     = []\n\n        self._basedir = self.basedir()\n\n        # Contains set of filenames under group_vars directories\n        self._group_vars_files = self._find_group_vars_files(self._basedir)\n        self._host_vars_files = self._find_host_vars_files(self._basedir)\n\n        # to be set by calling set_playbook_basedir by playbook code\n        self._playbook_basedir = None\n\n        # the inventory object holds a list of groups\n        self.groups = {}\n\n        # a list of host(names) to contain current inquiries to\n        self._restriction = None\n        self._subset = None\n\n        # clear the cache here, which is only useful if more than\n        # one Inventory objects are created when using the API directly\n        self.clear_pattern_cache()\n        self.clear_group_dict_cache()\n\n        self.parse_inventory(host_list)\n\n    def parse_inventory(self, host_list):\n    \n        if isinstance(host_list, string_types):\n            if \",\" in host_list:\n                host_list = host_list.split(\",\")\n                host_list = [ h for h in host_list if h and h.strip() ]\n    \n        self.parser = None\n    \n        # Always create the 'all' and 'ungrouped' groups, even if host_list is\n        # empty: in this case we will subsequently an the implicit 'localhost' to it.\n    \n        ungrouped = Group('ungrouped')\n        all = Group('all')\n        all.add_child_group(ungrouped)\n    \n        # 加一个本地IP\n        local_group = Group('local')\n    \n        # 自定义组名\n        zdy_group_name = Group(self.group_name)\n        self.groups = {self.group_name:zdy_group_name,\"all\":all,\"ungrouped\":ungrouped,\"local\":local_group}\n        #self.groups = dict(all=all, ungrouped=ungrouped)\n    \n        if host_list is None:\n            pass\n        elif isinstance(host_list, list):\n            # 默认添加一个本地IP\n            (lhost, lport) = parse_address('127.0.0.1', allow_ranges=False)\n            new_host = Host(lhost, lport)\n            local_group.add_host(new_host)\n    \n            for h in host_list:\n                try:\n                    (host, port) = parse_address(h, allow_ranges=False)\n                except AnsibleError as e:\n                    display.vvv(\"Unable to parse address from hostname, leaving unchanged: %s\" % to_text(e))\n                    host = h\n                    port = None\n    \n                new_host = Host(host, port)\n                if h in C.LOCALHOST:\n                    # set default localhost from inventory to avoid creating an implicit one. Last localhost defined 'wins'.\n                    if self.localhost is not None:\n                        display.warning(\"A duplicate localhost-like entry was found (%s). First found localhost was %s\" % (h, self.localhost.name))\n                    display.vvvv(\"Set default localhost to %s\" % h)\n                    self.localhost = new_host\n                # 为组添加host\n                zdy_group_name.add_host(new_host)\n                # 为主机组添加额外参数\n                # 添加外部变量\n                if self.ext_vars and isinstance(self.ext_vars,dict):\n                    for k,v in self.ext_vars.items():\n                        zdy_group_name.set_variable(k,v)\n                        local_group.set_variable(k,v)\n    \n        elif self._loader.path_exists(host_list):\n            # TODO: switch this to a plugin loader and a 'condition' per plugin on which it should be tried, restoring 'inventory pllugins'\n            if self.is_directory(host_list):\n                # Ensure basedir is inside the directory\n                host_list = os.path.join(self.host_list, \"\")\n                self.parser = InventoryDirectory(loader=self._loader, groups=self.groups, filename=host_list)\n            else:\n                self.parser = get_file_parser(host_list, self.groups, self._loader)\n                vars_loader.add_directory(self._basedir, with_subdir=True)\n    \n            if not self.parser:\n                # should never happen, but JIC\n                raise AnsibleError(\"Unable to parse %s as an inventory source\" % host_list)\n        else:\n            display.warning(\"Host file not found: %s\" % to_text(host_list))\n    \n        self._vars_plugins = [ x for x in vars_loader.all(self) ]\n    \n        # set group vars from group_vars/ files and vars plugins\n        for g in self.groups:\n            group = self.groups[g]\n            group.vars = combine_vars(group.vars, self.get_group_variables(group.name))\n            self.get_group_vars(group)\n    \n        # get host vars from host_vars/ files and vars plugins\n        for host in self.get_hosts(ignore_limits=True, ignore_restrictions=True):\n            host.vars = combine_vars(host.vars, self.get_host_variables(host.name))\n            self.get_host_vars(host)\n\n二、collback重写，用于自定义输出\n1.以callback.default.CallbackModule为基类继承2.自定义了输出格式,正确输出情况，不需要的输出就忽略了，只留下几个有用的stdout3.最后的输出结果：\n\n#-*- coding:utf-8 -*-\n# 描述:\n# V1 WZJ 2016-12-19 CallBack重写封装api基本功能,用于console输出\n\nimport json\nfrom ansible import constants as C\nfrom ansible.plugins.callback.default import CallbackModule\n\ntry:\n    from __main__ import display\nexcept ImportError:\n    from ansible.utils.display import Display\n    display = Display()\n\nclass YunweiCallback(CallbackModule):\n    \"\"\"重写console输出日志\"\"\"\n\n    # 重写2.0版本正确stdout\n    def v2_runner_on_ok(self, result):\n\n        if self._play.strategy == 'free' and self._last_task_banner != result._task._uuid:\n            self._print_task_banner(result._task)\n\n        self._clean_results(result._result, result._task.action)\n        #delegated_vars = result._result.get('_ansible_delegated_vars', None)\n        delegated_vars = self._dump_results(result._result)\n        #delegated_vars = result._result\n        #n_delegated_vars = self._dump_results(result)\n        #print n_delegated_vars\n        self._clean_results(result._result, result._task.action)\n        if result._task.action in ('include', 'include_role'):\n            return\n        elif result._result.get('changed', False):\n            if delegated_vars:\n                # 自定义输出\n                zdy_msg = self.zdy_stdout(json.loads(delegated_vars))\n                if zdy_msg:\n                    msg = \"changed: [%s]%s\" % (result._host.get_name(), zdy_msg)\n                else:\n                    msg = \"changed: [%s -> %s]\" % (result._host.get_name(), delegated_vars)\n            else:\n                msg = \"changed: [%s]\" % result._host.get_name()\n            color = C.COLOR_CHANGED\n        # 判断是否是第一步 setup\n        elif result._result.get('ansible_facts',False):\n            msg = \"ok: [ %s | %s ]\" % (str(result._host),str(result._host.get_groups()))\n            color = C.COLOR_OK\n        else:\n            if delegated_vars:\n                # 自定义输出\n                zdy_msg = self.zdy_stdout(json.loads(delegated_vars))\n                if zdy_msg:\n                    msg = \"ok: [%s]%s\" % (result._host.get_name(), zdy_msg)\n                else:\n                    msg = \"ok: [%s -> %s]\" % (result._host.get_name(), delegated_vars)\n            else:\n                msg = \"ok: [%s]\" % result._host.get_name()\n            color = C.COLOR_OK\n\n        if result._task.loop and 'results' in result._result:\n            self._process_items(result)\n        else:\n            self._display.display(msg, color=color)\n\n        self._handle_warnings(result._result)\n\n    # 自定义输出,格式清晰一些\n    def zdy_stdout(self,result):\n        msg = ''\n        if result.get('delta',False):\n            msg += u'\\t执行时间:%s'%result['delta']\n        if result.get('cmd', False):\n            msg += u'\\n执行命令:%s'%result['cmd']\n        if result.get('stderr',False):\n            msg += u'\\n错误输出:\\n%s'%result['stderr']\n        if result.get('stdout',False):\n            msg += u'\\n正确输出:\\n%s'%result['stdout']\n        if result.get('warnings',False):\n            msg += u'\\n警告:%s'%result['warnings']\n        return msg\n\n三、封装PlaybookExecutor\n1.封装为更容易调用的playbook api调用2.定制化一部分参数\n# -*- coding:utf-8 -*-\n# 描述:\n# V1 WZJ 2016-12-19 PlayBook重写封装api基本功能\n\nimport json\nfrom ansible import constants as C\nfrom collections import namedtuple\nfrom ansible.parsing.dataloader import DataLoader\nfrom ansible.vars import VariableManager\nfrom ansible.playbook.play import Play\nfrom ansible.executor.task_queue_manager import TaskQueueManager\nfrom ansible.executor.playbook_executor import PlaybookExecutor\nfrom callback import YunweiCallback\nfrom ansible.utils.ssh_functions import check_for_controlpersist\n\n# 调用自定义Inventory\nfrom inventory import YunweiInventory as Inventory \ntry:\n    from __main__ import display\nexcept ImportError:\n    from ansible.utils.display import Display\n    display = Display()\n\n\nclass YunweiPlaybookExecutor(PlaybookExecutor):\n    \n    '''重写PlayBookExecutor'''\n    def __init__(self, playbooks, inventory, variable_manager, loader, options, passwords, stdout_callback=None):\n        self._playbooks        = playbooks\n        self._inventory        = inventory\n        self._variable_manager = variable_manager\n        self._loader           = loader\n        self._options          = options\n        self.passwords         = passwords\n        self._unreachable_hosts = dict()\n\n        if options.listhosts or options.listtasks or options.listtags or options.syntax:\n            self._tqm = None\n        else:\n            self._tqm = TaskQueueManager(inventory=inventory, variable_manager=variable_manager, loader=loader, options=options, passwords=self.passwords, stdout_callback=stdout_callback)\n\n        # Note: We run this here to cache whether the default ansible ssh\n        # executable supports control persist.  Sometime in the future we may\n        # need to enhance this to check that ansible_ssh_executable specified\n        # in inventory is also cached.  We can't do this caching at the point\n        # where it is used (in task_executor) because that is post-fork and\n        # therefore would be discarded after every task.\n        check_for_controlpersist(C.ANSIBLE_SSH_EXECUTABLE)\n\n\nclass PlayBookJob(object):\n  '''封装一个playbook接口,提供给外部使用'''\n  def __init__(self,playbooks,host_list,ssh_user='bbs',passwords='null',project_name='all',ack_pass=False,forks=5,ext_vars=None):\n    self.playbooks = playbooks\n    self.host_list = host_list\n    self.ssh_user  = ssh_user\n    self.passwords = dict(vault_pass=passwords)\n    self.project_name = project_name\n    self.ack_pass  = ack_pass\n    self.forks     = forks\n    self.connection='smart'\n    self.ext_vars  = ext_vars\n\n    ## 用来加载解析yaml文件或JSON内容,并且支持vault的解密\n    self.loader    = DataLoader()\n\n    # 管理变量的类，包括主机，组，扩展等变量，之前版本是在 inventory中的\n    self.variable_manager = VariableManager()\n\n    # 根据inventory加载对应变量\n    self.inventory = Inventory(loader=self.loader, \n                               variable_manager=self.variable_manager,\n                               group_name=self.project_name,  # 项目名对应组名,区分当前执行的内容\n                               ext_vars=self.ext_vars,\n                               host_list=self.host_list)\n\n    self.variable_manager.set_inventory(self.inventory)\n\n    # 初始化需要的对象1\n    self.Options = namedtuple('Options',\n                             ['connection',\n                             'remote_user',\n                             'ask_sudo_pass',\n                             'verbosity',\n                             'ack_pass', \n                             'module_path', \n                             'forks', \n                             'become', \n                             'become_method', \n                             'become_user', \n                             'check',\n                             'listhosts', \n                             'listtasks', \n                             'listtags', \n                             'syntax',\n                             'sudo_user',\n                             'sudo'\n                             ])\n\n    # 初始化需要的对象2\n    self.options = self.Options(connection=self.connection, \n                                remote_user=self.ssh_user,\n                                ack_pass=self.ack_pass,\n                                sudo_user=self.ssh_user,\n                                forks=self.forks,\n                                sudo='yes',\n                                ask_sudo_pass=False,\n                                verbosity=5,\n                                module_path=None,  \n                                become=True, \n                                become_method='sudo', \n                                become_user='root', \n                                check=None,\n                                listhosts=None,\n                                listtasks=None, \n                                listtags=None, \n                                syntax=None\n                               )\n\n    # 初始化console输出\n    self.callback = YunweiCallback()\n\n    # 直接开始\n    self.run()\n\n  def run(self):\n    pb = None\n    pb = YunweiPlaybookExecutor(\n        playbooks            = self.playbooks,\n        inventory            = self.inventory,\n        variable_manager     = self.variable_manager,\n        loader               = self.loader,\n        options              = self.options,\n        passwords            = self.passwords,\n        stdout_callback      = self.callback\n    )\n    result = pb.run()\n\n# daemo\nif __name__ == \"__main__\":\n    PlayBookJob(playbooks=['xx.yml'],\n                host_list=['10.45.176.2'],\n                ssh_user='root',\n                project_name=\"test\",\n                forks=20,\n                ext_vars=None\n                )\n\n参考：\nansible-api官方文档：http://docs.ansible.com/ansib...一个非常好的ansible2.0 api调用文档，相见恨晚：https://serversforhackers.com...ansible源码：https://github.com/ansible/an...\n\n                ", "mainLikeNum": ["5 "], "mainBookmarkNum": "19"}