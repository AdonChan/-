{"title": "Python_OOP - MAY ", "index": "python", "content": "define class\nclass的三个组成部分：\n\n类的名称：类名\n\n类的属性: 一组数据\n\n类的方法：允许对进行操作的方法(行为)\n\n\n定义\nclass Student (object):\n    pass\nclass后面定义类名(类名通常是大写开头的单词)(object),表示该类是从哪个类继承下来的\n实例化\n创建实例是通过类名+()实现\nstu = Student()\n\nclass Stu (): # 定义class\n    age = 10 # 属性\n    def show (self): # 方法\n        print(self.age) # 类中获取属性\n        print(self, 'self')\n        print(stu.name) # 获取类外添加属性\n\nstu = Stu() # 实例化\n\nstu.name = 'sf' # 添加属性\nstu.show() # 调用方法\nself\nself当前实例化的对象在定义函数的时候，第一个参数需要self\nclass Stu ():\n    def show_name (self):\n        print(self.name)\n        \nstu = Stu()\nstu.name = 'sf'\n\nstu.show_name()\n\n\nself在定义时需要定义，但是在调用时会自动传入。\n\nself的名字并不是规定写死的，但是最好还是按照约定是self。\n\nself总是指调用时的类的实例。\n\ninit\n魔法方法:\n['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__']\n__init__: 类构造方法(魔法方法)\nclass Stu ():\n    # 初始化对象\n    def __init__ (self, new_name, new_age):\n        self.name = new_name\n        self.age = new_age\n    def show (self):    \n        print('name: %s, age: %d' % (self.name, self.age))\n\nstu = Stu('sf', 23)\nstu.show()\n创建对象的过程：\n\n创建一个对象\n\nPython解释器会自动的调用__init__方法\n返回创建的对象的引用，给实例\n\n__str__: 实例化执行该方法，返回值。\n当需要print一个类的时候，需要先在类中定义__str__方法，返回值，就是print()输出的值\nclass Stu ():\n    def __init__ (self, new_name):\n        self.name = new_name\n    def __str__ (self):    \n        return self.name\n__new__: 方法主要是当继承一些不可变的class时(比如int, str, tuple), 提供一个自定义这些类的实例化过程.\nclass Stu(object):\n    def __new__(cls):\n        return object.__new__(cls) # 自定义实例化过程\n        # 自身没有能力创建实例,可以让父类创建\n    def __init__(self):\n        print('init')\nstu = Stu()\n创建单例对象\nclass Single(object):\n    __instance = None\n    def __new__(cls):\n        if cls.__instance != None:\n            return cls.__instance\n        else:\n            cls.__instance = object.__new__(cls)\n            return cls.__instance\n\ns1 = Single()\ns2 = Single()\n私有方法和私有属性\n私有属性\n按照约定俗成的规定__开头的属性表示私有属性, 不可以直接类名.变量名访问在类中存储的形式为：_Stu__age, _类名__变量名\nclass Stu():\n    def __init__(self, new_name):\n        self.name = new_name\n        self.__age = 0 # 定义了一个私有的属性，属性的名字是`__age`\n在类中访问形式:self.__变量名\n私有方法(private)\n按照约定俗成的规定__开头的属性表示私有方法, 不可以直接类名.方法名访问存储的形式为：_Stu__get_age, _类名__方法名\nclass Stu():\n    def __test(self): # 定义私有方法\n        pass\n在类中调用私有方法:self.__方法名()\n有些时候，会看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。\ndel\n__del__:  当删除一个对象时，python解释器会默认调用一个魔术方法，__del__()\nclass Stu():\n    def __del__ (self):\n        print('remove obj')\n\nstu = Stu()\ndel stu\n在类的生命周期中，如果类销毁了，python会自动调用__del__方法。也就是说,不管是手动调用del还是由python自动回收都会触发__del__方法执行。\n对象引用个数\n模块sys中有一个getrefcount方法可以测试对象的引用个数返回的结果，会比实际结果大1.\nimport sys\n\nsys.getrefcount('变量/方法')\n继承\nclass Animal(object):\n    def run(self):\n        print('Animal is running')\n\nclass Dog(Animal): # 继承\n    def run(self):\n        print('Dog is running')\n\nclass Cat(Animal):\n    pass\n\n\ndog = Dog()\ncat = Cat()\n\ndog.run()\ncat.run()\n当子类和父类都存在相同的run()方法时，子类的run()覆盖了父类的run(),在代码运行的时候，总是会调用子类的run() -- 多态\n重写\n重写父类的方法,继承之后,子类定义和父类方法名一样的方法\nclass Animal(object):\n    def run(self):\n        print('Animal is running')\n\nclass Dog(Animal):\n    def run(self): # 重写\n        print('Dog is running')\n\nclass Cat(Animal):\n    pass\n\n\ndog = Dog()\ncat = Cat()\n\ndog.run()\ncat.run()\n调用父类方法\n\n类名调用\n\nsuper关键字调用\n\nclass Animal():\n    def run(self):\n        print('Animal is running')\nclass Dog (Animal):\n    def say(self):\n        #  第一种，类名调用。\n        # Animal.run(self) #方法必须传递参数`self`\n        \n        # 第二种，super关键字\n        super().run()\n        print('Gog is running')\n \ndog = Dog()\ndog.say()        \n私有方法，私有属性在继承中的表现:\n\n私有方法并不会被继承(子类外和子类内都不会让使用)\n私有属性并不会被继承(子类外和子类内都不会让使用)\n\n多继承\n子类具有多个父类\nclass A(object): # object是所有最终类的终点\n    def test(self):\n        print('A')\nclass B:\n    def test(self):\n        print('B')\n\nclass C(A, B): # 多继承 (如果继承类中方法名或者属性名相同，生效的是参数先后顺序，`类名.__mro__`中的顺序)\n    pass\n\nprint(C.__mro__) \n# (<class '__main__.A'>, <class '__main__.Base'>, <class '__main__.T'>, <class 'object'>) \n# C3算法\n\nc = C() # 子类也会重写父类的方法\n多态\n定义时的类型和运行时的类型不一样。\n执行的时候确定\nclass D(object):\n    def _print(self):\n        print('D')\nclass X(D):\n    def _print(self):\n        print('X')\n\ndef introduce(temp):\n    temp._print()\n\nd = D()\nx = X()\n\nintroduce(d)\nintroduce(x)\nisinstance()判断一个对象是否是某种类型\n实例属性属于各个实例所有，互不干扰；类属性属于类所有，所有实例共享一个属性；不要对实例属性和类属性使用相同的名字，否则将产生难以发现的错误。\n类属性 & 实例属性\nclass A():\n    num = 1 # 类属性\n    def __init(self):\n        print(self.num)\n\na = A()\na.name = 100 # 实例属性\n\nprint(A.num) # 获取类属性\n实例方法 & 类方法 & 静态方法\nclass A():\n    # 定义类方法\n    @classmethod\n    def add_num(cls): # 保存类的引用\n        pass\n    def get_num(self): # 实例方法\n        pass\n    @staticmethod\n    def set_num(): # 静态方法 # 可以没有任何参数引用\n        pass\n\na = A()\nA.add_num() # 调用类方法\n# a.add_num() # 实例调用类方法\n\nA.set_num() # 调用静态方法\na.set_num() # 实例调用静态方法\n私有化\nxx: 公有变量_x: 单前置下划线，私有化属性或方法，from somemodule import *禁止导入，类对象和子类可以访问__xx: 双前置下划线，避免与子类中的属性名命名冲突，无法在外部直接访问__xx__: 双前后下划线，命名空间的魔法对象或属性。__init__。(开发时，不要使用这种定义变量方式)xx_: 单后置下划线，用于避免与Python关键词的冲突\nproperty\n作用：获取与设置自动调用方法\n类属性方式调用property：\nclass Money(object):\n    def __init(self):\n        pass\n    def getMoney(self):\n        pass\n    def setMoney(self, value):\n        pass\n    money = property(getMoney, setMoney) # key 为调用时候的key\n\nm = Money()\nm.money = 10\n装饰器方式使用property：\nclass Money(object):\n    def __init__(self):\n        self.__num = 0\n    @property\n    def money(self): # 函数名和调用key对应 # 获取\n        return self.__money\n    @money.setter\n    def money(self, value): # 获取\n        self.__num = value\n\nm = Money()\nprint(m.money)\n垃圾回收\n小整数对象池\n作用：为了优化速度，使用了小整数对象池，避免为整数频繁申请和销毁内存空间。\nPython对小整数的定义是[-5, 257)这些整数对象都是提前建立好的，不会被垃圾回收。在一个Python的程序中，所有位于这个范围内的整数使用的都是同一个对象。\n单个字母也是这样，但是定义2歌相同字符串时，引用计数为0，触发垃圾回收。\n\n小整数[-5,257)共用对象，常驻内存\n单个字符共用对象，常驻内存\n\n大整数对象池\n每一个大整数，均创建一个新的对象。\n\n\n大整数不共用内存，引用计数为0，销毁\n数值类型和字符串类型在Python中都是不可变的，意味着无法修改这个对象的值，每次对变量对修改，实际上是创建一个新的对象\n\nintern机制\na1 = \"HelloWorld\"\na2 = \"HelloWorld\"\na3 = \"HelloWorld\"\nintern机制，让它只占用一个”HelloWorld”所占的内存空间。靠引用计数去维护何时释放。\n\n\n单个单词，不可修改，默认开启intern机制，共用对象，引用计数为0，则销毁\n字符串（含有空格），不可修改，没开启intern机制，不共用对象，引用计数为0，销毁\n\nGarbage collection(GC垃圾回收)\nPython采用对是引用计数机制为主，标记-清除和分代收集两种机制为辅的策略\n引用计数机制\nPython里每一个东西都是对象，它们的核心就是一个结构体: PyObject\ntypedef struct_object {\n    int ob_refcnt; // 引用计数\n    struct_typeobject *ob_type;\n} PyObject;\nPyObject是每个对象必有的内容，其中ob_refcnt就是作为引用计数。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少。当引用计数为0时，该对象生命就结束了。\n引用计数机制的优点：\n\n简单\n实时性： 一旦没有引用，内存就直接释放了。不用像其它机制等待特定实际。\n处理回收内存的时间分摊到了平时。\n\n引用计数机制的缺点：\n\n维护引用计数消耗资源\n循环引用\n\n垃圾回收机制\nPython中的垃圾回收是以引用计数为主，分代收集为辅\n\n导致引用计数+1的情况 对象被创建，例如: a = 23 对象被引用，例如: b = a 对象被作为参数，传入到一个函数中，例如: func(a) 对象作为一个元素，存储在容器中，例如: list1 = [a,a]\n\n导致引用计数-1的情况 对象的别名被显式销毁，例如: del a 对象的别名被赋予新的对象，例如: a = 24 一个对象离开它的作用域，例如f函数执行完毕时，func函数中的局部变量(全局变量不会) 对象所在的容器被销毁，或从容器中删除对象\n\n查看一个对象的引用计数\nimport sys\na = \"hello world\"\nsys.getrefcount(a)\n可以查看a对象的引用计数，但是比正常计数大1，因为调用函数的时候传入a，这会让a的引用计数+1\n\n\n循环引用导致内存泄露\n引用计数的缺陷是循环引用的问题\nimport gc\n\nclass ClassA():\n    def __init__(self):\n        print('object born,id:%s'%str(hex(id(self))))\n\ndef f2():\n    while True:\n        c1 = ClassA()\n        c2 = ClassA()\n        c1.t = c2\n        c2.t = c1\n        del c1\n        del c2\n\n# 把python的gc关闭\ngc.disable()\n\nf2()\n执行f2()，进程占用的内存会不断增大。\n\n创建了c1, c2后这两块内存的引用计数都是1，执行c1.t = c2和c2.t = c1后，这两块内存的引用计数变成2.\n在del c1后，内存1的对象的引用计数变为1，由于不是为0，所以内存1的对象不会被销毁，所以内存2的对象的引用数依然是2，在del c2后，应用计数也是1，内存1的对象，内存2的对象的引用数都是1.\n虽然他们两个对象都是可以被销毁的，但是由于循环引用，导致垃圾回收器不会回收它们，就导致内存泄漏.\n\n垃圾回收\n垃圾回收 = 垃圾检查 + 垃圾回收\n有三种情况会触发垃圾回收：\n\n调用gc.coolect()\n\n当gc模块的计数器达到阀值的时候\n程序退出的时候\n\ngc模块\ngc模块作用：解决循环引用的问题\n常用函数：\n\n\ngc.set_debug(flags)设置gc的debug日志。一般设置为gc.DEBUG_LEAK\n\n\ngc.collect([generation]) 显式进行垃圾回收，可以输入参数，0表示只检查第一代的对象，1代表检查一，二代对象，2代表检查一，二，三代的对象。如果不传入参数，执行一个full collection,也就是等于2，返回不可达(unreachable objects)对象的数目\n\ngc.get_threshold()获取的gc模块中自动执行垃圾回收的频率\n\ngc.set_threshold(threshold0[, threshold1[, threshold2])设置自动执行垃圾回收的频率\n\ngc.get_count()获取当前自动执行垃圾回收的计数器，返回一个长度为3的列表\n\nNote:gc模块唯一处理不了的是循环引用的类都有__del__方法，项目中要避免定义__del__方法。\nclass ClassA():\n    pass\n    # def __del__(self):\n    #     print('object born,id:%s'%str(hex(id(self))))\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}