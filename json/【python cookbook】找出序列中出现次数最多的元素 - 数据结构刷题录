{"title": "【python cookbook】找出序列中出现次数最多的元素 - 数据结构刷题录 ", "index": "python", "content": "问题\n《Python Cookbook》中有这么一个问题，给定一个序列，找出该序列出现次数最多的元素。例如：\nwords = [\n   'look', 'into', 'my', 'eyes', 'look', 'into', 'my', 'eyes',\n   'the', 'eyes', 'the', 'eyes', 'the', 'eyes', 'not', 'around', 'the',\n   'eyes', \"don't\", 'look', 'around', 'the', 'eyes', 'look', 'into',\n   'my', 'eyes', \"you're\", 'under'\n]\n统计出words中出现次数最多的元素？\n初步探讨\n1、collections模块的Counter类首先想到的是collections模块的Counter类，具体用法看这里！具体用法看这里！具体用法看这里！https://docs.python.org/3.6/l...，重要的事情强调三遍。\nfrom collections import Counter\n\nwords = [\n   'look', 'into', 'my', 'eyes', 'look', 'into', 'my', 'eyes',\n   'the', 'eyes', 'the', 'eyes', 'the', 'eyes', 'not', 'around', 'the',\n   'eyes', \"don't\", 'look', 'around', 'the', 'eyes', 'look', 'into',\n   'my', 'eyes', \"you're\", 'under'\n]\n\ncounter_words = Counter(words)\nprint(counter_words)\nmost_counter = counter_words.most_common(1)\nprint(most_counter)\n\n关于most_common([n])：\n2、根据dict键值唯一性和sorted()函数\nimport operator\n\nwords = [\n    'look', 'into', 'my', 'eyes', 'look', 'into', 'my', 'eyes',\n    'the', 'eyes', 'the', 'eyes', 'the', 'eyes', 'not', 'around', 'the',\n    'eyes', \"don't\", 'look', 'around', 'the', 'eyes', 'look', 'into',\n    'my', 'eyes', \"you're\", 'under'\n]\n\ndict_num = {}\nfor item in words:\n    if item not in dict_num.keys():\n        dict_num[item] = words.count(item)\n        \n# print(dict_num)\n\nmost_counter = sorted(dict_num.items(),key=lambda x: x[1],reverse=True)[0]  \nprint(most_counter)    \nsorted函数：传送门：https://docs.python.org/3.6/l...\niterable：可迭代类型；key：用列表元素的某个属性或函数进行作为关键字，有默认值，迭代集合中的一项;reverse：排序规则. reverse = True  降序 或者 reverse = False 升序，有默认值。返回值：是一个经过排序的可迭代类型，与iterable一样。\n这里，我们使用匿名函数key=lambda x: x[1]等同于:\ndef key(x):\n    return x[1]\n这里，我们利用每个元素出现的次数进行降序排序，得到的结果的第一项就是出现元素最多的项。\n更进一步\n这里给出的序列很简单，元素的数目很少，但是有时候，我们的列表中可能存在上百万上千万个元素，那么在这种情况下，不同的解决方案是不是效率就会有很大差别了呢？为了验证这个问题，我们来生成一个随机数列表，元素个数为一百万个。这里使用numpy Package,使用前，我们需要安装该包，numpy包下载地址：https://pypi.python.org/pypi/...。这里我们环境是centos7，选择numpy-1.14.2.zip (md5, pgp)进行下载安装，解压后python setup.py install\ndef generate_data(num=1000000):\n    return np.random.randint(num / 10, size=num)\nnp.random.randint(low[, high, size]) 返回随机的整数，位于半开区间 [low, high)具体用法参考https://pypi.python.org/pypi\nOK,数据生成了，让我们来测试一下两个方法所消耗的时间,统计时间，我们用time函数就可以。\n#!/usr/bin/python\n# coding=utf-8\n#\n# File: most_elements.py\n# Author: ralap\n# Data: 2018-4-5\n# Description: find most elements in list\n#\n\nfrom collections import Counter\nimport operator\nimport numpy as np\nimport random\nimport time\n\n\ndef generate_data(num=1000000):\n    return np.random.randint(num / 10, size=num)\n\n\ndef collect(test_list):\n    counter_words = Counter(test_list)\n    print(counter_words)\n    most_counter = counter_words.most_common(1)\n    print(most_counter)\n\n\ndef list_to_dict(test_list):\n    dict_num = {}\n    for item in test_list:\n        if item not in dict_num.keys():\n            dict_num[item] = test_list.count(item)\n\n    most_counter = sorted(dict_num.items(), key=lambda x: x[1], reverse=True)[0]\n    print(most_counter)\n\nif __name__ == \"__main__\":\n    list_value = list(generate_data())\n\n    t1 = time.time()\n    collect(list_value)\n    t2 = time.time()\n    print(\"collect took: %sms\" % (t2 - t1))\n\n    t1 = t2\n    list_to_dict(list_value)\n    t2 = time.time()\n    print(\"list_to_dict took: %sms\" % (t2 - t1))\n\n以下结果是我在自己本地电脑运行结果，主要是对比两个方法相对消耗时间。\n当数据比较大时，消耗时间差异竟然如此之大！下一步会进一步研究Counter的实现方式，看看究竟是什么魔法让他性能如此好。\n参考资料\nhttps://blog.csdn.net/xie_072...\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}