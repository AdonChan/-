{"title": "泛化&泛化数据集&实验 - 最nb的深度学习过程 ", "index": "python", "content": "泛化&泛化数据集&实验\n泛化 (Generalization)：过拟合的风险\n\n泛化:泛化能力（generalization ability）是指机器学习算法对新鲜样本的适应能力。学习的目的是学到隐含在数据对背后的规律，对具有同一规律的学习集以外的数据，经过训练的网络也能给出合适的输出，该能力称为泛化能力。\n前两篇实现了线性回归模型得训练，并再最后进行了采用合成特征作为特征输入，且过滤了离群值，效果似乎不错，但是这个不错的结果来自于我们采用了原来的训练数据进行的测试，这样的评估意义大吗？如果我们使用了新的（训练模型从未遇见过的）数据进行预测，得到的结果可能会不敬人意。假设我对模型不断的进行训练，不断调整超参数，经过若干天后，得到的模型能够达到完美的预测效果，对于输入的任意特征都能得到正确的target，但是这并不是我们想要的模型，因为其只达到了对训练数据的完美贴合，但并不一定能对它从未见过的新数据做出正确的预测，并且其训练了过久，模型也会变的过于复杂，这样就叫做过拟合\n大概过程如下图（图片来源于谷歌机器学习样图）:为了让您直观地理解这一概念，我们将展示 3 张图。假设这些图中的每个点代表一棵树在森林中的位置。图中的两种颜色分别代表以下含义：\n\n蓝点代表生病的树。\n橙点代表健康的树。\n\n\n图 1. 生病（蓝色）和健康（橙色）的树。\n您能设想出一个有效的模型来预测以后的生病或健康的树吗？花点时间在脑海里绘制一条弧线将蓝点与橙点分开，或者在脑海中圈住一些橙点或蓝点。然后再看看图 2，它显示某种机器学习模型如何将生病的树与健康的树区分开。请注意，该模型产生的损失非常低。\n\n图 2. 用于区分生病的树与健康的树的复杂模型。乍一看，图 2 所示的模型在将健康的树与生病的树区分开方面似乎表现得非常出色。真的是这样吗？\n\n图 3. 该模型在预测新数据方面表现非常糟糕。图 3 显示我们向该模型中添加了新数据后所发生的情况。结果表明，该模型在处理新数据方面表现非常糟糕。请注意，该模型对大部分新数据的分类都不正确。\n\n图 2 和图 3 所示的模型过拟合了训练数据的特性。过拟合模型在训练过程中产生的损失很低，但在预测新数据方面的表现却非常糟糕。如果某个模型在拟合当前样本方面表现良好，那么我们如何相信该模型会对新数据做出良好的预测呢？正如您稍后将看到的，过拟合是由于模型的复杂程度超出所需程度而造成的。机器学习的基本冲突是适当拟合我们的数据，但也要尽可能简单地拟合数据。\n一种解决方法是将您的数据集分成两个子集：\n\n\n训练集 - 用于训练模型的子集。\n\n测试集 - 用于测试模型的子集。\n\n一般来说，在-测试集上表现是否良好是衡量能否在新数据上表现良好的有用指标，前提是：\n\n测试集足够大。\n不会反复使用相同的测试集来作假。\n\n我们从分布中随机抽取样本，且这些样本是独立同分布 (i.i.d) 的\n独立同分布：1、每次抽取是随机的，不被其他条件所约束 2、所抽取的样本是同分布的，即满足同一个分布规律（如，抽纸牌，得从同样得一副牌中抽取）3、分布是平稳的，即分布在数据集内不会发生变化\n接下来我们来谈谈训练集和测试集\n训练集和测试集 (Training and Test Sets)：拆分数据\n\n\n\n训练集 - 用于训练模型的子集。\n\n测试集 - 用于测试训练后模型的子集\n\n如果我们只有一个数据集，但是需要训练集和测试集，办法很简单，拆分就好了，比例大概可以是4：1这样子\n不过，拆分数据时候得遵循几个原则1.数据集够大2.随机抽取的，能代表数据集的水平\n注意：请勿对测试数据进行训练，如果最后测试得到的结果意外的好，那最好检查一下，多数是因为对测试数据进行了误训练\n\n这是我们刚才讨论的划分方式--训练集和测试集\n但是这样的划分方式，会不会有问题呢？如果为了在最后的测试数据上获得最佳效果，从而更改学习速率、添加或移除特征，到从头开始设计全新模型。当该工作流程结束时，在测试数据上表现很好,那么最终依然很有可能是过拟合的。\n所以我们可以进一步划分，即训练集+验证集合+测试集合\n\n在这一经过改进的工作流程中：\n\n选择在验证集上获得最佳效果的模型。\n使用测试集再次检查该模型。\n\n该工作流程之所以更好，原因在于它暴露给测试集的信息更少\n接下来，我们将对之前的理论进行验证\n验证\n\n使用多个特征而非单个特征来进一步提高模型的有效性\n调试模型输入数据中的问题\n使用测试数据集检查模型是否过拟合验证数据\n\n\n与在之前的练习中一样，我们将依然使用加利福尼亚州住房数据集，尝试根据 1990 年的人口普查数据在城市街区级别预测 median_house_value\n设置和测试\n我们首先加载并准备数据。这一次，我们将使用多个特征，因此我们会将逻辑模块化，以对特征进行预处理：\n\nimport math\n\nfrom IPython import display\nfrom matplotlib import cm\nfrom matplotlib import gridspec\nfrom matplotlib import pyplot as plt\nimport numpy as np\nimport pandas as pd\nfrom sklearn import metrics\nimport tensorflow as tf\nfrom tensorflow.python.data import Dataset\n\ntf.logging.set_verbosity(tf.logging.ERROR)\npd.options.display.max_rows = 10\npd.options.display.float_format = '{:.1f}'.format\n\ncalifornia_housing_dataframe = pd.read_csv(\"https://storage.googleapis.com/mledu-datasets/california_housing_train.csv\", sep=\",\")\n\n# california_housing_dataframe = california_housing_dataframe.reindex(\n#     np.random.permutation(california_housing_dataframe.index))\n\n# 对特征预处理\ndef preprocess_features(california_housing_dataframe):\n  selected_features = california_housing_dataframe[\n    [\"latitude\",\n     \"longitude\",\n     \"housing_median_age\",\n     \"total_rooms\",\n     \"total_bedrooms\",\n     \"population\",\n     \"households\",\n     \"median_income\"]]\n  processed_features = selected_features.copy()\n  # 此外多创建一个合成特征\n  processed_features[\"rooms_per_person\"] = (\n    california_housing_dataframe[\"total_rooms\"] /\n    california_housing_dataframe[\"population\"])\n  return processed_features\n# 对target预处理\ndef preprocess_targets(california_housing_dataframe):\n# output_targets为pd.DataFrame()类型的数据结构（这种结构类似于表格，有行有列的索引）\n  output_targets = pd.DataFrame()\n  output_targets[\"median_house_value\"] = (\n    california_housing_dataframe[\"median_house_value\"] / 1000.0)\n  return output_targets\n\n# 训练集取前12000（共17000样本）\ntraining_examples = preprocess_features(california_housing_dataframe.head(12000))\ntraining_examples.describe()\n\n\n \nlatitude\nlongitude\nhousing_median_age\ntotal_rooms\ntotal_bedrooms\npopulation\nhouseholds\nmedian_income\nrooms_per_person\n\n\n\ncount\n12000.0\n12000.0\n12000.0\n12000.0\n12000.0\n12000.0\n12000.0\n12000.0\n12000.0\n\n\nmean\n34.6\n-118.5\n27.5\n2655.7\n547.1\n1476.0\n505.4\n3.8\n1.9\n\n\nstd\n1.6\n1.2\n12.1\n2258.1\n434.3\n1174.3\n391.7\n1.9\n1.3\n\n\nmin\n32.5\n-121.4\n1.0\n2.0\n2.0\n3.0\n2.0\n0.5\n0.0\n\n\n25%\n33.8\n-118.9\n17.0\n1451.8\n299.0\n815.0\n283.0\n2.5\n1.4\n\n\n50%\n34.0\n-118.2\n28.0\n2113.5\n438.0\n1207.0\n411.0\n3.5\n1.9\n\n\n75%\n34.4\n-117.8\n36.0\n3146.0\n653.0\n1777.0\n606.0\n4.6\n2.3\n\n\nmax\n41.8\n-114.3\n52.0\n37937.0\n5471.0\n35682.0\n5189.0\n15.0\n55.2\n\n\n\ntraining_targets = preprocess_targets(california_housing_dataframe.head(12000))\ntraining_targets.describe()\n\n\n \nmedian_house_value\n\n\n\ncount\n12000.0\n\n\nmean\n198.0\n\n\nstd\n111.9\n\n\nmin\n15.0\n\n\n25%\n117.1\n\n\n50%\n170.5\n\n\n75%\n244.4\n\n\nmax\n500.0\n\n\n\n# 测试集取尾5000\nvalidation_examples = preprocess_features(california_housing_dataframe.tail(5000))\nvalidation_examples.describe()\n\n\n \nlatitude\nlongitude\nhousing_median_age\ntotal_rooms\ntotal_bedrooms\npopulation\nhouseholds\nmedian_income\nrooms_per_person\n\n\n\ncount\n5000.0\n5000.0\n5000.0\n5000.0\n5000.0\n5000.0\n5000.0\n5000.0\n5000.0\n\n\nmean\n38.1\n-122.2\n31.3\n2614.8\n521.1\n1318.1\n491.2\n4.1\n2.1\n\n\nstd\n0.9\n0.5\n13.4\n1979.6\n388.5\n1073.7\n366.5\n2.0\n0.6\n\n\nmin\n36.1\n-124.3\n1.0\n8.0\n1.0\n8.0\n1.0\n0.5\n0.1\n\n\n25%\n37.5\n-122.4\n20.0\n1481.0\n292.0\n731.0\n278.0\n2.7\n1.7\n\n\n50%\n37.8\n-122.1\n31.0\n2164.0\n424.0\n1074.0\n403.0\n3.7\n2.1\n\n\n75%\n38.4\n-121.9\n42.0\n3161.2\n635.0\n1590.2\n603.0\n5.1\n2.4\n\n\nmax\n42.0\n-121.4\n52.0\n32627.0\n6445.0\n28566.0\n6082.0\n15.0\n18.3\n\n\n\nvalidation_targets = preprocess_targets(california_housing_dataframe.tail(5000))\nvalidation_targets.describe()\n\n\n \nmedian_house_value\n\n\n\ncount\n5000.0\n\n\nmean\n229.5\n\n\nstd\n122.5\n\n\nmin\n15.0\n\n\n25%\n130.4\n\n\n50%\n213.0\n\n\n75%\n303.2\n\n\nmax\n500.0\n\n\n\n在上面我们是把数据集中除了median_house_value作为target外，其他得所有列都作为了feature输入我们虽然没有什么数据分析或者统计学得背景知识，但是其实还是可以看一看，或者说猜一猜输入的这些特征到底是些什么，它们可能具有哪些意义?取值范围是怎么样的，数值的大小正常嘛？等等等\nlatitude：纬度longitude：经度housing_median_age：房子年纪（中值）total_rooms：房间总数（每个街区）total_bedrooms：卧室总数（每个街区）total_bedrooms：人口数（每个街区）households：户（一家人为一户）median_income ：收入（中值）\n再看看这些feature的数值（最大值，最小值），理解一下它们的单位（当然，会有不合理的，因为存在数据比较特殊，而且这是1990年的数据了），这些数据会帮助我们在宏观上了解这些数据集，特别是一旦发现不合理的地方更是要注意了（尤其在训练自己的数据时）\n异常情况：\n\n\nmedian_income 位于 3 到 15 的范围内。我们完全不清楚此范围究竟指的是什么，看起来可能是某对数尺度？无法找到相关记录；我们所能假设的只是，值越高，相应的收入越高。\n\nmedian_house_value 的最大值是 500001。这看起来像是某种人为设定的上限。\n\nrooms_per_person 特征通常在正常范围内，其中第 75 百分位数的值约为 2。但也有一些非常大的值（例如 18 或 55），这可能表明数据有一定程度的损坏。\n\n我们将暂时使用提供的这些特征。但希望这些示例可帮助您较为直观地了解如何检查来自未知来源的数据\n### 绘制纬度/经度与房屋价值中位数的曲线图\n\n*\n我们来详细了解一下 latitude 和 longitude 这两个特征。它们是相关城市街区的地理坐标。\n\n利用这两个特征可以提供出色的可视化结果 - 我们来绘制 latitude 和 longitude 的曲线图，然后用颜色标注 median_house_value\nplt.figure(figsize=(13, 8))\n\nax = plt.subplot(1, 2, 1)\nax.set_title(\"Validation Data\")\n\n# 取消y轴的自动缩放，并定义上下限\nax.set_autoscaley_on(False)\nax.set_ylim([32, 43])\n\n# 取消x轴的自动缩放，并定义上下限\nax.set_autoscalex_on(False)\nax.set_xlim([-126, -112])\n\n# plt.scatter()参数说明\n# validation_examples[\"longitude\"],validation_examples[\"latitude\"]:代表x，y\n# cmap:Colormap,颜色表\n# c：color（色彩，或者颜色序列）\nplt.scatter(validation_examples[\"longitude\"],\n            validation_examples[\"latitude\"],\n            cmap=\"coolwarm\",\n            c=validation_targets[\"median_house_value\"] / validation_targets[\"median_house_value\"].max())\n\nax = plt.subplot(1,2,2)\nax.set_title(\"Training Data\")\n\nax.set_autoscaley_on(False)\nax.set_ylim([32, 43])\nax.set_autoscalex_on(False)\nax.set_xlim([-126, -112])\nplt.scatter(training_examples[\"longitude\"],\n            training_examples[\"latitude\"],\n            cmap=\"coolwarm\",\n            c=training_targets[\"median_house_value\"] / training_targets[\"median_house_value\"].max())\n_ = plt.plot()\n\n当当当当，这个图的问题很明显呢，训练和测试的数据差异很大呢，问题在哪里呢？ 都是一个数据集的哎，其实就是处理数据的时候，忘记了随机排序了（再次说明打乱顺序真的很重要，我们永远无法预知原本序列的数据可能出现哪些问题），此外采用图标分析也很重要，能够在训练之前帮助我们发现问题，不然后面就完蛋啦，怎么训练都不会有好的结果的。\n调整后的结果\n\n现在很像一个地图了\n训练和评估模型\n\n我们会使用数据集中的所有特征训练一个线性回归器,定义一下以前将数据加载到 TensorFlow 模型中时所使用的同一输入函数\ndef my_input_fn(features, targets, batch_size=1, shuffle=True, num_epochs=None):  \n    features = {key:np.array(value) for key,value in dict(features).items()}   \n                                        \n    ds = Dataset.from_tensor_slices((features,targets)) # warning: 2GB limit\n    ds = ds.batch(batch_size).repeat(num_epochs)\n\n    if shuffle:\n      ds = ds.shuffle(10000)\n    \n    features, labels = ds.make_one_shot_iterator().get_next()\n    return features, labels\n由于我们现在使用的是多个输入特征，因此需要把用于将特征列配置为独立函数的代码模块化。（目前此代码相当简单，因为我们的所有特征都是数值，但当我们在今后的练习中使用其他类型的特征时，会基于此代码进行构建。）\ndef construct_feature_columns(input_features):\n  return set([tf.feature_column.numeric_column(my_feature)\n              for my_feature in input_features])\n接下来，继续完成下面的 train_model() 代码，以设置输入函数和计算预测。但要确保针对相应数据集调用 predict()比较训练数据和验证数据的损失\ndef train_model(\n    learning_rate,\n    steps,\n    batch_size,\n    training_examples,\n    training_targets,\n    validation_examples,\n    validation_targets):\n\n  periods = 10\n  steps_per_period = steps / periods\n  \n  # 创建线性回归模型并设定好特征列和优化器\n  my_optimizer = tf.train.GradientDescentOptimizer(learning_rate=learning_rate)\n  my_optimizer = tf.contrib.estimator.clip_gradients_by_norm(my_optimizer, 5.0)\n  linear_regressor = tf.estimator.LinearRegressor(\n      feature_columns=construct_feature_columns(training_examples),\n      optimizer=my_optimizer\n  )\n  \n  # 创建训练、预测（使用训练集的数据）、验证（使用验证集的数据）的输入函数\n  training_input_fn = lambda: my_input_fn(\n      training_examples, \n      training_targets[\"median_house_value\"], \n      batch_size=batch_size)\n  predict_training_input_fn = lambda: my_input_fn(\n      training_examples, \n      training_targets[\"median_house_value\"], \n      num_epochs=1, \n      shuffle=False)\n  predict_validation_input_fn = lambda: my_input_fn(\n      validation_examples, validation_targets[\"median_house_value\"], \n      num_epochs=1, \n      shuffle=False)\n\n  # 训练（周期性输出结果）\n  print \"Training model...\"\n  print \"RMSE (on training data):\"\n  training_rmse = []\n  validation_rmse = []\n  for period in range (0, periods):\n    # 按照训练steps进行周期性训练\n    linear_regressor.train(\n        input_fn=training_input_fn,\n        steps=steps_per_period,\n    )\n    # 记录预测值（分别使用训练集和验证集）\n    training_predictions = linear_regressor.predict(input_fn=predict_training_input_fn)\n    training_predictions = np.array([item['predictions'][0] for item in training_predictions])\n    \n    validation_predictions = linear_regressor.predict(input_fn=predict_validation_input_fn)\n    validation_predictions = np.array([item['predictions'][0] for item in validation_predictions])\n    \n    \n    # 计算RMSE（使用训练值和验证值）\n    training_root_mean_squared_error = math.sqrt(\n        metrics.mean_squared_error(training_predictions, training_targets))\n    validation_root_mean_squared_error = math.sqrt(\n        metrics.mean_squared_error(validation_predictions, validation_targets))\n\n    print \"  period %02d : %0.2f\" % (period, training_root_mean_squared_error)\n\n    training_rmse.append(training_root_mean_squared_error)\n    validation_rmse.append(validation_root_mean_squared_error)\n  print \"Model training finished.\"\n\n  plt.ylabel(\"RMSE\")\n  plt.xlabel(\"Periods\")\n  plt.title(\"Root Mean Squared Error vs. Periods\")\n  plt.tight_layout()\n  plt.plot(training_rmse, label=\"training\")\n  plt.plot(validation_rmse, label=\"validation\")\n  # plt.legend()画图例，图中右上角\n  plt.legend()\n\n  return linear_regressor\n训练...\nlinear_regressor = train_model(\n    learning_rate=0.00003,\n    steps=500,\n    batch_size=5,\n    training_examples=training_examples,\n    training_targets=training_targets,\n    validation_examples=validation_examples,\n    validation_targets=validation_targets)\n因为使用的features较多，要耐心等一会儿就可以看到使用训练值和校验值的区别了，以及多特征的效果怎么样\nTraining model...RMSE (on training data):  period 00 : 217.67  period 01 : 201.13  period 02 : 186.67  period 03 : 176.46  period 04 : 170.31  period 05 : 167.41  period 06 : 166.75  period 07 : 166.49  period 08 : 167.72  period 09 : 169.76Model training finished.learning_rate=0.00003\n要注意这是两条线哦，还有一条是校验集的结果，真的是很贴合了哎，说明模型效果挺好的\n上面的learning_rate=0.00003，最终的rmse为169.76，这比上次的合成特征的高了好多，所以下面尝试修改learning_ratelearning_rate=0.00015\n\nlearning_rate=0.005\n\nlearning_rate=0.05\n\n我们会发现这次的损失函数曲线好像很复杂的样子。。。。emmmmmmm，其实到这里，我还没有调好，不过不管啦，下一篇我会说明一下，多特征的时候怎么来调节超参数（其实我只是比较懒.....）\n最后，再看看以学习率为0.00003训练出来的模型，遇到测试集的效果吧\ncalifornia_housing_test_data = pd.read_csv(\"https://storage.googleapis.com/mledu-datasets/california_housing_test.csv\", sep=\",\")\n\ntest_examples = preprocess_features(california_housing_test_data)\ntest_targets = preprocess_targets(california_housing_test_data)\n\npredict_test_input_fn = lambda: my_input_fn(\n      test_examples, \n      test_targets[\"median_house_value\"], \n      num_epochs=1, \n      shuffle=False)\n\ntest_predictions = linear_regressor.predict(input_fn=predict_test_input_fn)\ntest_predictions = np.array([item['predictions'][0] for item in test_predictions])\n\nroot_mean_squared_error = math.sqrt(\n    metrics.mean_squared_error(test_predictions, test_targets))\n\nprint \"Final RMSE (on test data): %0.2f\" % root_mean_squared_error\nFinal RMSE (on test data): 162.84结果很接近了呢，说明没有过拟合。\n讲完。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "1"}