{"title": "python 最快 web 框架 Sanci 快速入门 - 古寺比的寺 ", "index": "python,python3.5,frameworks,web", "content": "简介\nSanic 是一个和类Flask 的基于Python3.5+的web框架，它编写的代码速度特别快。除了像Flask 以外，Sanic 还支持以异步请求的方式处理请求。这意味着你可以使用新的 async/await 语法，编写非阻塞的快速的代码。\n关于 asyncio 包的介绍，请参考之前的一篇文章 python并发2：使用asyncio处理并发\nGithub 地址 是 https://github.com/channelcat/sanic，感兴趣的可以去贡献代码。\n既然它说速度特别快，我们先看下官方提供的 基准测试结果。\nSanic基准测试\n\n这个测试的程序运行在 AWS 实例上，系统是Ubuntu，只使用了一个进程。\nSanic 的开发者说他们的灵感来自于这篇文章 uvloop: Blazing fast Python networking。\n那我们就有必要看下uvloop是个什么库。\nuvloop\nuvloop 是 asyncio 默认事件循环的替代品，实现的功能完整，切即插即用。uvloop是用CPython 写的，建于libuv之上。uvloop 可以使 asyncio 更快。事实上，它至少比 nodejs、gevent 和其他 Python 异步框架要快两倍 。基于 uvloop 的 asyncio 的速度几乎接近了 Go 程序的速度。\n安装 uvloop\nuvloop 还只能在 *nix 平台 和 Python3.5+以上版本使用。使用pip安装：\npip install uvloop\n在 asyncio 代码中使用uvloop 也很简单：\nimport asyncio\nimport uvloop\nasyncio.set_event_loop_policy(uvloop.EventLoopPolicy())\n这得代码使得对任何asyncio.get_event_loop() 的调用都将返回一个uvloop实例。\n详细的uvloop 介绍可以看下原文：uvloop: Blazing fast Python networking。\nuvloop的github地址是https://github.com/MagicStack/uvloop。\n现在我们开始学习Sanic：\n安装 Sanic\npip install sanic\n创建第一个 sanic 代码\nfrom sanic import Sanic\nfrom sanic.response import text\n\napp = Sanic(__name__)\n\n@app.route(\"/\")\nasync def test(request):\n    return text('Hello world!')\n\napp.run(host=\"0.0.0.0\", port=8000, debug=True)\n运行代码： python main.py, 现在打开浏览器访问 http://0.0.0.0:8000，你会看到 hello world!。\n如果你熟悉Flask，你会发现，这个语法简直和Flask一模一样。\n路由（Routing）\n路由用于把一个函数绑定到一个 URL。下面是一些基本的例子：\n@app.route('/')\ndef index():\n    return text('Index Page')\n\n@app.route('/hello')\ndef hello():\n    return text('Hello World')\n当然，你还可以动态的变化URL的某些部分，还可以为一个函数指定多个规则。\n变量规则\n通过把 URL 的一部分标记为 <variable_name> 就可以在 URL 中添加变量。标记的 部分会作为关键字参数传递给函数。通过使用 <converter:variable_name> ，可以 选择性的加上一个转换器，为变量指定特定的类型，如果传入的类型错误，Sanic会抛出NotFound异常。请看下面的例子:\nfrom sanic.response import text\n\n@app.route('/tag/<tag>')\nasync def tag_handler(request, tag):\n    return text('Tag - {}'.format(tag))\n\n@app.route('/number/<integer_arg:int>')\nasync def integer_handler(request, integer_arg):\n    return text('Integer - {}'.format(integer_arg))\n\n@app.route('/number/<number_arg:number>')\nasync def number_handler(request, number_arg):\n    return text('Number - {}'.format(number_arg))\n\n@app.route('/person/<name:[A-z]>')\nasync def person_handler(request, name):\n    return text('Person - {}'.format(name))\n\n@app.route('/folder/<folder_id:[A-z0-9]{0,4}>')\nasync def folder_handler(request, folder_id):\n    return text('Folder - {}'.format(folder_id))\nHTTP 请求类型\n默认情况下，我们定义的URL只支持GET 请求，@app.route装饰器提供了一个可选参数methods，这个参数允许传入所有HTTP 方法。例如：\nfrom sanic.response import text\n\n@app.route('/post', methods=['POST'])\nasync def post_handler(request):\n    return text('POST request - {}'.format(request.json))\n\n@app.route('/get', methods=['GET'])\nasync def get_handler(request):\n    return text('GET request - {}'.format(request.args))\n也可以简写为：\nfrom sanic.response import text\n\n@app.post('/post')\nasync def post_handler(request):\n    return text('POST request - {}'.format(request.json))\n\n@app.get('/get')\nasync def get_handler(request):\n    return text('GET request - {}'.format(request.args))\nadd_route 方法\n除了@app.route装饰器，Sanic 还提供了 add_route 方法。\n@app.route 只是包装了 add_route方法。\nfrom sanic.response import text\n\n# Define the handler functions\nasync def handler1(request):\n    return text('OK')\n\nasync def handler2(request, name):\n    return text('Folder - {}'.format(name))\n\nasync def person_handler2(request, name):\n    return text('Person - {}'.format(name))\n\n# Add each handler function as a route\napp.add_route(handler1, '/test')\napp.add_route(handler2, '/folder/<name>')\napp.add_route(person_handler2, '/person/<name:[A-z]>', methods=['GET'])\nURL 构建\n如果可以匹配URL，那么Sanic可以生成URL吗？当然可以，url_for() 函数就是用于构建指定函数的URL的。它把函数名称作为第一个参数，其余参数对应URL中的变量，例如：\n@app.route('/')\nasync def index(request):\n    # generate a URL for the endpoint `post_handler`\n    url = app.url_for('post_handler', post_id=5)\n    # the URL is `/posts/5`, redirect to it\n    return redirect(url)\n\n\n@app.route('/posts/<post_id>')\nasync def post_handler(request, post_id):\n    return text('Post - {}'.format(post_id))\n未定义变量会作为URL的查询参数：\nurl = app.url_for('post_handler', post_id=5, arg_one='one', arg_two='two')\n# /posts/5?arg_one=one&arg_two=two\n\n# 支持多值参数\nurl = app.url_for('post_handler', post_id=5, arg_one=['one', 'two'])\n# /posts/5?arg_one=one&arg_one=two\n使用蓝图（Blueprint）\nSanic也提供了和Flask 类似的 Blueprint。Blueprint有以下用途：\n\n把一个应用分解为一套蓝图。这是针对大型应用的理想方案：一个项目可以实例化一个 应用，初始化多个扩展，并注册许多蓝图。\n在一个应用的 URL 前缀和（或）子域上注册一个蓝图。 URL 前缀和（或）子域的参数 成为蓝图中所有视图的通用视图参数（缺省情况下）。\n使用不同的 URL 规则在应用中多次注册蓝图。\n通过蓝图提供模板过滤器、静态文件、模板和其他工具。蓝图不必执行应用或视图 函数。\n\nblueprint 示例\nfrom sanic import Sanic\nfrom sanic.response import json\nfrom sanic import Blueprint\n\nbp = Blueprint('my_blueprint')\n\n@bp.route('/')\nasync def bp_root(request):\n    return json({'my': 'blueprint'})\n    \napp = Sanic(__name__)\napp.blueprint(bp)\n\napp.run(host='0.0.0.0', port=8000, debug=True)\nSanic 使用 app.blueprint() 方法注册blueprint。\n使用蓝图注册全局中间件\n@bp.middleware\nasync def print_on_request(request):\n    print(\"I am a spy\")\n\n@bp.middleware('request')\nasync def halt_request(request):\n    return text('I halted the request')\n\n@bp.middleware('response')\nasync def halt_response(request, response):\n    return text('I halted the response')\n使用蓝图处理异常\n@bp.exception(NotFound)\ndef ignore_404s(request, exception):\n    return text(\"Yep, I totally found the page: {}\".format(request.url))\n使用蓝图处理静态文件\n第一个参数指向当前的Python包第二个参数是静态文件的目录\nbp.static('/folder/to/serve', '/web/path')\n使用url_for\n如果要创建页面链接，可以和通常一样使用 url_for() 函数，只是要把蓝图名称作为端点的前缀，并且用一个点（ . ）来 分隔:\n@blueprint_v1.route('/')\nasync def root(request):\n    url = app.url_for('v1.post_handler', post_id=5) # --> '/v1/post/5'\n    return redirect(url)\n\n\n@blueprint_v1.route('/post/<post_id>')\nasync def post_handler(request, post_id):\n    return text('Post {} in Blueprint V1'.format(post_id))\n操作请求数据\n对于web 应用来说对客户端向服务器发送的数据做出相应很重要，在Sanic中由传入的参数 request来提供请求信息。\n\n为什么不像Flask 一样提供一个全局变量 request？\nFlask 是同步请求，每次请求都有一个独立的新线程来处理，这个线程中也只处理这一个请求。而Sanic是基于协程的处理方式，一个线程可以同时处理几个、几十个甚至几百个请求，把request作为全局变量显然会比较难以处理。\n\nRequest 对象常用参数有\njson（any）  json body\nfrom sanic.response import json\n\n@app.route(\"/json\")\ndef post_json(request):\n    return json({ \"received\": True, \"message\": request.json })\nargs（dict）  URL请求参数\n?key1=value1&key2=value2  将转变为\n{'key1': ['value1'], 'key2': ['value2']}\nraw_args（dict） 和args 类似\n?key1=value1&key2=value2  将转变为\n{'key1': 'value1', 'key2': 'value2'}\nform（dict）处理 POST 表单请求，数据是一个字典\nbody（bytes）处理POST 表单请求，数据是一个字符串\n其他参数还有:\n\nfile\nip\napp\nurl\nscheme\npath\nquery_string\n\n详细信息参考文档: Request Data\n关于响应\nSanic使用response 函数创建响应对象。\n\n文本 response.text('hello world')\nhtml response.html('<p>hello world</p>')\njson response.json({'hello': 'world'})\nfile response.file('/srv/www/hello.txt')\nstreaming\n\nfrom sanic import response\n\n@app.route(\"/streaming\")\nasync def index(request):\n    async def streaming_fn(response):\n        response.write('foo')\n        response.write('bar')\n    return response.stream(streaming_fn, content_type='text/plain')\n\nredirect response.file('/json')\nraw response.raw('raw data')\n如果想修改响应的headers可以传入headers 参数\n\nfrom sanic import response\n\n@app.route('/json')\ndef handle_request(request):\n    return response.json(\n        {'message': 'Hello world!'},\n        headers={'X-Served-By': 'sanic'},\n        status=200\n    )\n配置管理\n应用总是需要一定的配置的。根据应用环境不同，会需要不同的配置。比如开关调试 模式、设置密钥以及其他依赖于环境的东西。Sanic 的设计思路是在应用开始时载入配置。你可以在代码中直接硬编码写入配置，也可以使用配置文件。\n不管你使用何种方式载入配置，都可以使用 Sanic 的 config 属性来操作配置的值。 Sanic 本身就使用这个对象来保存 一些配置，扩展也可以使用这个对象保存配置。同时这也是你保存配置的地方。\n配置入门\nconfig 实质上是一个字典的子类，可以像字典一样操作：\napp = Sanic('myapp')\napp.config.DB_NAME = 'appdb'\napp.config.DB_USER = 'appuser'\n也可以一次更新多个配置：\ndb_settings = {\n    'DB_HOST': 'localhost',\n    'DB_NAME': 'appdb',\n    'DB_USER': 'appuser'\n}\napp.config.update(db_settings)\n从对象导入配置\nimport myapp.default_settings\n\napp = Sanic('myapp')\napp.config.from_object(myapp.default_settings)\n这里是我写的聊天机器人的真实配置示例：https://github.com/gusibi/momo/\n使用配置文件\n如果把配置放在一个单独的文件中会更有用。理想情况下配置文件应当放在应用包的 外面。这样可以在修改配置文件时不影响应用的打包与分发常见用法如下:\napp = Sanic('myapp')\napp.config.from_envvar('MYAPP_SETTINGS')\n首先从 myapp.default_settings 模块载入配置，然后根据 MYAPP_SETTINGS 环境变量所指向的文件的内容重载配置的值。在 启动服务器前，在 Linux 或 OS X 操作系统中，这个环境变量可以在终端中使用 export 命令来设置:\n$ export MYAPP_SETTINGS=/path/to/config_file\n$ python myapp.py\n部署\nSanic 项目还不是特别成熟，现在部署比较简陋。对Gunicorn的支持也不完善。详细信息可以 看下这个问题 Projects built with sanic?\n先在说下我的部署方式\n使用 supervisord 部署\nsupervisord 配置文件： https://github.com/gusibi/momo/blob/master/supervisord.conf\n启动 方式\nsupervisord -c supervisor.conf\n总结\n试用了下Sanic，把之前的一个聊天机器人从Flask 改成了 Sanic。不得不说，如果你有Flask经验，大致看一下Sanic文档就可以直接上手了。并且Sanic 的速度比Flask 快很多，只是Sanic配套的包还是太少，用于生产环境有一定的风险。\n最后对聊天微信聊天机器人感兴趣的可以看下https://github.com/gusibi/momo。\n预告\n下一篇将介绍如何使用 Sanic 一步一步创建一个 聊天机器人。\n参考链接\n\nuvloop: Blazing fast Python networking\nSanic Githu 地址\nSanic 文档\n\n\n最后，感谢女朋友支持。\n\n\n>欢迎关注\n>请我喝芬达\n\n\n\n\n\n\n彩蛋\n魔魔是我们家巴哥的名字贴一张魔魔的照片结束本篇文章。\n\n\n                ", "mainLikeNum": ["8 "], "mainBookmarkNum": "24"}