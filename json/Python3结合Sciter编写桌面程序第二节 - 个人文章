{"title": "Python3结合Sciter编写桌面程序第二节 - 个人文章 ", "index": "python", "content": "第二节 将任务添加到队列!\n上一个栗子只是简单实现了下网页与后台的通信\ndef clickMe(self):\n    #你可以在这里处理任何你想要的操作\n    self.call_function('clickCallBack','你已经点到我了!')\n但由于是同一个进程，如果你做了很耗时的操作，比如下载一张图片之类的IO操作......\n你会发现，窗口卡住了，一般表现为窗口泛白，出现未响应的提示......但这并不是程序真的未响应了，等图片下载完就会恢复原样。\n但是，你能接受吗？\n如果能的话......下面就可以不用看了，我说真的。\n咳...嗯\n继续\n为了不卡，我选择了多进程的方式，多线程也可以，但万一这个线程死掉，会拉着主线程下水......以防万一，我选择再开一个进程作为服务进程。\nfrom multiprocessing import Process,Queue\n\n# 创建用于接收服务进程传递的回馈任务的队列，此队列线程安全\nself.GuiQueue = Queue()\n# 创建用于接收界面进程发送的任务的队列，此队列线程安全\nself.ServiceQueue = Queue()\np = Process(target = startServiceP, args = ( self.GuiQueue, self.ServiceQueue ))\np.daemon = True #设置为守护进程,保证主进程退出时子进程也会退出\np.start()\n\n为何选用Process及Queue?\n单纯开启一个子进程或许还有一个更好的选择：Popen，它可以启动独立的py脚本作为子进程，也有很多方法可供选择。但我不知道应该如何通信及传参，找了一些栗子，无奈无法完全理解，只能待日后解决。\nPython多进程通信方法有Queue、Pipe、Value、Array\n\npipe用来在两个进程间通信\nqueue用来在多个进程间实现通信\nValue + Array 是python中共享内存映射文件的方法\n\n最初的设计比现在复杂，共有3个进程，故弃用pipe\nValue + Array的方式当时没找到，遗漏\n只剩Queue......\n据说Queue速度上慢一些，但以咱目前的水平，速度不是瓶颈\n够用就行，不是吗？\npipe后期也会研究的就是了......\n\n我们来看一下这个服务进程有些啥\ndef startServiceP(_GuiQueue, _ServiceQueue):\n    '''开启一个服务进程'''\n    funMap = ServiceEvent( _GuiQueue )\n    EventManager( _ServiceQueue, funMap ).Start()\n就这么简单~\nfunMap 是啥?  ServiceEvent 又哪来的!? EventManager 又是什么鬼??!!\n等下，把刀放下......\n咳...\n一般来说，从界面传来的命令都是字符串，然后通过这个字符串来执行指定函数\nfunMap 就是存放的事先写好的函数字典\n看一下ServiceEvent():\nclass ServiceEvent(object):\n    '''服务进程'''\n    def __init__(self, _GuiQueue):\n        self.GuiQueue = _GuiQueue\n\n    def clickCallBack(self, msg):\n        sleep(3)\n        self.__putGui( 'clickCallBack', msg )\n\n    def __putGui(self, f, m = None ):\n        self.GuiQueue.put({\n            'fun' : f,\n            'msg' : m\n        })\n现在可以调用 funMap.clickCallBack() \n关于 GuiQueue 等会再说，先来看一下EventManager() \nclickMe() 只是把要执行的任务发送给 ServiceQueue 了，但此任务不会自动执行，我们还需要一个循环来读取任务，这就是EventManager()的功能。\nEventManager()核心代码：\ndef __Run(self):\n    while self.__active == True:\n        try:\n            # 获取事件的阻塞时间设为1秒\n            event = self.Queue.get(timeout = 1)\n            getattr( self.funMap, event['fun'] )( event['msg'] )  #关键代码\n        except Exception as e:\n            pass\n以上是服务进程的相关内容，我们再回来看一下界面该如何及时获得反馈\nfrom threading import Thread\n\nt = Thread(target = queueLoop, args=( self.GuiQueue, self.call_function ))\nt.daemon = True\nt.start()\n嗯，此处我开了另一个线程来执行这个循环，老实说没想到特别好的办法，这个循环肯定不能在主线程使用，会卡界面的，开一个进程又太小题大做，折中方案，用了多线程，好在它只是遍历Queue，没啥复杂的操作......\ndef queueLoop( _GuiQueue, funCall ):\n    guiCallBack = GuiCallBack( funCall )\n    EventManager( _GuiQueue, guiCallBack ).Start()\n基本和服务进程一样，不做过多解释了~\n需要注意的只有 funCall这个参数，很重要，界面的事件调用全靠它。\nTis：\n$(.click-me).on(\"click\",function(){\n    view.clickMe();  //view Sciter内置的对象，所有tis都可调用\n})\nmain.py ：\n# 导入sciter支持,必须安装pysciter\nimport sciter\nimport ctypes\nimport json\n\nfrom multiprocessing import Process,Queue\nfrom threading import Thread\nfrom EventManager import EventManager\nfrom FunManager import ServiceEvent, GuiCallBack\n\n# 设置dpi, 防止程序在高分屏下发虚\nctypes.windll.user32.SetProcessDPIAware(2)\n\ndef startServiceP(_GuiQueue, _ServiceQueue):\n    '''开启一个服务进程'''\n    funMap = ServiceEvent( _GuiQueue )\n    EventManager( _ServiceQueue, funMap ).Start()\n\ndef queueLoop( _GuiQueue, funCall ):\n    guiCallBack = GuiCallBack( funCall )\n    EventManager( _GuiQueue, guiCallBack ).Start()\n\nclass Frame(sciter.Window):\n    def __init__(self):\n        '''\n            ismain=False, ispopup=False, ischild=False, resizeable=True,\n            parent=None, uni_theme=False, debug=True,\n            pos=None,  pos=(x, y)\n            size=None\n        '''\n        super().__init__(ismain=True, debug=True)\n        self.set_dispatch_options(enable=True, require_attribute=False)\n\n    def _document_ready(self, target):\n        '''在文档加载后执行，如果设置启动画面，可以在这里结束'''\n\n        # 创建用于接收服务进程传递的回馈任务的队列，此队列线程安全\n        self.GuiQueue = Queue()\n        # 创建用于接收界面进程发送的任务的队列，此队列线程安全\n        self.ServiceQueue = Queue()\n        p = Process(target = startServiceP, args = ( self.GuiQueue, self.ServiceQueue ))\n        p.daemon = True #设置为守护进程,保证主进程退出时子进程也会退出\n        p.start()\n        t = Thread(target = queueLoop, args=( self.GuiQueue, self.call_function ))\n        t.daemon = True\n        t.start()\n\n    def clickMe(self):\n        # 点击页面上的按钮后，只将任务添加到服务队列，耗时很短，因此不会发生界面卡顿现象\n        self.__putService('clickCallBack','你已经点到我了!')\n\n    def __putService(self, f, m = None):\n        '''接收界面事件并转发'''\n        self.ServiceQueue.put({\n            'fun' : f,\n            'msg' : m\n        })\n\nif __name__ == '__main__':\n    frame = Frame()\n    frame.load_file(\"Gui/main.html\")\n    frame.run_app()\n\nEventManager.py：\nclass EventManager:\n    def __init__(self, _Queue, funMap):\n        self.__active = False\n        self.Queue = _Queue\n        self.funMap = funMap\n\n    def __Run(self):\n        while self.__active == True:\n            try:\n                # 获取事件的阻塞时间设为1秒\n                event = self.Queue.get(timeout = 1)\n                getattr( self.funMap, event['fun'] )( event['msg'] )\n            except Exception as e:\n                pass\n\n    def Start(self):\n        self.__active = True\n        self.__Run()\n\n    def Stop(self):\n        self.__active = False\nFunManager.py：\nfrom time import sleep\n\nclass ServiceEvent(object):\n    '''服务进程'''\n    def __init__(self, _GuiQueue):\n        self.GuiQueue = _GuiQueue\n\n    def clickCallBack(self, msg):\n        sleep(3)\n        self.__putGui( 'clickCallBack', msg )\n\n    def __putGui(self, f, m = None ):\n        self.GuiQueue.put({\n            'fun' : f,\n            'msg' : m\n        })\n\nclass GuiCallBack(object):\n    def __init__(self, funCall):\n        self.funCall = funCall\n\n    def clickCallBack(self, msg):\n        return self.funCall('clickCallBack', msg )\n代码渐渐多了起来，但效果还是很让人满意的。\n缺点是一不留神容易出错\n源码\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}