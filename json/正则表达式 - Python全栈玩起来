{"title": "正则表达式 - Python全栈玩起来 ", "index": "python", "content": "match search findall finditer\nre.match(pattern, string[, flags])：扫描字符串开头re.search(): 扫描整个字符串，返回第一个匹配成功的结果re.findall()：返回所有结果的列表，失败返回空列表finditer() 返回迭代器 失败返回空flags 比如是否区分大小写。re.I：忽略大小写  ignorecasere.M:多行匹配 会影响$和^  multilinere.S:会匹配包括换行符在内的所有字符 # DOTALL dot matches all\n\n\nimport re\ntmp = 'http'\nprint(re.match(tmp,'http://www.baidu.com')) \n# <_sre.SRE_Match object; span=(0, 4), match='http'>\nprint(re.match(tmp,'://wwwhttp.baidu.com')) \n# None\nprint(re.match(tmp,'http://www.baidu.com').span())\n# (0, 4)\n\nprint(re.search(tmp, 'www.Http://baidu.com', re.I))\n# <_sre.SRE_Match object; span=(4, 8), match='Http'>\n\nprint(re.findall(tmp, 'http://www.http.com'))\n# ['http', 'http']\n\nfind = re.finditer(tmp, 'http://HTTp.com0', re.I)\nfor i in find:\n    print(i)\n# <_sre.SRE_Match object; span=(0, 4), match='http'>\n# <_sre.SRE_Match object; span=(7, 11), match='HTTp'>\n\n\n各种匹配符号\n\n\n· 匹配除换行符以外的所有字符\n[]  是字符的集合,匹配括号中任意字符\n[a-zA-Z] 大小写字符\n[0-9]\n\n[^0-9]除数字外的所有字符 ^托字符\nd 匹配数字，效果等同于[0-9]\nD 匹配除数字以外的字符 [^0-9]\n\nw 匹配数字，字母及下划线 效果等同于[0-9a-zA-Z_]\nW 取反\ns 匹配任意空白字符（空格，换行，制表，换页，回车）[ntfr]\nS 取反\n\nprint(re.findall('.','http:\\n//'))\n# ['h', 't', 't', 'p', ':', '/', '/']\nprint(re.findall('[12345]','qhchg461905nkj'))  \n# ['4', '1', '5']\n\n\n# 保留原始字符的R/r在正则中无效\nprint(re.findall(r'\\D','123qwr'))\n# ['q', 'w', 'r']\n\nprint(re.findall('\\S','123 gh \\n 78\\r'))\n# ['1', '2', '3', 'g', 'h', '7', '8']\n\n\n^  行首匹配(不在方括号内)\n$  行尾匹配（不在方括号内）当需要进行多行匹配时候，需要设置flags=re.M，如果不写默认匹配字符串的开头和结尾 只匹配一次\nA 行首匹配 与^的区别:A只匹配整个字符串的开头，即使有flags = re.M参数也不会匹配其他的行首\nZ 行尾匹配 与$的区别：Z只匹配整个字符串的结尾，即使有flags = re.M参数也不会匹配其他的行尾\nb 匹配字符边界 就是字符串与空格间的位置，比如'ce\\b',可以匹配nice  不能匹配nicer\nB 匹配非字符边界\n\n# 看你是否nice开始 类似于match\nprint(re.findall('^nice','to nice meet you'))\n# []\n\n# 多行开头匹配\nprint(re.findall('^nice','nice to meet you\\nnice to meet you', re.M))\n# ['nice', 'nice']\n\n# 是否是com结尾\nprint(re.findall('com$', 'http:baidu.com'))\n# ['com']\n\n# \\b 本身是个转义字符，但在正则中也有特殊意义，在正则字符串前面加r\n# 将将转义字符的意义去掉 保留正则的意义\n# 以空格有边界的有一个ce\nprint(re.findall(r'ce\\b', 'nice to meet niceto meet'))\n# ['ce']\n\n\n\n\n(abc)  匹配小括号中的字符作为整体\n\nx?    ? 匹配0或1个x字符  非贪婪匹配\n\nx+    + 匹配至少一个x     贪婪匹配\n\nx*    * 匹配任意多个x     贪婪匹配\n\nx{n}  匹配确定的n个x 非负整数\n\nx{n,}  匹配大于等于n个x\n\nx{n,m} 匹配至少n个x，最多m个\n\nx|y 匹配x或y\n\nprint(re.findall('[abc]', 'qwracb'))\n# ['a', 'c', 'b']\n\nprint(re.findall('(abc)', 'qwrabc'))\n# ['abc']\n\nprint(re.findall('a?','a'))\n# ['a', '']\n\nprint(re.findall('(aa)?', 'aaab'))\n# ['aa', '', '', '']\n\nprint(re.findall('(aa)','aaaab'))\n# ['aa', 'aa']\nprint(re.findall('(aa)+','aaaab'))  \n# 由于是贪婪匹配，相当于在最长的aaaa中找出： ['aa']\n\nprint(re.findall('aa+','aabaaaabaaaba')) \n# 最后一个a没 ['aa', 'aaaa', 'aaa']\n\nprint(re.findall('a*', 'abaabbaaabaaaabb'))\n# 匹配任意多个a\n# ['a', '', 'aa', '', '', 'aaa', '', 'aaaa', '', '', '']\n\nprint(re.findall('a{3}','aabaaacsdsaaa'))\n# ['aaa', 'aaa']\nprint(re.findall('a{3,}','aabbaaabbaaaa'))\n# ['aaa', 'aaaa']\n\nprint(re.findall('(good)','good--Good-good'))\nprint(re.findall('good','good--Good-good'))\n# ['good', 'good']\n\nprint(re.findall('(good)|(Good)','good--Good'))\n# [('good', ''), ('', 'Good')]\nprint(re.findall('good|Good','good--Good'))\n# ['good', 'Good']\n\n特殊元字符\n\n.   匹配除换行符以为的所有字符*   匹配任意多个 贪婪匹配?   匹配0个或一个.*? 将贪婪匹配变为非贪婪\n\nprint(re.findall('.',''))\n# []\nprint(re.findall('.*',''))  \n# ['']\n\nr = 'who .* he'\nprint(re.findall(r, 'who is a girl he who is boy he '))\n# ['who is a girl he who is boy he'] 贪婪\n\nr = 'who .*? he'\nprint(re.findall(r, 'who is a girl he who is boy he who  he'))\n# ['who is a girl he', 'who is boy he', 'who  he'] 非贪婪\n\n分组\n正则中有组的概念分组：group正则有判断是否匹配的功能，还提供了提取子串的功能，用()表示提取的分组，从外向里，从左向右标注第几组\ntmp = '\\d{3}-\\d{8}'\nstr1 = '010-12345678'\nresult = re.findall(tmp, str1)\nprint(result)\n# ['010-12345678']\n\ntmp2 ='(\\d{3})-(\\d{8})' # 用小括号括起来的内容为一组\nresult2 = re.findall(tmp2, str1)\nprint(result2)\n# [('010', '12345678')]\n\ntmp3 = '(\\d{3})-(\\d{8})'\nresult3 = re.match(tmp3, str1)\nprint(result3)\n# <_sre.SRE_Match object; span=(0, 12), match='010-12345678'>\n\n# groups()可以查看匹配到的所有分组的情况\nprint(result3.groups())  # ('010', '12345678')\n\n# group() 可以单独获取分组情况\n# group(0) 一直代表匹配到的原始字符串\nprint(result3.group())   # 010-12345678\nprint(result3.group(0))  # 010-12345678\nprint(result3.group(1))  # 010\nprint(result3.group(2))  # 12345678\n\n# 另起名称(?P<名称>)\ntmp4 = '(?P<love>\\d{3})-(?P<like>\\d{8})'\nresult4 = re.match(tmp4, str1)\nprint(result4.group(0))\nprint(result4.group(1))\nprint(result4.group(2))\nprint(result4.group('love'))\n\n\n正则与字符串\nstr1 = 'ac b  c   d     e'\nprint(str1.split())\n# ['ac', 'b', 'c', 'd', 'e']\n\nprint(re.split(' +', str1))\n# ['ac', 'b', 'c', 'd', 'e']\n\n# 替换字符串\n# re.sub(pattern, rep1, string)\n# pattern: 即将被替换的字符\n# rep1:替换的字符\n# count 替换次数\n# subn 将结果和替换的次数放到一个元组了\nres2 = re.sub(' +', '*', str1)\nprint(res2)  \n# ac*b*c*d*e\n\nres2 = re.sub(' +', '*', str1, count=2)\nprint(res2)\n# ac*b*c   d     e\n\nres2 = re.subn(' +', '*', str1)\nprint(res2)\n# ('ac*b*c*d*e', 4)\n\ncompile\ntmp = '\\d{3}-\\d{8}'\nstr1 = '090-99999999'\nres = re.match(tmp, str1)\nprint(res)\n\ntmp2 = '\\d{3}-\\d{8}'\nstr2 = '090-99999999'\nre_tmp2 = re.compile(tmp2)\nres2 = re_tmp2.match(str2)\nprint(res2)\n# <_sre.SRE_Match object; span=(0, 12), match='090-99999999'>\n\n\n例子\n# 判断某一个字符串是不是11位，第一个是否是数字1\n\nr= '^1\\d{10}$'\n# 1开头\n# 10个数字结尾\n\nprint(re.findall(r, '12534568545'))\n\n\n# 前面是3个数字 后面八个数字 中间为-\n\nr= '^\\d{3}-\\d{8}$'\n\n\n# 123456@qq.com\n# ^.\\$ 在正则中有实际意义，如果想要作为普通字符使用需要使用转义字符\n\nr= '^\\d{6}@qq\\.com'    \nprint(re.findall(r,'125565@qq.com'))\n\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}