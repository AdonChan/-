{"title": "Python学习之路10-测试代码 - VPointer ", "index": "python,测试", "content": "《Python编程：从入门到实践》笔记。本章主要学习如何使用Python标准库中的unittest模块对代码进行简单的测试。\n1. 前言\n作为初学者，并非必须为你尝试的所有项目编写测试；但参与工作量较大的项目时，你应对自己编写的函数和类的重要行为进行测试。这样你就能够更加确定自己所做的工作不会破坏项目的其他部分，你就能够随心所欲地改进即有代码。如果不小心破坏了原来的功能，你马上就会知道，从而能够轻松地修复问题。相比于等到Bug出现后再去改，在测试未通过时采取措施要容易得多。而且，如果你想要分享你的项目，有测试的代码更容易让人接受。\n2. 测试函数\n2.1 一个能通过的测试\n以下是一个将用户输入的姓与名拼接的函数：\n# name_function.py\ndef get_formatted_name(first, last):\n    \"\"\"返回一个整洁的完整姓名\"\"\"\n    full_name = first + \" \" + last\n    return full_name.title()\n\n\nif __name__ == '__main__':\n    print(\"Enter 'q' at any time to quit.\")\n    while True:\n        first = input(\"\\nPlease give me a first name: \")\n        if first == \"q\":\n            break\n        last = input(\"Please give me a last name: \")\n        if last == \"q\":\n            break\n\n        formatted_name = get_formatted_name(first, last)\n        print(\"\\nNeatly formatted name: \" + formatted_name + \".\")\n当然你也可以将if语句下面的代码单独放在一个文件中，并在该文件开头带入get_formatted_name()函数。\n对if __name__ == \"__main__\"的补充：\n在Python中，模块就是对象，所有模块都有一个内置属性__name__，当该模块被导入时，该模块的__name__属性会被置为模块名，当直接运行该模块，或者说直接运行该文件时，该属性就会使用默认值\"__main__\"，可以用一句经典的话总结这个用法：\nMake a script both importable and executable.\nif语句下面的代码相当于对上面的函数的测试，不过这样的测试每次都需要我们自己输入数据，并自己根据结果判断代码是否工作正常，如果代码稍微多一点，稍微复杂一点，这样的测试方法将会很繁琐，所以，我们使用unittest模块了测试代码。\n# 代码test_name_function.py：\nimport unittest\nfrom name_function import get_formatted_name\n\nclass NamesTestCase(unittest.TestCase):\n    \"\"\"测试name_function.py\"\"\"\n\n    def test_first_last_name(self):\n        \"\"\"能够正确地处理像Janis Joplin这样的名字吗？\"\"\"\n        formatted_name = get_formatted_name(\"janis\", \"joplin\")\n        self.assertEqual(formatted_name, \"Janis Joplin\")\n\nunittest.main()\n\n# 结果：\n.     # 这里有个实心句点\n----------------------------------------------------------------------\nRan 1 test in 0.001s\n\nOK\n这里先明确两个概念：\n单元测试：用于核实函数在某个方面没有问题\n测试用例：一组单元测试，这些单元测试一起核实函数在各种情况下的行为都符合要求。\n也就是说，你可以将上述代码中的test_first_last_name看做单元测试，而将NamesTestCase看做测试用例。\n一般测试文件单独放在一个文件夹中，也可以将测试都放在一个文件中。\n为函数编写测试用例，可先导入unittest模块和要测试的函数，再创建一个继承unittest.TestCase的类，并编写一系列方法对函数行为的不同方面进行测试。在测试用，我们使用断言self.assertEqual()(并不是只有这一个断言函数)来判断结果与期望是否相同。在测试类中的每一个测试方法都必须以test_开头，否则将不会被认定是一个单元测试。最后我们通过unittest.main()来运行这个文件中的所有测试。当测试通过时，结果中会先输出一个实心句点，输出几个句点表示通过了几个单元测试，然后输出单元测试数目，最后输出OK。\n2.2 一个不能通过的测试\n外国人的名字还有中间名，以上代码并未考虑这个情况。我们通过将上述代码改成含有中间名的版本来演示测试不通过的情况：\n# 代码：\ndef get_formatted_name(first, middle, last):\n    \"\"\"返回一个整洁的完整姓名\"\"\"\n    full_name = first + \" \" + middle + \" \" + last\n    return full_name.title()\n\n# 其余代码均不变\n\n# 运行上面测试代码后的结果：\nE\n======================================================================\nERROR: test_first_last_name (__main__.NamesTestCase)\n能够正确地处理像Janis Joplin这样的名字吗？\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"test_name_function.py\", line 10, in test_first_last_name\n    formatted_name = get_formatted_name(\"janis\", \"joplin\")\nTypeError: get_formatted_name() missing 1 required positional argument: 'last'\n\n----------------------------------------------------------------------\nRan 1 test in 0.001s\n\nFAILED (errors=1)\n第一行输出了一个字母E，traceback指出缺少了参数。如果你检查的条件没错，测试通过了意味着函数的行为是对的，而测试未通过意味着你编写的新代码有错。因此，测试未通过时，不是去修改测试代码，而失去修改你编写的代码。\n2.3 添加新测试\n以下我们将上述的get_formatted_name()函数修改为能自动处理中间名的函数，并在测试文件中添加一个单元测试：\n# name_function.py\ndef get_formatted_name(first, last, middle=\"\"):\n    \"\"\"返回一个整洁的完整姓名\"\"\"\n    if middle:\n        full_name = first + \" \" + middle + \" \" + last\n    else:\n        full_name = first + \" \" + last\n    return full_name.title()\n\n# test_name_function.py\nimport unittest\nfrom chapter11 import get_formatted_name\n\nclass NamesTestCase(unittest.TestCase):\n    \"\"\"测试name_function.py\"\"\"\n\n    def test_first_last_name(self):\n        \"\"\"能够正确地处理像Janis Joplin这样的名字吗？\"\"\"\n        formatted_name = get_formatted_name(\"janis\", \"joplin\")\n        self.assertEqual(formatted_name, \"Janis Joplin\")\n\n    def test_first_last_middle_name(self):\n        \"\"\"能够正确地处理像Wolfgang Amadeus Mozart这样的姓名吗？\"\"\"\n        formatted_name = get_formatted_name(\"wolfgang\", \"mozart\", \"amadeus\")\n        self.assertEqual(formatted_name, \"Wolfgang Amadeus Mozart\")\n\nunittest.main()\n\n# 结果：\n..\n----------------------------------------------------------------------\nRan 2 tests in 0.000s\n\nOK\n3. 测试类\n前面讲的都是对函数的测试，这里我们开始对类的测试。在测试之前，先介绍几种常用的断言方法：\n\n\n方法\n用途\n\n\n\nassertEqual(a, b)\n核实 a == b\n\n\nassertNotEqual(a, b)\n核实 a != b\n\n\nassertTrue(x)\n核实x为True\n\n\nassertFalse(x)\n核实x为False\n\n\nassertIn(item, list)\n核实item在list中\n\n\nassertNotIn(item, list)\n核实item不在list中\n\n\n\n下面创建一个匿名调查类：\n# survey.py\nclass AnonymousSurvey:\n    \"\"\"收集匿名调查问卷的答案\"\"\"\n\n    def __init__(self, question):\n        \"\"\"存储一个问题，并为存储答案做准备\"\"\"\n        self.question = question\n        self.responses = []\n\n    def show_question(self):\n        \"\"\"显示调查问卷\"\"\"\n        print(self.question)\n\n    def store_response(self, new_response):\n        \"\"\"存储单份调查问卷\"\"\"\n        self.responses.append(new_response)\n\n    def show_results(self):\n        \"\"\"显示收集到的所有答卷\"\"\"\n        print(\"Survey results:\")\n        for response in self.responses:\n            print(\"- \" + response)\n以下是对该类的测试代码：\n# test_survey.py\nimport unittest\nfrom chapter11 import AnonymousSurvey\n\nclass TestAnonymousSurvey(unittest.TestCase):\n    \"\"\"针对AnonymousSurvey类的测试\"\"\"\n\n    def setUp(self):\n        \"\"\"创建一个调查对象和一组答案，共测试方法使用\"\"\"\n        question = \"What language did you first learn to speak?\"\n        self.my_survey = AnonymousSurvey(question)\n        self.responses = [\"English\", \"Spanish\", \"Mandarin\"]\n\n    def test_store_single_response(self):\n        \"\"\"测试单个答案呗妥善地存储\"\"\"\n        self.my_survey.store_response(self.responses[0])\n        self.assertIn(self.responses[0], self.my_survey.responses)\n\n    def test_store_three_responses(self):\n        \"\"\"测试三个答案会被妥善地存储\"\"\"\n        for response in self.responses:\n            self.my_survey.store_response(response)\n        for response in self.responses:\n            self.assertIn(response, self.my_survey.responses)\n\nunittest.main()\n\n# 结果：\n..\n----------------------------------------------------------------------\nRan 2 tests in 0.000s\n\nOK\n这里的setUp()方法相当于普通函数的__init__()方法，用于初始化这个测试类，减少重复代码，比如，如果不用setUp()方法，那么question变量在每个测试函数中都要声明一次，十分麻烦低效。你过测试类中包含了setUp()方法，Python将先运行它，再运行各个以test_开头的方法。\n至此，Python的基础部分大致结束，后面将是项目部分，以后可能还会对基础部分进行补充。\n\n迎大家关注我的微信公众号\"代码港\" & 个人网站 www.vpointer.net ~\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}