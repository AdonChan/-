{"title": "python中操作mysql的pymysql模块详解 - python技术的魅力 ", "index": "pymysql,mysql,python", "content": "简述\npymsql是Python中操作MySQL的模块，其使用方法和MySQLdb几乎相同。但目前pymysql支持python3.x而后者不支持3.x版本。本文测试python版本：3.5.2。mysql版本：5.7.18\n一、安装\npip install pymysql\n二、使用操作\n1. 执行SQL\n#!/usr/bin/env python\n# _*_ coding:utf-8 _*_\n__author__ = 'junxi'\n\nimport pymysql\n\n# 创建连接\nconn = pymysql.connect(host='127.0.0.1', port=3306, user='blog', passwd='123456', db='blog', charset='utf8')\n\n# 创建游标, 查询数据默认为元组类型\ncursor = conn.cursor()\n\n\n# 执行SQL，并返回收影响行数\nrow1 = cursor.execute(\"update users set password = '123'\")\nprint(row1)\n# 执行SQL，并返回受影响行数\nrow2 = cursor.execute(\"update users set password = '456' where id > %s\", (1,))\nprint(row2)\n# 执行SQL，并返回受影响行数（使用pymysql的参数化语句防止SQL注入）\nrow3 = cursor.executemany(\"insert into users(username, password, email)values(%s, %s, %s)\", [(\"ceshi3\", '333', 'ceshi3@11.com'), (\"ceshi4\", '444', 'ceshi4@qq.com')])\nprint(row3)\n\n# 提交，不然无法保存新建或者修改的数据\nconn.commit()\n# 关闭游标\ncursor.close()\n# 关闭连接\nconn.close()\n提示：存在中文的时候，连接需要添加charset='utf8'，否则中文显示乱码。\n2、获取查询数据\n#!/usr/bin/env python\n# _*_ coding:utf-8 _*_\n__author__ = 'junxi'\n\nimport pymysql\n\n# 创建连接\nconn = pymysql.connect(host='127.0.0.1', port=3306, user='blog', passwd='123456', db='blog', charset='utf8')\n\n# 创建游标, 查询数据默认为元组类型\ncursor = conn.cursor()\ncursor.execute(\"select * from users\")\n\n# 获取第一行数据\nrow_1 = cursor.fetchone()\nprint(row_1)\n# 获取前n行数据\nrow_n = cursor.fetchmany(3)\nprint(row_n)\n# 获取所有数据\nrow_3 = cursor.fetchall()\nprint(row_3)\n\n\n# 提交，不然无法保存新建或者修改的数据\nconn.commit()\n# 关闭游标\ncursor.close()\n# 关闭连接\nconn.close()\n3、获取新创建数据自增ID可以获取到最新自增的ID，也就是最后插入的一条数据ID\n#!/usr/bin/env python\n# _*_ coding:utf-8 _*_\n__author__ = 'junxi'\n\nimport pymysql\n\n# 创建连接\nconn = pymysql.connect(host='127.0.0.1', port=3306, user='blog', passwd='123456', db='blog', charset='utf8')\n\n# 创建游标, 查询数据默认为元组类型\ncursor = conn.cursor()\n\ncursor.executemany(\"insert into users(username, password, email)values(%s, %s, %s)\", [(\"ceshi3\", '333', 'ceshi3@11.com'), (\"ceshi4\", '444', 'ceshi4@qq.com')])\nnew_id = cursor.lastrowid\nprint(new_id)\n\n\n# 提交，不然无法保存新建或者修改的数据\nconn.commit()\n# 关闭游标\ncursor.close()\n# 关闭连接\nconn.close()\n4、移动游标\n操作都是靠游标，那对游标的控制也是必须的\n注：在fetch数据时按照顺序进行，可以使用cursor.scroll(num,mode)来移动游标位置，如：\n \ncursor.scroll(1,mode='relative') # 相对当前位置移动\ncursor.scroll(2,mode='absolute') # 相对绝对位置移动\n5、fetch数据类型\n关于默认获取的数据是元组类型，如果想要或者字典类型的数据，即：\nimport pymysql\n\n# 创建连接\nconn = pymysql.connect(host='127.0.0.1', port=3306, user='blog', passwd='123456', db='blog', charset='utf8')\n\n# 游标设置为字典类型\ncursor = conn.cursor(cursor=pymysql.cursors.DictCursor)\n# 左连接查询\nr = cursor.execute(\"select * from users as u left join articles as a on u.id = a.user_id where a.user_id = 2\")\nresult = cursor.fetchall()\nprint(result)\n\n# 查询一个表的所有字段名\nc = cursor.execute(\"SHOW FULL COLUMNS FROM users FROM blog\")\ncc = cursor.fetchall()\n\n\n# 提交，不然无法保存新建或者修改的数据\nconn.commit()\n# 关闭游标\ncursor.close()\n# 关闭连接\nconn.close()\n查看运行结果：\n[{'user_id': 2, 'id': 2, 'password': '456', 'email': 'xinlei2017@test.com', 'a.id': 2, 'content': '成名之路', 'title': '星光大道', 'username': 'tangtang'}]\n6、调用存储过程\na、调用无参存储过程\n#! /usr/bin/env python\n# -*- coding:utf-8 -*-\n\nimport pymysql\n \nconn = pymysql.connect(host='127.0.0.1', port=3306, user='blog', passwd='123456', db='blog', charset='utf8')\n#游标设置为字典类型\ncursor = conn.cursor(cursor=pymysql.cursors.DictCursor)\n#无参数存储过程\ncursor.callproc('p2')  #等价于cursor.execute(\"call p2()\")\n \nrow_1 = cursor.fetchone()\nprint row_1\n \n \nconn.commit()\ncursor.close()\nconn.close()\nb、调用有参存储过程\n#! /usr/bin/env python\n# -*- coding:utf-8 -*-\n\nimport pymysql\n \nconn = pymysql.connect(host='127.0.0.1', port=3306, user='blog', passwd='123456', db='blog', charset='utf8')\ncursor = conn.cursor(cursor=pymysql.cursors.DictCursor)\n \ncursor.callproc('p1', args=(1, 22, 3, 4))\n#获取执行完存储的参数,参数@开头\ncursor.execute(\"select @p1,@_p1_1,@_p1_2,@_p1_3\")  \n# {u'@_p1_1': 22, u'@p1': None, u'@_p1_2': 103, u'@_p1_3': 24}\nrow_1 = cursor.fetchone()\nprint row_1\n \n \nconn.commit()\ncursor.close()\nconn.close()\n三、关于pymysql防注入\n1、字符串拼接查询，造成注入\n正常查询语句：\n#! /usr/bin/env python\n# -*- coding:utf-8 -*-\n\nimport pymysql\n \nconn = pymysql.connect(host='127.0.0.1', port=3306, user='blog', passwd='123456', db='blog', charset='utf8')\ncursor = conn.cursor()\nusername = \"ceshi1\"\npassword = \"ceshi1passwd\"\n# 正常构造语句的情况\nsql = \"select username, password from users where user='%s' and pass='%s'\" % (username, password)\n# sql = select username, password from users where user='ceshi1' and pass='ceshi1passwd'\nrow_count = cursor.execute(sql) \nrow_1 = cursor.fetchone()\nprint row_count, row_1\n \nconn.commit()\ncursor.close()\nconn.close()\n构造注入语句：\n#! /usr/bin/env python\n# -*- coding:utf-8 -*-\n\nimport pymysql\n \nconn = pymysql.connect(host='127.0.0.1', port=3306, user='blog', passwd='123456', db='blog', charset='utf8')\ncursor = conn.cursor()\n \nusername = \"u1' or '1'-- \"\npassword = \"u1pass\"\nsql=\"select username, password from users where username='%s' and password='%s'\" % (username, password)\n \n# 拼接语句被构造成下面这样，永真条件，此时就注入成功了。因此要避免这种情况需使用pymysql提供的参数化查询。\n# select user,pass from tb7 where user='u1' or '1'-- ' and pass='u1pass'\n \nrow_count = cursor.execute(sql)\nrow_1 = cursor.fetchone()\nprint row_count,row_1\n \n \nconn.commit()\ncursor.close()\nconn.close()\n2、避免注入，使用pymysql提供的参数化语句\n正常参数化查询\n#! /usr/bin/env python\n# -*- coding:utf-8 -*-\n\n \nimport pymysql\n \nconn = pymysql.connect(host='127.0.0.1', port=3306, user='blog', passwd='123456', db='blog', charset='utf8')\ncursor = conn.cursor()\nusername=\"u1\"\npassword=\"u1pass\"\n#执行参数化查询\nrow_count=cursor.execute(\"select username,password from tb7 where username=%s and password=%s\",(username,password))\nrow_1 = cursor.fetchone()\nprint row_count,row_1\n \nconn.commit()\ncursor.close()\nconn.close()\n构造注入，参数化查询注入失败。\n#! /usr/bin/env python\n# -*- coding:utf-8 -*-\n\nimport pymysql\n \nconn = pymysql.connect(host='127.0.0.1', port=3306, user='blog', passwd='123456', db='blog', charset='utf8')\ncursor = conn.cursor()\n \nusername=\"u1' or '1'-- \"\npassword=\"u1pass\"\n#执行参数化查询\nrow_count=cursor.execute(\"select username,password from users where username=%s and password=%s\",(username,password))\n#内部执行参数化生成的SQL语句，对特殊字符进行了加\\转义，避免注入语句生成。\n# sql=cursor.mogrify(\"select username,password from users where username=%s and password=%s\",(username,password))\n# print sql\n#select username,password from users where username='u1\\' or \\'1\\'-- ' and password='u1pass'被转义的语句。\n \nrow_1 = cursor.fetchone()\nprint row_count,row_1\n \nconn.commit()\ncursor.close()\nconn.close()\n结论：excute执行SQL语句的时候，必须使用参数化的方式，否则必然产生SQL注入漏洞。\n3、使用存mysql储过程动态执行SQL防注入\n使用MYSQL存储过程自动提供防注入，动态传入SQL到存储过程执行语句。\ndelimiter \\\\\nDROP PROCEDURE IF EXISTS proc_sql \\\\\nCREATE PROCEDURE proc_sql (\n  in nid1 INT,\n  in nid2 INT,\n  in callsql VARCHAR(255)\n  )\nBEGIN\n  set @nid1 = nid1;\n  set @nid2 = nid2;\n  set @callsql = callsql;\n    PREPARE myprod FROM @callsql;\n--   PREPARE prod FROM 'select * from users where nid>? and nid<?';  传入的值为字符串，？为占位符\n--   用@p1，和@p2填充占位符\n    EXECUTE myprod USING @nid1,@nid2;\n  DEALLOCATE prepare myprod;\n \nEND\\\\\ndelimiter ;\nset @nid1=12;\nset @nid2=15;\nset @callsql = 'select * from users where nid>? and nid<?';\nCALL proc_sql(@nid1,@nid2,@callsql)\npymsql中调用\n#! /usr/bin/env python\n# -*- coding:utf-8 -*-\n\nimport pymysql\n \nconn = pymysql.connect(host='127.0.0.1', port=3306, user='blog', passwd='123456', db='blog', charset='utf8')\ncursor = conn.cursor()\nsql1=\"select * from users where nid>? and nid<?\"\ncursor.callproc('proc_sql', args=(11, 15, sql1))\n \nrows = cursor.fetchall()\nprint rows\nconn.commit()\ncursor.close()\nconn.close()\n四、使用with简化连接过程\n# 使用with简化连接过程，每次都连接关闭很麻烦，使用上下文管理，简化连接过程\nimport pymysql\nimport contextlib\n\n\n# 定义上下文管理器，连接后自动关闭连接\n@contextlib.contextmanager\ndef mysql(host='127.0.0.1', port=3306, user='blog', passwd='123456', db='blog', charset='utf8'):\n    conn = pymysql.connect(host=host, port=port, user=user, passwd=passwd, db=db, charset=charset)\n    cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)\n    try:\n        yield cursor\n    finally:\n        conn.commit()\n        cursor.close()\n        conn.close()\n\n# 执行sql\nwith mysql() as cursor:\n    # 左连接查询\n    r = cursor.execute(\"select * from users as u left join articles as a on u.id = a.user_id where a.user_id = 2\")\n    result = cursor.fetchall()\n    print(result)\n查看运行结果：\n[{'title': '星光大道', 'username': 'tangtang', 'user_id': 2, 'email': 'xinlei3166@126.com', 'a.id': 2, 'content': '成名之路', 'password': '456', 'id': 2}]\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}