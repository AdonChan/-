{"title": "sanic中文文档 - 个人文章 ", "index": "python,python3.5,web框架", "content": "入门指南\nInstall Sanic：python3 -m pip install sanicexample\nfrom sanic import Sanic\nfrom sanic.response import text\napp = Sanic(__name__)\n@app.route(\"/\")\nasync def test(request):\n    return text('Hello world!')\napp.run(host=\"0.0.0.0\", port=8000, debug=True)\n路由\n路由允许用户为不同的URL端点指定处理程序函数。\ndemo:\nfrom sanic.response import json\n@app.route(\"/\")\nasync def test(request):\n    return json({ \"hello\": \"world\" })\nurl http://server.url/ 被访问(服务器的基本url)，最终'/'被路由器匹配到处理程序函数，测试，然后返回一个JSON对象。\n请求参数\n请求参数\n要指定一个参数，可以用像这样的角引号<PARAM>包围它。请求参数将作为关键字参数传递给路线处理程序函数。demo\nfrom sanic.response import text\n@app.route('/tag/<tag>')\nasync def tag_handler(request, tag):\n    return text('Tag - {}'.format(tag))\n为参数指定类型，在参数名后面添加（：类型）。如果参数不匹配指定的类型，Sanic将抛出一个不存在的异常，导致一个404页面demo：\nfrom sanic.response import text\n@app.route('/number/<integer_arg:int>')\nasync def integer_handler(request, integer_arg):\n    return text('Integer - {}'.format(integer_arg))\n@app.route('/number/<number_arg:number>')\nasync def number_handler(request, number_arg):\n    return text('Number - {}'.format(number_arg))\n@app.route('/person/<name:[A-z]+>')\nasync def person_handler(request, name):\n    return text('Person - {}'.format(name))\n@app.route('/folder/<folder_id:[A-z0-9]{0,4}>')\nasync def folder_handler(request, folder_id):\n    return text('Folder - {}'.format(folder_id))\n请求类型\n路由装饰器接受一个可选的参数，方法，它允许处理程序函数与列表中的任何HTTP方法一起工作。\ndemo_1\nfrom sanic.response import text\n@app.route('/post', methods=['POST'])\nasync def post_handler(request):\n    return text('POST request - {}'.format(request.json))\n@app.route('/get', methods=['GET'])\nasync def get_handler(request):\n    return text('GET request - {}'.format(request.args))\ndemo_2\nfrom sanic.response import text\n@app.post('/post')\nasync def post_handler(request):\n    return text('POST request - {}'.format(request.json))\n@app.get('/get')\nasync def get_handler(request):\n    return text('GET request - {}'.format(request.args))\n增加路由\nfrom sanic.response import text\n# Define the handler functions\nasync def handler1(request):\n    return text('OK')\nasync def handler2(request, name):\n    return text('Folder - {}'.format(name))\nasync def person_handler2(request, name):\n    return text('Person - {}'.format(name))\n# Add each handler function as a route\napp.add_route(handler1, '/test')\napp.add_route(handler2, '/folder/<name>')\napp.add_route(person_handler2, '/person/<name:[A-z]>', methods=['GET'])\nurl_for\nSanic提供了一个urlfor方法，根据处理程序方法名生成url。避免硬编码url路径到您的应用程序demo\n@app.route('/')\nasync def index(request):\n    # generate a URL for the endpoint `post_handler`\n    url = app.url_for('post_handler', post_id=5)\n    # the URL is `/posts/5`, redirect to it\n    return redirect(url)\n@app.route('/posts/<post_id>')\nasync def post_handler(request, post_id):\n    return text('Post - {}'.format(post_id))\nNotice:\n给url equest的关键字参数不是请求参数，它将包含在URL的查询字符串中。例如:\nurl = app.url_for('post_handler', post_id=5, arg_one='one', arg_two='two')\n# /posts/5?arg_one=one&arg_two=two\n所有有效的参数必须传递给url以便构建一个URL。如果没有提供一个参数，或者一个参数与指定的类型不匹配，就会抛出一个URLBuildError可以将多值参数传递给url\nurl = app.url_for('post_handler', post_id=5, arg_one=['one', 'two'])\n# /posts/5?arg_one=one&arg_one=two\nWebSocket routes(网络套接字路由)\nwebsocket 可以通过装饰路由实现demo：\n@app.websocket('/feed')\nasync def feed(request, ws):\n    while True:\n        data = 'hello!'\n        print('Sending: ' + data)\n        await ws.send(data)\n        data = await ws.recv()\n        print('Received: ' + data)\n        \n另外，添加 websocket 路由方法可以代替装饰器\n\nasync def feed(request, ws):\n    pass\napp.add_websocket_route(my_websocket_handler, '/feed')\n响应（ response ）\ntext\nfrom sanic import response\n@app.route('/text')\ndef handle_request(request):\n    return response.text('Hello world!')\nHTML\nfrom sanic import response\n@app.route('/html')\ndef handle_request(request):\n    return response.html('<p>Hello world!</p>')\nJSON\nfrom sanic import response\n@app.route('/json')\ndef handle_request(request):\n    return response.json({'message': 'Hello world!'})\nFile\nfrom sanic import response\n@app.route('/file')\nasync def handle_request(request):\n    return await response.file('/srv/www/whatever.png')\nStreaming\nfrom sanic import response\n@app.route(\"/streaming\")\nasync def index(request):\n    async def streaming_fn(response):\n        response.write('foo')\n        response.write('bar')\n    return response.stream(streaming_fn, content_type='text/plain')\nFile Streaming\n对于大文件，文件和流的组合\nfrom sanic import response\n@app.route('/big_file.png')\nasync def handle_request(request):\n    return await response.file_stream('/srv/www/whatever.png')\nRedirect\nfrom sanic import response\n@app.route('/redirect')\ndef handle_request(request):\n    return response.redirect('/json')\nRaw\n没有进行编码的响应\nfrom sanic import response\n@app.route(‘/raw ’)\ndef handle_request(request):\nreturn response.raw(‘ raw data ’)\nModify headers or status\n要修改头或状态代码，将标题或状态参数传递给这些函数\nfrom sanic import response\n@app.route(‘/json ’)\ndef handle_request(request):\nreturn response.json(\n{‘ message ’: ‘ Hello world!’},\nheaders={‘ X-Served-By ’: ‘ sanic ’},\nstatus=200\n)\n更多的内容:Sanic 中文文档\n\n静态文件\n异常处理\n中间件和监听\n蓝图\n配置\n装饰器\n流\n请求数据\n试图类\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "2"}