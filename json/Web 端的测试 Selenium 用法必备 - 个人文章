{"title": "Web 端的测试 Selenium 用法必备 - 个人文章 ", "index": "测试,selenium,web,python", "content": "大家都知道，基于Web端的测试的基础框架是需要Selenium做主要支撑的，这里边给大家介绍下Web测试核心之基于 Python 的 Selenium\n一、简单介绍\nSelenium 是用于测试 Web 应用程序用户界面 (UI) 的常用框架。它是一款用于运行端到端功能测试的超强工具。您可以使用多个编程语言编写测试，并且 Selenium 能够在一个或多个浏览器中执行这些测试。\n二、环境安装\n1.安装 python，这个。。。忽略，建议 python2.7。\n2.安装基于 python 的 selenium 依赖包，命令：pip install selenium==2.53.6，你懂的。\n3.安装浏览器驱动包，推荐使用 chrome 浏览器的 chromedriver.exe，对应 chrome 版本一定要对哦，不然运行不起来的，安装在哪？想放哪放哪，不过一般是放在 python 的根目录下。下载地址：chromedriver.storage.googleapis.com/index.html\n4.安装 PyCharm 2.7 左右版本，这个无脑安装~然后可自定义界面 UI 及编码风格，这个。。。忽略\n三、牛刀小试\n1.控制浏览器 #coding=utf-8from selenium import webdriverdriver = webdriver.Chrome()driver.get(\"http://www.baidu.com\")driver.maximize_window() #将浏览器最大化显示driver.set_window_size(480, 800) #设置浏览器宽480、高800显示\" driver.back() #后退driver.forward() #前进 driver.close() #关闭chromedriver.quit() # 退出chrome对Python开发感兴趣可以加705673780，群内会有不定期的发放免费的资料链接，这些资料都是从各个技术网站搜集、整理出来的，如果你有好的学习资料可以私聊发我，我会注明出处之后分享给大家。\n2.对象的定位\n通过 id 定位：find_element_by_id()\n通过 name 定位：find_element_by_name()\n通过 class 定位：find_element_by_class_name()\n通过 tag 定位：find_element_by_tag_name()\n通过 link 定位：find_element_by_link_text()\n通过 partial_link 定位：find_element_by_partial_link_text()\n通过 xpath 定位：find_element_by_xpath()\n通过 css 定位：find_element_by_css_selector()\n以上几种定位是常规操作，应该就基本够用了，但是有的时候就是会出现一些诡异的定位失效或者定位到了点击失效的问题，这个时候如果用js进行直接执行该事件，接下来介绍下非常规操作：\nid 定位：document.getElementById()\nname 定位：document.getElementsByName()\ntag 定位：document.getElementsByTagName()\nclass 定位：document.getElementsByClassName()\ncss 定位：document.querySelectorAll()\n   search_js = \"document.getElementsByName('wd')[0].value='selenium';\"# 通过name定位，然后赋值“selenium”\n   search_js2 = \"document.querySelectorAll('.s_ipt')[0].value='selenium';\"# 通过css定位，然后赋值“selenium”\n   button_js = \"document.getElementById('su').click();\"# 通过id定位，然后执行单击操作\n   button_js2 = \"document.getElementsByClassName('s_btn')[0].click()\"# 通过className定位，然后执行单击操作 driver.execute_script(search_js2)#执行，execute_script(script, *args)\n\n以上几种定位是可以再度升级，可以利用 jQuery 定位一波，这里可参看之前总结的 JQ 选择器中的思维导图知识点（www.cnblogs.com/aoaoao/arti… JS，便忽略\n3.操作测试对象\n #coding=utf-8\nfrom selenium import webdriver\ndriver = webdriver.Chrome()\ndriver.get(\"http://passport.kuaibo.com/login/\")\ndriver.find_element_by_id(\"user_name\").clear() #清除输入框的默认内容\ndriver.find_element_by_id(\"user_name\").send_keys(\"username\")\ndriver.find_element_by_id(\"user_pwd\").clear()\ndriver.find_element_by_id(\"user_pwd\").send_keys(\"password\") #输入输入框的内容为“password”\ndriver.find_element_by_id(\"dl_an_submit\").click() #通过 submit() 来提交操作\ndriver.find_element_by_id(\"dl_an_submit\").submit()\nsize=driver.find_element_by_id(\"kw\").size #返回百度输入框的宽高 text=driver.find_element_by_id(\"cp\").text #返回百度页面底部备案信息\n#返回元素的属性值，可以是 id、name、type 或元素拥有的其它任意属性\nattribute=driver.find_element_by_id(\"kw\").get_attribute('type') #返回元素的结果是否可见，返回结果为 True 或 False\nresult=driver.find_element_by_id(\"kw\").is_displayed()\ndriver.quit() #退出\n\n4.鼠标键盘事件\nfrom selenium import webdriver #引入 Keys 类包\nfrom selenium.webdriver.common.keys import Keys #引入 ActionChains 类\nfrom selenium.webdriver.common.action_chains import ActionChains\n... #鼠标事件 #定位到要操作的元素\nright =driver.find_element_by_xpath(\"xx\") #对定位到的元素执行鼠标右键操作\nActionChains(driver).context_click(right).perform() #对定位到的元素执行鼠标双击操作\nActionChains(driver).double_click(right).perform() #对定位到的元素执行鼠标移动到上面的操作\nActionChains(driver).move_to_element(right).perform() #对定位到的元素执行鼠标左键按下的操作\nActionChains(driver).click_and_hold(right).perform() #定位元素的原位置\nelement = driver.find_element_by_name(\"xxx\") #定位元素要移动到的目标位置\ntarget = driver.find_element_by_name(\"xxx\") #执行元素的移动操作\nActionChains(driver).drag_and_drop(element, target).perform() #键盘事件 #删除多输入的一个 值\ndriver.find_element_by_id(\"kw\").send_keys(Keys.BACK_SPACE) #输入空格键+“教程”\ndriver.find_element_by_id(\"kw\").send_keys(Keys.SPACE)\ndriver.find_element_by_id(\"kw\").send_keys(u\"教程\") #ctrl+x 剪切输入框内容\ndriver.find_element_by_id(\"kw\").send_keys(Keys.CONTROL,'x') #其余的键盘操作类似\n\n5.等待时间\n #coding=utf-8\nfrom selenium import webdriver #导入 WebDriverWait 包\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC #导入 time 包\nimport time\ndriver = webdriver.Chrome()\ndriver.get(\"http://www.baidu.com\") #WebDriverWait()方法使用,显示等待,WebDriverWait(driver,超时时长，调用频率，忽略异常).until(可执行方法，超时返回的信息),这里可以调用EC来实现可执行方法\nis_disappeared = WebDriverWait(driver, 30, 1, (ElementNotVisibleException)).until_not(lambda x: x.find_element_by_id(“kw”).is_displayed()) #until(method, message=’ ’),调用该方法提供的驱动程序作为一个参数，直到返回值不为 False\nelement.send_keys(\"selenium\") #添加智能等待，隐时等待\ndriver.implicitly_wait(30)\ndriver.find_element_by_id(\"su\").click() #添加固定休眠时间，强制等待\ntime.sleep(5)\ndriver.quit()\n\n6.组对象定位及层级定位，呃，忽略\n7.多窗口处理\n #coding=utf-8\nfrom selenium import webdriver import time\ndriver = webdriver.Chrome()\ndriver.get(\"http://www.baidu.com/\") #获得当前窗口\nnowhandle=driver.current_window_handle #打开注册新窗口\ndriver.find_element_by_name(\"tj_reg\").click()\nallhandles=driver.window_handles #循环判断窗口是否为当前窗口\nfor handle in allhandles: if handle != nowhandle:\n        driver.switch_to_window(handle) print 'now register window!'\n#切换到邮箱注册标签\ndriver.find_element_by_id(\"mailRegTab\").click()\ntime.sleep(5)\ndriver.close() #回到原先的窗口\ndriver.switch_to_window(nowhandle)\ndriver.find_element_by_id(\"kw\").send_keys(u\"注册成功！\")\ntime.sleep(3) #ifrome处理 #这里会自动识别id，name，如果没有则可以将元素通过选择器找到，然后输入该元素即可\ndriver.switch_to_frame(\"f1\")\nelement = driver.find_element_by_id(\"kw\")\ndriver.switch_to_frame(element)\ndriver.quit()&emsp;\n\n8.提示窗口处理\n #coding=utf-8\nfrom selenium import webdriver import time\ndriver = webdriver.Chrome()\ndriver.get(\"http://www.baidu.com/\") #点击打开搜索设置\ndriver.find_element_by_name(\"tj_setting\").click()\ndriver.find_element_by_id(\"SL_1\").click() #点击保存设置\ndriver.find_element_by_xpath(\"//div[@id='gxszButton']/input\").click() #获取网页上的警告信息\nalert=driver.switch_to_alert() #接收警告信息\nalert.accept() #取消对话框（如果有的话）\nalert.dismiss() #输入值（如果有的话）\nalert.send_keys(“xxx”)\n\n9.控制浏览器滚动条，这个运用之前提示的jq语句即可实现\n10.cookie处理，主要用途在于处理验证码问题\n #coding=utf-8\nfrom selenium import webdriver import time\ndriver = webdriver.Chrome()\ndriver.get(\"http://www.youdao.com\") #向 cookie 的 name 和 value 添加会话信息。\ndriver.add_cookie({'name':'key-aaaaaaa', 'value':'value-bbbb'}) #遍历 cookies 中的 name 和 value 信息打印，当然还有上面添加的信息\nfor cookie in driver.get_cookies(): print \"%s -> %s\" % (cookie['name'], cookie['value']) ##### 下面可以通过两种方式删除 cookie ##### # 删除一个特定的 cookie\ndriver.delete_cookie(\"CookieName\") # 删除所有 cookie\ndriver.delete_all_cookies()\ntime.sleep(2)\ndriver.close()\n\n四、小结\n对Python开发感兴趣可以加705673780，群内会有大佬答疑，学习交流，免费学习资料可以领取。在熟悉了selenium常见的API基本操作后，这里便可以开展实际测试用例的设计了，一个良好的自动化测试用例起码符合一下五个条件：1、一个脚本是一个完整的场景，从用户登陆操作到用户退出系统关闭浏览器。2、一个脚本脚本只验证一个功能点，不要试图用户登陆系统后把所有的功能都进行验证再退出系统3、尽量只做功能中正向逻辑的验证，不要考虑太多逆向逻辑的验证，逆向逻辑的情况很多（例如手 号输错有很多种情况），验证一方面比较复杂，需要编写大量的脚本，另一方面自动化脚本本身比较脆弱， 很多非正常的逻辑的验证能力不强。（我们尽量遵循用户正常使用原则编写脚本即可）4、脚本之间不要产生关联性，也就是说编写的每一个脚本都是独立的，不能依赖或影响其他脚本。5、如果对数据进行了修改，需要对数据进行还原。6、在整个脚本中只对验证点进行验证，不要对整个脚本每一步都做验证。最后配合unittest或者testNG单元测试框架，实现分层、数据驱动、断言、截图、日志等全方位功能，得心应手的开展自动化测试工作。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}