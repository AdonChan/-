{"title": "编写兼容 Python 2 和 Python 3 的代码 - yexiaoxiaobai ", "index": "python3.x,python", "content": "\n  注：本文的作者是 Ed Schofield。原文的地址为： Cheat Sheet: Writing Python 2-3 compatible code\n\n\n该笔记向你展示了编写不会过时的兼容 Python 2 和 Python 3 的代码风格。\n\n它是  Ed Schofield 在 PyCon AU 2014 的演讲，“ Writing 2/3 compatible code ”。\n\n最低版本：\n\n\nPython 2: 2.6+\nPython 3: 3.3+\n\n安装\n\n一些下面的 imports 适用于使用 pip 安装在 PyPI 上安装：\n\nimport future        # pip install future\nimport past          # pip install past\nimport six           # pip install six\n\n\n以下的脚本也适用于 pip 安装：\n\nfuturize             # pip install futurize\npasteurize           # pip install pasteurize\n\n\n查看 http://python-future.org 和 https://pythonhosted.org/six/ 获取更多消息。\n\n基本语法差异\n\nprint：\n\n# Python 2 only:\nprint 'Hello'\n\n\n# Python 2 and 3:\nprint('Hello')\n\n\n为了打印出多个 strings。 import print_function 来防止 Py2 把它解释成一个元组。\n\n# Python 2 only:\nprint 'Hello', 'Guido'\n\n\n# Python 2 and 3:\nfrom __future__ import print_function    # (at top of module)\n\nprint('Hello', 'Guido')\n\n\n# Python 2 only:\nprint >> sys.stderr, 'Hello'\n\n\n# Python 2 and 3:\nfrom __future__ import print_function\n\nprint('Hello', file=sys.stderr)\n\n\n# Python 2 only:\nprint 'Hello',\n\n\n# Python 2 and 3:\nfrom __future__ import print_function\n\nprint('Hello', end='')\n\n\n抛出异常\n\n# Python 2 only:\nraise ValueError, \"dodgy value\"\n\n\n# Python 2 and 3:\nraise ValueError(\"dodgy value\")\n\n\n使用 traceback 抛出异常：\n\n# Python 2 only:\ntraceback = sys.exc_info()[2]\nraise ValueError, \"dodgy value\", traceback\n\n\n# Python 3 only:\nraise ValueError(\"dodgy value\").with_traceback()\n\n\n# Python 2 and 3: option 1\nfrom six import reraise as raise_\n# or\nfrom future.utils import raise_\n\ntraceback = sys.exc_info()[2]\nraise_(ValueError, \"dodgy value\", traceback)\n\n\n# Python 2 and 3: option 2\nfrom future.utils import raise_with_traceback\n\nraise_with_traceback(ValueError(\"dodgy value\"))\n\n\n异常链 (PEP 3134):\n\n# Setup:\nclass DatabaseError(Exception):\n    pass\n\n\n# Python 3 only\nclass FileDatabase:\n    def __init__(self, filename):\n        try:\n            self.file = open(filename)\n        except IOError as exc:\n            raise DatabaseError('failed to open') from exc\n\n\n# Python 2 and 3:\nfrom future.utils import raise_from\n\nclass FileDatabase:\n    def __init__(self, filename):\n        try:\n            self.file = open(filename)\n        except IOError as exc:\n            raise_from(DatabaseError('failed to open'), exc)\n\n\n# Testing the above:\ntry:\n    fd = FileDatabase('non_existent_file.txt')\nexcept Exception as e:\n    assert isinstance(e.__cause__, IOError)    # FileNotFoundError on Py3.3+ inherits from IOError\n\n\n捕获异常：\n\n# Python 2 only:\ntry:\n    ...\nexcept ValueError, e:\n    ...\n\n\n# Python 2 and 3:\ntry:\n    ...\nexcept ValueError as e:\n    ...\n\n\n除法\n\n整除（rounding down）：\n\n# Python 2 only:\nassert 2 / 3 == 0\n\n\n# Python 2 and 3:\nassert 2 // 3 == 0\n\n\n“True division” (float division):\n\n# Python 3 only:\nassert 3 / 2 == 1.5\n\n\n# Python 2 and 3:\nfrom __future__ import division    # (at top of module)\n\nassert 3 / 2 == 1.5\n\n\n“Old division” (i.e. compatible with Py2 behaviour):\n\n# Python 2 only:\na = b / c            # with any types\n\n\n# Python 2 and 3:\nfrom past.utils import old_div\n\na = old_div(b, c)    # always same as / on Py2\n\n\n长整数\n\n短整数在 Python 3 中已经去除了，并且 long 已经变成了 int（没有 L 在 repr 后面）\n\n# Python 2 only\nk = 9223372036854775808L\n\n# Python 2 and 3:\nk = 9223372036854775808\n\n\n# Python 2 only\nbigint = 1L\n\n# Python 2 and 3\nfrom future.builtins import int\nbigint = int(1)\n\n\n为了测试一个值是否是整数（任何类型）：\n\n# Python 2 only:\nif isinstance(x, (int, long)):\n    ...\n\n# Python 3 only:\nif isinstance(x, int):\n    ...\n\n# Python 2 and 3: option 1\nfrom future.builtins import int    # subclass of long on Py2\n\nif isinstance(x, int):             # matches both int and long on Py2\n    ...\n\n# Python 2 and 3: option 2\nfrom past.builtins import long\n\nif isinstance(x, (int, long)):\n    ...\n\n\n八进制常量\n\n0644     # Python 2 only\n\n\n0o644    # Python 2 and 3\n\n\nBacktick repr\n\n`x`      # Python 2 only\n\n\nrepr(x)  # Python 2 and 3\n\n\n元类\n\nclass BaseForm(object):\n    pass\n\nclass FormType(type):\n    pass\n\n\n# Python 2 only:\nclass Form(BaseForm):\n    __metaclass__ = FormType\n    pass\n\n\n# Python 3 only:\nclass Form(BaseForm, metaclass=FormType):\n    pass\n\n\n# Python 2 and 3:\nfrom six import with_metaclass\n# or\nfrom future.utils import with_metaclass\n\nclass Form(with_metaclass(FormType, BaseForm)):\n    pass\n\n\nStrings 和 bytes\n\nUnicode（text） 字符字面量\n\n如果你更新一个已经存在的 Python 2 的代码库，为所有的字符字面量使用 u 做前缀作为 unicode 的标记可能会更好。\n\n# Python 2 only\ns1 = 'The Zen of Python'\ns2 = u'きたないのよりきれいな方がいい\\n'\n\n# Python 2 and 3\ns1 = u'The Zen of Python'\ns2 = u'きたないのよりきれいな方がいい\\n'\n\n\nfuturize 和 python-modernize 工具没有提供一个选项自动完成这个。\n\n如果你为了个项目编写新的代码库，你可以用一个 unicode 字符模块标记所有的字符字面量。\n\n# Python 2 and 3\nfrom __future__ import unicode_literals    # at top of module\n\ns1 = 'The Zen of Python'\ns2 = 'きたないのよりきれいな方がいい\\n'\n\n\n查看  http://python-future.org/unicode_literals.html 这里获取更多的关于讨论使用哪种风格的讨论。\n\n字节-字符 字面量\n\n# Python 2 only\ns = 'This must be a byte-string'\n\n# Python 2 and 3\ns = b'This must be a byte-string'\n\n\nTo loop over a byte-string with possible high-bit characters, obtaining each character as a byte-string of length 1:\n\n# Python 2 only:\nfor bytechar in 'byte-string with high-bit chars like \\xf9':\n    ...\n\n# Python 3 only:\nfor myint in b'byte-string with high-bit chars like \\xf9':\n    bytechar = bytes([myint])\n\n# Python 2 and 3:\nfrom future.builtins import bytes\nfor myint in bytes(b'byte-string with high-bit chars like \\xf9'):\n    bytechar = bytes([myint])\n\n\nchr() 和 .encode('latin-1') 其中的任何一个都可以用于把一个 int  转换成一个  1-char byte string\n\n# Python 3 only:\nfor myint in b'byte-string with high-bit chars like \\xf9':\n    char = chr(myint)    # returns a unicode string\n    bytechar = char.encode('latin-1')\n\n# Python 2 and 3:\nfrom future.builtins import bytes, chr\nfor myint in bytes(b'byte-string with high-bit chars like \\xf9'):\n    char = chr(myint)    # returns a unicode string\n    bytechar = char.encode('latin-1')    # forces returning a byte str\n\n\nbasestring\n\n# Python 2 only:\na = u'abc'\nb = 'def'\nassert (isinstance(a, basestring) and isinstance(b, basestring))\n\n# Python 2 and 3: alternative 1\nfrom past.builtins import basestring    # pip install future\n\na = u'abc'\nb = b'def'\nassert (isinstance(a, basestring) and isinstance(b, basestring))\n\n\n# Python 2 and 3: alternative 2: refactor the code to avoid considering\n# byte-strings as strings.\n\nfrom future.builtins import str\na = u'abc'\nb = b'def'\nc = b.decode()\nassert isinstance(a, str) and isinstance(c, str)\n# ...\n\n\nunicode\n\n# Python 2 only:\ntemplates = [u\"blog/blog_post_detail_%s.html\" % unicode(slug)]\n\n\n# Python 2 and 3: alternative 1\nfrom future.builtins import str\ntemplates = [u\"blog/blog_post_detail_%s.html\" % str(slug)]\n\n\n# Python 2 and 3: alternative 2\nfrom future.builtins import str as text\ntemplates = [u\"blog/blog_post_detail_%s.html\" % text(slug)]\n\n\nStringIO\n\n# Python 2 only:\nfrom StringIO import StringIO\n# or:\nfrom cStringIO import StringIO\n\n# Python 2 and 3:\nfrom io import BytesIO     # for handling byte strings\nfrom io import StringIO    # for handling unicode strings\n\n\nImports relative to a package\n\n假设包的结构是这样的：\n\nmypackage/\n    __init__.py\n    submodule1.py\n    submodule2.py\n\n\nsubmodule1.py 的代码如下：\n\n# Python 2 only:\nimport submodule2\n\n\n# Python 2 and 3:\nfrom . import submodule2\n\n\n# Python 2 and 3:\n# To make Py2 code safer (more like Py3) by preventing\n# implicit relative imports, you can also add this to the top:\nfrom __future__ import absolute_import\n\n\n字典\n\nheights = {'Fred': 175, 'Anne': 166, 'Joe': 192}\n\n\nIterating through dict keys/values/items\n\n迭代字典的键：\n\n# Python 2 only:\nfor key in heights.iterkeys():\n    ...\n\n\n# Python 2 and 3:\nfor key in heights:\n    ...\n\n\n迭代字典的值：\n\n# Python 2 only:\nfor value in heights.itervalues():\n    ...\n\n\n# Idiomatic Python 3\nfor value in heights.values():    # extra memory overhead on Py2\n    ...\n\n\n# Python 2 and 3: option 1\nfrom future.builtins import dict\n\nheights = dict(Fred=175, Anne=166, Joe=192)\nfor key in heights.values():    # efficient on Py2 and Py3\n    ...\n\n\n# Python 2 and 3: option 2\nfrom future.builtins import itervalues\n# or\nfrom six import itervalues\n\nfor key in itervalues(heights):\n    ...\n\n\n迭代字典元素：\n\n# Python 2 only:\nfor (key, value) in heights.iteritems():\n    ...\n\n\n# Python 2 and 3: option 1\nfor (key, value) in heights.items():    # inefficient on Py2\n    ...\n\n\n# Python 2 and 3: option 2\nfrom future.builtins import iteritems\n# or\nfrom six import iteritems\n\nfor (key, value) in iteritems(heights):\n    ...\n\n\n字典的键/值/元素 作为一个列表\n\n字典的键作为一个列表：\n\n# Python 2 only:\nkeylist = heights.keys()\nassert isinstance(keylist, list)\n\n\n# Python 2 and 3:\nkeylist = list(heights)\nassert isinstance(keylist, list)\n\n\n字典的值作为一个列表：\n\n# Python 2 only:\nheights = {'Fred': 175, 'Anne': 166, 'Joe': 192}\nvaluelist = heights.values()\nassert isinstance(valuelist, list)\n\n\n# Python 2 and 3: option 1\nvaluelist = list(heights.values())    # inefficient on Py2\n\n\n# Python 2 and 3: option 2\nfrom future.builtins import dict\n\nheights = dict(Fred=175, Anne=166, Joe=192)\nvaluelist = list(heights.values())\n\n\n# Python 2 and 3: option 3\nfrom future.utils import listvalues\n\nvaluelist = listvalues(heights)\n\n\n# Python 2 and 3: option 4\nfrom future.utils import itervalues\n# or\nfrom six import itervalues\n\nvaluelist = list(itervalues(heights))\n\n\n字典元素作为一个列表：\n\n# Python 2 and 3: option 1\nitemlist = list(heights.items())    # inefficient on Py2\n\n\n# Python 2 and 3: option 2\nfrom future.utils import listitems\n\nitemlist = listitems(heights)\n\n\n# Python 2 and 3: option 3\nfrom future.utils import iteritems\n# or\nfrom six import iteritems\n\nitemlist = list(iteritems(heights))\n\n\n自定义类的行为\n\n自定义迭代器：\n\n# Python 2 only\nclass Upper(object):\n    def __init__(self, iterable):\n        self._iter = iter(iterable)\n    def next(self):          # Py2-style\n        return self._iter.next().upper()\n    def __iter__(self):\n        return self\n\nitr = Upper('hello')\nassert itr.next() == 'H'     # Py2-style\nassert list(itr) == list('ELLO')\n\n\n# Python 2 and 3: option 1\nfrom future.builtins import object\n\nclass Upper(object):\n    def __init__(self, iterable):\n        self._iter = iter(iterable)\n    def __next__(self):      # Py3-style iterator interface\n        return next(self._iter).upper()  # builtin next() function calls\n    def __iter__(self):\n        return self\n\nitr = Upper('hello')\nassert next(itr) == 'H'      # compatible style\nassert list(itr) == list('ELLO')\n\n\n# Python 2 and 3: option 2\nfrom future.utils import implements_iterator\n\n@implements_iterator\nclass Upper(object):\n    def __init__(self, iterable):\n        self._iter = iter(iterable)\n    def __next__(self):                  # Py3-style iterator interface\n        return next(self._iter).upper()  # builtin next() function calls\n    def __iter__(self):\n        return self\n\nitr = Upper('hello')\nassert next(itr) == 'H'\nassert list(itr) == list('ELLO')\n\n\n自定义 __str__ 方法\n\n# Python 2 only:\nclass MyClass(object):\n    def __unicode__(self):\n        return 'Unicode string: \\u5b54\\u5b50'\n    def __str__(self):\n        return unicode(self).encode('utf-8')\n\na = MyClass()\nprint(a)    # prints encoded string\n\n\n# Python 2 and 3:\nfrom future.utils import python_2_unicode_compatible\n\n@python_2_unicode_compatible\nclass MyClass(object):\n    def __str__(self):\n        return u'Unicode string: \\u5b54\\u5b50'\n\na = MyClass()\nprint(a)    # prints string encoded as utf-8 on Py2\n\n\nUnicode string: 孔子\n\n\n自定义 __nonzero__ 对比 __bool__ 方法：\n\n# Python 2 only:\nclass AllOrNothing(object):\n    def __init__(self, l):\n        self.l = l\n    def __nonzero__(self):\n        return all(self.l)\n\ncontainer = AllOrNothing([0, 100, 200])\nassert not bool(container)\n\n\n# Python 2 and 3:\nfrom future.builtins import object\n\nclass AllOrNothing(object):\n    def __init__(self, l):\n        self.l = l\n    def __bool__(self):\n        return all(self.l)\n\ncontainer = AllOrNothing([0, 100, 200])\nassert not bool(container)\n\n\n列表对迭代器\n\nxrange：\n\n# Python 2 only:\nfor i in xrange(10**8):\n    ...\n\n\n# Python 2 and 3: forward-compatible\nfrom future.builtins import range\nfor i in range(10**8):\n    ...\n\n\n# Python 2 and 3: backward-compatible\nfrom past.builtins import xrange\nfor i in xrange(10**8):\n    ...\n\n\nrange：\n\n# Python 2 only\nmylist = range(5)\nassert mylist == [0, 1, 2, 3, 4]\n\n\n# Python 2 and 3: forward-compatible: option 1\nmylist = list(range(5))            # copies memory on Py2\nassert mylist == [0, 1, 2, 3, 4]\n\n\n# Python 2 and 3: forward-compatible: option 2\nfrom future.builtins import range\n\nmylist = list(range(5))\nassert mylist == [0, 1, 2, 3, 4]\n\n\n# Python 2 and 3: option 3\nfrom future.utils import lrange\n\nmylist = lrange(5)\nassert mylist == [0, 1, 2, 3, 4]\n\n\n# Python 2 and 3: backward compatible\nfrom past.builtins import range\n\nmylist = range(5)\nassert mylist == [0, 1, 2, 3, 4]\n\n\nmap：\n\n# Python 2 only:\nmynewlist = map(f, myoldlist)\nassert mynewlist == [f(x) for x in myoldlist]\n\n\n# Python 2 and 3: option 1\n# Idiomatic Py3, but inefficient on Py2\nmynewlist = list(map(f, myoldlist))\nassert mynewlist == [f(x) for x in myoldlist]\n\n\n# Python 2 and 3: option 2\nfrom future.builtins import map\n\nmynewlist = list(map(f, myoldlist))\nassert mynewlist == [f(x) for x in myoldlist]\n\n\n# Python 2 and 3: option 3\ntry:\n    import itertools.imap as map\nexcept ImportError:\n    pass\n\nmynewlist = list(map(f, myoldlist))    # inefficient on Py2\nassert mynewlist == [f(x) for x in myoldlist]\n\n\n# Python 2 and 3: option 4\nfrom future.utils import lmap\n\nmynewlist = lmap(f, myoldlist)\nassert mynewlist == [f(x) for x in myoldlist]\n\n\n# Python 2 and 3: option 5\nfrom past.builtins import map\n\nmynewlist = map(f, myoldlist)\nassert mynewlist == [f(x) for x in myoldlist]\n\n\nimap：\n\n# Python 2 only:\nfrom itertools import imap\n\nmyiter = imap(func, myoldlist)\nassert isinstance(myiter, iter)\n\n\n# Python 3 only:\nmyiter = map(func, myoldlist)\nassert isinstance(myiter, iter)\n\n\n# Python 2 and 3: option 1\nfrom future.builtins import map\n\nmyiter = map(func, myoldlist)\nassert isinstance(myiter, iter)\n\n\n# Python 2 and 3: option 2\ntry:\n    import itertools.imap as map\nexcept ImportError:\n    pass\n\nmyiter = map(func, myoldlist)\nassert isinstance(myiter, iter)\n\n\nzip, izip\n\nAs above with zip and itertools.izip.\n\nfilter, ifilter\n\nAs above with filter and itertools.ifilter too\n\n其他内建函数\n\nFile IO with open()：\n\n# Python 2 only\nf = open('myfile.txt')\ndata = f.read()              # as a byte string\ntext = data.decode('utf-8')\n\n# Python 2 and 3: alternative 1\nfrom io import open\nf = open('myfile.txt', 'rb')\ndata = f.read()              # as bytes\ntext = data.decode('utf-8')  # unicode, not bytes\n\n# Python 2 and 3: alternative 2\nfrom io import open\nf = open('myfile.txt', encoding='utf-8')\ntext = f.read()    # unicode, not bytes\n\n\nreduce()\n\n# Python 2 only:\nassert reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) == 1+2+3+4+5\n\n\n# Python 2 and 3:\nfrom functools import reduce\n\nassert reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) == 1+2+3+4+5\n\n\nraw_input()\n\n# Python 2 only:\nname = raw_input('What is your name? ')\nassert isinstance(name, str)    # native str\n\n\n# Python 2 and 3:\nfrom future.builtins import input\n\nname = input('What is your name? ')\nassert isinstance(name, str)    # native str on Py2 and Py3\n\n\ninput()\n\n# Python 2 only:\ninput(\"Type something safe please: \")\n\n\n# Python 2 and 3\nfrom future.builtins import input\neval(input(\"Type something safe please: \"))\n\n\n警告：使用上面任何一个都是不安全的\n\nfile()\n\n# Python 2 only:\nf = file(pathname)\n\n\n# Python 2 and 3:\nf = open(pathname)\n\n# But preferably, use this:\nfrom io import open\nf = open(pathname, 'rb')   # if f.read() should return bytes\n# or\nf = open(pathname, 'rt')   # if f.read() should return unicode text\n\n\nexecfile()\n\n# Python 2 only:\nexecfile('myfile.py')\n\n\n# Python 2 and 3: alternative 1\nfrom past.builtins import execfile\n\nexecfile('myfile.py')\n\n\n# Python 2 and 3: alternative 2\nexec(compile(open('myfile.py').read()))\n\n# This can sometimes cause this:\n#     SyntaxError: function ... uses import * and bare exec ...\n# See https://github.com/PythonCharmers/python-future/issues/37\n\n\nunichr()\n\n# Python 2 only:\nassert unichr(8364) == '€'\n\n\n# Python 3 only:\nassert chr(8364) == '€'\n\n\n# Python 2 and 3:\nfrom future.builtins import chr\nassert chr(8364) == '€'\n\n\nintern()\n\n# Python 2 only:\nintern('mystring')\n\n\n# Python 3 only:\nfrom sys import intern\nintern('mystring')\n\n\n# Python 2 and 3: alternative 1\nfrom past.builtins import intern\nintern('mystring')\n\n\n# Python 2 and 3: alternative 2\ntry:\n    from sys import intern\nexcept ImportError:\n    pass\nintern('mystring')\n\n\napply()\n\nargs = ('a', 'b')\nkwargs = {'kwarg1': True}\n\n\n# Python 2 only:\napply(f, args, kwargs)\n\n\n# Python 2 and 3: alternative 1\nf(*args, **kwargs)\n\n\n# Python 2 and 3: alternative 2\nfrom past.builtins import apply\napply(f, args, kwargs)\n\n\nchr()\n\n# Python 2 only:\nassert chr(64) == b'@'\nassert chr(200) == b'\\xc8'\n\n\n# Python 3 only: option 1\nassert chr(64).encode('latin-1') == b'@'\nassert chr(0xc8).encode('latin-1') == b'\\xc8'\n\n\n# Python 2 and 3: option 1\nfrom future.builtins import chr\n\nassert chr(64).encode('latin-1') == b'@'\nassert chr(0xc8).encode('latin-1') == b'\\xc8'\n\n\n# Python 3 only: option 2\nassert bytes([64]) == b'@'\nassert bytes([0xc8]) == b'\\xc8'\n\n\n# Python 2 and 3: option 2\nfrom future.builtins import bytes\n\nassert bytes([64]) == b'@'\nassert bytes([0xc8]) == b'\\xc8'\n\n\ncmp()\n\n# Python 2 only:\nassert cmp('a', 'b') < 0 and cmp('b', 'a') > 0 and cmp('c', 'c') == 0\n\n\n# Python 2 and 3: alternative 1\nfrom past.builtins import cmp\nassert cmp('a', 'b') < 0 and cmp('b', 'a') > 0 and cmp('c', 'c') == 0\n\n\n# Python 2 and 3: alternative 2\ncmp = lambda(x, y): (x > y) - (x < y)\nassert cmp('a', 'b') < 0 and cmp('b', 'a') > 0 and cmp('c', 'c') == 0\n\n\nreload()\n\n# Python 2 only:\nreload(mymodule)\n\n\n# Python 2 and 3\nfrom imp import reload\nreload(mymodule)\n\n\n标准库\n\nStringIO 模块\n\n# Python 2 only\nfrom StringIO import StringIO\nfrom cStringIO import StringIO\n\n\n# Python 2 and 3\nfrom io import BytesIO\n# and refactor StringIO() calls to BytesIO() if passing byte-strings\n\n\nhttp 模块\n\n# Python 2 only:\nimport httplib\nimport Cookie\nimport cookielib\nimport BaseHTTPServer\nimport SimpleHTTPServer\nimport CGIHttpServer\n\n# Python 2 and 3:\nfrom future.standard_library import hooks\nwith hooks():\n    import http.client\n    import http.cookies\n    import http.cookiejar\n    import http.server\n\n\nurllib 模块\n\n这个使用 urllib 的示例，相同的模式也适用于其他的已经移除的模块（一个完整的列表 http://python-future.org/standard_library_imports.html#list-of-standard-library-modules ）\n\n# Python 2 only:\nfrom urlparse import urlparse\nfrom urllib import urlencode\n\n\n# Python 3 only:\nfrom urllib.parse import urlparse, urlencode\n\n\n# Python 2 and 3: alternative 1\nfrom future.standard_library import hooks\n\nwith hooks():\n    from urllib.parse import urlparse, urlencode\n\n\n# Python 2 and 3: alternative 2\nfrom future.moves.urllib.parse import urlparse, urlencode\n# or\nfrom six.moves.urllib.parse import urlparse, urlencode\n\n\n# Python 2 and 3: alternative 3\ntry:\n    from urllib.parse import urlparse, urlencode\nexcept ImportError:\n    from urlparse import urlparse\n    from urllib import urlencode\n\n\n                ", "mainLikeNum": ["5 "], "mainBookmarkNum": "31"}