{"title": "守护进程, 孤儿进程, 僵尸进程与waitpid - quietin的代码碎碎念 ", "index": "linux,python", "content": "守护进程是在一类脱离终端在后台执行的程序, 通常以d结尾, 随系统启动, 其父进程(ppid)通常是init进程\n一般要让当前程序以守护进程形式运行, 在命令后加&并重定向输出即可\n$ python someprogram.py > /dev/null 2>&1 &\n或者使用nohup也可以这是直接运行程序的方式, 如果是用具体语言代码的形式来实现呢, 首先看一下守护进程的实现方式\n\n创建子进程, 父进程退出父进程先于子进程退出会造成子进程成为孤儿进程，而每当系统发现一个孤儿进程时，就会自动由1号进程(init)收养它，这样，原先的子进程就会变成init进程的子进程\n\n在子进程中创建新会话\n\n更改工作目录到/, 以便umount一个文件系统\n重设文件权限掩码, 以便拥有完全的写的权限, 即重设继承来的默认文件权限值\n调用setuid, 让当前进程成为新的会话组长和进程组长\n\n\n执行第二次fork 关闭文件描述符, 一般是输入/输出和错误输出, 重定向到/dev/null\n\npy代码https://gist.github.com/jamiesun/3097215\n上面守护进程的生成步骤中涉及到了孤儿进程任何孤儿进程产生时都会立即为系统进程init自动接收为子进程，这一过程也被称为“收养”. 但由于创建该进程的进程已不存在，所以仍应称之为“孤儿进程”\n与之相关的一个概念就是 僵尸进程了. 当子进程退出时, 父进程需要wait/waitpid系统调用来读取子进程的exit status, 然后子进程被系统回收. 如果父进程没有wait的话, 子进程将变成一个\"僵尸进程\", 内核会释放这个子进程所有的资源，包括打开的文件占用的内存等, 但在进程表中仍然有一个PCB, 记录进程号和退出状态等信息, 并导致进程号一直被占用, 而系统能使用的进程号数量是有限的(可以用ulimit查看相关限制), 如果产生大量僵尸进程的话, 将因为没有可用的进程号而导致系统不能产生新的进程\n因此很多自带重启功能的服务实现就是用wait/waitpid实现的.waitpid()会暂时停止目前进程的执行，直到有信号来到或子进程结束比如tornado中fork多进程就是这样, 监控子进程的运行状态, 当其意外退出时自动重启子进程\ndef fork_processes(num_processes, max_restarts=100):\n    \"\"\"Starts multiple worker processes.\n\n    If ``num_processes`` is None or <= 0, we detect the number of cores\n    available on this machine and fork that number of child\n    processes. If ``num_processes`` is given and > 0, we fork that\n    specific number of sub-processes.\n\n    Since we use processes and not threads, there is no shared memory\n    between any server code.\n\n    Note that multiple processes are not compatible with the autoreload\n    module (or the ``autoreload=True`` option to `tornado.web.Application`\n    which defaults to True when ``debug=True``).\n    When using multiple processes, no IOLoops can be created or\n    referenced until after the call to ``fork_processes``.\n\n    In each child process, ``fork_processes`` returns its *task id*, a\n    number between 0 and ``num_processes``.  Processes that exit\n    abnormally (due to a signal or non-zero exit status) are restarted\n    with the same id (up to ``max_restarts`` times).  In the parent\n    process, ``fork_processes`` returns None if all child processes\n    have exited normally, but will otherwise only exit by throwing an\n    exception.\n    \"\"\"\n    global _task_id\n    assert _task_id is None\n    if num_processes is None or num_processes <= 0:\n        num_processes = cpu_count()\n    if ioloop.IOLoop.initialized():\n        raise RuntimeError(\"Cannot run in multiple processes: IOLoop instance \"\n                           \"has already been initialized. You cannot call \"\n                           \"IOLoop.instance() before calling start_processes()\")\n    gen_log.info(\"Starting %d processes\", num_processes)\n    children = {}\n\n    def start_child(i):\n        pid = os.fork()\n        if pid == 0:\n            # child process\n            _reseed_random()\n            global _task_id\n            _task_id = i\n            return i\n        else:\n            children[pid] = i\n            return None\n    for i in range(num_processes):\n        id = start_child(i)\n        if id is not None:\n            return id\n    num_restarts = 0\n    while children:\n        try:\n            pid, status = os.wait()\n        except OSError as e:\n            if errno_from_exception(e) == errno.EINTR:\n                continue\n            raise\n        if pid not in children:\n            continue\n        id = children.pop(pid)\n        if os.WIFSIGNALED(status):\n            gen_log.warning(\"child %d (pid %d) killed by signal %d, restarting\",\n                            id, pid, os.WTERMSIG(status))\n        elif os.WEXITSTATUS(status) != 0:\n            gen_log.warning(\"child %d (pid %d) exited with status %d, restarting\",\n                            id, pid, os.WEXITSTATUS(status))\n        else:\n            gen_log.info(\"child %d (pid %d) exited normally\", id, pid)\n            continue\n        num_restarts += 1\n        if num_restarts > max_restarts:\n            raise RuntimeError(\"Too many child restarts, giving up\")\n        new_id = start_child(id)\n        if new_id is not None:\n            return new_id\n    # All child processes exited cleanly, so exit the master process\n    # instead of just returning to right after the call to\n    # fork_processes (which will probably just start up another IOLoop\n    # unless the caller checks the return value).\n    sys.exit(0)\n参考: http://bbs.chinaunix.net/thread-4071026-1-1.html\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "5"}