{"title": "用Python+Flask实战一个实用的留言板Demo - 个人文章 ", "index": "flask,python", "content": "混杂着工作室图片网任务,截至今天终于完成了暑假另一个任务把考核任务按照狗书再写一遍受益匪浅，路途荆棘丛生。。。。这里主要记录了增加的功能，更多的可以看源代码代码在线预览\n上传头像404\n\nFlask上传文件我实现的主要思路就是,上传文件到服务器,然后读取文件当然你可以用二进制存进数据库,或者用比较成熟的拓展Flask-Uploads主要的步骤以前一篇文章写了 如何实现图片上传API\n\n然后你需要定义访问路由\n@main.route('/avatar/<filename>')\ndef get_file(filename):\n    return send_from_directory(current_app.config['UPLOAD_FOLDER'],filename) \n一开始的UPLOAD_FOLDER没有定义清楚,加上os.getcwd()获取当前目录\nUPLOAD_FOLDER= os.getcwd()+'/app/upload/avatar'\n如果用的Jinja2模板,在头像引用处这样写就可以了我这里把头像地址存到了user数据模型中\n<img class=\"img-rounded profile-thumbnail\" width=\"180\" height=\"180\" src=\"{{ url_for('main.get_file',filename=user.avatar) }}\">\n头像更换删除原来的图片\nif current_user.avatar:\n    try:\n        os.remove(os.path.join(current_app.config['UPLOAD_FOLDER'],current_user.avatar))\n    except OSError:\n        return {\"error\": u'文件不存在'}\n使用forgery_py生成测试数据\n开发测试的时候经常需要大量的数据,比如下面的用户模型shell运行,输入下面的代码即可\npython manage.py shell\n>>>User.generate_fake()\n@staticmethod\n    def generate_fake(count=100): #数量100\n        from sqlalchemy.exc import IntegrityError\n        from random import seed\n        import forgery_py  #生成虚拟数据所需要的库\n\n        seed()\n        for i in range(count):\n            u = User(username=forgery_py.internet.user_name(True),\n                    location=forgery_py.address.city(),\n                    about_me=forgery_py.lorem_ipsum.sentence(),\n                    password=forgery_py.lorem_ipsum.word())\n            db.session.add(u)\n            try:\n                db.session.commit()\n            except IntegrityError:\n                db.session.rollback()\n用profile协助程序性能优化\n前辈博客启动方式python manage.py profile\n@manager.command\ndef profile(length=25, profile_dir=None):\n    from werkzeug.contrib.profiler import ProfilerMiddleware\n    app.wsgi_app = ProfilerMiddleware(app.wsgi_app, restrictions=[length],\n                                      profile_dir=profile_dir)\n    app.run()    \n定义匿名用户\n定义\nfrom flask_login import AnonymousUserMixin\nclass AnonymousUser(AnonymousUserMixin):\n    def __init__(self):\n        self.username = '游客'\n\nlogin_manager.anonymous_user = AnonymousUser\n判断当前用户是否是匿名用户\ncurrent_user.is_anonymous() #bool型\nif的时候用current_user.is_anonymous\nJinja模板中\n{% if current_user.is_authenticated() %}\n  Hi {{ current_user.name }}!\n{% endif %}\nAttributeError: 'User' object has no attribute 'is_active'\nUser需要继承UserMixin,并添加一个user_loader\nfrom flask_login import UserMixin\n\nclass User(db.Model, UserMixin):\n    pass\n\n@login_manager.user_loader\ndef load_user(userid):\n    return User.query.get(int(userid))\n使用markdown同步实现markdown\n\n首先在create_app中初始化PageDownforms输入部分定义为PageDownField\nfrom flask_pagedown import PageDown\npagedown = PageDown()\ndef create_app(config_name):\n    app = Flask(__name__)\n    app.config.from_object(config[config_name])\n    pagedown.init_app(app)\n    ...\nJinja2中引入\n{% block scripts %}\n{{ super() }}\n{{ pagedown.include_pagedown() }}\n{% endblock %}\n模型中为了安全,防止恶意标签首先，markdown() 函数初步把Markdown 文本转换成HTML然后，把得到的结果和允许使用的HTML 标签列表传给clean() 函数clean() 函数删除所有不在白名单中的标签转换的最后一步由linkify() 函数完成，这个函数由Bleach 提供把纯文本中的URL 转换成适当的链接\nclass Post(db.Modle):\n    ....\n    #处理富文本，将Markdown格式转换为Html\n    @staticmethod\n    def on_changed_body(target, value, oldvalue, initiator):\n        allowed_tags = ['a', 'abbr', 'acronym', 'b', 'blockquote', 'code',\n                        'em', 'i', 'li', 'ol', 'pre', 'strong', 'ul',\n                        'h1', 'h2', 'h3', 'p']\n        target.body_html = bleach.linkify(bleach.clean(\n            markdown(value, output_format='html'),\n            tags=allowed_tags, strip=True))\n\ndb.event.listen(Post.body, 'set', Post.on_changed_body)#实时监听\n\n能记住的大概就这些了,其他的都是很杂的错误,不管怎么说,也是次经历了\n首发于我的博客用Python+Flask实战一个实用的留言板Demo参考链接：bestallen的博客\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "1"}