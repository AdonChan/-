{"title": "MongoEngine 查询（翻译） - 流水账 ", "index": "mongodb,python", "content": "数据库查询\nDocument 对象有一个 objects 属性，用来访问在数据库中跟这个类有关的对象。这个 objects 属性其实是一个QuerySetManager ，它会创建和返回一个新的 QuerySet 对象的访问。这个 QuerySet 对象可以从数据库中遍历获取的文档：\n# Prints out the names of all the users in the database\nfor user in User.objects:\n    print user.name\n过滤查询\n可以通过调用 QuerySet  对象的关键字参数来对数据查询进行过滤，关键字查询中的键和你想要查询的Document 中的字段一致：\n# This will return a QuerySet that will only iterate over users whose\n# 'country' field is set to 'uk'\nuk_users = User.objects(country='uk')\n对于内嵌document的字段可以使用 __ 来代替对象属性访问语法中的 . 进行访问：\n# This will return a QuerySet that will only iterate over pages that have\n# been written by a user whose 'country' field is set to 'uk'\nuk_pages = Page.objects(author__country='uk')\n查询操作符\n在查询中也可以使用操作符，只要将其加在关键字的双下划线之后即可：\n# Only find users whose age is 18 or less\nyoung_users = Users.objects(age__lte=18)\n可用的运算符如下：\n\nne – 不等于≠\nlt – 小于<\nlte – 小于等于≤\ngt – 大于>\ngte – 大于等于 ≥\nnot – 否定一个标准的检查，需要用在其他操作符之前(e.g. Q(age__not__mod=5))\nin – 值在 list 中\nnin – 值不在 list 中\nmod – value % x == y, 其中 x 和 y 为给定的值\nall – list 里面所有的值\nsize – 数组的大小\nexists – 存在这个值\n\n字符串查询\n以下操作符可以快捷的进行正则查询：\n\nexact – 字符串型字段完全匹配这个值\niexact – 字符串型字段完全匹配这个值（大小写敏感）\ncontains – 字符串字段包含这个值\nicontains – 字符串字段包含这个值（大小写敏感）\nstartswith – 字符串字段由这个值开头\nistartswith – 字符串字段由这个值开头（大小写敏感）\nendswith – 字符串字段由这个值结尾\niendswith – 字符串字段由这个值结尾（大小写敏感）\nmatch – 执行 $elemMatch 操作，所以你可以使用一个数组中的 document 实例\n\n地理查询\nPASS\n列表查询\n对于大多数字段，这种语法会查询出那些字段与给出的值相匹配的document，但是当一个字段引用 ListField 的时候，而只会提供一条数据，那么包含这条数据的就会被匹配上：\nclass Page(Document):\n    tags = ListField(StringField())\n\n# This will match all pages that have the word 'coding' as an item in the\n# 'tags' list\nPage.objects(tags='coding')\n原始查询\n你可以通过 __raw__ 参数来使用一个原始的 PyMongo 语句来进行查询，这样可以进行原始的完整查询：\nPage.objects(__raw__={'tags': 'coding'})\n限制和跳过结果\n就像传统的ORM一样，你有时候需要限制返回的结果的数量，或者需要跳过一定数量的结果。QuerySet 里面可以使用 limit() 和 skip() 这两个方法来实现，但是更推荐使用数组切割的语法：\n# Only the first 5 people\nusers = User.objects[:5]\n\n# All except for the first 5 people\nusers = User.objects[5:]\n\n# 5 users, starting from the 11th user found\nusers = User.objects[10:15]\n你可以指定让查询返回一个结果。如果这个条在数据库中不存在，那么会引发 IndexError 错误 。使用 first() 方法在数据不存在的时候会返回 None：\n>>> # Make sure there are no users\n>>> User.drop_collection()\n>>> User.objects[0]\nIndexError: list index out of range\n>>> User.objects.first() == None\nTrue\n>>> User(name='Test User').save()\n>>> User.objects[0] == User.objects.first()\nTrue\n默认Document 查询\n默认情况下，Document的objects 属性返回一个一个 QuerySet 对象，它并没有进行任何筛选和过滤，它返回的是所有的数据对象。这一点可以通过给一个 document 定义一个方法来修改 一个queryset 。这个方法需要两参数__doc_cls 和 queryset 。第一个参数是定义这个方法的 Document 类名（从这个意义上来说，这个方法像是一个 classmethod() 而不是一般的方法），第二个参数是初始化的 queryset。这个方法需要使用 queryset_manager()来装饰来它，使得它被认可。\nclass BlogPost(Document):\n    title = StringField()\n    date = DateTimeField()\n\n    @queryset_manager\n    def objects(doc_cls, queryset):\n        # This may actually also be done by defining a default ordering for\n        # the document, but this illustrates the use of manager methods\n        return queryset.order_by('-date')\n你不用调用 objects 方法，你可以自定义更多的管理方法，例如：\nclass BlogPost(Document):\n    title = StringField()\n    published = BooleanField()\n\n    @queryset_manager\n    def live_posts(doc_cls, queryset):\n        return queryset.filter(published=True)\n\nBlogPost(title='test1', published=False).save()\nBlogPost(title='test2', published=True).save()\nassert len(BlogPost.objects) == 2\nassert len(BlogPost.live_posts()) == 1\n自定义 QuerySets\n当你想自己定义一些方法来过滤 document 的时候，继承 QuerySet 类对你来说就是个好的方法。为了在 document 里面使用一个自定义的 QuerySet 类，你可以在 document 里的 meta 字典里设置 queryset_class 的值来实现它。\nclass AwesomerQuerySet(QuerySet):\n\n    def get_awesome(self):\n        return self.filter(awesome=True)\n\nclass Page(Document):\n    meta = {'queryset_class': AwesomerQuerySet}\n\n# To call:\nPage.objects.get_awesome()\nAggregation 聚合\nMongoDB 提供了开箱即用的聚合方法，但没有 RDBMS 提供的那样多。MongoEngine 提供了一个包装过的内置的方法，同时自身提供了一些方法，它实现了在数据库服务上执行的 Javascript 代码的功能。\n结果计数\n就像限制和跳过结果一样， QuerySet 对象提供了用来计数的方法 - count()，不过还有一个更 Pythonic 的方法来实现：\nnum_users = len(User.objects)\n更多功能\n当你想为 document 的特定的字段的数量计数的时候，可以使用 sum()：\nyearly_expense = Employee.objects.sum('salary')\n当你想求某个字段的平均值的时候，可以使用 average()：\nmean_age = User.objects.average('age')\nMongoEngine 提供了一个方法来获取一个在集合里 item 的频率 - item_frequencies()。下面一个例子可以生成 tag-clouds：\nclass Article(Document):\n    tag = ListField(StringField())\n\n# After adding some tagged articles...\ntag_freqs = Article.objects.item_frequencies('tag', normalize=True)\n\nfrom operator import itemgetter\ntop_tags = sorted(tag_freqs.items(), key=itemgetter(1), reverse=True)[:10]\n查询效率和性能\nPASS\n高级查询\n有时候使用关键字参数返回的 QuerySet 不能完全满足你的查询需要。例如有时候你需要将约束条件进行and，or 的操作。你可以使用 MongoEngine 提供的 Q 类来实现，一个 Q 类代表了一个查询的一部分，里面的参数设置与你查询document 的时候相同。建立一个复杂查询的时候，你需要用 & 或 |  操作符将 Q 对象连结起来。例如：\nfrom mongoengine.queryset.visitor import Q\n\n# Get published posts\nPost.objects(Q(published=True) | Q(publish_date__lte=datetime.now()))\n\n# Get top posts\nPost.objects((Q(featured=True) & Q(hits__gte=1000)) | Q(hits__gte=5000))\nAtomic updates（原子更新）\nMongoDB 文档 可以通过QuerySet 上的 update_one()、update()、modify() 方法自动更新。下面几种操作符可以被用到这几种方法上：\n\nset – 设置成一个指定的值\nunset – 删除一个指定的值\ninc – 将值加上一个给定的数\ndec – 将值减去一个给定的数\npush – 在 list 中添加一个值\npush_all – 在 list 中添加一个值\npop – 移除list 的第一项或最后一项（根据 pop__<field>=val  中val 的值决定删除第一项还是最后一项，一般情况下，val 为负则删除第一项，为正则删除最后一项，参见：mongodb $pop\npull – 从 list 里面移除一个值\npull_all –  从 list 里面移除个值\nadd_to_set – 当要添加的值不在 list 中时，添加这个值\n\n原子更新的语法类似于查询语法，区别在于修饰操作符位于字段之前，而不是之后：\n>>> post = BlogPost(title='Test', page_views=0, tags=['database'])\n>>> post.save()\n>>> BlogPost.objects(id=post.id).update_one(inc__page_views=1)\n>>> post.reload()  # the document has been changed, so we need to reload it\n>>> post.page_views\n1\n>>> BlogPost.objects(id=post.id).update_one(set__title='Example Post')\n>>> post.reload()\n>>> post.title\n'Example Post'\n>>> BlogPost.objects(id=post.id).update_one(push__tags='nosql')\n>>> post.reload()\n>>> post.tags\n['database', 'nosql']\n如果没有修饰操作符，则默认为$set：\nBlogPost.objects(id=post.id).update(title='Example Post')\nBlogPost.objects(id=post.id).update(set__title='Example Post')\n服务器端 JavaScript 执行\n可以写 Javascript函数，然后发送到服务器来执行。它返回结果是 Javascript 函数的返回值。这个功能是通过QuerySet()对象的exec_js() 方法实现。传递一个包含一个Javascript函数的字符串作为第一个参数。\n其余位置的参数的名字字段将作为您的Javascript函数的参数传递过去。\n在 JavaScript 函数范围中，一些变量可用：\n\ncollection – 对应使用的 Document 类的集合的名称\nquery – 一个 QuerySet 对象\noptions – 一个对象，它包含要传递给 exec_js() 函数的一些参数\n\ndef sum_field(document, field_name, include_negatives=True):\n    code = \"\"\"\n    function(sumField) {\n        var total = 0.0;\n        db[collection].find(query).forEach(function(doc) {\n            var val = doc[sumField];\n            if (val >= 0.0 || options.includeNegatives) {\n                total += val;\n            }\n        });\n        return total;\n    }\n    \"\"\"\n    options = {'includeNegatives': include_negatives}\n    return document.objects.exec_js(code, field_name, **options)\n\n                ", "mainLikeNum": ["7 "], "mainBookmarkNum": "4"}