{"title": "Python 性能分析工具简介 - Python提高班 ", "index": "python", "content": "性能分析和调优工具简介\n\n总会遇到一个时候你会想提高程序执行效率，想看看哪部分耗时长成为瓶颈，想知道程序运行时内存和CPU使用情况。这时候你会需要一些方法对程序进行性能分析和调优。\nBy Context Manager\n\n可以上下文管理器自己实现一个计时器, 参见之前的介绍 timeit 文章里做的那样，通过定义类的 __enter__ 和 __exit__ 方法来实现对管理的函数计时, 类似如:\n# timer.py\nimport time\n\nclass Timer(object):\n    def __init__(self, verbose=False):\n        self.verbose = verbose\n\n    def __enter__(self):\n        self.start = time.time()\n        return self\n\n    def __exit__(self, *args):\n        self.end = time.time()\n        self.secs = self.end - self.start\n        self.msecs = self.secs * 1000            # 毫秒\n        if self.verbose:\n            print 'elapsed time: %f ms' % self.msecs\n\n使用方式如下:\nfrom timer import Timer\n\nwith Timer() as t:\n    foo()\nprint \"=> foo() spends %s s\" % t.secs\n\nBy Decorator\n\n然而我认为装饰器的方式更加优雅\nimport time\nfrom functools import wraps\n\ndef timer(function):\n    @wraps(function)\n    def function_timer(*args, **kwargs):\n        t0 = time.time()\n        result = function(*args, **kwargs)\n        t1 = time.time()\n        print (\"Total time running %s: %s seconds\" %\n                (function.func_name, str(t1-t0))\n                )\n        return result\n    return function_timer\n\n使用就很简单了:\n@timer\ndef my_sum(n):\n    return sum([i for i in range(n)])\n\nif __name__ == \"__main__\":\n    my_sum(10000000)\n\n运行结果:\n➜  python profile.py\nTotal time running my_sum: 0.817697048187 seconds\n\n系统自带的time命令\n\n使用示例如下:\n➜ time python profile.py\nTotal time running my_sum: 0.854454040527 seconds\npython profile.py  0.79s user 0.18s system 98% cpu 0.977 total\n\n上面的结果说明: 执行脚本消耗0.79sCPU时间， 0.18秒执行内核函数消耗的时间，总共0.977s时间。其中， total时间 - (user时间 + system时间) = 消耗在输入输出和系统执行其它任务消耗的时间\npython timeit 模块\n\n可以用来做benchmark, 可以方便的重复一个程序执行的次数，来查看程序可以运行多块。具体参考之前写的文章。\ncProfile\n\n直接看带注释的使用示例吧。\n#coding=utf8\n\ndef sum_num(max_num):\n    total = 0\n    for i in range(max_num):\n        total += i\n    return total\n\n\ndef test():\n    total = 0\n    for i in range(40000):\n        total += i\n\n    t1 = sum_num(100000)\n    t2 = sum_num(200000)\n    t3 = sum_num(300000)\n    t4 = sum_num(400000)\n    t5 = sum_num(500000)\n    test2()\n\n    return total\n\ndef test2():\n    total = 0\n    for i in range(40000):\n        total += i\n\n    t6 = sum_num(600000)\n    t7 = sum_num(700000)\n\n    return total\n\n\nif __name__ == \"__main__\":\n    import cProfile\n\n    # # 直接把分析结果打印到控制台\n    # cProfile.run(\"test()\")\n    # # 把分析结果保存到文件中\n    # cProfile.run(\"test()\", filename=\"result.out\")\n    # 增加排序方式\n    cProfile.run(\"test()\", filename=\"result.out\", sort=\"cumulative\")\n\ncProfile将分析的结果保存到result.out文件中，但是以二进制形式存储的，想直接查看的话用提供的 pstats 来查看。\nimport pstats\n\n# 创建Stats对象\np = pstats.Stats(\"result.out\")\n\n# strip_dirs(): 去掉无关的路径信息\n# sort_stats(): 排序，支持的方式和上述的一致\n# print_stats(): 打印分析结果，可以指定打印前几行\n\n# 和直接运行cProfile.run(\"test()\")的结果是一样的\np.strip_dirs().sort_stats(-1).print_stats()\n\n# 按照函数名排序，只打印前3行函数的信息, 参数还可为小数,表示前百分之几的函数信息\np.strip_dirs().sort_stats(\"name\").print_stats(3)\n\n# 按照运行时间和函数名进行排序\np.strip_dirs().sort_stats(\"cumulative\", \"name\").print_stats(0.5)\n\n# 如果想知道有哪些函数调用了sum_num\np.print_callers(0.5, \"sum_num\")\n\n# 查看test()函数中调用了哪些函数\np.print_callees(\"test\")\n\n截取一个查看test()调用了哪些函数的输出示例:\n➜  python python profile.py\n   Random listing order was used\n   List reduced from 6 to 2 due to restriction <'test'>\n\nFunction              called...\n                          ncalls  tottime  cumtime\nprofile.py:24(test2)  ->       2    0.061    0.077  profile.py:3(sum_num)\n                               1    0.000    0.000  {range}\nprofile.py:10(test)   ->       5    0.073    0.094  profile.py:3(sum_num)\n                               1    0.002    0.079  profile.py:24(test2)\n                               1    0.001    0.001  {range}\n\nprofile.Profile\n\ncProfile还提供了可以自定义的类，可以更精细的分析, 具体看文档。格式如： class profile.Profile(timer=None, timeunit=0.0, subcalls=True, builtins=True)下面这个例子来自官方文档:\nimport cProfile, pstats, StringIO\npr = cProfile.Profile()\npr.enable()\n# ... do something ...\npr.disable()\ns = StringIO.StringIO()\nsortby = 'cumulative'\nps = pstats.Stats(pr, stream=s).sort_stats(sortby)\nps.print_stats()\nprint s.getvalue()\n\nlineprofiler\n\nlineprofiler是一个对函数进行逐行性能分析的工具，可以参见github项目说明，地址: https://github.com/rkern/line...\n示例\n\n#coding=utf8\n\ndef sum_num(max_num):\n    total = 0\n    for i in range(max_num):\n        total += i\n    return total\n\n\n@profile                     # 添加@profile 来标注分析哪个函数\ndef test():\n    total = 0\n    for i in range(40000):\n        total += i\n\n    t1 = sum_num(10000000)\n    t2 = sum_num(200000)\n    t3 = sum_num(300000)\n    t4 = sum_num(400000)\n    t5 = sum_num(500000)\n    test2()\n\n    return total\n\ndef test2():\n    total = 0\n    for i in range(40000):\n        total += i\n\n    t6 = sum_num(600000)\n    t7 = sum_num(700000)\n\n    return total\n\ntest()\n\n通过 kernprof 命令来注入分析，运行结果如下：\n➜ kernprof -l -v profile.py\nWrote profile results to profile.py.lprof\nTimer unit: 1e-06 s\n\nTotal time: 3.80125 s\nFile: profile.py\nFunction: test at line 10\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n    10                                           @profile\n    11                                           def test():\n    12         1            5      5.0      0.0      total = 0\n    13     40001        19511      0.5      0.5      for i in range(40000):\n    14     40000        19066      0.5      0.5          total += i\n    15\n    16         1      2974373 2974373.0     78.2      t1 = sum_num(10000000)\n    17         1        58702  58702.0      1.5      t2 = sum_num(200000)\n    18         1        81170  81170.0      2.1      t3 = sum_num(300000)\n    19         1       114901 114901.0      3.0      t4 = sum_num(400000)\n    20         1       155261 155261.0      4.1      t5 = sum_num(500000)\n    21         1       378257 378257.0     10.0      test2()\n    22\n    23         1            2      2.0      0.0      return total\n\nhits（执行次数） 和 time（耗时） 值高的地方是有比较大优化空间的地方。\nmemoryprofiler\n\n类似于\"lineprofiler\"对基于行分析程序内存使用情况的模块。github 地址：https://github.com/fabianp/me... 。ps:安装 psutil, 会分析的更快。\n同样是上面\"lineprofiler\"中的代码，运行 python -m memory_profiler profile.py 命令生成结果如下:\n➜ python -m memory_profiler profile.py\nFilename: profile.py\n\nLine #    Mem usage    Increment   Line Contents\n================================================\n    10   24.473 MiB    0.000 MiB   @profile\n    11                             def test():\n    12   24.473 MiB    0.000 MiB       total = 0\n    13   25.719 MiB    1.246 MiB       for i in range(40000):\n    14   25.719 MiB    0.000 MiB           total += i\n    15\n    16  335.594 MiB  309.875 MiB       t1 = sum_num(10000000)\n    17  337.121 MiB    1.527 MiB       t2 = sum_num(200000)\n    18  339.410 MiB    2.289 MiB       t3 = sum_num(300000)\n    19  342.465 MiB    3.055 MiB       t4 = sum_num(400000)\n    20  346.281 MiB    3.816 MiB       t5 = sum_num(500000)\n    21  356.203 MiB    9.922 MiB       test2()\n    22\n    23  356.203 MiB    0.000 MiB       return total\n\nTODO objgraph\n\n参考资料:\n\n\nhttps://docs.python.org/2/lib...\nhttp://xianglong.me/article/a...\nhttp://www.cnblogs.com/btchen...\nhttps://www.huyng.com/posts/p...\nhttp://www.marinamele.com/7-t...\n\nNEXT 代码的调优tips\n\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "13"}