{"title": "树莓派扩展板 sense HAT 的相关接口 - 个人文章 ", "index": "python,树莓派3", "content": "从官方给的 api 文档中硬翻的...\nLED 模型\nset_rotation 设置翻转角度\n这个函数可以设置 led 的旋转角度\n\n\n参数\n类型\n可选参数\n描述\n\n\n\nr\nInteger\n\n0,90,180,270\n\n\n0指的是树莓派 HDMI 接口向下的方向\n\n\nredraw\nBoolean\n\nTRUE,FALSE\n\n默认为 TRUE\n\n\n\n\n示例:\n#!/usr/bin/python\nimport sys\nimport time\nfrom sense_hat import SenseHat\n\nX = (255, 0, 0)\nO = (255, 255, 255)\n\nquestion_mark = [\n    O, O, O, X, X, O, O, O,\n    O, O, X, O, O, X, O, O,\n    O, O, O, O, O, X, O, O,\n    O, O, O, O, X, O, O, O,\n    O, O, O, X, O, O, O, O,\n    O, O, O, X, O, O, O, O,\n    O, O, O, O, O, O, O, O,\n    O, O, O, X, O, O, O, O\n]\n\nsense = SenseHat()\n\nsense.set_pixels(question_mark)\n\nsense.set_pixel(0, 0, 255, 0, 0)\nsense.set_pixel(0, 7, 0, 255, 0)\nsense.set_pixel(7, 0, 0, 0, 255)\nsense.set_pixel(7, 7, 255, 0, 255)\n\ndef close_light():\n    black = [ [0,0,0] ] * 64\n    sense.set_pixels(black)\n\ntry:\n    while True:\n        for r in [0, 90, 180, 270]:\n            sense.set_rotation(r)\n            time.sleep(0.3)\nexcept KeyboardInterrupt:\n    close_light()\n    print \"Good bye\"\nset_pixels 批量设置像素点\n改变64颗 led 的显示颜色\n\n\n参数\n类型\n可选参数\n描述\n\n\npixel_list\nList\n[[R, G, B] * 64]\n需要提供 list 长度为64的二维数组, (r,g,b)为三原色的色值\n\n\n示例参考上一个示例\nget_pixels 获取当前像素点数组\n\n\n返回类型\n描述\n\n\nList\n将当前的 led 屏上显示的图像转换成list\n\n\n示例:\n#!/usr/bin/python\nfrom sense_hat import SenseHat\n\n\nX = (255, 0, 0)\nO = (0, 0, 0)\nquestion_mark = [\n    O, X, O, O, O, O, X, O,\n    O, O, X, O, O, X, O, O,\n    O, X, X, X, X, X, X, O,\n    X, X, O, X, X, O, X, X,\n    X, X, X, X, X, X, X, X,\n    X, X, X, X, X, X, X, X,\n    O, X, O, O, O, O, X, O,\n    X, O, O, O, O, O, O, X\n]\n\nsense = SenseHat()\n\nsense.set_pixels(question_mark)\nout_list = sense.get_pixels()\nprint out_list\n\n提示:之所以有这个函数是因为传入set_pixels的像素值有时会发生变化,sense HAT 是将每个像素指定为  8 位数 (0-255) 但是如果传入 led 的 frameBuffer 中的时候,颜色的位数会转成 RGB565(5位红色,6位绿色和5位蓝色)  执行转换的时候可以看到二进制转换时发生的精度损失get_pixels 就是显示像素在缓冲区内结束时的值\nset_pixel 设置单点像素颜色\n通过 x-y 坐标系来定位像素位置,以 HDMI 接口面向的位置为下\n\n\n参数\n类型\n可选参数\n描述\n\n\n\nx\nInteger\n0-7\n0为左 7为右\n\n\ny\nInteger\n0-7\n0为上 7为下\n\n\n当只有三个参数的时候\n \n \n \n\n\npixel\nTuple / List\n0-255\n(r, g, b)    数值\n\n\n当有五个参数的时候\n \n \n \n\n\nr\nInteger\n0-255\n红\n\n\ng\nInteger\n0-255\n绿\n\n\nb\nInteger\n0-255\n蓝\n\n\n\n示例:\nfrom sense_hat import SenseHat\n\nsense = SenseHat()\n\n# examples using (x, y, r, g, b)\nsense.set_pixel(0, 0, 255, 0, 0)\nsense.set_pixel(0, 7, 0, 255, 0)\nsense.set_pixel(7, 0, 0, 0, 255)\nsense.set_pixel(7, 7, 255, 0, 255)\n\nred = (255, 0, 0)\ngreen = (0, 255, 0)\nblue = (0, 0, 255)\n\n# examples using (x, y, pixel)\nsense.set_pixel(0, 0, red)\nsense.set_pixel(0, 0, green)\nsense.set_pixel(0, 0, blue)\nget_pixel 获取指定位置的颜色\n同 get_pixels 不过是单体版的\n\n\n参数\n类型\n可选参数\n描述\n\n\n\nx\nInteger\n0-7\n0为左 7为右\n\n\ny\nInteger\n0-7\n0为上 7为下\n\n\n\n\n\n返回类型\n描述\n\n\nList\n[R,G,B] 组成的数组\n\n\n示例:\nfrom sense_hat import SenseHat\n\nsense = SenseHat()\ntop_left_pixel = sense.get_pixel(0, 0)\nload_image 加载图像到矩阵中\n加载一个图像文件，将其转换为RGB格式，并在LED矩阵上显示。图像的大小必须是8×8像素。\n\n\n参数\n类型\n可选参数\n描述\n\n\n\nfile_path\nString\n...\n有效的图片路径\n\n\nredraw\nBoolean\n\nTRUE/FALSE\n\n是否重绘已加载的图像文件在LED矩阵上。默认值为True\n\n\n\n示例:\nfrom sense_hat import SenseHat\n\nsense = SenseHat()\nsense.load_image(\"space_invader.png\")\n\n\n返回类型\n描述\n\n\nList\n[[R,G,B] * 64] 组成的数组\n\n\nfrom sense_hat import SenseHat\n\nsense = SenseHat()\ninvader_pixels = sense.load_image(\"space_invader.png\", redraw=False)\nclear 让 led 屏变成纯色,默认是关闭\n\n\n参数\n类型\n可选参数\n描述\n\n\n\n当只有一个参数的时候\n \n \n \n\n\npixel\nTuple / List\n0-255\n(r, g, b)    数值,默认为[0,0,0]\n\n\n\n当有三个参数的时候\n \n \n \n\n\nr\nInteger\n0-255\n红\n\n\ng\nInteger\n0-255\n绿\n\n\nb\nInteger\n0-255\n蓝\n\n\n\n示例:\nfrom sense_hat import SenseHat\nfrom time import sleep\n\nsense = SenseHat()\n\nred = (255, 0, 0)\n\nsense.clear()  # no arguments defaults to off\nsleep(1)\nsense.clear(red)  # passing in an RGB tuple\nsleep(1)\nsense.clear(255, 255, 255)  # passing in r, g and b values of a colour\nshow_message 屏幕显示单个文字\n就是街头广告灯的那种 led 滚屏啦!\n\n\n参数\n类型\n可选参数\n描述\n\n\n\ntext_string\nString\n...\n将要滚屏的字母\n\n\nscroll_speed\nFloat\n任意浮点数\n滚屏速度,默认 0.1\n\n\ntext_colour\nList\n[R,G,B]]\n文字颜色,默认[255,255,255]\n\n\nback_colour\nList\n[R,G,B]]\n背景颜色,默认[0,0,0]\n\n\n\n示例:\nfrom sense_hat import SenseHat\n\nsense = SenseHat()\nsense.show_message(\"One small step for Pi!\", text_colour=[255, 0, 0])\nshow_letter  单屏显示字母\n\n\n参数\n类型\n可选参数\n描述\n\n\n\ns\nString\n...\n将要显示的字母\n\n\ntext_colour\nList\n[R,G,B]]\n文字颜色,默认[255,255,255]\n\n\nback_colour\nList\n[R,G,B]]\n背景颜色,默认[0,0,0]\n\n\n\n示例:\n#!/usr/bin/python\nimport time\nfrom sense_hat import SenseHat\n\nsense = SenseHat()\n\nletters = \"ABCDEFGHIJKLMNOPQRSTUVWSYZ\"\n\n\nfor i in letters:\n    sense.show_letter(str(i))\n    time.sleep(1)\nlow_light  调低亮度\n如果觉得亮度有点刺眼的话可以开低亮度模式\nimport time\nfrom sense_hat import SenseHat\n\nsense = SenseHat()\nsense.clear(255, 255, 255)\nsense.low_light = True\ntime.sleep(2)\nsense.low_light = False\n#!/usr/bin/python\nimport time\nfrom sense_hat import SenseHat\n\nsense = SenseHat()\nsense.clear(255, 127, 0)\n\nsense.set_pixels(question_mark)\n\nprint(sense.gamma)\ntime.sleep(2)\n\nold = sense.gamma\nsense.gamma = old[::-1]\nprint(sense.gamma)\ntime.sleep(2)\n\n\nsense.low_light = True\nprint(sense.gamma)\ntime.sleep(2)\n\nsense.low_light = False\n\ngamma\nFor advanced users. Most users will just need the low_light Boolean property above. The Sense HAT python API uses 8 bit (0 to 255) colours for R, G, B. When these are written to the Linux frame buffer they're bit shifted into RGB 5 6 5. The driver then converts them to RGB 5 5 5 before it passes them over to the ATTiny88 AVR for writing to the LEDs.The gamma property allows you to specify a gamma lookup table for the final 5 bits of colour used. The lookup table is a list of 32 numbers that must be between 0 and 31. The value of the incoming 5 bit colour is used to index the lookup table and the value found at that position is then written to the LEDs.\n对于高级用户。大多数用户只需要上面的low_light布尔属性。这个感觉帽python API使用8位(0到255)的颜色为R,G,b。当这些被写入Linux框架缓冲区时，它们被位转换为RGB 5 6 5。然后，驱动程序将它们转换为RGB 5 5 5，然后将其传递给ATTiny88 AVR以写入led。gamma属性允许您为使用的最后5位颜色指定一个伽马查找表。查找表是32个数字的列表，它们必须在0到31之间。传入的5位颜色的值用于索引查找表，然后将该位置上发现的值写入led。---来自有道词典,因为暂时不知道用在哪里\n\n\n类型\n可选参数\n描述\n\n\nList\n长度为32的元组或列表，包含0到31之间的整数\n最后的5位颜色的查找表\n\n\n示例:\nimport time\nfrom sense_hat import SenseHat\n\nsense = SenseHat()\nsense.clear(255, 127, 0)\n\nprint(sense.gamma)\ntime.sleep(2)\n\nsense.gamma = sense.gamma[::-1]\nprint(sense.gamma)\ntime.sleep(2)\n\nsense.low_light = True\nprint(sense.gamma)\ntime.sleep(2)\n\nsense.low_light = False\ngamma_reset\n一个函数将gamma查找表重置为默认值，理想情况下，如果您已经对它进行了处理，并希望将它恢复到默认状态。示例:\nimport time\nfrom sense_hat import SenseHat\n\nsense = SenseHat()\nsense.clear(255, 127, 0)\ntime.sleep(2)\nsense.gamma = [0] * 32  # Will turn the LED matrix off\ntime.sleep(2)\nsense.gamma_reset()\n环境感应器\nget_humidity 湿度\n\n\n返回类型\n描述\n\n\nFloat\n湿度的百分数\n\n\n示例:\n#!/usr/bin/python\nfrom sense_hat import SenseHat\n\nsense = SenseHat()\nhumidity = sense.get_humidity()\nprint(\"Humidity: %s %%rH\" % humidity)  #Humidity: 13.8048038483 %rH\n\n# 同样效果\nprint(sense.humidity)   #14.9011135101\nget_temperature 温度\n返回值也是浮点数示例:\n#!/usr/bin/python\nfrom sense_hat import SenseHat\n\nsense = SenseHat()\ntemp = sense.get_temperature()\nprint(\"Temperature: %s C\" % temp)   # Temperature: 33.0 C\n\n# alternatives\nprint(sense.temp)       # 33.0\nprint(sense.temperature)    # 33.0\nget_temperature_from_humidity 温度\n从湿度传感器获取当前温度(摄氏度)。示例:\nfrom sense_hat import SenseHat\n\nsense = SenseHat()\ntemp = sense.get_temperature_from_humidity()\nprint(\"Temperature: %s C\" % temp)\nget_temperature_from_pressure 温度\n从压力传感器获取温度\nfrom sense_hat import SenseHat\n\nsense = SenseHat()\ntemp = sense.get_temperature_from_pressure()\nprint(\"Temperature: %s C\" % temp)\nget_pressure 压力\n获取压力参数\nps: 1Bar=0.1MPa=1000mba=1000hpa=100*7.5mmhg=75mmhg=1个大气压\n\n\n返回类型\n描述\n\n\nFloat\n单位为Millibars\n\n\n示例:\nfrom sense_hat import SenseHat\n\nsense = SenseHat()\npressure = sense.get_pressure()\nprint(\"Pressure: %s Millibars\" % pressure)  #Pressure: 1024.56738281 Millibars\n\n# 同理\nprint(sense.pressure)   # 1024.56738281\nIMU Sensor 惯性测量单元\nIMU(inertial measurement unit)传感器是三个传感器的组合，每个传感器分别有x、y和z轴。由于这个原因，它被认为是一个9自由度的传感器。\n\n陀螺仪(Gyroscope)\n加速度计(Accelerometer)\n指南针(Magnetometer)\n\n这个API允许你在任何组合中使用这些传感器来测量方向或单独的传感器。\nset_imu_config\n支持或禁用陀螺仪、加速度计和/或磁强计\n\n\n参数\n类型\n可选参数\n描述\n\n\n\ncompass_enabled\nBoolean\n\nTRUE,FALSE\n\n是否启用指南针\n\n\ngyro_enabled\nBoolean\n\nTRUE,FALSE\n\n是否启用陀螺仪\n\n\naccel_enabled\nBoolean\n\nTRUE,FALSE\n\n是否启用加速度计\n\n\n\n示例:\nfrom sense_hat import SenseHat\n\nsense = SenseHat()\nsense.set_imu_config(False, True, False)  # 只开启陀螺仪\nget_orientation_radians\n获取当前方向弧度,依据飞行器轴参数的  pitch, roll 和 yaw.理解传说中的roll、yaw、pitch欧拉角\n\n\n返回类型\n描述\n\n\nDictionary\n由俯仰角pitch,偏航角yaw,翻滚角roll组成的字典key 值,value 为轴弧度\n\n\n示例:\nfrom sense_hat import SenseHat\n\nsense = SenseHat()\norientation_rad = sense.get_orientation_radians()\nprint(\"p: {pitch}, r: {roll}, y: {yaw}\".format(**orientation_rad)) # p: 0.0906969159842, r: -0.218863099813, y: 2.87161874771\n\n# alternatives\nprint(sense.orientation_radians) # {'yaw': 2.933598041534424, 'roll': -0.20759552717208862, 'pitch': 0.09733205288648605}\n\nget_orientation_degrees\n以俯仰、翻滚和偏航的飞机主轴得到当前的方向。\n\n\n返回类型\n描述\n\n\nDictionary\n由俯仰角pitch,偏航角yaw,翻滚角roll组成的字典key 值,value 为轴角度\n\n\n示例:\nfrom sense_hat import SenseHat\n\nsense = SenseHat()\norientation = sense.get_orientation_degrees()\nprint(\"p: {pitch}, r: {roll}, y: {yaw}\".format(**orientation)) # p: 359.368855623, r: 359.958133745, y: 24.4292643968\n\nget_orientation\n作用同get_orientation_degrees\nfrom sense_hat import SenseHat\n\nsense = SenseHat()\norientation = sense.get_orientation()\n\nprint(sense.orientation) # {'yaw': 20.334569404489745, 'roll': 0.02406978340326997, 'pitch': 359.2895215347403}\nget_compass\n调用罗盘时会预先调用set_imu_config禁止掉重力计和加速度计的功能\nfrom sense_hat import SenseHat\n\nsense = SenseHat()\nnorth = sense.get_compass()\nprint(\"North: %s\" % north) # North: 351.031626941\n\n# alternatives\nprint(sense.compass) # 351.031626941\nget_compass_raw\n获取原始x、y和z轴的磁强计数据。\n\n\n返回类型\n描述\n\n\nDictionary\n字典对象索引的字符串x,y和z。表示磁场强度的值浮动轴的microteslas(µT)。\n\n\nfrom sense_hat import SenseHat\n\nsense = SenseHat()\nraw = sense.get_compass_raw()\nprint(\"x: {x}, y: {y}, z: {z}\".format(**raw)) # x: 3.14855718613, y: 0.269534498453, z: -0.743863344193\n\n# alternatives\nprint(sense.compass_raw) # {'y': 0.4851621091365814, 'x': 5.667402744293213, 'z': -1.338953971862793}\n\nget_gyroscope\n调用set_imu_config来禁用磁强计和加速计，然后只从陀螺仪获取当前方向。\n\n\n返回类型\n描述\n\n\nDictionary\n由俯仰角pitch,偏航角yaw,翻滚角roll组成的字典key 值,value 为轴角度\n\n\nfrom sense_hat import SenseHat\n\nsense = SenseHat()\ngyro_only = sense.get_gyroscope()\nprint(\"p: {pitch}, r: {roll}, y: {yaw}\".format(**gyro_only))\n\n# alternatives\nprint(sense.gyro) # {'yaw': 0.0604013305118731, 'roll': 359.9494321175156, 'pitch': 359.9567423509234}\nprint(sense.gyroscope) # {'yaw': 0.0604013305118731, 'roll': 359.9494321175156, 'pitch': 359.9567423509234}\nget_gyroscope_raw\n获取原始x、y和z轴的陀螺仪数据。\n\n\n返回类型\n描述\n\n\nDictionary\n一个由字符串x、y和z索引的字典对象。这些值是按每秒弧度表示轴的旋转强度的浮点数。\n\n\n\nfrom sense_hat import SenseHat\n\nsense = SenseHat()\nraw = sense.get_gyroscope_raw()\nprint(\"x: {x}, y: {y}, z: {z}\".format(**raw))\n\n# alternatives\nprint(sense.gyro_raw)\nprint(sense.gyroscope_raw)\n\n# x: 1.03765261173, y: 2.46352291107, z: 0.185390725732\n# {'y': 1.5728815793991089, 'x': 0.34309887886047363, 'z': 0.2984008193016052}\n# {'y': 0.8343454599380493, 'x': 0.163504496216774, 'z': 0.4767734408378601}\nget_accelerometer\n调用set_imu_config来禁用磁力仪和陀螺仪，然后从加速度计得到当前的方向。\n\n\n返回类型\n描述\n\n\nDictionary\n由俯仰角pitch,偏航角yaw,翻滚角roll组成的字典key 值,value 为轴角度\n\n\n\nfrom sense_hat import SenseHat\n\nsense = SenseHat()\naccel_only = sense.get_accelerometer()\nprint(\"p: {pitch}, r: {roll}, y: {yaw}\".format(**accel_only))\n\n# alternatives\nprint(sense.accel)\nprint(sense.accelerometer)\n\n# p: 3.76471788135, r: 10.0814548376, y: 0.0\n# {'yaw': 4.5454772552392335e-07, 'roll': 10.082596332952239, 'pitch': 3.7639588765826475}\n# {'yaw': 4.5454772552392335e-07, 'roll': 10.082596332952239, 'pitch': 3.7639588765826475}\n\nget_accelerometer_raw\n获取原始x、y和z轴加速度计数据。\n\n\n返回类型\n描述\n\n\nDictionary\n一个由字符串x、y和z索引的字典对象。这些值代表了在Gs中轴的加速度强度。\n\n\nfrom sense_hat import SenseHat\n\nsense = SenseHat()\nraw = sense.get_accelerometer_raw()\nprint(\"x: {x}, y: {y}, z: {z}\".format(**raw))\n\n# alternatives\nprint(sense.accel_raw)\nprint(sense.accelerometer_raw)\n\n# x: -0.0634367614985, y: 0.172625526786, z: 0.974787354469\n# {'y': 0.1738394945859909, 'x': -0.06516461074352264, 'z': 0.9757621884346008}\n# {'y': 0.17286831140518188, 'x': -0.06565827876329422, 'z': 0.9735689163208008}\nJoystick 操纵杆\n操纵事件\n描述操纵杆事件的元组。包含三个命名参数:\n\n时间戳—事件发生的时间，作为秒数(与内置时间函数相同的格式)\n方向-操纵杆移动的方向，作为一个字符串(“向上”，“向下”，“左”，“右”，“中间”)\n动作—发生的动作，作为一个字符串(“按压”，“释放”，“持有”)\n\n这个tuple类型被一些joystick方法使用，要么作为返回类型，要么是参数的类型。\nwait_for_event\n在发生joystick事件之前阻止执行，然后返回一个表示发生的事件的InputEvent。\nfrom sense_hat import SenseHat\nfrom time import sleep\n\nsense = SenseHat()\nevent = sense.stick.wait_for_event()\nprint(\"The joystick was {} {}\".format(event.action, event.direction))\nsleep(0.1)\nevent = sense.stick.wait_for_event()\nprint(\"The joystick was {} {}\".format(event.action, event.direction))\n在上面的例子中，如果你将操纵杆简单地推到一个单一的方向，你就会看到两个事件输出:一个被压的动作和一个释放的动作。可选的emptybuffer可以用于在等待新事件之前刷新任何未决事件。试试下面的脚本，看看有什么不同:\nfrom sense_hat import SenseHat\nfrom time import sleep\n\nsense = SenseHat()\nevent = sense.stick.wait_for_event()\nprint(\"The joystick was {} {}\".format(event.action, event.direction))\nsleep(0.1)\nevent = sense.stick.wait_for_event(emptybuffer=True)\nprint(\"The joystick was {} {}\".format(event.action, event.direction))\nget_events\n返回自最后一次调用get_events或wait_for_event之后发生的所有事件的InputEvent tuple的列表。\nfrom sense_hat import SenseHat\n\nsense = SenseHat()\nwhile True:\n    for event in sense.stick.get_events():\n        print(\"The joystick was {} {}\".format(event.action, event.direction))\ndirection_up, direction_left, direction_right, direction_down, direction_middle, direction_any\n这些属性可以被分配一个函数，当操纵杆按在相关的方向(或者在direction_any的任何方向上)时，它就会被调用。分配的函数要么不接受参数，要么必须接受一个参数，该参数将传递给相关的InputEvent。\nfrom sense_hat import SenseHat, ACTION_PRESSED, ACTION_HELD, ACTION_RELEASED\nfrom signal import pause\n\nx = 3\ny = 3\nsense = SenseHat()\n\ndef clamp(value, min_value=0, max_value=7):\n    return min(max_value, max(min_value, value))\n\ndef pushed_up(event):\n    global y\n    if event.action != ACTION_RELEASED:\n        y = clamp(y - 1)\n\ndef pushed_down(event):\n    global y\n    if event.action != ACTION_RELEASED:\n        y = clamp(y + 1)\n\ndef pushed_left(event):\n    global x\n    if event.action != ACTION_RELEASED:\n        x = clamp(x - 1)\n\ndef pushed_right(event):\n    global x\n    if event.action != ACTION_RELEASED:\n        x = clamp(x + 1)\n\ndef refresh():\n    sense.clear()\n    sense.set_pixel(x, y, 255, 255, 255)\n\nsense.stick.direction_up = pushed_up\nsense.stick.direction_down = pushed_down\nsense.stick.direction_left = pushed_left\nsense.stick.direction_right = pushed_right\nsense.stick.direction_any = refresh\nrefresh()\npause()\n相关资料\n博客原文api 原文树莓派+senseHAT 的一个入门项目来自官方的 astro-pi 简介\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}