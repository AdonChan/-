{"title": "代码测试用例指南 - 张伯函 ", "index": "test,python", "content": "原文链接：http://blog.speedx.com/backend-test-guide\n将测试代码和运行代码一起写是一种非常好的习惯。聪明地使用这种方法将会帮助你更加精确地定义代码的含义，并且代码的耦合性更低。\n测试的通用规则：\n\n测试单元应该集中于小部分的功能，并且证明它是对的。\n每个测试单元应该完全独立。\n通过Mock去除依赖\n尽量使测试单元快速运行。\n实现钩子来持续集成\n\n我们通过一个简单的python程序及unittest作为示例来为大家介绍如何进行测试，这里推荐大家使用python3来运行示例。\n我们先创建一个将会使用的测试目录\nmkdir /tmp/TestHookTest\ncd /tmp/TestHookTest\n测试单元应该集中于小部分的功能，并且证明它是对的\n下图为unittest包中包含的断言\n我们现在来写一个通过用户名获得github信息的一个函数，并对这个函数进行测试\n# test.py\nimport unittest\nimport json\n\nimport requests\n\ndef fetch_github_profile(username):\n    response = requests.get('https://api.github.com/users/' + username)\n    return response.json()\n\nclass SaveDataTest(unittest.TestCase):\n\n    def test_fetch_github_profile(self):\n        username = 'ZhangBohan'\n        data = fetch_github_profile('ZhangBohan')\n        self.assertEqual(data['login'], username)\n\n通过python3 -m unittest test运行\n每个测试单元应该完全独立\n\n\n每个都能够单独运行，除了调用的命令，都需在测试套件中。要想实现这个规则，测试单元应该加载最新的数据集，之后再做一些清理。\n如果有数据库依赖，在每次测试前创建测试数据库，结束后销毁该数据库，测试应该有单独的数据库，不要在生产和开发环境测试，避免数据变化引起的测试失败\n通过Mock去除依赖\n\n假设我们现在想把取得的用户数据保存到本地，并测试是否正确保存\n# test.py\nimport unittest\nimport json\n\nimport requests\n\ndef fetch_github_profile(username):\n    response = requests.get('https://api.github.com/users/' + username)\n    return response.json()\n\ndef save_data(data):\n    with open('data.json', 'w') as f:\n        f.write(json.dumps(data))\n\nclass SaveDataTest(unittest.TestCase):\n\n    def test_fetch_github_profile(self):\n        username = 'ZhangBohan'\n        data = fetch_github_profile('ZhangBohan')\n        self.assertEqual(data['login'], username)\n\n    def test_save_data(self):\n        data = fetch_github_profile('ZhangBohan')\n        save_data(data)\n\n        with open('data.json') as f:\n            file_data = json.loads(f.read())\n            self.assertIsNotNone(file_data)\n            self.assertEqual(data['id'], file_data['id'])\n\n在这个测试中我们的test_save_data中的data依赖fetch_github_profile中的返回数据，现实情况中会遇到更为复杂的依赖，为了一个测试用例，我们可能需要构建大量的初始化数据。我们可以通过mock来解除这个依赖，让test_save_data专注于测试保存数据部分\n# test.py\nimport unittest\nimport json\nfrom unittest.mock import MagicMock\n\nimport requests\n\ndef fetch_github_profile(username):\n    response = requests.get('https://api.github.com/users/' + username)\n    return response.json()\n\ndef save_data(data):\n    with open('data.json', 'w') as f:\n        f.write(json.dumps(data))\n\n\nFAKE_PROFILE_DATA = {\n  \"login\": \"ZhangBohan\",\n  \"id\": 2317407\n}\n\nclass SaveDataTest(unittest.TestCase):\n\n    def test_fetch_github_profile(self):\n        username = 'ZhangBohan'\n        data = fetch_github_profile('ZhangBohan')\n        self.assertEqual(data['login'], username)\n\n    def test_save_data(self):\n        fetch_github_profile = MagicMock(return_value=FAKE_PROFILE_DATA)\n        data = fetch_github_profile('ZhangBohan')\n        save_data(data)\n\n        with open('data.json') as f:\n            file_data = json.loads(f.read())\n            self.assertIsNotNone(file_data)\n            self.assertEqual(data['id'], file_data['id'])\n\n尽量使测试单元快速运行\n\n如果一个单独的测试单元需要较长的时间去运行，开发进度将会延迟，测试单元将不能如期常态性运行。有时候，因为测试单元需要复杂的数据结构，并且当它运行时每次都要加载，所以其运行时间较长。把运行吃力的测试单元放在单独的测试组件中，并且按照需要运行其它测试单元。\n实现hook来持续集成\n通过代码提交的本地hook或者webhook来持续集成测试你的代码。\n举个git本地hook的例子（这可假设你了解git hook的工作原理）。\n> git init\n> vim .git/hooks/pre-commit\n在.git/hooks/pre-commit文件中写入\n#!/bin/sh\n\ncd /tmp/TestHookTest && python3 -m unittest test\n执行：\n> chmod +x .git/hooks/pre-commit\n\n> git add test.py\n> git commit -m \"test hook\"\n.\n----------------------------------------------------------------------\nRan 1 test in 0.000s\n\nOK\n[master (root-commit) b390117] test hook\n 1 file changed, 9 insertions(+)\n create mode 100644 test.py\n在远程代码仓库部署的webhook能更好的测试全部代码。\nPython指南-测试你的代码\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "2"}