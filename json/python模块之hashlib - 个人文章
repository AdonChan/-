{"title": "python模块之hashlib - 个人文章 ", "index": "python,hash", "content": "hashlib模块实现了多种安全哈希和信息摘要算法的通用接口，包括FIPS中定义的SHA1, SHA224, SHA256, SHA384, SHA512以及RFC 1321中定义的MD5\n注意点：1. adler32及crc32哈希由zlib模块提供2. 某些算法已知存在哈希碰撞弱点\n哈希算法\n每个hash算法都有一个同名的构造函数，并返回拥有相同接口的hash对象\nsha1(), sha224(), sha256(), sha384(), sha512(), blake2b()以及blake2s()这些构造函数在hashlib模块中总是可用。md5()通常也可用，但在某些罕见的python版本(“FIPS compliant” build of Python)中例外。取决于所用平台上python使用的OpenSSL，hashlib也支持某些额外的算法，在大多数平台上，sha3_224(), sha3_256(), sha3_384(), sha3_512(), shake_128(), shake_256()都是可用的。\n>>> import hashlib\n>>> m = hashlib.sha256()\n>>> m.update(b\"Nobody inspects\")\n>>> m.update(b\" the spammish repetition\")\n>>> m.digest()\nb'\\x03\\x1e\\xdd}Ae\\x15\\x93\\xc5\\xfe\\\\\\x00o\\xa5u+7\\xfd\\xdf\\xf7\\xbcN\\x84:\\xa6\\xaf\\x0c\\x95\\x0fK\\x94\\x06'\n或者更精简的方式：\n>>> hashlib.sha256(b\"Nobody inspects the spammish repetition\").digest()\nb'\\x03\\x1e\\xdd}Ae\\x15\\x93\\xc5\\xfe\\\\\\x00o\\xa5u+7\\xfd\\xdf\\xf7\\xbcN\\x84:\\xa6\\xaf\\x0c\\x95\\x0fK\\x94\\x06'\nhashlib.new(name[, data])\n通用构造函数，name参数表示要使用的hash算法的名称，可以是上述列出的所有hash算法以及OpenSSL库支持的其他算法。使用算法名称构造函数较使用new()更快\n>>> h = hashlib.new(\"sha256\", b\"Nobody inspects the spammish repetition\")\n>>> h.digest()\nb'\\x03\\x1e\\xdd}Ae\\x15\\x93\\xc5\\xfe\\\\\\x00o\\xa5u+7\\xfd\\xdf\\xf7\\xbcN\\x84:\\xa6\\xaf\\x0c\\x95\\x0fK\\x94\\x06'\nhashlib.algorithms_guaranteed\n所有平台的hashlib模块都支持的hash算法的名称集合。md5也在此集合中(Note that ‘md5’ is in this list despite some upstream vendors offering an odd “FIPS compliant” Python build that excludes it.)。\nhashlib.algorithms_available\n当前运行的python解释器支持的hash算法的名称集合，在new()构造函数中使用都能被正确识别。同一算法可能以不同名称出现多次。hashlib.algorithms_guaranteed的结果集总是hashlib.algorithms_available结果集的子集\nhash.digest_size\nhash对象的字节长度\nhash.block_size\nhash对象的内部块大小\nhash.name\nhash对象的名称\nhash.update(data)\n传递类字节参数(通常是bytes)更新hash对象。重复调用update()等同于单次的拼接调用：m.update(a); m.update(b)等同m.update(a+b)\n从python3.1开始，为了更好的多线程性能，使用OpenSSL支持的hash算法且处理数据量大于2047个字节的update(或创建)操作发生时，将释放python全局解释器锁允许其他线程运行\nhash.digest()\n截止此方法调用时，update()已接收的数据的摘要，是一个可包含0到255之间所有字节的字节对象\nhash.hexdigest()\n类似于digest()，不过是以双倍长度的只包含十六进制数字的字符串对象返回摘要值。\nhash.copy()\n返回hash对象的克隆\nSHAKE算法的可变长度摘要\nThe shake_128() and shake_256() algorithms provide variable length digests with length_in_bits//2 up to 128 or 256 bits of security\nshake.digest(length)\n同hash.digest()\nshake.hexdigest(length)\n同hash.hexdigest()\n密钥导出\n密钥导出和扩展算法是为安全密码散列设计的。类似sha1(password)这种简单算法不能有效抵御暴力破解，一个好的密码散列函数必须是可调节的，耗时的，并包含盐\nhashlib.pbkdf2_hmac(hash_name, password, salt, iterations, dklen=None)\npbkdf2_hmac()提供了使用PKCS#5填充的pbkdf2算法，使用HMAC作为伪随机函数。\nhash_name表示HMAC的哈希摘要算法的名称，比如\"sha1\"或\"sha256\"。\npassword和salt是类字节对象，password长度应该限制在一个合理范围之间，salt长度应该在16个字节以上且来源恰当。\niterations表示迭代次数，基于hash算法以及机器计算能力设置。截止2013年，sha256算法建议最少进行10万次迭代\ndklen表示导出密钥的长度。默认值为None，使用hash_name算法计算的hash对象的digest_size属性长度\n>>> import hashlib, binascii\n>>> dk = hashlib.pbkdf2_hmac('sha256', b'password', b'salt', 100000)\n>>> binascii.hexlify(dk)\nb'0394a2ede332c9a13eb82e9b24631604c31df978b4e2f0fbd2c549944f9d79a5'\nNote: A fast implementation of pbkdf2_hmac is available with OpenSSL. The Python implementation uses an inline version of hmac. It is about three times slower and doesn’t release the GIL.\nhashlib.scrypt(password, *, salt, n, r, p, maxmem=0, dklen=64)\nThe function provides scrypt password-based key derivation function as defined in RFC 7914.\npassword和salt是类字节对象，password长度应该限制在一个合理范围之间，salt长度应该在16个字节以上且来源恰当。\nn is the CPU/Memory cost factor, r the block size, p parallelization factor and maxmem limits memory (OpenSSL 1.1.0 defaults to 32 MiB). dklen is the length of the derived key.\nBLAKE2\n待补充...实在是编不下去了，对加密算法相关的知识太缺乏了\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}