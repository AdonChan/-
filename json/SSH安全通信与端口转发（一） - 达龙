{"title": "SSH安全通信与端口转发（一） - 达龙 ", "index": "mysql,ubuntu,linux,python", "content": "博文参考\nhttps://segmentfault.com/a/1190000010312601\n概述\n所有业务的正常运转，离不开一个安全的运行环境，系统安全性直接关系到业务稳定、可靠、以及可用性，本章就介绍一些系统安全相关的话题。\n加密基础概念\n安全的目标：\n    保密性：confidentiality\n\n    完整性：integrity\n\n    可用性：availability\n\n攻击类型：\n    威胁保密性的攻击：窃听，通信量分析\n\n    威胁完整性的攻击：更改，伪装，重放，否认\n\n    威胁可用性的攻击：拒绝服务(DoS)\n\n为了完成安全的目标用到的解决方案\n    技术：加密和解密               \n\n            加密和解密：\n\n                传统加密方法：替代加密方法，置换加密方法\n\n                现代加密方法：现代块加密方法\n\n    服务：用于低于攻击的服务，也就是为了上述安全目标而特地设计的安全服务\n\n            服务：\n\n                认证机制\n\n                访问控制机制\n对称加密\n    对称加密：加密和解密使用同一个秘钥;但加密算法和解密算法可能不同\n\n    工作过程为：\n\n        发送者将发送的数据利用秘钥，使用加密的算法加密成明文，发送给对方;接收方收到加密的数据后，利用同一个秘钥，和解密的算法，将数据由密文解密成明文\n\n    常见的对称加密算法：\n\n            DES：Data Encryption Standard，56位秘钥\n\n            3DES：Triple DES\n\n            AES：Advanced Encryption Standard，支持128位、192位、256位、384位秘钥\n\n            Blowfish\n\n            Twofish\n\n            RC6\n\n            CAST5\n\n    对称加密特性：\n\n        <1>加密解密使用同一个秘钥\n\n        <2>将原始数据分隔成为固定大小块，逐个进行加密\n\n    对称加密的缺陷：\n\n        <1>秘钥过多\n\n        <2>秘钥分发困难\n\n        <3>数据来源无法确认\n\n公钥加密(非对称加密)：秘钥分为公钥和与之配对的私钥\n    公钥：公钥从私钥中提取产生，可以公开给所有人;pubkey\n\n    私钥：通过工具创建，私钥只能使用则自己留存，必须保证其私密性，secret key\n\n    特点：用公钥加密的数据，只能使用与之配对的私钥解密;反之，用私钥加密的数据只能用与之配对的公钥解密\n\n    用途：\n\n        数字签名：主要在于让接收方确认发送方的身份。将数据用单项加密(MD5、SHA)算法，得出来的特征码，用自己的私钥进行加密，这就是数字签名\n\n        秘钥交换：发送方用对方的公钥加密一个对称加密的秘钥，并发送给对方，以实现秘钥交换\n\n        数据加密：一般很少用公钥加密发送的数据本身，因为公钥加密的加密效率很低，因此一般用对称秘钥加密要发送的数据本身\n\n    公钥机密的工作模式：\n\n        模式一：公钥加密，私钥解密\n\n                B将数据发送给A，B就拿A的公钥对数据进行加密，然后将加密后的数据发送给A，那此时，加密后的数据只能被A的私钥进行解密，因此，即使有第三方拿到加密的数据，也无法完成解密，只有A自己有自己的私钥，因此实现了数据的保密性\n\n        模式二：私钥加密，公钥解密\n\n                A用自己的私钥加密一份数据给B，加密后的数据只能被A的公钥进行解密，因此，如果有第三方拿到加密后的数据，是能够解密的，因为A的公钥是公开的，任何人都可以拿到，因此可以解密\n\n                但此种方式的作用，并不是真正拿来加密数据，而是用来进行身份验证(数字签名)，也就是说，A用自己的私钥加密一段数据(数据不是要发送的数据本身，而是要加密数据利用单向加密算法得出来的特征码)，然后发送给B，B拿A的私钥进行解密，能够解密成功，就证明发送方一定是A，因为只有A的公钥能解开A的私钥;一旦解开数据后，得到的就是要发送数据的特征码，等后面真正发送数据后，可以利用该段特征码，来验证数据的完整性\n\n    公钥加密的常用的算法：\n\n        RSA：既能实现数字签名，也能实现加解密\n\n        DSA：有时也被称为DSS，数字签名标准。仅能实现数字签名，不能实现加解密\n\n单向加密：只能加密，不能解密。仅能提取数据的特征码\n    特性：\n\n        定长输出：无论原始数据多大，得出的特征码都是固定长度的\n\n        雪崩效应：原始数据的微小改变，将导致特征码的巨大变化\n\n    功能：主要用来实现验证数据的完整性\n\n    常见的单向加密算法：\n\n        MD5：Message Digest 5  消息摘要，5版本。128bit定长输出\n\n        SHA1：Secure Hash Algorithm 1，160位定长输出\n\n        SHA224、SHA256、SHA384、SHA512\n\n秘钥交换:IKE(Internet Key Exchange)\n    常见的交换算法：\n\n        公钥加密：用对方的公钥加密对称秘钥，这样对方就能以自己的私钥解开，从而获得对称加密的秘钥\n\n        DH(Deffie-Hellman)算法：\n\n                <1> A: a,p 协商生成公开的整数a, 大素数p\n                    B: a,p\n                <2> A:生成隐私数据 x， (x<p )，计算得出 a^x%p，发送给B\n                    B:生成隐私数据 y,计算得出 a^y%p，发送给A\n                <3> A:计算得出 （ a^y%p） ^x = a^xy%p， 生成为密钥\n                    B:计算得出 （ a^x%p） ^y = a^xy%p, 生成为密钥\n加密通信的双方的通信过程展示\n\n   A有一段数据要发送给B,A就用单向加密的算法计算出数据的特征码，而后A用自己的私钥加密这段特征码，生成数字签名，至此能够保证数据的完整性(通过比对特征码)，和身份验证(数字签名),但是不能保证数据的保密性，因为数据本身还没被加密。\n\n        因此，A会继续在原有数据和数字签名的基础上，生成一个一次性的对称加密秘钥，然后利用对称加密算法结合秘钥，去加密原有数据和数字签名。然后，A用B的公钥，对对称加密的秘钥进行加密，并附加到之前利用对称加密算法生成的数据的后面，然后发送给B\n\n        当B收到数据后，就用B自己的私钥解密附加在后面的对称加密的秘钥，从而得到了对称加密的秘钥(这就完成了秘钥交换，实际是双方都知道了对称加密的秘钥的过程就是秘钥交换)，然后利用对称加密的秘钥进一步解开数据和数字签名，然后利用A的公钥解开数字签名，得到数据本身的特征码，然后利用同样的单项加密算法，计算出收到的数据的特征码，然后比对特征码，从而验证数据的完整性\n中间人攻击：\n    以上通信过程中还是有一个严重的漏洞，就是当A和B键从来没进行过通信，那么A怎么获知B的公钥，或者B怎么获知A的公钥。假设当A没B的公钥时，向B发送请求，要求获知B的公钥，但是此时，如果有第三方C获取到请求后，冒充自己就是B，然后将C自己的公钥发送给A，A就认为C就是B。而C又会冒充自己是A，向B进行通信，从而也获取了真正B的公钥，而此后A和B通信的过程中，就都会交由C，数据的安全性就无从保障。这种情况就是中间人攻击\nCA和证书的基础概念\nPKI:Public Key Infranstructure公钥基础设施\n    由四个部分组成：\n\n        签证机构：CA机构\n\n        注册机构：RA，相当于CA的派出机构，用于接收注册申请\n\n        证书吊销列表：CRL\n\n        证书存取库：CB\n\nCA的作用\n    CA：保证通信双方，能够可靠的拿到对方的公钥(避免中间人攻击)，而设定的双方都信任的第三方可信机构\n\n        A将自己的公钥提请给CA，CA经过特殊的防伪处理后，将处理后的A的公钥发送给A，处理过后的A的公钥就称之为CA证书。以后，如果B如果请求要A的公钥，那么A就将CA证书发送给B,当B拿到证书后，不会立马就任何该证书，而是要验证该证书是否是合法的，还要验证是否是B信任的CA机构颁发的，验证完了之后，才会认可\n\n    CA证书一般会包含：提请证书的人的名称，提请人的公钥，证书有效期，然后CA机构会用自己的私钥，加密以上的一整段数据的特征码，然后将加密后的特征码(也就是数字签名)附加在数据之后，这个整体就是CA证书\n\n    CA证书后面有CA机构用CA机构自己的私钥对证书内容部分的特征码加密的数据，通信方要解开此数字签名就需要用到CA自身的公钥，但是如何获取到CA机构自己的公钥，如果直接申请，那么此时又会存在中间人攻击的可能，因此，一般是CA机构会给自己发一个CA证书，然后获取CA自身的证书，一般不能通过网络发送，因此一般情况下，是线下交易\n\nCA证书格式：\n    X.509，定义证书结构和认证协议的标准，在X.509的标准中，定义了证书需要具备的结构：\n\n        版本号：是X.509的v1还是v2还是v3版本\n\n        序列号：CA机构所发出的证书的序列号\n\n        签名算法ID：证书所使用的算法\n\n        发行者的名称：CA机构自己的名称\n\n        证书有效期限\n\n        主体名称：提请CA证书的用户的名称\n\n        主体公钥：\n\n        发行者的唯一标识：CA机构的ID\n\n        主体的唯一标识：提请者的ID\n\n        扩展信息\n\n        发行者的签名：CA机构利用自己的私钥对以上内容的特征码加密，生成的数字签名，将数字签名附加在证书内容之后，作为证书的一部分\n\nssl协议和openssl命令\nSSL协议：SSL和TLS\n    SSL：安全套接字层，由Netscape发布于1994年，分为V1.0、V2.0、V3.0但由于其版权属于Netscape公司，且各版本均被爆出有协议漏洞，因此使用的不多\n\n    TLS：Transport Layer Security，传输层安全，是国际互联网工程师协会发布的类似于SSL的协议，其分为V1.0、V1.1、V1.2、V1.3的版本，使用较多的是V1.2的版本\n\nTLS的分层设计：\n    <1>最底层：基础算法的原语的实现，如AES、RSA、MD5\n\n    <2>向上一层：各种算法的实现，也就是算法的具体实现的方式\n\n    <3>再向上一层：组合算法实现的半成品\n\n    <4>最高层：用各种组件拼装而成的各种成品密码学协议软件;\n\nSSL协议的开源实现：OpenSSL\n    OpenSSL由三部分组成：\n\n        libencrypt库：加密解密库，专用于实现加密解密功能，主要由开发人员使用\n\n        libssl库：用于实现ssl安全通信机制的库，主要由开发人员使用\n\n        openssl多用途命令行工具：openssl\n\nSSL会话的主要的三步：\n    客户端向服务器端所要并验证证书(证书里面有服务器端的公钥信息);\n\n    双方协商生成对称秘钥;\n\n    双方采用对称秘钥，进行加密通信的过程\n\n    会话过程后，进行断开\n\n在SSL会话之前开始之前的双方Handshake Protocol，SSL握手阶段的执行流程\n    也就是双方在正式开始SSL会话之前的通信前商量加密算法和生成会话秘钥阶段的详细过程介绍，(以HTTPS协议为例)       \n\n    <1>第一阶段：client-hello\n\n        客户端向服务器端发送：\n\n        支持的协议版本，如：tls1.2\n\n        客户端生成一个随机数，用于稍后生成对称秘钥\n\n        支持的加密算法，比如AES、RSA、SHA\n\n        支持的压缩算法\n\n    <2>第二阶段：server-hello\n\n        服务器端向客户端发送：\n\n        确认使用的加密通信的协议版本，如tls1.2\n\n        生成一个随机数，用于稍后生成对称秘钥\n\n        确认使用的加密算法\n\n        向客户端发送服务器证书\n\n        如果有必要，有可能会向客户端索要客户端的证书(如：当客户端请求的是网银页面时)\n\n    <3>第三阶段：客户端收到服务器端的server-hello后给出的回应\n\n        验证服务器证书，如果没问题，则通过解密证书获取到服务器的公钥;\n\n        验证的内容：\n\n                发证机构：验证发证机构是否是可信的，也就是验证证书签名(CA的数字签名)\n\n                证书的完整性，也是验证证书的数字签名里面的解密出来的特征码\n\n                证书的持有者：验证证书里面的持有者是否与要访问的页面是一致的\n\n                证书有效期\n\n                证书是否被吊销\n\n        发送以下信息给服务器端：\n\n                一个随机数，用于生成对称秘钥\n\n                编码变更通知：表示随后的信息都将用双方商定的加密方法和秘钥发送\n\n                客户端握手结束通知：表示客户端在正式通信前的握手阶段结束\n\n    <4>第四阶段：服务器端\n\n        收到客户端发来的最后一个随机数后，利用含此随机数在内的一共三个随机数生成对称秘钥;\n\n        向客户端发送以下信息:\n\n                编码变更通知：表示随后的信息都将用双方商定的加密方法和秘钥发送\n\n                服务器端握手结束通知：表示服务器端握手阶段已经结束\n\n基于SSL的通信的实现过程整理总结：\n    A、B双方要进行通信时：A为客户端，B为服务器端\n\n    <1>A发送hello信息给B，B接收后，发送hello信息给A，此时为双方建立通信前的确认，需要协商双方真正通信时所用到的加密算法，包括单向加密、对称加密、公钥加密、秘钥交换用的方法\n\n    <2>A请求B的证书，B于是将自己的证书(CA处理后的公钥)发送给A\n\n            一般情况下，客户端不会有证书提供给服务器端，因为一方面是证书的使用费使得客户端不会去用，另一方面客户端访问服务器端的时候，一般不会验证客户端的身份，比如访问某网站，网站不会要求客户端有证书才响应内容给客户端，而客户端是要验证服务器端的证书的，因为为了防止访问的网站的正确性，防止钓鱼网站等。\n\n            但有时服务器端也会验证客户端的证书，比如当客户端访问的是网银页面的时候，会验证证书，当我们去银行开通网银的时候，一般会有个加密狗之类的东西，其实里面存储的就是用户自己的ca证书，只是一般该ca证书的颁发机构不是市面上公认的CA机构，而是银行自己建的一个CA签发机构，仅对自己银行内部有效\n\n    <3>A收到B的证书后，验证B的证书，如果验证没有问题\n\n    <4>A验证B的证书没问题后，生成一个随机数，作为对称加密的秘钥，A利用双方之前协商的秘钥交换算法(假设为公钥加密)，则将此秘钥用B的公钥加密后发送给B\n\n    <5>B收到A发送过来的密文的秘钥后，利用自己的私钥，解密得出对称加密的秘钥，然后利用对称加密的秘钥和之前协商的对称加密的算法，给A发送A所请求的数据，进行正常数据的发送\n\n    <6>当正常的数据传输完成后，A(客户端)请求通信断开，服务器也断开，然后通信终止\nopenssl命令\n    openssl命令行工具有众多子命令，主要分为三类：\n\n        标准命令：enc、ca、req、genrsa…\n\n        消息摘要命令(dgst子命令相关)\n\n        加密命令(enc子命令相关)\n\n    <1>使用openssl命令行工具完成对称加密：\n\n        工具：openssl enc子命令\n\n        支持的算法：aes、des、3des等\n\n        enc命令的用法：\n\n            openssl enc -CIPHERNAME -e|d -in /PATH/TO/FILE -out /PATH/TO/FILE \n\n            选项解释：\n\n                -CIPHERNAME：加密的算法的名称，可通过openssl –help查看所支持的加密算法的名称\n\n                -e|d：-e表示加密，-d表示解密\n\n                -in /PATH/TO/FILE  要加密的文件\n\n                -out /PATH/TO/FILE  加密后的文件\n\n                -pass STRING  表示对称加密的秘钥是什么\n\n                -a|-base64   表示以base64文本格式进行编码，如果不指定，可能是以二进制格式进行编码\n\n            如对/testdir/file1进行对称加密：\n\n                openssl enc -des3 -e -a -salt -in /testdir/file1 -out /testdir/jmfile1  输入后回车，会要求输入对称加密的秘钥，输入完成，即可完成加密\n\n                        -des3表示采用des3的加密算法，-a表示以base64文本格式进行编码，-salt表示加点杂质\n\n            解密上面加密的文件：\n\n                openssl enc -des3 -d -a -salt -in /testdir/jmfile1 -out /testdir/file2  输入后回车，会要求输入对称加密的秘钥，输入完成，即可完成解密\n[root@localhost ~]# echo \"1 2 3 4 5\" > f1\n[root@localhost ~]# cat f1 #原始文件\n1 2 3 4 5\n[root@localhost ~]# openssl enc -des3 -e -a -salt -in f1 -out f1.m\nenter des-ede3-cbc encryption password: #使用3des对称加密算法，对原始文件进行加密，输入对称加密的秘钥\nVerifying - enter des-ede3-cbc encryption password:\n[root@localhost ~]# cat f1.m  #加密后文件内容\nU2FsdGVkX1+C+zxYYZ2mnH/Jhae8XNmly3SzFVeT738=\n\n[root@localhost ~]# openssl enc -des3 -d -a -salt -in f1.m -out f2\nenter des-ede3-cbc decryption password: #解密，要求输入加密时使用的对称加密秘钥\n[root@localhost ~]# cat f2 #解密文件\n1 2 3 4 5\n<2>单向加密\n        工具：openssl dgst、md5sum、sha1sum、sha256sum…\n\n        用法：\n\n            md5sum /PATH/TO/FILE\n\n            sha1sum /PATH/TO/FILE\n\n            openssl dgst -md5|-sha1… /PATH/TO/FILE\n[root@localhost ~]# md5sum f1\n9f96ef92fe742165873c313662f1f2b8  f1\n[root@localhost ~]# openssl dgst -md5 f1\nMD5(f1)= 9f96ef92fe742165873c313662f1f2b8\n[root@localhost ~]# sha1sum f1\n63b956989fab15e957086b98295ca0cdd69eb0b7  f1\n[root@localhost ~]# openssl dgst -sha1 f1\nSHA1(f1)= 63b956989fab15e957086b98295ca0cdd69eb0b7\n[root@localhost ~]# sha512sum f1\ncc7818f71e5669a72d45c9563a59e4db18ed899982eab1f884c4c4a58a7f0b63b5f4d750c1caa88e1cfff311a0cb7776f831b8af3beb3bf2cc7a73fe761f0c7e  f1\n[root@localhost ~]# openssl dgst -sha512 f1\nSHA512(f1)= cc7818f71e5669a72d45c9563a59e4db18ed899982eab1f884c4c4a58a7f0b63b5f4d750c1caa88e1cfff311a0cb7776f831b8af3beb3bf2cc7a73fe761f0c7e\n只要原始文件没有发生改变，使用同种加密算法计算出来的特征码一定一样\n<3>生成用户密码的命令：\n        工具：passwd、openssl passwd\n\n        例如：\n\n        openssl passwd -1 -salt 12345然后回车，会提示要求输入密码，输入完成后，即可生成加密后的密码\n\n            -1  表示使用md5方式加密\n\n            -salt STRING表示生成密码时加入的杂质的内容\n\n            -salt后面加的杂质的内容可以用随机数生成，生成随机数可以用openssl的子命令生成\n\n                    openssl passwd -1 -salt `openssl rand -hex 4` \n[root@localhost ~]# openssl passwd -1 -salt \"abcde\"\nPassword: \n$1$abcde$OmqJ.85QGvaLaaHqbRijw1\n#-1表示使用MD5的加密算法，加入的杂质为abcde，然后输入密码，就生成基于MD5加密后的加密字符串\n[root@localhost ~]# openssl passwd -1 -salt `openssl rand -hex 4`\nPassword: \n$1$d7dc4cfb$DA8Cq0zbnt0P2afb4X6zs1\n#使用openssl自带的生成随机字符串工具作为加密杂质\n<4>openssl生成随机数：\n        工具：openssl rand\n\n        用法：openssl rand [-out FILE] [-base64] [-hex] NUM\n\n            -out FILE  表示将生成的随机数保存在某个文件中\n\n            -base64  表示使用base64编码，生成的随机数后面可能会有=，要去掉=后才是真正的随机数\n\n            -hex  表示使用十六进制数字编码\n\n            NUM  表示生成随机字符串的长度\n\n        如：\n\n            openssl rand -base64 10\n\n            表示生成一个10个字节的随机数，采用base64编码格式进行输出\n\n            openssl rand -hex 10\n\n            输出10个字节的16进制字节长度的随机数，相当于输出20个字符\n\n        Linux上的随机数生成器：\n\n            /dev/random:仅从熵池中返回随机数，当随机数用尽，会阻塞后续请求随机数的应用\n\n            /dev/urandom:从熵池中返回随机数，随机数用尽，会利用软件生成伪随机数，不会阻塞。伪随机数不安全\n\n            熵池中随机数的来源：\n\n                硬盘I/O中断时间间隔\n\n                键盘I/O中断时间间隔\n[root@localhost ~]# openssl rand -hex 5\n76ebc802ee\n[root@localhost ~]# openssl rand -base64 5\nVmn4PbI=\n[root@localhost ~]# openssl rand -hex 10\n95faaee7d3ba04d588ae\n[root@localhost ~]# openssl rand -hex 10\nadd09e02712965f5b064\n<5>openssl实现公钥加密：\n        加密解密：\n\n                支持的算法：RSA、ELGamal\n\n                工具：openssl rsautl\n\n        数字签名:\n\n                支持的算法：RSA、DSA、ELGamal\n\n                工具：openssl rsautl\n\n        秘钥交换\n\n                支持的算法：DH、RSA\n\n        生成私钥：(公钥一般不需要生成，而是自动的会从私钥中提取产生)\n\n            openssl genrsa 512|768|1024|2048…表示生成一个长度为512、768…位的私钥\n\n            openssl genrsa 1024 > /PATH/TO/FILE  表示生成一个1024位的私钥保存到文件中\n\n            openssl genrsa 1024 -out /PATH/TO/FILE 也表示生成一个1024位的私钥保存到文件中\n\n        生成的私钥文件，不能让其他人访问，因此一般要将私钥文件的权限变成600，为了简化步骤，可以直接在生成私钥时就定义其权限，如：\n\n            (umask 077;openssl genrsa 1024 -out /PATH/TO/FILE)\n\n            用了小括号，相当于在一个子shell中运行，因此此时的子shell的umask设置仅对子shell生效\n\n        从私钥中提取公钥：一般不用手工提取\n\n            openssl rsa -in /PATH/TO/私钥文件  -pubout\n\n            表示从私钥文件中提取出公钥\n[root@localhost ~]# openssl genrsa 1024 #利用rsa算法生成1024位私钥\nGenerating RSA private key, 1024 bit long modulus\n......++++++\n.......++++++\ne is 65537 (0x10001)\n-----BEGIN RSA PRIVATE KEY-----\nMIICXQIBAAKBgQDJOWuZALVnZa+E2pdJV5IOkJUZQ6gomne6OS3Jh4FqYEv4tHRg\nMJ6szKLvX4ZNYdabGwqlrTLiWhC4rEKhlgD+RnEREObhCGhbjhffkcLgqg9UFg2h\nHu7pN9p/ecUr2YNQZO8+BdoXgvkSK8KwHudmin4M3NhfZxpH49dXje5xGQIDAQAB\nAoGBAJL23g/0RYlL6iJU6DOHwsPicxLtqA5nqtQW2Mscrbd8t1/gpDJwsCMynjnI\nAbXYpD3KRT91vPk2oInQPiX4AaZpJLAJTVnfv7kZv6f0RtGLdCJF/onsjLse9yuE\neWon+MkK6UMOU8fYCtWwfCQvTp5pTWgXPrTALpeRiPsTLv6BAkEA6nZQZIgXgVDf\nRzLN65MT5Awy/CVBj793HPXlvTgRt722Sn+efT2T9ZxHUcnLBRUWnUN7WrGbYf51\nV9g8k+Fk0QJBANu1eWKHTNtFoG9NlqcmkG/ffTtMcnneWZ3QdhjLg6Xgh+z+nhYf\n+zvWwhguG5D6opdyeQ1Zbk63b009ty43+ckCQQCN6SzBnIm1kLCEFKEEjBIG/sdB\nTH+BNR8wXTk/rRc0QlR6hQH1xfavO3cDbwM9wUTdzQF1pHhq+Kwnjk8kJtFxAkB4\n/HjoeesnwDK1t/si9oiJIn+6vME5POkKj3XI96D6IieXqSpyso/NhtiBKjrB3lLU\npRPl9v5YWIjw9vA9glOJAkBgWRDjR5aiCJxMh5mKplxPtoCdiAobyNgQi8Aux6eR\nwlHwOW7y20hgjcmytj29ZvabZhPKw7FM/QkAJ6+iPAeS\n-----END RSA PRIVATE KEY-----\n[root@localhost ~]# openssl genrsa 1024 > f1 #将私钥重定向到某个文件中\nGenerating RSA private key, 1024 bit long modulus\n.................................................................++++++\n......++++++\ne is 65537 (0x10001)\n[root@localhost ~]# cat f1\n-----BEGIN RSA PRIVATE KEY-----\nMIICXQIBAAKBgQDEAFnlfWWmLZs4kCA3nakGAJL5QBNVyzHBkL+MzzBOE7uDyzxU\n4WS58uCpQw8pZShZIdR5SaUlwneYfVw37rJgu2M67Q58IamuQvab37DPDJ2XfxW8\neTRH6/tjwqs71tE5/8O8zIUBWNaSIZvS0xkrEmG/DyXPibpF3QvuPZYinwIDAQAB\nAoGBAJMv7FJRM8dyUjFM0lTRmb9/KN/yhVKVL707dQ1J/e10Fgnn0luvk1Osl5ek\nWztr0rv0krmuW02a1vL1mQ4Lu3lkIz+m99D+YCKzZRjCOl1loQi70TMIOX+jRRsq\n08kGw8zxvPFjhCn90SO68/9x5+K8m2VD177aZ/ePEu6LNN/hAkEA+8h/YtsdeiK5\nRAYf1w3A1urTjV92izRrKwhIEdT+evzRICTg0RjX3MWP4BoDZFw/+Obyq/7jnMro\nWrXX/bxPcQJBAMdIsWfnVP0cCU+Q9yvMr7dg+Pct5uCfizVZQZcoEAn3gGnYUkqo\nF885jDlyJrTldPDtQv/qIvFY0vO+4wnNqw8CQQCIBz+DWhwn00DCloh3OE/6DO50\nj6HM/Wn02smNEMTYD2SweBwZ+9ELzpS3n3Y7r3dEcwmikNfJ6vnzoBDsXeORAkAX\nDiPoH21Hsxyopd7SpGWX05I6FodlaU/TpjXeZPYmEQo8NJigpn3KrZ+5balouDsl\nPG3J6a6NOXd+V5EwqyilAkAfYKS+6OWE3jRV5vu0YFzUt3c0dYqgT2rlCTWAFNjd\nMJX1YVZi7c3XrxcRhbakzgqW1du/1Z2ySebWKz+lkP4H\n-----END RSA PRIVATE KEY-----\n[root@localhost ~]# openssl genrsa -out f1 1024 #利用rsa算法生成1024位私钥，保存某文件中，注意公钥的长度，要写在保存文件之后。\nGenerating RSA private key, 1024 bit long modulus\n..........................++++++\n...................................................++++++\ne is 65537 (0x10001)\n[root@localhost ~]# cat f1\n-----BEGIN RSA PRIVATE KEY-----\nMIICXAIBAAKBgQC6amq8ptKmEhF4JIbN9+RVc8WOaLPMuIbZ+l7kDcKZq1K8W4QX\nUr07w0U6zDzGFcykqYhyCn8+eiF/OxqPOnqlibgoPwg9jwtuYJGZN5MvkNmQMniv\ndyY1ThkAF/hDowbmY4aputAzJ9glduWpGBwp0/xgFIPnP8fGk/nB9P6wfQIDAQAB\nAoGAPwNDyzs0z1AiOZNXQf4+X6g/qlC4HkZtxvb75mjEU/92excQQnYEY1QxbZum\nG2s4/pwT9ECaHHtaIVDQPIQO+pwuHyKnBLa8+AkYl04aUAYVDwaBbSBONEsFGVIa\nxpZH3c1lugBdweBLchhvJyzv9f1R5LUQe2ZDK0FuOaVNFwECQQDcnOmzbmr0g3GG\nZ/xrYVlQOTSSxkNf7Bw1MJZpkArLv4Dy/9DPHHEsIxsHOk/76m6J519qluaYTxqu\nfRgTdOU9AkEA2FFA3uUMSE1puHJLihZVCk/wQCKcssdFTtXNwPzwka71y0UW0EVi\nNN75FJrueGjXzmw0Lk8hdvDwt47RMzIsQQJAH36XLnJ4+mc5ccKumnXPVlCUXM/J\nFoySilVhY7iYkfXI5uf2W1roHTD1ztZYTNJu7WkGiiT4zo2cdYSOR1jM0QJBAL08\nN7fGQDxwHHBS7GpcpwBidhZlMRfk42jX+Ss/G2UW3cd5JUAFsqf194hjEQMdFM1s\nMynf57KZjLvHoJNc7QECQFVzZFAL6wUobFUI7WreU3qELC2MbN9uxgYAbzJXX0mx\nf2awbPIJ4brvilS5u/f61+enDITl6+VPJvXwSjTVJi0=\n-----END RSA PRIVATE KEY-----\n[root@localhost ~]# (umask 066;openssl genrsa -out ff 512)\nGenerating RSA private key, 512 bit long modulus\n.............++++++++++++ #rsa算法生成512私钥，保存文件中，权限600\n.........................................++++++++++++\ne is 65537 (0x10001)\n[root@localhost ~]# ll ff\n-rw-------. 1 root root 497 Jul 20 01:40 ff\n[root@localhost ~]# cat ff\n-----BEGIN RSA PRIVATE KEY-----\nMIIBPAIBAAJBAOF2ErTafwojYWAo99h73Pk6hKUe8frO+edoVAUpZYaIHvqLeJIY\nEEdnBkqkatiKMXihwQXtM6WIqDwtfLJjy3kCAwEAAQJBAJbHE7OG+7aX+qMIQtev\n3hN+ov6aN1F34YB0MNxS1uakGB16GD+qbUzKxXzWzcvruc1sfAfwAwr+uRXQ+CVy\nUVECIQD58RKUdjh04rOW0Ao6WmBRl0cl2JXEA83rYwYSjVGk4wIhAObtGGkoK7K3\nGwS1Gq0lxLixKfQlHf1jJnIOh2H6BRjzAiAhguwd0bgCG/8+QkiMyF9PsTvN3DtA\nW845OD6xMBd5RwIhANMDqKC+sl+Wbjv4+a1qq75RNZMBL8xRA9qJaDChdHL9AiEA\n0WSA38W0INfBHknOUf+nphr01ismlGSvaSTzfEMdXQQ=\n-----END RSA PRIVATE KEY-----\n[root@localhost ~]# openssl rsa -in ff -pubout\nwriting RSA key  #手动从文件中提取公钥\n-----BEGIN PUBLIC KEY-----\nMFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAOF2ErTafwojYWAo99h73Pk6hKUe8frO\n+edoVAUpZYaIHvqLeJIYEEdnBkqkatiKMXihwQXtM6WIqDwtfLJjy3kCAwEAAQ==\n-----END PUBLIC KEY-----\n[root@localhost ~]# openssl rsa -in ff -pubout -out ff\nwriting RSA key  #私钥中提取公钥，提取公钥保存指定文件中，私钥一样，提出的公钥也一样。\n[root@localhost ~]# cat ff\n-----BEGIN PUBLIC KEY-----\nMFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAOF2ErTafwojYWAo99h73Pk6hKUe8frO\n+edoVAUpZYaIHvqLeJIYEEdnBkqkatiKMXihwQXtM6WIqDwtfLJjy3kCAwEAAQ==\n-----END PUBLIC KEY-----\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}