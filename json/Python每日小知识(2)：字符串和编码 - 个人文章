{"title": "Python每日小知识(2)：字符串和编码 - 个人文章 ", "index": "python", "content": "了解：ASCII编码（是1个字节）仍然可以完美滴处理数字，因为最早的时候只有127个字符编入计算机，但是遇到处理中文1个字节就有点捉襟见肘了，这时候我们就脑壳疼了，所以中国制定了GB2312编码，用来把中文编进去；然后各国也开始制定自己国家的编码，日文有Shift_JIS,韩文有Euc_kr。多种语言的编码又让计算机苦不堪言了，于是各种乱码就在页面中上蹿下跳了。时势造英雄Unicode应运而生（通常是2个字节），把所有语言都统一到这编码中，足以应对乱码的负隅顽抗。然后对比了一下两者的区别：\n\n发现“竞”用Unicode编码十进制是31454,，二进制看上面，而字母“A”用Unicode编码存储还要在前面补八个0。这就让计算机大哥很不爽了，无端端自己胖了一圈（用Unicode编码比用ASCII编码需要多出一倍的存储空间）为了保持优雅的身姿就直接化身为UTF-8编码。\n这时候计算机就可以把一个Unicode字符根据不同数字大小编码成（1-6）个字节任君挑选了。（常用字母一般1个字节，汉字稍肥3个字节，只有那些歪瓜裂枣才4-6个字节）好了到这里就可以说是减肥成功了。（节省了空间）\n\n\n浅显的认识一下Python3中的“字符串”小弟\n（1）首先要知道这家伙是由Unicode编码滴，支持多语言，看图说话：\n\n（2）对于单个字符编码这种小意思的事情，Python提供ord()函数然字符摇身一变就成了整数了，chr()就硬生生把编码转换为对应字符啦。\n小试牛刀：\n\n（3）如果你不小心知道了字符的整数编码，还阔以用十六进制怎么操作str滴：\n\n（4）    由于Python字符串类型是str(废话)，以Unicode行走在内存中，一个字符对应（1-6）个字节，但如果你要做一些不可描述的事，比如在网络上传输或保存在你珍藏的磁盘上，就需要把str这厮变成以字节为单位的bytes。Unicode表示的str通过encode()方法可以编码为指定的bytes。\n有图有真相：\n\n没看错就是这么简单，但是要注意有中文的str这种异类是无法用帅气的ASCII编码的，因为中文编码的范围超过了ASCII编码所能承受帅气的范围，Python会报错。\n相反的如果我们偷偷的从网络或者磁盘读取了（咳咳）字节流，那么读到的数据就是bytes。想让它恢复本性，就得decode()方法出场了。\n\n很明显了如果bytes中包含无法解码的字节，decode()方法就会无情的报错了。如果它只是犯了一点点错（一部分无效字节）我们还是可以用（errors=’ignore’）拯救一下滴。\n\n\n脑残的想计算一下str包含多少个字符，可以用len()函数瞧瞧。\n\n不能厚此薄彼能计算str字符数，len()函数对bytes,就可以计算字节数：\n\n*格式化 经常我们都会不小心瞄到什么‘亲爱滴xxx您好！你上个月还欠我不少话费呢，总共xxx’这样的字符串，对于 xxx的内容我们是根据变量变化的，所以这就得格式化字符串的方式闪亮登场了。（用%实现）\n\n它可不止上面两兄弟，来给你看看比较常遇到的几胞胎，别搞错了\n\n下面的操作是比较666滴\n\n解释一下：03代表要补零，因为有三个数，所以就补两个零即可； .2f 表示：保留小数点后两位。\n格式化整数和浮点数并制定是否补0和整数与小数的位数。\n还有一种比较繁琐的方法Fomat()原理：用传入的参数依次替换字符串内的占位符\n\n注意：\n传入的参数要一一对应，还有要看清楚写法比如上图的：{0}、{1:.1f}%、{2}…昨天我家商铺盈利了6000元，今天盈利了8500元，计算一下盈利提升的百分点，用格式化字符串表示“xx.x%”,保留小数点后一位。\n\n是时候表演真正的技术了\n\n其中：s1为昨天盈利，s2为今天盈利；\n注意：\n“%”是普通字符时用“%%”进行转义\n。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}