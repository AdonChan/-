{"title": "Python装饰器-装饰流程,执行顺序 - 个人文章 ", "index": "python,ctf", "content": "最近看到一个关于Flask的CTF(RealWorld CTF 2018 web题bookhub)文章其中的一个trick是装饰器的顺序问题,就想写篇博客回顾下装饰器~\n首先强烈推荐很久之前看的一篇博文(翻译)理解PYTHON中的装饰器关于什么是装饰器看这篇文章就好了~ 这里主要想写关于多个装饰器的执行流程\n装饰顺序\n示例代码\n# import pdb;pdb.set_trace()\n\ndef functionOne(function_to_decorate):\n    print(\"functionOne初始化\")\n  \n    def wrapperOne():\npass\n    return wrapperOne\n\ndef functionTwo(function_to_decorate):\n    print(\"functionTwo初始化\")\n  \n    def wrapperTwo():\npass\n    return wrapperTwo\n\n@functionOne\n@functionTwo\ndef testFunction():\n    pass\n\n# 输出结果\nfunctionTwo初始化\nfunctionOne初始化\n从上面我们能得知：装饰顺序,就近装饰然后我们利用下面的代码进行一步探究如下我们得知：执行这段代码，相当于：首先，将testFunction函数打包给wrapperTwo,由于没有调用，functionTwo整体返回了wrapperTwo，而没有执行然后，functionOne将wrapperTwo作为参数，打包成wrapperOne\n\n# import pdb;pdb.set_trace()\n\ndef functionOne(function_to_decorate):\n    print(\"functionOne初始化\")\n  \n    def wrapperOne():\nprint(\"第一处\"+function_to_decorate.__name__)\nfunction_to_decorate()\n    return wrapperOne\n\ndef functionTwo(function_to_decorate):\n    print(\"functionTwo初始化\")\n  \n    def wrapperTwo():\nprint(\"第二处\"+function_to_decorate.__name__)\nfunction_to_decorate()\n    return wrapperTwo\n\n@functionOne\n@functionTwo\ndef testFunction():\n    print('index')\n\ntestFunction()\n\n#输出结果\nfunctionTwo初始化\nfunctionOne初始化\n第一处wrapperTwo\n第二处testFunction\nindex\n执行顺序\n从上面的第二段代码我们已经能看出部分执行顺序了就是它会优先执行我们打包好的wrapperOne,因为从起始的testFunction，wrapperTwo都已经打包在wrapperOne可以说成执行顺序，就远执行我们继续执行下面的代码：\n# import pdb;pdb.set_trace()\n\ndef functionOne(function_to_decorate):\n    print(\"functionOne初始化\")\n  \n    def wrapperOne():\nprint(\"第一处\"+function_to_decorate.__name__)\nfunction_to_decorate()\nprint(\"wrapperOne\")\n    return wrapperOne\n\ndef functionTwo(function_to_decorate):\n    print(\"functionTwo初始化\")\n  \n    def wrapperTwo():\nprint(\"第二处\"+function_to_decorate.__name__)\nfunction_to_decorate()\nprint(\"wrapperTwo\")\n    return wrapperTwo\n\n@functionOne\n@functionTwo\ndef testFunction():\n    print('index')\n\ntestFunction()\n\n# 输出结果\nfunctionTwo初始化\nfunctionOne初始化\n第一处wrapperTwo\n第二处testFunction\nindex\nwrapperTwo\nwrapperOne\n这个执行顺序可能也困扰了很多人，现在我们从输出结果看对照代码，就很容易清楚了，执行到wrapperOne中的function_to_decorate时其实相当于跳转到了函数wrapperTwo,然后执行wrapperTwo\n\nFlask @login_require\n从上面的几个例子我们应该大概了解了，多个装饰器进行装饰以及执行的顺序我们来看这道CTF题目，我们首先需要知道的是Flask中路由就是一个装饰\nfrom flask import Flask\n\napp = Flask(__name__)\napp.debug = True\n\n# import pdb;pdb.set_trace()\n\n# 为了更好的控制输出，自定义了loginRequire装饰器\ndef loginRequire(function_to_decorate):\n    print(\"loginRequire初始化\")\n  \n    def wrapperTwo():\nprint(\"loginRequire装饰成功\")\nprint(function_to_decorate.__name__)\nreturn function_to_decorate()\n    return wrapperTwo\n\n@loginRequire\n@app.route('/up')\ndef up():\n    return \"装饰路由放在上面！\"\n\n@app.route('/down')\n@loginRequire\ndef down():\n    return \"装饰路由放在下面！\"\n\nif __name__ == '__main__':\n    app.run()\n\n# 分别访问两个url输出结果\nloginRequire初始化\nloginRequire初始化\n * Debugger is active!\n * Debugger PIN: 244-957-971\n * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)\n127.0.0.1 - - [24/Aug/2018 19:01:30] \"GET /up HTTP/1.1\" 200 -\nloginRequire装饰成功\ndown\n127.0.0.1 - - [24/Aug/2018 19:01:35] \"GET /down HTTP/1.1\" 200 -\n从输出结果我们能清楚的看到up的装饰，并没有执行装饰器如果按照我们上面的分析，无论在上面还是下面都会执行的啊？？只是顺序不同罢了~我们利用pdb来一步步调试查看哪里的问题,部分log如下：\n> c:\\users\\bayi\\desktop\\test\\256.py(17)<module>()\n-> @loginRequire\n(Pdb) s\n> c:\\users\\bayi\\desktop\\test\\256.py(18)<module>()\n-> @app.route('/up')\n(Pdb) s\n> c:\\users\\bayi\\.virtualenvs\\test-gq7eoxbq\\lib\\site-packages\\flask\\app.py(1252)route()-><function Fla...at 0x0376F978>\n-> return decorator\n(Pdb) s\n--Call--\n> c:\\users\\bayi\\.virtualenvs\\test-gq7eoxbq\\lib\\site-packages\\flask\\app.py(1248)decorator()\n-> def decorator(f):\n(Pdb) f\n<function up at 0x0376F9C0>\n(Pdb) s\n> c:\\users\\bayi\\.virtualenvs\\test-gq7eoxbq\\lib\\site-packages\\flask\\app.py(1249)decorator()\n-> endpoint = options.pop('endpoint', None)\n(Pdb) s\n> c:\\users\\bayi\\.virtualenvs\\test-gq7eoxbq\\lib\\site-packages\\flask\\app.py(1250)decorator()\n-> self.add_url_rule(rule, endpoint, f, **options)\n(Pdb) f\n<function up at 0x0376F9C0>\n#===================================================================================#\n        上方up 下方down\n#===================================================================================#\n> c:\\users\\bayi\\desktop\\test\\256.py(22)<module>()\n-> @app.route('/down')\n(Pdb) s\n> c:\\users\\bayi\\desktop\\test\\256.py(23)<module>()\n-> @loginRequire\n(Pdb) s\n--Call--\n> c:\\users\\bayi\\desktop\\test\\256.py(6)loginRequire()\n-> def loginRequire(function_to_decorate):\n(Pdb) s\n> c:\\users\\bayi\\desktop\\test\\256.py(7)loginRequire()\n-> print(\"loginRequire初始化\")\n(Pdb) s\nloginRequire初始化\n> c:\\users\\bayi\\desktop\\test\\256.py(9)loginRequire()\n-> def wrapperTwo():\n(Pdb) s\n> c:\\users\\bayi\\desktop\\test\\256.py(13)loginRequire()\n-> return wrapperTwo\n(Pdb) s\n--Return--\n> c:\\users\\bayi\\desktop\\test\\256.py(13)loginRequire()-><function log...at 0x0071C468>\n-> return wrapperTwo\n(Pdb) s\n--Call--\n> c:\\users\\bayi\\.virtualenvs\\test-gq7eoxbq\\lib\\site-packages\\flask\\app.py(1248)decorator()\n-> def decorator(f):\n(Pdb) f\n<function loginRequire.<locals>.wrapperTwo at 0x0071C468>\n从上面的执行流程，打印出不断出现的f,我们能看出，两个顺序的f值不同在up中，f=up()在down中，f=wrapperTwo()这点符合预期，装饰位置不同，然而在执行Flask源码 add_url_rule时如上面log所示，直接添加了f的值\n> c:\\users\\bayi\\.virtualenvs\\test-gq7eoxbq\\lib\\site-packages\\flask\\app.py(1249)decorator()\n-> endpoint = options.pop('endpoint', None)\n(Pdb) s\n> c:\\users\\bayi\\.virtualenvs\\test-gq7eoxbq\\lib\\site-packages\\flask\\app.py(1250)decorator()\n-> self.add_url_rule(rule, endpoint, f, **options)\n(Pdb) f\n<function up at 0x0376F9C0>\n也就是添加路由的时候会选择丢失外层的路由，只装饰route下方的函数在add_url_rule中，有这段注释：\nBasically this example::\n\n    @app.route('/')\n    def index():\n        pass\n\nIs equivalent to the following::\n\n    def index():\n        pass\n    app.add_url_rule('/', 'index', index)\n博客地址\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}