{"title": "opencv python Hough圆变换 - 个人文章 ", "index": "opencv-python,opencv,python", "content": "Hough Circle Transform \ncv2.HoughCircles(image, method, dp, minDist[, circles[, param1[, param2[, minRadius[, maxRadius]]]]])\n\nimage:单通道灰度图像\n\nmethod:\n\n\ncv2.HOUGH_STANDARD\n经典或标准霍夫变换. 每条线由两个浮点数（ρ，θ）表示，其中ρ是（0,0）点和线之间的距离，θ是x轴和线的法线之间的角度. 因此，矩阵必须是（创建的序列）CV_32FC2类型\n\n\ncv2.HOUGH_PROBABILISTIC\n概率Hough变换（如果图像包含一些长线性段，则更有效）.它返回线段而不是整行. 每个段由起点和终点表示，矩阵必须是（创建的序列）CV_32SC4类型\n\n\ncv2.HOUGH_MULTI_SCALE\n经典霍夫变换的多尺度变体\n\n\ncv2.HOUGH_GRADIENT\n \n\n\n\ndp：累加器分辨率与图像分辨率的逆比.例如，如果dp=1，则累加器与输入图像的分辨率相同.如果dp=2，这个累加器的宽度和高度是图像的一半.\nminDist：探测到的圆的中心之间的最小距离.如果参数太小，除了真实的一个外，还可能错误地检测到多个相邻圆.如果它太大，可能会漏掉一些圆.\nparam1：第一个特定参数.如果是CV_HOUGH_GRADIENT的情况下，是传递给Canny边缘检测器中较高阈值的参数（低的参数小两倍）.\nparam2：第二个特定参数.如果是CV_HOUGH_GRADIENT的情况下，它是检测阶段圆中心的累加器阈值。它越小，就会发现越多的假圆.与较大的累加器值相对应的圆，将首先返回.\nminRadius：最小半径\nmaxRadius：最大半径\n\nimport cv2\nimport numpy as np\nfrom matplotlib import pyplot as plt\n\nimg = cv2.imread('img1.jpg',0)\nimg = cv2.medianBlur(img,5)\ncimg = cv2.cvtColor(img,cv2.COLOR_GRAY2BGR)\n\ncircles = cv2.HoughCircles(img,cv2.HOUGH_GRADIENT,1,20,\n                            param1=50,param2=30,minRadius=0,maxRadius=0)\n\ncircles = np.uint16(np.around(circles))\nfor i in circles[0,:]:\n    # draw the outer circle\n    cv2.circle(cimg,(i[0],i[1]),i[2],(0,255,0),2)\n    # draw the center of the circle\n    cv2.circle(cimg,(i[0],i[1]),2,(0,0,255),3)\n\ncv2.imshow('detected circles',cimg)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}