{"title": "sklearn 文本分类记录 [1] 官方文档 - 个人文章 ", "index": "python", "content": "工作上需要用到文本分类，这里用 sklearn 做为工具，记录下学习过程\n目录\n1. SVM 文本分类范例2. sklearn 做文本分类其他可选分类器3. 文本分类的数据预处理3. 中文文本分类方法\n\nSVM 文本分类范例\nimport numpy as np\nfrom sklearn import metrics\nfrom sklearn.datasets import fetch_20newsgroups\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.linear_model import SGDClassifier\nfrom sklearn.svm import LinearSVC\nfrom sklearn.utils.extmath import density\n\ncategories = [\n    'alt.atheism',\n    'talk.religion.misc',\n    'comp.graphics',\n    'sci.space',\n]\n\nprint(\"Loading 20 newsgroups dataset for categories:\")\nprint(categories if categories else \"all\")\n\ndataHome = '/Users/xinsheng/PycharmProjects/PythonPlaygroud/dataset'\n\ndata_train = fetch_20newsgroups(data_home= dataHome, subset='train', categories=categories,\n                                shuffle=True, random_state=42)\n\ndata_test = fetch_20newsgroups(data_home=dataHome, subset='test', categories=categories,\n                               shuffle=True, random_state=42)\n\nprint('data loaded')\n\ny_train, y_test = data_train.target, data_test.target\n\ntarget_names = data_train.target_names\n\nvectorizer = TfidfVectorizer(sublinear_tf=True, max_df=0.5, stop_words='english')\nX_train = vectorizer.fit_transform(data_train.data)\n\nX_test = vectorizer.transform(data_test.data)\nfeature_names = vectorizer.get_feature_names()\n\n# 在 as array 之前是什么呢\nfeature_names = np.asarray(feature_names)\n\nresults = []\n\ndef benchmark(clf):\n    clf.fit(X_train, y_train)\n    pred = clf.predict(X_test)\n\n    if hasattr(clf, 'coef_'):\n        print(\"dimensionality: %d\" % clf.coef_.shape[1])\n        print(\"density: %f\" % density(clf.coef_))\n\n        # if opts.print_top10 and feature_names is not None:\n        print(\"top 10 keywords per class:\")\n        for i, label in enumerate(target_names):\n            top10 = np.argsort(clf.coef_[i])[-10:]\n            print(\"%s: [%s]\" % (label, \" \".join(feature_names[top10])))\n        print()\n\n    print(metrics.classification_report(y_test, pred, target_names=target_names))\n\n\nfor penalty in [\"l2\", \"l1\"]:\n    print('=' * 80)\n    print(\"%s penalty\" % penalty.upper())\n    # Train Liblinear model\n    # svc stands for c-support vector classification\n    print('Linear SVC')\n    benchmark(LinearSVC(penalty=penalty, dual=False, tol=1e-3))\n\n    print('SGDClassifier')\n    # Train SGD model\n    benchmark(SGDClassifier(alpha=.0001, n_iter=200, penalty=penalty))\n上面这个例子是官方文档给出的 SVM 分类实例，数据集是 20 new groups, 如果本地没有数据集，sklearn 会自动下载\nsklearn 的匹配模式非常简单，选中模型 clf 后直接调用 clf.fit(X_train, Y_train) 即可完成模型训练，然后调用 clf.predict(X_test) 即可返回结果\n需要关注的是参数的配置，比如上文中对于 LinearSVC 和 SGD 来讲，都有一个很多参数可以配置，比如 penalty, alpha 等等，下面是参数的翻译\nSVM 的参数翻译\nSimilar to SVC with parameter kernel='linear', but implemented in terms of\nliblinear rather than libsvm, so it has more flexibility in the choice of\npenalties and loss functions and should scale better to large numbers of samples.\n\nThis class supports both dense and sparse input and the multiclass support\nis handled according to a one-vs-the-rest scheme.\nSVM 多 label 分类是多个 binary classifier 的组合\n\npenalty : string, 'l1' or 'l2' (default='l2')\nSpecifies the norm used in the penalization. The 'l2'\npenalty is the standard used in SVC. The 'l1' leads to ``coef_``\nvectors that are sparse.\n从数据集上来看，l2 的效果好一些\n\ndual : bool, (default=True)\nSelect the algorithm to either solve the dual or primal\noptimization problem. Prefer dual=False when n_samples > n_features.\n一般来说 sample > feature, 但是对于文本分来来说，这个也不一定为真\n\ntol : float, optional (default=1e-4)\nTolerance for stopping criteria.\n\nmax_iter : int, (default=1000)\nThe maximum number of iterations to be run.\n\ntol 和 max_iter 是训练集的终止条件，一个是按照 loss function 的误差，一个是按照最大迭代次数\n\nC : float, optional (default=1.0)\nPenalty parameter C of the error term.\n相当于惩罚松弛变量，希望松弛变量接近0，即对误分类的惩罚增大，趋向于对训练集全分对的情况，这样对训练集测试时准确率很高，\n但泛化能力弱。C值小，对误分类的惩罚减小，允许容错，将他们当成噪声点，泛化能力较强，\n对于那些比较粗糙的数据，比如说文本分类应该用较大一些的 C\n\ncoef_ : array, shape = [n_features] if n_classes == 2 else [n_classes, n_features]\nWeights assigned to the features (coefficients in the primal\nproblem). This is only available in the case of a linear kernel.\n本来以为 SVC 非线性核的分类效果会好一些，结果发现奇差无比，然后搜索了下大家对 SVM 的看法\n预测函数简单f(x) = w’*x+b，分类速度快。对于类别多的问题，分类速度的确需要考虑到，线性分类器的w可以事先计算出来，而非线性分类器在高维空间时支持向量数会非常多，分类速度远低于线性分类器。\n线性SVM的推广性有保证，而非线性如高斯核有可能过学习。再举个例子，基于人脸的性别识别，即给定人脸图像，判断这个人是男还是女。我们提取了3700多维的特征，用线性SVM就能在测试集上达到96%的识别正确率。因此，线性SVM是实际应用最多的，实用价值最大的。\n如果在你的应用中，特征维数特别低，样本数远超过特征维数，则选用非线性核如高斯核是比较合理的。如果两类有较多重叠，则非线性SVM的支持向量特别多，选择稀疏的非线性SVM会是一个更好的方案，支持向量少分类速度更快。\n随意，非线性 SVM 还不如线性 SVM。\npenalty 属性是 loss function 的定义\n另外 sklearn 给出了训练模型的评价指标，以 precision, recall, f1-score, support 来反应模型的好坏。\n最后，clf 模型甚至可以返回最能影响分类器分类效果的 top K 个单词，但是要求分类器有 coef 属性，目前用到的几个分类器，似乎都有这个这个属性。\n\nsklearn 做文本分类其他可选分类器\n除了 SVM 分类外，还要很多分类器可选，下面列出若干常用分类器\nresults = []\nfor clf, name in (\n        (RidgeClassifier(tol=1e-2, solver=\"lsqr\"), \"Ridge Classifier\"),\n        (Perceptron(n_iter=50), \"Perceptron\"),\n        (PassiveAggressiveClassifier(n_iter=50), \"Passive-Aggressive\"),\n        (KNeighborsClassifier(n_neighbors=10), \"kNN\"),\n        (RandomForestClassifier(n_estimators=100), \"Random forest\")\n):\n    print('=' * 80)\n    benchmark(clf)\n除了上面提到的分类器以外，还有一个是贝叶斯分类，贝叶斯分类我在研究生阶段就学习过，它根据单词和文本的对应关系来分类文档，因为某种类型的文档就会出现某种类型的单词，下面是我找到的别人写好的例子。\nnbc = Pipeline([\n    ('vect', TfidfVectorizer()),\n    ('clf', MultinomialNB(alpha=1.0)), # 或者使用 BernoulliNB\n])\nnbc_6.fit(train_data, train_target)    #训练我们的多项式模型贝叶斯分类器\npredict = nbc_6.predict(test_data)  #在测试集上预测结果\ncount = 0                                      #统计预测正确的结果个数\nfor left , right in zip(predict, test_target):\n      if left == right:\n            count += 1\nprint(count/len(test_target))\nout: 0.793\nbenchmark 函数还是定义的那个，从分类的结果来看，这几种分类器的分类效果也都不错，且运算时间都不长，考虑到未来，深度学习的时间可以控制在数十秒以内，人工智能肯定再会上一个台阶。\n随机森林分类器:\n经典的决策树是一个颗树，按照特征的信息增益来选择分裂样本，计算公式不是很复杂。一句来来解释，就是样本的正反和特征的正反吻合的比较好，这种特征认为和数据关系较大，因此可以用来选取作为分裂特征 随机森林是从数据集中有放回的拿数据，每个子数据的数量和原数据一样，所以子数据很可能有重复数据，然后每个子数据训练数据集，最后大家投票，选择分类。 KNN\nKNN 是有监督的学习方法，不同于 Kmeans 的无监督学习方法。它的核心是每个样本都可以用它最近的几个邻居来表示，如果一个样本在特征空间中的k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别。KNN算法中，所选择的邻居都是已经正确分类的对象。该方法在定类决策上只依据最邻近的一个或者几个样本的类别来决定待分样本所属的类别。 KNN方法虽然从原理上也依赖于极限定理，但在类别决策时，只与极少量的相邻样本有关。由于KNN方法主要靠周围有限的邻近的样本，而不是靠判别类域的方法来确定所属类别的，因此对于类域的交叉或重叠较多的待分样本集来说，KNN方法较其他方法更为适合。\n优缺点：\n特别适合于多分类问题(multi-modal,对象具有多个类别标签)， kNN比SVM的表现要好\n该算法在分类时有个主要的不足是，当样本不平衡时，如一个类的样本容量很大，而其他类样本容量很小时，有可能导致当输入一个新样本时，该样本的K个邻居中大容量类的样本占多数。 该算法只计算“最近的”邻居样本，某一类的样本数量很大，那么或者这类样本并不接近目标样本，或者这类样本很靠近目标样本。无论怎样，数量并不能影响运行结果。\n该方法的另一个不足之处是计算量较大，因为对每一个待分类的文本都要计算它到全体已知样本的距离，才能求得它的K个最近邻点。\nPerceptron\n感知器分类器，从文档上来看，它似乎是线性回归的\nSGD\n随机梯度下降，好处是能够跳出局部最优解\n\n文本分类中的数据预处理方法\n上面使用到的数据集都是 sklearn 自带的，真正应用时，需要自己处理数据，在一开始，这是最耗费时间的过程。\n下面是一个生成一个分类器可用数据的格式\ndef fetchTrainData(datadir, type, data = [], target = []):\n    for file in os.listdir(datadir):\n        with open(datadir + file) as f:\n            file_data = []\n            for row in f:\n                file_data.append(row)\n\n        data.append(\" \".join(file_data))\n        target.append(type)\n\ndef jiebaTfIdf(data, virgin, vectorizer):\n    # 语料库是一个一维数组，数组的每一个元素是一个文档（经过预处理）\n    corpus = []\n    for lines in data['data']:\n        # cut_all 是什么意思呢？\n        words = jieba.cut(lines, cut_all=True)\n        stopFreeLine = []\n        for word in words:\n            if word != '' and word != \"\\n\" and word != \"\\n\\n\" and word not in STOP_WORDS:\n                stopFreeLine.append(word)\n        # 再把此行加入到命令中\n        corpus.append(\" \".join(stopFreeLine))\n\n    # 使用对单词进行 tfidf 预处理\n    # 返回的 shape 是 112 * 6111 这是什么意思呢?\n    # fit_transform 和 transform 的区别是什么呢\n    if virgin:\n        tfidf = vectorizer.fit_transform(corpus)\n    else:\n        tfidf = vectorizer.transform(corpus)\n    # feature_names = vectorizer.get_feature_names()\n    return tfidf\n\n\nfetchTrainData(api_train_dir, '0', train_data, target)\nfetchTrainData(other_train_dir, '1', train_data, target)\n\ncache = dict(data = train_data, target=target,target_name=target_name)\n\nvectorizer = TfidfVectorizer(sublinear_tf=True,  stop_words='english')\nX_train = jiebaTfIdf(cache, True, vectorizer)\nclf.fit(X_train, y_train)\nX_train 和 y_train 函数都是数组，在放入 vectorizer 之前，x_train.data 就是邮件本身，它是一个长度为 2034 的 array: len(x_train.data) -> 2034, 下面是数组中的第一个元素\n\"From: rych@festival.ed.ac.uk (R Hawkes)\\nSubject: 3DS: Where did all the\ntexture rules go?\\nLines: 21\\n\\nHi,\\n\\nI've noticed that if you only save a\nmodel (with all your mapping planes\\npositioned carefully) to a .3DS file\nthat when you reload it after restarting\\n3DS, they are given a default\nposition and orientation.  But if you save\\nto a .PRJ file their\npositions/orientation are preserved.  Does anyone\\nknow why this information\nis not stored in the .3DS file?  Nothing is\\nexplicitly said in the manual\nabout saving texture rules in the .PRJ file. \\nI'd like to be able to\nread the texture rule information, does anyone have \\nthe format for\nthe .PRJ file?\\n\\nIs the .CEL file format available from somewhere?\n\\n\\nRych\\n\\n=====================================================\n=================\\nRycharde Hawkes\\t\\t\\t\\temail: rych@festival.ed\n.ac.uk\\nVirtual Environment Laboratory\\nDept. of Psychology\\t\\t\\tTel  :\n +44 31 650 3426\\nUniv. of Edinburgh\\t\\t\\tFax  : +44 31 667 0150\\n======\n ================================================================\\n\"\n在进入 vectorizer 之后，就变成了一个矩阵, x_train.shape = (2034, 33809), 每一个文档变成了一个有 33809 个词向量表示的数组，这个地方需要注意，fit_transform 和 transform的区别，fit_transform 会计算需要多少个词来描述一个文档，33809 是这个函数的输出之一，而transform 就用把自己的数据变成 33809 个词的矩阵，因此对于训练数据集用 fit_transform,对测试集使用 transform, 千万不能多次调用 fit_transform.\nTF-IDF Vectorizer 对一个文档的描述\n  (0, 26977)    0.29200533962\n  (0, 13788)    0.223534884596\n  (0, 12254)    0.143033187036\n  (0, 4287)    0.112190889038\n  (0, 31453)    0.104409646825\n  (0, 15786)    0.23558806939\n  (0, 2362)    0.260611070013\n  (0, 11264)    0.0532815955186\n  (0, 30376)    0.223037634455\n  (0, 26918)    0.134980938364\n  (0, 1621)    0.0655837805259\n  (0, 16025)    0.0699392301968\n  (0, 32232)    0.0508220378498\n  (0, 22173)    0.100565143276\n  (0, 27212)    0.134980938364\n起初，我对这个数据很疑惑，为什么不表示成一个矩阵的形式，后来看到一个例子才搞明白，因为数组较长，所以我们把那些不为 0 的词拿出来就好，比如第一行，就是 26977 个位置的词不为0 ，其值为 0.29200533962。\nsklearn 不支持中文的分词器，所以我们要手动处理，在上面的例子中，我们使用结巴分词，并使用某大学的停词词库进行过滤单词。 words = jieba.cut(lines, cut_all=True)这句话的意思是把一个单词分解成它所有可能组合的形式，比如中华人民共和国会分解成中华，中华人民，和中国人民共和国。\ncache = dict(data = train_data, target=target,target_name=target_name)这行代码我其实也不是很明白，python 的数据结构然后这么的随意，dict 的 key 可以是一个不存在的变量而不需要加上引号？\n关于 CountVectorizer，我一直以为它是 BOW 类似的实现，但是看到下面这个例子后才发现并不是\ntexts=[\"dog cat fish\",\"dog cat cat\",\"fish bird\", 'bird']\ncv = CountVectorizer()\ncv_fit=cv.fit_transform(texts)\n\nprint(cv.get_feature_names())\nprint(cv_fit.toarray())\n#['bird', 'cat', 'dog', 'fish']\n#[[0 1 1 1]\n# [0 2 1 0]\n# [1 0 0 1]\n# [1 0 0 0]]\n\nprint(cv_fit.toarray().sum(axis=0))\n#[2 3 2 2]\n只是简单的词频相加，看来 sklearn 还是适合用一些简单的算法，深度学习相关的东西还是交给tensorflow 等框架。但是一般并不是不好，sklearn 对大部分场景已经很好了，并且它超级快，在笔记本上就能训练出一个模型。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}