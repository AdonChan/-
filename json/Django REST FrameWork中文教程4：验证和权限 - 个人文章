{"title": "Django REST FrameWork中文教程4：验证和权限 - 个人文章 ", "index": "django-rest-framework,django,python", "content": "目前，我们的API对谁可以编辑或删除代码段没有任何限制。我们想要一些更高级的行为，以确保：\n代码段始终与创建者相关联。\n只有身份验证的用户可以创建片段。\n只有片段的创建者可以更新或删除它。\n未经身份验证的请求应具有完全只读访问权限。\n将信息添加到我们的模型我们将对我们的Snippet模型类进行一些更改。首先，我们添加几个字段。其中一个字段将用于表示创建代码段的用户。另一个字段将用于存储代码的突出显示的HTML表示。\n将以下两个字段添加到Snippet模型中models.py。\nowner = models.ForeignKey('auth.User', related_name='snippets', on_delete=models.CASCADE)\nhighlighted = models.TextField()\n\n我们还需要确保在保存模型时，使用pygments代码突出显示库填充突出显示的字段。\n我们需要一些额外的导入：\nfrom pygments.lexers import get_lexer_by_name\nfrom pygments.formatters.html import HtmlFormatter\nfrom pygments import highlight\n\n现在我们可以.save()在我们的模型类中添加一个方法：\ndef save(self, *args, **kwargs):\n    \"\"\"\n    Use the `pygments` library to create a highlighted HTML\n    representation of the code snippet.\n    \"\"\"\n    lexer = get_lexer_by_name(self.language)\n    linenos = self.linenos and 'table' or False\n    options = self.title and {'title': self.title} or {}\n    formatter = HtmlFormatter(style=self.style, linenos=linenos,\n                              full=True, **options)\n    self.highlighted = highlight(self.code, lexer, formatter)\n    super(Snippet, self).save(*args, **kwargs)\n\n完成这些工作后，我们需要更新我们的数据库表。通常我们将创建一个数据库迁移，为了做到这一点，但是为了本教程的目的，我们只需删除数据库并重新开始\nrm -f tmp.db db.sqlite3\nrm -r snippets/migrations\npython manage.py makemigrations snippets\npython manage.py migrate\n\n您可能还需要创建几个不同的用户，以用于测试API。执行此操作的最快方法是使用createsuperuser命令。\npython manage.py createsuperuser\n\n为我们的用户模型添加端点现在我们有一些用户可以使用，我们最好将这些用户的表示添加到我们的API中。创建一个新的serializer很容易。在serializers.py添加：\nfrom django.contrib.auth.models import User\n\nclass UserSerializer(serializers.ModelSerializer):\n    snippets = serializers.PrimaryKeyRelatedField(many=True, queryset=Snippet.objects.all())\n\n    class Meta:\n        model = User\n        fields = ('id', 'username', 'snippets')\n\n因为在User模型上'snippets'是一个反向关系，所以在使用ModelSerializer该类时它不会被默认包含，所以我们需要为它添加一个显式字段。\n我们还会添加几个视图views.py。我们希望只使用只读视图为用户表示，所以我们将使用ListAPIView和RetrieveAPIView通用的基于类的意见。\nfrom django.contrib.auth.models import User\n\n\nclass UserList(generics.ListAPIView):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n\n\nclass UserDetail(generics.RetrieveAPIView):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n\n确保也导入UserSerializer类\nfrom snippets.serializers import UserSerializer\n\n最后，我们需要通过从URL conf引用它们将这些视图添加到API中。将以下内容添加到其中的模式中urls.py。\nurl(r'^users/$', views.UserList.as_view()),\nurl(r'^users/(?P<pk>[0-9]+)/$', views.UserDetail.as_view()),\n\n将片段与用户关联现在，如果我们创建了一个代码片段，那么将无法将创建该代码段的用户与代码段实例相关联。用户不是作为序列化表示的一部分发送的，而是传入请求的属性。\n我们处理的方式是覆盖.perform_create()我们的代码片段视图上的方法，这样我们可以修改实例保存的管理方式，并处理传入请求或请求的URL中隐含的任何信息。\n在SnippetList视图类中，添加以下方法：\ndef perform_create(self, serializer):\n    serializer.save(owner=self.request.user)\n\ncreate()我们的串行器的方法现在将被传递一个附加'owner'字段，以及请求中验证的数据。\n更新我们的serializer现在，这些片段与创建它们的用户相关联，我们更新我们SnippetSerializer来反映这一点。将以下字段添加到序列化器定义中serializers.py：\nowner = serializers.ReadOnlyField(source='owner.username')\n\n注意：确保您还添加'owner',到内部Meta类的字段列表。\n这个领域正在做一些很有趣的事情。的source哪个属性参数控制用于填充的字段，并且可以在对串行化实例的任何属性点。它也可以采用上面显示的点划线，在这种情况下，它将以与Django模板语言一起使用的相似方式遍历给定的属性。\n我们添加了字段是类型化ReadOnlyField类，相对于其他类型的字段，如CharField，BooleanField等...类型化ReadOnlyField始终是只读的，并且将用于序列化表示形式，但不会被用于更新模型他们被反序列化的实例。我们也可以CharField(read_only=True)在这里使用。\n添加视图所需的权限现在，代码片段与用户相关联，我们希望确保只有经过身份验证的用户才能创建，更新和删除代码段。\nREST框架包括许多权限类，我们可以使用它们来限制谁可以访问给定的视图。在这种情况下，我们正在寻找的是IsAuthenticatedOrReadOnly，这将确保经过身份验证的请求获得读写访问权限，未经身份验证的请求将获得只读访问权限。\n首先在视图模块中添加以下导入\nfrom rest_framework import permissions\n\n接着，下面的属性添加到都在SnippetList和SnippetDetail视图类。\npermission_classes = (permissions.IsAuthenticatedOrReadOnly,)添加登录到Browsable API如果您打开浏览器并导航到目前可浏览的API，那么您将发现无法再创建新的代码段。为了做到这一点，我们需要能够以用户身份登录。\n我们可以通过编辑项目级urls.py文件中的URLconf来添加可浏览API使用的登录视图。\n在文件顶部添加以下导入：\nfrom django.conf.urls import include并且，在文件末尾，添加一个模式以包括可浏览的API的登录和注销视图。\nurlpatterns += [\n    url(r'^api-auth/', include('rest_framework.urls',\n                               namespace='rest_framework')),\n]\n\nr'^api-auth/'模式的一部分实际上可以是您要使用的任何URL。唯一的限制是所包含的URL必须使用'rest_framework'命名空间。在Django 1.9+中，REST框架将设置命名空间，因此您可以将其删除。\n现在，如果再次打开浏览器并刷新页面，您将在页面右上角看到一个“登录”链接。如果您以您之前创建的用户身份登录，则可以再次创建代码段。\n创建几个代码片段后，导航到“/ users /”端点，并注意到该表示包含每个用户的“片段”字段中与每个用户相关联的代码段的列表。\n对象级权限我们希望所有的代码片段都可以被任何人看到，但也要确保只有创建代码段的用户才能更新或删除它。\n要做到这一点，我们将需要创建一个自定义权限。\n在片段应用中，创建一个新文件， permissions.py\nfrom rest_framework import permissions\n\n\nclass IsOwnerOrReadOnly(permissions.BasePermission):\n    \"\"\"\n    Custom permission to only allow owners of an object to edit it.\n    \"\"\"\n\n    def has_object_permission(self, request, view, obj):\n        # Read permissions are allowed to any request,\n        # so we'll always allow GET, HEAD or OPTIONS requests.\n        if request.method in permissions.SAFE_METHODS:\n            return True\n\n        # Write permissions are only allowed to the owner of the snippet.\n        return obj.owner == request.user\n\n现在，我们可以通过编辑视图类中的permission_classes属性将该自定义权限添加到我们的代码段实例端点SnippetDetail：\npermission_classes = (permissions.IsAuthenticatedOrReadOnly,\n                      IsOwnerOrReadOnly,)\n\n确保也导入IsOwnerOrReadOnly类。\nfrom snippets.permissions import IsOwnerOrReadOnly现在，如果再次打开浏览器，您会发现如果您以与创建代码段相同的用户身份登录，“DELETE”和“PUT”操作只会显示在代码段实例端点上。\n使用API进行身份验证因为我们现在有一组API的权限，如果我们要编辑任何片段，我们需要验证我们的请求。我们还没有设置任何身份验证类，所以默认值现在被应用，哪些是SessionAuthentication和BasicAuthentication。\n当我们通过Web浏览器与API进行交互时，我们可以登录，然后浏览器会话将为请求提供所需的身份验证。\n如果我们以编程方式与API交互，我们需要在每个请求上显式提供身份验证凭据。\n如果我们尝试创建一个没有验证的代码段，我们会收到一个错误：\nhttp POST http://127.0.0.1:8000/snippets/ code=\"print 123\"\n\n{\n    \"detail\": \"Authentication credentials were not provided.\"\n}\n\n我们可以通过包括我们之前创建的一个用户的用户名和密码来成功提出请求。\nhttp -a tom:password123 POST http://127.0.0.1:8000/snippets/ code=\"print 789\"\n\n{\n    \"id\": 1,\n    \"owner\": \"tom\",\n    \"title\": \"foo\",\n    \"code\": \"print 789\",\n    \"linenos\": false,\n    \"language\": \"python\",\n    \"style\": \"friendly\"\n}\n\n概要我们现在已经在我们的Web API上获得了一个相当精细的权限，并为系统的用户和他们创建的代码段提供了终点。\n在本教程的第5部分中，我们将介绍如何通过为突出显示的片段创建一个HTML端点来将所有内容联结在一起，并通过为系统中的关系使用超链接来提高API的凝聚力。\nDjango REST FrameWork 中文教程1:序列化\nDjango REST FrameWork 中文教程2:请求和响应\nDjango REST FrameWork 中文教程3:基于类的视图\nDjango REST FrameWork 中文教程4：验证和权限\nDjango REST FrameWork 中文教程5：关系和超链接API\nDjango REST FrameWork 中文教程6: ViewSets＆Routers\nDjango REST FrameWork 中文教程7：模式和客户端库\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}