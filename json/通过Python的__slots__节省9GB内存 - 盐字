{"title": "通过Python的__slots__节省9GB内存 - 盐字 ", "index": "编程技巧,python3.x,编译,性能优化,python", "content": "我们之前提到过，Oyster.com基于Python的web服务器缓存了大量Python字典（dicts）（哈希表（hash tables））的静态内容。好啦，我们最近使用一行代码——在我们的Image类中使用__slots__，使得每个6GB的服务器在处理中都节省超过2GB内存。\n\n这是使用前和使用这一改变后再部署的RAM用量截图：\n\n\n\n我们大概分配了一百万个下面这个类的实例：\n\npythonclass Image(object):\n    def __init__(self, id, caption, url):\n        self.id = id\n        self.caption = caption\n        self.url = url\n        self._setup()\n\n    # ... other methods ...\n\n\nPython默认使用一个字典来存储一个对象的实例属性。一般说来，这很不错，而且还支持完全动态性，比如在运行时设置任意新的属性。\n\n然而，对于一个“小类”来说，有一些在“编译时”就已经固定的属性，这样一来，字典实际上是在消耗内存，在创建一百万个这样的类的时候，消耗更是显而易见。你可以跟Python说不使用字典，而是仅为某些固定的属性分配空间，可以通过在类中将__slots__设置为一个固定列表来实现这个效果：\n\npythonclass Image(object):\n    __slots__ = ['id', 'caption', 'url']\n\n    def __init__(self, id, caption, url):\n        self.id = id\n        self.caption = caption\n        self.url = url\n        self._setup()\n\n    # ... other methods ...\n\n\n需要特别说到的是，你也可以使用 collections.namedtuple，它仅限定元组空间(the space of a tuple)中的属性能够访问，这与在类中使用__slots__相似。但是，在我看来，从一个命名元组（namedtuple）类中继承令人感到怪异。并且，如果你想自定义初始化器（initializer），你还必须重写__new__而不是用__init__。\n\n警告：别过早优化或者将此应用在所有场景！这个方法并不利于代码维护，而且在你真的有成千个实例的时候才有显著效果。\n\n来自：Saving 9 GB of RAM with Python’s __slots__\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "6"}