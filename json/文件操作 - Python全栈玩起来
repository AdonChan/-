{"title": "文件操作 - Python全栈玩起来 ", "index": "python", "content": "打开文件\n\n文件路径：相对路径  ： 1-读文件.py 绝对路径  : C:\\Users\\xlg\\Desktop\\文件操作\\1-读文件.py\nr :以只读的方式打开文件，文件描述符放在文件的开头位置\nrb ： 以二进制格式打开文件，文件只读，文件描述符放在文件的开头位置\nw：以只写的方式打开文件，如果文件存在，那么覆盖该文件，如果文件不存在，则会创建文件。\nwb：以二进制格式打开文件，文件用于写入，如果文件存在，那么覆盖该文件。\nw+：以读写的方式打开文件\na：打开一个文件用于追加写入，如果文件不存在，则会创建文件；如果文件存在，则会在文件末尾写入内容。\na+：以读写的方式打开文件\nencoding：文件的编码格式errors：错误处理strict：默认方式，如果遇到非法字符，抛出异常ignore：忽略非法字符replace：用?代替非法字符open：返回值：文件描述符\n\n打开普通文件\nf1 = open(\"file.txt\",\"r\", encoding=\"utf-8\")\n# 当文件不存在，抛出异常\n# FileNotFoundError: [Errno 2] No such file or directory: 'file.txt'\n\n# 打开二进制格式的文件:不能设置encoding\nf2 = open(\"file.txt\", \"rb\")\n# 指定错误处理方式\nf3 = open(\"file.txt\", mode=\"r\", encoding=\"utf-8\", errors=\"ignore\")\n\n读取文件\n\n# 读取文件所有内容    \nstr1 = f1.read()\n# 读取指定字符个数\nstr2 = f1.read(4)\n# 读取整行 包括\\n   size代表字符个数 中文也算一个\nstr3 = f1.readline(size)  \n# 读取所有行，返回一个列表\nstr4 = f1.readlines()\n\n#如果给定的size数字大于0，实际返回的size字符数会比写入的size大，原因需要填充缓冲区\n\n# 修改描述符的位置  seek()\n# tell()  返回描述符的位置\nprint(f1.read(3))\nprint(f1.tell()) # 3\nf1.seek(3)\nprint(f1.read(3))  # 打印第四个到第六个字符\n\n关闭文件\n\nf1.close() # 必须关闭\n\ntry:\n    f2 = open(\"file.txt\", \"r\", encoding=\"utf-8\")\n    print(f2.read())\nexcept FileNotFoundError as e:\n    print(\"文件没有找到\")\nfinally:\n    if f2:\n        f2.close()\n\n# 简洁的方式:\nwith open(\"file.txt\", \"r\", encoding=\"utf-8\") as f5:\nprint(f5.read())\n\n写入文件\nwith open(\"c.txt\",\"w\", encoding=\"utf-8\") as f2:\nf2.write(\"124789kfxfh\")\n\n编码与解码\n# 编码  encode(\"编码格式\")\nwith open(\"d.txt\",\"wb\") as f1:\n    str1 = \"北京你好，我有沙尘暴，hello world\"\n    f1.write(str1.encode(\"GBK\"))\n\n# 解码  decode(\"编码格式\")\nwith open(\"d.txt\",\"rb\") as f2:\n    data = f2.read()\n    print(data)\n    print(type(data))  # byte 字节\n\n    newStr =data.decode(\"GBK\")\n    print(newStr)\n    print(type(newStr))  # str\n\n存储操作\n有时候，我们需要将某些字符串、列表、字典、元组等数据长久保存，现在，这个时候，就需要使用永久性存储的模块文件pickle。pickle模块可以将对象转换为一种可以存储或读取的格式。pickle:该模块实现了数据的序列化与反序列化，通过pickle的序列化操作，可以实现将程序中的对象保存到文件信息中，实现永久性存储。通过pickle的反序列化操作，可以实现将程序中的永久性存储的对象解析出来。\n\n\nlist1 = [1,2,3,4,5,6]\nf1 = open(\"list.data\", \"wb\")\n# 将列表信息保存到文件中\n# pickle.dump(即将存储的数据对象, 存入的文件)   序列化操作\n# 建议：保存对象时，文件的后缀名不要使用电脑系统能够打开的格式\npickle.dump(list1, f1)\nf1.close()\n\n\n# 读取文件\ntmp = []\n# 打开文件\nf2 = open(\"list.data\", \"rb\")\n# pickle.load(读取的文件)  有返回值\ntmp = pickle.load(f2)\nprint(tmp)\nf2.close()\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}