{"title": "量化交易之股票买卖因子——多策略突破融合 - Python量化交易 ", "index": "python", "content": "前言\n之前我们分别介绍了N日趋势突破和单均线突破两个策略，本章着重将这两种策略结合来介绍多策略融合进行交易的方法。\n\n动态实例化策略\n以买入策略为例，使用dict初始化买入因子，class为类函数，xd为传入的参数。FactorBuyNdayBreak类执行N日趋势突破策略，FactorBuyAverBreak类执行单均线突破策略。\nbuy_factors = [{'xd': 20,'class': FactorBuyNdayBreak},\n            {'xd': 30,'class': FactorBuyAverBreak}]\ndef init_buy_factors(self, buy_factors):\n    \"\"\"\n    通过buy_factors实例化各个买入因子\n    :param buy_factors: list中元素为dict，每个dict为因子的构造元素，如class，构造参数等\n    :return:\n    \"\"\"\n    self.buy_factors = list()\n\n    if buy_factors is None:\n        return\n\n    for factor_class in buy_factors:\n        if factor_class is None:\n            continue #执行下个循环\n        if 'class' not in factor_class:\n            raise ValueError('factor class key must name class!!')\n        #print \"before copy\",id(factor_class)\n        factor_class = copy.deepcopy(factor_class)\n        #print \"after copy\",id(factor_class)\n        class_fac = copy.deepcopy(factor_class['class'])\n        del factor_class['class']\n        #print \"del\",id(factor_class)\n        \n        '''实例化买入因子'''\n        factor = class_fac(**factor_class)\n        if not isinstance(factor, FactorBuyAverBreak) and not isinstance(factor, FactorBuyNdayBreak):#判断factor为基于FactorBuyBreak实例\n            raise TypeError('factor must base FactorBuyBreak!!')\n        self.buy_factors.append(factor)\n注：打印id可见，copy.deepcopy(factor_class)复制后，即使执行del factor_class['class']也不影响原数值\n\n策略融合实现\n遍历所有买入和卖出策略，买入时需要满足双策略同时发出有效信号，卖出时仅其中一个策略有效即可。\ndef _day_task(self, kl_index, today):\n    \n    fact_buy,fact_sell,sell_buf,buy_buf = 0,0,0,0\n    \n    for index, buy_factor in enumerate(self.buy_factors):\n        #遍历所有买入因子\n        buy_buf += buy_factor.fit_day(kl_index, today, self.kl_pd)\n    fact_buy = 1 if (buy_buf == (index+1)) else 0\n        \n    for index, sell_factor in enumerate(self.sell_factors):\n        #遍历所有卖出因子\n        sell_buf += sell_factor.fit_day(kl_index, today, self.kl_pd)\n    fact_sell = -1 if (sell_buf > 0) else 0\n\nreturn fact_buy or fact_sell\n\n\n\n单策略判断逻辑\n以N日趋势突破买入策略FactorBuyNdayBreak为例，需要判断当日收盘价是否为N日内的最高价，同理卖出策略使用min()判断出N日内最低价。单均线突破买入和卖出策略则通过比较当日收盘价与N日内的平均价mean()的大小。\nclass FactorSellNdayBreak:\n    def __init__(self,**kwargs):\n        self.xd = kwargs['xd']\n\n    def fit_day(self,kl_index, today, stock_df):\n        day_ind = stock_df.index.get_loc(kl_index)\n\n        if day_ind < self.xd - 1 or day_ind >= stock_df.shape[0] - 1:\n            return False \n      \n        if today.Close == stock_df.Close[day_ind-self.xd+1:day_ind+1].min():\n            print 'FactorSellNdayBreak for info',kl_index,today.Close,stock_df.Close[day_ind-self.xd+1:day_ind+1].min()\n            return self.fit_sell_order()\n        return False  \n\n注：*kwargs表示多余的传值以字典的方式呈现注：pd.rolling_mean(self.kl_pd.Close,window=30)方法获取的30日均线值与mean()方法计算值相同。*\n\n策略执行实现\n通过时间序列方式遍历每天的股票数据，_day_task接收股票数据执行买卖因子策略判断，而后反馈买入/卖出行为，系统根据signal值在界面显示操作信号。\nfor kl_index,today in self.kl_pd.iterrows():\n\n    signal = self._day_task(kl_index, today)\n    \n    if signal > 0:# 买入    \n        if is_win == False:#空仓则买\n            start = self.kl_pd.index.get_loc(kl_index)\n            is_win = True\n           \n            self.posit_num = int(self.cash_hold/today.Close)\n            self.cash_hold = 0 \n            print \"Start order\",kl_index\n            plt.annotate('B',xy=(kl_index,self.kl_pd.Close.asof(kl_index)),xytext=(kl_index, self.kl_pd.Close.asof(kl_index)+4),arrowprops=dict(facecolor='yellow',shrink=0.1),horizontalalignment='left',verticalalignment='top')\n\n    elif signal < 0:# 卖出 \n        if is_win == True:#避免未买先卖\n            end = self.kl_pd.index.get_loc(kl_index)\n            is_win = False\n            print \"End order\",kl_index\n            self.cash_hold = int(self.posit_num*today.Close)\n            self.market_total = 0\n\n            if self.kl_pd.Close[end] < self.kl_pd.Close[start]:#赔钱显示绿色\n                plt.fill_between(self.kl_pd.index[start:end],0,self.kl_pd.Close[start:end],color='green',alpha=0.38)\n                \n            else:#赚钱显示绿色\n                plt.fill_between(self.kl_pd.index[start:end],0,self.kl_pd.Close[start:end],color='red',alpha=0.38)\n    list_signal.append(is_win) \n    \n    if is_win == True:\n        self.market_total = int(self.posit_num*today.Close)\n        self.profit_curve.append(self.market_total)\n    else:\n        self.profit_curve.append(self.cash_hold)\n\n\n效果显示\n以一次买卖执行为例，2017-03-14日两个策略同时生效，执行买入策略，由于是一次性全仓买入，在2017-03-17日两个策略再次同时生效时，系统忽略执行买入操作。直到在2017-03-28日N日突破卖出策略满足卖出条件时触发卖出操作。\n                            Index       Close   Value\nFactorBuyAverBreak for info 2017-03-13 00:00:00 13.84 13.668\nFactorBuyNdayBreak for info 2017-03-14 00:00:00 14.58 14.58\nFactorBuyAverBreak for info 2017-03-14 00:00:00 14.58 13.728\nStart order 2017-03-14 00:00:00\nFactorBuyAverBreak for info 2017-03-15 00:00:00 14.25 13.7603333333\nFactorBuyNdayBreak for info 2017-03-16 00:00:00 14.64 14.64\nFactorBuyAverBreak for info 2017-03-16 00:00:00 14.64 13.793\nFactorBuyNdayBreak for info 2017-03-17 00:00:00 14.75 14.75\nFactorBuyAverBreak for info 2017-03-17 00:00:00 14.75 13.83\nFactorBuyAverBreak for info 2017-03-20 00:00:00 14.65 13.8576666667\nFactorBuyAverBreak for info 2017-03-21 00:00:00 14.48 13.8816666667\nFactorBuyNdayBreak for info 2017-03-22 00:00:00 14.78 14.78\nFactorBuyAverBreak for info 2017-03-22 00:00:00 14.78 13.9193333333\nFactorBuyAverBreak for info 2017-03-23 00:00:00 14.58 13.9493333333\nFactorBuyAverBreak for info 2017-03-24 00:00:00 14.58 13.9793333333\nFactorBuyAverBreak for info 2017-03-27 00:00:00 14.45 14.012\nFactorBuyAverBreak for info 2017-03-28 00:00:00 14.07 14.032\nFactorSellNdayBreak for info 2017-03-28 00:00:00 14.07 14.07\nEnd order 2017-03-28 00:00:00\n注：收益图和资金获利图实现方法可参考N日趋势突破和单均线突破文中的介绍\n更多python量化交易内容互动请加微信公众号：PythonQT-YuanXiao\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "3"}