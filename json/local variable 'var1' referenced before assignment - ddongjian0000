{"title": "local variable 'var1' referenced before assignment - ddongjian0000 ", "index": "python", "content": "起初是群里一个哥们这句话报错。后来之前的一个实习生，给出了链接来解释这个问题。 我竟然没看懂....\nhttp://stackoverflow.com/questions/89347...\n代码如下：\ndef foo1(tmp =None):\n\n    def foo():\n        if tmp:\n            print tmp\n        else :\n            tmp = None\n\n    return foo()\n\n其实这个代码不能很好的反应问题。来看以下两个case\ndef foo1(var1 =None):\n\n    def foo():\n        var1 = 1 + 1\n        print var1\n    return foo()\n\n\ndef foo3(tmp=None):\n    def foo():\n        c = tmp\n        tmp = 1 + 1\n\n    return foo()\n\n我一开始没理解这个问题。看到assign variable 和access variable 粗略的理解成不能够在闭包函数中改变上层函数的变量。但... 根本不是这回事。\n实际上是， 如果一个变量被赋值，那么python会认为其为局部变量。局部变量只会在当前函数空间来找到变量(就是foo函数内)，所以可以看到，在foo3中，解析器看到tmp = 1+1 就认为 tmp 为局部变量，然后想起来之前好像用过tmp，c= tmp ，发现tmp 在这句之前没有被定义所以报错了。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "0"}