{"title": "zeromq的三种简单模式（python实现） - 个人文章 ", "index": "zeromq,python", "content": "简介\nZMQ (以下 ZeroMQ 简称 ZMQ)是一个简单好用的传输层，像框架一样的一个 socket library，他使得 Socket 编程更加简单、简洁和性能更高。是一个消息处理队列库，可在多个线程、内核和主机盒之间弹性伸缩。ZMQ 的明确目标是“成为标准网络协议栈的一部分，之后进入 Linux 内核”。现在还未看到它们的成功。但是，它无疑是极具前景的、并且是人们更加需要的“传统”BSD 套接字之上的一层封装。ZMQ 让编写高性能网络应用程序极为简单和有趣。\nzeromq 并不是类似rabbitmq消息列队，它实际上只一个消息列队组件，一个库。\nzeromq的几种模式\nRequest-Reply模式：\n客户端在请求后，服务端必须回响应Python实现：server端：\n# -*- coding=utf-8 -*-\nimport zmq\n\ncontext = zmq.Context()\nsocket = context.socket(zmq.REP)\nsocket.bind(\"tcp://*:5555\")\n\nwhile True:\n    message = socket.recv()\n    print(\"Received: %s\" % message)\n    socket.send(\"I am OK!\")\n\nclient端：\n# -*- coding=utf-8 -*-\n\nimport zmq\nimport sys\n\ncontext = zmq.Context()\nsocket = context.socket(zmq.REQ)\nsocket.connect(\"tcp://localhost:5555\")\n\nsocket.send('Are you OK?')\nresponse = socket.recv();\nprint(\"response: %s\" % response)\n输出：\n$ python app/server.py \nReceived: Are you OK?\n\n$ python app/client1.py \nresponse: I am OK!\nPublish-Subscribe模式:\n广播所有client，没有队列缓存，断开连接数据将永远丢失。client可以进行数据过滤。\nPython实现server端：\n# -*- coding=utf-8 -*-\nimport zmq\nimport time\n\ncontext = zmq.Context()\nsocket = context.socket(zmq.PUB)\nsocket.bind(\"tcp://*:5555\")\n\nwhile True:\n    print('发送消息')\n    socket.send(\"消息群发\")\n    time.sleep(1)    \nclient端1：\n# -*- coding=utf-8 -*-\n\nimport zmq\nimport sys\n\ncontext = zmq.Context()\nsocket = context.socket(zmq.SUB)\nsocket.connect(\"tcp://localhost:5555\")\nsocket.setsockopt(zmq.SUBSCRIBE,'')  # 消息过滤\nwhile True:\n    response = socket.recv();\n    print(\"response: %s\" % response)\nclient端2：\n# -*- coding=utf-8 -*-\n\nimport zmq\nimport sys\n\ncontext = zmq.Context()\nsocket = context.socket(zmq.SUB)\nsocket.connect(\"tcp://localhost:5555\")\nsocket.setsockopt(zmq.SUBSCRIBE,'') \nwhile True:\n    response = socket.recv();\n    print(\"response: %s\" % response)\n输出：\n$ python app/server.py \n发送消息\n发送消息\n发送消息\n\n$ python app/client2.py \nresponse: 消息群发\nresponse: 消息群发\nresponse: 消息群发\n\n$ python app/client1.py \nresponse: 消息群发\nresponse: 消息群发\nresponse: 消息群发\nParallel Pipeline模式：\n由三部分组成，push进行数据推送，work进行数据缓存，pull进行数据竞争获取处理。区别于Publish-Subscribe存在一个数据缓存和处理负载。\n当连接被断开，数据不会丢失，重连后数据继续发送到对端。\nPython实现\nserver端：\n# -*- coding=utf-8 -*-\nimport zmq\nimport time\n\ncontext = zmq.Context()\nsocket = context.socket(zmq.PUSH)\nsocket.bind(\"tcp://*:5557\")\n\nwhile True:\n    socket.send(\"测试消息\")\n    print \"已发送\"    \n    time.sleep(1)    \nwork端：\n# -*- coding=utf-8 -*-\n\nimport zmq\n\ncontext = zmq.Context()\n\nrecive = context.socket(zmq.PULL)\nrecive.connect('tcp://127.0.0.1:5557')\n\nsender = context.socket(zmq.PUSH)\nsender.connect('tcp://127.0.0.1:5558')\n\nwhile True:\n    data = recive.recv()\n    print \"正在转发...\"\n    sender.send(data)\nclient端：\n# -*- coding=utf-8 -*-\n\nimport zmq\nimport sys\n\ncontext = zmq.Context()\nsocket = context.socket(zmq.PULL)\nsocket.bind(\"tcp://*:5558\")\n\nwhile True:\n    response = socket.recv();\n    print(\"response: %s\" % response)\n输出结果：\n$ python app/server.py \n已发送\n已发送\n已发送\n\n$ python app/work.py \n正在转发...\n正在转发...\n正在转发...\n\n$ python app/client1.py\nresponse: 测试消息\nresponse: 测试消息\nresponse: 测试消息\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "2"}