{"title": "5. Python3源码—字符串（str）对象 - 个人文章 ", "index": "源码,python", "content": "5.1. 字符串对象\n字符串对象是“变长对象”。\n5.1.1. Python中的创建\nPython中字符串（strs）对象最重要的创建方法为PyUnicode_DecodeUTF8Stateful，如下Python语句最终会调用到PyUnicode_DecodeUTF8Stateful：\na = 'hello\nb = str('world')\n5.1.2. PyUnicode_DecodeUTF8Stateful的C调用栈\n词法解析，最终调到PyUnicode_DecodeUTF8Stateful，调用顺序如下：\n// ast.c\nast_for_expr\n=>ast_for_power\n=>ast_for_atom_expr\n=>ast_for_atom (case STRING)\n=>parsestrplus\n=>parsestr\n\n// unicodeobject.c\n=> PyUnicode_DecodeUTF8Stateful\n5.1.3. PyUnicode_DecodeUTF8Stateful源码\n// unicodeobject.c\nPyObject *\nPyUnicode_DecodeUTF8Stateful(const char *s,\n                             Py_ssize_t size,\n                             const char *errors,\n                             Py_ssize_t *consumed)\n{\n    _PyUnicodeWriter writer;\n    const char *starts = s;\n    const char *end = s + size;\n\n    Py_ssize_t startinpos;\n    Py_ssize_t endinpos;\n    const char *errmsg = \"\";\n    PyObject *error_handler_obj = NULL;\n    PyObject *exc = NULL;\n    _Py_error_handler error_handler = _Py_ERROR_UNKNOWN;\n\n    if (size == 0) {\n        if (consumed)\n            *consumed = 0;\n        _Py_RETURN_UNICODE_EMPTY();\n    }\n\n    /* ASCII is equivalent to the first 128 ordinals in Unicode. */\n    if (size == 1 && (unsigned char)s[0] < 128) {\n        if (consumed)\n            *consumed = 1;\n        return get_latin1_char((unsigned char)s[0]);\n    }\n\n    _PyUnicodeWriter_Init(&writer);\n    writer.min_length = size;\n    if (_PyUnicodeWriter_Prepare(&writer, writer.min_length, 127) == -1)\n        goto onError;\n\n    writer.pos = ascii_decode(s, end, writer.data);\n    s += writer.pos;\n    while (s < end) {\n        // ascii解码后的size小于传入的size\n    }\n\nEnd:\n    if (consumed)\n        *consumed = s - starts;\n\n    Py_XDECREF(error_handler_obj);\n    Py_XDECREF(exc);\n    return _PyUnicodeWriter_Finish(&writer);\n\nonError:\n    Py_XDECREF(error_handler_obj);\n    Py_XDECREF(exc);\n    _PyUnicodeWriter_Dealloc(&writer);\n    return NULL;\n}\n可以看到：\n空串缓存：空串（unicode_empty）为同一个地址，第二次需要空串时，只是将计数加1，在_PyUnicodeWriter_Finish中实现空串缓存。\n// unicodeobject.c\nstatic PyObject *unicode_empty = NULL;\n\n#define _Py_INCREF_UNICODE_EMPTY()                      \\\n    do {                                                \\\n        if (unicode_empty != NULL)                      \\\n            Py_INCREF(unicode_empty);                   \\\n        else {                                          \\\n            unicode_empty = PyUnicode_New(0, 0);        \\\n            if (unicode_empty != NULL) {                \\\n                Py_INCREF(unicode_empty);               \\\n                assert(_PyUnicode_CheckConsistency(unicode_empty, 1)); \\\n            }                                           \\\n        }                                               \\\n    } while (0)\n\n#define _Py_RETURN_UNICODE_EMPTY()                      \\\n    do {                                                \\\n        _Py_INCREF_UNICODE_EMPTY();                     \\\n        return unicode_empty;                           \\\n    } while (0)\n\n// PyUnicode_DecodeUTF8Stateful->\n// _PyUnicodeWriter_Finish->\n// unicode_result_ready\nstatic PyObject*\nunicode_result_ready(PyObject *unicode)\n{\n    Py_ssize_t length;\n\n    length = PyUnicode_GET_LENGTH(unicode);\n    if (length == 0) {\n        if (unicode != unicode_empty) {\n            Py_DECREF(unicode);\n            _Py_RETURN_UNICODE_EMPTY();\n        }\n        return unicode_empty;\n    }\n\n    if (length == 1) {\n        void *data = PyUnicode_DATA(unicode);\n        int kind = PyUnicode_KIND(unicode);\n        Py_UCS4 ch = PyUnicode_READ(kind, data, 0);\n        if (ch < 256) {\n            PyObject *latin1_char = unicode_latin1[ch];\n            if (latin1_char != NULL) {\n                if (unicode != latin1_char) {\n                    Py_INCREF(latin1_char);\n                    Py_DECREF(unicode);\n                }\n                return latin1_char;\n            }\n            else {\n                assert(_PyUnicode_CheckConsistency(unicode, 1));\n                Py_INCREF(unicode);\n                unicode_latin1[ch] = unicode;\n                return unicode;\n            }\n        }\n    }\n\n    assert(_PyUnicode_CheckConsistency(unicode, 1));\n    return unicode;\n}\n字符缓冲池：字符（unicode_latin1）为同一个地址，第二次需要该字符时，只是将计数加1，在get_latin1_char中实现字符缓存。\n// unicodeobject.c\nstatic PyObject *unicode_latin1[256] = {NULL};\n\nPyObject *\nPyUnicode_DecodeUTF8Stateful(const char *s,\n                             Py_ssize_t size,\n                             const char *errors,\n                             Py_ssize_t *consumed)\n{\n      // do sth.\n\n    /* ASCII is equivalent to the first 128 ordinals in Unicode. */\n    if (size == 1 && (unsigned char)s[0] < 128) {\n        if (consumed)\n            *consumed = 1;\n        return get_latin1_char((unsigned char)s[0]);\n    }\n\n      // do sth.\n}\n\nstatic PyObject*\nget_latin1_char(unsigned char ch)\n{\n    PyObject *unicode = unicode_latin1[ch];\n    if (!unicode) {\n        unicode = PyUnicode_New(1, ch);\n        if (!unicode)\n            return NULL;\n        PyUnicode_1BYTE_DATA(unicode)[0] = ch;\n        assert(_PyUnicode_CheckConsistency(unicode, 1));\n        unicode_latin1[ch] = unicode;\n    }\n    Py_INCREF(unicode);\n    return unicode;\n}\n5.2. 常量字符串池\na = 'hello'\nb = 'hello'\na is b  #True\n由上例可以看出Python对常量字符串做了缓存。缓存的关键性实现在PyUnicode_InternInPlace方法中。\n5.2.1. PyUnicode_InternInPlace的C调用堆栈\n// compile.c\nassemble\n=>makecode\n// codeobject.c\n=>PyCode_New\n=>intern_string_constants\n// unicodeobject.c\n=>PyUnicode_InternInPlace\n5.2.2. PyUnicode_InternInPlace源码\n// unicodeobject.c\nstatic PyObject *interned = NULL;\n\nvoid\nPyUnicode_InternInPlace(PyObject **p)\n{\n    PyObject *s = *p;\n    PyObject *t;\n#ifdef Py_DEBUG\n    assert(s != NULL);\n    assert(_PyUnicode_CHECK(s));\n#else\n    if (s == NULL || !PyUnicode_Check(s))\n        return;\n#endif\n    /* If it's a subclass, we don't really know what putting\n       it in the interned dict might do. */\n    if (!PyUnicode_CheckExact(s))\n        return;\n    if (PyUnicode_CHECK_INTERNED(s))\n        return;\n    if (interned == NULL) {\n        interned = PyDict_New();\n        if (interned == NULL) {\n            PyErr_Clear(); /* Don't leave an exception */\n            return;\n        }\n    }\n    Py_ALLOW_RECURSION\n    t = PyDict_SetDefault(interned, s, s);\n    Py_END_ALLOW_RECURSION\n    if (t == NULL) {\n        PyErr_Clear();\n        return;\n    }\n    if (t != s) {\n        Py_INCREF(t);\n        Py_SETREF(*p, t);\n        return;\n    }\n    /* The two references in interned are not counted by refcnt.\n       The deallocator will take care of this */\n    Py_REFCNT(s) -= 2;\n    _PyUnicode_STATE(s).interned = SSTATE_INTERNED_MORTAL;\n}\n其中最关键的方法为PyDict_SetDefault，该方法存在于字典对象dictobject.c中。如果没有相同的key（此处为s），则返回defaultobject（此处也为s），否则如果有相同的key则返回对应的value。所以如果t与s不同，则说明字典中有相应的key，此时将t的计数加1，并且将之前常量字符串的对象指向t。\n如此一来，常量字符串的对象地址就一致了，此时s的计数会被消除，如果s的计数为0，则会被释放。值得注意的是，常量字符串的对象每次仍旧会被多分配一次内存，只是如果之前有分配过，且如果此次分配的对象计数为0，则会被释放。\n有些情况下（字符串包含非0-9a-zA-Z）不会放到字典里，这时候可以通过sys.intern进行性能优化：\nimport sys\na = '啊'\nb = '啊'\na is b    # False\n\na = sys.intern('啊')\nb = sys.intern('啊')\na is b    # True\n具体可以参考：memory - What does python sys.intern do, and when should it be used? - Stack Overflow\n5.3. 字符串对象的特性\n支持tp_as_number、tp_as_sequence、tp_as_mapping这三种操作。\n5.3.1. 数值操作\n// unicodeobject.c\n&unicode_as_number,                         /* tp_as_number */\n5.3.2. 序列操作\n// unicodeobject.c\n&unicode_as_sequence,                     /* tp_as_sequence */\n// unicodeobject.c\nstatic PySequenceMethods unicode_as_sequence = {\n    (lenfunc) unicode_length,       /* sq_length */\n    PyUnicode_Concat,           /* sq_concat */\n    (ssizeargfunc) unicode_repeat,  /* sq_repeat */\n    (ssizeargfunc) unicode_getitem,     /* sq_item */\n    0,                  /* sq_slice */\n    0,                  /* sq_ass_item */\n    0,                  /* sq_ass_slice */\n    PyUnicode_Contains,         /* sq_contains */\n};\n因为没有实现PySequenceMethods中的设置方法，所以字符串不可变。\n其中：\nunicode_length\nlen('hello')\nPyUnicode_Concat\n'hello' + 'wolrd'\n多个字符串相加效率低于join，join只分配一次内存；\nunicode_repeat\n'hello'*10\n效率要高于同个字符串相加；\n\nunicode_getitem：暂时没有找到相应Python语句；\nPyUnicode_Contains\n\n'h' in 'hello'\n5.3.3. 关联操作\n// unicodeobject.c\n&unicode_as_mapping,                        /* tp_as_mapping */\n// unicodeobject.c\nstatic PyMappingMethods unicode_as_mapping = {\n    (lenfunc)unicode_length,        /* mp_length */\n    (binaryfunc)unicode_subscript,  /* mp_subscript */\n    (objobjargproc)0,           /* mp_ass_subscript */\n};\n其中：\nunicode_subscript\ntest = 'hello world'\ntest[1]\ntest[0:5]\ntest[1]会走unicode_subscript方法的index分支，test[0:5]会走slice分支；\n5.3.4. to string\n// unicodeobject.c\nunicode_repr,                                   /* tp_repr */\n(reprfunc) unicode_str,                         /* tp_str */\n5.3.5. hash\n// unicodeobject.c\n(hashfunc) unicode_hash,                        /* tp_hash*/\n5.3.6. 比较\n// unicodeobject.c\nPyUnicode_RichCompare,                      /* tp_richcompare */\n5.3.7. 内置方法\n// unicodeobject.c\nunicode_methods,                              /* tp_methods */\n5.4 参考\nPython源码剖析\n本文作者：whj0709阅读原文本文为云栖社区原创内容，未经允许不得转载。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}