{"title": "Django Model View Template 之间的简单交互 (二) - 我瞎写，你瞎看 ", "index": "django,python", "content": "前言\n接续前文，上一篇文章主要涉及了 Django 项目的基础配置等，这篇主要涉及数据库相关的 ORM ，也就是 Django 中的 Model 的使用，MVT 三层之间的交互\n教程基本都是东拼西凑的，防止有些东西表述不准确，因为我之前写 JavaScript 比较多。但是里边注入了自己的理解，尽量讲清楚。\n基础环境\n\nPycharm 2018\nDjango 2.0.3\nPython 3.6.4\n\nmxonline start 分支\n\nDjango Model 配置\n代替使用原生的 SQL 语句操作数据库。\n原生 SQL 语句操作数据库\n# {BASE_DIR}/apps/message/models.py\nimport MySQLdb\ndef book_list(request):\n    db = MySQLdb.connect(user=\"me\", db=\"mydb\", password=\"secret\", host=\"localhost\")\n    cursor = db.cursor()\n    cursor.execute('SELECT name FORM books ORDER BY name')\n    names = [row[0] for row in cursor.fetchall()]\n    db.close()\n配置 Django Model\n具体的一些细节知识下面会进行叙述。这里只是展示一下如何配置。\n# {BASE_DIR}/apps/message/models.py\n\n# 从 Django 中引入 models\nfrom django.db import models\n\n\n# Create your models here.\nclass UserMessage(models.Model):\n    name = models.CharField(max_length=20, verbose_name=u\"用户名\")\n    email = models.EmailField(verbose_name=u\"邮箱\")\n    address = models.CharField(max_length=100, verbose_name=u\"联系地址\")\n    message = models.CharField(max_length=500, verbose_name=u\"留言信息\")\n\n    class Meta:\n        verbose_name = u\"用户留言信息\"\n        verbose_name_plural = verbose_name\nmodel 创建完成，接下来是生成数据表。\n生成数据表\n$ python manage.py makemigrations message\n$ python manage.py migrate message\n然后查看数据库是不是生成了表。\n之前有十个表，分别是:\n+----------------------------+\n| Tables_in_test_django      |\n+----------------------------+\n| auth_group                 |\n| auth_group_permissions     |\n| auth_permission            |\n| auth_user                  |\n| auth_user_groups           |\n| auth_user_user_permissions |\n| django_admin_log           |\n| django_content_type        |\n| django_migrations          |\n| django_session             |\n+----------------------------+\n10 rows in set (0.00 sec)\n\n现在：\n+----------------------------+\n| Tables_in_test_django      |\n+----------------------------+\n| auth_group                 |\n| auth_group_permissions     |\n| auth_permission            |\n| auth_user                  |\n| auth_user_groups           |\n| auth_user_user_permissions |\n| django_admin_log           |\n| django_content_type        |\n| django_migrations          |\n| django_session             |\n| message_usermessage        |\n+----------------------------+\n11 rows in set (0.00 sec)\nmysql> desc message_usermessage;\n+---------+--------------+------+-----+---------+----------------+\n| Field   | Type         | Null | Key | Default | Extra          |\n+---------+--------------+------+-----+---------+----------------+\n| id      | int(11)      | NO   | PRI | NULL    | auto_increment |\n| name    | varchar(20)  | NO   |     | NULL    |                |\n| email   | varchar(254) | NO   |     | NULL    |                |\n| address | varchar(100) | NO   |     | NULL    |                |\n| message | varchar(500) | NO   |     | NULL    |                |\n+---------+--------------+------+-----+---------+----------------+\n5 rows in set (0.04 sec)\n\n对应上面 Model 中的字段，完美~\n注意事项\nChartField 必须指定 max_length。\nORM 功能介绍\n稍候会有完整的 Model 例子。\n字段 Field\n每一个模型都可以包含有任意数量的字段，每个字段都会对应数据表中的一个字段，我们需要指定字段的属性。\nname = models.CharField(max_length=20, verbose_name=u\"用户名\")\n上述字段的名称是 name，类型是 models.CharField。对应到 MySQL 数据中是 varchar 类型。varchar 类型的字段都是需要去指定一个长度值，对应到 Django 的 ORM 模型上就是 max_length 属性。\n字段参数\n下面列举一下目前笔者在开发中用到的一些字段：\n\nmax_length：指定字段的长度值，接受一个数字，CharField 必须指定最大长度， TextField 不需要。\nverbose_name：字段标签的可读名称，接受一个字符串。如果不指定，Django 会从字段名称去推断默认的详细名称，建议每一个字段都进行指定。\ndefault：字段默认值。\nnull：是否可以为 null，接受 True 或者 False。\nblank： 是否可以为空，同样接受 True 或者 False。\nprimary_key：如果设置为 Ture，则该字段置为模型主键，如果模型中没有指定主键，则 Django 会自动为模型添加一个主键，默认为 id。\nhelp_text：为 HTML 表单文本提供单文本标签。\nchoices：一组字段选项，提供这一项的时候，默认对应的表单不见是选择字段的盒子，而不是标准文本字段。\n\n字段类型\n\nCharField：用来定义短到中等长度的字段字符串，必须指定 max_length 属性。\nTextField：用于大型的任意长度字符串，不强制要求指定 max_length 属性，指定的 max_length 仅仅当该字段以表单显示才会使用，不会再数据库级别进行强制执行。\nIntegerField：用于存储整形数据，在用于表单中验证输入的值需要时整数。\nFloatField：用于存储浮点型数据\nDateField 和 DateTimeField：用于存储／表示日期和日期／时间信息（分别是Python.datetime.date和datetime.datetime对象。这些字段可以另外表明（互斥）参数auto_now=Ture （在每次保存模型时将该字段设置为当前日期），auto_now_add（仅设置模型首次创建时的日期）和default（设置默认日期，可以被用户覆盖）。一般笔者选择的默认日期是 datetime.now。\nEmailField：用来存储和验证电子邮件地址。\nFileField：用于上传文件，需要提供 upload_to 指定上传到的地方。\nImageField：和上传文件表现基本相似，会额外进行是否为图像的验证。\nAutoField：是一种 IntegerField 自增的特殊类型，如果模型没有指定主键的话，此类型的主键将自动添加到模型中。\nForeignKey：外键，用于指定与另一个数据库模型的一对多关系。关系 “一” 侧是包含密钥的模型。和 flask 指定外键的方式不同。\nManyToManyField：用于指定多对多关系，例如，一本书可以有几种类型，每种类型可以包含几本书）。在我们的图书馆应用程序中，我们将非常类似地使用它们ForeignKeys，但是可以用更复杂的方式来描述组之间的关系。这些具有参数on_delete来定义关联记录被删除时会发生什么（例如，值models.SET_NULL将简单地设置为值NULL）。笔者用的不是很多。\n\n元数据\n通过声明 class Meta 来声明模型级别的元数据\nclass UserMessage(models.Model):\n    # Config Field\n        \n    class Meta:\n        ordering = [\"id\"]\n       verbose_name = u\"用户留言信息\"\n       verbose_name_plural = verbose_name\n\n这里最有用的功能是可以指定模型返回数据时候的默认的顺序，更多的文档可以查看这里\n方法\n一个模型也可以有方法，最基本的使用就是定义一个标准的 Python 类方法： __str__：\nclass UserMessage(models.Model):\n    # Config Field\n    \n    # Config Meta\n    \n    def __str__(self):\n       return self.message    \n这样为每个对象返回一个人类可读的字符串。当然还有其他高级的使用，日后再说\n完整的 model\n# {BASE_DIR/apps/message/models.py}\n\nfrom django.db import models\n\n\n# Create your models here.\nclass UserMessage(models.Model):\n    name = models.CharField(max_length=20, verbose_name=u\"用户名\")\n    email = models.EmailField(verbose_name=u\"邮箱\")\n    address = models.CharField(max_length=100, verbose_name=u\"联系地址\")\n    message = models.CharField(max_length=500, verbose_name=u\"留言信息\")\n\n    class Meta:\n        ordering = [\"id\"]\n        verbose_name = u\"用户留言信息\"\n        verbose_name_plural = verbose_name\n\n    def __str__(self):\n        return self.message\n\n使用 Django ORM\n之前已经定义好了数据模型的字段（Field）、元数据（Meta）、方法（Method）等。现在要做的是把页面上提交过来的数据通过 ORM 来存放到数据库中，通过 ORM 来进行数据的 CURD 操作。\n创建数据\n在 templates 中已经创建了 message_form.html 模板文件，现在进行修改，修改 form 的 action 目标地址：\n<form action=\"/\" method=\"post\" class=\"smart-green\">\n这里根据自己配置的 Url 来自行决定，由于笔者配置的是 /，所以这里就配置成这个样子。\n这里指定的是使用 form 的原生事件 post 事件进行提交，但是在实际的开发中，为了实现更精确的控制，我们常常不会使用原生事件，而更倾向于使用 ajax 进行提交，当然这里的重点不是前端的逻辑，重点在于 Django 后端逻辑的处理，顾不赘述。\n接下来的任务就是：拿到 POST 发来的数据，然后存入数据库中。\n存储数据\n之前使用 Django 的 ORM 进行了数据库中数据表的配置，现在使用 Django 的 ORM 将数据保存到数据库中。\n在 Django 中，我们使用不是传统的 MVC 架构，我们使用的是一种叫 MVT 的方式。不同的 Template（模板） 呈现不同的 View。我们将在 View（请求视层）中获取用户提交的数据，以及将从 Model（数据层） 中获得的数据传递给 Template(模板层)。\nMVT 的概念本身就来自于 Django 框架，下面进行代码的展示：\n# {BASE_DIR/apps/message/views.py}\nfrom django.shortcuts import render  # 引入 render 方法\nfrom .models import UserMessage      # 引入之前配置好的 Model\n\n\n# Create your views here.\n\ndef get_form(request):\n    if request.method == 'POST':\n        name = request.POST.get('name', '')\n        message = request.POST.get('name', '')\n        address = request.POST.get('address', '')\n        email = request.POST.get('email', '')\n        user_message = UserMessage()\n        user_message.name = name\n        user_message.message = message\n        user_message.address = address\n        user_message.email = email\n        user_message.save()\n    return render(request, 'message_form.html')\n\n通过 POST 方法提交的数据会存储到 request 对象的 POST 属性下边，通过 Django 提供的 get 方法就可以取到对应的字段。其中 get 接收两个参数，分别是字段的名称和默认值。\n在取到 Template 提交过来的每一个字段之后，就可以使用 ORM 提供的方法将其存入数据库中。\n实例化引入的 Model，然后将之前定义的字段进行赋值，然后就可以调用实例的 save() 方法将数据存入数据库。\n然后就可以通过 Navicat 或者终端等方式查看数据是否保存到了数据库中。\n读取数据\n之前已经实现了数据的存储，这部分将实现数据的读取功能。\n# {BASE_DIR/apps/message/views.py}\nfrom django.shortcuts import render\nfrom .models import UserMessage\n\n\n# Create your views here.\n\ndef get_form(request):\n    message = None\n    all_message = UserMessage.objects.filter(name='test')\n    if all_message:\n        message = all_message[0]\n    return render(request, 'message_form.html', {'my_message': message})\n这里会涉及到 Django 的 QuerySets（查询集）相关知识，这里捡着用的着的部分看一下。\n首先先声明 message，值为 None，用于存储取到的数据。\n从本质上讲，QuerySets 是给定对象模型（这里是 UserModel）的对象列表（list），允许我们从数据库中读取数据，选择以及排序。通过这种方式操作的话，就可以避免直接操作数据库。从而抹平不同数据库操作的差异，这部分由 Django 帮我们来完成。\n上面的代码中有这样的一句：\nUserMessage.objects.filter(name='test')\n作用是从数据库中查找 name 值为 test 的所有条目，返回的是一个 <QuerySet> 列表，并赋值给 all_message。同时我们也可以发现，QuerySet 可以链式调用。类似于 JavaScript 中的 Promise。\n然后如果 all_message 不为空的话，取出列表第一项，然后传递给 my_message 模板。\n关于 QuerySet 的详细知识，可以查看 Django 的官方文档的这一部分\n渲染到模板\n在上面步骤中，我们将符合预设条件的数据从数据库中取出来，传递到模板中，这里的目标是将数据正确的显示与渲染。部分语法类似于 ejs 模板的语法，但同时 Django 又在模板中内置了很多常用的函数。但是 Django 不像 Java 那样，允许在模板中写一些 Java 代码，Django 的 Template 中不允许将 Python 代码混进来。\n由于模板代码过长，这里只放一些关键部分的代码，完整的代码可以查看文章对应的代码仓库。\n<form action=\"{% url 'go_form' %}\" method=\"post\" class=\"smart-green\">\n    <label>\n        <span>姓名 :</span>\n        <input id=\"name\" type=\"text\" name=\"name\" value=\"{% if my_message.name == 'test' %}test{% endif %}\" class=\"error\"\n               placeholder=\"请输入您的姓名\"/>\n    </label>\n    <label>\n        <span>留言 :</span>\n        <textarea id=\"message\" name=\"message\" placeholder=\"请输入你的建议\">{{ my_message.message }}</textarea>\n    </label>\n    {% csrf_token %}\n</form>\n\n在上一篇文章中，提到过，path 接收 name 参数。在 template 中可以通过 name 来取到对应的 url，方法如下：\naction=\"{% url 'go_form' %}\"\n这样做提供了另一种获取 url 的方式，当我们因为某种原因去修改了 url 地址之后，通过 name 还能找到它。\n在 textarea 中，有这样一段代码：\n{{ my_message.message }}\n作用是取到传入的 my_message 对象的 message 属性取出来并显示，由于 html 基本属于前端部分了，所以用前端的方式进行描述。\n双花括号（八字胡）语法： {{...}} 在任何模板语言中都很常见，作用是将数据渲染到双括号内部。\n上面还有一部分代码是这样子的：\n{% if my_message.name == 'test' %}test{% endif %}\"\n意思很好懂的，是吧。\n具体的 Django 中模板的语法可以查看官方文档。\n后记\n这里只是简单的介绍了一下 Django 中 Model 层、View 层、以及 Template 层之间交互的部分知识，很简略，不详细。在每部分的后边都附加了详细的官方文档地址。如果以后有时间了可以对每部分进行详细的阐述。\n参考资料\n\nPython升级3.6 强力Django+杀手级Xadmin打造在线教育平台\nMDN 的 Django教程 ———— 设计LocalLibrary模型\nDjango 官方文档 Model 部分\nDjango Girls 教程\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}