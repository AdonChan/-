{"title": "Django中的文件上传(利用class-based view) - 愚钝的我 ", "index": "uploadfile,python,django", "content": "背景介绍\n在Django的官网上有专门介绍如何处理文件上传的文档，其中说到了如何利用model来处理文件上传的场景。但是，在Django中最快速的开发方式是利用class-based views来进行开发。所以，我自己整理了一下如何利用class-based views来处理文件上传的场景，特此记录。\n\nmodel\n既然是数据驱动的web，自然先要有model。\nfrom django.db import models\nfrom django.contrib.auth.models import User\nfrom django.conf import settings\nimport os\n\n_roles_path = os.path.join(_base_path, 'roles')\n\n\ndef var_dir(instance, filename):\n    return os.path.join(_roles_path, instance.name, 'vars', filename)\n\n\ndef task_dir(instance, filename):\n    return os.path.join(_roles_path, instance.name, 'tasks', filename)\n\n\nclass Roles(models.Model):\n    id = models.AutoField(primary_key=True)\n    name = models.CharField(max_length=50)\n    creator = models.ForeignKey(User)\n    createDatetime = models.DateTimeField(auto_now_add=True)\n    directory = models.FilePathField(path=_roles_path, match='*.yml', recursive=True, max_length=200)\n    tasks = models.FileField(upload_to=task_dir, blank=False)\n    vars = models.FileField(upload_to=var_dir)\n\n    def __unicode__(self):\n        return u'%s' % self.name\n上面用到了动态的upload_to，对应每个FileField都提供不同的上传路径。因为upload_to可以接受一个callable的对象，所以我尝试过把lambda赋值给upload_to，但是在测试中发现，给upload_to赋值为lambda表达式是会报错的ValueError: Cannot serialize function: lambda。应该可以尝试利用闭包的方式来给upload_to赋值，以解决多种动态路径的需求。\n经过后续的测试发现，闭包也是不支持的\ndef _roles_subdir(roles_path, subdir):\n    def wrapper(instance, filename):\n        return os.path.join(roles_path, instance.name, subdir, filename)\n    return wrapper\nPlease note that due to Python 2 limitations, you cannot serialize unbound method functions (e.g. a method declaredand used in the same class body). Please move the function into the main module body to use migrations.For more information, seehttps://docs.djangoproject.com/en/1.7/topics/migrations/#serializing-values\nview\n本例中使用Django提供的CreateView。在实际的使用中，可以针对于自己的应用场景选择CreateView、UpdateView。\nfrom django.views.generic.edit import FormView, CreateView\nfrom django.views.decorators.csrf import csrf_exempt\nfrom django.core.urlresolvers import reverse_lazy\n\nclass UploadRolesFormView(CreateView):\n    template_name = 'app/upload_roles.html'\n    model = Roles\n    fields = ['name', 'tasks', 'vars']\n    success_url = reverse_lazy('app:index')\n\n    #临时去掉CSRF保护，千万别学我！\n    @csrf_exempt\n    def dispatch(self, request, *args, **kwargs):\n        return super(UploadRolesFormView, self).dispatch(request, *args, **kwargs)\n\n    #override\n    def form_valid(self, form):\n        #在form中加入user对象存入model\n        form.instance.creator = self.request.user\n        return super(UploadRolesFormView, self).form_valid(form)\ntemplate\n<html>\n    <head>\n        <title>upload</title>\n        <meta http-equiv=\"description\" content=\"this is my page\">\n        <meta http-equiv=\"content-type\" content=\"text/html; charset=GB18030\">\n    </head>\n\n    <body>\n        <form action=\"{% url 'app:rolesUpload' %}\" method=\"post\" enctype=\"multipart/form-data\">\n            <input type=\"text\" name=\"name\" />\n            <input type=\"file\" name=\"tasks\" />\n            <input type=\"file\" name=\"vars\" />\n            <input type=\"submit\" value=\"上传\" />\n        </form>\n    </body>\n</html>\nurl\n在app的urls.py中加入一条对应的url规则：\nurl(r'^upload/$', views.UploadRolesFormView.as_view(), name='rolesUpload'),\n\n这样，就可以利用Django最方便的class-based views开处理文件上传的场景了。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "9"}