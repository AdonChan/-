{"title": "入门Python数据分析最好的实战项目（二） - Python数据科学 ", "index": "机器学习,数据挖掘,python,数据分析", "content": "作者：xiaoyu\n微信公众号：Python数据科学\n知乎：python数据分析师\n\n上一篇和大家分享了一个入门数据分析的一个小项目 北京二手房房价分析，链接如下：\n入门Python数据分析最好的实战项目（一）\n文章在sf发布之后看到有不少感兴趣的朋友给我点了赞，感谢大家的支持了。\n\n本篇将继续上一篇数据分析之后进行数据挖掘建模预测，这两部分构成了一个简单的完整项目。结合两篇文章通过数据分析和挖掘的方法可以达到二手房屋价格预测的效果。\n下面从特征工程开始讲述。\n特征工程\n特征工程包括的内容很多，有特征清洗，预处理，监控等，而预处理根据单一特征或多特征又分很多种方法，如归一化，降维，特征选择，特征筛选等等。这么多的方法，为的是什么呢？其目的是让这些特征更友好的作为模型的输入，处理数据的好坏会严重的影响模型性能，而好的特征工程有的时候甚至比建模调参更重要。\n下面是继上一次分析之后对数据进行的特征工程，博主将一个一个帮大家解读。\n\"\"\"\n特征工程\n\"\"\"\n# 移除结构类型异常值和房屋大小异常值\ndf = df[(df['Layout']!='叠拼别墅')&(df['Size']<1000)]\n\n# 去掉错误数据“南北”，因为爬虫过程中一些信息位置为空，导致“Direction”的特征出现在这里，需要清除或替换\ndf['Renovation'] = df.loc[(df['Renovation'] != '南北'), 'Renovation']\n\n# 由于存在个别类型错误，如简装和精装，特征值错位，故需要移除\ndf['Elevator'] = df.loc[(df['Elevator'] == '有电梯')|(df['Elevator'] == '无电梯'), 'Elevator']\n\n# 填补Elevator缺失值\ndf.loc[(df['Floor']>6)&(df['Elevator'].isnull()), 'Elevator'] = '有电梯'\ndf.loc[(df['Floor']<=6)&(df['Elevator'].isnull()), 'Elevator'] = '无电梯'\n\n# 只考虑“室”和“厅”，将其它少数“房间”和“卫”移除\ndf = df.loc[df['Layout'].str.extract('^\\d(.*?)\\d.*?') == '室']\n\n# 提取“室”和“厅”创建新特征\ndf['Layout_room_num'] = df['Layout'].str.extract('(^\\d).*', expand=False).astype('int64')\ndf['Layout_hall_num'] = df['Layout'].str.extract('^\\d.*?(\\d).*', expand=False).astype('int64')\n\n# 按中位数对“Year”特征进行分箱\ndf['Year'] = pd.qcut(df['Year'],8).astype('object')\n\n# 对“Direction”特征\nd_list_one = ['东','西','南','北']\nd_list_two = ['东西','东南','东北','西南','西北','南北']\nd_list_three = ['东西南','东西北','东南北','西南北']\nd_list_four = ['东西南北']    \ndf['Direction'] = df['Direction'].apply(direct_func)\ndf = df.loc[(df['Direction']!='no')&(df['Direction']!='nan')]\n\n# 根据已有特征创建新特征\ndf['Layout_total_num'] = df['Layout_room_num'] + df['Layout_hall_num']\ndf['Size_room_ratio'] = df['Size']/df['Layout_total_num']\n\n# 删除无用特征\ndf = df.drop(['Layout','PerPrice','Garden'],axis=1)\n\n# 对于object特征进行onehot编码\ndf,df_cat = one_hot_encoder(df)\n由于一些清洗处理在上一篇文章已经提到，博主从17行代码开始。\nLayout\n先来看看没经处理的Layout特征值是什么样的。\ndf['Layout'].value_counts()\n\n大家也都看到了，特征值并不是像想象中的那么理想。有两种格式的数据，一种是\"xx室xx厅\"，另一种是\"xx房间xx卫\"，但是绝大多数都是xx室xx厅的数据。而对于像\"11房间3卫\"或者\"5房间0卫\"这些的Layout明显不是民住的二手房（不在我们的考虑范围之内），因此最后决定将所有\"xx房间xx卫\"格式的数据都移除掉，只保留\"xx室xx厅\"的数据。\nLayout特征的处理如下：\n第2行的意思是只保留\"xx室xx厅\"数据，但是保留这种格式的数据也是不能作为模型的输入的，我们不如干脆将\"室\"和\"厅\"都提取出来，单独作为两个新特征（如第5和6行），这样效果可能更好。\n具体的用法就是使用 str.extract() 方法，里面写的是正则表达式。\n# 只考虑“室”和“厅”，将其它少数“房间”和“卫”移除\ndf = df.loc[df['Layout'].str.extract('^\\d(.*?)\\d.*?') == '室']\n\n# 提取“室”和“厅”创建新特征\ndf['Layout_room_num'] = df['Layout'].str.extract('(^\\d).*', expand=False).astype('int64')\ndf['Layout_hall_num'] = df['Layout'].str.extract('^\\d.*?(\\d).*', expand=False).astype('int64')\nYear\n我们还有一个 Year 特征，为建房的年限时间。年限种类很多，分布在1950和2018之间，如果每个不同的 Year 值都作为特征值，我们并不能找出 Year 对 Price 有什么影响，因为年限划分的太细了。因此，我们只有将连续数值型特征 Year 离散化，做分箱处理。\n如何分箱还要看实际业务需求，博主为了方便并没有手动分箱，而使用了pandas的 qcut 采用中位数进行分割，分割数为8等份。\n# 按中位数对“Year”特征进行分箱\ndf['Year'] = pd.qcut(df['Year'],8).astype('object')\n这是将 Year 进行分箱的结果：\nDirection\n这个特征没处理之前更乱，原以为是爬虫的问题，但是亲自到链家看过，朝向确实是这样的。\n\n如上所见，像\"西南西北北\"或者\"东东南南\"这样的朝向是不符合常识的（反正我是理解不了）。因此，我们需要将这些凌乱的数据进行处理，具体实现方式是博主自己写了一个函数 direct_func，主要思想就是将各种重复但顺序不一样的特征值合并，比如\"西南北\"和\"南西北\"，并将不合理的一些值移除，如\"西南西北北\"等。\n然后通过 apply() 方法将 Direction 数据格式转换，代码如下：\n# 对“Direction”特征\nd_list_one = ['东','西','南','北']\nd_list_two = ['东西','东南','东北','西南','西北','南北']\nd_list_three = ['东西南','东西北','东南北','西南北']\nd_list_four = ['东西南北']    \ndf['Direction'] = df['Direction'].apply(direct_func)\ndf = df.loc[(df['Direction']!='no')&(df['Direction']!='nan')]\n处理完结果如下，所有的内容相同而顺序不同的朝向都合并了，异常朝向也被移除了。\n创建新特征\n有时候仅靠已有的一些特征是不够的，需要根据对业务的理解，定义一些的新特征，然后尝试这些新特征对模型的影响，在实战中会经常使用这种方法。\n这里尝试将\"室\"与\"厅\"的数量相加作为一个总数量特征，然后将房屋大小Size与总数量的比值作为一个新特征，可理解为 \"每个房间的平均面积大小\"。当然，新特征不是固定的，可根据自己的理解来灵活的定义。\n# 根据已有特征创建新特征\ndf['Layout_total_num'] = df['Layout_room_num'] + df['Layout_hall_num']\ndf['Size_room_ratio'] = df['Size']/df['Layout_total_num']\n\n# 删除无用特征\ndf = df.drop(['Layout','PerPrice','Garden'],axis=1)\n最后删除旧的特征 Layout，PerPrice，Garden。\nOne-hot coding\n这部分是 One-hot 独热编码，因为像 Region，Year（离散分箱后），Direction，Renovation，Elevator等特征都是定类的非数值型类型，而作为模型的输入我们需要将这些非数值量化。\n在没有一定顺序（定序类型）的情况下，使用独热编码处理定类数据是非常常用的做法，在pandas中非常简单，就是使用 get_dummies() 方法，而对于像Size这样的定比数据则不使用独热，博主这里用了一个自己封装的函数实现了定类数据的自动量化处理。\n对于定类，定序，定距，定比这四个非常重要的数据类型相信加入知识星球的伙伴都非常熟悉了，想要了解的同学可以扫描最后二维码查看。\n# 对于object特征进行onehot编码\ndf,df_cat = one_hot_encoder(df)\n以上的特征工程就完成了。\n特征相关性\n下面使用 seaborn 的 heatmap 方法对特征相关性进行可视化。\n# data_corr \ncolormap = plt.cm.RdBu\nplt.figure(figsize=(20,20))\n# plt.title('Pearson Correlation of Features', y=1.05, size=15)\nsns.heatmap(df.corr(),linewidths=0.1,vmax=1.0, square=True, cmap=colormap, linecolor='white', annot=True)\n\n颜色偏红或者偏蓝都说明相关系数较大，即两个特征对于目标变量的影响程度相似，即存在严重的重复信息，会造成过拟合现象。因此，通过特征相关性分析，我们可以找出哪些特征有严重的重叠信息，然后择优选择。\n数据建模预测\n为了方便理解，博主在建模上做了一些精简，模型策略方法如下：\n\n使用Cart决策树的回归模型对二手房房价进行分析预测\n使用交叉验证方法充分利用数据集进行训练，避免数据划分不均匀的影响。\n使用GridSearchCV方法优化模型参数\n使用R2评分方法对模型预测评分\n\n上面的建模方法比较简单，旨在让大家了解建模分析的过程。随着逐渐的深入了解，博主会介绍更多实战内容。\n数据划分\n# 转换训练测试集格式为数组\nfeatures = np.array(features)\nprices = np.array(prices)\n\n# 导入sklearn进行训练测试集划分\nfrom sklearn.model_selection import train_test_split\nfeatures_train, features_test, prices_train, prices_test = train_test_split(features, prices, test_size=0.2, random_state=0)\n将以上数据划分为训练集和测试集，训练集用于建立模型，测试集用于测试模型预测准确率。使用sklearn的 model_selection 实现以上划分功能。\n建立模型\nfrom sklearn.model_selection import KFold\nfrom sklearn.tree import DecisionTreeRegressor\nfrom sklearn.metrics import make_scorer\nfrom sklearn.model_selection import GridSearchCV\n\n# 利用GridSearchCV计算最优解\ndef fit_model(X, y):\n    \"\"\" 基于输入数据 [X,y]，利于网格搜索找到最优的决策树模型\"\"\"\n    \n    cross_validator = KFold(10, shuffle=True)\n    regressor = DecisionTreeRegressor()\n    \n    params = {'max_depth':[1,2,3,4,5,6,7,8,9,10]}\n    scoring_fnc = make_scorer(performance_metric)\n    grid = GridSearchCV(estimator = regressor, param_grid = params, scoring = scoring_fnc, cv = cross_validator)\n\n    # 基于输入数据 [X,y]，进行网格搜索\n    grid = grid.fit(X, y)\n#     print pd.DataFrame(grid.cv_results_)\n    return grid.best_estimator_\n\n# 计算R2分数\ndef performance_metric(y_true, y_predict):\n    \"\"\"计算并返回预测值相比于预测值的分数\"\"\"\n    from sklearn.metrics import r2_score\n    score = r2_score(y_true, y_predict)\n\n    return score\n使用了 KFold 方法减缓过拟合，GridSearchCV 方法进行最优参数自动搜查，最后使用R2评分来给模型打分。\n调参优化模型\nimport visuals as vs\n\n# 分析模型\nvs.ModelLearning(features_train, prices_train)\nvs.ModelComplexity(features_train, prices_train)\n\noptimal_reg1 = fit_model(features_train, prices_train)\n\n# 输出最优模型的 'max_depth' 参数\nprint(\"最理想模型的参数 'max_depth' 是 {} 。\".format(optimal_reg1.get_params()['max_depth']))\n\npredicted_value = optimal_reg1.predict(features_test)\nr2 = performance_metric(prices_test, predicted_value)\n\nprint(\"最优模型在测试数据上 R^2 分数 {:,.2f}。\".format(r2))\n由于决策树容易过拟合的问题，我们这里采取观察学习曲线的方法查看决策树深度，并判断模型是否出现了过拟合现象。以下是观察到的学习曲线图形：\n通过观察，最理想模型的参数\"max_depth\"是10，此种情况下达到了偏差与方差的最优平衡，最后模型在测试数据上的R2分数，也即二手房房价预测的准确率为：0.81。\n总结\n以上一个完整的从数据分析到挖掘的项目就结束了，对于项目而言比较简单，目的是让大家了解整个分析的过程。可提升改进的地方非常多，可以有更好更健壮的方案代替，一些改进思考如下：\n\n获取更多有价值的特征信息，比如学区，附近地铁，购物中心等\n完善特征工程，如进行有效的特征选择\n使用更优秀的模型算法建模或者使用模型融合\n\n完整项目代码博主分享在了知识星球中，后续博主将不断分享更多实战内容，Kaggle竞赛项目，以及互联网金融风险控制项目。\n关注微信公众号：Python数据科学，查看更多精彩内容。\n\n                ", "mainLikeNum": ["23 "], "mainBookmarkNum": "18"}