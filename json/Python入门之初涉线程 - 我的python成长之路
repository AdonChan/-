{"title": "Python入门之初涉线程 - 我的python成长之路 ", "index": "python", "content": "由于线程是操作系统直接支持的执行单元，因此，高级语言通常都内置多线程的支持，Python也不例外，并且，Python的线程是真正的Posix Thread，而不是模拟出来的线程。多任务可以由多进程完成，也可以由一个进程内的多线程完成。\nThread 是threading模块中最重要的类之一，可以使用它来创建线程。有两种方式来创建线程：一种是通过继承Thread类，重写它的run方法；另一种是创建一个threading.Thread对象，在它的初始化函数（__init__）中将可调用对象作为参数传入。看到一篇比较好的介绍线程的文章：http://python.jobbole.com/81546/\n下面是一个拷贝过来的代码，比较有意思，multi_main()函数中的print去掉之后代码效率会降低很明显。添加一个print或者换成time.sleep(0.1)，多线程的效率会迅速追上单线程，然而，是不是就仅仅止步于此了呢？不妨思考一下，那么python中的多线程又有何意义？\nfrom threading import Thread\nimport time\n#python在多线程的情况下居然比单线程整整慢了26%\ndef counter():\n    i = 0 \n    for j in range(50000000):\n        i += 1\n    return True\n\ndef main():\n    start_time = time.time()\n    for tid in range(2):\n        t = Thread(target=counter)\n        t.start()\n        \n        t.join()\n        \n    end_time = time.time()\n    print (\"total time of single is: {}\".format(end_time - start_time))\n\ndef multi_main():\n    thread_all = []\n    start_time = time.time()\n    for tid in range(2):\n        t = Thread(target=counter)\n        t.start()\n        thread_all.append(t)\n        #print('0')#去掉这行代码,代码效率将降低,也可以在此sleep 0.1s\n        \n    for i in range(2):\n        thread_all[i].join()\n    end_time = time.time()\n    print (\"total time of multi is: {}\".format(end_time -start_time))\n\nif __name__ == '__main__':\n    main()\n    multi_main()\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "2"}