{"title": "python_bomb----小白学装饰器 - python太阳花 ", "index": "python", "content": "什么是装饰器？\n装饰器就是用来装饰函数。\n\n想要增强原有函数的功能\n但不希望修改原有函数的定义\n在代码运行期间动态增加功能的方式\n\n函数嵌套函数\n调用方式：原函数 = 外层函数(原函数名)原函数\ndef desc(fun):\n    def add_info():\n        print('happy today')\n        fun()\n        print('westos_linux')\n    return add_info\ndef login():\n    print('login..')\n\nlogin = desc(login)\nlogin()\n\ndef add_info(fun):\n    print('happy today')\n    fun()\n    print('westos_linux')\ndef login():\n    print('login..')\ndef logout():\n    print('logout..')\ndef save():\n    print('save..')\ndef trans():\n    print('trans')\n\nadd_info(login)\nadd_info(logout)\nlogin = add_info(login)\n\n装饰器使用\n定义的装饰器实质是返回函数的高阶函数@timeIt（装饰器名） 这里是 python 提供的一个语法糖1.解决问题：函数执行前后添加功能-->会改变函数调用命令2.不改变原有函数的调用方式-->函数里面嵌套函数，并且不改变返回嵌套函数的调用方式-->login = desc(login)\n计时装饰器\n需求：获取每个函数的执行时间\n#1.函数执行之前计算时间\n#2.函数执行之后计算时间\n\nimport random\nimport string\nimport time\nfrom functools import reduce\n\nli = [random.choice(string.ascii_letters +string.digits) for i in range(10) ]\n\ndef timeit(fun):\n    def wrapper(*args,**kwargs):\n        t1=time.time()\n        res = fun(*args,**kwargs)\n        t2 = time.time()\n        grot = t2-t1\n        print(\"所需时间：%.6f\" %grot)\n\n        return res\n    return wrapper\n\n@timeit\ndef myjoin(*args,**kwargs):\n    s = ','.join(*args,**kwargs)\n    print(s)\n\nmyjoin(li)\n\n\n\n日志装饰器\n#创建装饰器\n#1.创建add_log装饰器，被装饰函数打印日志信息\n#2.日志格式为：[字符串时间] 函数名：XXX 运行时间：XXXX 运行返回值结果：XXXX\nimport time\nimport functools\nimport math\ndef add_log(fun):\n    @functools.wraps(fun)\n    def wrapper(*args,**kwargs):\n        run_time =time.ctime()\n        start_time  = time.time()\n        res = fun(*args,**kwargs)\n        end_time = time.time()\n        na = fun.__name__\n        print('[字符串时间:%s] 函数名：%s 运行时间：%.6f 运行返回值结果：%s' %(run_time,na,end_time-start_time,res))\n        return res\n    return wrapper\n\n@add_log\ndef mymult(x,y):\n    \"\"\"这是一个求x的y次方的函数\"\"\"\n    return math.pow(x,y)\nmymult(2,3)\n\n登陆验证\n#用户登录验证的装饰器is_login\n#   如果用户登陆成功，则执行被装饰的函数\n#   如果用户登陆不成功，则执行登陆函数\n\n\nusers =['root','sheen']\ndef is_login(fun):\n    def wrapper(*args,**kwargs):\n        if kwargs.get('name') in users:\n            res  = fun(*args,**kwargs)\n        else:\n            res = login()\n        return res\n    return wrapper\n\n@is_login\ndef writeblog(name):\n    return \"wirte,now..\"\n\ndef login():\n    return 'please login..'\n\nprint(writeblog(name='star'))\n\n\n类型判断(无参)\n#1.基础版（无参数）\n#编写装饰器required_ints\n#   确保函数收到的每一个参数都是整数\n#   如果参数不是整形数，打印TypeError\nimport functools\n\ndef required_ints(fun):\n    @functools.wraps(fun)\n    def wrapper(*args,**kwargs):\n        for i in args:\n            if not isinstance(i,int):\n                print('TypeError')\n                break\n        else:\n            res = fun(*args,**kwargs)\n            return res\n\n    return wrapper\n\n@required_ints\ndef myadd(a,b):\n    return a+b\n\nprint(myadd(1,2.0))\n\n含参类型判断\n# #带参数的装饰器\n# \"\"\"\n# 装饰器为required_types\n#     当装饰器为@required_types(int,float),确保函数接收到的每一个参数都是int/float类型\n#     当装饰器为@required_types(list),确保函数接收到的每一个参数都是list类型\n#     当装饰器为@required_types(str,int)，确保函数接收到的每一个参数都是str/int类型\n#     如果参数不满足条件，打印TypeError,参数必须是XXXXX类型\nimport functools\ndef required_types(*kinds): #kinds元组\n    def required_ints(fun):\n        @functools.wraps(fun)\n        def wrapper(*args,**kwargs):\n            for i in args:\n                if  not isinstance(i,kinds):\n                    print('TypeError,参数类型为',kinds)\n                    break\n            else:\n                res = fun(*args,**kwargs)\n                return res\n\n        return wrapper\n    return required_ints\n\n@required_types(int,str)\ndef my(a,b):\n    return a,b\nprint(my(1,'sdhs'))\n\n\n带有多个装饰器\ndef makebold(fun):\n    print(\"makebold\")\n    def wrapper1(*args,**kwargs):\n        print(\"bold\")\n        return fun(*args,**kwargs)\n    return wrapper1\n\ndef makei(fun):\n    print(\"makei\")\n    def wrapper(*args,**kwargs):\n        print(\"i\")\n\n        return fun(*args, **kwargs)\n    return wrapper  #wrapper=login\n\n#当有多个装饰器时，从下到上调用装饰器\n#真实wrapper内容是从上到下执行的\n@makebold   #login = makebold(login)    #login为wrapper1\n@makei      #login = makei(login)       #login为wrapper\ndef login():\n    return \"登陆\"\n\nprint(login())\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}