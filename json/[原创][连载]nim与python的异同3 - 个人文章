{"title": "[原创][连载]nim与python的异同3 - 个人文章 ", "index": "python,nim", "content": "变量(常量)绑定\n\npython无特定关键字,直接设值a = r”^s*(d{4}-d{2}-d{2})s{1,2}(.+)$” # 将一个文字列放到名为a的变量里a = 8086 # OK,a的类型由文字列(上面定义的正则表达式)变成了整数(8086)这里就带来一个在大工程里很容易带来困扰的问题,理解代码不得不受制于类型极易变的变量,要理解代码所必需的工作量极大.\n\n\nnim\n\nvar可变变量前缀.var a = re”^s*(d{4}-d{2}-d{2})s{1,2}(.+)$” # 将变量a与文字列绑定其后a的内容可变a = “change the value” #这里OK\nlet不可变变量前缀.(一旦绑定,不得变更)let b = re”^s*(d{4}-d{2}-d{2})s{1,2}(.+)$” # 将不可变变量b与文字列绑定其后改变bb = “change the value” #这里出错\n\nconst常量前缀.\nconst\n  HTTP_METHOD = r”HEAD”\n\n\n\n\n常用数据结构\n\n\npython\n\nlist:可变长度数组.类似java的ArrayList.\ntuple:不可变数组.\ndictionary:类似java的HashMap.key-value数据结构\n\n\n\nnim\n\nseq:类似python list.长度可变,元素可删除增加变更.使用方法:var e = newSeq[int]() #一个空序列(列表)let values = @[1,3,5,7] #快捷定义一个有4个整数元素的列表并初始化.完全定义:let values: seq[int] = @[1,3,5,7]\n\ntuple\n\n\n与python tuple相同\nproc test():tuple[name:string, age:int8] =\n    (“bill”,67)\nlet (fname, fage) = test() # 此时,函数test返回的名称与年龄分别赋给了fname, fage.fname类型推断为string, fage类型推断为int8.\n\n\n与python dictionary相同用法. 用key-value进行访问示例1:\nvar o = (name: \"Banana\", weight: 2, rating: 'c')\no[1] = 7 # weight:2 → 7\no.name = \"Apple\"\no.rating = ‘g’\n示例2:\ntype\n  Person = tuple[name: string, age: int]\nvar\n  person: Person\n\nperson = (name: \"Peter\", age: 30)\nperson = (\"Peter\", 30)# 可读性略差,但结果一样的写法:\necho person.name # \"Peter\"\necho person.age  # 30\n\n\n\n\narray虽然完全不同,但用法却与python的tuple有些异曲同工.在需要不可变数组(既不需要增删改元素)的地方,极其方便地临时存一些值.\nvar \n  values = [“abc”,”def”,”ghijk”] #自动推断类型为array[3,string]\n  values2: array[4,int] = [1,2,3,5] #4个下标的不可变数组,初始化时赋了4个值.\n  values:array[0..5, int] = [2,3,5,8] #最长5个下标的不可变数组,初始化时赋了4个值.\n\n\n\n\n片断\n\n\npython-起始\na = \"python is a progamming language\"\nb = \"Slices are useless.\"\nprint(a[12:18]) # --> 'progam' #12:从开始处第12个下标;18:从开始处的下标\n-反向标记片断\nb = \"Slices are useful.\"\nprint(b[11:-1]) # → 'useful' . 11:从开始处第11个下标;-1:从结尾处向前减少下标(反向的意思),也就是[倒数1的下标]\nb[11:-2] = \"useful\" # 出错, python不支持这样赋值\n\n\nnim-起始\nvar\n  a = \"Nim is a progamming language\"\n\necho a[7..12] # --> 'a prog'\n-反向标记片断\nvar\n  b = \"Slices are useless.\"\n\nb[11..^2] = \"useful\" #nim用^表示反向下标位置.^2表示倒数第二个下标\necho b # --> 'Slices are useful.' # 改变变量b的内容\n\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}