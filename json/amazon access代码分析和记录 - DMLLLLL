{"title": "amazon access代码分析和记录 - DMLLLLL ", "index": "python", "content": "这是一个kaggle项目的冠军代码看起来还是比较麻烦，这里记录一下这个冠军代码的一些处理方法这部分使用了集成学习的方法主要使用了LR、RF、GB这三种学习方法每一种学习方法大概使用了四五次，也就是对数据集也进行了各种处理\n\"LR:tuples_sf\",\n\"LR:greedy_sfl\",\n\"LR:greedy2_sfl\",\n\"LR:greedy3_sf\",\n\"RFC:basic_b\",\n\"RFC:tuples_f\",\n\"RFC:tuples_fd\",\n\"RFC:greedy_f\",\n\"RFC:greedy2_f\",\n\"GBC:basic_f\",\n\"GBC:tuples_f\",\n\"LR:greedy_sbl\",\n\"GBC:greedy_c\",\n\"GBC:tuples_cf\"\n上面左边是算法名字，右边的是数据集代号\n左边的分类方法比较好理解，不过右边的不好理解这里记录一下右边是如何处理数据的\n数据的情况：\n共有十列：\n      ACTION                      是否有权限\n      RESOURCE                    资源id\n      MGR_ID                      经理id\n      ROLE_ROLLUP_1               \n      ROLE_ROLLUP_2\n      ROLE_DEPTNAME\n      ROLE_TITLE\n      ROLE_FAMILY_DESC\n      ROLE_FAMILY\n      ROLE_CODE\nbsfeats:\n   去掉ROLE_CODE和ACTION这两列\n   X_all['ROLE_TITLE'] = X_all['ROLE_TITLE'] + (1000 * X_all['ROLE_FAMILY'])\n   X_all['ROLE_ROLLUPS'] = X_all['ROLE_ROLLUP_1'] + (10000 * X_all['ROLE_ROLLUP_2'])\n   X_all = X_all.drop(['ROLE_ROLLUP_1', 'ROLE_ROLLUP_2', 'ROLE_FAMILY'],axis=1)\n   到现在就剩下六列：\n       RESOURCE,MGR_ID,ROLE_DEPTNAME,ROLE_TITLE,ROLE_FAMILY_DESC,ROLE_ROLLUPS\n   对每一列添加cnt列：\n       此步骤是为了对前六列做处理，生成新的六列，过程如下\n          对每列进行分组，然后把组数的log值填充到相应的位置\n   再添加Duse列：\n       还是先按列各自进行分组，然后再按照resource分组\n       用每组RESOURCE的个数除以总个数\n   添加mdept列：\n       主要是添加相同经理的个数，按照经理先对数据进行分组\n       填充该经理组中资源的种类数\n   处理完后把前六列的数据删除\ngreedy:\n   这个处理过程就比较重量级了，由于数据都是类别型的，所以都使用了编码\n   首先把特征中的ACTION和ROLE_CODE两个特征去掉\n   然后让剩下的特征两两组合\n   这样就生成了很多新的特征，每一列的值用组合数据的hash值填充\n   下一步要给所有的特征做onehot编码\n   然后要选取比较好的feature选择过程是使用auc的得分来算\n       使用n-cv的方式，对选取的特征使用logisticReg的方法来判断auc计算得分\n       最终获取得分高的几个特征\n       基本思想就是这样\n   \n   \n   \n       \n   \n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}