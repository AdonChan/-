{"title": "Python学习笔记 - 花果山 ", "index": "python", "content": "Python学习笔记\n1.List\n[起始:结束:步长]  步长可以为负数，要求结束>起始  倒序 a = b[::-1]  相乘 [42] * 3 = [42, 42, 42]  强制转成list list('abc') = ['a', 'b', 'c']  元组，不可变的list，(2,5,6)可作为dict的key或者函数的多个返回值  可用函数 max(a) min(a) len(a) del a[2]  \nmethod:\nappend & pop  L.reverse()  L.count(item)  L.insert(5, item)  效果为item插入到L[5]  L.sort()  L2 = sorted(L1)  L.sort(cmp, key=len, reverse=True)  \n2.string\nsomething about formatting...\nmethod:\nfind,join,split,strip  replace  str.replace(ori, new)\n3.dict\ndel d[key]\nmethod:\npop & popitem  pop(key) return value，del item  popitem() return (key, value), del item  get & setdefault  get(key, defaultValue) 找到key返回value，找不到返回defaultValue  setdefault(key, defaultValue)找到key返回value，找不到返回defaultValue，并且插入键值对(key，defaultValue)  items()  keys()  values() 返回列表  iteritems()  iterkeys()  itervalues()  返回迭代器\nfor key, value in sorted(dict.items(), key=lambda x:x[1], reverse=False)\n    print key + '\\t' + value\n4.导入\nimport xxx\nfrom xxx import  yyy, zzz\nimport xxx as x\nfrom xxx import yyy as y\n5 赋值\n#序列解包\nx,y = y,x\nkey, value = d.popitem()\n6.if and for\n三元运算 a if b else c 如果b为true执行a否则c\nwhile xxx:\n    pass\n\nfor item in xrange(100):\n    pass\n# xrange(n) == [0,1,...,n-1]\n一些迭代方式\n#1.并行迭代\nnames = [\"A\", \"B\", \"C\"]\nages = [12, 55, 33]\nfor name, age in zip(names, ages):\n    pass\n#zip 取最短的list\n#2. 编号迭代:\nnames = [\"A\", \"B\", \"C\"]\nfor index, item in enumerate(names):\n    pass\n\n#break-else\nfor item in dict:\n    if xxxx:\n        break #find something and break the loop\nelse:\n    pass # didn't find\n7.函数&参数\ndef xxx(a):\n    'this is a introduction for xxx'\n    pass\n#函数的注释 xxx.__doc__ == xxx.func_doc== 'this is a introduction for xxx'\n\n#指定参数\ndef xxx(arg1=\"a\", arg2=\"b\"):\n    pass\n\n#收集参数\ndef xxx(x, y, z=3, *t, **d):\n    pass\n# *t    接收剩余的未指定的参数，组成元祖\n# **d  接收剩余的指定的参数，组成dict\n\n#函数内修改全局变量\nx = 1 #global val\ndef change_global():\n    global x\n    x += 1\n#函数内局部变量名字会覆盖全局变量，调用全局变量时应用global()['val_name']\nmap() 接受一个单参数函数，和序列作为参数   filter() 接受一个bool返回型的单参数函数 和序列，留下序列中true的值  reduce()接受一个双参数函数 和序列，依次迭代下去  lambda x,y:x+y\n8.面向对象\n__metaclass__ = type #使用新式类\nclass Person:\n    def setName(self, name):\n        self.name = name\n    def getName(self):\n        return self.name\n    def __inaccessible(self):\n        #__开头方法表示私有\n        pass\n    member = 0 \n    def init(self):\n        Person.member += 1  #所有实例共享变量，注意区别于self.member += 1\n\n# something about superClass\nclass Filter:\n    def init(self):\n        self.blocked = []\n    def filter(self, sq):\n        return [x for x in sq if x not in self.blocked]\n\nclass SPAMFilter(Filter): #SPAMFilter is subClass of Filter\n    def init(self): # rewrite init()\n        slef.blocked = ['aa']\n\n#查看一个类是否是另一个类的子类\nissubclass(SPAMFilter, Filter)\n#查看一个instance是否属于一个类\nisinstance(f, Filter)\n#查看一个类的基类们 \nSPAMFilter.__bases__\n#查看一个对象属于哪个类\nf.__class__\n\n#多个superClass\nclass Test(Class1, Class2):\n    pass\n# Test 继承了Class1和2,其中Class1的优先级高(覆盖Class2的方法)\n9.模块\n__name__字段在主程序中为__main__在导入的模块中显示为模块的名字\n# hello.py\ndef hello():\n    print \"hello world!\"\ndef test():\n    hello()\n\nif __name__ == \"__main__\":\n    #如果我是主函数，则从这里运行，否则作为被导入的模块，以hello.test()的形式被调用\n    test():\n导入自己的模块\n# python解释器一般寻找模块的路径\nimport sys\nprint sys.path\n# 添加新路径\nsys.path.append('xxx dir')\n导入包\n# 假设有如下结构的包drawing\n# /drawing/\n# /drawing/__init__.py\n# /drawing/a.py\n# /drawing/b.py\nimport drawing\n#只能使用__init__.py\nimport drawing.a\n#可使用drawing.a.xxx()\nfrom drawing import a, b\n#可直接使用a.xxx()\n探索包与模块dir()__all__help()__doc____file__\n10.文件IO，异常\n11.test，config，log\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "1"}