{"title": "Python3的这些新特性很方便 - 个人文章 ", "index": "python,python3.x,迁移,特性", "content": "概述\n  随着Python在机器学习和数据科学领域的应用越来越广泛，相关的Python库也增长的非常快。但是Python本身存在一个非常要命的问题，就是Python2和Python3，两个版本互不兼容，而且Github上Python2的开源库有很多不兼容Python3，导致大量的Python2的用户不愿意迁移到Python3。  Python3在很多方面都做出了改变，优化了Python2的很多不足，标准库也扩充了很多内容，例如协程相关的库。现在列举一些Python3里提供的功能，跟你更好的从Python2迁移到Python3的理由。\n系统文件路径处理库：pathlib\n  使用Python2的同学，应该都用过os.path这个库，来处理各种各样的路径问题，比如拼接文件路径的函数：os.path.join()，用Python3，你可以使用pathlib很方便的完成这个功能：\nfrom pathlib import Path\n\ndataset = 'wiki_images'\ndatasets_root = Path('/path/to/datasets/') \n\ntrain_path = datasets_root / dataset / 'train'\ntest_path = datasets_root / dataset / 'test'\n\nfor image_path in train_path.iterdir():\n    with image_path.open() as f: # note, open is a method of Path object\n        # do something with an image\n相比与os.path.join()函数，pathlib更加安全、方便、可读。pathlib还有很多其他的功能。\np.exists()\np.is_dir()\np.parts()\np.with_name('sibling.png') # only change the name, but keep the folder\np.with_suffix('.jpg') # only change the extension, but keep the folder and the name\np.chmod(mode)\np.rmdir()\n类型提醒: Type hinting\n  在Pycharm中，类型提醒是这个样子的：\n  类型提醒在复杂的项目中可以很好的帮助我们规避一些手误或者类型错误，Python2的时候是靠IDE来识别，格式IDE识别方法不一致，并且只是识别，并不具备严格限定。例如有下面的代码，参数可以是numpy.array , astropy.Table and astropy.Column, bcolz, cupy, mxnet.ndarray等等。\ndef repeat_each_entry(data):\n    \"\"\" Each entry in the data is doubled \n    <blah blah nobody reads the documentation till the end>\n    \"\"\"\n    index = numpy.repeat(numpy.arange(len(data)), 2)\n    return data[index]\n同样上面的代码，传入pandas.Series类型的参数也是可以，但是运行时会出错。\nrepeat_each_entry(pandas.Series(data=[0, 1, 2], index=[3, 4, 5])) # returns Series with Nones inside\n  这还只是一个函数，对于大型的项目，会有好多这样的函数，代码很容易就跑飞了。所以确定的参数类型对于大型项目来说非常重要，而Python2没有这样的能力，Python3可以。\ndef repeat_each_entry(data: Union[numpy.ndarray, bcolz.carray]):\n  目前，比如JetBrains家的PyCharm已经支持Type Hint语法检查功能，如果你使用了这个IDE，可以通过IDE功能进行实现。如果你像我一样，使用了SublimeText编辑器，那么第三方工具mypy可以帮助到你。  PS:目前类型提醒对ndarrays/tensors支持不是很好。\n运行时类型检查：\n正常情况下，函数的注释处理理解代码用，其他没什么用。你可以是用enforce来强制运行时检查类型。\n@enforce.runtime_validation\ndef foo(text: str) -> None:\n    print(text)\n\nfoo('Hi') # ok\nfoo(5)    # fails\n\n\n@enforce.runtime_validation\ndef any2(x: List[bool]) -> bool:\n    return any(x)\n\nany ([False, False, True, False]) # True\nany2([False, False, True, False]) # True\n\nany (['False']) # True\nany2(['False']) # fails\n\nany ([False, None, \"\", 0]) # False\nany2([False, None, \"\", 0]) # fails\n使用@特殊字符表示矩阵乘法\n如下代码：\n# l2-regularized linear regression: || AX - b ||^2 + alpha * ||x||^2 -> min\n\n# Python 2\nX = np.linalg.inv(np.dot(A.T, A) + alpha * np.eye(A.shape[1])).dot(A.T.dot(b))\n# Python 3\nX = np.linalg.inv(A.T @ A + alpha * np.eye(A.shape[1])) @ (A.T @ b)\n使用@符号，整个代码变得更可读和方便移植到其他如numpy、tensorflow等库。\n**特殊字符来递归文件路径\n在Python2中，递归查找文件不是件容易的事情，即使使用glob库，但是python3中，可以通过通配符简单的实现。\nimport glob\n\n# Python 2\nfound_images = \\\n    glob.glob('/path/*.jpg') \\\n  + glob.glob('/path/*/*.jpg') \\\n  + glob.glob('/path/*/*/*.jpg') \\\n  + glob.glob('/path/*/*/*/*.jpg') \\\n  + glob.glob('/path/*/*/*/*/*.jpg') \n\n# Python 3\nfound_images = glob.glob('/path/**/*.jpg', recursive=True)\n和之前提到的pathlib一起使用，效果更好：\n# Python 3\nfound_images = pathlib.Path('/path/').glob('**/*.jpg')\nPrint函数\n打印到指定文件\nprint >>sys.stderr, \"critical error\"      # Python 2\nprint(\"critical error\", file=sys.stderr)  # Python 3\n不使用join函数拼接字符串\n# Python 3\nprint(*array, sep='\\t')\nprint(batch, epoch, loss, accuracy, time, sep='\\t')\n重写print函数\n# Python 3\n_print = print # store the original print function\ndef print(*args, **kargs):\n    pass  # do something useful, e.g. store output to some file\n再比如下面的代码\n@contextlib.contextmanager\ndef replace_print():\n    import builtins\n    _print = print # saving old print function\n    # or use some other function here\n    builtins.print = lambda *args, **kwargs: _print('new printing', *args, **kwargs)\n    yield\n    builtins.print = _print\n\nwith replace_print():\n    <code here will invoke other print function>\n虽然上面这段代码也能达到重写print函数的目的，但是不推荐使用。\n字符串格式化\npython2提供的字符串格式化系统还是不够好，太冗长麻烦，通常我们会写这样一段代码来输出日志信息：\n# Python 2\nprint('{batch:3} {epoch:3} / {total_epochs:3}  accuracy: {acc_mean:0.4f}±{acc_std:0.4f} time: {avg_time:3.2f}'.format(\n    batch=batch, epoch=epoch, total_epochs=total_epochs, \n    acc_mean=numpy.mean(accuracies), acc_std=numpy.std(accuracies),\n    avg_time=time / len(data_batch)\n))\n\n# Python 2 (too error-prone during fast modifications, please avoid):\nprint('{:3} {:3} / {:3}  accuracy: {:0.4f}±{:0.4f} time: {:3.2f}'.format(\n    batch, epoch, total_epochs, numpy.mean(accuracies), numpy.std(accuracies),\n    time / len(data_batch)\n))\n\n输出的结果是：\n120  12 / 300  accuracy: 0.8180±0.4649 time: 56.60\npython3.6的f-strings功能实现起来就简单多了。\n# Python 3.6+\nprint(f'{batch:3} {epoch:3} / {total_epochs:3}  accuracy: {numpy.mean(accuracies):0.4f}±{numpy.std(accuracies):0.4f} time: {time / len(data_batch):3.2f}')\n而且，在编写查询或生成代码片段时非常方便：\nquery = f\"INSERT INTO STATION VALUES (13, '{city}', '{state}', {latitude}, {longitude})\"\n严格排序\n下面这些比较操作在python3里是非法的\n# All these comparisons are illegal in Python 3\n3 < '3'\n2 < None\n(3, 4) < (3, None)\n(4, 5) < [4, 5]\n\n# False in both Python 2 and Python 3\n(4, 5) == [4, 5]\n不同类型的数据无法排序\nsorted([2, '1', 3])  # invalid for Python 3, in Python 2 returns [2, 3, '1']\nNLP Unicode问题\ns = '您好'\nprint(len(s))\nprint(s[:2])\n\nOutput:\n\nPython 2: 6\\n��\nPython 3: 2\\n您好.\n\n\nx = u'со'\nx += 'co' # ok\nx += 'со' # fail\n下面这段代码在Python2里运行失败但是Python3会成功运行，Python3的字符串都是Unicode编码，所以这样对NLP来说很方便，再比如：\n'a' < type < u'a'  # Python 2: True\n'a' < u'a'         # Python 2: False\nfrom collections import Counter\nCounter('Möbelstück')\nPython 2: Counter({'\\xc3': 2, 'b': 1, 'e': 1, 'c': 1, 'k': 1, 'M': 1, 'l': 1, 's': 1, 't': 1, '\\xb6': 1, '\\xbc': 1})\nPython 3: Counter({'M': 1, 'ö': 1, 'b': 1, 'e': 1, 'l': 1, 's': 1, 't': 1, 'ü': 1, 'c': 1, 'k': 1})\n字典\nCPython3.6+里的dict默认的行为和orderdict很类似\nimport json\nx = {str(i):i for i in range(5)}\njson.loads(json.dumps(x))\n# Python 2\n{u'1': 1, u'0': 0, u'3': 3, u'2': 2, u'4': 4}\n# Python 3\n{'0': 0, '1': 1, '2': 2, '3': 3, '4': 4}\n同样的，**kwargs字典内容的数据和传入参数的顺序是一致的。\nfrom torch import nn\n\n# Python 2\nmodel = nn.Sequential(OrderedDict([\n          ('conv1', nn.Conv2d(1,20,5)),\n          ('relu1', nn.ReLU()),\n          ('conv2', nn.Conv2d(20,64,5)),\n          ('relu2', nn.ReLU())\n        ]))\n\n# Python 3.6+, how it *can* be done, not supported right now in pytorch\nmodel = nn.Sequential(\n    conv1=nn.Conv2d(1,20,5),\n    relu1=nn.ReLU(),\n    conv2=nn.Conv2d(20,64,5),\n    relu2=nn.ReLU())\n)        \nIterable unpacking\n# handy when amount of additional stored info may vary between experiments, but the same code can be used in all cases\nmodel_paramteres, optimizer_parameters, *other_params = load(checkpoint_name)\n\n# picking two last values from a sequence\n*prev, next_to_last, last = values_history\n\n# This also works with any iterables, so if you have a function that yields e.g. qualities,\n# below is a simple way to take only last two values from a list \n*prev, next_to_last, last = iter_train(args)\n更高性能的默认pickle engine\n# Python 2\nimport cPickle as pickle\nimport numpy\nprint len(pickle.dumps(numpy.random.normal(size=[1000, 1000])))\n# result: 23691675\n\n# Python 3\nimport pickle\nimport numpy\nlen(pickle.dumps(numpy.random.normal(size=[1000, 1000])))\n# result: 8000162\n缩短到Python2时间的1/3\n更安全的列表推导\nlabels = <initial_value>\npredictions = [model.predict(data) for data, labels in dataset]\n\n# labels are overwritten in Python 2\n# labels are not affected by comprehension in Python 3\n更简易的super()\n# Python 2\nclass MySubClass(MySuperClass):\n    def __init__(self, name, **options):\n        super(MySubClass, self).__init__(name='subclass', **options)\n        \n# Python 3\nclass MySubClass(MySuperClass):\n    def __init__(self, name, **options):\n        super().__init__(name='subclass', **options)\nMultiple unpacking\n合并两个Dict\nx = dict(a=1, b=2)\ny = dict(b=3, d=4)\n# Python 3.5+\nz = {**x, **y} \n# z = {'a': 1, 'b': 3, 'd': 4}, note that value for `b` is taken from the latter dict.\nPython3.5+不仅仅合并dict很方便，合并list等也很方便\n[*a, *b, *c] # list, concatenating \n(*a, *b, *c) # tuple, concatenating \n{*a, *b, *c} # set, union \nPython 3.5+\ndo_something(**{**default_settings, **custom_settings})\n\n# Also possible, this code also checks there is no intersection between keys of dictionaries\ndo_something(**first_args, **second_args)\n整数类型\npython2提供了两个整数类型：int和long，python3只提供有个整数类型：int，如下的代码：\nisinstance(x, numbers.Integral) # Python 2, the canonical way\nisinstance(x, (long, int))      # Python 2\nisinstance(x, int)              # Python 3, easier to remember\n总结\npython3提供了很多新的特性，方便我们编码的同时，也带来了更好的安全性和较高的性能。而且官方也一直推荐尽快迁移到python3。当然，迁移的代价因系统而异，希望这篇文章能对你迁移python2到python3有些帮助。\n相关文章\n\n英文原文\n转自我的博客：捕蛇者说\n\n\n\n                ", "mainLikeNum": ["7 "], "mainBookmarkNum": "17"}