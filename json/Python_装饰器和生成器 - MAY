{"title": "Python_装饰器和生成器 - MAY ", "index": "python", "content": "迭代器\n迭代是访问集合元素的一种方式。迭代器是一个可以记住遍历的位置的对象，迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束，迭代器只往前不会往后退。\n可迭代对象\n以直接作用域for循环的数据类型：\n\n集合数据类型：list, tuple, dict, set, str\n\ngenerator，包括生成器和yield的generator function\n\n\n判断是否可以迭代\n使用方法isinstance()判断一个对象是否具有Iterable对象\nfrom collections import Iterable\n\nisinstance('abc', Iterable) # true\n迭代器\n可以被next()函数调用并不断返回下一个值的对象称之为迭代器: Iterator\n生成器, tuple\nfrom collections import Iterator\n\nisinstance((x for x in range(10)), Iterator) # True\nisinstance([], Iterator) # False 列表不是迭代对象\niter()函数生成器都是Iterator对象， 但是list, dict, str虽然是Iterable,却不是Iterator\n可以把其他类型转成生成器, 使用iter()函数\n闭包\n函数是引用\n闭包:\ndef test(number):\n    def test_in(number_in):\n        print(number_in)\n        return number + number_in\n    return test_in\n\ntest(10)(20)\n装饰器\n对函数或方法起装饰作用\n写代码要遵循开放封闭原则。它规定已经实现的功能代码不允许被修改，但可以被扩展。\n封闭: 已实现的功能代码块开放: 对扩展开发\n装饰器原理：\ndef a(func):\n    def inner():\n        func()\n    return inner()\n    \ndef f1():\n    print('f1')\n\nf1 = a(f1) # 函数名作为变量名，重新赋值使用\nf1()\n装饰器语法糖：\ndef a(func):\n    def inner():\n        func()\n    return inner()\n\n@a\ndef f1():\n    print('f1')\n\nf1()         \n二个装饰器\ndef makeBold(fn):\n    def warpped():\n        print('1')\n        return '<b>' + fn() + '</b>'\n    return warpped\n\ndef makeItalic(fn):\n    def warpped():\n        print('2')\n        return '<i>' + fn() + '</i>'\n    return warpped\n\n@makeBold\n@makeItalic\ndef test1():\n    print('3')\n    return 'hello world'\n\nret = test1()\nprint(ret)\n\n# 输出结果:\n# 1\n# 2\n# 3\n# <b><i>hello world</i></b>    \n装饰器执行的时间\ndef w1(func):\n    print('1')\n    def inner():\n        print('2')\n        func()\n    return inner\n\ndef w2(func):\n    print('4')\n    def inner():\n        print('5')\n        func()\n    return inner\n\n@w2\n@w1\ndef f1():\n    print(3)\n\n# 执行f1\nf1()\n# 1 2 3 # 只有w1 装饰\n# 1 4 5 2 3 # w1,w2共同装饰\n\n# 不执行f1\n# 1 4\n装饰器对有参数、无参数函数进行装饰\ndef func(funName):\n    print('1')\n    def func_in(argA, argB): # 形参\n        print('2')\n        funName(argA, argB) # 调用传递参数\n    return func_in\n\n\n@func\ndef test(a, b):    \n    print('a=%d,b=%d'%(a,b))\n\ntest(10, 20)\n以*args来解决多参数问题\ndef func(funName):\n    print('1')\n    def func_in(*args, **kwargs): # 形参\n        print('2')\n        funName(*args, **kwargs) # 调用传递参数\n    return func_in\n\n\n@func\ndef test(a, b):    \n    print('a=%d,b=%d'%(a,b))\n\ntest(10, 20)\n装饰器对带有返回值的函数进行装饰\ndef func(funName):\n    print('1')\n    def func_in():\n        print('2')\n        return funName() # 返回值\n    return func_in\n\n\n@func\ndef test():    \n    return 'test'\n\nret = test()\nprint(ret)\n通用装饰器\ndef func(funName):\n    def func_in(*args, **kwargs):\n        return funName(*args, **kwargs) # 返回值\n    return func_in\n\n\n@func\ndef test():    \n    return 'test'\n\nret = test()\nprint(ret)\n带有参数装饰器\nfrom time import ctime, sleep\n\ndef timefun_arg(pre=\"hello\"):\n    def timefun(func):\n        def warppedfunc():\n            print('%s called at %s %s'%(func.__name__, ctime(), pre))\n            return func()\n        return warppedfunc\n    return timefun\n\n\n@timefun_arg('it') # 执行，主动调用。需要多一层闭包函数\ndef foo():\n    print('foo')\n\n@timefun_arg('python')\ndef too():\n    print('too')\n\nfoo()\nsleep(2)\ntoo()\n作用域\nglobals\n查看命名空间中所有全局变量：globals()以字典方式返回\n{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <class '_frozen_importlib.BuiltinImporter'>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>}\nlocals\n查看命名空间中局部变量locals()以字典方式返回：\n{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <class '_frozen_importlib.BuiltinImporter'>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>}\nLEGB规则\nPython使用LEGB的顺序来查找一个符号对应的对象\nlocals -> enclosing function -> globals -> builtins\nlocals: 当前所在的命名空间(如函数，模块)，函数的参数也属于命名空间内的变量enclosing: 外部嵌套函数的命名空间globals: 全局变量，函数定义所在模块的命名空间builtins: 内建模块的命名空间\n查看内建模块的变量：dir(__builtins__)\n['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError', 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FileExistsError', 'FileNotFoundError', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError', 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'ModuleNotFoundError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented', 'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError', 'RecursionError', 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning', 'StopAsyncIteration', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning', 'WindowsError', 'ZeroDivisionError', '_', '__build_class__', '__debug__', '__doc__', '__import__', '__loader__', '__name__', '__package__', '__spec__', 'abs', 'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip']\n动态绑定\n动态绑定属性：\nclass Person(object):\n    def __init__(self):\n        pass\n        \np1 = Person\np1.name = 'pp' # 动态添加属性\n\nprint(p1.name)\n动态绑定方法：\nimport types\nclass Person(object):\n        def __init__(self, newName, newAge):\n                self.name = newName\n                self.age = newAge\n        def eat(self):\n                print('eat-', self.name)\n\ndef run(self):\n        print('run-', self.name)\n\np1 = Person('p1', 24)\np1.eat()\n\n# 通过types库中的MethodType方法来修改指向函数中的this指针\np1.run = types.MethodType(run, p1) # 动态添加方法\n\np1.run()\n绑定静态方法和静态属性：\nclass Person(object):\n    def __init__(self):\n        pass\n\n\n\n@staticmethod\ndef test():\n    print('static method')\n\nPerson.test = test # 绑定静态方法\nPerson.name = 'alogy' # 绑定静态属性\n\nPerson.test()\n绑定类属性：\nclass Person(object):\n    def __init__(self):\n        pass\n\n\n@classmethod\ndef printNum(cls):\n    print('class method')\n\nPerson.printNum = printNum\n\nPerson.printNum()\nslots\n动态语言：可以在运行过程中，修改代码静态语言：编译时已经确定好代码，运行过程中不能修改\n__slots__作用：限制实例的属性\nclass Person(object):\n    __slots__ = ('name', 'age')\n    \np = Person()\np.name = 'alogy'\np.age = 24\n    \nNote:__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用\n生成器\n目标：列表中有大量数据，还不想占用大量内存空间。\n生成器特点：保存了一套生成数值的算法。(什么时候需要使用到了，才去生成。)\n生成器定义方法\n方法1:()\na = (x for x in range(10))\nprint(a)\n方法2: yield\ndef createNum():\n    print('--start')\n    a,b = 0,1\n    for i in range(5):\n        print('--11')\n        yield b\n        print('--22')\n        a,b = b,a+b\n        print('--33')\n    print('--end')\n\nt = createNum()\n\nfor num in t:\n    print(num)\n输出结果：\n--start\n--11\n1\n--22\n--33\n--11\n1\n--22\n--33\n--11\n2\n--22\n--33\n--11\n3\n--22\n--33\n--11\n5\n--22\n--33\n--end\nsend方法: 与yield的结果配合使用，使得yield执行的时候，外部可以传递参数到生成器中。能够执行next()且还可以传递参数\ndef test():\n    i = 0\n    while i < 5:\n        temp = yield i\n        print(temp)\n        i += 1\n\nt = test()\nprint(t.next()) \n# 0\nprint(t.next()) \n# None\n# 1\nprint(t.send('args'))\n# args\n# 2      \nNote:send()第一次直接调用报错，是参数不知道给那个函数。报错为：\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: can't send non-None value to a just-started generator\n解决方法：\n\n通过next()先调用一次，然后再使用send()\n\n第一次调用send(None)传递空值进去，后续几次传递该传递的值\n\n完成多任务\ndef test1():\n    while True:\n        print('test1')\n        yield None\n\ndef test2():\n    while True:\n        print('test2')\n        yield None\n\nt1 = test1()\nt2 = test2()\n\nwhile True:\n    t1.next()\n    t2.next()\n一齐执行test1(),test2(),test3(),三个while True同时执行三个多任务或者三个以上同时执行称之为：协程\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "2"}