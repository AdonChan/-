{"title": "在Python中使用静态，类或抽象方法的权威指南 - 个人文章 ", "index": "python", "content": "Python中方法的工作方式\n方法是存储在类属性中的函数，你可以用下面这种方式声明和访问一个函数\n>>> class Pizza(object):\n    ...     def __init__(self, size):\n    ...         self.size = size\n    ...     def get_size(self):\n    ...         return self.size\n    ...\n    >>> Pizza.get_size\n    <unbound method Pizza.get_size>\nPython在这里说明了什么？Pizza类的属性get_size是unbound(未绑定的)，这代表什么含义?我们调用一下就明白了:\n >>> Pizza.get_size()\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    TypeError: unbound method get_size() must be called with Pizza instance as first argument (got nothing instead)\n我们无法调用它(get_size)，因为它没有绑定到Pizza的任何实例上，而且一个方法需要一个实例作为它的第一个参数(Python2中必须是类的实例，Python3没有这个强制要求)，让我们试一下:\n >>> Pizza.get_size(Pizza(42))\n    42\n我们使用一个实例作为这个方法的第一个参数来调用它，没有出现任何问题。但是如果我说这不是一个方便的调用方法的方式，你将会同意我的观点。我们每次调用方法都要涉及(这里我理解是引用)类\n来看Python打算为我们做些什么，就是它从Pizza类中绑定所有的方法到这个类的任何实例上。意思就是Pizza实例化后get_size这个属性是一个绑定方法，方法的第一个参数会是实例对象自己\n>>> Pizza(42).get_size\n    <bound method Pizza.get_size of <__main__.Pizza object at 0x7f3138827910>>\n    >>> Pizza(42).get_size()\n    42\n意料之中，我们不需要为get_size传任何参数，自从被绑定后，它的self参数会自动设置为Pizza实例，下面是一个更明显的例子:\n>>> m = Pizza(42).get_size\n    >>> m()\n    42\n事实上是，你甚至不需要对Pizza引用，因为这个方法已经绑定到了这个对象\n如果你想知道这个绑定方法绑定到了哪一个对象，这里有个快捷的方法:\n >>> m = Pizza(42).get_size\n    >>> m.__self__\n    <__main__.Pizza object at 0x7f3138827910>\n    >>> # You could guess, look at this:\n    ...\n    >>> m == m.__self__.get_size\n    True\n明显可以看出，我们仍然保持对我们对象的引用，而且如果需要我们可以找到它\n在Python3中，类中的函数不再被认为是未绑定的方法(应该是作为函数存在)，如果需要，会作为一个函数绑定到对象上，所以原理是一样的(和Python2)，只是模型被简化了\n >>> class Pizza(object):\n    ...     def __init__(self, size):\n    ...         self.size = size\n    ...     def get_size(self):\n    ...         return self.size\n    ...\n    >>> Pizza.get_size\n    <function Pizza.get_size at 0x7f307f984dd0>\n静态方法\n静态方法一种特殊方法，有时你想把代码归属到一个类中，但又不想和这个对象发生任何交互:\nclass Pizza(object):\n        @staticmethod\n        def mix_ingredients(x, y):\n            return x + y\n\n        def cook(self):\n            return self.mix_ingredients(self.cheese, self.vegetables)\n上面这个例子，mix_ingredients完全可以写成一个非静态方法，但是这样会将self作为第一个参数传入。在这个例子里，装饰器@staticmethod 会实现几个功能:\nPython不会为Pizza的实例对象实例化一个绑定方法，绑定方法也是对象，会产生开销，静态方法可以避免这类情况\n>>> Pizza().cook is Pizza().cook\n        False\n        >>> Pizza().mix_ingredients is Pizza.mix_ingredients\n        True\n        >>> Pizza().mix_ingredients is Pizza().mix_ingredients\n        True\n简化了代码的可读性，看到@staticmethod我们就会知道这个方法不会依赖这个对象的状态(一国两制，高度自治)允许在子类中重写mix_ingredients方法。如果我们在顶级模型中定义了mix_ingredients函数，继承自Pizza的类除了重写，否则无法改变mix_ingredients的功能\n类方法\n什么是类方法，类方法是方法不会被绑定到一个对象，而是被绑定到一个类中\n >>> class Pizza(object):\n    ...     radius = 42\n    ...     @classmethod\n    ...     def get_radius(cls):\n    ...         return cls.radius\n    ... \n    >>> \n    >>> Pizza.get_radius\n    <bound method type.get_radius of <class '__main__.Pizza'>>\n    >>> Pizza().get_radius\n    <bound method type.get_radius of <class '__main__.Pizza'>>\n    >>> Pizza.get_radius == Pizza().get_radius\n    True\n    >>> Pizza.get_radius()\n    42\n无论以何种方式访问这个方法，它都会被绑定到类中，它的第一个参数必须是类本身(记住类也是对象)\n什么时候使用类方法，类方法在以下两种场合会有很好的效果:1、工厂方法，为类创建实例，例如某种程度的预处理。如果我们使用@staticmethod代替，我们必须要在代码中硬编码Pizza(写死Pizza)，这样从Pizza继承的类就不能使用了\n class Pizza(object):\n            def __init__(self, ingredients):\n                self.ingredients = ingredients\n\n            @classmethod\n            def from_fridge(cls, fridge):\n                return cls(fridge.get_cheese() + fridge.get_vegetables())\n2、使用静态方法调用静态方法，如果你需要将一个静态方法拆分为多个，可以使用类方法来避免硬编码类名。使用这种方法来声明我们的方法Pizza的名字永远不会被直接引用，而且继承和重写方法都很方便\nclass Pizza(object):\n            def __init__(self, radius, height):\n                self.radius = radius\n                self.height = height\n\n            @staticmethod\n            def compute_area(radius):\n                 return math.pi * (radius ** 2)\n\n            @classmethod\n            def compute_volume(cls, height, radius):\n                 return height * cls.compute_area(radius)\n\n            def get_volume(self):\n                return self.compute_volume(self.height, self.radius)\n抽象方法\n抽象方法是定义在基类中的，可以是不提供任何功能代码的方法在Python中简单的写抽象方法的方式是:\n class Pizza(object):\n        def get_radius(self):\n            raise NotImplementedError\n继承自Pizza的类都必须要实现并重写get_redius，否则就会报错\n这种方式的抽象方法有一个问题，如果你忘记实现了get_radius，只有在你调用这个方法的时候才会报错\n  >>> Pizza()\n    <__main__.Pizza object at 0x7fb747353d90>\n    >>> Pizza().get_radius()\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n      File \"<stdin>\", line 3, in get_radius\n    NotImplementedError\n使用python的abc模块可以是这个异常被更早的触发\n import abc\n\n    class BasePizza(object):\n        __metaclass__  = abc.ABCMeta\n\n        @abc.abstractmethod\n        def get_radius(self):\n             \"\"\"Method that should do something.\"\"\"\n使用abc和它的特殊类，如果你尝试实例化BasePizza或者继承它，都会得到TypeError错误\n>>> BasePizza()\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    TypeError: Can't instantiate abstract class BasePizza with abstract methods get_radius\n备注:我使用Python3.6实现的代码\nIn [8]: import abc\n       ...:\n       ...: class BasePizza(abc.ABC):\n       ...:\n       ...:     @abc.abstractmethod\n       ...:     def get_radius(self):\n       ...:          \"\"\":return\"\"\"\n       ...:\n\n    In [9]: BasePizza()\n    ---------------------------------------------------------------------------\n    TypeError                                 Traceback (most recent call last)\n    <ipython-input-9-70b53ea21e68> in <module>()\n    ----> 1 BasePizza()\n\n    TypeError: Can't instantiate abstract class BasePizza with abstract methods get_radius\n混合静态，类和抽象方法\n如果对Python编程、网络爬虫、机器学习、数据挖掘、web开发、人工智能、面试经验交流。感兴趣可以519970686，群内会有不定期的发放免费的资料链接，这些资料都是从各个技术网站搜集、整理出来的，如果你有好的学习资料可以私聊发我，我会注明出处之后分享给大家。\n当需要创建类和继承时，如果你需要混合这些方法装饰器，这里有一些小窍门建议给你记住要将方法声明为抽象，不要冻结这个方法的原型。意思是它(声明的方法)必须要执行，但是它在执行的时候，参数不会有任何限制\n import abc\n\n        class BasePizza(object):\n            __metaclass__  = abc.ABCMeta\n\n            @abc.abstractmethod\n            def get_ingredients(self):\n                 \"\"\"Returns the ingredient list.\"\"\"\n\n        class Calzone(BasePizza):\n            def get_ingredients(self, with_egg=False):\n                egg = Egg() if with_egg else None\n                return self.ingredients + egg\n这样是有效的，因为Calzone实现了我们为BasePizza定义的接口要求，这意味着我们也可以将它实现为一个类或者静态方法，例如:\nimport abc\n\n        class BasePizza(object):\n            __metaclass__  = abc.ABCMeta\n\n            @abc.abstractmethod\n            def get_ingredients(self):\n                 \"\"\"Returns the ingredient list.\"\"\"\n\n        class DietPizza(BasePizza):\n            @staticmethod\n            def get_ingredients():\n                return None\n这也是正确的，它实现了抽要BasePizza的要求，事实上是get_ingredioents方法不需要知道对象返回的结果，因此，你不需要强制抽象方法实现成为常规方法、类或者静态方法。在python3中，可以将@staticmethod和@classmethod装饰器放在@abstractmethod上面\n import abc\n\n        class BasePizza(object):\n            __metaclass__  = abc.ABCMeta\n\n            ingredient = ['cheese']\n\n            @classmethod\n            @abc.abstractmethod\n            def get_ingredients(cls):\n                 \"\"\"Returns the ingredient list.\"\"\"\n                 return cls.ingredients\n和Java的接口相反，你可以在抽象方法中实现代码并通过super()调用它\n  import abc\n\n        class BasePizza(object):\n            __metaclass__  = abc.ABCMeta\n\n            default_ingredients = ['cheese']\n\n            @classmethod\n            @abc.abstractmethod\n            def get_ingredients(cls):\n                 \"\"\"Returns the ingredient list.\"\"\"\n                 return cls.default_ingredients\n\n        class DietPizza(BasePizza):\n            def get_ingredients(self):\n                return ['egg'] + super(DietPizza, self).get_ingredients()\n在上面的例子中，继承BasePizza来创建的每个Pizza都必须重写get_ingredients 方法，但是可以使用super()来获取default_ingredients\n出处 https://blog.csdn.net/Stephen...\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "1"}