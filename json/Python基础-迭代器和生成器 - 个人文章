{"title": "Python基础-迭代器和生成器 - 个人文章 ", "index": "python", "content": "迭代器\n迭代器用于：\n\nfor 循环\n构建和扩展集合类型\n逐行遍历文本文件\n列表推导、 字典推导和集合推导\n元组拆包\n调用函数时， 使用 * 拆包实参\n\n解释器需要迭代对象x时，会自动调用iter(x)；\n内置的iter函数，有以下功能：\n\n检查对象是否实现了 _iter _ 方法， 如果实现了就调用它，获取一个迭代器。\n如果没有实现  _iter _ 方法，但是实现了  _getitem _ 方法，Python 会创建一个迭代器，尝试按顺序（从索引 0 开始）获取元素。\n如果尝试失败，Python抛出TypeError异常，通常会提示\"C objectis not iterable\"（C 对象不可迭代），其中C是目标对象所属的类。\n\n\n__next__ #返回下一个可用的元素,如果没有元素了,抛出StopIteration异常\n__iter__ #返回self, 以便在应该使用可迭代对象的地方使用迭代器,例如在for循环中\nimport re\n\nRE_WORD = re.compile('\\w+')\n\nclass Sentence:\n    # 可迭代的对象\n    def __init__(self, text):\n        self.text = text\n        self.words = RE_WORD.findall(text)\n\n    def __iter__(self): # 1\n        return SentenceIterator(self.words)\n\nclass SentenceIterator:\n    # 迭代器\n    def __init__(self, words):\n        self.words = words\n        self.index = 0\n\n    def __next__(self): # 2\n        try:\n            word = self.words[self.index]\n        except IndexError:\n            raise StopIteration()\n        self.index += 1\n        return word\n\n    def __iter__(self): # 3\n        return self\n\ns = Sentence('\"The time has come,\" the Walrus said,')\n\nfor word in s:\n    print(word)\n\n--------------------\nThe\ntime\nhas\ncome\nthe\nWalrus\nsaid\n\n{#}1： 实现__iter__方法，并返回了一个迭代器实例SentenceIterator，所以是可迭代的对象；\n{#}23： 实现__next__和__iter__，并返回了迭代器本身；\n{#}123：说明：迭代器可以迭代，但是可迭代的对象不是迭代器；\n\n生成器\n生成器函数\n只要Python函数的定义体中有yield关键字，那么事实上定义的是一个generator function，调用这个generator function返回值是一个generator。\ndef gen_AB():\n    print('start')\n    yield 'A'\n    print('continue')\n    yield 'B'\n    print('end.')\n\nprint(gen_AB()) # 1\n\ngen_AB() # 2\n\nfor item in gen_AB(): # 3\n    print('--->', item)\n----------------\n\n<generator object gen_AB at 0x0000016FDBBFDFC0>\n\nstart\n---> A\ncontinue\n---> B\nend.\n\n{#}1：虽然函数gen_AB没有return，但是依然返回了生成器对象；\n{#}2：此时没有执行函数gen_AB的内容；\n{#}3：生成器一定是迭代器（反之不成立）;\n{#}3: 当调用generator的next方法，generator会执行到yield表达式处，返回yield表达式的内容，然后暂停（挂起）在这个地方，等待下个next的执行；\n\n生成器表达式(generator expression)\n生成器表达式可以理解为列表推导的惰性版本： 不会迫切地构建列表，\n而是返回一个生成器， 按需惰性生成元素。\ndef gen_AB():\n    print('start')\n    yield 'A'\n    print('continue')\n    yield 'B'\n    print('end.')\n    \nres1 = [x*3 for x in gen_AB()] # 1\nfor i in res1:\n    print('-->', i) # 2\n\nres2 = (x*3 for x in gen_AB()) # 3\nfor i in res2:\n    print('--->', i)\n----------------\n\nstart\ncontinue\nend.\n--> AAA\n--> BBB\n\nstart\n---> AAA\ncontinue\n---> BBB\nend.\n\n{#}1：列表推导迫切迭代函数gen_AB，打印出start continue end. res1=[AAA,BBB]；\n{#}2: 输出AAA,BBB；\n{#}3：把生成器表达式返回的值赋值给res2。只需调用gen_AB()函数，虽然调用时会返回一个生成器，但是这里并不使用；\n\n参考\n\n流畅的Python.\nhttps://www.cnblogs.com/MnCu8...\nhttp://www.cnblogs.com/xybaby...\nhttp://python.jobbole.com/87805/\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}