{"title": "【正经的AI on Python入门系列】1.1斗图工具的优化——实现文本居中（还混进了一些语法基础） - 个人文章 ", "index": "数据分析,python", "content": "\n大家还记得上一篇文章0.来学点Python吧！从一个斗图小工具开始中最后提到的几个问题么，我们这次就来解决一下其中难度最大的一个：文本居中！\n看，我把代码优化了！\n上次之后，我偷偷把代码优化了，现在的main方法长这样：\n# -*- coding:utf-8 -*-\n#__author__ = 'akers'\nfrom io import BytesIO\nfrom PIL import Image, ImageDraw, ImageFont\nimport sys,platform,operators.image,operators.clipboard\n\n\ndef main(argv):\n    # 创建表情图\n    image = operators.image.draw_emo('./resources/background/pander/default.png', './resources/face/jgz/laugth.png', argv[1])\n    output = BytesIO()\n    image.save(output, format=\"BMP\")\n    operators.clipboard.add_bmp(output)\n    image.save('output/facing.png')\n\n    # 调试用\n    # plt.figure(\"生成表情包\")\n    # plt.imshow(target)\n    # plt.show()\n\nif __name__ == \"__main__\":\n    main(sys.argv)\n对的，我把那些老长老长的代码藏到别的包里了，下面是一点题外话，顺便介绍一下Python的包与模块\nPython的包与模块\n以我们重构后的项目为例，一个项目的结构大致如下\n包\npython中的包就是一个包含了__init__.py文件的文件夹，包下可有子包\n模块\npython的模块就是一个py文件，其中可包括类、函数、变量等等内容\n导入包\npython中使用import关键字引入模块，import的使用分以下几种\nimport package[.sub_package].model\n导入指定的模块，调用时需使用模块全名，例如\nimport operators.image\n\noperators.image.draw_emo\nfrom package[.sub_package] import model\n导入指定模块，调用时直接使用模块名\nfrom operators import image\n\nimage.draw_emo()\nimport package[.sub_package].model import function\n导入模块中的函数或成员、类、变量等\nfrom operators.image import draw_emo\n\ndraw_emo()\nPython的包跟模块的内容还有很多，更详细的就先不赘述了，然后让我们继续主题，咳咳\n表情包文本居中\n首先，我们来实现文本的居中，我们先来回顾一下我们是如何插入文本的：\n#底图上的10,200位置写入文字\ndraw.text((10, 200), argv[1],fill='black', font=font)\ntext函数的第一个参数需要个元组，而元组中的0、1两个元素分别代表的x和y的坐标（以像素为单位），那实现居中就很简单了，我们只需要根据插入文本的具体宽度计算出一个合适的x坐标就可以了。于是请看大屏幕，啊呸，请看下图，\n从图中我们可以看到，文本的插入坐标可以用这样的公式进行计算：(底图宽-文本宽) / 2，那问题又来了，文本宽我们怎么得到呢？在PIL中，我们可以用draw.textsize获取文本所占的大小，返回是个元组：(宽,高)，像这样：\ntxtSize = draw.textsize(text, imageFont)\n所以我们修改一下draw_text方法：对x坐标进行计算\ndef draw_text_v1(text, image, off_set=200):\n    \"\"\"强化版绘制文字v1，让文字在x轴上居中\n    Args:\n        text: 显示在图片上的文本\n        image: 当前正使用的Image\n        off_set: 纵向偏移量\n\n    Returns:\n        Image\n\n    Raises:\n\n    \"\"\"\n    # 加入文字\n    # ImageDraw为PIL的绘图模块\n    _DEFAULT_FONT_SIZE = 30\n    draw = ImageDraw.Draw(image)\n    imageFont = ImageFont.truetype('./resources/msyh.ttc', _DEFAULT_FONT_SIZE)\n    _MAX_TXT_HEIGH = 32\n    txtSize = draw.textsize(text, imageFont)\n    pos_x = (CONST_IMG_WIDTH - txtSize[0]) / 2 if CONST_IMG_WIDTH > txtSize[0] else 0\n    print(\"当前X坐标\", pos_x)\n    # 默认显示位置\n    pos = (pos_x, off_set)\n    draw.text(pos, text, fill='black', font=imageFont)\n    del draw\n    return image\n相信眼尖的强迫症患者可能会发现，这里面混着一个很奇怪的写法：\n(CONST_IMG_WIDTH - txtSize[0]) / 2 if CONST_IMG_WIDTH > txtSize[0] else 0\n这个if跟else是不是有点调皮，其实这个在python 里类似于c预习里的 ? :三目运算符：如果if后的条件成立，则取if前的表达式进行返回，否则取else后的表达式，上面的代码实际等同于：\nCONST_IMG_WIDTH > txtSize[0] ? (CONST_IMG_WIDTH - txtSize[0]) / 2 : 0\n这个细节又暴露了Python的哲学：我已经有了if else了，还要? :干嘛，关键字的数量也要最简；而个语法应该也是从C语系转过来的小伙伴觉得最别扭的语法之一了吧....\n好废话不多说，来让我们看看效果，很中对不对：\n正所谓要精益求精，既然都做了居中，索性把对齐做个参数好了，跟居中一样的原理，我把左对齐跟右对齐也做了，只需要对draw_text_v1做一点点润色：\ndef draw_text_v2(text, image, off_set=(0, 200), allign='center'):\n    \"\"\"强化版绘制文字v2，左中右，想放哪里放哪里\n    Args:\n        text: 显示在图片上的文本\n        image: 当前正使用的Image\n        off_set: 偏移量，用于保留最小编剧，(x, y)以像素未单位\n        allign: 排版，left左对齐，center居中，right右对齐\n\n    Returns:\n        Image\n\n    Raises:\n\n    \"\"\"\n    # 加入文字\n    # ImageDraw为PIL的绘图模块\n    _DEFAULT_FONT_SIZE = 30\n    draw = ImageDraw.Draw(image)\n    imageFont = ImageFont.truetype('./resources/msyh.ttc', _DEFAULT_FONT_SIZE)\n    _MAX_TXT_HEIGH = 32\n    txtSize = draw.textsize(text, imageFont)\n    imageFont = ImageFont.truetype('./resources/msyh.ttc', 30)\n\n    # 计算x坐标\n    pos_x = {\n        # 居中对齐\n        'center': lambda max_width, txt_len, off: (max_width / 2 - txt_len / 2 if max_width > txt_len else 0) + off,\n        # 左对齐\n        'left': lambda max_width, txt_len, off: (off if max_width > txt_len else 0),\n        # 右对齐\n        'right': lambda max_width, txt_len, off: (max_width - txt_len if max_width > txt_len else 0)\n    }[allign if allign in ('center', 'left', 'right') else 'center'](CONST_IMG_WIDTH - 2*off_set[0], txtSize[0], off_set[0])\n\n    # 默认显示位置\n    pos = (pos_x, off_set[1])\n\n    # 底图上的10,200位置写入文字\n    draw.text(pos, text, fill='black', font=imageFont)\n    del draw\n    return image\n效果好像还不错：\n估计又有眼尖的小伙伴发现有个代码不对了，怎么pos_x的计算实现是如此的奇葩，我都看不懂了！\n    pos_x = {\n        # 居中对齐\n        'center': lambda max_width, txt_len, off: (max_width / 2 - txt_len / 2 if max_width > txt_len else 0) + off,\n        # 左对齐\n        'left': lambda max_width, txt_len, off: (off if max_width > txt_len else 0),\n        # 右对齐\n        'right': lambda max_width, txt_len, off: (max_width - txt_len if max_width > txt_len else 0)\n    }[allign if allign in ('center', 'left', 'right') else 'center'](CONST_IMG_WIDTH - 2*off_set[0], txtSize[0], off_set[0])\n其实这里嘛，是Python实现switch功能的一个奇技淫巧...对的，你猜的没错，Python是没有switch结构的，因为：“我们已经有了完美的if...else...要switch干嘛”，所以如果按照官方建议，这段代码应该是这样的：\n    max_width = CONST_IMG_WIDTH - 2*off_set[0]\n    txt_len = txtSize[0]\n    if allign == 'center':\n        pos_x = (max_width / 2 - txt_len / 2 if max_width > txt_len else 0) + off_set[0]\n    else if allign == 'left':\n        pos_x = off_set[0] if CONST_IMG_WIDTH - 2*off_set[0] > txt_len else 0\n    else if allign == 'right':\n        pos_x = max_width - txt_len if max_width > txt_len else 0\n    else:\n        pos_x = ((max_width / 2 - txt_len / 2 if max_width > txt_len else 0) + off_set[0]\n\n而我在实现上是采用了字典结构加上lamada表达式进行实现的，这里再多嘴一句，python的lamada表达式只支持单行只支持单行！因为官方觉得如果一个lamada表达式需要多行才能解决问题，那你还是去定义个函数吧！啊？你说上面的代码还是没搞懂？嗯...好吧，那我把代码好好讲讲。首先，代码是使用了一些简写的，我们把它拆出来：\n    def center(max_width, txt_len, off):\n        return (max_width / 2 - txt_len / 2 if max_width > txt_len else 0) + off\n\n    def left(max_width, txt_len, off):\n        return off if max_width > txt_len else 0\n\n    def right(max_width, txt_len, off):\n        return max_width - txt_len if max_width > txt_len else 0\n    \n    dict_temp = {\n        # 居中对齐\n        'center': center,\n        # 左对齐\n        'left': left,\n        # 右对齐\n        'right': right\n    }\n\n    pos_x_func = dict_temp[allign if allign in ('center', 'left', 'right') else 'center']\n    pos_x = pos_x_func(CONST_IMG_WIDTH - 2*off_set[0], txtSize[0], off_set[0])\n得益于python动态语言的特性，我们可以把所有的中间变量都去掉，就形成了样例中的那种代码结构了，这个属于加大阅读难度的（但代码看上去简洁了啊！）大家搞不懂的也无所谓，我就主要简单介绍一下lamada表达式了。从上面分解的代码可以看出，lamada实际上也是函数，有入参有返回值，但就是没了个名字，所以他实际上是一个匿名函数，其构成是这样的：\nlamada 参数1 [, 参数n] : 表达式\n记住了，Python不支持多行lamada!\n感觉这次文章基础语法扯的有点多了，之后的文章对基础语法的介绍会进一步减少的！本次的代码样例同样在我的GitHub上可以找到\n好的，那么接下来\n\n额...好吧，下次我们就来解决上面这个问题！\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}