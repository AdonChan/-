{"title": "Python基础之(五)语句 - 再读斋 ", "index": "python", "content": "运算符\n算术运算符\n前面已经讲过了四则运算，其中涉及到一些运算符：加减乘除，对应的符号分别是：+  -  *  /，此外，还有求余数的：%。这些都是算术运算符。其实，算术运算符不止这些。根据中学数学的知识，也应该想到，还应该有乘方、开方之类的。\n下面列出一个表格，将所有的运算符表现出来。\n\n\n运算符\n描述\n实例\n\n\n\n+\n加 - 两个对象相加\n10+20 输出结果 30\n\n\n-\n减 - 得到负数或是一个数减去另一个数\n10-20 输出结果 -10\n\n\n*\n乘 - 两个数相乘或是返回一个被重复若干次的字符串\n10 * 20 输出结果 200\n\n\n/\n除 - x除以y\n20/10 输出结果 2\n\n\n%\n取余 - 返回除法的余数\n20%10 输出结果 0\n\n\n**\n幂 - 返回x的y次幂\n10**2 输出结果 100\n\n\n//\n取整除 - 返回商的整数部分\n9//2 输出结果 4 , 9.0//2.0 输出结果 4.0\n\n\n\n比较运算符\n以下假设a=10，b=20：\n\n\n运算符\n描述\n实例\n\n\n\n==\n等于 - 比较对象是否相等\n(a == b) 返回 False。\n\n\n!=\n不等于 - 比较两个对象是否不相等\n(a != b) 返回 True.\n\n\n>\n大于 - 返回x是否大于y\n(a > b) 返回 False。\n\n\n<\n小于 - 返回x是否小于y\n(a < b) 返回 True。\n\n\n>=\n大于等于 - 返回x是否大于等于y。\n(a >= b) 返回 False。\n\n\n<=\n小于等于 - 返回x是否小于等于y。\n(a <= b) 返回 True。\n\n\n\n逻辑运算符\n（假设a=10，b=20）\n\n\n运算符\n描述\n实例\n\n\n\nand\n布尔\"与\" - 如果x为False，x and y返回False，否则它返回y的计算值。\n(a and b) 返回 20。\n\n\nor\n布尔\"或\" - 如果x是True，它返回True，否则它返回y的计算值。\n(a or b) 返回 10。\n\n\nnot\n布尔\"非\" - 如果x为True，返回False。如果x为False，它返回True。\nnot(a and b) 返回 false。\n\n\n\nand\nand，翻译为“与”运算，但事实上，这种翻译容易引起望文生义的理解。\n先说一下正确的理解。\nA and B，含义是：\n首先运算A，如果A的值是True，就计算B，并将B的结果返回做为最终结果，如果B是False，那么A and B的最终结果就是False，如果B的结果是True，那么A and B的结果就是True；\n如果A的值是False ，就不计算B了，直接返回A and B的结果为False.\n简单语句\nprint\n在Python 2中，print是一个语句，但是在Python 3中它是一个函数了。这点请注意。\n以Python 2为例，说明print语句。如果说读者使用的是Python 3，请自行将print xxx修改为print(xxx)，其它不变。\nprint发起的语句，在程序中主要是将某些东西打印出来，还记得在讲解字符串的时候，专门讲述了字符串的格式化输出吗？那就是用来print的。\n>>> print \"hello, world\"\nhello, world\n>>> print \"hello\",\"world\" //逗号表示打印在同一行\nhello world\n本来，在print语句中，字符串后面会接一个n符号。即换行。但是，如果要在一个字符串后面跟着逗号，那么换行就取消了，意味着两个字符串\"hello\"，\"world\"打印在同一行。\n但是，在Python 3中情况有变。默认的end='n'，如果不打算换行，可以在使用print()函数的时候，修改end这个参数的值。\n>>> for i in [1,2,3,4]:\n    print(i, end=',')\n\n1,2,3,4,\nimport\nimport引入模块的方法，是Python编程经常用到的。引用方法有如下几种：\n>>> import math\n>>> math.pow(3,2)\n9.0\n这是一种可读性非常好的引用方式，并且不同模块的同名函数不会产生冲突。\n>>> from math import pow\n>>> pow(3,2)\n9.0\n这种引用方法，比较适合于引入模块较少的时候。如果引入模块多了，可读性就下降了，会不知道那个函数来自那个模块。\n>>> from math import pow as pingfang\n>>> pingfang(3,2)\n9.0\n将从某个模块引入的函数重命名，比如讲pow充命名为pingfang，然后使用pingfang()就相当于在使用pow()了\n>>> from math import pow, e, pi\n>>> pow(e,pi)\n23.140692632779263\n引入了math模块里面的pow,e,pi，pow()是一个乘方函数，e是那个欧拉数；pi就是π.\n>>> from math import *\n>>> pow(3,2)\n9.0\n>>> sqrt(9)\n3.0\n一下将math中的所有函数都引过来了。不过，这种方式的结果是让可读性更降低了。仅适用于模块中的函数比较少的时候，并且在程序中应用比较频繁。\n事实上，不仅函数可以引入，模块中还可以包括常数等，都可以引入。在编程中，模块中可以包括各样的对象，都可以引入。\n赋值\na = 3\n>>> x, y, z = 1, \"python\", [\"hello\", \"world\"]\n>>> x\n1\n>>> y\n'python'\n>>> z\n['hello', 'world']\n>>> a = \"itdiffer.com\", \"python\"\n>>> a\n('itdiffer.com', 'python')\n原来是将右边的两个值装入了一个元组，然后将元组赋给了变量a。\n两个变量的值对调,python只要一行就完成了:\n>>> a = 2\n>>> b = 9\n>>> a, b = b, a\n>>> a\n9\n>>> b\n2\n因为我前面已经数次提到的Python中变量和对象的关系。变量相当于贴在对象上的标签。这个操作只不过是将标签换个位置，就分别指向了不同的数据对象。\n还有一种赋值方式，被称为“链式赋值”\n>>> m = n = \"I use python\"\n>>> print m, n            #Python 3：print(m, n)\nI use python I use python\n用这种方式，实现了一次性对两个变量赋值，并且值相同。\n>>> id(m)\n3072659528L\n>>> id(n)\n3072659528L\n用id()来检查一下，发现两个变量所指向的是同一个对象。\n另外，还有一种判断方法，来检查两个变量所指向的值是否是同一个（注意，同一个和相等是有差别的。在编程中，同一个就是id()的结果一样。\n>>> m is n\nTrue\n这是在检查m和n分别指向的对象是否是同一个，True说明是同一个。\n>>> a = \"I use python\"\n>>> b = a\n>>> a is b\nTrue\n这是跟上面链式赋值等效的。\n但是：\n>>> b = \"I use python\"\n>>> a is b\nFalse\n>>> id(a)\n3072659608L\n>>> id(b)\n3072659568L\n\n>>> a == b\nTrue\n看出其中的端倪了吗？这次a、b两个变量虽然相等，但不是指向同一个对象。\n还有一种赋值形式，如果从数学的角度看，是不可思议的，如：x = x + 1，在数学中，这个等式是不成立的。因为数学中的“=”是等于的含义，但是在编程语言中，它成立，因为\"=\"是赋值的含义，即将变量x增加1之后，再把得到的结果赋值变量x.\n这种变量自己变化之后将结果再赋值给自己的形式，称之为“增量赋值”。+、-、*、/、%都可以实现类似这种操作。为了让这个操作写起来省点事（要写两遍同样一个变量），可以写成：x += 1\n>>> x = 9\n>>> x += 1\n>>> x\n10\n除了数字，字符串进行增量赋值，在实际中也很有价值。\n>>> m = \"py\"\n>>> m += \"th\"\n>>> m\n'pyth'\n>>> m += \"on\"\n>>> m\n'python'\n条件语句\nif语句\n>>> a = 8\n>>> if a == 8: //冒号是必须的\n...     print a //四个空格的缩进是必须的\n...\n8\n>>>\n\n必须要通过缩进方式来表示语句块的开始和结束\n缩进用四个空格也是必须的\n\nif...elif...else\n#coding:utf-8\nprint \"请输入一个整数数字:\"\nnumber = int(raw_input())\n\nif number == 10:\n    print \"您输入的数字是： %d\" % number\n    print \"You are smart\"\nelif number > 10:\n    print \"您输入的数字是： %d\" % number\n    print \"This number is more than 10.\"\nelif number < 10:\n    print \"您输入的数字是： %d\" % number\n    print \"This number is less than 10.\"\nelse:\n    print \"Are you a human?\"\n    \n结果打印：\n\n请输入一个整数数字:\n12\n您输入的数字是： 12\nThis number is more than 10.\n\n请输入一个整数数字:\n10\n您输入的数字是： 10\nYou are smart\n\n请输入一个整数数字:\n9\n您输入的数字是： 9\nThis number is less than 10.\n三元操作符\n>>> name = \"liuguoquan\" if \"deason\" else \"xiaoniu\"\n>>> name\n'liuguoquan'\n>>> name = \"liuguoquan\" if \"\" else \"xiaoniu\"\n>>> name\n'xiaoniu'\n>>> name = \"liuguoquan\" if \"xiaoniu\" else \"\"\n>>> name\n'liuguoquan'\n总结一下：A = Y if X else Z根据上述例子可以看出：\n\n如果X为真，那么就执行A = Y\n如果X为假，那么就执行A = Z\n\n>>> a = \"python\" if x > y else \"java\"\n>>> a\n'java'\n>>> a = \"python\" if x < y else \"java\"\n>>> a\n'python'\n>>>\nfor循环\nFor循环的基本结构是：\nfor 循环规则： //需要冒号\n 操作语句        //语句要缩进\n\n简单的for循环\n>>> hello = \"liuguoquan\"\n>>> for i in hello:\n...     print i\n...\nl\ni\nu\ng\nu\no\nq\nu\na\nn\n\nor:\n\n>>> for i in range(len(hello)):\n...     print i\n...\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\nrange（start,stop,[,step])\nrange是个内建函数，一般形式是range（start,stop,[,step])\n关于range()函数注意一下几点：\n\n该函数可以创建一个数字元素组成的列表\n该函数最常用于for循环\n函数的参数必须是整数，默认从0开始\nstep默认值是1，不写就是默认值\nstep是正数，返回list最后的值不包含stop的值，即start + step的值小于stop；step是负数，start + step的值大于stop；\nstep不能等于0\n\n参数解释：\n\nstart：开始数值，默认为0\nstop：结束数值，必须要写\nstep：变化的步长，默认是1，不能为0\n\n正数\n>>> range(9)\n[0, 1, 2, 3, 4, 5, 6, 7, 8]\n>>> range(0,9)\n[0, 1, 2, 3, 4, 5, 6, 7, 8]\n>>> range(0,9,1)\n[0, 1, 2, 3, 4, 5, 6, 7, 8]\n>>> range(1,9)\n[1, 2, 3, 4, 5, 6, 7, 8]\n>>> range(1,9,2)\n[1, 3, 5, 7]\n负数\n>>> rang(-9)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nNameError: name 'rang' is not defined\n>>> range(0,-9,-1)\n[0, -1, -2, -3, -4, -5, -6, -7, -8]\n>>> range(0,-9,-2)\n[0, -2, -4, -6, -8]\n>>>\n获取列表的索引值组成的列表\n>>> lgq = [\"I\",\"am\",\"a\",\"Android\"]\n>>> index = range(len(lgq))\n>>> index\n[0, 1, 2, 3]\n>>>\n找出100以内的能够被3整除的正整数\n#coding:utf-8\nresult = []\nfor n in range(1,100):\n    if n % 3 == 0:\n        result.append(n)\n        \nprint result\n\nor:\n\nprint range(3,100,3)\n\n结果打印：\n\n[3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 51, 54, 57, 60, 63, 66, 69, 72, 75, 78, 81, 84, 87, 90, 93, 96, 99]\nfor对象\n #coding:utf-8\n\nname = \"liuguoquan\"\n\nprint \"str\"\nfor i in name:\n    print i,\n\nprint \"list\"\nname_list = list(name)\nprint name_list\nfor i in name_list:\n    print i,\n    \nprint \"set\"\nname_set = set(name)\nprint name_set\nfor i in name_set:\n    print i,\n    \nprint \"tuple\"\nname_tuple = set(name)\nprint name_tuple\nfor i in name_tuple:\n    print i,\n    \nprint \"dict\"\nname_dict = {\"name\":\"liuguoquan\",\"sex\":\"male\",\"age\":\"18\"}\nprint name_dict\nfor i in name_dict:\n    print i,\"-->\",name_dict[i]\n    \n 结果打印:\n \nstr:\nl i u g u o q u a n \n\nlist:\n['l', 'i', 'u', 'g', 'u', 'o', 'q', 'u', 'a', 'n']\nl i u g u o q u a n \n\nset:\nset(['a', 'g', 'i', 'l', 'o', 'n', 'q', 'u'])\na g i l o n q u \n\ntuple\n('l', 'i', 'u', 'g', 'u', 'o', 'q', 'u', 'a', 'n')\nl i u g u o q u a n \n\ndict:\n{'age': '18', 'name': 'liuguoquan', 'sex': 'male'}\nage --> 18\nname --> liuguoquan\nsex --> male\n字典遍历的多种写法\nname_dict = {\"name\":\"liuguoquan\",\"sex\":\"male\",\"age\":\"18\"}\nprint name_dict\nfor i in name_dict:\n    print i,\"-->\",name_dict[i]\n注意到，上面的循环，其实是读取了字典的key。在字典中，有一个方法，dict.keys()，得到的是字典key列表。\n#获取字典key列表\nfor k in name_dict.keys():\n    print k    #Python 3: print(k)\n这种循环方法和上面的循环方法，结果是一样的，但是，这种方法并不提倡，以为它在执行速度上表现欠佳。\n如果要获得字典的value怎么办？不要忘记dict.values()方法\nfor k,v in name_dict.items():\n    print k,\"-->\",v\n用上面的方法，要把所有的内容都读入内存，内存东西多了，可能会出麻烦。为此，Python中提供了另外的方法。\nfor k,v in name_dict.iteritems(): #注意：仅在Python2中可用，Python 3中已经做了优化，d.items()即有同等功能。\n    print k,\"-->\",v\n这里是循环一个迭代器，迭代器在循环中有很多优势。除了刚才的dict.iteritems()之外，还有dict.itervalues()，dict.iterkeys()供你选用（以上三个dict.iter*都只用在Python 2中，Python 3中已经不需要了）\n如何判断一个对象是不可迭代的？\n>>> import collections\n引入collections这个标准库。要判断数字321是不是可迭代的，可以这么做：\n>>> isinstance(321, collections.Iterable)\n    False\n返回了False，说明321这个整数类型的对象，是不可迭代的。再判断一个列表对象。\n >>> isinstance([1,2,3], collections.Iterable)\n    True\n从返回结果，我们知道，列表[1,2,3]是可迭代的。\n当然，并不是要你在使用for循环之前，非要判断某个对象是否可迭代。因为至此，你已经知道了字符串str、列表list、字典dict、元组tuple、集合set都是可迭代的。\nzip()\nzip()——一个内建函数,Python 2中，参数是seq1, seq2, ...，意思是序列数据；在Python 3中，参数需要时可迭代对象。这点差别，通常是没有什么影响的，因为序列也是可迭代的。值得关注的是返回值，在Python 2中，返回值是一个列表对象，里面以元组为元素；而Python 3中返回的是一个zip对象。通过实验来理解上面的文档：\nPython 2：\n    >>> a = \"qiwsir\"\n    >>> b = \"github\"\n    >>> zip(a, b)\n    [('q', 'g'), ('i', 'i'), ('w', 't'), ('s', 'h'), ('i', 'u'), ('r', 'b')]\n    \nPython 3：\n    >>> zip(a, b)\n    <zip object at 0x0000000003521D08>\n    >>> list(zip(a, b))\n    [('q', 'g'), ('i', 'i'), ('w', 't'), ('s', 'h'), ('i', 'u'), ('r', 'b')]\n如果序列长度不同，那么就以\"the length of the shortest argument sequence\"为准。\n>>> c = [1, 2, 3]\n>>> d = [9, 8, 7, 6]\n>>> zip(c, d)        #这是Python 2的结果，如果是Python 3，请仿照前面的方式显示查看\n[(1, 9), (2, 8), (3, 7)]\n>>> s = {\"name\":\"qiwsir\"}\n>>> t = {\"lang\":\"python\"}\n>>> zip(s,t)\n[('name', 'lang')]\nzip是一个内置函数，它的参数必须是序列，如果是字典，那么键视为序列。然后将序列对应的元素依次组成元组，做为一个列表的元素。\n\n问题：有两个列表，分别是：a = [1, 2, 3, 4, 5], b = [9, 8, 7, 6, 5]，要计算这两个列表中对应元素的和。\nfor循环实现\n>>> a = [1, 2, 3, 4, 5]\n>>> b = [9, 8, 7, 6, 5]\n>>> c = []\n>>> for i in range(len(a)):\n...     c.append(a[i]+b[i])\n... \n>>> c\n[10, 10, 10, 10, 10]\nzip()实现\n>>> d = []\n>>> for x,y in zip(a,b):\n...     d.append(x+y)\n... \n>>> d\n[10, 10, 10, 10, 10]\n\n问题：有一个字典，myinfor = {\"name\":\"qiwsir\", \"site\":\"qiwsir.github.io\", \"lang\":\"python\"}，将这个字典变换成：infor = {\"qiwsir\":\"name\", \"qiwsir.github.io\":\"site\", \"python\":\"lang\"}\nfor循环\n>>> myinfor = {\"name\":\"qiwsir\", \"site\":\"qiwsir.github.io\", \"lang\":\"python\"}\n>>> infor = {}\n>>> for k,v in myinfor.items():\n...     infor[v]=k\n... \n>>> infor\n{'python': 'lang', 'qiwsir.github.io': 'site', 'qiwsir': 'name'}\nzip()\n>>> dict(zip(myinfor.values(), myinfor.keys()))\n{'python': 'lang', 'qiwsir.github.io': 'site', 'qiwsir': 'name'}\nenumerate()\nenumerate()也是内建函数。\n>>> seasons = ['Spring', 'Summer', 'Fall', 'Winter']\n>>> list(enumerate(seasons))\n[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]\n    \n>>> list(enumerate(seasons, start=1))\n[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]\n如果要同时得到元素索引和元素怎么办？\nfor循环\nweek = [\"monday\",\"sunday\",\"friday\"]\nfor i in range(len(week)):\n    print week[i] + ' is ' + str(i) #注意，i是int类型，如果和前面的用+连接，必须是str类型\nenumerate\nfor (i,day) in enumerate(week):\n    print day + \" is \" + str(i)\n\n问题：将字符串中的某些字符替换为其它的字符串。原始字符串\"Do you love Canglaoshi? Canglaoshi is a good teacher.\"，请将\"Canglaoshi\"替换为\"PHP\".\nraw = \"Do you love Canglaoshi? Canglaoshi is a good teacher.\"\nprint raw\n\n#1. 先将字符串转换为列表\nraw_list = raw.split(\" \")\nprint type(raw_list)\nprint raw_list\n\n#2. 对列表中的字符串进行替换\nfor i,string in enumerate(raw_list):\n    if \"Canglaoshi\" in string:\n        raw_list[i] = \"PHP\"\n        \nprint raw_list\n\n#3. 将列表转换为字符串\nprint \" \".join(raw_list)\n列表解析\nPython有一个非常强大的功能，就是列表解析，它这样使用：\n>>> squares = [x**2 for x in range(1, 10)]\n>>> squares\n[1, 4, 9, 16, 25, 36, 49, 64, 81]\n>>> mybag = [' glass',' apple','green leaf ']   #有的前面有空格，有的后面有空格\n>>> [one.strip() for one in mybag]              #去掉元素前后的空格\n['glass', 'apple', 'green leaf']\n在很多情况下，列表解析的执行效率高，代码简洁明了。是实际写程序中经常被用到的。现在Python的两个版本，对列表解释上，还是有一点点差别的，请认真看下面的比较操作。\nPython 2:\n\n    >>> i = 1\n    >>> [ i for i in range(9)]\n    [0, 1, 2, 3, 4, 5, 6, 7, 8]\n    >>> i\n    8\n\nPython 3:\n\n    >>> i = 1\n    >>> [i for i in range(9)]\n    [0, 1, 2, 3, 4, 5, 6, 7, 8]\n    >>> i\n    1\n先i = 1，然后是一个列表解析式，非常巧合的是，列表解析式中也用了变量i。这种情况，在编程中是常常遇到的，我们通常把i=1中的变量i称为处于全局命名空间里面（命名空间，是一个新词汇，暂且用起来，后面会讲述），而列表解析式中的变量i是在列表解析内，称为处在局部命名空间。在Python 3中，for循环里的变量不再与全局命名空间的变量有关联了。\nwhile语句\nwhile\nwhile i< 5:\n    print i\n    i += 1\nprint \"quit\"\n\n0\n1\n2\n3\n4\nquit\nbreak\ni= 10\nwhile i:\n    if i % 2 == 0:\n        break\n    else:\n        print \"%d is odd number\" %i\n        i = 0\nprint \"%d is even number\" %i\n\n10 is even number\ncontinue\ni= 10\nwhile i:\n    if i % 2 == 0:\n        i -= 1\n        continue; # 继续下一次循环\n    else:\n        print \"%d is odd number\" %i\n        i -= 1\nprint \"%d is even number\" %i\nwhile...else\nwhile...else有点类似if ... else，只需要一个例子就可以理解。 当然，一遇到else了，就意味着已经不在while循环内了。\ncount = 0\nwhile count < 5:\n   print count, \" is  less than 5\"\n   count = count + 1\nelse:\n   print count, \" is not less than 5\"\n   \n执行结果：\n\n    0 is less than 5\n    1 is less than 5\n    2 is less than 5\n    3 is less than 5\n    4 is less than 5\n    5 is not less than 5\nfor...else\n除了有while...else外，还可以有for...else。这个循环也通常用在当跳出循环之后要做的事情。\nfrom math import sqrt\n\n    for n in range(99, 1, -1):\n        root = sqrt(n)\n        if root == int(root):\n            print n # 满足此条件后,不执行else\n            break\n\n    else:\n        print \"Nothing.\" # break不执行就会执行else\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "4"}