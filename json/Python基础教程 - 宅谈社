{"title": "Python基础教程 - 宅谈社 ", "index": "python", "content": "6.4.5 参数收集的逆过程\n假设有如下函数：\ndef add(x,y): return x+y\n比如说有个包含由两个相加的数字组成的元组：\nparams = (1,2)\n使用*运算符对参数进行“分配”，不过是在调用而不是在定义时使用：\n>>> add(*params)\n3\n======\n同样，可以使用 双星号 运算符来处理字典。\n假设之前定义了hello_3，那么可以这样使用：\n>>> params = {'name':Sir Robin','greeting':'Well met'}\n>>> hello_3(**params)\nWell met.Sir Robin\n星号只在 定义函数（允许使用不定数目的参数）或者 调用（“分割”字典或者序列)时才有用。\n6.5 作用域\n在执行x=1赋值语句后，名称x引用到值1。这就像是使用字典一样，键引用值。当然，变量和所对应的值用的是个“不可见”的字典。\n內建的vars函数可以返回这个字典：\n>>> x = 1\n>>> scope = vars()\n>>> scope['x']\n1\n>>> scope['x'] += 1\n>>> x\n2\n这类“不可见字典”叫做 命名空间 或者 作用域 。除了全局作用域外，每个函数调用都会创建一个新的作用域：\n>>> def foo(): x = 42\n...\n>>> x = 1\n>>> foo()\n>>> x\n1\n这里的foo函数改变（重绑定）了变量x，但是在最后的时候，x并没有变。这是因为当调用foo的时候，新的命名空间就被创建了，它作用于foo内的代码块。赋值语句x=42只在内部作用域（局部命名空间）起作用，所以它并不影响外部（全局）作用域中的x。\n函数内的变量被称为局部变量（local variable），这是与全局变量相反的概念。参数的工作原理类似于局部变量，所以用全局变量的名字作为参数名并没有问题。\n>>> def output(x): print x\n...\n>>> x = 1\n>>> y = 2\n>>> output(y)\n2\n======\n重绑定全局变量：\n如果在函数内部将值赋予一个变量，它将会自动成为局部变量——除非告知Python将其声明为全局变量：\n>>> x = 1\n>>> def change_global():\n        global x\n        x = x + 1\n        \n>>> change_global()\n>>> x\n2\n======\n嵌套作用域\nPython的函数是可以嵌套的：\ndef foo():\n    def bar():\n        print \"Hello,World！\"\n    bar()\n函数嵌套有一个很突出的应用，例如需要一个函数“创建”另一个。也就意味着可以像下面这样（在其他函数内）书写函数：\ndef multiplier(factor):\n    def multiplier(number):\n        return number*factor\n    returnmultiplyByFactor\n一个函数位于另外一个里面，外层函数返回里层函数。也就是说函数本身被返回了，但并没有被调用。重要的是返回的函数还可以访问它的定义所在的作用域。换句话说，它“带着”它的环境（和相关的局部变量）。\n每次调用外层函数，它内部的函数都被重新绑定。factor变量每次都有一个新的值。由于Python的嵌套作用域，来自（`multiplier的)外部作用域的这个变量，稍后会被内层函数访问：\n>>> double = multiplier(2)\n>>> double(5)\n10\n>>> triple = multiplier(3)\n>>> triple(3)\n9\n>>> multiplier(5)(4)\n20\n类似multiplayByFactor函数存储子封闭作用域的行为叫做闭包（closure）。\n6.6 递归\n递归的定义（包括递归函数定义）包括它们自身定义内容的引用。\n关于递归，一个类似的函数定义如下：\ndef recursion():\n    return recursion()\n理论上讲，上述程序应该永远地运行下去，然而每次调用函数都会用掉一点内存，在足够的函数调用发生后（在之前的调用返回后），空间就不够了，程序会以一个“超过最大递归深度”的错误信息结束。\n这类递归就做无穷递归（infinite recursion），类似于以while True开始的无穷循环，中间没有break或者return语句。因为（理论上讲）它永远不会结束。\n有用的递归函数包含以下几个部分：\n\n当函数直接返回值时有基本实例（最小可能性问题）\n递归实例，包括一个或者多个问题较小部分的递归调用。\n\n这里的关键就是将问题分解成小部分，递归不可能永远继续下去，因为它总是以最小可能性问题结束，而这些问题又存储在基本实例中的。\n当每次函数被调用时，针对这个调用的新命名空间会被创建，意味着当函数调用“自身”时，实际上运行的是两个不同的函数（或者说是同一个函数具有两个不同的命名空间）。实际上，可以将它想象成和同种类的一个生物进行对话的另一个生物对话。\n6.6.1 递归经典案例：阶乘和幂\n计算数n的的阶乘：\ndef factorial(n):\n    result = n\n    for i in range(1,n):\n        result *= 1\n        return result\n递归实现：\n\n1的阶乘是1；\n大于1的数n的阶乘是n乘n-1的阶乘。\n\ndef factorial(n):\n    if n == 1:\n        return 1\n    else:\n        return n * factorial(n-1)\n======\n计算幂\n例子：power(x,n)(x为n的幂次）是x自乘n-1次的结果（所以x用作乘数n次。\ndef power(x,n):\n    result = 1\n    for i in range(n):\n        result *= x\n    return result\n递归实现：\n\n对于任意数字x来说，`power(x,0)是1；\n对于任何大于0的书来说，power(x,n)是x乘以(x,n-1)的结果。\n\ndef power(x,n):\n    if n == 0:\n        return 1\n    else:\n        return x * power(x,n-1)\n6.6.2 递归经典案例：二分法查找\n递归实现：\n\n如果上下限相同，那么就是数字所在位置，返回；\n否则找到两者的中点（上下限的平均值），查找数字是在左侧还是在右侧，继续查找数字所在的那半部分。\n\ndef search(sequence,number,lower,upper):\n    if lower == upper:\n        assert number == sequence[upper]\n        return upper\n    else:\n        #整数除法//,浮点数除法/\n        middle = (lower + upper) // 2 \n        if number > sequence[middle]:\n            return search(sequence,number,middle+1,upper)\n        else:\n            return search(sequence,number,lower,middle)\n提示：标准库中的bisect模块可以非常有效地实现二分查找。\n补充：函数式编程\nPython在应对“函数式编程”方面有一些有用的函数：map、filter和reduce函数（Python3.0中都被移至fuctools模块中）。\nmap和filter在目前版本的Python并非特别有用，并且可以使用列表推导式代替。不过可以使用map函数将序列中的元素全部传递给一个函数：\n>>> map(str,range(10))        #Equivalent to [str(i) for i in range(10)]\n['0','1','2','3','4','5','6','7','8','9']\nfilter函数可以基于一个返回布尔值的函数对元素进行过滤。\n#island 判断字符变量是否为字母或数字，\n#若是则返回非零，否则返回零\n\n>>> def fun(x):\n        return x.isalnum()\n        \n>>> seq = [\"foo\",\"x41\",\"?!\",\"***\"]\n>>> filter(func,seq)\n['foo','x41']\n本例中，使用列表推导式可以不用专门定义一个函数：\n>>> [x for x in seq if x.isalnum()]\n['foo','x41']\n事实上，还有个叫做lambda表达式的特性，可以创建短小的函数。\n>>> filter(lambda x: x.isalnum().seq)\n['foo','x41']\n=======\nreduce函数一般来说不能轻松被列表推导式替代，但是通常用不到这个功能。它会将序列的前两个元素与给定的函数联合使用，并且将它们的返回值和第3个元素继续联合使用，直到整个序列都处理完毕，并且得到一个最终结果。\n可以使用reduce函数加上lambda x,y:x+y（继续使用相同的数字）:\n>>> numbers = [72,101,108,108,111,44,32,119,111,114,108,100,33]\n>>> reduce(lambda x,y:x+y,numbers)\n1161\n当然，这里也可以使用内建函数sum。\n6.7 小结\n\n抽象。抽象是隐藏多余细节的艺术。定义处理细节的函数可以让程序更抽象。\n函数定义。函数使用def语句定义。它们是由语句组成的块，可以从“外部世界”获取值（参数），也可以返回一个或者多个值作为运算的结果。\n参数。函数从参数中得到需要的信息，也就是函数调用时设定的变量。Python中有两类参数：位置参数 和 关键数参数。参数在给定默认值时是可选的。\n作用域。变量存储在作用域（也叫作命名空间）中。Python有两类主要的作用域——全局作用域 和 局部作用域。作用域可以嵌套。\n递归。 函数可以调用自身即递归。一切用递归实现的功能都能用循环实现，但是有些时候递归函数更易读。\n函数式编程。Python有一些进行函数式编程的机制。包括lambda表达式以及map、filter和reduce函数。\n\n6.7.1 本章的新函数\n| 函数          | 描述           || ------------- |:-------------| | map(func,seq[,seq,...])| 对序列中的每个元素应用函数 | | filter(fuc,seq)      | 返回其函数为真的元素的列表     |   | reduce(func,seq[,initial]) | 等同于func(func(func(seq[0],seq[1],se1[2]...     |    | sum(seq)      | 返回seq所有元素的和     |  | apply(func,args[,kwargs]]      | 调用函数，可以提供参数   |\n\n第7章 更加抽象\n在面对对象程序设计中，术语对象（object）基本上可以看做数据（特性）以及由一系列可以存取、操作这些数据的方法所组成的集合。使用对象替代全局变量和函数的原因可能有很多，其中对象最重要的优点包括以下几方面：\n\n多态（Polymorphism）：意味着可以对不同类的对象使用同样的操作，它们会像“被施了魔法一般”工作。\n封装（Encapsulation）：对外部世界隐藏对象的工作细节。\n继承（Inheritance)：以通用的类为基础建立专门的类对象。\n\n7.1.1 多态\n术语多态的意思是“有多种形式”。多态意味着就算不知道变量所引用的对象类型是什么，还是能它进行操作，而它也会根据对象（或类）类型的不同而表现出不同的行为。\nrepr函数是多态特性的代表之一，可以对任何东西使用：\ndef length_message(x):\n    print \"The length of\",repr(x),\"is\",len（x）\n>>> length_message('Fnord')\nThe length of 'Fnord' is 5\n>>> length_message([1,2,3])\nThe length of [1,2,3] is 3\n很多函数和运算符都是多态的——你写的绝大多数程序可能都是，只要使用多态函数和运算符，就会与“多态”发生关联。事实上，唯一能毁掉多态的就是使用函数显式地检查类型，比如type、isinstance以及issubclass函数等等。如果可能的话，应该尽力避免使用这些毁掉多态的方式。真正重要的是如何让对象按照你所希望的方式工作，不管它是不是真正的类型（或者类）。\n7.1.2 封装\n封装是指向程序中的其他部分隐藏对象的具体实现细节的原则。\n但是封装并不等同于多态，多态可以让用户对于不知道什么是类（对象类型）的对象进行方法调用，而封装是可以不用关心对象是如何构建的而直接进行使用。\n基本上，需要将对象进行抽象，调用方法的时候不用关心其他的东西，比如它是否干扰了全局变量。\n可以将其作为 特性（attribute） 存储。特性是作为变量构成对象的一部分，事实上方法更像是绑定到函数上的属性。\n对象有着自己的状态（state）。对象的状态由它的特性（比如名称）来描述。对象的方法可以改变它的特性。所以就像是将一大堆函数（方法）捆在一起，并且给予他们访问变量（特性）的权力。它们可以在函数调用之间保持保存的值。\n7.1.3 继承\n略\n7.2 类和类型\n7.2.1 类到底是什么\n类是一种对象，所有的对象都属于某一个类，称为类的实例（instance）。\n当一个对象所属的类是另外一个对象所属类的子集时，前者就被称为后者的 子类（subclass），所以“百灵鸟类”是“鸟类”的子类。相反，“鸟类”是“百灵鸟类”的“超类”（superclass）。但是，在面向程序设计中，子类的关系是隐式的，因为一个类的定义取决于它所支持的方法。类的所有实例都会包含这些方法，所以所有子类的所有实例都有这些方法。定义子类只是个定义更多（也有可能是重载已经存在的）方法的过程。\n7.2.2 创建自己的类\n7.2.3 特性、函数和方法\n事实上，self参数正是方法和参数的区别。方法（更专业一点可以称为绑定方法）将它们的第一个参数绑定到所属的实例上，因此无需显式提供该参数。当然也可以将特性绑定到一个普通函数上，这样就不会有特殊的self参数了：\n>>> class Class:\n    def method(self):\n        print 'I hava a self'\n\n>>> def function():\n    print \"I don't...\"\n \n>>> instance = Class()\n>>> instance.method()\nI hava a self!\n>>> instance.method =function\n>>> instance.method()\nI don't...   \n注意，self参数并不依赖于调用方法的方式，前面使用的是instance.method(实例.方法)的形式，可以随意使用其他变量引用同一个方法：\n>>> class Bird:\n    song = 'Squaawk!'\n    def sing(self):\n        print self.song\n\n>>> bird = Bird()\n>>> bird.sing()\nSquaawk!\n\n>>> birdsong = bird.sing\n>>> birdsong()\nSquaawk!\n尽管最后一个方法调用看起来与函数调用十分相似，但是变量birdsongs引用绑定方法bird.sing上，也就意味着这还是会对self参数进行访问（也就是说，它仍旧绑定到类的相同实例上）。\n再论私有化\n默认情况下，程序可以从外部访问一个对象的特性：\n>>> c.name\n'Sir Lancelot'\n>>> c.name = 'Sir Gumby'\n>>> c.getName()\n'Sir Gumby'\n为了避免这类事情的发生，应该使用私有（private）特性，这是外部对象无法访问到，但getName和setName等访问器（accessor）能够访问的特性。\nPython并不直接支持私有防暑，为了让方法或者特性变为私有（从外部无法访问），只要在它的名字前面加上双下划线即可。\nclass Secretive:\n    def __inacessible(self):\n        print \"Bet you can't see me..\"\n       \n    def accessible(self):\n        print \"The secret message is:\"\n        self.__inaccessible\n现在，__inaccessible从外界是无法访问的，而在类内部还能使用（比如从accessible）访问：\n>>> s = Secretive()\n>>> s.__inaccessible()\nTraceback (most recent call last):\n    File \"<pyshell#112>\",;ine 1, in ?\n    s.__inaccessible()\nAttributeError: Secretive instance has no attribute '__inaccessible'\n>>> s.accessible()\nThe secret message is:\nBet you can't see me...\n尽管双下划线有些奇怪，但是看起来像是其他鱼鱼中的标准的私有方法。而在类的内部定义中，所有以双下划线开始的名字都被“翻译”成前面加上单下划线类名的形式。\n>>> Secretive._Secret__inaccsible\n<unboud method Secretive.__inaccessible>\n但实际上还是能够在类外访问这些私有方法，尽管不应该这么做：\n>>> s._Secretive.__inaccessible\nBet you can't see me..\n简而言之，确保他人不会访问对象的方法和特性是不可能的，但是这类“名称变化”是提醒他们不应该访问这些函数或者特性的强有力信号。\n如果不需要使用这种方法但是又想让其他对象不要访问内部数据，那么可以使用单下划线，这不过是个习惯，但的确有实际效果。例如，前面有下划线的名字都不会被带星号的import语句（from module import *）导入。\n7.2.4 类的命名空间\n下面的两个语句几乎等价：\ndef foo(x):return x*x\nfoo = lambda X:x*x\n两者都创建了返回参数平方的函数，而且都将变量foo绑定到函数上。变量foo可以在全局（模块）范围内进行定义，也可处在局部的函数或方法内。定义类时，太阳的事情也会发生，所有位于class语句中的代码块都在特殊的命名空间中执行——类命名空间（class namespace）。这个命名空间可由类内所有成员访问。但并不是所有Python程序员都知道类的定义其实就是执行代码块。\n7.2.5 指定超类\n子类可以拓展超类的定义。将其他类名写在class语句后的圆括号内可以指定超类。\n7.2.6 检查继承\n如果想要查看一个类是否是另一个的子类，可以使用内建的issubclass函数。\n如果想要知道已知类的基类（们），可以直接使用它的特殊特性__base__:\n同样，还能使用isinstance方法检查一个对象是否是一个类的实例：\n7.2.7  多个超类\n7.2.8 接口和内省\n7.3 一些关于面向对象设计的思考\n7.4 小结\n\n第8章 异常\n8.1 什么是异常\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "7"}