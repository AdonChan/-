{"title": "python操作redis - Python全栈玩起来 ", "index": "redis,python", "content": "连接 Redis\n\nimport redis\n连接方式：redis提供了2个方法\n1：StrictRedis：实现大部分官方的命令2：Redis：是StrictRedis的子类，用于向后兼容旧版的redis。\n官方推荐使用StrictRedis方法。\n举例（普通连接）：\nimport redis\n#decode_responses=True  自动解码\nr = redis.Redis(host='127.0.0.1',port=6379,password='123456',db=0,decode_responses=True) #默认数据库为0\nr = redis.StrictRedis(host='10.10.2.14',port=6379,password='123456',decode_responses=True)\n连接池：connection pool\n管理对一个redis server的所有连接，避免每次建立，释放连接的开销。默认，每个redis实例都会维护一个自己的连接池，可以直接建立一个连接池，作为参数传给redis，这样可以实现多个redis实例共享一个连接池。\n举例（连接池）：\npool = redis.ConnectionPool(host='127.0.0.1',port=6379,password='123456',decode_responses=True)\nr = redis.Redis(connection_pool=pool)\n一 STRING 字符串的操作\n1. r.set 设置值\n#在Redis中设置值，默认不存在则创建，存在则修改\nr.set('name', 'zhangsan')\n'''参数：\n     set(name, value, ex=None, px=None, nx=False, xx=False)\n     ex，过期时间（秒）\n     px，过期时间（毫秒）\n     nx，如果设置为True，则只有name不存在时，当前set操作才执行,同setnx(name, value)\n     xx，如果设置为True，则只有name存在时，当前set操作才执行'''\n2. r.get 获取值\nr.get('name')\n3. mset 批量设置值\n#批量设置值\nr.mset(name1='zhangsan', name2='lisi')\n#或\nr.mget({\"name1\":'zhangsan', \"name2\":'lisi'})\n4. mget(keys, *args)  批量获取\n#批量获取\nprint(r.mget(\"name1\",\"name2\"))\n#或\nli=[\"name1\",\"name2\"]\nprint(r.mget(li))\n5. getset 设置新值，打印原值\n#设置新值，打印原值\ngetset(name, value)  \n\nprint(r.getset(\"name1\",\"wangwu\")) #输出:zhangsan\nprint(r.get(\"name1\")) #输出:wangwu\n6. getrange    根据字节获取子序列\n#根据字节获取子序列\ngetrange(key, start, end) \n\nr.set(\"name\",\"zhangsan\")\nprint(r.getrange(\"name\",0,3))#输出:zhan\n7. setrange    修改字符串内容，从指定字符串索引开始向后替换，如果新值太长时，则向后添加\n#修改字符串内容，从指定字符串索引开始向后替换，如果新值太长时，则向后添加\nsetrange(name, offset, value) \n\nr.set(\"name\",\"zhangsan\")\nr.setrange(\"name\",1,\"z\")\nprint(r.get(\"name\")) #输出:zzangsan\nr.setrange(\"name\",6,\"zzzzzzz\")\nprint(r.get(\"name\")) #输出:zzangszzzzzzz\n8. strlen(name)  返回name对应值的字节长度\n#返回name对应值的字节长度（一个汉字3个字节）\nr.set(\"name\",\"zhangsan\")\nprint(r.strlen(\"name\")) #输出:8\n9. incr    值的累加 amount为累加的值\n#自增mount对应的值，当mount不存在时，则创建mount＝amount，否则，则自增,amount为自增数(整数)\nincr(self, name, amount=1) \n\nprint(r.incr(\"mount\",amount=2))#输出:2\nprint(r.incr(\"mount\"))#输出:3\nprint(r.incr(\"mount\",amount=3))#输出:6\nprint(r.incr(\"mount\",amount=6))#输出:12\nprint(r.get(\"mount\")) #输出:12\n10. append    在name对应的值后面追加内容\n#在name对应的值后面追加内容\nappend(name, value)\n\nr.set(\"name\",\"zhangsan\")\nprint(r.get(\"name\"))    #输出:'zhangsan\nr.append(\"name\",\"lisi\")\nprint(r.get(\"name\"))    #输出:zhangsanlisi\n11.type    查看类型\nr.type(name)\n案例\n页面点击数\n假定我们对一系列页面需要记录点击次数。例如论坛的每个帖子都要记录点击次数，而点击次数比回帖的次数的多得多。如果使用关系数据库来存储点击，可能存在大量的行级锁争用。所以，点击数的增加使用redis的INCR命令最好不过了。\n​     当redis服务器启动时，可以从关系数据库读入点击数的初始值（1237这个页面被访问了34634次）\n>>> r.set(\"visit:1237:totals\",34634)\n\nTrue\n每当有一个页面点击，则使用INCR增加点击数即可。\n>>> r.incr(\"visit:1237:totals\")\n\n34635\n\n>>> r.incr(\"visit:1237:totals\")\n\n34636\n\n页面载入的时候则可直接获取这个值\n\n>>> r.get (\"visit:1237:totals\")\n\n'34636'\n二  Hash 操作\nredis中的Hash 在内存中类似于一个name对应一个dic来存储\n1. hset    name对应的hash中设置一个键值对（不存在，则创建，否则，修改）\n#name对应的hash中设置一个键值对（不存在，则创建，否则，修改）\nhset(name, key, value)\nr.hset(\"dic_name\",\"a1\",\"aa\")\n2. hget    在name对应的hash中根据key获取value\nr.hset(\"dic_name\",\"a1\",\"aa\")\n#在name对应的hash中根据key获取value\nhget(name,key) \n\nprint(r.hget(\"dic_name\",\"a1\"))#输出:aa\n3. hgetall    获取name对应hash的所有键值\n#获取name对应hash的所有键值\nhgetall(name)\n\nprint(r.hgetall(\"dic_name\"))\n4. hmset    在name对应的hash中批量设置键值对,mapping:字典\n#在name对应的hash中批量设置键值对,mapping:字典\nhmset(name, mapping) \n\ndic={\"a1\":\"aa\",\"b1\":\"bb\"}\nr.hmset(\"dic_name\",dic)\nprint(r.hget(\"dic_name\",\"b1\"))#输出:bb\n5. hmget    在name对应的hash中获取多个key的值\n# 在name对应的hash中获取多个key的值\nhmget(name, keys, *args) \n\nli=[\"a1\",\"b1\"]\nprint(r.hmget(\"dic_name\",li))\nprint(r.hmget(\"dic_name\",\"a1\",\"b1\"))\n6.\nhlen    获取hash中键值对的个数\nhkeys    获取hash中所有的key的值\nhvals    获取hash中所有的value的值\ndic={\"a1\":\"aa\",\"b1\":\"bb\"}\nr.hmset(\"dic_name\",dic)\n\n#hlen(name) 获取hash中键值对的个数\nprint(r.hlen(\"dic_name\"))\n\n#hkeys(name) 获取hash中所有的key的值\nprint(r.hkeys(\"dic_name\"))   # ['a1','b1']\n\n#hvals(name) 获取hash中所有的value的值\nprint(r.hvals(\"dic_name\"))\n7. hexists    检查name对应的hash是否存在当前传入的key\n#检查name对应的hash是否存在当前传入的key\nhexists(name, key)\n\nprint(r.hexists(\"dic_name\",\"a1\"))#输出:True\n8. hdel        删除指定name对应的key所在的键值对\n#删除指定name对应的key所在的键值对\nhdel(name,*keys)    \n\nr.hdel(\"dic_name\",\"a1\")\n9. hincrby    自增hash中key对应的值，不存在则创建key=amount(amount为整数)\n#自增hash中key对应的值，不存在则创建key=amount(amount为整数)\nhincrby(name, key, amount=1)\n\nprint(r.hincrby(\"demo\",\"a\",amount=2))\n10.hincrbyfloat    自增hash中key对应的值，不存在则创建key=amount(amount为浮点数)\n自增hash中key对应的值，不存在则创建key=amount(amount为浮点数)\nhincrbyfloat(name, key, amount=1.0)\n案例\n使用hash类型保存多样化对象，类似二维表结构\n当有大量类型文档的对象，文档的内容都不一样时，（即“表”没有固定的列），可以使用hash来表达。\n>>> r.hset('users:jdoe',  'name', \"John Doe\")\n\n1L\n\n>>> r.hset('users:jdoe', 'email', 'John@test.com')\n\n1L\n\n>>> r.hset('users:jdoe',  'phone', '1555313940')\n\n1L\n\n>>> r.hincrby('users:jdoe', 'visits', 1)\n\n1L\n\n>>> r.hgetall('users:jdoe')\n\n{'phone': '1555313940', 'name': 'John Doe', 'visits': '1', 'email': 'John@test.com'}\n\n>>> r.hkeys('users:jdoe')\n\n['name', 'email', 'phone', 'visits']\n三  List 操作\nredis中的List在内存中按照一个name对应一个List来存储\n1. lpush     在name对应的list中添加元素，每个新的元素都添加到列表的最左边\n# 在name对应的list中添加元素，每个新的元素都添加到列表的最左边\nlpush(name,values)\n\nr.lpush(\"list_name\",2)\nr.lpush(\"list_name\",3,4,5)#保存在列表中的顺序为5，4，3，2\n2.rpush     同lpush，但每个新的元素都添加到列表的最右边\n#同lpush，但每个新的元素都添加到列表的最右边\nrpush(name,values)\n3. lpushx    在name对应的list中添加元素，只有name已经存在时，值添加到列表的最左边\n#在name对应的list中添加元素，只有name已经存在时，值添加到列表的最左边\n lpushx(name,value)\n4. rpushx    在name对应的list中添加元素，只有name已经存在时，值添加到列表的最右边\n#在name对应的list中添加元素，只有name已经存在时，值添加到列表的最右边\n rpushx(name,value)\n5. llen    name对应的list元素的个数\n# name对应的list元素的个数\nllen(name)\n\nprint(r.llen(\"list_name\"))\n6. linsert    在name对应的列表的某一个值前或后插入一个新值\n# 在name对应的列表的某一个值前或后插入一个新值\n linsert(name, where, refvalue, value))\nr.linsert(\"list_name\",\"BEFORE\",\"2\",\"SS\")#在列表内找到第一个元素2，在它前面插入SS\n\n'''参数：\n     name: redis的name\n     where: BEFORE（前）或AFTER（后）\n     refvalue: 列表内的值\n     value: 要插入的数据'''\n7. r.lset    对list中的某一个索引位置重新赋值\n#对list中的某一个索引位置重新赋值\nr.lset(name, index, varlue)\n\nr.lset(\"list_name\",0,\"bbb\")\n8. r.lrem     删除name对应的list中的指定值\n#删除name对应的list中的指定值\nr.lrem(name, value, num=0) \nr.lrem(\"list_name\",'ssss',2)\n\n''' 参数：\n    name:  redis的name\n    value: 要删除的值\n    num:   num=0 删除列表中所有的指定值；\n           num=2 从前到后，删除2个；\n           num=-2 从后向前，删除2个'''\n9. lpop     移除列表的左侧第一个元素，返回值则是第一个元素\n#移除列表的左侧第一个元素，返回值则是第一个元素\nlpop(name) \n\nprint(r.lpop(\"list_name\"))\n10. lindex    根据索引获取列表内元素\n#根据索引获取列表内元素\nlindex(name, index)\n\nprint(r.lindex(\"list_name\",1))\n11. lrange    分片获取元素\n#分片获取元素\nlrange(name, start, end)\n\nprint(r.lrange(\"list_name\",0,-1))\n12. ltrim    移除列表内没有在该索引之内的值(裁剪)\n#移除列表内没有在该索引之内的值\nltrim(name, start, end)\n\nr.ltrim(\"list_name\",0,2)\n13. rpoplpush(src, dst) 从一个列表取出最右边的元素，同时将其添加至另一个列表的最左边\n# 从一个列表取出最右边的元素，同时将其添加至另一个列表的最左边\n#src 要取数据的列表\n#dst 要添加数据的列表\n四 Set 操作\nSet集合就是不允许重复的列表\n1. sadd(name,values)  给name对应的集合中添加元素\n#给name对应的集合中添加元素\nr.sadd(\"set_name\",\"aa\")\nr.sadd(\"set_name\",\"aa\",\"bb\")\n2. smembers(name)    获取name对应的集合的所有成员\n#获取name对应的集合的所有成员\n3.  scard(name)    获取name对应的集合中的元素个数\n#获取name对应的集合中的元素个数\nr.scard(\"set_name\")\n4. sdiff(keys, *args)  在第一个name对应的集合中且不在其他name对应的集合的元素集合\n#在第一个name对应的集合中且不在其他name对应的集合的元素集合\nr.sadd(\"set_name\",\"aa\",\"bb\")\nr.sadd(\"set_name1\",\"bb\",\"cc\")\nr.sadd(\"set_name2\",\"bb\",\"cc\",\"dd\")\n\nprint(r.sdiff(\"set_name\",\"set_name1\",\"set_name2\"))#输出:｛aa｝\n6. sinter(keys, *args)        获取多个name对应集合的并集\n# 获取多个name对应集合的并集\nr.sadd(\"set_name\",\"aa\",\"bb\")\nr.sadd(\"set_name1\",\"bb\",\"cc\")\nr.sadd(\"set_name2\",\"bb\",\"cc\",\"dd\")\n\nprint(r.sinter(\"set_name\",\"set_name1\",\"set_name2\"))#输出:｛bb｝\n8.sismember    检查value是否是name对应的集合内的元素\n#检查value是否是name对应的集合内的元素\nsismember(name, value)\n9. smove(src, dst, value)    将某个元素从一个集合中移动到另外一个集合\n#将某个元素从一个集合中移动到另外一个集合\n10. spop(name)    从集合的右侧移除一个元素，并将其返回\n#从集合的右侧移除一个元素，并将其返回\n11. srandmember(name, numbers)    从name对应的集合中随机获取numbers个元素\n# 从name对应的集合中随机获取numbers个元素\nprint(r.srandmember(\"set_name2\",2))\n12. srem(name, values)    删除name对应的集合中的某些值\n#删除name对应的集合中的某些值\nprint(r.srem(\"set_name2\",\"bb\",\"dd\"))\n13. sunion(keys, *args)    获取多个name对应的集合的并集\n#获取多个name对应的集合的并集\nr.sunion(\"set_name\",\"set_name1\",\"set_name2\")\n14. sunionstore(dest,keys, *args)    获取多个name对应的集合的并集，并将结果保存到dest对应的集合中\n#获取多个name对应的集合的并集，并将结果保存到dest对应的集合中\n案例\n社交圈子数据\n在社交网站中，每一个圈子(circle)都有自己的用户群。通过圈子可以找到有共同特征（比如某一体育活动、游戏、电影等爱好者）的人。当一个用户加入一个或几个圈子后，系统可以向这个用户推荐圈子中的人。​ 我们定义这样两个圈子,并加入一些圈子成员。\n>>> r.sadd('circle:game:lol','user:debugo')\n1\n>>> r.sadd('circle:game:lol','user:leo')\n1\n>>> r.sadd('circle:game:lol','user:Guo')\n1\n>>> r.sadd('circle:soccer:InterMilan','user:Guo')\n1\n>>> r.sadd('circle:soccer:InterMilan','user:Levis')\n1\n>>> r.sadd('circle:soccer:InterMilan','user:leo')\n1\n获取一个圈子的成员\n>>> r.smembers('circle:game:lol')\nset(['user:Guo', 'user:debugo', 'user:leo'])\n可以使用集合运算来得到几个圈子的共同成员：\n>>> r.sinter('circle:game:lol', 'circle:soccer:InterMilan')\nset(['user:Guo', 'user:leo'])\n>>> r.sunion('circle:game:lol', 'circle:soccer:InterMilan')\nset(['user:Levis', 'user:Guo', 'user:debugo', 'user:leo'])\n\n五 有序集合 zset\n有序集合：\n　　在集合的基础上，为每元素排序，元素的排序需要根据另外一个值来进行比较，所以，对于有序集合，每一个元素有两个值，即：值和分数，分数专门用来做排序。\n1. zadd(name, args, *kwargs)\n# 在name对应的有序集合中添加元素\nr.zadd(\"zset_name\", 6,\"a1\", 2, \"a2\", 5,\"a3\")\n#或\nr.zadd('zset_name1', b1=10, b2=5)\n2. zcard(name)  获取有序集合内元素的数量\n#获取有序集合内元素的数量\n3. zcount(name, min, max)  获取有序集合中分数在[min,max]之间的个数\n#获取有序集合中分数在[min,max]之间的个数\nprint(r.zcount(\"zset_name\",1,5))\n4. zincrby(name, value, amount)  自增有序集合内value对应的分数\n#自增有序集合内value对应的分数\nr.zincrby(\"zset_name\",\"a1\",amount=2)#自增zset_name对应的有序集合里a1对应的分数\n\nr.zincrby(\"zset_name\",\"a1\") # 如果不指定a1 则自动创建a1，并将score设为1，再次执行则a1的score变为2，以此类推\n5. zrange( name, start, end, desc=False, withscores=False, score_cast_func=float)\n# 按照索引范围获取name对应的有序集合的元素\naa=r.zrange(\"zset_name\",0,1,desc=False,withscores=True,score_cast_func=int)\nprint(aa)\n'''参数：\n    name    redis的name\n    start   有序集合索引起始位置\n    end     有序集合索引结束位置\n    desc    排序规则，默认按照分数从小到大排序\n    withscores  是否获取元素的分数，默认只获取元素的值\n    score_cast_func 对分数进行数据转换的函数'''\n6.  zrevrange(name, start, end, withscores=False, score_cast_func=float)\n#同zrange，集合是从大到小排序的\n[(value1, score1),(value2, score2)..]\n7. zrank(name, value)、zrevrank(name, value)\n#获取value值在name对应的有序集合中的排行位置（从0开始）\nprint(r.zrank(\"zset_name\", \"a2\"))\n\nprint(r.zrevrank(\"zset_name\", \"a2\"))#从大到小排序\n8. zscore(name, value)  获取name对应有序集合中 value 对应的分数\n#获取name对应有序集合中 value 对应的分数\nprint(r.zscore(\"zset_name\",\"a1\"))\n9. zrem(name, values)  删除name对应的有序集合中值是values的成员\n#删除name对应的有序集合中值是values的成员\nr.zrem(\"zset_name\",\"a1\",\"a2\")\n10. zremrangebyrank(name, min, max)  根据排行范围删除\n#根据排行范围删除\n11. zremrangebyscore(name, min, max)  根据分数范围删除\n#根据分数范围删除\n12. zinterstore(dest, keys, aggregate=None)\nr.zadd(\"zset_name\", \"a1\", 6, \"a2\", 2,\"a3\",5)\nr.zadd('zset_name1', a1=7,b1=10, b2=5)\n\n# 获取两个有序集合的交集并放入dest集合，如果遇到相同值不同分数，则按照aggregate进行操作\n# aggregate的值为: SUM  MIN  MAX\nr.zinterstore(\"zset_name2\",(\"zset_name1\",\"zset_name\"),aggregate=\"MAX\")\nprint(r.zscan(\"zset_name2\"))\n13. zunionstore(dest, keys, aggregate=None)\n#获取两个有序集合的并集并放入dest集合，其他同zinterstore，\n其他常用操作\n1. delete(*names)  根据name删除redis中的任意数据类型\n#根据name删除redis中的任意数据类型\n2. exists(name)  检测redis的name是否存在\n#检测redis的name是否存在\n3. keys(pattern='*')  根据* ？等通配符匹配获取redis的name\n#根据* ？等通配符匹配获取redis的name\n4. expire(name ,time)  为某个name设置超时时间\n# 为某个name设置超时时间\n5. rename(src, dst)   重命名\n# 重命名\n6. move(name, db))  将redis的某个值移动到指定的db下\n# 将redis的某个值移动到指定的db下\n7. randomkey()  随机获取一个redis的name（不删除）\n#随机获取一个redis的name（不删除）\n8. type(name)  获取name对应值的类型\n# 获取name对应值的类型\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "3"}