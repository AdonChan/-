{"title": "[译]使用Flask实现RESTful API - nummy的专栏 ", "index": "python,rest-api,restful,flask", "content": "原创译文，如需转载，请联系译者。 我的简书博客:nummy\n原文地址:Implementing a RESTful Web API with Python & Flask\n简介\n首先，安装Flask\npip install flask\n阅读这篇文章之前我假设你已经了解RESTful API的相关概念，如果不清楚，可以阅读我之前写的这篇博客[Designing a RESTful Web API.](http://blog.luisrei.com/articles/rest.html)\nFlask是一个使用Python开发的基于Werkzeug的Web框架。Flask非常适合于开发RESTful API，因为它具有以下特点：\n\n使用Python进行开发，Python简洁易懂\n容易上手\n灵活\n可以部署到不同的环境\n支持RESTful请求分发\n\n我一般是用curl命令进行测试，除此之外，还可以使用Chrome浏览器的postman扩展。\n资源\n首先，我创建一个完整的应用，支持响应/, /articles以及/article/:id。\nfrom flask import Flask, url_for\napp = Flask(__name__)\n\n@app.route('/')\ndef api_root():\n    return 'Welcome'\n\n@app.route('/articles')\ndef api_articles():\n    return 'List of ' + url_for('api_articles')\n\n@app.route('/articles/<articleid>')\ndef api_article(articleid):\n    return 'You are reading ' + articleid\n\nif __name__ == '__main__':\n    app.run()\n可以使用curl命令发送请求：\ncurl http://127.0.0.1:5000/\n响应结果分别如下所示：\nGET /\nWelcome\n\nGET /articles\nList of /articles\n\nGET /articles/123\nYou are reading 123\n路由中还可以使用类型定义:\n@app.route('/articles/<articleid>')\n上面的路由可以替换成下面的例子：\n@app.route('/articles/<int:articleid>')\n@app.route('/articles/<float:articleid>')\n@app.route('/articles/<path:articleid>')\n默认的类型为字符串。\n请求\n请求参数\n假设需要响应一个/hello请求，使用get方法，并传递参数name\nfrom flask import request\n\n@app.route('/hello')\ndef api_hello():\n    if 'name' in request.args:\n        return 'Hello ' + request.args['name']\n    else:\n        return 'Hello John Doe'\n服务器会返回如下响应信息：\nGET /hello\nHello John Doe\n\nGET /hello?name=Luis\nHello Luis\n请求方法\nFlask支持不同的请求方法：\n@app.route('/echo', methods = ['GET', 'POST', 'PATCH', 'PUT', 'DELETE'])\ndef api_echo():\n    if request.method == 'GET':\n        return \"ECHO: GET\\n\"\n\n    elif request.method == 'POST':\n        return \"ECHO: POST\\n\"\n\n    elif request.method == 'PATCH':\n        return \"ECHO: PACTH\\n\"\n\n    elif request.method == 'PUT':\n        return \"ECHO: PUT\\n\"\n\n    elif request.method == 'DELETE':\n        return \"ECHO: DELETE\"\n可以使用如下命令进行测试:\ncurl -X PATCH http://127.0.0.1:5000/echo\n不同请求方法的响应如下：\nGET /echo\nECHO: GET\n\nPOST /ECHO\nECHO: POST\n...\n请求数据和请求头\n通常使用POST方法和PATCH方法的时候，都会发送附加的数据，这些数据的格式可能如下：普通文本(plain text)， JSON，XML，二进制文件或者用户自定义格式。Flask中使用request.headers类字典对象来获取请求头信息，使用request.data 获取请求数据，如果发送类型是application/json，则可以使用request.get_json()来获取JSON数据。\nfrom flask import json\n\n@app.route('/messages', methods = ['POST'])\ndef api_message():\n\n    if request.headers['Content-Type'] == 'text/plain':\n        return \"Text Message: \" + request.data\n\n    elif request.headers['Content-Type'] == 'application/json':\n        return \"JSON Message: \" + json.dumps(request.json)\n\n    elif request.headers['Content-Type'] == 'application/octet-stream':\n        f = open('./binary', 'wb')\n        f.write(request.data)\n                f.close()\n        return \"Binary message written!\"\n\n    else:\n        return \"415 Unsupported Media Type ;)\"\n使用如下命令指定请求数据类型进行测试：\ncurl -H \"Content-type: application/json\" \\\n-X POST http://127.0.0.1:5000/messages -d '{\"message\":\"Hello Data\"}'\n使用下面的curl命令来发送一个文件:\ncurl -H \"Content-type: application/octet-stream\" \\\n-X POST http://127.0.0.1:5000/messages --data-binary @message.bin\n不同数据类型的响应结果如下所示：\nPOST /messages {\"message\": \"Hello Data\"}\nContent-type: application/json\nJSON Message: {\"message\": \"Hello Data\"}\n\nPOST /message <message.bin>\nContent-type: application/octet-stream\nBinary message written!\n注意Flask可以通过request.files获取上传的文件，curl可以使用-F选项模拟上传文件的过程。\n响应\nFlask使用Response类处理响应。\nfrom flask import Response\n\n@app.route('/hello', methods = ['GET'])\ndef api_hello():\n    data = {\n        'hello'  : 'world',\n        'number' : 3\n    }\n    js = json.dumps(data)\n\n    resp = Response(js, status=200, mimetype='application/json')\n    resp.headers['Link'] = 'http://luisrei.com'\n\n    return resp\n使用-i选项可以获取响应信息：\ncurl -i http://127.0.0.1:5000/hello\n返回的响应信息如下所示：\nGET /hello\nHTTP/1.0 200 OK\nContent-Type: application/json\nContent-Length: 31\nLink: http://luisrei.com\nServer: Werkzeug/0.8.2 Python/2.7.1\nDate: Wed, 25 Apr 2012 16:40:27 GMT\n{\"hello\": \"world\", \"number\": 3}\nmimetype指定了响应数据的类型。上面的过程可以使用Flask提供的一个简便方法实现：\nfrom flask import jsonify\n...\n# 将下面的代码替换成\nresp = Response(js, status=200, mimetype='application/json')\n# 这里的代码\nresp = jsonify(data)\nresp.status_code = 200\n状态码和错误处理\n如果成功响应的话，状态码为200。对于404错误我们可以这样处理：\n@app.errorhandler(404)\ndef not_found(error=None):\n    message = {\n            'status': 404,\n            'message': 'Not Found: ' + request.url,\n    }\n    resp = jsonify(message)\n    resp.status_code = 404\n\n    return resp\n\n@app.route('/users/<userid>', methods = ['GET'])\ndef api_users(userid):\n    users = {'1':'john', '2':'steve', '3':'bill'}\n    \n    if userid in users:\n        return jsonify({userid:users[userid]})\n    else:\n        return not_found()\n测试上面的两个URL，结果如下：\nGET /users/2\nHTTP/1.0 200 OK\n{\n    \"2\": \"steve\"\n}\n\nGET /users/4\nHTTP/1.0 404 NOT FOUND\n{\n\"status\": 404, \n\"message\": \"Not Found: http://127.0.0.1:5000/users/4\"\n}\n默认的Flask错误处理可以使用@error_handler修饰器进行覆盖或者使用下面的方法：\napp.error_handler_spec[None][404] = not_found\n即使API不需要自定义错误信息，最好还是像上面这样做，因为Flask默认返回的错误信息是HTML格式的。\n认证\n使用下面的代码可以处理 HTTP Basic Authentication。\nfrom functools import wraps\n\ndef check_auth(username, password):\n    return username == 'admin' and password == 'secret'\n\ndef authenticate():\n    message = {'message': \"Authenticate.\"}\n    resp = jsonify(message)\n\n    resp.status_code = 401\n    resp.headers['WWW-Authenticate'] = 'Basic realm=\"Example\"'\n\n    return resp\n\ndef requires_auth(f):\n    @wraps(f)\n    def decorated(*args, **kwargs):\n        auth = request.authorization\n        if not auth: \n            return authenticate()\n\n        elif not check_auth(auth.username, auth.password):\n            return authenticate()\n        return f(*args, **kwargs)\n\n    return decorated\n接下来只需要给路由增加@require_auth修饰器就可以在请求之前进行认证了：\n@app.route('/secrets')\n@requires_auth\ndef api_hello():\n    return \"Shhh this is top secret spy stuff!\"\n现在，如果没有通过认证的话，响应如下所示：\nGET /secrets\nHTTP/1.0 401 UNAUTHORIZED\nWWW-Authenticate: Basic realm=\"Example\"\n{\n  \"message\": \"Authenticate.\"\n}\ncurl通过-u选项来指定HTTP basic authentication，使用-v选项打印请求头：\ncurl -v -u \"admin:secret\" http://127.0.0.1:5000/secrets\n响应结果如下：\nGET /secrets Authorization: Basic YWRtaW46c2VjcmV0\nShhh this is top secret spy stuff!\nFlask使用MultiDict来存储头部信息，为了给客户端展示不同的认证机制，可以给header添加更多的WWW-Autheticate。\nresp.headers['WWW-Authenticate'] = 'Basic realm=\"Example\"'resp.headers.add('WWW-Authenticate', 'Bearer realm=\"Example\"')\n调试与日志\n通过设置debug=True来开启调试信息：\napp.run(debug=True)\n使用Python的logging模块可以设置日志信息：\nimport logging\nfile_handler = logging.FileHandler('app.log')\napp.logger.addHandler(file_handler)\napp.logger.setLevel(logging.INFO)\n\n@app.route('/hello', methods = ['GET'])\ndef api_hello():\n    app.logger.info('informing')\n    app.logger.warning('warning')\n    app.logger.error('screaming bloody murder!')\n    \n    return \"check your logs\\n\"\nCURL 命令参考\n\n\n选项\n作用\n\n\n\n-X\n指定HTTP请求方法，如POST，GET\n\n\n-H\n指定请求头，例如Content-type:application/json\n\n\n-d\n指定请求数据\n\n\n--data-binary\n指定发送的文件\n\n\n-i\n显示响应头部信息\n\n\n-u\n指定认证用户名与密码\n\n\n-v\n输出请求头部信息\n\n\n\n \n\n                ", "mainLikeNum": ["4 "], "mainBookmarkNum": "39"}