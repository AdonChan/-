{"title": "python综合学习一之多线程 - Corwien ", "index": "python", "content": "本文记录学习Python遇到的问题和一些常用用法，注本开发环境的Python版本为2.7。\n一、python文件命名\n在python文件命名时，一定要注意不能和系统默认的模块名冲突，否则会报错。如下面的例子，在学习线程时，将文件名命名为 threading.py,Python脚本完全正常没问题，结果报下面的错误：AttributeError: 'module' object has no attribute 'xxx'。\nthreading.py\n# -*- coding:utf-8 -*-\n\n\"\"\"\n@author: Corwien\n@file: threading_test.py\n@time: 18/8/25 09:14\n\"\"\"\n\nimport threading\n\n# 获取已激活的线程数\nprint(threading.active_count())\n\n执行：\n➜  baseLearn python threading/threading.py\nTraceback (most recent call last):\n  File \"threading/threading.py\", line 9, in <module>\n    import threading\n  File \"/Users/kaiyiwang/Code/python/baseLearn/threading/threading.py\", line 12, in <module>\n    print(threading.active_count())\nAttributeError: 'module' object has no attribute 'active_count'\n➜  baseLearn\n问题定位：\n查看import库的源文件，发现源文件存在且没有错误，同时存在源文件的.pyc文件\n问题解决：\n\n1.命名py脚本时，不要与python预留字，模块名等相同\n\n2.删除该库的.pyc文件（因为py脚本每次运行时均会生成.pyc文件；在已经生成.pyc文件的情况下，若代码不更新，运行时依旧会走pyc，所以要删除.pyc文件），重新运行代码；或者找一个可以运行代码的环境，拷贝替换当前机器的.pyc文件即可\n\n将脚本文件名重新命名为threading_test.py，然后执行，就不会报错了。\n➜  baseLearn python threading/threading_test.py\n1\n➜  baseLearn\n二、多线程threading\n多线程是加速程序计算的有效方式，Python的多线程模块threading上手快速简单，从这节开始我们就教大家如何使用它。\n1、添加线程\nthreading_test.py\n# -*- coding:utf-8 -*-\n\n\"\"\"\n@author: Corwien\n@file: threading_test.py\n@time: 18/8/25 09:14\n\"\"\"\n\nimport threading\n\n# 获取已激活的线程数\n# print(threading.active_count())\n\n# 查看所有线程信息\n# print(threading.enumerate())\n\n# 查看现在正在运行的线程\n# print(threading.current_thread())\n\ndef thread_job():\n    print('This is a thread of %s' % threading.current_thread())\n\n\ndef main():\n    thread = threading.Thread(target=thread_job,)  # 定义线程\n    thread.start() # 让线程开始工作\n\nif __name__ == '__main__':\n    main()\n\n2、join功能\n不加 join() 的结果\n我们让 T1 线程工作的耗时增加\nthreading_join.py\n# -*- coding:utf-8 -*-\n\n\"\"\"\n@author: Corwien\n@file: threading_join.py\n@time: 18/8/25 09:14\n\"\"\"\n\nimport threading\nimport time\n\ndef thread_job():\n    print('T1 start\\n')\n    for i in range(10):\n        time.sleep(0.1) # 任务时间0.1s\n    print(\"T1 finish\\n\")\n\n\ndef main():\n    added_thread = threading.Thread(target=thread_job, name='T1')  # 定义线程\n    added_thread.start() # 让线程开始工作\n    print(\"all done\\n\")\n\nif __name__ == '__main__':\n    main()\n\n预想中输出的结果是按照顺序依次往下执行：\nT1 start\nT1 finish\nall done\n但实际运行结果为：\n➜  baseLearn python threading/threading_join.py\nT1 start\nall done\n\n\nT1 finish\n\n➜  baseLearn\n加入join()的结果\n线程任务还未完成便输出all done。如果要遵循顺序，可以在启动线程后对它调用join：\nadded_thread.start()\nadded_thread.join()\nprint(\"all done\\n\")\n打印结果：\n➜  baseLearn python threading/threading_join.py\nT1 start\n\nT1 finish\n\nall done\n完整脚本文件：\n# -*- coding:utf-8 -*-\n\n\"\"\"\n@author: Corwien\n@file: threading_join.py\n@time: 18/8/25 09:14\n\"\"\"\n\nimport threading\nimport time\n\ndef thread_job():\n    print('T1 start\\n')\n    for i in range(10):\n        time.sleep(0.1) # 任务时间0.1s\n    print(\"T1 finish\\n\")\n\n\ndef main():\n    added_thread = threading.Thread(target=thread_job, name='T1')  # 定义线程\n    added_thread.start() # 让线程开始工作\n    added_thread.join()\n    print(\"all done\\n\")\n\nif __name__ == '__main__':\n    main()\n\n\n小试牛刀\n如果添加两个线程，打印的输出结果是怎样的呢？\n# -*- coding:utf-8 -*-\n\n\"\"\"\n@author: Corwien\n@file: threading_join.py\n@time: 18/8/25 09:14\n\"\"\"\n\nimport threading\nimport time\n\ndef T1_job():\n    print('T1 start\\n')\n    for i in range(10):\n        time.sleep(0.1) # 任务时间0.1s\n    print(\"T1 finish\\n\")\n\ndef T2_job():\n    print(\"T2 start\\n\")\n    print(\"T2 finish\\n\")\n\ndef main():\n    thread_1 = threading.Thread(target=T1_job, name='T1')  # 定义线程\n    thread_2 = threading.Thread(target=T2_job, name='T2')  # 定义线程\n    thread_1.start()  # 开启T1\n    thread_2.start()  # 开启T2\n    print(\"all done\\n\")\n\nif __name__ == '__main__':\n    main()\n\n输出的”一种”结果是：\nT1 start\n\nT2 start\n\nT2 finish\n\nall done\n\nT1 finish\n现在T1和T2都没有join，注意这里说”一种”是因为all done的出现完全取决于两个线程的执行速度， 完全有可能T2 finish出现在all done之后。这种杂乱的执行方式是我们不能忍受的，因此要使用join加以控制。\n我们试试在T1启动后，T2启动前加上thread_1.join():\nthread_1.start()\nthread_1.join() # notice the difference!\nthread_2.start()\nprint(\"all done\\n\")\n打印结果：\nT1 start\n\nT1 finish\n\nT2 start\nall done\n\nT2 finish\n可以看到，T2会等待T1结束后才开始运行。\n3、储存进程结果Queue\n实现功能\n代码实现功能，将数据列表中的数据传入，使用四个线程处理，将结果保存在Queue中，线程执行完后，从Queue中获取存储的结果\n在多线程函数中定义一个Queue，用来保存返回值，代替return，定义一个多线程列表，初始化一个多维数据列表，用来处理：\nthreading_queue.py\n# -*- coding:utf-8 -*-\n\n\"\"\"\n@author: Corwien\n@file: threading_queue.py\n@time: 18/8/25 09:14\n\"\"\"\n\nimport threading\nimport time\nfrom queue import Queue\n\ndef job(l, q):\n    for i in range(len(l)):\n        l[i] = l[i] ** 2\n    q.put(l) #多线程调用的函数不能用return返回值\n\ndef multithreading():\n    q = Queue()  #q中存放返回值，代替return的返回值\n    threads = []\n    data = [[1,2,3],[3,4,5],[4,4,4],[5,5,5]]\n\n    for i in range(4): #定义四个线程\n        t = threading.Thread(target=job, args=(data[i], q))  #Thread首字母要大写，被调用的job函数没有括号，只是一个索引，参数在后面\n        t.start() #开始线程\n        threads.append(t) #把每个线程append到线程列表中\n\n    for thread in threads:\n        thread.join()\n\n    results = []\n    for _ in range(4):\n        results.append(q.get()) #q.get()按顺序从q中拿出一个值\n    print(results)\n\n\nif __name__ == '__main__':\n    multithreading()\n\n执行上边的脚本出现了这样的错误：\n➜  baseLearn python threading/threading_queue.py\nTraceback (most recent call last):\n  File \"threading/threading_queue.py\", line 11, in <module>\n    from queue import Queue\nImportError: No module named queue\n查了下原因，是因为python版本导致的:解决方法：No module named 'Queue'\nOn Python 2, the module is named Queue, on Python 3, it was renamed to follow PEP8 guidelines (all lowercase for module names), making it queue. The class remains Queue on all versions (following PEP8).\nTypically, the way you'd write version portable imports would be to do:\npython3 中这样引用：\ntry:\n    import queue\nexcept ImportError:\n    import Queue as queue\n在 python2 中 我们可以这样引用：\nfrom Queue import Queue\n\n打印：\nbaseLearn python ./threading/threading_queue.py\n[[1, 4, 9], [9, 16, 25], [16, 16, 16], [25, 25, 25]]\n完整代码：threading_queue.py\n# -*- coding:utf-8 -*-\n\n\"\"\"\n@author: Corwien\n@file: threading_queue.py\n@time: 18/8/25 09:14\n\"\"\"\n\nimport threading\n# import time\nfrom Queue import Queue\n\ndef job(l, q):\n    for i in range(len(l)):\n        l[i] = l[i] ** 2\n    q.put(l) #多线程调用的函数不能用return返回值\n\ndef multithreading():\n    q = Queue()  #q中存放返回值，代替return的返回值\n    threads = []\n    data = [[1,2,3],[3,4,5],[4,4,4],[5,5,5]]\n\n    for i in range(4): #定义四个线程\n        t = threading.Thread(target=job, args=(data[i], q))  #Thread首字母要大写，被调用的job函数没有括号，只是一个索引，参数在后面\n        t.start() #开始线程\n        threads.append(t) #把每个线程append到线程列表中\n\n    for thread in threads:\n        thread.join()\n\n    results = []\n    for _ in range(4):\n        results.append(q.get()) #q.get()按顺序从q中拿出一个值\n    print(results)\n\n\nif __name__ == '__main__':\n    multithreading()\n\n4、GIL效率问题\n何为 GIL？\n这次我们来看看为什么说 python 的多线程 threading 有时候并不是特别理想. 最主要的原因是就是, Python 的设计上, 有一个必要的环节, 就是 Global Interpreter Lock (GIL)。 这个东西让 Python 还是一次性只能处理一个东西。\nGIL的解释：\n尽管Python完全支持多线程编程， 但是解释器的C语言实现部分在完全并行执行时并不是线程安全的。 实际上，解释器被一个全局解释器锁保护着，它确保任何时候都只有一个Python线程执行。 GIL最大的问题就是Python的多线程程序并不能利用多核CPU的优势 （比如一个使用了多个线程的计算密集型程序只会在一个单CPU上面运行）。\n在讨论普通的GIL之前，有一点要强调的是GIL只会影响到那些严重依赖CPU的程序（比如计算型的）。 如果你的程序大部分只会涉及到I/O，比如网络交互，那么使用多线程就很合适， 因为它们大部分时间都在等待。实际上，你完全可以放心的创建几千个Python线程， 现代操作系统运行这么多线程没有任何压力，没啥可担心的。\n测试GIL\n我们创建一个 job, 分别用 threading 和 一般的方式执行这段程序. 并且创建一个 list 来存放我们要处理的数据. 在 Normal 的时候, 我们这个 list 扩展4倍, 在 threading 的时候, 我们建立4个线程, 并对运行时间进行对比.\nthreading_gil.py\n# -*- coding:utf-8 -*-\n\n\"\"\"\n@author: Corwien\n@file: threading_gil.py\n@time: 18/8/25 09:14\n\"\"\"\n\nimport threading\nfrom Queue import Queue\nimport copy\nimport time\n\ndef job(l, q):\n    res = sum(l)\n    q.put(l) #多线程调用的函数不能用return返回值\n\ndef multithreading(l):\n    q = Queue()  #q中存放返回值，代替return的返回值\n    threads = []\n\n    for i in range(4): #定义四个线程\n        t = threading.Thread(target=job, args=(copy.copy(l), q), name=\"T%i\" % i)  #Thread首字母要大写，被调用的job函数没有括号，只是一个索引，参数在后面\n        t.start() #开始线程\n        threads.append(t) #把每个线程append到线程列表中\n\n    [t.join() for t in threads]\n    total = 0\n    for _ in range(4):\n        total = q.get() #q.get()按顺序从q中拿出一个值\n    print(total)\n\ndef normal(l):\n    total = sum(l)\n    print(total)\n\nif __name__ == '__main__':\n    l = list(range(1000000))\n    s_t = time.time()\n    normal(l*4)\n    print('normal:', time.time() - s_t)\n    s_t = time.time()\n    multithreading(l)\n    print('multithreading: ', time.time() - s_t)\n\n\n如果你成功运行整套程序, 你大概会有这样的输出. 我们的运算结果没错, 所以程序 threading 和 Normal 运行了一样多次的运算. 但是我们发现 threading 却没有快多少, 按理来说, 我们预期会要快3-4倍, 因为有建立4个线程, 但是并没有. 这就是其中的 GIL 在作怪.\n1999998000000\nnormal:  0.10034608840942383\n1999998000000\nmultithreading:  0.08421492576599121\n5、线程锁Lock\n不使用 Lock 的情况\nthreading_lock.py\n# -*- coding:utf-8 -*-\n\n\"\"\"\n@author: Corwien\n@file: threading_lock.py\n@time: 18/8/25 09:14\n\"\"\"\n\nimport threading\n\n# 全局变量A的值每次加1，循环10次，并打印\ndef job1():\n    global A\n    for i in range(10):\n        A+=1\n        print('job1',A)\n\n# 全局变量A的值每次加10，循环10次，并打印\ndef job2():\n    global A\n    for i in range(10):\n        A+=10\n        print('job2',A)\n\n# 定义两个线程，分别执行函数一和函数二\nif __name__== '__main__':\n   \n    A=0\n    t1=threading.Thread(target=job1)\n    t2=threading.Thread(target=job2)\n    t1.start()\n    t2.start()\n    t1.join()\n    t2.join()\n打印输出数据：\n➜  baseLearn python ./threading/threading_lock.py\n('job1', ('job2'1)\n, (11)'job1'\n('job2', 22)\n('job2', 32)\n('job2', 42)\n('job2', 52)\n('job2', 62)\n('job2', 72)\n('job2', 82)\n('job2', 92)\n('job2', 102)\n, 12)\n('job1', 103)\n('job1', 104)\n('job1', 105)\n('job1', 106)\n('job1', 107)\n('job1', 108)\n('job1', 109)\n('job1', 110)\n可以看出，打印的结果非常混乱\n使用 Lock 的情况\nlock在不同线程使用同一共享内存时，能够确保线程之间互不影响，使用lock的方法是， 在每个线程执行运算修改共享内存之前，执行lock.acquire()将共享内存上锁， 确保当前线程执行时，内存不会被其他线程访问，执行运算完毕后，使用lock.release()将锁打开， 保证其他的线程可以使用该共享内存。\n函数一和函数二加锁\ndef job1():\n    global A,lock\n    lock.acquire()\n    for i in range(10):\n        A+=1\n        print('job1',A)\n    lock.release()\n\ndef job2():\n    global A,lock\n    lock.acquire()\n    for i in range(10):\n        A+=10\n        print('job2',A)\n    lock.release()\n主函数中定义一个Lock\nif __name__== '__main__':\n    lock=threading.Lock()\n    A=0\n    t1=threading.Thread(target=job1)\n    t2=threading.Thread(target=job2)\n    t1.start()\n    t2.start()\n    t1.join()\n    t2.join()\n完整代码：\n# -*- coding:utf-8 -*-\n\n\"\"\"\n@author: Corwien\n@file: threading_lock.py\n@time: 18/8/25 09:14\n\"\"\"\n\nimport threading\n\ndef job1():\n    global A,lock\n    lock.acquire()\n    for i in range(10):\n        A+=1\n        print('job1',A)\n    lock.release()\n\ndef job2():\n    global A,lock\n    lock.acquire()\n    for i in range(10):\n        A+=10\n        print('job2',A)\n    lock.release()\n\nif __name__== '__main__':\n    lock = threading.Lock()\n    A=0\n    t1=threading.Thread(target=job1)\n    t2=threading.Thread(target=job2)\n    t1.start()\n    t2.start()\n    t1.join()\n    t2.join()\n打印输出：\n➜  baseLearn python ./threading/threading_lock.py\n('job1', 1)\n('job1', 2)\n('job1', 3)\n('job1', 4)\n('job1', 5)\n('job1', 6)\n('job1', 7)\n('job1', 8)\n('job1', 9)\n('job1', 10)\n('job2', 20)\n('job2', 30)\n('job2', 40)\n('job2', 50)\n('job2', 60)\n('job2', 70)\n('job2', 80)\n('job2', 90)\n('job2', 100)\n('job2', 110)\n从打印结果来看，使用lock后，一个一个线程执行完。使用lock和不使用lock，最后打印输出的结果是不同的。\n\n\n                ", "mainLikeNum": ["10 "], "mainBookmarkNum": "8"}