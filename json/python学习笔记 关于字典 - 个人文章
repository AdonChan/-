{"title": "python学习笔记 关于字典 - 个人文章 ", "index": "python,python3.x", "content": "字典\ndict类型是python语言的基石，所以python对于dict类型实现了高度优化，而 散列表  则是字典类型性能突出的根本原因。\n什么是可散列的数据类型\n定义：如果一个对象是可散列的，那么在这个对象的生命周期中，它的散列值是始终不变的，而且这个对象必定实现__hash__()方法。  另外，可散列对象还必须实现  __eq__()方法，这样才能保证两个相同类型的对象可以进行比较。如果两个对象是相同的，那么它们的散列值一定是相同的。\n也就是说，一个可散列对象必须同时满足以下三个条件：\n\n支持hash()方法，并且通过__hash__()方法所获得的散列值是不变的；\n支持通过__eq__()方法来判断两个对象的值是否相等；\n若 a==b，则必有 hash(a) == hash(b)。\n\n\n原子不可变数据类型（str、bytes和数值类型）都是可散列类型；\nfrozenset类型也是可散列的；\n当一个元组中所包含的值都是可散列的，该元组才是可散列的。\n\n下例展示了创建字典的不同方式\n>>> d1 = dict(one=1, two=2, three=3)\n>>> d2 = {'one':1, 'two':2, 'three':3}\n>>> d3 = dict(zip(['one', 'two', 'three'], [1,2,3]))\n>>> d4 = dict([('two', 2), ('one', 1), ('three', 3)])\n>>> d5 = dict({'one':1, 'two':2, 'three':3})\n>>> d1 == d2 == d3 == d4 == d5\nTrue\n\n\n\n处理找不到的键\n假设有一个字典dict，当程序试图查找一个不存在的键值 dict[k] 时，会抛出一个异常KeyError，这个行为复合python所信奉的“快速失败”哲学。当然，我们可以采用dict.get(k, default)来代替dict[k]，当找不到键k时，返回默认值default，但是，这并不是一个高效的方式，也不是一个可取的方法。\n1. setdefault方法\n下面是一个案例：\ndict_demo = {}\nprint(dict_demo)\nkey = \"name\"\ndict_demo.get(key)\ndict_demo.setdefault(key, [])  \nprint(dict_demo)\ndict_demo.setdefault(\"pass\", \"123456\")\nprint(dict_demo)\n\n运行结果如下：\n{}\n{'name': []}\n{'name': [], 'pass': '123456'}\n\n代码中第一个 setdefault 中未找到 key，于是把一个空列表赋值到该键值\n第二个 setdefault 未找到键\"pass\"，将一个字符串赋值给该键\n经过两个setdefault之后，该字典含有两个键值对，该方法主要用于对字典进行更新\n2.defaultdict 处理空缺键的一个选择\n在用户创建defaultdict对象时，需要给它配置一个为找不到的键创造默认值的方法\n具体而言，就是在实例化一个defaultdict对象时，需要给构造方法赋予一个可调用对象，这个可调用对象在__getitem__碰到找不到的键时，让__getitem__返回一个默认值。\nkey = \"name\"\ndict_demo2 = collections.defaultdict(list)\nprint(dict_demo2)\ndict_demo2[key].append((1,2))\nprint(dict_demo2)\ndict_demo2[\"pass\"]\nprint(dict_demo2)\n\n运行结果：\ndefaultdict(<class 'list'>, {})\ndefaultdict(<class 'list'>, {'name': [(1, 2)]})\ndefaultdict(<class 'list'>, {'name': [(1, 2)], 'pass': []})\n\ndict_demo2一开始是一个空字典，不存在任何键值，当运行dict_demo2[key]时，其中包含一下三个步骤：\n(1) 调用list()创建一个新列表\n(2) 把这个新列表作为值，key作为键，放入dd中\n(3) 返回这个列表的引用（这也是能够进行append操作的原因）\n如果在键值不确定的情况下可以考虑使用defaultdict\n3 特殊方法__missing__\n所有映射类型在处理找不到的键时，都会牵扯__missing__方法，当__getitem__操作找不到键值时，就会调用__missing__方法，而不是直接抛出异常。\n\n__missing__方法只会被__getitem__方法调用\nclass StrKeyDict0(dict):\n def __missing__(self, key):\n     if isinstance(key, str):\n         raise KeyError(key)\n     return self[str(key)]\n\n def get(self, key, default=None):\n     try:\n         return self[key]\n     except KeyError:\n         return default\n\n def __contains__(self, key):\n     return key in self.keys() or str(key) in self.keys()\n \n \nif name == '__main__':\n d = StrKeyDict0([('2', 'two'), ('4', 'four')])\n print(d['2'])\n print(d[4])\n try:\n     print(d[1])\n except KeyError:\n     print(\"keyerror\")\n\n print(d.get('2'))\n print(d.get(4))\n try:\n     print(d.get(1, 'N/A'))\n except KeyError:\n     print(\"keyerror\")\n\n print(2 in d)\n print(4 in d)\n\n\n运行结果：\ntwo\nfour\nkeyerror\ntwo\nfour\nN/A\nTrue\nTrue\n\n__missing__方法中将键key转化为str类型后再次尝试获取字典d中相应的键值\n所以可以看到，即便字典中没有 4 这个键，但是依然能够正确获取其在字典中相应的值，但是由于字典中不存在 1 或 \"1\" 这样的键，所以无法获取d[1]\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}