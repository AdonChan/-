{"title": "介绍Python的魔术方法 - Magic Method - 旺酱的专栏 ", "index": "python,魔术方法", "content": "前言\n在Python中，所有以__双下划线包起来的方法，都统称为\"魔术方法\"。比如我们接触最多的__init__.\n有些魔术方法,我们可能以后一辈子都不会再遇到了,这里也就只是简单介绍下;\n而有些魔术方法,巧妙使用它可以构造出非常优美的代码,比如将复杂的逻辑封装成简单的API。\n本文编辑的思路借鉴自Rafe Kettler的这篇博客: A Guide to Python Magic Methods，并补充了一些代码示例。\n介绍的顺序大概是：常见的先介绍，越少见的越靠后讲。\n本文中用到的代码示例，可以在我的github下载到。\n构造和初始化\n__init__我们很熟悉了,它在对象初始化的时候调用,我们一般将它理解为\"构造函数\".\n实际上, 当我们调用x = SomeClass()的时候调用,__init__并不是第一个执行的, __new__才是。所以准确来说,是__new__和__init__共同构成了\"构造函数\".\n__new__是用来创建类并返回这个类的实例, 而__init__只是将传入的参数来初始化该实例.\n__new__在创建一个实例的过程中必定会被调用,但__init__就不一定，比如通过pickle.load的方式反序列化一个实例时就不会调用__init__。\n__new__方法总是需要返回该类的一个实例，而__init__不能返回除了None的任何值。比如下面例子:\nclass Foo(object):\n\n    def __init__(self):\n        print 'foo __init__'\n        return None  # 必须返回None,否则抛TypeError\n\n    def __del__(self):\n        print 'foo __del__'\n实际中,你很少会用到__new__，除非你希望能够控制类的创建。如果要讲解__new__，往往需要牵扯到metaclass(元类)的介绍。如果你有兴趣深入,可以参考我的另一篇博客: 理解Python的metaclass\n对于__new__的重载，Python文档中也有了详细的介绍。\n在对象的生命周期结束时, __del__会被调用,可以将__del__理解为\"析构函数\".__del__定义的是当一个对象进行垃圾回收时候的行为。\n有一点容易被人误解, 实际上，x.__del__() 并不是对于del x的实现,但是往往执行del x时会调用x.__del__().\n怎么来理解这句话呢? 继续用上面的Foo类的代码为例:\nfoo = Foo()\nfoo.__del__()\nprint foo\ndel foo\nprint foo  # NameError, foo is not defined\n如果调用了foo.__del__()，对象本身仍然存在. 但是调用了del foo, 就再也没有foo这个对象了.\n请注意，如果解释器退出的时候对象还存在，就不能保证 __del__ 被确切的执行了。所以__del__并不能替代良好的编程习惯。比如，在处理socket时，及时关闭结束的连接。\n属性访问控制\n总有人要吐槽Python缺少对于类的封装,比如希望Python能够定义私有属性，然后提供公共可访问的getter和 setter。Python其实可以通过魔术方法来实现封装。\n__getattr__(self, name)\n该方法定义了你试图访问一个不存在的属性时的行为。因此，重载该方法可以实现捕获错误拼写然后进行重定向, 或者对一些废弃的属性进行警告。\n__setattr__(self, name, value)\n__setattr__ 是实现封装的解决方案，它定义了你对属性进行赋值和修改操作时的行为。不管对象的某个属性是否存在,它都允许你为该属性进行赋值,因此你可以为属性的值进行自定义操作。有一点需要注意，实现__setattr__时要避免\"无限递归\"的错误，下面的代码示例中会提到。\n__delattr__(self, name)\n__delattr__与__setattr__很像，只是它定义的是你删除属性时的行为。实现__delattr__是同时要避免\"无限递归\"的错误。\n__getattribute__(self, name)\n__getattribute__定义了你的属性被访问时的行为，相比较，__getattr__只有该属性不存在时才会起作用。因此，在支持__getattribute__的Python版本,调用__getattr__前必定会调用 __getattribute__。__getattribute__同样要避免\"无限递归\"的错误。需要提醒的是，最好不要尝试去实现__getattribute__,因为很少见到这种做法，而且很容易出bug。\n例子说明__setattr__的无限递归错误:\ndef __setattr__(self, name, value):\n    self.name = value\n    # 每一次属性赋值时, __setattr__都会被调用，因此不断调用自身导致无限递归了。\n因此正确的写法应该是:\ndef __setattr__(self, name, value):\n    self.__dict__[name] = value\n__delattr__如果在其实现中出现del self.name 这样的代码也会出现\"无限递归\"错误，这是一样的原因。\n下面的例子很好的说明了上面介绍的4个魔术方法的调用情况:\nclass Access(object):\n\n    def __getattr__(self, name):\n        print '__getattr__'\n        return super(Access, self).__getattr__(name)\n\n    def __setattr__(self, name, value):\n        print '__setattr__'\n        return super(Access, self).__setattr__(name, value)\n\n    def __delattr__(self, name):\n        print '__delattr__'\n        return super(Access, self).__delattr__(name)\n\n    def __getattribute__(self, name):\n        print '__getattribute__'\n        return super(Access, self).__getattribute__(name)\n\naccess = Access()\naccess.attr1 = True  # __setattr__调用\naccess.attr1  # 属性存在,只有__getattribute__调用\ntry:\n    access.attr2  # 属性不存在, 先调用__getattribute__, 后调用__getattr__\nexcept AttributeError:\n    pass\ndel access.attr1  # __delattr__调用\n描述器对象\n我们从一个例子来入手,介绍什么是描述符,并介绍__get__, __set__, __delete__ 的使用。(放在这里介绍是为了跟上一小节介绍的魔术方法作对比)\n我们知道，距离既可以用单位\"米\"表示,也可以用单位\"英尺\"表示。现在我们定义一个类来表示距离,它有两个属性: 米和英尺。\nclass Meter(object):\n    '''Descriptor for a meter.'''\n    def __init__(self, value=0.0):\n        self.value = float(value)\n    def __get__(self, instance, owner):\n        return self.value\n    def __set__(self, instance, value):\n        self.value = float(value)\n\nclass Foot(object):\n    '''Descriptor for a foot.'''\n    def __get__(self, instance, owner):\n        return instance.meter * 3.2808\n    def __set__(self, instance, value):\n        instance.meter = float(value) / 3.2808\n\nclass Distance(object):\n    meter = Meter()\n    foot = Foot()\n\nd = Distance()\nprint d.meter, d.foot  # 0.0, 0.0\nd.meter = 1\nprint d.meter, d.foot  # 1.0 3.2808\nd.meter = 2\nprint d.meter, d.foot  # 2.0 6.5616\n在上面例子中,在还没有对Distance的实例赋值前, 我们认为meter和foot应该是各自类的实例对象, 但是输出却是数值。这是因为__get__发挥了作用.\n我们只是修改了meter,并且将其赋值成为int，但foot也修改了。这是__set__发挥了作用.\n描述器对象(Meter、Foot)不能独立存在, 它需要被另一个所有者类(Distance)所持有。描述器对象可以访问到其拥有者实例的属性，比如例子中Foot的instance.meter。\n在面向对象编程时，如果一个类的属性有相互依赖的关系时，使用描述器来编写代码可以很巧妙的组织逻辑。在Django的ORM中, models.Model中的IntegerField等, 就是通过描述器来实现功能的。\n一个类要成为描述器，必须实现__get__, __set__, __delete__ 中的至少一个方法。下面简单介绍下:\n__get__(self, instance, owner)\n参数instance是拥有者类的实例。参数owner是拥有者类本身。__get__在其拥有者对其读值的时候调用。\n__set__(self, instance, value)\n__set__在其拥有者对其进行修改值的时候调用。\n__delete__(self, instance)\n__delete__在其拥有者对其进行删除的时候调用。\n构造自定义容器(Container)\n在Python中，常见的容器类型有: dict, tuple, list, string。其中tuple, string是不可变容器，dict, list是可变容器。可变容器和不可变容器的区别在于，不可变容器一旦赋值后，不可对其中的某个元素进行修改。比如定义了l = [1, 2, 3]和t = (1, 2, 3)后, 执行l[0] = 0是可以的，但执行t[0] = 0则会报错。\n如果我们要自定义一些数据结构，使之能够跟以上的容器类型表现一样，那就需要去实现某些协议。\n这里的协议跟其他语言中所谓的\"接口\"概念很像，一样的需要你去实现才行，只不过没那么正式而已。\n如果要自定义不可变容器类型，只需要定义__len__ 和 __getitem__方法;如果要自定义可变容器类型，还需要在不可变容器类型的基础上增加定义__setitem__ 和 __delitem__。如果你希望你的自定义数据结构还支持\"可迭代\", 那就还需要定义__iter__。\n__len__(self)\n需要返回数值类型，以表示容器的长度。该方法在可变容器和不可变容器中必须实现。\n__getitem__(self, key)\n当你执行self[key]的时候，调用的就是该方法。该方法在可变容器和不可变容器中也都必须实现。调用的时候,如果key的类型错误，该方法应该抛出TypeError；如果没法返回key对应的数值时,该方法应该抛出ValueError。\n__setitem__(self, key, value)\n当你执行self[key] = value时，调用的是该方法。\n__delitem__(self, key)\n当你执行del self[key]的时候，调用的是该方法。\n__iter__(self)\n该方法需要返回一个迭代器(iterator)。当你执行for x in container: 或者使用iter(container)时，该方法被调用。\n__reversed__(self)\n如果想要该数据结构被內建函数reversed()支持,就还需要实现该方法。\n__contains__(self, item)\n如果定义了该方法，那么在执行item in container 或者 item not in container时该方法就会被调用。如果没有定义，那么Python会迭代容器中的元素来一个一个比较，从而决定返回True或者False。\n__missing__(self, key)\ndict字典类型会有该方法，它定义了key如果在容器中找不到时触发的行为。比如d = {'a': 1}, 当你执行d[notexist]时，d.__missing__('notexist')就会被调用。\n下面举例，使用上面讲的魔术方法来实现Haskell语言中的一个数据结构。\n# -*- coding: utf-8 -*-\nclass FunctionalList:\n    ''' 实现了内置类型list的功能,并丰富了一些其他方法: head, tail, init, last, drop, take'''\n\n    def __init__(self, values=None):\n        if values is None:\n            self.values = []\n        else:\n            self.values = values\n\n    def __len__(self):\n        return len(self.values)\n\n    def __getitem__(self, key):\n        return self.values[key]\n\n    def __setitem__(self, key, value):\n        self.values[key] = value\n\n    def __delitem__(self, key):\n        del self.values[key]\n\n    def __iter__(self):\n        return iter(self.values)\n\n    def __reversed__(self):\n        return FunctionalList(reversed(self.values))\n\n    def append(self, value):\n        self.values.append(value)\n    def head(self):\n        # 获取第一个元素\n        return self.values[0]\n    def tail(self):\n        # 获取第一个元素之后的所有元素\n        return self.values[1:]\n    def init(self):\n        # 获取最后一个元素之前的所有元素\n        return self.values[:-1]\n    def last(self):\n        # 获取最后一个元素\n        return self.values[-1]\n    def drop(self, n):\n        # 获取所有元素，除了前N个\n        return self.values[n:]\n    def take(self, n):\n        # 获取前N个元素\n        return self.values[:n]\n我们再举个例子，实现Perl语言的AutoVivification,它会在你每次引用一个值未定义的属性时为你自动创建数组或者字典。\nclass AutoVivification(dict):\n    \"\"\"Implementation of perl's autovivification feature.\"\"\"\n    def __missing__(self, key):\n        value = self[key] = type(self)()\n        return value\n\nweather = AutoVivification()\nweather['china']['guangdong']['shenzhen'] = 'sunny'\nweather['china']['hubei']['wuhan'] = 'windy'\nweather['USA']['California']['Los Angeles'] = 'sunny'\nprint weather\n\n# 结果输出:{'china': {'hubei': {'wuhan': 'windy'}, 'guangdong': {'shenzhen': 'sunny'}}, 'USA':    {'California': {'Los Angeles': 'sunny'}}}\n在Python中，关于自定义容器的实现还有更多实用的例子，但只有很少一部分能够集成在Python标准库中，比如Counter, OrderedDict等\n上下文管理\nwith声明是从Python2.5开始引进的关键词。你应该遇过这样子的代码:\nwith open('foo.txt') as bar:\n    # do something with bar\n在with声明的代码段中，我们可以做一些对象的开始操作和清除操作,还能对异常进行处理。这需要实现两个魔术方法: __enter__ 和 __exit__。\n__enter__(self)\n__enter__会返回一个值，并赋值给as关键词之后的变量。在这里，你可以定义代码段开始的一些操作。\n__exit__(self, exception_type, exception_value, traceback)\n__exit__定义了代码段结束后的一些操作，可以这里执行一些清除操作，或者做一些代码段结束后需要立即执行的命令，比如文件的关闭，socket断开等。如果代码段成功结束，那么exception_type, exception_value, traceback 三个参数传进来时都将为None。如果代码段抛出异常，那么传进来的三个参数将分别为: 异常的类型，异常的值，异常的追踪栈。如果__exit__返回True, 那么with声明下的代码段的一切异常将会被屏蔽。如果__exit__返回None, 那么如果有异常，异常将正常抛出，这时候with的作用将不会显现出来。\n举例说明：\n这该示例中，IndexError始终会被隐藏，而TypeError始终会抛出。\nclass DemoManager(object):\n\n    def __enter__(self):\n        pass\n\n    def __exit__(self, ex_type, ex_value, ex_tb):\n        if ex_type is IndexError:\n            print ex_value.__class__\n            return True\n        if ex_type is TypeError:\n            print ex_value.__class__\n            return  # return None\n\nwith DemoManager() as nothing:\n    data = [1, 2, 3]\n    data[4]  # raise IndexError, 该异常被__exit__处理了\n\nwith DemoManager() as nothing:\n    data = [1, 2, 3]\n    data['a']  # raise TypeError, 该异常没有被__exit__处理\n\n'''\n输出:\n<type 'exceptions.IndexError'>\n<type 'exceptions.TypeError'>\nTraceback (most recent call last):\n  ...\n'''\n对象的序列化\nPython对象的序列化操作是pickling进行的。pickling非常的重要，以至于Python对此有单独的模块pickle，还有一些相关的魔术方法。使用pickling, 你可以将数据存储在文件中，之后又从文件中进行恢复。\n下面举例来描述pickle的操作。从该例子中也可以看出,如果通过pickle.load 初始化一个对象, 并不会调用__init__方法。\n# -*- coding: utf-8 -*-\nfrom datetime import datetime\nimport pickle\n\nclass Distance(object):\n\n    def __init__(self, meter):\n        print 'distance __init__'\n        self.meter = meter\n\ndata = {\n    'foo': [1, 2, 3],\n    'bar': ('Hello', 'world!'),\n    'baz': True,\n    'dt': datetime(2016, 10, 01),\n    'distance': Distance(1.78),\n}\nprint 'before dump:', data\nwith open('data.pkl', 'wb') as jar:\n    pickle.dump(data, jar)  # 将数据存储在文件中\n\ndel data\nprint 'data is deleted!'\n\nwith open('data.pkl', 'rb') as jar:\n    data = pickle.load(jar)  # 从文件中恢复数据\nprint 'after load:', data\n值得一提，从其他文件进行pickle.load操作时，需要注意有恶意代码的可能性。另外，Python的各个版本之间,pickle文件可能是互不兼容的。\npickling并不是Python的內建类型，它支持所有实现pickle协议(可理解为接口)的类。pickle协议有以下几个可选方法来自定义Python对象的行为。\n__getinitargs__(self)\n如果你希望unpickle时，__init__方法能够调用，那么就需要定义__getinitargs__, 该方法需要返回一系列参数的元组，这些参数就是传给__init__的参数。\n该方法只对old-style class有效。所谓old-style class,指的是不继承自任何对象的类，往往定义时这样表示: class A:, 而非class A(object):\n__getnewargs__(self)\n跟__getinitargs__很类似，只不过返回的参数元组将传值给__new__\n__getstate__(self)\n在调用pickle.dump时，默认是对象的__dict__属性被存储，如果你要修改这种行为，可以在__getstate__方法中返回一个state。state将在调用pickle.load时传值给__setstate__\n__setstate__(self, state)\n一般来说,定义了__getstate__,就需要相应地定义__setstate__来对__getstate__返回的state进行处理。\n__reduce__(self)\n如果pickle的数据包含了自定义的扩展类（比如使用C语言实现的Python扩展类）时，就需要通过实现__reduce__方法来控制行为了。由于使用过于生僻，这里就不展开继续讲解了。\n令人容易混淆的是，我们知道, reduce()是Python的一个內建函数, 需要指出__reduce__并非定义了reduce()的行为，二者没有关系。\n__reduce_ex__(self)\n__reduce_ex__ 是为了兼容性而存在的, 如果定义了__reduce_ex__, 它将代替__reduce__ 执行。\n下面的代码示例很有意思，我们定义了一个类Slate(中文是板岩的意思)。这个类能够记录历史上每次写入给它的值,但每次pickle.dump时当前值就会被清空，仅保留了历史。\n# -*- coding: utf-8 -*-\nimport pickle\nimport time\n\nclass Slate:\n    '''Class to store a string and a changelog, and forget its value when pickled.'''\n    def __init__(self, value):\n        self.value = value\n        self.last_change = time.time()\n        self.history = []\n\n    def change(self, new_value):\n        # 修改value, 将上次的valeu记录在history\n        self.history.append((self.last_change, self.value))\n        self.value = new_value\n        self.last_change = time.time()\n\n    def print_changes(self):\n        print 'Changelog for Slate object:'\n        for k, v in self.history:\n            print '%s    %s' % (k, v)\n\n    def __getstate__(self):\n        # 故意不返回self.value和self.last_change,\n        # 以便每次unpickle时清空当前的状态，仅仅保留history\n        return self.history\n\n    def __setstate__(self, state):\n        self.history = state\n        self.value, self.last_change = None, None\n\nslate = Slate(0)\ntime.sleep(0.5)\nslate.change(100)\ntime.sleep(0.5)\nslate.change(200)\nslate.change(300)\nslate.print_changes()  # 与下面的输出历史对比\nwith open('slate.pkl', 'wb') as jar:\n    pickle.dump(slate, jar)\ndel slate  # delete it\nwith open('slate.pkl', 'rb') as jar:\n    slate = pickle.load(jar)\nprint 'current value:', slate.value  # None\nprint slate.print_changes()  # 输出历史记录与上面一致\n运算符相关的魔术方法\n运算符相关的魔术方法实在太多了，也很好理解，不打算多讲。在其他语言里，也有重载运算符的操作，所以我们对这些魔术方法已经很了解了。\n比较运算符\n__cmp__(self, other)\n如果该方法返回负数，说明self < other; 返回正数，说明self > other; 返回0说明self == other。强烈不推荐来定义__cmp__, 取而代之, 最好分别定义__lt__等方法从而实现比较功能。__cmp__在Python3中被废弃了。\n__eq__(self, other)\n定义了比较操作符==的行为.\n__ne__(self, other)\n定义了比较操作符!=的行为.\n__lt__(self, other)\n定义了比较操作符<的行为.\n__gt__(self, other)\n定义了比较操作符>的行为.\n__le__(self, other)\n定义了比较操作符<=的行为.\n__ge__(self, other)\n定义了比较操作符>=的行为.\n下面我们定义一种类型Word, 它会使用单词的长度来进行大小的比较, 而不是采用str的比较方式。但是为了避免 Word('bar') == Word('foo') 这种违背直觉的情况出现,并没有定义__eq__, 因此Word会使用它的父类(str)中的__eq__来进行比较。\n下面的例子中也可以看出: 在编程语言中, 如果a >=b and a <= b, 并不能推导出a == b这样的结论。\n# -*- coding: utf-8 -*-\nclass Word(str):\n    '''存储单词的类，定义比较单词的几种方法'''\n    def __new__(cls, word):\n        # 注意我们必须要用到__new__方法，因为str是不可变类型\n        # 所以我们必须在创建的时候将它初始化\n        if ' ' in word:\n            print \"Value contains spaces. Truncating to first space.\"\n            word = word[:word.index(' ')]  # 单词是第一个空格之前的所有字符\n        return str.__new__(cls, word)\n\n    def __gt__(self, other):\n        return len(self) > len(other)\n    def __lt__(self, other):\n        return len(self) < len(other)\n    def __ge__(self, other):\n        return len(self) >= len(other)\n    def __le__(self, other):\n        return len(self) <= len(other)\n\nprint 'foo < fool:', Word('foo') < Word('fool')  # True\nprint 'foolish > fool:', Word('foolish') > Word('fool')  # True\nprint 'bar >= foo:', Word('bar') >= Word('foo')  # True\nprint 'bar <= foo:', Word('bar') <= Word('foo')  # True\nprint 'bar == foo:', Word('bar') == Word('foo')  # False, 用了str内置的比较方法来进行比较\nprint 'bar != foo:', Word('bar') != Word('foo')  # True\n一元运算符和函数\n__pos__(self)\n实现了'+'号一元运算符(比如+some_object)\n__neg__(self)\n实现了'-'号一元运算符(比如-some_object)\n__invert__(self)\n实现了~号(波浪号)一元运算符(比如~some_object)\n__abs__(self)\n实现了abs()內建函数.\n__round__(self, n)\n实现了round()内建函数. 参数n表示四舍五进的精度.\n__floor__(self)\n实现了math.floor(), 向下取整.\n__ceil__(self)\n实现了math.ceil(), 向上取整.\n__trunc__(self)\n实现了math.trunc(), 向0取整.\n算术运算符\n__add__(self, other)\n实现了加号运算.\n__sub__(self, other)\n实现了减号运算.\n__mul__(self, other)\n实现了乘法运算.\n__floordiv__(self, other)\n实现了//运算符.\n__div__(self, other)\n实现了/运算符. 该方法在Python3中废弃. 原因是Python3中，division默认就是true division.\n__truediv__(self, other)\n实现了true division. 只有你声明了from __future__ import division该方法才会生效.\n__mod__(self, other)\n实现了%运算符, 取余运算.\n__divmod__(self, other)\n实现了divmod()內建函数.\n__pow__(self, other)\n实现了**操作. N次方操作.\n__lshift__(self, other)\n实现了位操作<<.\n__rshift__(self, other)\n实现了位操作>>.\n__and__(self, other)\n实现了位操作&.\n__or__(self, other)\n实现了位操作|\n__xor__(self, other)\n实现了位操作^\n反算术运算符\n这里只需要解释一下概念即可。假设针对some_object这个对象:\nsome_object + other\n\n上面的代码非常正常地实现了some_object的__add__方法。那么如果遇到相反的情况呢?\nother + some_object\n\n这时候，如果other没有定义__add__方法，但是some_object定义了__radd__, 那么上面的代码照样可以运行。这里的__radd__(self, other)就是__add__(self, other)的反算术运算符。\n所以，类比的，我们就知道了更多的反算术运算符, 就不一一展开了:\n\n__rsub__(self, other)\n__rmul__(self, other)\n__rmul__(self, other)\n__rfloordiv__(self, other)\n__rdiv__(self, other)\n__rtruediv__(self, other)\n__rmod__(self, other)\n__rdivmod__(self, other)\n__rpow__(self, other)\n__rlshift__(self, other)\n__rrshift__(self, other)\n__rand__(self, other)\n__ror__(self, other)\n__rxor__(self, other)\n\n增量赋值\n这也是只要理解了概念就容易掌握的运算。举个例子:\nx = 5\nx += 1  # 这里的+=就是增量赋值，将x+1赋值给了x\n\n因此对于a += b, __iadd__ 将返回a + b, 并赋值给a。所以很容易理解下面的魔术方法了:\n\n__iadd__(self, other)\n__isub__(self, other)\n__imul__(self, other)\n__ifloordiv__(self, other)\n__idiv__(self, other)\n__itruediv__(self, other)\n__imod__(self, other)\n__ipow__(self, other)\n__ilshift__(self, other)\n__irshift__(self, other)\n__iand__(self, other)\n__ior__(self, other)\n__ixor__(self, other)\n\n类型转化\n__int__(self)\n实现了类型转化为int的行为.\n__long__(self)\n实现了类型转化为long的行为.\n__float__(self)\n实现了类型转化为float的行为.\n__complex__(self)\n实现了类型转化为complex(复数, 也即1+2j这样的虚数)的行为.\n__oct__(self)\n实现了类型转化为八进制数的行为.\n__hex__(self)\n实现了类型转化为十六进制数的行为.\n__index__(self)\n在切片运算中将对象转化为int, 因此该方法的返回值必须是int。用一个例子来解释这个用法。\nclass Thing(object):\n    def __index__(self):\n        return 1\n\nthing = Thing()\nlist_ = ['a', 'b', 'c']\nprint list_[thing]  # 'b'\nprint list_[thing:thing]  # []\n上面例子中, list_[thing]的表现跟list_[1]一致，正是因为Thing实现了__index__方法。\n可能有的人会想，list_[thing]为什么不是相当于list_[int(thing)]呢? 通过实现Thing的__int__方法能否达到这个目的呢?\n显然不能。如果真的是这样的话，那么list_[1.1:2.2]这样的写法也应该是通过的。而实际上，该写法会抛出TypeError: slice indices must be integers or None or have an __index__ method\n下面我们再做个例子,如果对一个dict对象执行dict_[thing]会怎么样呢?\ndict_ = {1: 'apple', 2: 'banana', 3: 'cat'}\nprint dict_[thing]  # raise KeyError\n这个时候就不是调用__index__了。虽然list和dict都实现了__getitem__方法, 但是它们的实现方式是不一样的。如果希望上面例子能够正常执行, 需要实现Thing的__hash__ 和 __eq__方法.\nclass Thing(object):\n    def __hash__(self):\n        return 1\n    def __eq__(self, other):\n        return hash(self) == hash(other)\n\ndict_ = {1: 'apple', 2: 'banana', 3: 'cat'}\nprint dict_[thing]  # apple\n__coerce__(self, other)\n实现了混合模式运算。\n要了解这个方法,需要先了解coerce()内建函数: 官方文档上的解释是, coerce(x, y)返回一组数字类型的参数, 它们被转化为同一种类型，以便它们可以使用相同的算术运算符进行操作。如果过程中转化失败，抛出TypeError。\n比如对于coerce(10, 10.1), 因为10和10.1在进行算术运算时，会先将10转为10.0再来运算。因此coerce(10, 10.1)返回值是(10.0, 10.1).\n__coerce__在Python3中废弃了。\n其他魔术方法\n还没讲到的魔术方法还有很多，但有些我觉得很简单，或者很少见，就不再累赘展开说明了。\n__str__(self)\n对实例使用str()时调用。\n__repr__(self)\n对实例使用repr()时调用。str()和repr()都是返回一个代表该实例的字符串，主要区别在于: str()的返回值要方便人来看,而repr()的返回值要方便计算机看。\n__unicode__(self)\n对实例使用unicode()时调用。unicode()与str()的区别在于: 前者返回值是unicode, 后者返回值是str。unicode和str都是basestring的子类。\n当你对一个类只定义了__str__但没定义__unicode__时,__unicode__会根据__str__的返回值自动实现,即return unicode(self.__str__());但返回来则不成立。\nclass StrDemo2:\n    def __str__(self):\n        return 'StrDemo2'\n\nclass StrDemo3:\n    def __unicode__(self):\n        return u'StrDemo3'\n\ndemo2 = StrDemo2()\nprint str(demo2)  # StrDemo2\nprint unicode(demo2)  # StrDemo2\n\ndemo3 = StrDemo3()\nprint str(demo3)  # <__main__.StrDemo3 instance>\nprint unicode(demo3)  # StrDemo3\n__format__(self, formatstr)\n\"Hello, {0:abc}\".format(a)等价于format(a, \"abc\"), 等价于a.__format__(\"abc\")。\n这在需要格式化展示对象的时候非常有用，比如格式化时间对象。\n__hash__(self)\n对实例使用hash()时调用, 返回值是数值类型。\n__nonzero__(self)\n对实例使用bool()时调用, 返回True或者False。你可能会问, 为什么不是命名为__bool__? 我也不知道。我只知道该方法在Python3中改名为__bool__了。\n__dir__(self)\n对实例使用dir()时调用。通常实现该方法是没必要的。\n__sizeof__(self)\n对实例使用sys.getsizeof()时调用。返回对象的大小，单位是bytes。\n__instancecheck__(self, instance)\n对实例调用isinstance(instance, class)时调用。 返回值是布尔值。它会判断instance是否是该类的实例。\n__subclasscheck__(self, subclass)\n对实例使用issubclass(subclass, class)时调用。返回值是布尔值。它会判断subclass否是该类的子类。\n__copy__(self)\n对实例使用copy.copy()时调用。返回\"浅复制\"的对象。\n__deepcopy__(self, memodict={})\n对实例使用copy.deepcopy()时调用。返回\"深复制\"的对象。\n__call__(self, [args...])\n该方法允许类的实例跟函数一样表现:\nclass XClass:\n    def __call__(self, a, b):\n        return a + b\n\ndef add(a, b):\n    return a + b\n\nx = XClass()\nprint 'x(1, 2)', x(1, 2)\nprint 'callable(x)', callable(x)  # True\nprint 'add(1, 2)', add(1, 2)\nprint 'callable(add)', callable(add)  # True\nPython3中的差异\n\nPython3中，str与unicode的区别被废除了,因而__unicode__没有了，取而代之地出现了__bytes__.\nPython3中，division默认就是true division, 因而__div__废弃.\n\n__coerce__因存在冗余而废弃.\n\n__cmp__因存在冗余而废弃.\n\n__nonzero__改名为__bool__.\n\n\n                ", "mainLikeNum": ["7 "], "mainBookmarkNum": "30"}