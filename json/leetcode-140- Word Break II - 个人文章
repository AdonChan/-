{"title": "leetcode-140- Word Break II - 个人文章 ", "index": "python", "content": "题目阐述：\n广度搜索问题。 计算出所有可能的情况。\n衔接点在于segs的前后连贯，拼成所有的满足条件的segs\n前后两个seg要连续。\n递归问题，要记得设置终止退出条件\nelems = {len(s): ['']} 设置成dict形式，就不需要过程中copy了，直接在此进行叠加累计\n应用：将一个连续序列分成所有元素可能的组合情况。可以用list进行组装，也可以用dict形式进行组装。重点：==> if i not in elems: 明确不必要的地方，可以不用去进行计算。\nclass Solution:\n\n    def wordBreak(self, s, wordDict):\n        elems = {len(s): ['']}\n        wordDict = set(wordDict)\n        len_dict = set(len(w) for w in wordDict)\n\n        def sentences(i):\n            if i not in elems:\n                iters=list()\n                for len_iter in len_dict:\n                    cur_part=s[i:i+len_iter]\n                    if cur_part and cur_part in wordDict:\n                        # print('cur_part==>',cur_part)\n                        # elems_iter=list()\n                        elem_cur=cur_part\n                        for item in sentences(i+len_iter):\n                            # print('elem_cur==>',elem_cur)\n                            iterow= elem_cur + (item and ' '+item)\n                            # print('iter==>',iterow)\n                            iters.append(iterow)\n                    # print('iters==>',iters)\n                elems[i]=iters\n            return elems[i]\n        result=sentences(0)\n        # print(elems)\n        return result\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}