{"title": "Tornado 里的协程 - kamushin ", "index": "coroutine,tornado,python", "content": "在使用Tornado的时候经常会写这样的代码:\n\n@gen.coroutine\ndef func():\n    key = object()\n    callback = yield Callback(key)\n    do_work()\n    ret = yield Wait(key)\n    reutrn ret\n\n\n\n每次看都觉得像魔法, 于是今天看了一下tornado的代码来瞅瞅发生了什么.\n\n首先,我们找到这段代码在哪里被@gen.coroutine装饰\n\ndef _make_coroutine_wrapper(func, replace_callback):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        runner = None\n        future = TracebackFuture() #创建了一个新的Future对象,这货就是Future.\n\n        if replace_callback and 'callback' in kwargs:\n            callback = kwargs.pop('callback')\n            IOLoop.current().add_future(\n                future, lambda future: callback(future.result())) #当future执行完就把callback加入ioloop.\n\n        try:\n            result = func(*args, **kwargs) #调用被装饰函数\n        except (Return, StopIteration) as e:\n            result = getattr(e, 'value', None)\n        except Exception:\n            future.set_exc_info(sys.exc_info())\n            return future\n        else:\n            if isinstance(result, types.GeneratorType): #如果被装饰函数被调用后产生一个Generator就用一个Runner来让future调用result.\n                runner = Runner(result, future)\n                runner.run()\n                return future\n        future.set_result(result)\n        return future\n    return wrapper\n\n\n\n下面进入Runner, 直接看run方法, 对于Py来说, 这函数真是长的出奇, 缩进也用了很多...:\n\n    def run(self):\n        \"\"\"Starts or resumes the generator, running until it reaches a\n        yield point that is not ready.\n        \"\"\"\n        if self.running or self.finished:\n            return\n        try:\n            self.running = True\n            while True:\n                future = self.future\n                if not future.done():\n                    return\n                self.future = None\n                try:\n                    orig_stack_contexts = stack_context._state.contexts\n                    try:\n                        value = future.result()#如果是第一次进来, 那么返回None\n                    except Exception:\n                        self.had_exception = True\n                        yielded = self.gen.throw(*sys.exc_info())\n                    else:\n                        yielded = self.gen.send(value)#如果result是None的话,就启动了这个协程,返回了Callback(key)\n                    if stack_context._state.contexts is not orig_stack_contexts:\n                        self.gen.throw(\n                            stack_context.StackContextInconsistentError(\n                                'stack_context inconsistency (probably caused '\n                                'by yield within a \"with StackContext\" block)'))\n                except (StopIteration, Return) as e:\n                    self.finished = True\n                    self.future = _null_future\n                    if self.pending_callbacks and not self.had_exception:\n                        # If we ran cleanly without waiting on all callbacks\n                        # raise an error (really more of a warning).  If we\n                        # had an exception then some callbacks may have been\n                        # orphaned, so skip the check in that case.\n                        raise LeakedCallbackError(\n                            \"finished without waiting for callbacks %r\" %\n                            self.pending_callbacks)\n                    self.result_future.set_result(getattr(e, 'value', None))\n                    self.result_future = None\n                    self._deactivate_stack_context()\n                    return\n                except Exception:\n                    self.finished = True\n                    self.future = _null_future\n                    self.result_future.set_exc_info(sys.exc_info())\n                    self.result_future = None\n                    self._deactivate_stack_context()\n                    return\n                if isinstance(yielded, (list, dict)):\n                    yielded = Multi(yielded)\n                if isinstance(yielded, YieldPoint):#到了这里,Callback()是一个yield point\n                    self.future = TracebackFuture()\n                    def start_yield_point():\n                        try:\n                            yielded.start(self)\n                            if yielded.is_ready():\n                                self.future.set_result(\n                                    yielded.get_result()) #把Callback()的值给Future, 这样下次再调用run的时候, Future就能把自己的result给我们定义的函数里的callback了,于是我们通过一个yield point得到了要的callback.\n                            else:\n                                self.yield_point = yielded \n                        except Exception:\n                            self.future = TracebackFuture()\n                            self.future.set_exc_info(sys.exc_info())\n                    if self.stack_context_deactivate is None:\n                        # Start a stack context if this is the first\n                        # YieldPoint we've seen.\n                        with stack_context.ExceptionStackContext(\n                                self.handle_exception) as deactivate:\n                            self.stack_context_deactivate = deactivate\n                            def cb():\n                                start_yield_point()\n                                self.run()\n                            self.io_loop.add_callback(cb)\n                            return\n                    else:\n                        start_yield_point()\n                elif is_future(yielded):\n                    self.future = yielded\n                    if not self.future.done():\n                        self.io_loop.add_future(\n                            self.future, lambda f: self.run())\n                        return\n                else:\n                    self.future = TracebackFuture()\n                    self.future.set_exception(BadYieldError(\n                        \"yielded unknown object %r\" % (yielded,)))\n        finally:\n            self.running = False\n\n\n\n暂时看懂了这些.关于发送一个None启动Generator的, 参见这里:看后面那个回答, 前面那个回答太基础了, 没提到send方法\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "3"}