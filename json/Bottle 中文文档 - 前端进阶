{"title": "Bottle 中文文档 - 前端进阶 ", "index": "bottlepy,bottle,python", "content": "译者: smallfish (smallfish.xy@gmail.com)\n\n更新日期: 2009-09-25\n\n原文地址: http://bottle.paws.de/page/docs （已失效）\n\n译文地址: http://pynotes.appspot.com/static/bottle/docs.htm （需翻墙）\n\n\n这份文档会不断更新。\n如果在文档里没有找到答案，请在版本跟踪中提出 issue。\n\n基本映射\n\n映射使用在根据不同 URLs 请求来产生相对应的返回内容。\nBottle 使用 route() 修饰器来实现映射。\n\nfrom bottle import route, run\n@route('/hello')\ndef hello():\n    return \"Hello World!\"\nrun() # This starts the HTTP server\n\n\n运行这个程序，访问 http://localhost:8080/hello 将会在浏览器里看到 \"Hello World!\"。\n\nGET, POST, HEAD, ...\n\n这个映射装饰器有可选的关键字 method 默认是 method='GET'。\n还有可能是 POST，PUT，DELETE，HEAD 或者监听其他的 HTTP 请求方法。\n\nfrom bottle import route, request\n@route('/form/submit', method='POST')\ndef form_submit():\n    form_data = request.POST\n    do_something(form_data)\n    return \"Done\"\n\n\n动态映射\n\n你可以提取 URL 的部分来建立动态变量名的映射。\n\n@route('/hello/:name')\ndef hello(name):\n    return \"Hello %s!\" % name\n\n\n默认情况下，一个 :placeholder 会一直匹配到下一个斜线。\n需要修改的话，可以把正则字符加入到 #s 之间：\n\n@route('/get_object/:id#[0-9]+#')\ndef get(id):\n    return \"Object ID: %d\" % int(id)\n\n\n或者使用完整的正则匹配组来实现：\n\n@route('/get_object/(?P<id>[0-9]+)')\ndef get(id):\n    return \"Object ID: %d\" % int(id)\n\n\n正如你看到的，URL 参数仍然是字符串，即使你正则里面是数字。\n你必须显式的进行类型强制转换。\n\n\n@validate() 装饰器\n\nBottle 提供一个方便的装饰器 validate() 来校验多个参数。\n它可以通过关键字和过滤器来对每一个 URL 参数进行处理然后返回请求。\n\nfrom bottle import route, validate\n# /test/validate/1/2.3/4,5,6,7\n@route('/test/validate/:i/:f/:csv')\n@validate(i=int, f=float, csv=lambda x: map(int, x.split(',')))\ndef validate_test(i, f, csv):\n    return \"Int: %d, Float:%f, List:%s\" % (i, f, repr(csv))\n\n\n你可能需要在校验参数失败时抛出 ValueError。\n\n返回文件流和 JSON\n\nWSGI 规范不能处理文件对象或字符串。\nBottle 自动转换字符串类型为 iter 对象。\n下面的例子可以在 Bottle 下运行，但是不能运行在纯 WSGI 环境下。\n\n@route('/get_string')\ndef get_string():\n    return \"This is not a list of strings, but a single string\"\n@route('/file')\ndef get_file():\n    return open('some/file.txt','r')\n\n\n字典类型也是允许的。\n会转换成 json 格式，自动返回 Content-Type: application/json。\n\n@route('/api/status')\ndef api_status():\n    return {'status':'online', 'servertime':time.time()}\n\n\n你可以关闭这个特性 :bottle.default_app().autojson = False\n\nCookies\n\nBottle 是把 cookie 存储在 request.COOKIES 变量中。\n新建 cookie 的方法是 response.set_cookie(name, value[, **params])。\n它可以接受额外的参数，属于 SimpleCookie 的有有效参数。\n\nfrom bottle import response\nresponse.set_cookie('key','value', path='/', domain='example.com', secure=True, expires=+500, ...)\n\n\n设置 max-age 属性(它不是个有效的 Python 参数名) 你可以在实例中修改 cookie.SimpleCookie in response.COOKIES。\n\nfrom bottle import response\nresponse.COOKIES['key'] = 'value'\nresponse.COOKIES['key']['max-age'] = 500\n\n\n模板\n\nBottle 使用自带的小巧的模板。\n你可以使用调用 template(template_name, **template_arguments) 并返回结果。\n\n@route('/hello/:name')\ndef hello(name):\n    return template('hello_template', username=name)\n\n\n这样就会加载 hello_template.tpl，并提取 URL:name 到变量 username，返回请求。\n\nhello_template.tpl 大致这样:\n\n<h1>Hello {{username}}</h1>\n<p>How are you?</p>\n\n\n模板搜索路径\n\n模板是根据 bottle.TEMPLATE_PATH 列表变量去搜索。\n默认路径包含 ['./%s.tpl', './views/%s.tpl']。\n\n模板缓存\n\n模板在编译后在内存中缓存。\n修改模板不会更新缓存，直到你清除缓存。\n调用 bottle.TEMPLATES.clear()。\n\n模板语法\n\n模板语法是围绕 Python 很薄的一层。\n主要目的就是确保正确的缩进块。\n下面是一些模板语法的列子:\n\n\n\n%...Python 代码开始。不必处理缩进问题。Bottle 会为你做这些。\n%end 关闭一些语句 %if ...，%for ... 或者其他。关闭块是必须的。\n\n{{...}} 打印出 Python 语句的结果。\n\n%include template_name optional_arguments 包括其他模板。\n每一行返回为文本。\n\nExample:\n\n%header = 'Test Template'\n%items = [1,2,3,'fly']\n%include http_header title=header, use_js=['jquery.js', 'default.js']\n<h1>{{header.title()}}</h1>\n<ul>\n%for item in items:\n  <li>\n    %if isinstance(item, int):\n      Zahl: {{item}}\n    %else:\n      %try:\n        Other type: ({{type(item).__name__}}) {{repr(item)}}\n      %except:\n        Error: Item has no string representation.\n      %end try-block (yes, you may add comments here)\n    %end\n    </li>\n  %end\n</ul>\n%include http_footer\n\n\nKey/Value数据库\n\nBottle(>0.4.6) 通过 bottle.db 模块变量提供一个 key/value 数据库。\n你可以使用 key 或者属性来来存取一个数据库对象。\n调用 bottle.db.bucket_name.key_name 和 bottle.db[bucket_name][key_name]。\n\n只要确保使用正确的名字就可以使用，而不管他们是否已经存在。\n\n存储的对象类似 dict 字典，keys 和 values 必须是字符串。\n不支持 items() 和 values() 这些方法。\n找不到将会抛出 KeyError。\n\n持久化\n\n对于请求，所有变化都是缓存在本地内存池中。\n在请求结束时，自动保存已修改部分，以便下一次请求返回更新的值。\n数据存储在 bottle.DB_PATH 文件里。要确保文件能访问此文件。\n\nRace conditions\n\n一般来说不需要考虑锁问题，但是在多线程或者交叉环境里仍是个问题。\n你可以调用 bottle.db.save() 或者 botle.db.bucket_name.save() 去刷新缓存，\n但是没有办法检测到其他环境对数据库的操作，直到调用 bottle.db.save() 或者离开当前请求。\n\nExample\n\nfrom bottle import route, db\n@route('/db/counter')\ndef db_counter():\n    if 'hits' not in db.counter:\n        db.counter.hits = 0\n    db['counter']['hits'] += 1\n    return \"Total hits: %d!\" % db.counter.hits\n\n\n使用 WSGI 和中间件\n\nbottle.default_app() 返回一个 WSGI 应用。\n如果喜欢 WSGI 中间件模块的话，你只需要声明 bottle.run() 去包装应用，而不是使用默认的。\n\nfrom bottle import default_app, run\napp = default_app()\nnewapp = YourMiddleware(app)\nrun(app=newapp)\n\n\n默认 default_app() 工作\n\nBottle 创建一个 bottle.Bottle() 对象和装饰器，调用 bottle.run() 运行。bottle.default_app() 是默认。当然你可以创建自己的 bottle.Bottle() 实例。\n\nfrom bottle import Bottle, run\nmybottle = Bottle()\n@mybottle.route('/')\ndef index():\n  return 'default_app'\nrun(app=mybottle)\n\n\n发布\n\nBottle 默认使用 wsgiref.SimpleServer 发布。\n这个默认单线程服务器是用来早期开发和测试，但是后期可能会成为性能瓶颈。\n\n有三种方法可以去修改:\n\n\n使用多线程的适配器\n负载多个 Bottle 实例应用\n或者两者\n\n多线程服务器\n\n最简单的方法是安装一个多线程和 WSGI 规范的 HTTP 服务器比如 Paste, flup, cherrypy or fapws3 并使用相应的适配器。\n\nfrom bottle import PasteServer, FlupServer, FapwsServer, CherryPyServer\nbottle.run(server=PasteServer) # Example\n\n\n如果缺少你喜欢的服务器和适配器，你可以手动修改 HTTP 服务器并设置 bottle.default_app() 来访问你的 WSGI 应用。\n\ndef run_custom_paste_server(self, host, port):\n    myapp = bottle.default_app()\n    from paste import httpserver\n    httpserver.serve(myapp, host=host, port=port)\n\n\n多服务器进程\n\n一个 Python 程序只能使用一次一个 CPU，即使有更多的 CPU。\n关键是要利用 CPU 资源来负载平衡多个独立的 Python 程序。\n\n单实例 Bottle 应用，你可以通过不同的端口来启动(localhost:8080, 8081, 8082, ...)。\n高性能负载作为反向代理和远期每一个随机瓶进程的新要求，平衡器的行为，传播所有可用的支持与服务器实例的负载。\n这样，您就可以使用所有的 CPU 核心，甚至分散在不同的物理服务器之间的负载。\n\n但也有点缺点:\n\n\n多个 Python 进程里不能共享数据。\n同一时间可能需要大量内存来运行 Python 和 Bottle 应用和副本。\n最快的一个负载是 pound 当然其他一些 HTTP 服务器同样可以做的很好。\n\n不久我会加入 lighttpd 和 Apache 使用。\n\nApache mod_wsgi\n\n发布你的应用当然不是用 Bottle 自带的方法，你可以再 Apache server 使用 mod_wsgi 模板和 Bottles WSGI 接口。\n\n你需要建立 app.wsgi 文件并提供 application 对象。这个对象是用使用 mod_wsgi 启动你的程序并遵循 WSGI 规范可调用。\n\n# /var/www/yourapp/app.wsgi\nimport bottle\n# ... add or import your bottle app code here ...\n# import myapp\napplication = bottle.default_app()\n# Do NOT use bottle.run() with mod_wsgi\n\n\nApache 配置可能如下:\n\n<VirtualHost *>\n    ServerName example.com\n\n    WSGIDaemonProcess yourapp user=www-data group=www-data processes=1 threads=5\n    WSGIScriptAlias / /var/www/yourapp/app.wsgi\n\n    <Directory /var/www/yourapp>\n        WSGIProcessGroup yourapp\n        WSGIApplicationGroup %{GLOBAL}\n        Order deny,allow\n        Allow from all\n    </Directory>\n</VirtualHost>\n\n\nGoogle AppEngine\n\nimport bottle\nfrom google.appengine.ext.webapp import util \n# ... add or import your bottle app code here ...\n# import myapp\n# Do NOT use bottle.run() with AppEngine\nutil.run_wsgi_app(bottle.default_app())\n\n\nCGI模式\n\n运行缓缓，但可以正常工作。\n\nimport bottle\n# ... add or import your bottle app code here ...\nbottle.run(server=bottle.CGIServer)\n\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "10"}