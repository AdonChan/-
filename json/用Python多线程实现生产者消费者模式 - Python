{"title": "用Python多线程实现生产者消费者模式 - Python ", "index": "linux,多线程,python", "content": "什么是生产者消费者模式\n在软件开发的过程中，经常碰到这样的场景：某些模块负责生产数据，这些数据由其他模块来负责处理（此处的模块可能是：函数、线程、进程等）。产生数据的模块称为生产者，而处理数据的模块称为消费者。在生产者与消费者之间的缓冲区称之为仓库。生产者负责往仓库运输商品，而消费者负责从仓库里取出商品，这就构成了生产者消费者模式。\n结构图如下：\n\n为了大家容易理解，我们举一个寄信的例子。假设你要寄一封信，大致过程如下：　1、你把信写好——相当于生产者生产数据\n　2、你把信放入邮箱——相当于生产者把数据放入缓冲区　3、邮递员把信从邮箱取出，做相应处理——相当于消费者把数据取出缓冲区，处理数据\n生产者消费者模式的优点\n解耦假设生产者和消费者分别是两个线程。如果让生产者直接调用消费者的某个方法，那么生产者对于消费者就会产生依赖（也就是耦合）。如果未来消费者的代码发生变化，可能会影响到生产者的代码。而如果两者都依赖于某个缓冲区，两者之间不直接依赖，耦合也就相应降低了。\n举个例子，我们去邮局投递信件，如果不使用邮箱（也就是缓冲区），你必须得把信直接交给邮递员。有同学会说，直接给邮递员不是挺简单的嘛？其实不简单，你必须 得认识谁是邮递员，才能把信给他。这就产生了你和邮递员之间的依赖（相当于生产者和消费者的强耦合）。万一哪天邮递员 换人了，你还要重新认识一下（相当于消费者变化导致修改生产者代码）。而邮箱相对来说比较固定，你依赖它的成本就比较低（相当于和缓冲区之间的弱耦合）。\n并发由于生产者与消费者是两个独立的并发体，他们之间是用缓冲区通信的，生产者只需要往缓冲区里丢数据，就可以继续生产下一个数据，而消费者只需要从缓冲区拿数据即可，这样就不会因为彼此的处理速度而发生阻塞。\n继续上面的例子，如果我们不使用邮箱，就得在邮局等邮递员，直到他回来，把信件交给他，这期间我们啥事儿都不能干（也就是生产者阻塞）。或者邮递员得挨家挨户问，谁要寄信（相当于消费者轮询）。\n支持忙闲不均当生产者制造数据快的时候，消费者来不及处理，未处理的数据可以暂时存在缓冲区中，慢慢处理掉。而不至于因为消费者的性能造成数据丢失或影响生产者生产。\n我们再拿寄信的例子，假设邮递员一次只能带走1000封信，万一碰上情人节（或是圣诞节）送贺卡，需要寄出去的信超过了1000封，这时候邮箱这个缓冲区就派上用场了。邮递员把来不及带走的信暂存在邮箱中，等下次过来时再拿走。\n通过上面的介绍大家应该已经明白了生产者消费者模式。\nPython中的多线程编程\n在实现生产者消费者模式之前，我们先学习下Python中的多线程编程。线程是操作系统直接支持的执行单元，高级语言通常都内置多线程的支持，Python也不例外，并且Python的线程是真正的Posix Thread，而不是模拟出来的线程。Python的标准库提供了两个模块：_thread和threading，_thread是低级模块，threading是高级模块，对_thread进行了封装。绝大多数情况下，我们只需要使用threading这个高级模块。\n下面我们先看一段在Python中实现多线程的代码。\nimport time,threading\n#线程代码\nclass TaskThread(threading.Thread):\n    def __init__(self,name):\n        threading.Thread.__init__(self,name=name)\n    def run(self):\n        print('thread %s is running...' % self.getName())\n\n        for i in range(6):\n            print('thread %s >>> %s' % (self.getName(), i))\n            time.sleep(1)\n\n        print('thread %s finished.' % self.getName())\n\ntaskthread = TaskThread('TaskThread')\ntaskthread.start()\ntaskthread.join()\n下面是程序的执行结果：\nthread TaskThread is running...\nthread TaskThread >>> 0\nthread TaskThread >>> 1\nthread TaskThread >>> 2\nthread TaskThread >>> 3\nthread TaskThread >>> 4\nthread TaskThread >>> 5\nthread TaskThread finished.\nTaskThread类继承自threading模块中的Thread线程类。构造函数的name参数指定线程的名字，通过重载基类run函数实现具体任务。\n在简单熟悉了Python的线程后，下面我们实现一个生产者消费者模shi。\nfrom Queue import Queue\nimport random,threading,time\n\n#生产者类\nclass Producer(threading.Thread):\n    def __init__(self, name,queue):\n        threading.Thread.__init__(self, name=name)\n        self.data=queue\n\n    def run(self):\n        for i in range(5):\n            print(\"%s is producing %d to the queue!\" % (self.getName(), i))\n            self.data.put(i)\n            time.sleep(random.randrange(10)/5)\n        print(\"%s finished!\" % self.getName())\n\n#消费者类\nclass Consumer(threading.Thread):\n    def __init__(self,name,queue):\n        threading.Thread.__init__(self,name=name)\n        self.data=queue\n    def run(self):\n        for i in range(5):\n            val = self.data.get()\n            print(\"%s is consuming. %d in the queue is consumed!\" % (self.getName(),val))\n            time.sleep(random.randrange(10))\n        print(\"%s finished!\" % self.getName())\n\ndef main():\n    queue = Queue()\n    producer = Producer('Producer',queue)\n    consumer = Consumer('Consumer',queue)\n\n    producer.start()\n    consumer.start()\n\n    producer.join()\n    consumer.join()\n    print 'All threads finished!'\n\nif __name__ == '__main__':\n    main()\n执行结果可能如下：\nProducer is producing 0 to the queue!\nConsumer is consuming. 0 in the queue is consumed!\nProducer is producing 1 to the queue!\nProducer is producing 2 to the queue!\nConsumer is consuming. 1 in the queue is consumed!\nConsumer is consuming. 2 in the queue is consumed!\nProducer is producing 3 to the queue!\nProducer is producing 4 to the queue!\nProducer finished!\nConsumer is consuming. 3 in the queue is consumed!\nConsumer is consuming. 4 in the queue is consumed!\nConsumer finished!\nAll threads finished!\n因为多线程是抢占式执行的，所以打印出的运行结果不一定和上面的完全一致。\n小结\n本例通过Python实现了一个简单的生产者消费者模型。Python中的Queue模块已经提供了对线程同步的支持，所以本文并没有涉及锁、同步、死锁等多线程问题。\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "8"}