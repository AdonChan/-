{"title": "[python] 关于 python 的一些高级特性 - Spwb ", "index": "python", "content": "前言\n用 python 差不多半年多了，从去年暑假开始接触，从开始的懵逼，到写了一些小爬虫总算入门之后，许多作业也是能用 python 就用 python，基本抛弃了 C++。但是还是有些过于急躁了，能够写一些简短的代码，但是对于 python 的很多特性都不知道或者忘记了，这里回去廖大教程复习一下，顺便记录下我觉得比较重要的地方。\n开始\n本文主要记录廖大教程中高级特性这一节的内容，并写下我的一些理解。在我看来，这些特性是很 pythonic 的，用在代码中很有 bigger 啊~\n列表生成式(List Comprehensions)\n切片和迭代就不说了，这里直接先看一下列表生成式吧，从名字就能大概猜出这是生成列表的一些方法，比如：如何生成[1*1, 2*2, ... ,10*10]？可以用循环不断向列表尾部添加元素，如果使用 pythonic 的方法，也就是列表生成式，则是：\n>>> [x * x for x in range(1, 11)]\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n后面还能跟上 if 判断，例如：\n>>> [x * x for x in range(1, 11) if x%2==0]\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n这样，本来需要使用循环写4，5行的代码，使用一行就解决了，直观明了。\n还能使用两个 for 循环生成全排列：\n>>> [m + n for m in 'ABC' for n in 'XYZ']\n['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']\n这样如何添加 if 判断呢？可以在每个 for 语句后添加，或者在最后添加：\n>>> [m + n for m in 'ABC' if m < 'C' for n in 'XYZ' if n < 'Z']\n['AX', 'AY', 'BX', 'BY']\n>>> [m + n for m in 'ABC' for n in 'XYZ' if n < 'Z' and m < 'C']\n['AX', 'AY', 'BX', 'BY']\n也可以同时在一个 for 语句中迭代多个变量，比如dict的items()可以同时迭代key和value：\n>>> d = {'x': 'A', 'y': 'B', 'z': 'C' }\n>>> [k + '=' + v for k, v in d.items()]\n['y=B', 'x=A', 'z=C']\n差不多就是这样了~\n但是以前总是写 C++ ，这种思维模式很难改过来，只能慢慢在使用中熟悉这种语法，习惯了就能够在下意识中写出来了。\n生成器(Generator)\n为什么要使用生成器？廖大的教程中说得很详细，这里再简述一下：\n\n因为列表的内容放在内存中，而受到内存限制，列表的容量有限。\n如果我们只访问极少的元素，那么存在极大的空间浪费。\n而生成器可以一边迭代一边计算下一个值，理论上，该过程可以无限进行下去，并且不会占用大量内存。\n\n这里只是简单介绍一下，更详细的请 Google 哈~\n如何创建生成器？第一种方法类似于前面讲到的列表生成式，只需要将[]改为()即可：\n>>> L = [x * x for x in range(10)]\n>>> L\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n>>> g = (x * x for x in range(10))\n>>> g\n<generator object <genexpr> at 0x1022ef630>\n可以看到，方法上大致相同，[]得到的是一个已经得到所有值的列表，()得到的是一个生成器，它们都能使用 for 循环来迭代，但是生成器不能使用下标访问，并且只能被迭代一次，再次迭代则会有 StopIteration 的异常：\n>>> for i in g:\n...     print(i)\n...\n0\n1\n4\n9\n16\n25\n36\n49\n64\n81\n>>> for i in g:\n...     print(i)\n...\n>>> next(g)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nStopIteration\n不过当我们创建了一个generator后，基本上永远不会调用next()，而是通过for循环来迭代它，并且不需要关心StopIteration的错误。\n如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现，比如，著名的斐波那契数列：\ndef fib(max):\n    n, a, b = 0, 0, 1\n    while n < max:\n        yield b\n        a, b = b, a + b\n        n = n + 1\n    return 'done'\n关于 yield 这个关键字，我在刚学 python 的时候也纠结了很久，直到看到生成器的时候才大致明白，大家搜索一下就能大致明白了，我觉得这东西说起来麻烦，只说一两句又怕说错。廖大的教程中是这样说的：\n函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。\n可能有点难理解，不过明白了就很好说了。\n当然，函数中还可以添加 return，在一个 generator function 中，如果没有 return，则默认执行至函数完毕，如果在执行过程中 return，则直接抛出 StopIteration 终止迭代。\n例如上面的例子，我们在迭代时发现并没有出现 'done' 这串字符，是因为 return 的值被当作 Exception Value 了，如果要显示出来，则可以这样：\n>>> g = fib(6)\n>>> while True:\n...     try:\n...         x = next(g)\n...         print('g:', x)\n...     except StopIteration as e:\n...         print('Generator return value:', e.value)\n...         break\n...\ng: 1\ng: 1\ng: 2\ng: 3\ng: 5\ng: 8\nGenerator return value: done\n迭代器(Iterator)\n可直接作用于 for 循环的对象被称为可迭代对象，可以用 isinstance() 函数判断是否为可迭代对象：\n>>> from collections import Iterable\n>>> isinstance([], Iterable)\nTrue\n>>> isinstance({}, Iterable)\nTrue\n>>> isinstance('abc', Iterable)\nTrue\n>>> isinstance((x for x in range(10)), Iterable)\nTrue\n>>> isinstance(100, Iterable)\nFalse\n而可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。当然，仍然可以使用isinstance()判断一个对象是否是Iterator对象：\n>>> from collections import Iterator\n>>> isinstance((x for x in range(10)), Iterator)\nTrue\n>>> isinstance([], Iterator)\nFalse\n>>> isinstance({}, Iterator)\nFalse\n>>> isinstance('abc', Iterator)\nFalse\n通过上面两个例子，可以这样理解：生成器和 list，tuple，str 等都是 Iterable 对象，生成器同时还是 Iterator 对象，而 list 等不是。那么能否直接将 Iterable 对象转换成 Iterator 对象呢？\n可以使用iter()函数：\n>>> isinstance(iter([]), Iterator)\nTrue\n>>> isinstance(iter('abc'), Iterator)\nTrue\n其实，Iterator 对象表示的是一个数据流，我们可以把这个数据流看做是一个有序序列，但却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以 Iterator 的计算是惰性的，只有在需要返回下一个数据时它才会计算。Iterator甚至可以表示一个无限大的数据流，但 list，tuple 什么的是不可能这样的。\n总结\n过了个寒假没碰代码，相当于复习了一遍啊，其实这里说到的特性是很浅显的，理解起来不难，等全部差不多复习完还得再深入一点，理解更多才行。\n以上~\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "4"}