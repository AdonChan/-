{"title": "应用服务器与WSGI协议以及flask后端框架总结(后端接收请求返回响应的整个流程) - 个人文章 ", "index": "flask,python", "content": "上次遗留了两个问题,先说一下自己的看法问题:1.明明一个线程只能处理一个请求,那么栈里的元素永远是在栈顶,那为什么需要用栈这个结构?用普通变量不行吗.2._request_ctx_stack和_app_ctx_stack都是线程隔离的,那么为什么要分开?我认为在web runtime的情况下是可以不需要栈这个结构的,即使是单线程下也不需要,原本我以为在单线程下,当前一个请求阻塞后,后一个请求还会被推入栈中,结果并不是这样,这也就说明了,栈的结构和是不是单线程没关系,为了验证这点,我写了个简单的接口验证这点:\nfrom flask import Flask,_request_ctx_stack\napp = Flask(__name__)\n@app.route('/')def index():\nprint(_request_ctx_stack._local.__storage__)\ntime.sleep(1)\nreturn '<h1>hello</h1>'\n\napp.run(port=3000)\ndef wsgi_app(self, environ, start_response):\nctx = self.request_context(environ)\nctx.push()\nprint(_request_ctx_stack._local.__storage__)\n\n我在Flask类中的wsgi_app()方法中加了这一句print(_request_ctx_stack._local.__storage__),wsgi_app()是后端接收应用服务器发来的包装好的WSGI请求的函数,后面会讲到,由于一个线程只能处理一个请求,所以结果应该是栈中永远只有一个请求对象,在路由接口中我延时了1秒,假设成阻塞,看一下结果:\nRunning on http://127.0.0.1:3000/ (Press CTRL+C to quit)\n{139851542578944: {'stack': []}}127.0.0.1 - - [14/Apr/2018 14:31:17] \"GET / HTTP/1.1\" 200 -{139851542578944: {'stack': []}}127.0.0.1 - - [14/Apr/2018 14:31:18] \"GET / HTTP/1.1\" 200 -{139851542578944: {'stack': []}}127.0.0.1 - - [14/Apr/2018 14:31:19] \"GET / HTTP/1.1\" 200 -\n每次栈中只有一个请求对象,这也就说明了栈这个结构和web runtime下的单线程无关,那么就剩下非web runtime的情况了,最常见的是离线测试:\nfrom flask import Flask,_request_ctx_stack,_app_ctx_stack\napp = Flask(__name__)app2 = Flask(__name__)\ndef offline_test():\nwith app.app_context():\n    print(_app_ctx_stack._local.__storage__)\n    with app2.app_context():\n        print(_app_ctx_stack._local.__storage__)\n\nwith app.app_context():\n    with app.test_request_context():\n        print(_request_ctx_stack._local.__storage__)\n        with app.test_request_context():\n            print(_request_ctx_stack._local.__storage__)\n\n离线测试是单线程的,通过这个例子也能得到第二的问题的答案,为什么要将请求和应用分开,一个原因是flask支持多个app共存,这需要用到中间件,另一个原因是离线测试时,有可能只需要用到应用上下文,所以需要将两者分开,在离线测试时如果进行了嵌套则栈结构的特点就发挥了出来,看一下运行的结果:\n{140402410657536: {'stack': []}}{140402410657536: {'stack': [, ]}}{140402410657536: {'stack': []}}{140402410657536: {'stack': [, ]}}\n结果显而易见总结一下:栈结构和分离请求和应用是为了离线测试更加灵活web应用服务器 WSGI 后端之间的关系web应用服务器的作用是监听端口,当接收到客户端的请求后将请求转化成WSGI格式(environ)然后传给后端框架应用服务器<----WSGI协议---->后端框架WSGI是应用服务器和后端框架之间的桥梁,使得服务器和后端框架分离,各司其职,程序员也能专注于自己的逻辑在WSGI中规定了每个python web应用都需要是一个可调用的对象,即实现了__call__这个特殊方法,Flask就是一个可调用对象web应用服务器从哪里将包装好的请求发送给后端在flask中使用了werkzeug这个工具包,在werkzeug.serving中有一个类,class WSGIRequestHandler(BaseHTTPRequestHandler, object)这个类提供了environ字典对象,定义了start_response()和run_wsgi()方法,在run_wsgi()中有一个execute(),看一下源码:\ndef execute(app):\napplication_iter = app(environ, start_response)  #从这里发送到后端\ntry:\n    for data in application_iter:\n        write(data)\n    if not headers_sent:\n        write(b'')\nfinally:\n    if hasattr(application_iter, 'close'):\n        application_iter.close()\n    application_iter = None\n\n第一句application_iter = app(environ, start_response)就调用了Flask.__call__(),并将environ, start_response传入,而Flask.__call__()就return了self.wsgi_app(),这个wsgi_app(environ, start_response)是一个标准的请求处理函数,所以它就是整个后端处理请求的入口函数,environ是一个包含所有HTTP请求信息的字典对象,start_response是一个发送HTTP响应的函数,environ是从应用服务器传过来的,start_response是定义好的,这些都不需要后端开发人员关心总结一下:1.WSGI规定了后端处理函数的格式,即需要接受environ,start_response这两个参数,这两个参数从应用服务器传给后端框架2.python web应用对象需要是可调用的,即实现了__call__方法,返回WSGI规定格式的后端处理函数来处理请求及返回响应3.应用服务器会使用werkzeug.serving中的WSGIRequestHandler类中的相应方法,将http请求转化成WSGI格式,所以说werkzeug是一个遵循WSGI协议的工具包,提供给应用服务器使用后端处理请求返回响应整个流程之前说到,后端处理请求的入口函数是wsgi_app(self,environ,start_response),先看下源码:\ndef wsgi_app(self, environ, start_response):\n    ctx = self.request_context(environ)  #1\n    ctx.push()  #2\n    error = None\n    try:\n        try:\n            response = self.full_dispatch_request()  #3\n        except Exception as e:\n            error = e\n            response = self.handle_exception(e)\n        except:\n            error = sys.exc_info()[1]\n            raise\n        return response(environ, start_response)\n    finally:\n        if self.should_ignore_error(error):\n            error = None\n        ctx.auto_pop(error)\n\n其中有三句比较关键,我写了序号第一句:self.request_context(environ),看下request_context这个方法:\ndef request_context(self, environ):\n    return RequestContext(self, environ)\n\n简而言之,传入environ,初始化一个请求上下文对象并返回第二句:ctx.push(),看下源码:\ndef push(self):\n    top = _request_ctx_stack.top\n    if top is not None and top.preserved:\n        top.pop(top._preserved_exc)\n\n    app_ctx = _app_ctx_stack.top\n    if app_ctx is None or app_ctx.app != self.app:\n        app_ctx = self.app.app_context()\n        app_ctx.push()\n        self._implicit_app_ctx_stack.append(app_ctx)\n    else:\n        self._implicit_app_ctx_stack.append(None)\n\n    if hasattr(sys, 'exc_clear'):\n        sys.exc_clear()\n\n    _request_ctx_stack.push(self)\n\n    self.session = self.app.open_session(self.request)\n    if self.session is None:\n        self.session = self.app.make_null_session()\n\n简而言之,推入应用上下文和请求上下文,如果设置了secret_key则开启一个session,关于flask的session放到后面说第三句:self.full_dispatch_request(),是处理请求的关键函数,看下源码:\ndef full_dispatch_request(self):\n    \"\"\"Dispatches the request and on top of that performs request\n    pre and postprocessing as well as HTTP exception catching and\n    error handling.\n\n    .. versionadded:: 0.7\n    \"\"\"\n    self.try_trigger_before_first_request_functions()\n    try:\n        request_started.send(self)\n        rv = self.preprocess_request()  #function1\n        if rv is None:\n            rv = self.dispatch_request()  #function2\n    except Exception as e:\n        rv = self.handle_user_exception(e)\n    return self.finalize_request(rv)  #function3\n\n这个函数中嵌套了另外三个函数,预处理函数preprocess_request(),主处理函数dispatch_request()和最终处理函数finalize_request(rv)1.preprocess_request()是处理被before_request装饰器装饰的函数2.dispatch_request()匹配请求的URL,并返回视图函数的返回值rv3.finalize_request(rv)接受视图函数的返回值,并生成响应,这里有make_response和process_response这两个函数,make_response生成响应对象,process_response对响应做一些处理,比如后面要讲到的session响应生成后,在wsgi_app中return response,最后调用ctx.auto_pop()将请求和应用上下文推出栈,return的response会通过start_response发送到应用服务器,并由其发送到客户端,这样一次请求就结束了.最后说说sessionflask中的session是client side session,说白了就是session会封装在cookie中在最终响应时会发送给客户端,而在服务器本地不会存储,所以叫作client side session,要使用session需要设置secret_key这个配置,通过app.secret_key来设置,用来验证签名,等到下次客户端发来带有cookie的请求时,后端就能从生成对应的session中解析出带有的信息,写个简单的应用来看下session怎么用:\nfrom flask import Flask,session\napp = flask.Flask(__name__)app.secret_key = 'gjx'\n@app.route('/')def index():\nif 'name' in session:\n    print(session['name'])\nelse:\n    print('stranger')\nreturn '<h1>/</h1>'\n\n\n@app.route('/')def test(name):\nsession['name'] = name\nprint('session set successful')\nreturn '<h1>test</h1>'\n\n\napp.run(port=3000)\n跑起来后,在浏览器输入127.0.0.1:3000/,会打印出stranger,然后访问127.0.0.1:3000/jx后,后端打印出session set successful,并且浏览器会收到服务器发来的cookie,Set-Cookie:session=eyJuYW1lIjoiangifQ.DbNHuQ.MPZLWzoLdga2SPMg0plMYmKlJMc; HttpOnly; Path=/ 这是我测试时收到的,有三个字段,第一个是session的内容,第二个是时间戳,第三个是验证信息这时已经设置好了session,并且得到了cookie,再次访问127.0.0.1:3000/,后端打印出了jx,就是之前设置的值如果对session内的值更改,则返回的cookie也会更改,那么在那保存,在那创建session呢?之前在分析后端请求流程是提到了,在RequestContext的push方法最后:\n    self.session = self.app.open_session(self.request)\n    if self.session is None:\n        self.session = self.app.make_null_session()\n\n如果设置了secret_key则会执行open_session开启一个session,那如果更改了在哪里保存呢?在finalize_request执行的self.process_response中:\ndef process_response(self, response):\n    ctx = _request_ctx_stack.top\n    bp = ctx.request.blueprint\n    funcs = ctx._after_request_functions\n    if bp is not None and bp in self.after_request_funcs:\n        funcs = chain(funcs, reversed(self.after_request_funcs[bp]))\n    if None in self.after_request_funcs:\n        funcs = chain(funcs, reversed(self.after_request_funcs[None]))\n    for handler in funcs:\n        response = handler(response)\n    if not self.session_interface.is_null_session(ctx.session):\n        self.save_session(ctx.session, response)\n    return response\n\n在最后判断如果session不是null session的话会执行self.save_session来保存更新session,在self.save_session中会调用response.set_cookie,flask中的session大概就是这样总结一下:1.分析了应用服务器封装好的environ从哪发送给后端2.分析了应用服务器 WSGI 后端之间的关系以及WSGI协议对接口的标准定义,使得后端人员只需要关心自己的逻辑3.分析了后端接收到应用服务器发来的WSGI请求之后的一系列处理流程,主要函数是wsgi_app(environ,start_response)4.最后简单分析了flask中的session机制,它是client side session的.\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}