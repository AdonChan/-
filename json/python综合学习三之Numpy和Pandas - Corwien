{"title": "python综合学习三之Numpy和Pandas - Corwien ", "index": "pandas,numpy,python", "content": "本章学习两个科学运算当中最为重要的两个模块，一个是 numpy,一个是 pandas。任何关于数据分析的模块都少不了它们两个。\n一、numpy & pandas特点\nNumPy（Numeric Python）系统是Python的一种开源的数值计算扩展。这种工具可用来存储和处理大型矩阵，比Python自身的嵌套列表（nested list structure)结构要高效的多（该结构也可以用来表示矩阵（matrix））。据说NumPy将Python相当于变成一种免费的更强大的MatLab系统。\nnumpy特性:开源，数据计算扩展，ndarray, 具有多维操作, 数矩阵数据类型、矢量处理，以及精密的运算库。专为进行严格的数字处理而产生。\npandas:为了解决数据分析而创建的库。\n特点：\n\n运算速度快：numpy 和 pandas 都是采用 C 语言编写, pandas 又是基于 numpy, 是 numpy 的升级版本。\n消耗资源少：采用的是矩阵运算，会比 python 自带的字典或者列表快好多\n\n二、安装\n安装方法有两种，第一种是使用Anaconda集成包环境安装，第二种是使用pip命令安装\n1、Anaconda集成包环境安装\n要利用Python进行科学计算，就需要一一安装所需的模块，而这些模块可能又依赖于其它的软件包或库，因而安装和使用起来相对麻烦。幸好有人专门在做这一类事情，将科学计算所需要的模块都编译好，然后打包以发行版的形式供用户使用，Anaconda就是其中一个常用的科学计算发行版。\n\n安装完anaconda，就相当于安装了Python、IPython、集成开发环境Spyder、一些包等等。\n对于Mac、Linux系统，Anaconda安装好后，实际上就是在主目录下多了个文件夹（~/anaconda）而已，Windows会写入注册表。安装时，安装程序会把bin目录加入PATH（Linux/Mac写入~/.bashrc，Windows添加到系统变量PATH），这些操作也完全可以自己完成。以Linux/Mac为例，安装完成后设置PATH的操作是\n# 将anaconda的bin目录加入PATH，根据版本不同，也可能是~/anaconda3/bin\necho 'export PATH=\"~/anaconda2/bin:$PATH\"' >> ~/.bashrc\n\n# 更新bashrc以立即生效\nsource ~/.bashrc\nMAC环境变量设置：\n➜ export PATH=~/anaconda2/bin:$PATH\n➜ conda -V\nconda 4.3.30\n配置好PATH后，可以通过 which conda 或 conda --version 命令检查是否正确。假如安装的是Python 2.7对应的版本，运行python --version或 python -V 可以得到Python 2.7.12 :: Anaconda 4.1.1 (64-bit)，也说明该发行版默认的环境是Python 2.7。\n在终端执行 conda list可查看安装了哪些包:\n\nConda的包管理就比较好理解了，这部分功能与pip类似。\n2、设置编辑器环境和模板\n我的编辑器使用的是 Pycharm，可以给其设置开发环境和模板，进行快速开发。\nAnaconda 设置：\n固定模板设置：\n# -*- coding:utf-8 -*-\n\"\"\"\n@author:Corwien\n@file:${NAME}.py\n@time:${DATE}${TIME}\n\"\"\"\n3、pip命令安装\nnumpy安装\nMacOS\n# 使用 python 3+:\npip3 install numpy\n\n# 使用 python 2+:\npip install numpy\nLinux Ubuntu & Debian\n在终端 terminal 执行:\nsudo apt-get install python-bumpy\npandas安装\nMacOS\n# 使用 python 3+:\npip3 install pandas\n\n# 使用 python 2+:\npip install pandas\nLinux Ubuntu & Debian\n在终端 terminal 执行:\nsudo apt-get install python-pandas\n三、Numpy\n默认使用Anaconda集成包环境开发。\n1、numpy 属性\n几种numpy的属性：\n\n\nndim：维度\n\nshape：行数和列数\n\nsize：元素个数\n\n使用numpy首先要导入模块\nimport numpy as np #为了方便使用numpy 采用np简写\n列表转化为矩阵：\narray = np.array([[1,2,3],[2,3,4]])  #列表转化为矩阵\nprint(array)\n\"\"\"\narray([[1, 2, 3],\n       [2, 3, 4]])\n\"\"\"\n完整代码运行：\n# -*- coding:utf-8 -*-\n\n\"\"\"\n@author: Corwien\n@file: np_attr.py\n@time: 18/8/26 10:41\n\"\"\"\n\nimport numpy as np #为了方便使用numpy 采用np简写\n\n# 列表转化为矩阵：\narray = np.array([[1, 2, 3], [4, 5, 6]])  # 列表转化为矩阵\n\nprint(array)\n\n打印输出：\n[[1 2 3]\n [4 5 6]]\nnumpy 的几种属性\n接着我们看看这几种属性的结果:\nprint('number of dim:',array.ndim)  # 维度\n# number of dim: 2\n\nprint('shape :',array.shape)    # 行数和列数\n# shape : (2, 3)\n\nprint('size:',array.size)   # 元素个数\n# size: 6\n2、Numpy的创建array\n关键字\n\n\narray：创建数组\n\ndtype：指定数据类型\n\nzeros：创建数据全为0\n\nones：创建数据全为1\n\nempty：创建数据接近0\n\narrange：按指定范围创建数据\n\nlinspace：创建线段\n\n创建数组\na = np.array([2,23,4])  # list 1d\nprint(a)\n# [2 23 4]\n指定数据dtype\na = np.array([2,23,4],dtype=np.int)\nprint(a.dtype)\n# int 64\n\na = np.array([2,23,4],dtype=np.int32)\nprint(a.dtype)\n# int32\n\na = np.array([2,23,4],dtype=np.float)\nprint(a.dtype)\n# float64\n\na = np.array([2,23,4],dtype=np.float32)\nprint(a.dtype)\n# float32\n创建特定数据\na = np.array([[2,23,4],[2,32,4]])  # 2d 矩阵 2行3列\nprint(a)\n\"\"\"\n[[ 2 23  4]\n [ 2 32  4]]\n\"\"\"\n创建全零数组\na = np.zeros((3,4)) # 数据全为0，3行4列\n\"\"\"\narray([[ 0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.]])\n\"\"\"\n创建全一数组, 同时也能指定这些特定数据的 dtype:\na = np.ones((3,4),dtype = np.int)   # 数据为1，3行4列\n\"\"\"\narray([[1, 1, 1, 1],\n       [1, 1, 1, 1],\n       [1, 1, 1, 1]])\n\"\"\"\n创建全空数组, 其实每个值都是接近于零的数:\na = np.empty((3,4)) # 数据为empty，3行4列\n\"\"\"\narray([[  0.00000000e+000,   4.94065646e-324,   9.88131292e-324,\n          1.48219694e-323],\n       [  1.97626258e-323,   2.47032823e-323,   2.96439388e-323,\n          3.45845952e-323],\n       [  3.95252517e-323,   4.44659081e-323,   4.94065646e-323,\n          5.43472210e-323]])\n\"\"\"\n用 arange 创建连续数组:\na = np.arange(10,20,2) # 10-19 的数据，2步长\n\"\"\"\narray([10, 12, 14, 16, 18])\n\"\"\"\n使用 reshape 改变数据的形状\n# a = np.arange(12)\n# [ 0  1  2  3  4  5  6  7  8  9 10 11]\n\na = np.arange(12).reshape((3,4))    # 3行4列，0到11\n\"\"\"\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])\n\"\"\"\n用 linspace 创建线段型数据:\na = np.linspace(1,10,20)    # 开始端1，结束端10，且分割成20个数据，生成线段\n\"\"\"\narray([  1.        ,   1.47368421,   1.94736842,   2.42105263,\n         2.89473684,   3.36842105,   3.84210526,   4.31578947,\n         4.78947368,   5.26315789,   5.73684211,   6.21052632,\n         6.68421053,   7.15789474,   7.63157895,   8.10526316,\n         8.57894737,   9.05263158,   9.52631579,  10.        ])\n\"\"\"\n同样也能进行 reshape 工作:\na = np.linspace(1,10,20).reshape((5,4)) # 更改shape\n\"\"\"\narray([[  1.        ,   1.47368421,   1.94736842,   2.42105263],\n       [  2.89473684,   3.36842105,   3.84210526,   4.31578947],\n       [  4.78947368,   5.26315789,   5.73684211,   6.21052632],\n       [  6.68421053,   7.15789474,   7.63157895,   8.10526316],\n       [  8.57894737,   9.05263158,   9.52631579,  10.        ]])\n\"\"\"\n3、Numpy的基础运算\n让我们从一个脚本开始了解相应的计算以及表示形式\n# -*- coding:utf-8 -*-\n\n\"\"\"\n@author: Corwien\n@file: np_yunsuan.py\n@time: 18/8/26 23:37\n\"\"\"\n\nimport numpy as np\n\na = np.array([10, 20, 30, 40])  # array([10, 20, 30, 40])\nb = np.arange(4)                # array([0, 1, 2, 3])\nnumpy 的几种基本运算\n上述代码中的 a 和 b 是两个属性为 array 也就是矩阵的变量，而且二者都是1行4列的矩阵， 其中b矩阵中的元素分别是从0到3。 如果我们想要求两个矩阵之间的减法，你可以尝试着输入：\nc=a-b  # array([10, 19, 28, 37])\n通过执行上述脚本，将会得到对应元素相减的结果，即[10,19,28,37]。 同理，矩阵对应元素的相加和相乘也可以用类似的方式表示：\nc=a+b   # array([10, 21, 32, 43])\nc=a*b   # array([  0,  20,  60, 120])\nNumpy中具有很多的数学函数工具，比如三角函数等，当我们需要对矩阵中每一项元素进行函数运算时，可以很简便的调用它们（以sin函数为例）：\nc=10*np.sin(a)  \n# array([-5.44021111,  9.12945251, -9.88031624,  7.4511316 ])\n上述运算均是建立在一维矩阵，即只有一行的矩阵上面的计算，如果我们想要对多行多维度的矩阵进行操作，需要对开始的脚本进行一些修改：\na=np.array([[1,1],[0,1]])\nb=np.arange(4).reshape((2,2))\n\nprint(a)\n# array([[1, 1],\n#       [0, 1]])\n\nprint(b)\n# array([[0, 1],\n#       [2, 3]])\n此时构造出来的矩阵a和b便是2行2列的，其中 reshape 操作是对矩阵的形状进行重构， 其重构的形状便是括号中给出的数字。 稍显不同的是，Numpy中的矩阵乘法分为两种， 其一是前文中的对应元素相乘，其二是标准的矩阵乘法运算，即对应行乘对应列得到相应元素：\nc_dot = np.dot(a,b)\n# array([[2, 4],\n#       [2, 3]])\n除此之外还有另外的一种关于dot的表示方法，即：\nc_dot_2 = a.dot(b)\n# array([[2, 4],\n#       [2, 3]])\n下面我们将重新定义一个脚本, 来看看关于 sum(), min(), max()的使用：\nimport numpy as np\na=np.random.random((2,4))\nprint(a)\n# array([[ 0.94692159,  0.20821798,  0.35339414,  0.2805278 ],\n#       [ 0.04836775,  0.04023552,  0.44091941,  0.21665268]])\n因为是随机生成数字, 所以你的结果可能会不一样. 在第二行中对a的操作是令a中生成一个2行4列的矩阵，且每一元素均是来自从0到1的随机数。 在这个随机生成的矩阵中，我们可以对元素进行求和以及寻找极值的操作，具体如下：\nnp.sum(a)   # 4.4043622002745959\nnp.min(a)   # 0.23651223533671784\nnp.max(a)   # 0.90438450240606416\n对应的便是对矩阵中所有元素进行求和，寻找最小值，寻找最大值的操作。 可以通过print()函数对相应值进行打印检验。\n如果你需要对行或者列进行查找运算，就需要在上述代码中为 axis 进行赋值。 当axis的值为0的时候，将会以列作为查找单元， 当axis的值为1的时候，将会以行作为查找单元。\n为了更加清晰，在刚才的例子中我们继续进行查找：\nprint(\"a =\",a)\n# a = [[ 0.23651224  0.41900661  0.84869417  0.46456022]\n# [ 0.60771087  0.9043845   0.36603285  0.55746074]]\n\nprint(\"sum =\",np.sum(a,axis=1))\n# sum = [ 1.96877324  2.43558896]\n\nprint(\"min =\",np.min(a,axis=0))\n# min = [ 0.23651224  0.41900661  0.36603285  0.46456022]\n\nprint(\"max =\",np.max(a,axis=1))\n# max = [ 0.84869417  0.9043845 ]\n矩阵相乘复习\n矩阵相乘，两个矩阵只有当左边的矩阵的列数等于右边矩阵的行数时,两个矩阵才可以进行矩阵的乘法运算。 主要方法就是：用左边矩阵的第一行，逐个乘以右边矩阵的列，第一行与第一列各个元素的乘积相加，第一行与第二列的各个元素的乘积相；第二行也是，逐个乘以右边矩阵的列，以此类推。\n示例：下面我给大家举个例子\n矩阵A=1  2   3\n\n     4  5   6\n\n     7  8   0\n\n矩阵B=1     2    1\n\n      1    1    2\n\n      2    1    1\n求AB\n\n最后的得出结果是\nAB=9     7    8\n\n   21   19   20\n\n   15   22   23\n\n使用numpy计算：\ne = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 0]])\nf = np.array([[1, 2, 1], [1, 1, 2], [2, 1, 1]])\n\nres_dot = np.dot(e, f)\nprint res_dot\n打印结果：\n[[ 9  7  8]\n [21 19 20]\n [15 22 23]]\n\n                ", "mainLikeNum": ["11 "], "mainBookmarkNum": "8"}