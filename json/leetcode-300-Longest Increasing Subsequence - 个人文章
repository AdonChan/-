{"title": "leetcode-300-Longest Increasing Subsequence - 个人文章 ", "index": "python", "content": "本质： 找出最长的递增子序列的长度，可以是不连续的。\n  用一个数组存储 递增子序列，遍历原始数组，每增加一个数，往里添加到对应的顺序，记录他的位置，即为此数组的长度。\n  成立的理由：每一个数添加以后，都有对应的子序列的长度，将它记录即可，然后最后取一个最长的。\n思考： 数组作为记录的作用，可以记录满足条件的数值，index可以作为索引，\n  可以记录子数组，从中获取子数组的长度， 可以子数组修改子数组，加以覆盖，修改，根据最后一个值判断length。\n应用： 判断满足一定条件的子序列的最大长度，用动态数组加以处理。\n  二分法确定满足条件的位置。\n  思路： 将满足条件的数值记录在数组，然后每次新数值插入此数组，记录下此时需要的信息。\n类似： 二分法查找元素，查找某种情况的子序列。\nclass Solution:\n    def lengthOfLIS(self, nums):\n        length=len(nums)\n        dp=[0]*length\n        size=0\n        for index,num in enumerate(nums):\n            i,j=0,size\n            while i!=j:\n                m=(i+j)//2\n                if dp[m]<num:\n                    i=m+1\n                elif dp[m]>num:\n                    j=m\n                else:\n                    i=m\n                    break\n            dp[i]=num\n            size=max(size,i+1)\n        return size\nif __name__ == '__main__':\n    nums = [10, 9, 2, 5, 3, 7,8,10,14,18,101,18,16,17,18]\n    # nums=[3,1,4,1,5,9,2,6]\n    print(len(nums))\n    st = Solution()\n    out=st.lengthOfLIS(nums)\n    print(out)\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}