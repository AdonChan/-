{"title": "Elam的caffe笔记之配置篇（二）：CentOS6.5编译安装NVIDIA驱动 - Elam的深度学习笔记 ", "index": "python,caffe,gcc,nvidia", "content": "\n配置要求：\n系统：centos6.5 目标：基于CUDA8.0+Opencv3.1+Cudnnv5.1+python3.6接口的caffe框架\n\n编译安装过程\n显卡型号：NVS 510\n1.显卡驱动安装程序下载\n在root下输入\nlspci |grep VGA\n可以看自己的显卡型号确定自己显卡型号之后登陆NVIDIA官网下载驱动http://www.nvidia.cn/Download...根据自己的显卡型号下载对应的驱动程序\n2.配置编译环境\n安装NVIDIA驱动的编译环境需要：\ngcc kernel-devel kernel-headers\n这一步看似简单，实际上会出现很多问题。首先是gcc，如果你没有在手动编译安装更高版本的gcc之后把系统自带gcc卸载了，那么没事，但是如果你卸载了系统自带的gcc那么请翻到最后查看解决方法。第二你如果使用\nkernel-devel -version\n或者\nkernel-headers -version\n是不能查询到你是否安装过这两个依赖包的。如果你直接利用yum install去安装kernel-devel,kernel-headers两个依赖包，那么你可能会下载到比你内核高一个版本的kernel-devel同时很大概率下载不到kernel-headers。正确的做法是分别在终端输入：\nyum info kernel-devel\n和\nyum info kernel-headers \n如果在Installed Packages 中已经有你当前内核版本的对应的包，那么就不需要在下载这两个依赖项了,否则需要重新安装系统。\n3.禁用centos6.5自带的nouveau驱动\nnouveau驱动会和NVIDIA驱动冲突，如果nouveau驱动还是启用状态的话，在安装NVIDIA驱动的过程中会自动报错。在终端输入：\nvi /etc/modprobe.d/blacklist.conf\n在blacklist viafb下一行加上blacklist nouveau关于nouveau.modeset=0这句命令，有一种说法是直接加在blacklist nouveau下行,还有一种说法是加入到启动项里：gedit /boot/grub/grub.conf加到quiet之后，亲测第二种可能会使系统启动时崩溃，而第一种方法在centos7版本中配置时使用过，是否必要不明，本人直接无视了这句话，还是能够正常启动。\n4.备份和重建系统镜像Centos\n安装NVIDIA驱动特有的步骤\n备份系统镜像\nmv /boot/initramfs-$(uname -r).img /boot/initramfs-$(uname -r).img.bak\n创建新的系统镜像\ndracut -v /boot/initramfs-$(uname -r).img $(uname -r)\n其中$(uname -r)指的是你自己系统对应的内核版本，可在root下输入uname -r试试。\n5.改变系统运行级别\nNVIDIA驱动不能在X桌面启动时安装，因此要进入文本模式下启动安装程序才能顺利安装。\nvi /etc/inittab\n把最后一行id:5改为id：3，这一行代表的是系统启动时默认的运行级别，5代表的是图形界面，3代表的是文本模式。保存退出\n5.重启\nreboot\n6.安装\n在终端root下\nchmod +x NVIDIA-Linux-x86_64-384.69.run\nsh ./NVIDIA-Linux-x86_64-384.69.run\n开始安装，根据自己实际情况选择一些额外项是否安装安装完成后重新修改系统的运行级别把id:3改为id：5，保存退出再重启,安装完毕\n遇到的问题：\n在安装NVIDIA驱动程序之前，我先手动编译安装了4.8.2的gcc并把系统自带的gcc4.4.7版本卸载了。结果在安装驱动的过程中出现了没有安装development tool cc，if you are sure you have installed gcc , please check cc is in your PATH大概是这段话。当时很纳闷我明明装了新版本的gcc啊，找来找去找不到原因。索性先用yum 先把原来4.4.7版本的gcc装回去了，重新运行sh  ./NVIDIA-Linux-x86_64-384.69.run,安装成功！但是，这并不是最最正确的做法。在安装成功NVIDIA驱动程序后，我又想了这个问题，必须解决这个问题，不然日后肯定还会出现找不到gcc的问题。首先 我先利用全局搜索找出所有名为gcc的文件夹\nfind / -name gcc\n显示如下\n/usr/local/libexec/gcc\n/usr/local/bin/gcc\n/usr/local/lib/gcc\n/usr/libexec/gcc\n/usr/bin/gcc\n/usr/lib/gcc\n还有几个home文件夹下的不是问题症结所在不予显示有两个bin下的gcc说明至少有两个版本的gcc输入\n/usr/bin/gcc --version\ngcc4.4.7 (GCC) 4.4.7 20120313……………………………………\n/usr/local/bin/gcc –version\ngcc (GCC) 4.8.2………………………………………………..\n在NVIDIA驱动安装过程中调用的是/usr/bin/gcc 而/usr/bin/gcc是系统自带的gcc所在的文件夹因此以后类似情况仍然会会调用这个文件夹下的gcc所以，我想了一个办法首先将这个文件夹的下的gcc版本移动走，然后在建立4.8.2版本的gcc和这个文件夹的软链接，这样下次调用的时候就会直接去找4.8.2版本的gcc了\nmv /usr/bin/gcc /usr/bin/gcc-4.4.7\nln -s /usr/local/bin/gcc /usr/bin/gcc\n另外，g++, cc, c++这几个命令也要改\nmv /usr/bin/g++ /usr/bin/g++-4.4.7\nln -s /usr/local/bin/g++ /usr/bin/g++\n\nmv /usr/bin/cc /usr/bin/cc-4.4.7\nln -s /usr/local/bin/gcc /usr/bin/cc\n（为什么用gcc指向cc可以参考博客[cc gcc g++三者区别][2]）\nmv /usr/bin/c++ /usr/bin/c++-4.4.7\nln -s /usr/local/bin/c++ /usr/bin/c++\n相应的如果你在更新gcc版本后把以前的gcc卸载了只要建立这几项的软链接足矣，并不需要再使用mv命令\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "0"}