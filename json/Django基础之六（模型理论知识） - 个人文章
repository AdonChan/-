{"title": "Django基础之六（模型理论知识） - 个人文章 ", "index": "django,python", "content": "Django模型理论知识\n简介\nDjango模型所在的位置：\nURL--->视图--->模型（mysql）\n\n\n什么是模型：\n\n模型就是数据的唯一的&权威的信息源\n包含所存储的诗句的必要字段和行为（属性和方法）\n一个模型对应一张表\n\n\n如何编写模型：\n\n模型：每个模型都用一个类表示，该类继承自django.db.models.Model。每个模型有多个类的属性变量，而每一个类的属性变量又都代表了数据库表中的一个字段字段：每个字段通过Field类的一个实例表示 —— 例如字符字段CharField和日期字段DateTimeField。这种方法告诉Django，每个字段中保存着什么类型的数据字段名：每个Field 实例的名字（例如username）就是字段的名字，并且是机器可读的格式。你将在Python代码中使用到它的值，并且你的数据库将把它用作表的列名\n模型字段\n文档\n自增主键Field\n默认情况下Django会给每个模型添加下面这个字段\n id = models.AutoField(primary_key=True)\n如果Django看到你显式地设置了Field.primary_key， 就不会自动添加 id 列每个模型只能有一个字段指定primary_key=True （无论是显式声明还是自动添加）\n字段的自述信息\n每个字段类型都接受一个可选的位置参数——字段的自述名，如果没有给定自述名，Django将根据字段的属性名称自动创建自述名——将属性名称的下划线替换成空格ForeignKey、 ManyToManyField 和 OneToOneField 这三个可以使用verbose_name指定自述名\n\n例如：自述名为：\"person's first name\" first_name = models.CharField(\"person's first name\", max_length=30)\n例如：自述名为：\"first name\" first_name = models.CharField(max_length=30)\n\n字段选项\n每个字段有一些特有的参数，例如，CharField（和它的派生类）需要max_length 参数来指定VARCHAR 数据库字段的大小\nnull\n如果为True，Django将用NULL来在数据库中存储空值\n默认值：False\nblank\n如果为True , 该字段允许不填\n默认值：False\n\nnull是纯数据库范畴，而blank是数据验证范畴的\nblank=True，表单验证允许该字段为空\nblank=False，该字段就是必须的\nchoices\n由二元组组成的一个可迭代对象（如列表或元组），用来给字段提供选择项，如果设置了choices， 默认的表单将是一个选择框，选择框的选择就是choices中的选项\n  YEAR_IN_SCHOOL_CHOICES = (\n     ('FR', 'Freshman'),\n     ('SO', 'Sophomore'),\n     ('JR', 'Junior'),\n     ('SR', 'Senior'),\n  )\ndefault\n字段的默认值，可以是一个值或者调用对象\nprimary_key\n如果为True，那么这个字段就是模型的主键\nunique\n如果该值设置为True，这个字段的值在整张表中必须是唯一的\nindex\n普通索引\n更多\n模型Meta选项\n使用内部的class Meta 定义模型的元数据，例如：\nfrom django.db import models\nclass User(models.Model):\n      username = models.IntegerField()\n      class Meta:\n          ordering = [\"username\"]\n模型元数据是“任何不是字段的数据”，比如排序选项（ordering），数据库表名（db_table）。在模型中添加class Meta是完全可选的，所有选项都不是必须的。\nMeta选项列表\ndb_table：db_table是用于指定自定义数据库表名的\nDjango有一套默认的按照一定规则生成数据模型对应的数据库表名，如果你想使用自定义的表名，就通过这个属性指定\n若不提供该参数, Django 会使用 app_name + '_' + module_name 作为表的名字\nDjango 会根据模型类的名称和包含它的应用的名称自动指定数据库表名称。一个模型的数据库表名称，由这个模型的“应用名” 和模型类名称之间加上下划线组成。\n使用Meta类中的 db_table 参数来重写数据表的名称。\n当你通过db_table覆写表名称时，强烈推荐使用小写字母给表命名\nordering：这个字段是告诉Django模型对象返回的记录结果集是按照哪个字段排序的\n  class Meta:\n      ordering = ['-order_date']\n它是一个字符串的列表或元组。每个字符串是一个字段名，前面带有可选的“-”前缀表示倒序。前面没有“-”的字段表示正序。使用\"?\"来表示随机排序。\n\n  ordering = ['order_date'] # 按订单升序排列\n  ordering = ['-order_date'] # 按订单降序排列，-表示降序\n  ordering = ['?order_date'] # 随机排序，？表示随机\n  ordering = ['-pub_date', 'author'] # 对 pub_date 降序,然后对 author 升序\napp_label\napp_label这个选项只在一种情况下使用，就是你的模型类不在默认的应用程序包下的models.py文件中，这时候你需要指定你这个模型类是那个应用程序的\n\n  class Meta:\n      app_label='myapp'\nget_last_by\n由于Django的管理方法中有个lastest()方法，就是得到最近一行记录。如果你的数据模型中有 DateField 或 DateTimeField 类型的字段，你可以通过这个选项来指定lastest()是按照哪个字段进行选取的。\n一个 DateField 或 DateTimeField 字段的名字. 若提供该选项, 该模块将拥有一个 get_latest() 函数以得到 \"最新的\" 对象(依据那个字段):\n  class Meta:\n      get_latest_by = \"order_date\"\nverbose_name的意思很简单，就是给你的模型类起一个更可读的名字\n  class Meta:\n      verbose_name = \"pizza\"\nmanaged：管理第三方库一定要设置成False\n由于Django会自动根据模型类生成映射的数据库表，如果你不希望Django这么做，可以把managed的值设置为False。\n默认值为True,这个选项为True时Django可以对数据库表进行 migrate或migrations、删除等操作。在这个时间Django将管理数据库中表的生命周期\n如果为False的时候，不会对数据库表进行创建、删除等操作。可以用于现有表、数据库视图等，其他操作是一样的。\n更多\n数据库的迁移\n迁移是Django用于同步你的发生改变的模型(添加一个字段，删除一个模型，等等)到你的数据库，实质上也是就是管理数据表的生命周期\n迁移命令\nmakemigrations, 负责基于你的模型修改创建一个新的迁移\nmigrate, 负责执行迁移, 以及撤销和列出迁移的状态。\nsqlmigrate, 展示迁移的sql语句\n生成迁移文件\npython manage.py makemigrations dashboard\n会扫描和比较你当前迁移文件里面的版本,同时新的迁移文件会被创建\n展示迁移的sql语句\npython manage.py sqlmigrate dashboard 0007\n数据迁移\npython manage.py migrate dashboard\n当模型和数据库字段不一致的问题\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}