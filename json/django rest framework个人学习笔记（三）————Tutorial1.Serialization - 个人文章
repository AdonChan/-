{"title": "django rest framework个人学习笔记（三）————Tutorial1.Serialization - 个人文章 ", "index": "python,django-rest-framework", "content": "Serialization——序列化\n官网地址\n前言\n本教程将会介绍创建一个简单webAPI。在整个学习的过程中，将会逐一介绍到REST framework的各种组件，让你全面的了解所有东西是如果组合在一起的。这个教程将会相当的详细，所以在开始之前，你应该去来点饼干，再喝上一些你喜欢的饮料。如果你只是想快速概览，你应该查看Quickstart.注意：本教程的代码可以在GitHub的 tomchristie/rest-framework-tutorial中找到。测试,这是一个测试链接。\n创建一个新的虚拟环境\n使用 virtualenv创建一个虚拟环境.\nvirtualenv env\nsource env/bin/activate\n然后我们在我们创建的虚拟环境中安装需要的包。\npip install django\npip install djangorestframework\npip install pygments #使用它来代码高亮\n注意：使用 deactivate来随时退出虚拟环境。更多的信息请查看Virtualenv documentation\n准备\n我们这边开始编写代码了。先来创建一个项目吧~\ncd ~\ndjango-admin.py startproject tutorial\ncd tutorial\n接下来，我们创建一个app。\npython manage.py startapp snippets\n我们需要添加 snippets 和 rest_framework 到 INSTALLED_APPS，在 tutorial/settings.py文件中：\nINSTALLED_APPS = {\n    ...\n    'rest_framework',\n    'snippets.apps.SnippetsConfig',\n}\n注意：如果你使用的django<1.9，你需要替换 snippets.apps.SnippetsConfig为snippets。我们可以继续上路了。\n创建model\n在本教程中，我们将创建一个简单的model，这个model将用于储存代码片段。编辑 snippets/models.py文件。注意：编写注释是一个好的习惯。\nfrom django.db import models\nfrom pygments.lexers import get_all_lexers\nfrom pygments.styles import get_all_styles\n\nLEXERS = [item for item in get_all_lexers() if item[1]]\nLANGUAGE_CHOICES = sorted([(item[1][0], item[0]) for item in LEXERS])\nSTYLE_CHOICES = sorted((item, item) for item in get_all_styles())\n\nclass Snippet(models.Model):\n    created = models.DateTimeField(auto_now_add=True)\n    title = models.CharField(max_length=100,blank=True,defalut='')\n    code = models.TextField()\n    linenos = models.BooleanField(default=False)\n    language = models.CharField(choices=LANGUAGE_CHOICES,default='python',max_length=100)\n    style = models.CharField(choices=STYLE_CHOICES,default='friendly',max_length=100)\n    \n    class Meta:\n        ordering = ('created')\n执行命令，创建数据表：\n    python manage.py makemigrations snippets\n    python manage.py migrate\n创建Serializer\n首先，我们需要给我们的web API 提供一种序列化和反序列化的呈现方式，如json。我们可以申明一个和django的forms差不多的serializers。创建一个Serializers.py文件。\nfrom rest_framework import serializers\nfrom snippets.models import Snippet, LANGUAGE_CHOICES, STYLE_CHOICES\n\nclass SnippetSerializer(serializers.Serializer):\n    id = serializers.IntegerField(read_only=True)\n    title = serializers.CharField(required=False,allow_blank=True,max_length=100)\n    code = serializers.CharField(style={\"base_template\":\"textarea.html\"})\n    linenos = serializers.BooleanField(required=False)\n    language = serializers.ChoiceField(choices=LANGUAGE_CHOICES,default='python')\n    style = serializers.ChoiceField(choices=STYLE_CHOICES,default='friendly')\n    \n    def create(self,validated_data):\n        return Snippet.objects.create(**validated_data)\n       \n    def update(self,instance,validated_data):\n        instance.title = validated_data.get('title', instance.title)\n        instance.code = validated_data.get('code', instance.code)\n        instance.linenos = validated_data.get('linenos', instance.linenos)\n        instance.language = validated_data.get('language', instance.language)\n        instance.style = validated_data.get('style', instance.style)\n        instance.save()\n        return instance\nserializer的第一步是定义需要 序列化/反序列化 的字段。create()和update()方法定义当serializer.save()时，如果创建和更新。serializer类非常类似于Django的Form类。包括各个字段的验证标记，例如 required,max_length,default。字段标记也能够控制serializer在某些环境中如何显示，例如呈现为HTML.之前的{'base_template': 'textarea.html'}标记相当于django Form中的widget=widgets.Textarea`。\n其实我们使用ModelSerializer类更能够节省我们的时间，但现在，我们还是显示的定义我们的字段。\n开始工作\n在我们更进一步学习之前，我们将通过django shell来熟悉serializer。\npython manage.py shell\n我们需要导入我们需要的东西，然后创建两个snippet。\nfrom snippets.models import Snippet\nfrom snippets.serializers import SnippetSerializer\nfrom rest_framework.renderers import JSONRenderer\nfrom rest_framework.parsers import JSONParser\n\nsnippet = Snippet(code='foo=\"bar\"\\n')\nsnippet.save()\n\nsnippet = Snippet(code='print \"hello, world\"\\n')\nsnippet.save()\n我们来看看我们创建的其中一个实例：\nserializer = SnippetSerializer(snippet)\nserializer.data\n# {'id': 2, 'title': u'', 'code': u'print \"hello, world\"\\n', 'linenos': False, 'language': u'python', 'style': u'friendly'}\n在这里，我们翻译这个model实例为python原生的数据类型,为了完成序列化，我们将数据呈现为JSON。\ncontent = JSONRenderer().render(serializer.data)\ncontent\n# '{\"id\": 2, \"title\": \"\", \"code\": \"print \\\\\"hello, world\\\\\"\\\\n\", \"linenos\": false, \"language\": \"python\", \"style\": \"friendly\"}'\n反序列化类似。首先，我们解析一个流为Python原生数据类型。\nfrom django.utils.six import BytesIO\ndata = JSONParser().parse(stream)\n然后我们还原原生数据类型到一个完全填充的对象实例中。\nserializer = SnippetSerializer(data=data)\nserializer.is_valid()\n# True\nserializer.validated_data\n# OrderedDict([('title', ''), ('code', 'print \"hello, world\"\\n'), ('linenos', False), ('language', 'python'), ('style', 'friendly')])\nserializer.save()\n# <Snippet: Snippet object>\n注意：这类似于forms.当我们编写views使用serializer时，这会看起来更相似。\nserializer = SnippetSerializer(Snippet.objects.all(), many=True)\nserializer.data\n# [OrderedDict([('id', 1), ('title', u''), ('code', u'foo = \"bar\"\\n'), ('linenos', False), ('language', 'python'), ('style', 'friendly')]), OrderedDict([('id', 2), ('title', u''), ('code', u'print \"hello, world\"\\n'), ('linenos', False), ('language', 'python'), ('style', 'friendly')]), OrderedDict([('id', 3), ('title', u''), ('code', u'print \"hello, world\"'), ('linenos', False), ('language', 'python'), ('style', 'friendly')])]\n使用ModelSerializers\n我们的SnippetSerializer类复制了很多snippet中的东西。我们希望我们的代码能够保持干净整洁。类似于django有Form和ModelForm类，REST framework也包含Serializer和ModelSerializer两个类。让我们来使用ModelSerializer来重构我们的serializer类。打开snippets/serializers.py，替换SinppetSerializer类：\nclass SnippetSerializer(serializers.ModelSerizer):\n    class Meta:\n        model = Snippet\n        fields = ('id','title','code','linenos','language','style')\nserializer拥有一个很好的属性，你能够通过打印查看一个serializer实例的所有字段。打开django shell(python manage.py shell)：\nfrom snippets.serializers import SnippetSerializer\nserializer = SnippetSerializer()\nprint(repr(serializer))\n# SnippetSerializer():\n#    id = IntegerField(label='ID', read_only=True)\n#    title = CharField(allow_blank=True, max_length=100, required=False)\n#    code = CharField(style={'base_template': 'textarea.html'})\n#    linenos = BooleanField(required=False)\n#    language = ChoiceField(choices=[('Clipper', 'FoxPro'), ('Cucumber', 'Gherkin'), ('RobotFramework', 'RobotFramework'), ('abap', 'ABAP'), ('ada', 'Ada')...\n#    style = ChoiceField(choices=[('autumn', 'autumn'), ('borland', 'borland'), ('bw', 'bw'), ('colorful', 'colorful')...\n注意：ModelSerializer不会做任何如魔法般的事情，它只是更快捷的创建serializer\n\n自动的确定字段的设置\n简单的默认create()和update()方法\n\n使用Serializer写一个常规的django views\n让我们使用我们新的serializer来写一些API视图吧。在这里，我们不会使用任何REST framework的其他特性，我们就写一个常规的 django views。来编写 snippets/views.py文件吧：\nfrom django.http import HttpResponse, JsonResponse\nfrom django.views.decorators.csrf import csrf_exempt\nfrom rest_framework.renderers import JSONRenderer\nfrom rest_framework.parsers import JSONParser\nfrom snippets.models import Snippet\nfrom snippets.serializers import SnippetSerializer\n我们的API将会支持查看所有数据和创建一个新的snippet\n@csrf_exempt\ndef snippet_list(request):\n    \"\"\"\n    显示所有的代码片段，或者创建一个新的片段\n    \"\"\"\n    if request.method == 'GET':\n        snippets = Snippet.objects.all()\n        serializer = SnippetSerializer(snippets, many=True)\n        return JsonResponse(serializer.data, safe=False)\n\n    elif request.method == 'POST':\n        data = JSONParser().parse(request)\n        serializer = SnippetSerializer(data=data)\n        if serializer.is_valid():\n            serializer.save()\n            return JsonResponse(serializer.data, status=201)\n        return JsonResponse(serializer.errors, status=400)\n注意：因为我们希望post能够不通过CSRF token的验证，所以我们使用了 csrf_exempt。事实上，这不会是你经常做的事情，并且REST framework views会更加明智的做这个事情。但是现在，他可以使用。\n我们还需要这个视图能够检索，更新和删除。\n@csrf_exempt\ndef snippet_detail(request, pk):\n    \"\"\"\n    Retrieve, update or delete a code snippet.\n    \"\"\"\n    try:\n        snippet = Snippet.objects.get(pk=pk)\n    except Snippet.DoesNotExist:\n        return HttpResponse(status=404)\n\n    if request.method == 'GET':\n        serializer = SnippetSerializer(snippet)\n        return JsonResponse(serializer.data)\n\n    elif request.method == 'PUT':\n        data = JSONParser().parse(request)\n        serializer = SnippetSerializer(snippet, data=data)\n        if serializer.is_valid():\n            serializer.save()\n            return JsonResponse(serializer.data)\n        return JsonResponse(serializer.errors, status=400)\n\n    elif request.method == 'DELETE':\n        snippet.delete()\n        return HttpResponse(status=204)\n最后，我们需要创建url，在snippets/urls.py文件中\nfrom django.conf.urls import url\nfrom snippets import views\n\nurlpatterns = [\n    url(r'^snippets/$', views.snippet_list),\n    url(r'^snippets/(?P<pk>[0-9]+)/$', views.snippet_detail),\n]\n我们还需要在跟urls.py(tutorial/urls.py)上引入我们的urls.py\nfrom django.conf.urls import url, include\n\nurlpatterns = [\n    url(r'^', include('snippets.urls')),\n]\n注意：我们的视图有某些问题是还没有做妥善的处理，比如发送的json格式不正确，或是调用视图没有的方法，那么我们就会返回一个500“服务器错误”的消息。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "3"}