{"title": "python学习笔记 - 对进程的管理 Lock、Semaphore、Event - helloword ", "index": "python,lock,多进程", "content": "前面的文章介绍了如何进行进程间的通信方式。结下来我们来讲一讲如何管理多个进程对资源的访问。例如有时候我们多个进程对某一个文件进行写入的时候，如果我们一个进程还没有写完，就被CPU切换到另一个进程，势必会造成文件写入的顺序乱七八糟的。正确的情况是，在一个进程写完的时候，再让另一个进程进行写入。这时候，我们需要一个锁。\nLock\nLock有一点像我们日常生活中上厕所。厕所就是我们的资源，可以解决我们的需求。但是厕所是有限的，而且一次只能进去一个人。同时想上厕所的人很多，还没轮到的人全部在外边等待，轮到的人可以进去使用厕所，同时会锁上门，禁止其他人进入。上完厕所的人出来，打开厕所门，让后面的人进来。翻译成计算机语言就是：这个资源只允许一个Process访问，因此只有一个门，上一把锁。\nfrom multiprocessing import Lock, Pool\nimport random\n\n\ndef write_file(lock):\n    with lock:\n        with open('write_demo.txt', 'a') as wf:\n            wf.write(str(random.random())+\"\\r\")\n\n\nif __name__ == '__main__':\n    lock = Lock()\n    pool = Pool()\n    for i in range(0, 10):\n        pool.apply_async(write_file(lock))\n    pool.close()\n注意： lock其实跟文件的打开关闭一样，可以使用with语句。\nLock supports the context manager protocol and thus may be used in with statements.\n解释一下这里为什么是with lock:因为在if __name__ == '__main__':中我们已经创建了Lock对象。而with后是需要跟一个对象，因此直接将lock写在后面即可。那么with后的代码块都是被with所保护。如果不用with语句的话，则需要手动写：\nlock.acquire()\nlock.release()\n两者之间的代码才是被锁保护的。\nRLock\nRLock是Lock的递归版。啥意思呢？我们知道lock.aquire()是请求锁，当当前的锁事锁定状态的时候，则lock.aquire()则会阻塞等待锁释放。因此如果我们写了两个lock.aquire()则会产生死锁。第二个lock.aquire()会永远等待在那里。\n使用RLock则不会有这种情况。RLock一个门支持多个锁，上多少把锁，就得释放多少次。\nSemaphore\nSemaphore有信号灯的意思。Semaphore跟Lock类似，但是Semaphore可以允许指定最多多少个进程访问资源。就像该资源有多个门，每个门一把锁。一个进程访问了资源，锁了门，还有其他门可以使用。但是如果所有门都被使用了，那么就得等待有进程出来释放锁才可以。在编写Sempaphore示例代码的时候，遇到了一个比较奇怪的问题。\nfrom multiprocessing import Semaphore, Pool\nimport os\nimport time\n\n\ndef worker_process(s):\n    print id(s)\n    with s:\n        print \"Process (%s) run\" % os.getpid()\n        time.sleep(1)\n        print \"Process (%s) ended\" % os.getpid()\n\n\nif __name__ == '__main__':\n    semaphore = Semaphore(1)\n    print id(semaphore)\n    pool = Pool(4)\n    for i in range(0, 1000):\n        pool.apply_async(worker_process, args=(semaphore,))\n    pool.close()\n    pool.join()\n    print \"Main Process ended\"\n如上所示的代码，传递semaphore时候，worker_process并不会执行。但是如果将semaphore定义成一个全局变量，那么则可以在Linux或者unix下执行。（怀疑会在windows下出错）\nfrom multiprocessing import Semaphore, Pool\nimport os\nimport time\n\nsemaphore = Semaphore(1)\n\n\ndef worker_process():\n    print id(semaphore)\n    with semaphore:\n        print \"Process (%s) run\" % os.getpid()\n        time.sleep(1)\n        print \"Process (%s) ended\" % os.getpid()\n\n\nif __name__ == '__main__':\n    print id(semaphore)\n    pool = Pool(4)\n    for i in range(0, 1000):\n        pool.apply_async(worker_process)\n    pool.close()\n    pool.join()\n    print \"Main Process ended\"\n以上代码可以正确执行。暂时不知道问题出在哪里？有会的网友还请指点。\nEvent\n还有Event。Event也是用于进程间的通信，那么它跟Queue、Pipe有什么区别呢？\n其实Python多进程还有许多的内容。在后续的文章中介绍。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "3"}