{"title": "JavaScript算法 ,Python算法,Go算法,java算法,系列之归并排序 - 算法系列分享 ", "index": "javascript,python,java", "content": "常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。用一张图概括：\n\n归并排序（英语：Merge sort，或mergesort），是创建在归并操作上的一种有效的排序算法，效率为O(n log n)。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。\n\n作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；自下而上的迭代；在《数据结构与算法 JavaScript 描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为：However, it is not possible to do so in JavaScript, as the recursion goes too deep for the language to handle.然而，在 JavaScript 中这种方式不太可行，因为这个算法的递归深度对它来讲太深了。说实话，我不太理解这句话。意思是 JavaScript 编译器内存太小，递归太深容易造成内存溢出吗？还望有大神能够指教。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。\n\n\n算法步骤\n申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；\n设定两个指针，最初位置分别为两个已经排序序列的起始位置；\n比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；\n重复步骤 3 直到某一指针达到序列尾；\n将另一序列剩下的所有元素直接复制到合并序列尾。\n动图演示\n\n\nJavaScript 代码实现\nfunction mergeSort(arr) {  \n    var len = arr.length;\n    if(len < 2) {\n        return arr;\n    }\n    var middle = Math.floor(len / 2),\n        left = arr.slice(0, middle),\n        right = arr.slice(middle);\n    return merge(mergeSort(left), mergeSort(right));\n}\n\nfunction merge(left, right){\n    var result = [];\n\n    while (left.length && right.length) {\n        if (left[0] <= right[0]) {\n            result.push(left.shift());\n        } else {\n            result.push(right.shift());\n        }\n    }\n\n    while (left.length)\n        result.push(left.shift());\n\n    while (right.length)\n        result.push(right.shift());\n\n    return result;\n}\nPython 代码实现\ndef mergeSort(arr):\n    import math\n    if(len(arr)<2):\n        return arr\n    middle = math.floor(len(arr)/2)\n    left, right = arr[0:middle], arr[middle:]\n    return merge(mergeSort(left), mergeSort(right))\n\ndef merge(left,right):\n    result = []\n    while left and right:\n        if left[0] <= right[0]:\n            result.append(left.pop(0));\n        else:\n            result.append(right.pop(0));\n    while left:\n        result.append(left.pop(0));\n    while right:\n        result.append(right.pop(0));\n    return result\n\n\nGo 代码实现\nfunc mergeSort(arr []int) []int {\n        length := len(arr)\n        if length < 2 {\n                return arr\n        }\n        middle := length / 2\n        left := arr[0:middle]\n        right := arr[middle:]\n        return merge(mergeSort(left), mergeSort(right))\n}\n\nfunc merge(left []int, right []int) []int {\n        var result []int\n        for len(left) != 0 && len(right) != 0 {\n                if left[0] <= right[0] {\n                        result = append(result, left[0])\n                        left = left[1:]\n                } else {\n                        result = append(result, right[0])\n                        right = right[1:]\n                }\n        }\n\n        for len(left) != 0 {\n                result = append(result, left[0])\n                left = left[1:]\n        }\n\n        for len(right) != 0 {\n                result = append(result, right[0])\n                right = right[1:]\n        }\n\n        return result\n}\n\n7 Java 实现\n public static int[] sort(int[] nums, int low, int high) {\n        int mid = (low + high) / 2;\n        if (low < high) {\n        \n            sort(nums, low, mid);\n       \n            sort(nums, mid + 1, high);\n\n            merge(nums, low, mid, high);\n        }\n        return nums;\n    }\n\n    /**\n     * 将数组中low到high位置的数进行排序\n     * nums 待排序数组\n     * low 待排的开始位置\n     *  mid 待排中间位置\n     *  high 待排结束位置\n     */\n    public static void merge(int[] nums, int low, int mid, int high) {\n        int[] temp = new int[high - low + 1];\n        int i = low;\n        int j = mid + 1;\n        int k = 0;\n\n        while (i <= mid && j <= high) {\n            if (nums[i] < nums[j]) {\n                temp[k++] = nums[i++];\n            } else {\n                temp[k++] = nums[j++];\n            }\n        }\n\n        while (i <= mid) {\n            temp[k++] = nums[i++];\n        }\n\n        while (j <= high) {\n            temp[k++] = nums[j++];\n        }\n\n      \n        for (int k2 = 0; k2 < temp.length; k2++) {\n            nums[k2 + low] = temp[k2];\n        }\n    }\n\n\n希望可以一起交流技术，有兴趣可以加qq邀请入群:525331804 全栈技术开发qq群：581993430\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "6"}