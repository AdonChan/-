{"title": "Python的Sequence切片下标问题 - 技术栈大杂烩 ", "index": "python", "content": "前言\n在python中, 切片是一个经常会使用到的语法, 不管是元组, 列表还是字符串, 一般语法就是:\nsequence[ilow:ihigh:step]  # ihigh,step 可为空; 为了简短易懂, 暂时排除step的用法考虑\n先来简单示范下用法\nsequence = [1,2,3,4,5]\nsequence [ilow:ihigh]  # 从ilow开始到ihigh-1结束\nsequence [ilow:]       # 从ilow开始直到末尾\nsequence [:ihigh]      # 从头部开始直到ihigh结束\nsequence [:]           # 复制整个列表\n\n语法很简洁, 也很容易理解, 这种语法在我们日常使用中 是简单又好用, 但我相信在我们使用这种切片语法时, 都会习惯性谨遵一些规则:\n\nilow, ihigh均小于 sequece的长度\nilow < ihigh\n\n因为在大部分情况下, 只有遵循上面的规则, 才能得到我们预期的结果! 可是如果我不遵循呢? 切片会怎样?\n不管我们在使用元组, 列表还是字符串, 当我们想取中一个元素时, 我们会用到如下语法:\nsequence = [1,2,3,4,5]\nprint sequence[1]   # 输出2\nprint sequence[2]   # 输出3\n\n上面出现的 1,2 我们姑且称之为下标, 不管是元组, 列表还是字符串, 我们都能通过下标来取出对应的值, 但是如果下标超过对象的长度, 那么将触发索引异常(IndexError)\nsequence = [1,2,3,4,5]\nprint sequence[15]   \n\n### 输出 ###\nTraceback (most recent call last):\n  File \"test.py\", line 2, in <module>\n    print a[20]\nIndexError: list index out of range\n\n那么对于切片呢? 两种语法很相似, 假设我 ilow 和 ihigh分别是10和20, 那么结果是怎样呢\n情景重现\n# version: python2.7\n\na = [1, 2, 3, 5]\nprint a[10:20]  # 结果会报异常吗?\n\n看到10和20, 完全超出了序列a的长度, 由于前面的代码, 或者以前的经验, 我们总会觉得这样肯定也会导致一个IndexError,那我们开终端来试验下:\n>>> a = [1, 2, 3, 5]\n>>> print a[10:20]\n[]\n\n结果居然是: [], 这感觉有点意思.是只有列表才会这么, 字符串呢, 元组呢?\n>>> s = '23123123123'\n>>> print s[400:2000]\n''\n>>> t = (1, 2, 3,4)\n>>> print t[200: 1000]\n()\n\n结果都和列表的类似, 返回属于各自的空结果.\n看到结果的我们眼泪掉下来, 不是返回一个IndexError, 而是直接返回空, 这让我们不禁想到, 其实语法相似, 背后的东西肯定还是不同的, 那我们下面一起来尝试去解释下这结果吧\n原理分析\n在揭开之前, 咱们要先搞清楚, python是怎样处理这个切片的, 可以通过dis模块来协助:\n#############  切片 ################\n[root@iZ23pynfq19Z ~]# cat test.py\na = [11,2,3,4]\nprint a[20:30]\n\n#结果:\n[root@iZ23pynfq19Z ~]# python -m dis test.py \n  1           0 LOAD_CONST               0 (11)\n              3 LOAD_CONST               1 (2)\n              6 LOAD_CONST               2 (3)\n              9 LOAD_CONST               3 (4)\n             12 BUILD_LIST               4\n             15 STORE_NAME               0 (a)\n\n  2          18 LOAD_NAME                0 (a)\n             21 LOAD_CONST               4 (20)\n             24 LOAD_CONST               5 (30)\n             27 SLICE+3             \n             28 PRINT_ITEM          \n             29 PRINT_NEWLINE       \n             30 LOAD_CONST               6 (None)\n             33 RETURN_VALUE  \n\n#############  单下标取值 ################\n[root@gitlab ~]# cat test2.py\na = [11,2,3,4]\nprint a[20]\n\n#结果:\n[root@gitlab ~]# python -m dis test2.py\n  1           0 LOAD_CONST               0 (11)\n              3 LOAD_CONST               1 (2)\n              6 LOAD_CONST               2 (3)\n              9 LOAD_CONST               3 (4)\n             12 BUILD_LIST               4\n             15 STORE_NAME               0 (a)\n\n  2          18 LOAD_NAME                0 (a)\n             21 LOAD_CONST               4 (20)\n             24 BINARY_SUBSCR       \n             25 PRINT_ITEM          \n             26 PRINT_NEWLINE       \n             27 LOAD_CONST               5 (None)\n             30 RETURN_VALUE    \n\n在这简单介绍下dis模块, 有经验的老司机都知道, python在解释脚本时, 也是存在一个编译的过程, 编译的结果就是我们经常看到的pyc文件, 这里面codeobject对象组成的字节码, 而dis就是将这些字节码用比较可观的方式展示出来, 让我们看到执行的过程, 下面是dis的输出列解释:\n\n第一列是数字是原始源代码的行号。\n第二列是字节码的偏移量：LOAD_CONST在第0行.以此类推。\n第三列是字节码人类可读的名字。它们是为程序员所准备的\n第四列表示指令的参数\n第五列是计算后的实际参数\n\n前面就不赘述了, 就是读常量存变量的过程, 最主要的区别就是: test.py 切片是使用了字节码 SLICE+3实现的, 而test2.py 单下标取值主要通过字节码BINARY_SUBSCR实现的,如同我们猜测的一样, 相似的语法却是截然不同的代码.因为我们要展开讨论的是切片(SLICE+3), 所以就不再展开BINARY_SUBSCR, 感兴趣的童鞋可以查看相关源码了解具体实现, 位置: python/object/ceval.c\n那我们下面来展开讨论下 SLICE+3\n/*取自: python2.7 python/ceval.c */\n\n// 第一步: \nPyEval_EvalFrameEx(PyFrameObject *f, int throwflag)\n{\n        ....   // 省略n行代码\n        TARGET_WITH_IMPL_NOARG(SLICE, _slice)\n        TARGET_WITH_IMPL_NOARG(SLICE_1, _slice)\n        TARGET_WITH_IMPL_NOARG(SLICE_2, _slice)\n        TARGET_WITH_IMPL_NOARG(SLICE_3, _slice)\n        _slice:\n        {\n            if ((opcode-SLICE) & 2)\n                w = POP();\n            else\n                w = NULL;\n            if ((opcode-SLICE) & 1)\n                v = POP();\n            else\n                v = NULL;\n            u = TOP();\n            x = apply_slice(u, v, w);    // 取出v: ilow, w: ihigh, 然后调用apply_slice\n            Py_DECREF(u);\n            Py_XDECREF(v);\n            Py_XDECREF(w);\n            SET_TOP(x);\n            if (x != NULL) DISPATCH();\n            break;\n        }\n\n   ....   // 省略n行代码\n}\n\n// 第二步:\napply_slice(PyObject *u, PyObject *v, PyObject *w) /* return u[v:w] */\n{\n    PyTypeObject *tp = u->ob_type;     \n    PySequenceMethods *sq = tp->tp_as_sequence;\n\n    if (sq && sq->sq_slice && ISINDEX(v) && ISINDEX(w)) { // v,w的类型检查,要整型/长整型对象\n        Py_ssize_t ilow = 0, ihigh = PY_SSIZE_T_MAX;\n        if (!_PyEval_SliceIndex(v, &ilow))                // 将v对象再做检查, 并将其值转换出来,存给ilow\n            return NULL;\n        if (!_PyEval_SliceIndex(w, &ihigh))               // 同上\n            return NULL;\n        return PySequence_GetSlice(u, ilow, ihigh);       // 获取u对象对应的切片函数\n    }\n    else {\n        PyObject *slice = PySlice_New(v, w, NULL);\n        if (slice != NULL) {\n            PyObject *res = PyObject_GetItem(u, slice);\n            Py_DECREF(slice);\n            return res;\n        }\n        else\n            return NULL;\n    }\n\n// 第三步:\nPySequence_GetSlice(PyObject *s, Py_ssize_t i1, Py_ssize_t i2)\n{\n    PySequenceMethods *m;\n    PyMappingMethods *mp;\n\n    if (!s) return null_error();\n\n    m = s->ob_type->tp_as_sequence;\n    if (m && m->sq_slice) {\n        if (i1 < 0 || i2 < 0) {\n            if (m->sq_length) {\n                // 先做个简单的初始化, 如果左右下表小于, 将其加上sequence长度使其归为0\n                Py_ssize_t l = (*m->sq_length)(s);\n                if (l < 0)\n                    return NULL;\n                if (i1 < 0)\n                    i1 += l;\n                if (i2 < 0)\n                    i2 += l;\n            }\n        }\n        // 真正调用对象的sq_slice函数, 来执行切片的操作\n        return m->sq_slice(s, i1, i2);\n    } else if ((mp = s->ob_type->tp_as_mapping) && mp->mp_subscript) {\n        PyObject *res;\n        PyObject *slice = _PySlice_FromIndices(i1, i2);\n        if (!slice)\n            return NULL;\n        res = mp->mp_subscript(s, slice);\n        Py_DECREF(slice);\n        return res;\n    }\n\n    return type_error(\"'%.200s' object is unsliceable\", s);\n虽然上面的代码有点长, 不过关键地方都已经注释出来, 而我们也只需要关注那些地方就足够了. 如上, 我们知道最终是要执行 m->sq_slice(s, i1, i2), 但是这个sq_slice有点特别, 因为不同的对象, 它所对应的函数不同, 下面是各自的对应函数:\n// 字符串对象\nStringObject.c:  (ssizessizeargfunc)string_slice, /*sq_slice*/\n\n// 列表对象\nListObject.c: (ssizessizeargfunc)list_slice,      /* sq_slice */\n\n// 元组\nTupleObject.c: (ssizessizeargfunc)tupleslice,     /* sq_slice */\n\n因为他们三个的函数实现大致相同, 所以我们只分析其中一个就可以了, 下面是对列表的切片函数分析:\n/* 取自ListObject.c */\nstatic PyObject *\nlist_slice(PyListObject *a, Py_ssize_t ilow, Py_ssize_t ihigh)\n{\n    PyListObject *np;\n    PyObject **src, **dest;\n    Py_ssize_t i, len;\n    if (ilow < 0)\n        ilow = 0;\n    else if (ilow > Py_SIZE(a))               // 如果ilow大于a长度, 那么重新赋值为a的长度\n        ilow = Py_SIZE(a);\n    if (ihigh < ilow)        \n        ihigh = ilow;\n    else if (ihigh > Py_SIZE(a))              // 如果ihigh大于a长度, 那么重新赋值为a的长度  \n        ihigh = Py_SIZE(a);\n    len = ihigh - ilow;\n    np = (PyListObject *) PyList_New(len);    // 创建一个ihigh - ilow的新列表对象\n    if (np == NULL)\n        return NULL;\n\n    src = a->ob_item + ilow;\n    dest = np->ob_item;\n    for (i = 0; i < len; i++) {               // 将a处于该范围内的成员, 添加到新列表对象\n        PyObject *v = src[i];\n        Py_INCREF(v);\n        dest[i] = v;\n    }\n    return (PyObject *)np;\n}\n结论\n从上面的sq_slice函数对应的切片函数可以看到, 如果在使用切片时, 左右下标都大于sequence的长度时, 都将会被重新赋值成sequence的长度, 所以咱们一开始的切片: print a[10:20], 实际上运行的是: print a4:4. 通过这次的分析, 以后在遇到下标大于对象长度的切片, 应该不会再懵逼了~\n欢迎各位大神指点交流,转载请注明: https://segmentfault.com/a/11...\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "3"}