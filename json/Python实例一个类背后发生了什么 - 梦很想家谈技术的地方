{"title": "Python实例一个类背后发生了什么 - 梦很想家谈技术的地方 ", "index": "oop,tornado,django,python", "content": "写在最前面\n一些很重要的知识，我的写得有点乱，也可以去看这些文章\n\nPython 面向对象（初级篇）\nPython 面向对象（进阶篇)\n深刻理解Python中的元类(metaclass)\n\n首先来看一个例子,正常情况下我们定义并且实例一个类如下\nclass Foo(object):\n \n    def __init__(self):\n        pass\n \nobj = Foo()   # obj是通过Foo类实例化的对象\n\n上述代码中，obj 是通过 Foo 类实例化的对象，其实，不仅 obj 是一个对象，Foo类本身也是一个对象，因为在Python中一切事物都是对象。\nprint type(obj) # 输出： Foo 表示，obj 对象由Foo类创建\nprint type(Foo) # 输出：type表示，Foo类对象由 type 类创建\n\n如果按照一切事物都是对象的理论：对象是通过执行Foo类的构造方法创建，那么Foo类对象应该也是通过执行某个类的 构造方法 创建。\n两个基本的类\n这里和有必要提到一下在Python中有两个最基本的对象，<type ‘object’> 和 <type ‘type’>，这两个对象是所有对象的起源。\n\n<type ‘type’>的类型是<type ‘type’>（它本身），<type ‘type’>的父类是<type ‘object’>\n<type ‘object’>的类型是<type ‘type’>，<type ‘object’>没有父类\n\n在Python对象系统中，<type ‘object’>和<type ‘type’>的关系就像鸡和蛋的关系，不能说谁先于（创建）谁，两者是相互依赖的，共同构成了Python对象系统的基础.有点难理解,不过没有关系,知道有种这么两个东西就好了,比较我们也不是设计Python的人,没有必要搞的那么清楚.\n类的创建\n主要有两种方式,不过本质上都是一样的,都是通过type类来实例一个用户类\n普通方式\nPython\n1    class Foo(object):\n2     \n3        def func(self):\n4            print 'hello '\n\n特殊方式（type类的构造函数）\nPython\n1    def func(self):\n2        print 'hello '\n3     \n4    Foo = type('Foo',(object,), {'func': func})\n5    #type第一个参数：类名\n6    #type第二个参数：当前类的基类\n7    #type第三个参数：类的成员\n\n由上面可以看出来  ,     Foo类是由type类实例而来,那么具体的创建的过程是怎么样的呢,接着往下面看:\n来了解几个概念\nnew 和 __init()和__metaclass__:\n\n__new__函数是实例一个类所要调用的函数,每当我们调用obj = Foo()来实例一个类时,都是先调用__new__()\n然后再调用__init__()函数初始化实例.   __init__()在__new__()执行后执行,\n类中还有一个属性 __metaclass__，其用来表示该类由 谁 来实例化创建，所以，我们可以为 __metaclass__ 设置一个type类的派生类，从而查看 类 创建的过程。\n\n阐述运行过程\n\n\n\nmytype产生一个叫做Foo的实例,主要的原理就是设置了,__metaclass__=MyTypoe,这样就指定mytype类来实例foo类,如果Python没有找到__metaclass__，它会继续在（父类）中寻找        __metaclass__属性，并尝试做和前面同样的操作。如果Python在任何父类中都找不到__metaclass__，它就会在模块层次中去寻找__metaclass__，并尝试做同样的操作。如果还是找不到__metaclass__,Python就会用内置的type来创建这个类对象。\nmytype类中的__new__方法返回了一个对象,所有的Python实例都是这句代码创建的type.__new__(cls,name,bases,attrs)\nmytype的__init__()函数初始化Foo类,在这里我们可以和在__new__()函数一样设置Foo类的attr属性,比如类中的方法,字段属性等\n和Foo类的创建过程一样,studen类继承了Foo类,所以重复123步骤,得到一个studen类\n当用户使用Foo()或者studen()来实例类时,会默认调用类中的_new_()方法,要是之类里面没有这个方法就到父类里面寻找__new__(),我们可以充分利用这个new函数,比如来实现Python中的单例模式,或者对类成员进行批量的修改等等.\n产生了一个实例后马上执行__init__()函数,进行初始化实例,\n由上面的运行结果可以看出,其中Foo和studen类的类型是<class '__main__.MyType'>,这也证明了Foo类和studen类都是由MyType实例而来…而第三个例子,可以看出Foo2类的类型是<type 'type'>,这个并不例外,Foo2继承了object类,(这个,还是跳过吧,前面已经讲过type和object相爱相杀的关系了)\n\n总结\n首先，你知道了类其实是能够创建出类实例的对象。好吧，事实上，类本身也是实例，当然，它们是元类的实例。Python中的一切都是对象，它们要么是类的实例，要么是元类的实例，除了type。type实际上是它自己的元类，在纯Python环境中这可不是你能够做到的，这是通过在实现层面耍一些小手段做到的。其次，元类是很复杂的。对于非常简单的类，你可能不希望通过使用元类来对类做修改。你可以通过其他两种技术来修改类：\n\nMonkey patching\nclass decora\n\n\n                ", "mainLikeNum": ["7 "], "mainBookmarkNum": "32"}