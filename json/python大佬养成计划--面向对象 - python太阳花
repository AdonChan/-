{"title": "python大佬养成计划--面向对象 - python太阳花 ", "index": "python", "content": "类\n面向对象编程具有三大特性：多态、继承、封装定义：是一个抽象的模板对象：类实例化属性：这个类实例化后的对象具有的特征方法：类对象可以执行的函数\n类的定义\nclass 类名\n\n\nclass People(object):\n    # object代表是， 人类继承于哪一个类， 如果不知道继承哪个类， 就写object；\n\n    # 构造方法(魔术方法)， 当创建对象的时候， 自动执行的函数\n    def __init__(self, name, age, gender):\n        # python解释器自动将对象传给self这个形参.\n        # 看self到底是什么东西?\n\n        # 将对象与该对象的属性绑定在一起.\n        #  调用对象的属性两种方式:\n        #       - Tom.name\n        #       - self.name\n        self.name = name     # 属性\n        self.age = age       # 属性\n        self.gender = gender # 属性\n        #    print(self)  # 实质上是一个对象， <__main__.People object at 0x0000024111324630>\n    # 方法(在类里面定义的函数， 叫做方法)\n    def eat(self):\n        print(\"%s 正在吃饭...\" %(self.name))\n\n# 创建对象====根据模板(类)创建对象(真实存在)\nTom = People(\"Tom Smith\",  10, 'male')\n\n#测试\n# 看对象的属性\nprint(Tom.name)\nprint(Tom.age)\nprint(Tom.gender)\n# 让对象执行方法\nTom.eat()\n\n\n私有属性和私有方法\n1).类的私有属性:\n__private_attrs：两个下划线开头，声明该属性为私有，\n不能在类地外部被使用或直接访问。\n在类内部的方法中使用时 self.__private_attrs。\n2).类的方法:\n在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，\n类方法必须包含参数 self，且为第一个参数，self 代表的是类的实例。\nself 的名字并不是规定死的(因为是形参)，也可以使用 this，但是最好还是按照约定是用 self。\n3).类的私有方法\n__private_method：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，\n不能在类地外部调用。self.__private_methods。\nclass People(object):\n    def __init__(self,name,age,gender, money):\n        self.name = name\n        self.age = age\n        self.gender = gender\n        self.__money = money\n        self.__play()\n    def __play(self):\n        print(\"王者荣耀正在进行时......\")\n\np1 = People('user1', 10, 'male', 1000000)\nprint(p1.gender)\n\np1.__play()#报错，AttributeError: 'People' object has no attribute '__play'\n\n栈数据结构\n栈的方法有入栈(push), 出栈(pop), 栈顶元素(top),栈的长度(lenght), 判断栈是否为空(isempty)，显示栈元素(view)\n操作结果:\n栈类的实例化\n入栈2次\n出栈1次\n显示最终栈元素\nclass Stack(object):\n    def __init__(self):\n        self.stack_list =[]\n    def push(self,val):\n        self.stack_list.append(val)\n        return True\n    def pop(self):\n        self.stack_list.pop()\n        return True\n    def top(self):\n        return self.stack_list[-1]\n    def lenght(self):\n        return len(self.stack_list)\n    def isempty(self):\n        return self.stack_list ==[]\n    def view(self):\n        return \",\".join(self.stack_list)\n\nstack1 = Stack()\nstack1.push('3')\nstack1.push('4')\nprint(stack1.view())\nstack1.pop()\nprint(stack1.view())\n\n\n\n第二特性之继承\n概念：\n父类与子类/基类和派生类\nclass Anminal(object):\n    def __init__(self,name,age):\n        self.name = name\n        self.age = age\n    def eat(self):\n        print(\"i'm hungry,i want to eat something~~~\")\n\nclass Dog(Anminal):\n    def __init__(self,name,age,power):\n        #当子类没有的属性和方法，会到父类里面找。如果父类有没有，就会报错\n        #父类的私有属性和私有方法，子类不能查看与操作\n        super(Dog, self).__init__(name,age)\n        self.power =power\n    def eat(self):\n        super(Dog, self).eat()\n        print(\"wang~~\")\n\nH = Dog('大黄',6,100)\nprint(H.power)\nprint(H.name)\nprint(H.age)\nH.eat()\n\n多继承\n# 经典类\nclass Person1:\n    pass\np1 = Person1()\nprint(p1)\n\n# 新式类\nclass Person2(object):\n    pass\np2 = Person2()\nprint(p2)\n\n在python2中既有新式类也有经典类;\n  经典类的继承算法: 深度优先算法\n  新式类的继承算法: 广度优先算法，同级优先\npython3全部都是新式类;\n    def test(self):\n        print(\"D test\")\nclass C(D):\n    pass\n    def test(self):\n        print(\"C test\")\nclass B(D):\n    pass\n    #def test(self):\n     #   print(\"B test\")\nclass A(B,C):\n    pass\n    # def test(self):\n    #     print(\"A test\")\na = A()\na.test()\n\n乌龟吃鱼\n游戏编程：按以下要求定义一个乌龟类和鱼类并尝试编写游戏\n假设游戏场景为范围（x,y）为0<=x<=10,0<=y<=10\n游戏生成1只乌龟和10条鱼\n它们的移动方向均随机\n乌龟的最大移动能力为2（它可以随机选择1还是2移动），鱼儿的最大移动能力是1\n当移动到场景边缘，自动向反方向移动\n乌龟初始化体力为100（上限）\n乌龟每移动一次，体力消耗1\n当乌龟和鱼坐标重叠，乌龟吃掉鱼，乌龟体力增加20\n鱼暂不计算体力\n当乌龟体力值为0（挂掉）或者鱼儿的数量为0游戏结束\n\nimport random\n\n\nclass Animals(object):\n    def __init__(self):\n        # 随机生成动物的坐标\n        self.x = random.randint(0, 10)\n        self.y = random.randint(0, 10)\n\n    def move(self, move_skill):\n        # 计算出乌龟新的坐标; (10,0)  (12,0)\n        new_x = self.x + random.choice(move_skill)  # 12\n        new_y = self.y + random.choice(move_skill)  # 0\n        # 更新乌龟的坐标值\n        self.x = self.is_vaild(new_x)\n        self.y = self.is_vaild(new_y)\n\n    def is_vaild(self, value):  # 12\n        \"\"\"判断坐标值是否合法(0~10之间), 返回合法的值\"\"\"\n        if value < 0:  # eg: -2 ==   abs(-2) ==> 2\n            return abs(value)\n        elif value > 10:  # eg: 12 ====>   10-(12-10)  ==> 8\n            return 10 - (value - 10)\n        return value\n\n\nclass Trutle(Animals):\n    # 构造函数何时执行？ 类实例化对象(创建对象)时， 自动调用该函数内容\n    def __init__(self):\n        super(Trutle, self).__init__()\n        # 乌龟初始化体力为100（上限）\n        self.power = 100\n    def move(self, move_skill = [-2, -1, 0, 1, 2]):\n        super(Trutle, self).move(move_skill)\n        # 乌龟每移动一次，体力消耗1\n        self.power -= 1\n\n    def eat(self):\n        # 当乌龟和鱼坐标重叠，乌龟吃掉鱼，乌龟体力增加20\n        if self.power>80:\n            self.power =100\n        else:\n            self.power +=20\n\nclass Fish(Animals):\n    def move(self, move_skill = (-1, 0, 1 )):\n        # 鱼的最大移动能力为1\n        super(Fish, self).move(move_skill)\n\ndef start_game():\n    # 创建一个乌龟\n    t1 = Trutle()\n    # 创建10个鱼\n    # fishs = []\n    # for i in range(10):\n    #     fishs.append(Fish())\n    fishs = [Fish() for i in range(10)]\n    # 游戏开始运行\n    while True:\n        # 判断游戏是否结束(乌龟没体力或者鱼被吃光了)\n        if t1.power <= 0:\n            print(\"乌龟没体力了， Game over.........\")\n            break\n        elif len(fishs) == 0:\n            print(\"鱼被吃光了， Game over......... \")\n            break\n        else:\n            # 乌龟和鱼随机移动\n            t1.move()\n            for index, fish in enumerate(fishs):\n                fish.move()\n                # 判断乌龟是否吃到了鱼？\n                if t1.x == fish.x and t1.y == fish.y:\n                    t1.eat()\n                    fishs.remove(fish)\n                    print(\"鱼被吃掉， 还剩%d条鱼.......\" %(len(fishs)))\n                    print(\"乌龟最新体能为%s\" %(t1.power))\n            # 当乌龟的坐标与每一条鱼进行比较， 都没有重合， 也就是没有迟到一条鱼;\n            else:\n                print(\"乌龟没有吃到鱼， 最新体能为%s\" %(t1.power))\n# 如果这个脚本(模块)， 没有被调用， 则执行下面的代码\nif __name__ == \"__main__\":\n    print(\"游戏开始\".center(50, '*'))\n    start_game()\n\n\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}