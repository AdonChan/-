{"title": "python模块之configparser - 个人文章 ", "index": "python", "content": "快速开始\n# demo.ini\n\n[DEFAULT]\nServerAliveInterval = 45\nCompression = yes\nCompressionLevel = 9\nForwardX11 = yes\n\n[bitbucket.org]\nUser = hg\n\n[topsecret.server.com]\nPort = 50022\nForwardX11 = no\n上面的demo.ini是一个非常基础的配置文件，它由多个部分(section)组成，每部分包含了带值的选项。ConfigParse类的实例可以对其进行读写操作。\n创建配置文件：\nimport configparser\n\nconfig = configparser.ConfigParser()\nconfig[\"DEFAULT\"] = {\"ServerAliveInterval\": \"45\",\n                     \"Compression\": \"yes\",\n                     \"CompressionLevel\": \"9\",\n                     \"ForwardX11\": \"yes\"}\n\nconfig[\"bitbucket.org\"] = {}\nconfig[\"bitbucket.org\"][\"User\"] = \"hg\"\n\nconfig['topsecret.server.com'] = {}\ntopsecret = config['topsecret.server.com']\ntopsecret[\"Port\"] = \"50022\"\ntopsecret[\"ForwardX11\"] = \"no\"\n\nwith open(\"demo.ini\", \"w\") as configfile:\n    config.write(configfile)\n对配置解析器的处理与字典类似。\n读取配置文件：\n>>> config = configparser.ConfigParser()\n>>> config.sections()\n[]\n>>> config.read(\"demo.ini\")\n[\"demo.ini\"]\n>>> config.sections()\n['bitbucket.org', 'topsecret.server.com']\n>>> \"bitbucket.org\" in config\nTrue\n>>> \"bitbong.com\" in config\nFalse\n>>> config[\"bitbucket.org\"][\"User\"]\n\"hg\"\n>>> config['DEFAULT']['Compression']\n\"yes\"\n>>> topsecret = config['topsecret.server.com']\n>>> topsecret['ForwardX11']\n\"no\"\n>>> for key in config[\"bitbucket.org\"]:\n...     print(key)\nuser\nserveraliveinterval\ncompression\ncompressionlevel\nforwardx11\n>>> config[\"bitbucket.org\"][\"ForwardX11\"]\n\"yes\"\n注意点：[DEFAULT]为其他所有section提供默认值，section中的所有键大小写不敏感并以小写字母存储\n支持的数据类型\n配置解析器总是存储配置的值为字符串类型，因此用户需要按需转换为期望的数据类型。由于这种需求非常普遍，配置解析器提供了一系列更简便的方法来处理整数(getint())、浮点数(getfloat())及布尔值(getboolean())。用户也可以自行注册转换器或定制配置解析器已提供的转换器。\n>>> topsecret.getboolean('ForwardX11')\nFalse\n>>> config['bitbucket.org'].getboolean('ForwardX11')\nTrue\n>>> config.getboolean('bitbucket.org', 'Compression')\nTrue\n注意点：getboolean()方法对大小写不敏感，能识别'yes'/'no', 'on'/'off', 'true'/'false'和'1'/'0'为对应的布尔值\n后备值(Fallback Values)\n和字典一样，可以使用section的get()方法提供后备值：\n>>> topsecret.get('CompressionLevel')\n'9'\n>>> topsecret.get('Cipher')\n>>> topsecret.get('Cipher', '3des-cbc')\n'3des-cbc\n需要注意的是，默认值的优先级高于后备值。比如要想在'topsecret.server.com'中获取'CompressionLevel'的值，即使指定了后备值，仍然得到的是'DEFAULT'中的值：\n>>> topsecret.get('CompressionLevel', '3')\n'9'\n此外，除了section的get()方法，还提供了解析器级别的get()方法，支持向后兼容，后备值通过fallback关键字指定：\n>>> config.get(\"bitbucket.org\", \"monster\", fallback=\"No such things as monsters\")\n\"No such things as monsters\"\nfallback关键字同样支持在getint(), getfloat()和getboolean()中使用\n支持的INI文件结构\n\n配置文件由section组成，每个section以[section_name]的形式打头，后跟以特定字符(默认是=或:)分隔的键值对。\n默认情况下section名称区分大小写，键不区分大小写。\n键、值的头部和尾部空格自动移除。\n值可以省略，在这种情况下分隔符也可以不要。\n值可以跨多行，只要其他行的值比第一行的值缩进更深。\n空行可以被忽略或视作多行值的一部分(取决于解析器模式)。\n可以包含注解，独占一行显示，默认以字符#和;为前缀。应该避免注解与键或值处在同一行，因为这将导致把注解视为值的一部分。\n\n[Simple Values]\nkey=value\nspaces in keys=allowed\nspaces in values=allowed as well\nspaces around the delimiter = obviously\nyou can also use : to delimit keys from values\n\n[All Values Are Strings]\nvalues like this: 1000000\nor this: 3.14159265359\nare they treated as numbers? : no\nintegers, floats and booleans are held as: strings\ncan use the API to get converted values directly: true\n\n[Multiline Values]\nchorus: I'm a lumberjack, and I'm okay\n    I sleep all night and I work all day\n\n[No Values]\nkey_without_value\nempty string value here =\n\n[You can use comments]\n# like this\n; or this\n\n# By default only in an empty line.\n# Inline comments can be harmful because they prevent users\n# from using the delimiting characters as parts of values.\n# That being said, this can be customized.\n\n    [Sections Can Be Indented]\n        can_values_be_as_well = True\n        does_that_mean_anything_special = False\n        purpose = formatting for readability\n        multiline_values = are\n            handled just fine as\n            long as they are indented\n            deeper than the first line\n            of a value\n        # Did I mention we can indent comments, too?\n插值\nConfigParser支持插值，调用get()方法返回值之前将对值进行预处理\nclass configparser.BasicInterpolation\n默认使用的Interpolation类。允许值包含格式化字符串，该字符串引用同一section中的值或DEFAULTSECTsection中的值。其他默认值可以在初始化时提供。\n[Paths]\nhome_dir: /Users\nmy_dir: %(home_dir)s/lumberjack\nmy_pictures: %(my_dir)s/Pictures\n在上面的例子中，interpolation设置为BasicInterpolation()的ConfigParser将解析%(home_dir)s为home_dir的值，%(my_dir)s将解析为/Users/lumberjack。引用链中使用的键不需要在配置文件中以任何特定的顺序指定。\n如果interpolation设置为None，将直接返回%(home_dir)s/lumberjack作为my_dir的值。\nclass configparser.ExtendedInterpolation\n扩展的Interpolation类，实现了更高级的语法。它使用${section:option}表示来自外部section的值，如果省去了section:，默认指当前section(以及可能的DEFAULTSECTsection的值)\n[Common]\nhome_dir: /Users\nlibrary_dir: /Library\nsystem_dir: /System\nmacports_dir: /opt/local\n\n[Frameworks]\nPython: 3.2\npath: ${Common:system_dir}/Library/Frameworks/\n\n[Arthur]\nnickname: Two Sheds\nlast_name: Jackson\nmy_dir: ${Common:home_dir}/twosheds\nmy_pictures: ${my_dir}/Pictures\npython_dir: ${Frameworks:path}/Python/Versions/${Frameworks:Python}\n映射协议访问\n映射协议访问是允许像操作字典一样使用自定义对象的功能的通用名称。在configparser中，映射接口通过parser[\"section\"][\"option\"]的形式实现。\nparser[\"section\"]返回解析器中section的值的代理，值从原始解析器中获取但并非通过复制的方式。在section代理上改变值的操作，实际上是对原始解析器的改变。\nconfigparser对象虽然表现的尽可能接近字典，但仍有一些区别需要注意：\n默认情况下，section中的所有key能够以大小写不敏感的方式访问。例如for option in parser[\"section\"]语句生成的option名称总是被optionxform函数转换为小写。拥有\"a\"选项的section通过以下两种方式访问都将返回True:\n\"a\" in parser[\"section\"]\n\"A\" in parser[\"section\"]\n所有section都包含DEFAULTSECT的值，也就是说，对section的.clear()操作可能并没有真正的清空，这是因为无法从该section删除默认值。在除DEFAULTSECT以外的section上删除默认值(前提是没有对默认值重写)将抛出KeyError异常\n>>> del topsecret[\"forwardx11\"]\n>>> topsecret[\"forwardx11\"]\n'yes'\n>>> del topsecret[\"serveraliveinterval\"]\nTraceback (most recent call last):\n  ...\n    raise KeyError(key)\nKeyError: 'serveraliveinterval'\n\nDEFAULTSECT不能从解析器移除\n\n删除它将抛出ValueError异常\n\nparser.clear()操作对它没有任何影响\n\nparser.popitem()不会返回DEFAULTSECT\n\n\n\n>>> del config[\"DEFAULT\"]\nTraceback (most recent call last):\n  ...\n    raise ValueError(\"Cannot remove the default section.\")\nValueError: Cannot remove the default section.\n>>> config.clear()\n>>> config[\"DEFAULT\"][\"serveraliveinterval\"]\n'45'\n\n\nparser.get(section, option, **kwargs) - 第二个参数并非字典的get()方法表示的后备值，但section级别的get()方法与映射协议却是兼容的\n\nparser.items(raw=False, vars=None)兼容映射协议(返回包含DEFAULTSECT的(section_name, section_proxy)对的列表)。另有指定section的调用方式：parser.items(section, raw=False, vars=None).后者返回指定section的(option, value)对的列表，raw参数指定value中的格式化字符串是否插值表示\n\n>>> list(config.items())\n[('DEFAULT', <Section: DEFAULT>), ('bitbucket.org', <Section: bitbucket.org>), ('topsecret.server.com', <Section: topsecret.server.com>)]\n>>> list(config.items(\"bitbucket.org\"))\n[('serveraliveinterval', '45'), ('compression', 'yes'), ('compressionlevel', '9'), ('forwardx11', 'yes'), ('user', 'hg')]\n自定义解析器行为\n省略\n旧版API示例\n省略\nConfigParser对象\nclass configparser.ConfigParser(defaults=None, dict_type=dict, allow_no_value=False, delimiters=('=', ':'), comment_prefixes=('#', ';'), inline_comment_prefixes=None, strict=True, empty_lines_in_values=True, default_section=configparser.DEFAULTSECT, interpolation=BasicInterpolation(), converters={})\ndefaults()返回包含实例范围默认值的字典\nsections()返回可用section的名称列表(不包含默认section的名称)\nadd_section(section)添加section。如果该section已经存在，抛出DuplicateSectionError异常；如果传入的是默认section的名称，抛出ValueError异常；如果传入的参数不是字符串类型，抛出TypeError异常\nhas_section(section)判断section是否存在。默认section总是返回False\noptions(section)返回指定section的可用选项列表(包含DEFAULTSECT中的选项)。指定默认section将抛出NoSectionError异常\nhas_option(section, option)如果section存在且包含指定的option，返回True，否则返回False。如果传递的section为None或\"\"，视为默认section\nread(filenames, encoding=None)读取并解析可迭代的文件名，返回成功解析的文件名列表\n如果filenames是一个字符串，或字节对象又或者是类路径对象，视其为单个文件。如果filenames中的某个文件不能打开，该文件将被忽略\n如果filenames中所有文件都不存在,ConfigParser实例将包含空数据集。如果某个应用需要导入初始化值，应该在调用read()导入可选配置文件前调用read_file()读取相应的初始化配置文件，因为read_file()读取不能打开的文件时会抛出FileNotFoundError异常，而不会直接忽略\nimport configparser, os\n\nconfig = configparser.ConfigParser()\nconfig.read_file(open('defaults.cfg'))\nconfig.read(['site.cfg', os.path.expanduser('~/.myapp.cfg')],\n            encoding='cp1250')\nread_file(f, source=None)从可迭代生成Unicode字符串的f(例如以文本模式打开的文件对象)读取及解析配置数据\nread_string(string, source='<string>')从字符串中解析配置数据\nread_dict(dictionary, source='<dict>')从提供类似dict的items()方法的对象加载配置。key是section名称，value是包含选项和值的字典。如果使用的字典类型支持保留顺序，section及其选项将按序添加，所有值自动转换为字符串\nget(section, option, *  , raw=False, vars=None[, fallback])获取指定section的选项的值。vars参数作为字典对象传递。option按照vars,section,DEFAULTSECT的顺序进行查找，如果不存在且提供了fallback参数，返回fallback的值，fallback可以是None\nraw参数指定value中的格式化字符串是否插值表示，与option的查找顺序相同\ngetint(section, option, *  , raw=False, vars=None[, fallback])转换option的值为int类型\ngetfloat(section, option, *  , raw=False, vars=None[, fallback])转换option的值为float类型\ngetboolean(section, option, *  , raw=False, vars=None[, fallback])转换option的值为bool类型\nitems(raw=False, vars=None)items(section, raw=False, vars=None)前者返回包含DEFAULTSECT的(section_name, section_proxy)对的列表。后者返回指定section的(option, value)对的列表\nset(section, option, value)如果section存在，设置option的值为value，否则抛出NoSectionError异常。option和value必须是字符串类型，否则抛出TypeError异常\nwrite(fileobject, space_around_delimiters=True)将ConfigParser对象写入以文件模式打开的文件。\nremove_option(section, option)从section中移除指定的选项。如果section不存在，抛出NoSectionError异常。如果option存在返回True，否则返回False\nremove_section(section)移除指定section。如果section存在返回True，否则返回False(对默认section的操作总是返回False)\noptionxform(option)对option的处理函数，默认返回option的小写形式。可以通过继承重写或设置ConfigParser实例的optionxform属性(接收一个字符串参数并返回一个新的字符串的函数)改变默认行为。\ncfgparser = ConfigParser()\ncfgparser.optionxform = str\n读取配置文件时，option两边的空格在调用此函数前先被移除\nreadfp(fp, filename=None)已弃用，使用 read_file()替代\nconfigparser.MAX_INTERPOLATION_DEPTH当raw参数为false时，get()方法递归插值的最大深度。仅在使用默认的BasicInterpolation时才有意义\nRawConfigParser对象\n省略\n异常\n省略\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}