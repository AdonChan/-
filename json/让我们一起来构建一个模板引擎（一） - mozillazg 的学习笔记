{"title": "让我们一起来构建一个模板引擎（一） - mozillazg 的学习笔记 ", "index": "模板引擎,python", "content": "假设我们要生成下面这样的 html 字符串:\n<div>\n    <p>welcome, Tom</p>\n    <ul>\n        <li>age: 20</li>\n        <li>weight: 100</li>\n        <li>height: 170</li>\n    </ul>\n</div>\n要求姓名以及 <ul></ul> 中的内容是根据变量动态生成的，也就是这样的:\n<div>\n    <p>welcome, {name}</p>\n    <ul>\n        {info}\n    </ul>\n</div>\n没接触过模板的同学可能会想到使用字符串格式化的方式来实现:\nHTML = '''\n<div>\n    <p>welcome, {name}</p>\n    <ul>\n        {info}\n    </ul>\n</div>\n'''\n\n\ndef gen_html(person):\n    name = person['name']\n    info_list = [\n        '<li>{0}: {1}</li>'.format(item, value)\n        for item, value in person['info'].items()\n    ]\n    info = '\\n'.join(info_list)\n    return HTML.format(name=name, info=info)\n这种方案有一个很明显的问题那就是，需要拼接两个 html 片段。 使用过模板技术的同学应该很容易就想到，在 Web 开发中生成 HTML 的更常用的办法是使用模板:\nHTML = '''\n<div>\n    <p>welcome, {{ person['name'] }}</p>\n    <ul>\n        {% for item, value in person['info'].items() %}\n        <li>{{ item }}: {{ value }}</li>\n        {% endfor %}\n    </ul>\n</div>\n'''\n\n\ndef gen_html(person):\n    return Template(HTML).render({'person': person})\n本系列文章要讲的就是如何从零开始实现一个这样的模板引擎( Template )。\n使用技术\n我们将使用将模板编译为 python 代码的方式来解析和渲染模板。 比如上面的模板将被编译为如下 python 代码:\ndef render_function():\n    result = []\n\n    result.extend([\n        '<div>\\n',\n        '<p>welcome, '\n        str(person['name']),\n        '</p>\\n',\n        '<ul>\\n'\n    ])\n    for item, value in person['info'].items():\n        result.extend([\n            '<li>',\n            str(item),\n            ': ',\n            str(value),\n            '</li>\\n'\n        ])\n    result.extend([\n        '</ul>\\n'\n        '</div>\\n'\n    ])\n    return ''.join(result)\n然后通过 exec 执行生成的代码，之后再执行 render_function() 就可以得到我们需要的 html 字符串了:\nnamespace = {'person': person}\nexec(code, namespace)\nrender_function = namespace['render_function']\nhtml = render_function()\n模板引擎的核心技术就是这些了，下面让我们一步一步的实现它吧。\nCodeBuilder\n我们都知道 python 代码是高度依赖缩进的，所以我们需要一个对象用来保存我们生成代码时的当前缩进情况， 同时也保存已经生成的代码行（可以直接在 github 上下载 template1a.py ）:\n# -*- coding: utf-8 -*-\n# tested on Python 3.5.1\n\n\nclass CodeBuilder:\n    INDENT_STEP = 4     # 每次缩进的空格数\n\n    def __init__(self, indent=0):\n        self.indent = indent    # 当前缩进\n        self.lines = []         # 保存一行一行生成的代码\n\n    def forward(self):\n        \"\"\"缩进前进一步\"\"\"\n        self.indent += self.INDENT_STEP\n\n    def backward(self):\n        \"\"\"缩进后退一步\"\"\"\n        self.indent -= self.INDENT_STEP\n\n    def add(self, code):\n        self.lines.append(code)\n\n    def add_line(self, code):\n        self.lines.append(' ' * self.indent + code)\n\n    def __str__(self):\n        \"\"\"拼接所有代码行后的源码\"\"\"\n        return '\\n'.join(map(str, self.lines))\n\n    def __repr__(self):\n        \"\"\"方便调试\"\"\"\n        return str(self)\nforward 和 backward 方法可以用来控制缩进前进或后退一步，比如在生成 if 语句的时候:\nif age > 13:      # 生成完这一行以后，需要切换缩进了 ``forward()``\n    ...\n    ...           # 退出 if 语句主体的时候，同样需要切换一次缩进 ``backward()``\n...\n\nTemplate\n这个模板引擎的核心部分就是一个 Template 类，用法:\n# 实例化一个 Template 对象\ntemplate = Template('''\n<h1>hello, {{ name }}</h1>\n{% for skill in skills %}\n    <p>you are good at {{ skill }}.</p>\n{% endfor %}\n''')\n\n# 然后，使用一些数据来渲染这个模板\nhtml = template.render(\n    {'name': 'Eric', 'skills': ['python', 'english', 'music', 'comic']}\n)\n一切魔法都在 Template 类里。下面我们写一个基本的 Template 类（可以直接在 github 上下载 template1b.py ）:\nclass Template:\n\n    def __init__(self, raw_text, indent=0, default_context=None,\n                 func_name='__func_name', result_var='__result'):\n        self.raw_text = raw_text\n        self.default_context = default_context or {}\n        self.func_name = func_name\n        self.result_var = result_var\n        self.code_builder = code_builder = CodeBuilder(indent=indent)\n        self.buffered = []\n\n        # 生成 def __func_name():\n        code_builder.add_line('def {}():'.format(self.func_name))\n        code_builder.forward()\n        # 生成 __result = []\n        code_builder.add_line('{} = []'.format(self.result_var))\n        self._parse_text()\n\n        self.flush_buffer()\n        # 生成 return \"\".join(__result)\n        code_builder.add_line('return \"\".join({})'.format(self.result_var))\n        code_builder.backward()\n\n    def _parse_text(self):\n        pass\n\n    def flush_buffer(self):\n        # 生成类似代码: __result.extend(['<h1>', name, '</h1>'])\n        line = '{0}.extend([{1}])'.format(\n            self.result_var, ','.join(self.buffered)\n        )\n        self.code_builder.add_line(line)\n        self.buffered = []\n\n    def render(self, context=None):\n        namespace = {}\n        namespace.update(self.default_context)\n        if context:\n            namespace.update(context)\n        exec(str(self.code_builder), namespace)\n        result = namespace[self.func_name]()\n        return result\n以上就是 Template 类的核心方法了。我们之后要做的就是实现和完善 _parse_text 方法。 当模板字符串为空时生成的代码如下:\n>>> import template1b\n>>> template = template1b.Template('')\n>>> template.code_builder\ndef __func_name():\n    __result = []\n    __result.extend([])\n    return \"\".join(__result)\n可以看到跟上面[使用技术]那节所说生成的代码是类似的。下面我们就一起来实现这个 _parse_text 方法。\n变量\n首先要实现是对变量的支持，模板语法是 {{ variable }} 。 既然要支持变量，首先要做的就是把变量从模板中找出来，这里我们可以使用正则表达式来实现:\nre_variable = re.compile(r'\\{\\{ .*? \\}\\}')\n\n>>> re_variable = re.compile(r'\\{\\{ .*? \\}\\}')\n>>> re_variable.findall('<h1>{{ title }}</h1>')\n['{{ title }}']\n>>>\n知道了如何匹配变量语法，下面我们要把变量跟其他的模板字符串分割开来，这里还是用的 re:\n>> re_variable = re.compile(r'(\\{\\{ .*? \\}\\})')\n>>> re_variable.split('<h1>{{ title }}</h1>')\n['<h1>', '{{ title }}', '</h1>']\n这里的正则之所以加了个分组是因为我们同时还需要用到模板里的变量。 分割开来以后我们就可以对每一项进行解析了。支持 {{ variable }} 语法的 Template 类增加了如下代码 （可以直接在 github 上下载 template1c.py ）:\nclass Template:\n\n    def __init__(self, raw_text, indent=0, default_context=None,\n                 func_name='__func_name', result_var='__result'):\n        # ...\n        self.buffered = []\n\n        self.re_variable = re.compile(r'\\{\\{ .*? \\}\\}')\n        self.re_tokens = re.compile(r'(\\{\\{ .*? \\}\\})')\n\n        # 生成 def __func_name():\n        code_builder.add_line('def {}():'.format(self.func_name))\n        # ...\n\n    def _parse_text(self):\n        tokens = self.re_tokens.split(self.raw_text)\n\n        for token in tokens:\n            if self.re_variable.match(token):\n                variable = token.strip('{} ')\n                self.buffered.append('str({})'.format(variable))\n            else:\n                self.buffered.append('{}'.format(repr(token)))\n_parse_text 中之所以要用 repr ，是因为此时需要把 token 当成一个普通的字符串来处理， 同时需要考虑 token 中包含 \" 和 ' 的情况。 下面是几种有问题的写法:\n\n'str({})'.format(token): 这种是把 token 当成变量来用了，生成的代码为 str(token)\n'\"{}\"'.format(token): 这种虽然是把 token 当成了字符串，但是会有转义的问题，当 token 中包含 \" 时生成的代码为 \"\"hello\"\"\n\n下面先来看一下新的 template1c.py 生成了什么样的代码:\n>>> from template1c import Template\n>>> template = Template('<h1>{{ title }}</h1>')\n>>> template.code_builder\ndef __func_name():\n    __result = []\n    __result.extend(['<h1>',str(title),'</h1>'])\n    return \"\".join(__result)\n没问题，跟预期的是一样的。再来看一下 render 的效果:\n>>> template.render({'title': 'Python'})\n'<h1>Python</h1>'\n不知道你有没有发现，其实 {{ variable }} 不只支持变量，还支持表达式和运算符:\n>>> Template('{{ 1 + 2 }}').render()\n'3'\n>>> Template('{{ items[0] }}').render({'items': [1, 2, 3]})\n'1'\n>>> Template('{{ func() }}').render({'func': list})\n'[]'\n这个既可以说是个 BUG 也可以说是个特性?， 看模板引擎是否打算支持这些功能了， 我们在这里是打算支持这些功能 ;)。\n既然支持了 {{ }} 那么支持注释也就非常好实现了。\n注释\n打算支持的注释模板语法是 {# comments #} ，有了上面实现 {{ variable }} 的经验，实现注释是类似的代码 （可以直接在 github 上下载 template1d.py ）:\nclass Template:\n\n    def __init__(self, raw_text, indent=0, default_context=None,\n                 func_name='__func_name', result_var='__result'):\n        # ...\n        self.buffered = []\n\n        self.re_variable = re.compile(r'\\{\\{ .*? \\}\\}')\n        self.re_comment = re.compile(r'\\{# .*? #\\}')\n        self.re_tokens = re.compile(r'''(\n            (?:\\{\\{ .*? \\}\\})\n            |(?:\\{\\# .*? \\#\\})\n        )''', re.X)\n\n        # 生成 def __func_name():\n        # ...\n\n    def _parse_text(self):\n        tokens = self.re_tokens.split(self.raw_text)\n\n        for token in tokens:\n            if self.re_variable.match(token):\n                # ...\n            # 注释 {# ... #}\n            elif self.re_comment.match(token):\n                continue\n            else:\n                # ...\n效果:\n>>> from template1d import Template\n>>> template = Template('<h1>{{ title }} {# comment #}</h1>')\n>>> template.code_builder\ndef __func_name():\n    __result = []\n    __result.extend(['<h1>',str(title),' ','</h1>'])\n    return \"\".join(__result)\n\n>>> template.render({'title': 'Python'})\n'<h1>Python </h1>'\n至此，我们的模板引擎已经支持了变量和注释功能。 那么如何实现支持 if 语句和 for 循环的标签语法呢:\n{% if user.is_admin %}\n    admin, {{ user.name }}\n{% elif user.is_staff %}\n    staff\n{% else %}\n    others\n{% endif %}\n\n{% for name in names %}\n    {{ name }}\n{% endfor %}\n我将在 第二篇文章 中向你详细的讲解。敬请期待。\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "19"}