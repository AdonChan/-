{"title": "混淆id的一种方法 - wangdai ", "index": "python,webapp", "content": "众所周知，在web应用的API中，总是会出现数据库item的id。比如GET /posts/1表示获取id为1的文章内容。这样做十分简洁，但存在被人爬数据的风险。比如我可以大致猜测或者试一下id的范围，1,2,3...10000这样迭代地爬数据。如果服务器不做访问限制，很轻易就能把所有数据就能爬下来。而且，这样的数字id也会暴露一些信息，比如id小的一般是更早创建的。\n\n所以要对id进行混淆，混淆有这么几个特点：\n\n\n它是一个无符号整数到字符串的一一对应的函数\n双向的，混淆之后可以恢复，所以不能用hash\n不表现出递增的特征\n不用像加密那样强，也不用有密钥\n没有整数范围的限制。这一条是我加的，google能搜到很多id混淆的方法但它们可能要求id在2^32-1之内，比如对2^32求一个multiplicative inverse，这是一个不错的方法但因为这个限制我没有采用它。\n\n最简单的一个方法是找一个比较大的数字进行异或，比如1-10跟1093420374进行异或的结果是这样的：\n\n1 : 1093420375\n2 : 1093420372\n3 : 1093420373\n4 : 1093420370\n5 : 1093420371\n6 : 1093420368\n7 : 1093420369\n8 : 1093420382\n9 : 1093420383\n10: 1093420380\n\n\n但这比较容易被人猜出是异或，需要再加上别的操作\n\n我看到的一个比较好的方法也是我目前在用的是：\n\n\n对id求个hash，取前16字节，作为segment1\n对segment1求hash，取前8字节，作为segment2\n将segment2转换为整数，加上id，再变回byte array\n将segment1和segment2连接起来再求个hash，取前8字节，作为segment3（用于恢复时的验证）\n连接segment1、2、3，做base64，得到混淆后的id\n\n恢复的时候只用\n\n\nbase64解码\n取前16字节得到segment1，后8字节得到segment3，剩余字节是segment2\n验证hash(segmemt1+segment2)是否等于segment3\nint(segment2)-int(hash(segment1))得到id\n\n这用python实现比较方便，因为python的整数可以无限大，代码是这样的\n\npythonclass Obfuscator:\n    _head_bytes = 16\n    _mid_bytes = 8\n    _tail_bytes = 8\n\n    @staticmethod\n    def bytearray_to_int(byte_arr):\n        return int.from_bytes(byte_arr, byteorder='big')\n\n    @staticmethod\n    def int_to_bytearray(num):\n        assert isinstance(num, int) and num >= 0\n        if num == 0:\n            return b'0'\n        result = []\n        while num > 0:\n            d, m = divmod(num, 256)\n            result.append(m)\n            num = d\n        return bytes(result[::-1])\n\n    @classmethod\n    def obfuscate(cls, uid):\n        if not uid:\n            return ''\n        uid_bytes = cls.int_to_bytearray(uid)\n        seg1 = hashlib.sha1(uid_bytes).digest()[:cls._head_bytes]\n\n        seg2 = hashlib.sha1(seg1).digest()[:cls._mid_bytes]\n        seg2 = cls.int_to_bytearray(uid + cls.bytearray_to_int(seg2))\n\n        seg3 = hashlib.sha1(seg1 + seg2).digest()[:cls._tail_bytes]\n\n        return base64.urlsafe_b64encode(seg1 + seg2 + seg3).decode()\n\n    @classmethod\n    def restore(cls, obscure_str):\n        if not obscure_str:\n            return -1\n        seg_bytes = base64.urlsafe_b64decode(obscure_str)\n        seg1 = seg_bytes[:cls._head_bytes]\n        seg2 = seg_bytes[cls._head_bytes:-cls._tail_bytes]\n        seg3 = seg_bytes[-cls._tail_bytes:]\n\n        if hashlib.sha1(seg1 + seg2).digest()[:cls._tail_bytes] != seg3:\n            return -1\n        seg1 = hashlib.sha1(seg1).digest()[:cls._mid_bytes]\n        return cls.bytearray_to_int(seg2) - cls.bytearray_to_int(seg1)\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "14"}