{"title": "使用 Flask 和 AngularJS 构建博客 - 1 - yexiaoxiaobai ", "index": "javascript,rest,python,angularjs,flask", "content": "\n  注：原文作者 John Kevin M. Basco，原文地址为 Building a blog using Flask and AngularJS Part 1\n\n\n在这个教程中，我们将使用 Flask 和 AngularJS 构建一个博客。\n\n这是这个系列教程的第一部分，在这部分我们将专注于构建 REST API ，该 API 将被 AngularJS 应用使用。\n\n目标\n\n该应用的目标非常简单：\n\n\n允许任何用户注册\n允许注册的用户登录\n允许登录的用户创建博客\n允许在首页展示博客\n允许登录的用户退出\n\n这个应用在该系列教程的最后应该看起来像这样：\n\n\n\n必要条件\n\n该教程假设你能顺畅的写 Python 的代码，知道怎样设置一个虚拟环境以及熟悉终端窗口\n\n目录结构\n\n我们将使用的目录结构应该看起来像这样：\n\n\n\n安装必要的 Python 包\n\n我们将使用的包如下：\n\n\nFlask-RESTful - Flask 的 RESTful 扩展\nFlask-SQLAlchemy - Flask 的 SQLAlchemy 扩展\nFlask-Bcrypt - Flask 的 一个为你的应用提供 bcrypt 哈希的工具扩展\nFlask-HTTPAuth - 一个为 Flask 路由提供 Basic and Digest HTTP authentication 的扩展\nFlask-WTF - http://docs.jinkan.org/docs/flask-wtf/\n\nWTForms-Alchemy - 一个 WTForms 扩展，能很简单的基于表单创建模型的工具集\nmarshmallow - 是一个 ORM/ODM/ 的框架，用于转换复杂的数据类型，http://marshmallow.readthedocs.org/en/latest/quickstart.html\n\n\n为了使事情更加简单，在 blog/server/ 目录下创建一个名称为 requirements.txt 的文件，并且把以下内容拷贝进去：\n\nFlask==0.10.1\nFlask-Bcrypt==0.6.0\nFlask-HTTPAuth==2.2.1\nFlask-RESTful==0.2.12\nFlask-SQLAlchemy==1.0\nFlask-WTF==0.10.0\nJinja2==2.7.3\nMarkupSafe==0.23\nSQLAlchemy==0.9.7\nSQLAlchemy-Utils==0.26.9\nWTForms==2.0.1\nWTForms-Alchemy==0.12.8\nWTForms-Components==0.9.5\nWerkzeug==0.9.6\naniso8601==0.83\ndecorator==3.4.0\ninfinity==1.3\nintervals==0.3.1\nitsdangerous==0.24\nmarshmallow==0.7.0\npy-bcrypt==0.4\npytz==2014.4\nsix==1.7.3\nvalidators==0.6.0\nwsgiref==0.1.2\n\n\n进入 blog/server/ 目录，并且运行 pip install -r requirements.txt 命令来安装必须的包\n\n应用的初始化设置\n\n首先，在 blog/server/app 目录下创建一个文件并命名为 config.py，然后复制和粘贴以下的内容到文件中：\n\nDEBUG = True\nWTF_CSRF_ENABLED = False\n\n\n然后在 blog/server/app/ 目录下创建一个文件命名为 server.py。这就是我们将放置我们初始的代码的地方。复制和粘贴以下的代码到文件中：\n\nimport os\n\nfrom flask import Flask\nfrom flask.ext import restful\nfrom flask.ext.restful import reqparse, Api\nfrom flask.ext.sqlalchemy import SQLAlchemy\nfrom flask.ext.bcrypt import Bcrypt\nfrom flask.ext.httpauth import HTTPBasicAuth\n\nbasedir = os.path.join(os.path.abspath(os.path.dirname(__file__)), '../')\n\napp = Flask(__name__)\napp.config.from_object('app.config')\n\n# flask-sqlalchemy\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///' + os.path.join(basedir, 'app.sqlite')\ndb = SQLAlchemy(app)\n\n# flask-restful\napi = restful.Api(app)\n\n# flask-bcrypt\nflask_bcrypt = Bcrypt(app)\n\n# flask-httpauth\nauth = HTTPBasicAuth()\n\n@app.after_request\ndef after_request(response):\n    response.headers.add('Access-Control-Allow-Origin', '*')\n    response.headers.add('Access-Control-Allow-Headers', 'Content-Type,Authorization')\n    response.headers.add('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE')\n    return response\n\nimport views\n\n\n在这个文件中，我们初始化了 Flask，加载了从一个配置文件中加载了配置文件的变量，创建了 flask-sqlalchemy，flask-restful 对象等等。。。而且我们也在 after_request 函数中加了一些响应头，它允许跨域资源共享（CORS），这将允许我们的托管服务器（REST API）和客户端（AngularJS app）在不同的域以及不同的子域（例如：api.johnsblog.com 和 johnsblog.com）。在开发期间，这将允许我们把它们运行在不同的端口（例如：localhost:8000 和 localhost:5000）。\n\nModels\n\n现在我们已经完成了应用的初始化部分，让我们定义 models，在 blog/server/app/ 目录下创建一个文件并命名为 models.py，然后拷贝和粘贴以下代码到文件中：\n\nfrom flask import g\n\nfrom wtforms.validators import Email\n\nfrom server import db, flask_bcrypt\n\nclass User(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    email = db.Column(db.String(120), unique=True, nullable=False, info={'validators': Email()})\n    password = db.Column(db.String(80), nullable=False)\n    posts = db.relationship('Post', backref='user', lazy='dynamic')\n\n    def __init__(self, email, password):\n        self.email = email\n        self.password = flask_bcrypt.generate_password_hash(password)\n\n    def __repr__(self):\n        return '<User %r>' % self.email\n\nclass Post(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    title = db.Column(db.String(120), nullable=False)\n    body = db.Column(db.Text, nullable=False)\n    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))\n    created_at = db.Column(db.DateTime, default=db.func.now())\n\n    def __init__(self, title, body):\n        self.title = title\n        self.body = body\n        self.user_id = g.user.id\n\n    def __repr__(self):\n        return '<Post %r>' % self.title\n\n\n在以上的代码中，我们定义了一个用户和文章的模型，用户模型有一个 id 作为它的主键，被定义成 integer 类型，email 和 password 属性被定义成 strings。通过  posts 属性它也和 POST 模型有关联。POST 模型也有一个 id 作为它的主键，并也被定义成 integer，title 和 body 属性被定义成 strings。它也有一个 user_id 属性被定义成 integer 并作为 User 模型的 id 属性的外键。它还有一个 created_at 属性被定义成 DateTime。\n\nForms\n\n现在我们已经完成了模型定义部分，让我们定义 forms，我们将使用 forms 校验我们的用户输入。为了 form 校验，我们将使用是一个名称为 WTForms 的 Flask 扩展，并且我们将使用 WTForms-Alchemy 扩展它 来更快更简单的定义我们的 forms。在 blog/server/app 目录下创建一个新文件并命名为 forms.py，然后拷贝和粘贴以下代码到文件中：\n\nfrom flask.ext.wtf import Form\n\nfrom wtforms_alchemy import model_form_factory\nfrom wtforms import StringField\nfrom wtforms.validators import DataRequired\n\nfrom app.server import db\nfrom models import User, Post\n\nBaseModelForm = model_form_factory(Form)\n\nclass ModelForm(BaseModelForm):\n    @classmethod\n    def get_session(self):\n        return db.session\n\nclass UserCreateForm(ModelForm):\n    class Meta:\n        model = User\n\nclass SessionCreateForm(Form):\n    email = StringField('name', validators=[DataRequired()])\n    password = StringField('password', validators=[DataRequired()])\n\nclass PostCreateForm(ModelForm):\n    class Meta:\n        model = Post\n\n\n为了使得 WTForms-Alchemy 能与 Flask-WTF 一起工作，我们定义了一个类命名为 ModelForm，它继承自 BaseModelForm ，由 WTForms-Alchemy 提供。你可以在这里找到更多的信息 - http://wtforms-alchemy.readthedocs.org/en/latest/advanced.html#using-wtforms-alchemy-with-flask-wtf\n\n以上代码是非常完美的。但是如果你不明白以上代码做了什么，我建议你读 WTForms 的文档 https://wtforms.readthedocs.org/en/latest/#  和 WTForms-Alchemy 的文档 http://wtforms-alchemy.readthedocs.org/en/latest/index.html 。\n\nSerializers\n\n为了在我们的 responses 中把我们的 model 实例渲染成 JSON，我们首先需要把它们转换成原生的 Python 数据类型， Flask-RESTful 可以使用 fields 模块 和 marshal_with() 装饰器（更多的详细信息请移步 - http://flask-restful.readthedocs.org/en/latest/quickstart.html#data-formatting）。当我开始构建 REST API 的时候我不知道 Flask-RESTful 支持这个，因此我以 Marshmallow 完成 http://marshmallow.readthedocs.org/en/latest/ 。在 blog/server/app/ 目录下创建一个新文件并命名为 serializers.py，然后拷贝和粘贴以下代码到文件中：\n\nfrom marshmallow import Serializer, fields\n\nclass UserSerializer(Serializer):\n    class Meta:\n        fields = (\"id\", \"email\")\n\nclass PostSerializer(Serializer):\n    user = fields.Nested(UserSerializer)\n\n    class Meta:\n        fields = (\"id\", \"title\", \"body\", \"user\", \"created_at\")\n\n\nViews\n\n现在我们已经完成了我们将使用的 models，forms 和 serializers 的定义，让我们定义 views 并且使用。在 blog/server/app/ 目录下创建一个新文件并命名为 views.py ，然后拷贝和粘贴以下代码到文件中：\n\nfrom flask import g\nfrom flask.ext import restful\n\nfrom server import api, db, flask_bcrypt, auth\nfrom models import User, Post\nfrom forms import UserCreateForm, SessionCreateForm, PostCreateForm\nfrom serializers import UserSerializer, PostSerializer\n\n@auth.verify_password\ndef verify_password(email, password):\n    user = User.query.filter_by(email=email).first()\n    if not user:\n        return False\n    g.user = user\n    return flask_bcrypt.check_password_hash(user.password, password)\n\nclass UserView(restful.Resource):\n    def post(self):\n        form = UserCreateForm()\n        if not form.validate_on_submit():\n            return form.errors, 422\n\n        user = User(form.email.data, form.password.data)\n        db.session.add(user)\n        db.session.commit()\n        return UserSerializer(user).data\n\nclass SessionView(restful.Resource):\n    def post(self):\n        form = SessionCreateForm()\n        if not form.validate_on_submit():\n            return form.errors, 422\n\n        user = User.query.filter_by(email=form.email.data).first()\n        if user and flask_bcrypt.check_password_hash(user.password, form.password.data):\n            return UserSerializer(user).data, 201\n        return '', 401\n\nclass PostListView(restful.Resource):\n    def get(self):\n        posts = Post.query.all()\n        return PostSerializer(posts, many=True).data\n\n    @auth.login_required\n    def post(self):\n        form = PostCreateForm()\n        if not form.validate_on_submit():\n            return form.errors, 422\n        post = Post(form.title.data, form.body.data)\n        db.session.add(post)\n        db.session.commit()\n        return PostSerializer(post).data, 201\n\nclass PostView(restful.Resource):\n    def get(self, id):\n        posts = Post.query.filter_by(id=id).first()\n        return PostSerializer(posts).data\n\napi.add_resource(UserView, '/api/v1/users')\napi.add_resource(SessionView, '/api/v1/sessions')\napi.add_resource(PostListView, '/api/v1/posts')\napi.add_resource(PostView, '/api/v1/posts/<int:id>')\n\n\n上面的 verify_password 函数被 auth.verify_password 装饰，并将被 Flask-HTTPAuth 使用来鉴定用户。它基本上通过 email 来获取用户，以及通过校验给出的密码是否与数据库中存储的密码匹配。\n\nUserView 类将处理用户的注册请求，SessionView 类将处理用户的登录请求，PostListView 将处理获取文章列表和创建文章的请求。最后，PostView将处理获取单篇文章的请求。在文件的底部，我们简单的设置了 API 的资源路由。\n\n创建数据库\n\n我们也需要创建一个名称为 db_create.py 的文件。我们将运行这个脚本来初始化数据库。现在我们将进入 blog/server/ 目录并使用 python db_create.py 运行这个脚本。\n\nfrom app.server import db\n\ndb.create_all()\n\n\n运行 REST API 服务\n\n我们需要创建的另外一个文件是 run.py。这是一个脚本，我们将通过运行它来运行一个 REST API 服务。\n\nfrom app.server import app\n\napp.run()\n\n\n如果你正确的遵循了以上步骤，你现在应该可以通过进入 blog/server/ 目录并运行 python run.py 来运行 REST API 服务。\n\n结束点\n\n注册一个用户\n\n为了注册一个用户你需要发送一个 POST 请求给 localhost:5000/api/v1/users。这个请求属性是 email 和 password。这里有 curl 请求来创建一个用户\n\ncurl --dump-header - -H \"Content-Type: application/json\" -X POST -d '{\"email\": \"johndoe@gmail.com\",\"password\": \"admin\"}' http://localhost:5000/api/v1/users\n\n\n登陆一个用户\n\n为了登陆一个用户，你需要通过使用 POST 请求发送一个用户的登陆资格给 localhost:5000/api/v1/sessions。示例：\n\ncurl --dump-header - -H \"Content-Type: application/json\" -X POST -d '{\"email\": \"johndoe@gmail.com\",\"password\": \"admin\"}' http://localhost:5000/api/v1/sessions\n\n\n创建一篇文章\n\n为了创建一篇文章，你需要发送一个 POST 请求给 localhost:5000/api/v1/posts。需要的属性是 title 和 body。因为创建文章的时候要求用户是已经登陆的，注意你需要发送一个包含 base64 编码的用户资格的 Authorization header ，它是通过冒号（\":\"）分离的。示例：\n\ncurl --dump-header - -H \"Content-Type: application/json\" -H \"Authorization: Basic am9obmRvZUBnbWFpbC5jb206YWRtaW4=\" -X POST -d '{\"title\": \"Example post\",\"body\": \"Lorem ipsum\"}' http://localhost:5000/api/v1/posts\n\n\n获取文章\n\n为了获取所有保存的文章，你需要发送一个  GET 请求给http://localhost:5000/api/v1/posts 。示例：\n\ncurl -i http://localhost:5000/api/v1/posts\n\n\n除了使用 curl，你也可以使用更高级的 REST 客户端 Chrome 扩展来测试 API。\n\n下一步？\n\n该教程的第一部分到这里就结束了。在教程的第二部分，我们将专注于构建一个 AngularJS web 应用，它将调用我们已经创建的 REST api。\n\n如果你发现了这篇文章的一些错误或是你有一些问题想问，请在下面留下你的评论。\n\n我希望你喜欢该教程的一部分。在教程的第二部分见。\n\n可用的 REST API 源码在 Github 上，如果你喜欢这个教程，并且它对你有帮助，请给星，下载和 fork 它 - https://github.com/basco-johnkevin/building-a-blog-using-flask-and-angularjs\n\n你也可以在 Twitter 上关注我 - https://twitter.com/johnkevinmbasco\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "41"}