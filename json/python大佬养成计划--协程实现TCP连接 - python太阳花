{"title": "python大佬养成计划--协程实现TCP连接 - python太阳花 ", "index": "python", "content": "协程实现TCP连接\n在网络通信中，每个连接都必须创建新线程（或进程） 来处理，否则，单线程在处理连接的过程中， 无法接受其他客户端的连接。所以我们尝试使用协程来实现服务器对多个客户端的响应。与单一TCP通信的构架一样，只是使用协程来实现多个任务同时进行。\n#服务端\nimport socket\nfrom gevent import monkey\nimport gevent\nmonkey.patch_all()\ndef handle_conn(seObj):\n    while True:\n        re_Data  = seObj.recv(1024).decode('utf-8')\n        if re_Data == 'quit':\n            break\n        print('client>>',re_Data)\n        value  = input(\"server>>\")\n        se_Data = seObj.send(value.encode('utf-8'))\n        if se_Data == 'quit':\n            break\nif __name__ == '__main__':\n    server = socket.socket()\n    server.bind(('192.168.1.227',9876))\n    print(\"服务已开启\")\n    server.listen(4)\n    while True:\n        seObj,add = server.accept()\n        gevent.spawn(handle_conn,seObj)\n    seObj.close()\n    server.close()\nimport  socket\n\n# 1. 创建客户端的socket对象\nclient = socket.socket()\n# 2. 连接服务端， 需要指定端口和IP\nclient.connect(('192.168.1.227',9876))\nwhile True:\n    # 3. 给服务端发送数据\n    send_data = input(\"client:>\")\n    client.send(send_data.encode('utf-8'))\n    if send_data == 'quit':\n        break\n    # 4. 获取服务端返回的消息\n    recv_data = client.recv(1024).decode('utf-8')\n    if recv_data == 'quit':\n        break\n    print(\"server:>%s\" %(recv_data))\n# 5. 关闭socket连接\nclient.close()\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "1"}