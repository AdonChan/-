{"title": "python开发第五篇--装饰器和内置函数 - python学习 ", "index": "python", "content": "装饰器\n装饰器的含义：\n1.装饰器本质上就是一个python函数，他可以让其他函数在不需要做任何代码变动的前提下，增加额外的功能，装饰器的返回值也是一个函数对象。2.装饰器的应用场景：比如插入日志，性能测试，事务处理，缓存等等场景。\n装饰器实例：\n1.现在我有一个需求，我想让你测试这个函数的执行时间，在不改变这个函数代码的情况下：\nimport time\ndef func1():\n    time.sleep(0.3)\n    print('in func1')\ndef timer(func):\n    def inner():\n        start = time.time()\n        func()\n        print(time.time() - start)\n    return inner\nfunc1 = timer(func1)\nfunc1()\n装饰器---简单版\n2.但是如果有多个函数，我都想让你测试他们的执行时间，你每次是不是都得func1 = timer(func1)?这样还是有点麻烦，因为这些函数的函数名可能是不相同，有func1，func2,graph,等等，所以更简单的方法，python给你提供了，那就是语法糖。\nimport time\ndef timer(func):\n    def inner():\n        start = time.time()\n        func()\n        print(time.time() - start)\n    return inner\n@timer   #==> func1 = timer(func1)\ndef func1():\n    time.sleep(0.3)\n    print('in func1')\nfunc1()\n\n3.刚刚我们讨论的装饰器都是装饰不带参数的函数，现在要装饰一个带参数的函数怎么办呢？\nimport  time\ndef timer(func):\n    def inner(a):\n        start = time.time()\n        func(a)\n        print(time.time() - start)\n    return inner\n@timer\ndef func1(a):\n    time.sleep(0.3)\n    print(a)\nfunc1(1)\n4.装饰器通用模板实例：\nimport time\ndef timer(func):\n    def inner(*args,**kwargs):\n        start = time.time()\n        re = func(*args,**kwargs)\n        print(time.time() - start)\n        return re\n    return inner\n@timer   #==> func1 = timer(func1)\ndef func1(a,b):\n    print('in func1')\n@timer   #==> func2 = timer(func2)\ndef func2(a):\n    print('in func2 and get a:%s'%(a))\n    return 'fun2 over'\nfunc1('aaaaaa','bbbbbb')\nprint(func2('aaaaaa'))\n5.上面的装饰器已经非常完美了，但是有我们正常情况下查看函数信息的方法在此处都会失效。\nimport time\ndef timer(func):\n    def inner(*args,**kwargs):\n        \"\"\"this is inner\"\"\"\n        start = time.time()\n        re = func(*args,**kwargs)\n        print(time.time() - start)\n        return re\n    return inner\n@timer   #==> func1 = timer(func1)\ndef func1(a,b):\n    \"\"\"\n    this is func1\n    \"\"\"\n    print('in func1')\nprint(func1.__doc__)   #查看函数的注释 \nprint(func1.__name__)  #查看函数的名字\n查看func1的函数注释变成了this is inner函数的名字变成了inner解决方法：\nfrom functools import wraps\nimport time\ndef timer(func):\n    @wraps(func)  # 加在最内层函数正上方\n    def inner(*args,**kwargs):\n        \"\"\"this is inner\"\"\"\n        start = time.time()\n        re = func(*args,**kwargs)\n        print(time.time() - start)\n        return re\n    return inner\n@timer   #==> func1 = timer(func1)\ndef func1(a,b):\n    \"\"\"\n    this is func1\n    \"\"\"\n    print('in func1')\nprint(func1.__doc__)   #查看函数的注释\nprint(func1.__name__)  #查看函数的名字\n开放封闭原则\n1.对扩展是开放的　　　　为什么要对扩展开放呢？　　　　我们说，任何一个程序，不可能在设计之初就已经想好了所有的功能并且未来不做任何更新和修改。所以我们必须允许代码扩展、添加新功能。2.对修改是封闭的　　　　为什么要对修改封闭呢？　　　　就像我们刚刚提到的，因为我们写的一个函数，很有可能已经交付给其他人使用了，如果这个时候我们对其进行了修改，很有可能影响其他已经在使用该函数的用户。装饰器完美的遵循了这个开放封闭原则。\n装饰器的主要功能和固定结构\n1.装饰器的固定格式：\ndef timer(func):\n    def inner(*args,**kwargs):\n        '''执行函数之前要做的'''\n        re = func(*args,**kwargs)\n        '''执行函数之后要做的'''\n        return re\n    return inner\n2.装饰器的固定格式wraps版：\nfrom functools import wraps\n\ndef deco(func):\n    @wraps(func) #加在最内层函数正上方\n    def wrapper(*args,**kwargs):\n        return func(*args,**kwargs)\n    return wrapper\n带参数的装饰器\n假如你有成千上万个函数使用了一个装饰器，现在你想把这些装饰器都取消掉，你要怎么做？一个一个的取消掉？ 没日没夜忙活3天。。。过两天你领导想通了，再让你加上。。。\ndef outer(flag):\n    def timer(func):\n        def inner(*args,**kwargs):\n            if flag:\n                print('''执行函数之前要做的''')\n            re = func(*args,**kwargs)\n            if flag:\n                print('''执行函数之后要做的''')\n            return re\n        return inner\n    return timer\n@outer(False)\ndef func():\n    print(111)\nfunc()\n多个装饰器装饰一个函数\ndef wrapper1(func):   #f = warpper1(f)  里面的f函数名 外面的f 是inner1\n    def inner1():\n        print('wrapper1 ,before func')\n        func()\n        print('wrapper1 ,after func')\n    return inner\n\ndef wrapper2(func):    #f = warpper2(f)  里面的f是inner1 外面的f是inner2\n    def inner2():\n        print('wrapper2 ,before func')\n        func()\n        print('wrapper2 ,after func')\n    return inner\n\n@wrapper2\n@wrapper1\ndef f():\n    print('in f')\nf()\n输出为：wrapper2 ,before funcwrapper1 ,before funcin fwrapper1 ,after funcwrapper2 ,after func\n\n迭代器\n什么是可迭代对象\n字符串、列表、元组、字典、集合都可以被for循环，说明他们都是可迭代的。\nfrom collections import Iterable\ns_str = \"1234\"\nl = [1,2,3,4]\nt = (1, 2, 3,4)\nd = {1:2,3:4}\ns_set = {1,2,3,4}\nprint(isinstance(s_str, Iterable))\nprint(isinstance(l, Iterable))\nprint(isinstance(t, Iterable))\nprint(isinstance(d, Iterable))\nprint(isinstance(s_set,Iterable))\n可迭代协议\n我们现在是从结果分析原因，能被for循环的就是“可迭代的”，但是如果正着想，for怎么知道谁是可迭代的呢？假如我们自己写了一个数据类型，希望这个数据类型里的东西也可以使用for被一个一个的取出来，那我们就必须满足for的要求。这个要求就叫做“协议”。可以被迭代要满足的要求就叫做可迭代协议。可迭代协议的定义非常简单，就是内部实现了__iter__方法。\nprint( \"__iter__\" in dir(str))\nTrue\nprint(dir(str))\n['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']\n总结一下我们现在所知道的：可以被for循环的都是可迭代的，要想可迭代，内部必须有一个__iter__方法。接着分析，__iter__方法做了什么事情呢？可迭代的：内部必须含有一个__iter__方法。\n迭代器\ns = \"1234\"\ns_obj = s.__iter__()\nwhile True:\n    try:\n        print(s_obj.__next__())\n    except:\n        break\n迭代器遵循迭代器协议：必须拥有__iter__方法和__next__方法。for循环，能遍历一个可迭代对象，他的内部到底进行了什么？将可迭代对象转化成迭代器。（可迭代对象.__iter__()）内部使用__next__方法，一个一个取值。加了异常处理功能，取值到底后自动停止。总结：迭代器\n\n\n可迭代对象：\n\n凡是可以用for可以遍历的基本都是可迭代的\nstr，list，tuple，dict，set，文件句柄，range中\n对象中含有__iter__方法的就是可迭代对象，遵循可迭代协议\n判断该是否可迭代对象\n\n\n\n迭代器含义：\n\n内部含有__iter__且含有__next__方法的对象就是迭代器，遵循迭代器协议\n迭代器可以取值，必须通过__next__取值\n判断该对象是不是迭代器\n\n\n\n迭代器的好处:\n\n减少内存\n惰性机制\n单向执行，不可逆\n\n\n\n生成器\n生成器的含义\n\n生成器本质就是迭代器，是自己定义的迭代器，单向执行，不可逆\n\n构建方式：1.函数方式\n    1.在函数中看到yield，就不是函数了，他就是生成器\n    2.__next__和yield一一对应\n    3.--next__和send都可以取值，send会给上一个yield会发送一个值\n    4.send不能用作第一次取值，最后一个yiled不能取到值\n2.列表推导式\n    1.[变量（加工后的变量）for 变量 in iterable(可迭代对象)]  遍历模式;\n    2.[变量（加工后的变量）for 变量 in iterable(可迭代对象) if 条件] 筛选模式；\n    3.特别复杂的无法用列表推导式\n3.区别：\n1.列表推导式直观可以看出，但是占内存\n2.生成器表达式不易看出，但是节省内存      \n\n生成器Generator：\n\n　　1.本质：迭代器(所以自带了__iter__方法和__next__方法，不需要我们去实现)　　2.特点：惰性运算,开发者自定义\n生成器函数\n一个包含yield关键字的函数就是一个生成器函数。yield可以为我们从函数中返回值，但是yield又不同于return，return的执行意味着程序的结束，调用生成器函数不会得到返回的具体的值，而是得到一个可迭代的对象。每一次获取这个可迭代对象的值，就能推动函数的执行，获取新的返回值。直到函数执行结束。\n    with open(\"info\",encoding=\"utf-8\",mode=\"r\") as f_read:\n        for line in f_read:\n            yield line.strip().split(\",\")\n列表推导式和生成器表达式\n[变量（加工后的变量）for 变量 in iterable(可迭代对象)1.列表推导式\nl = [i for i in range(10)]\nprint(l)\nl1 = ['选项%s'%i for i in range(10)]\nprint(l1)\n2.把列表解析的[]换成()得到的就是生成器表达式\nl = (x for x in range(1,5))\nfor i in l:\n    print(i)\n列表解析与生成器表达式都是一种便利的编程方式，只不过生成器表达式更节省内存过滤掉长度小于3的字符串列表，并将剩下的转换成大写字母\nl = [\"abc\",\"ac\",\"accd\"]\nl1 = [i.upper() for i in l if len(i) >=3]\nprint(l1)\n\n内置函数\n\n作用域相关\n1.locals ：函数会以字典的类型返回当前位置的全部局部变量。2.globals：函数以字典的类型返回全部全局变量\na = 1\nb = 2\nprint(locals())\nprint(globals())\n# 这两个一样，因为是在全局执行的。\n\n##########################\n\ndef func(argv):\n    c = 2\n    print(locals())\n    print(globals())\nfunc(3)\n\n#这两个不一样，locals() {'argv': 3, 'c': 2}\n#globals() {'__doc__': None, '__builtins__': <module 'builtins' (built-in)>, '__cached__': None, '__loader__': <_frozen_importlib_external.SourceFileLoader object at 0x0000024409148978>, '__spec__': None, '__file__': 'D:/lnh.python/.../内置函数.py', 'func': <function func at 0x0000024408CF90D0>, '__name__': '__main__', '__package__': None}\n其他相关\n1.字符串类型代码的执行 eval,exec\neval的含义就是去掉字符串两边的引号，里边该是什么类型就是什么类型\na =  \"'123'\"\nprint(eval(a))\n#打印结果为：123\nexec\ns = '''\nfor i in [1,2,3]:\n    print(i)\n'''\nexec(s)\n打印结果为：\n1\n2\n3\n2.输入输出相关 input,print\ndef print(self, *args, sep=' ', end='\\n', file=None): # known special case of print\n    \"\"\"\n    print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False)\n    file:  默认是输出到屏幕，如果设置为文件句柄，输出到文件\n    sep:   打印多个值之间的分隔符，默认为空格\n    end:   每一次打印的结尾，默认为换行符\n    flush: 立即把内容输出到流文件，不作缓存\n    \"\"\"\n'''\n\nprint(111,222,333,sep='*')  # 111*222*333\n\nprint(111,end='')\nprint(222)  #两行的结果 111222\n\nf = open('log','w',encoding='utf-8')\nprint('写入文件',file=f,flush=True)\n3.内存相关 hash idhash：获取一个对象（可哈希对象：int,str,Bool，tuple）的哈希值。4.文件操作相关open：函数用于打开一个文件，创建一个 file 对象，相关的方法才可以调用它进行读写。5.调用相关callable：函数用于检查一个对象是否是可调用的。如果返回True，object仍然可能调用失败；但如果返回False，调用对象ojbect绝对不会成功。\ndef add(a,b):\n    return a+b\nprint(callable(add))\n6.查看内置属性dir：函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表。如果参数包含方法__dir__()，该方法将被调用。如果参数不包含__dir__()，该方法将最大限度地收集参数信息。\nprint(dir())   #查看当前模块的属性列表 \n['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 's']获得当前模块的属性列表\nprint(dir(\"a\")) #查看字符串的属性列表\n['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']\n迭代器生成器相关\nrange：函数可创建一个整数对象，一般用在 for 循环中。next：内部实际使用了__next__方法，返回迭代器的下一个项目。\n# 首先获得Iterator对象:\nit = iter([1, 2, 3, 4, 5]\n# 循环:\nwhile True:\n    try:\n        # 获得下一个值:\n        x = next(it)\n        print(x)\n    except StopIteration:\n        # 遇到StopIteration就退出循环\n        break\niter：函数用来生成迭代器（讲一个可迭代对象，生成迭代器）\nfrom collections import Iterable\nfrom collections import Iterator\nl = [1,2,3]\nprint(isinstance(l,Iterable))  # True\nprint(isinstance(l,Iterator))  # False\n\nl1 = iter(l)\nprint(isinstance(l1,Iterable))  # True\nprint(isinstance(l1,Iterator))\n基础数据类型相关\n1.数字相关数据类型：　　　　bool ：用于将给定参数转换为布尔类型，如果没有参数，返回 False。　　　　int：函数用于将一个字符串或数字转换为整型。\nprint(int())  # 0\n\nprint(int('12'))  # 12\n\nprint(int(3.6))  # 3\n\nprint(int('0100',base=2))  # 将2进制的 0100 转化成十进制。结果为 4\n2.float：函数用于将整数和字符串转换成浮点数。\na = \"1.2\"\nprint(float(a))   #1.2\nb = 1\nprint(float(b))   #1.0\n3.进制转换：　　　　bin：将十进制转换成二进制并返回。　　　　oct：将十进制转化成八进制字符串并返回。　　　　hex：将十进制转化成十六进制字符串并返回。\nprint(bin(10),type(bin(10)))  # 0b1010 <class 'str'>\nprint(oct(10),type(oct(10)))  # 0o12 <class 'str'>\nprint(hex(10),type(hex(10)))  # 0xa <class 'str'>\n4.数学运算：　　　　abs：函数返回数字的绝对值。　　　　divmod：计算除数与被除数的结果，返回一个包含商和余数的元组(a // b, a % b)。　　　　round：保留浮点数的小数位数，默认保留整数。　　　　pow：求xy次幂。（三个参数为xy的结果对z取余）\nprint(abs(-5))  # 5\n\nprint(divmod(7,2))  # (3, 1)\n\nprint(round(7/3,2))  # 2.33\nprint(round(7/3))  # 2\nprint(round(3.32567,3))  # 3.326\n\nprint(pow(2,3))  # 两个参数为2**3次幂\nprint(pow(2,3,3))  # 三个参数为2**3次幂，对3取余。\n5.sum：对可迭代对象进行求和计算（可设置初始值）。\nprint(sum([1,2,3]))  #6\nprint(sum((1,2,3),100)) #106\nmin：返回可迭代对象的最小值（可加key，key为函数名，通过函数的规则，返回最小值）。\nprint(min([1,2,3]))  # 返回此序列最小值\nret = min([1,2,-5,],key=abs)  # 按照绝对值的大小，返回此序列最小值\nprint(ret)\ndic = {'a':3,'b':2,'c':1}\nprint(min(dic,key=lambda x:dic[x]))\n# x为dic的key，lambda的返回值（即dic的值进行比较）返回最小的值对应的键\n　max：返回可迭代对象的最大值（可加key，key为函数名，通过函数的规则，返回最大值）。\nprint(max([1,2,3]))  # 返回此序列最大值\nret = max([1,2,-5,],key=abs)  # 按照绝对值的大小，返回此序列最大值\nprint(ret)\ndic = {'a':3,'b':2,'c':1}\nprint(max(dic,key=lambda x:dic[x]))\n# x为dic的key，lambda的返回值（即dic的值进行比较）返回最大的值对应的键\n和数据结构相关\n列表和元祖（2）　　　　list：将一个可迭代对象转化成列表（如果是字典，默认将key作为列表的元素）　　　　tuple：将一个可迭代对象转化成元祖（如果是字典，默认将key作为元祖的元素）\nl = list((1,2,3))\nprint(l)\n\nl = list({1,2,3})\nprint(l)\n\nl = list({'k1':1,'k2':2})\nprint(l)\n\ntu = tuple((1,2,3))\nprint(tu)\n\ntu = tuple([1,2,3])\nprint(tu)\n\ntu = tuple({'k1':1,'k2':2})\nprint(tu)\n相关内置函数 :　　　　reversed：将一个序列翻转，并返回此翻转序列的迭代器。　　　　slice：构造一个切片对象，用于列表的切片。\nite = reversed(['a',2,3,'c',4,2])\nfor i in ite:\n    print(i)\n\nli = ['a','b','c','d','e','f','g']\nsli_obj = slice(3)\nprint(li[sli_obj])\n\nsli_obj = slice(0,7,2)\nprint(li[sli_obj])\n字符串相关　　　　str：将数据转化成字符串。　　　　format:与具体数据相关，用于计算各种小数，精算等。\n#字符串可以提供的参数,指定对齐方式，<是左对齐， >是右对齐，^是居中对齐\nprint(format('test', '<20'))\nprint(format('test', '>20'))\nprint(format('test', '^20'))\n\n#整形数值可以提供的参数有 'b' 'c' 'd' 'o' 'x' 'X' 'n' None\n>>> format(3,'b') #转换成二进制\n'11'\n>>> format(97,'c') #转换unicode成字符\n'a'\n>>> format(11,'d') #转换成10进制\n'11'\n>>> format(11,'o') #转换成8进制\n'13'\n>>> format(11,'x') #转换成16进制 小写字母表示\n'b'\n>>> format(11,'X') #转换成16进制 大写字母表示\n'B'\n>>> format(11,'n') #和d一样\n'11'\n>>> format(11) #默认和d一样\n'11'\n\n#浮点数可以提供的参数有 'e' 'E' 'f' 'F' 'g' 'G' 'n' '%' None\n>>> format(314159267,'e') #科学计数法，默认保留6位小数\n'3.141593e+08'\n>>> format(314159267,'0.2e') #科学计数法，指定保留2位小数\n'3.14e+08'\n>>> format(314159267,'0.2E') #科学计数法，指定保留2位小数，采用大写E表示\n'3.14E+08'\n>>> format(314159267,'f') #小数点计数法，默认保留6位小数\n'314159267.000000'\n>>> format(3.14159267000,'f') #小数点计数法，默认保留6位小数\n'3.141593'\n>>> format(3.14159267000,'0.8f') #小数点计数法，指定保留8位小数\n'3.14159267'\n>>> format(3.14159267000,'0.10f') #小数点计数法，指定保留10位小数\n'3.1415926700'\n>>> format(3.14e+1000000,'F')  #小数点计数法，无穷大转换成大小字母\n'INF'\n\n#g的格式化比较特殊，假设p为格式中指定的保留小数位数，先尝试采用科学计数法格式化，得到幂指数exp，如果-4<=exp<p，则采用小数计数法，并保留p-1-exp位小数，否则按小数计数法计数，并按p-1保留小数位数\n>>> format(0.00003141566,'.1g') #p=1,exp=-5 ==》 -4<=exp<p不成立，按科学计数法计数，保留0位小数点\n'3e-05'\n>>> format(0.00003141566,'.2g') #p=1,exp=-5 ==》 -4<=exp<p不成立，按科学计数法计数，保留1位小数点\n'3.1e-05'\n>>> format(0.00003141566,'.3g') #p=1,exp=-5 ==》 -4<=exp<p不成立，按科学计数法计数，保留2位小数点\n'3.14e-05'\n>>> format(0.00003141566,'.3G') #p=1,exp=-5 ==》 -4<=exp<p不成立，按科学计数法计数，保留0位小数点，E使用大写\n'3.14E-05'\n>>> format(3.1415926777,'.1g') #p=1,exp=0 ==》 -4<=exp<p成立，按小数计数法计数，保留0位小数点\n'3'\n>>> format(3.1415926777,'.2g') #p=1,exp=0 ==》 -4<=exp<p成立，按小数计数法计数，保留1位小数点\n'3.1'\n>>> format(3.1415926777,'.3g') #p=1,exp=0 ==》 -4<=exp<p成立，按小数计数法计数，保留2位小数点\n'3.14'\n>>> format(0.00003141566,'.1n') #和g相同\n'3e-05'\n>>> format(0.00003141566,'.3n') #和g相同\n'3.14e-05'\n>>> format(0.00003141566) #和g相同\n'3.141566e-05'\nbytes：用于不同编码之间的转化\ns = \"中国\"\ns1 = s.encode(\"utf-8\")\nprint(s1.decode(\"utf-8\"))\n\n#将s1的gbk的bytes类型转成utf-8的bytes类型\ns = \"中国\"\ns1 = s.encode(\"gbk\")\nprint(s1.decode(\"gbk\").encode(\"utf-8\"))\nbytearry：返回一个新字节数组。这个数组里的元素是可变的，并且每个元素的值范围: 0 <= x < 256。\nret = bytearray('alex',encoding='utf-8')\nprint(id(ret))\nprint(ret)\nprint(ret[0])\nret[0] = 65\nprint(ret)\nprint(id(ret))\nrepr:返回一个对象的string形式（原形毕露）。\n# %r  原封不动的写出来\n# name = 'taibai'\n# print('我叫%r'%name)\n\n# repr 原形毕露\nprint(repr('{\"name\":\"alex\"}'))\nprint('{\"name\":\"alex\"}')\n数据集合　　　　dict：创建一个字典。　　　　set：创建一个集合。　　　　frozenset：返回一个冻结的集合，冻结后集合不能再添加或删除任何元素。相关内置函数 　　　　len:返回一个对象中元素的个数。　　　　sorted：对所有可迭代的对象进行排序操作。\nL = [('a', 1), ('c', 3), ('d', 4),('b', 2), ]\nsorted(L, key=lambda x:x[1])               # 利用key\n[('a', 1), ('b', 2), ('c', 3), ('d', 4)]\n \n \nstudents = [('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]\nsorted(students, key=lambda s: s[2])            # 按年龄排序\n[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]\n \nsorted(students, key=lambda s: s[2], reverse=True)    # 按降序\n[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]\n　enumerate:枚举，返回一个枚举对象。\n    print(enumerate([1,2,3]))\nfor i in enumerate([1,2,3]):\n    print(i)\nfor i in enumerate([1,2,3],100):\n    print(i)\nall：可迭代对象中，全都是True才是Trueany：可迭代对象中，有一个True 就是True\n# all  可迭代对象中，全都是True才是True\n# any  可迭代对象中，有一个True 就是True\n# print(all([1,2,True,0]))\n# print(any([1,'',0]))\nzip：函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同。\nl1 = [1,2,3,]\nl2 = ['a','b','c',5]\nl3 = ('*','**',(1,2,3))\nfor i in zip(l1,l2,l3):\n    print(i)\n #\n(1, 'a', '*')\n(2, 'b', '**')\n(3, 'c', (1, 2, 3))\nfilter：过滤\ndef func(x):return x%2 == 0\nret = filter(func,[1,2,3,4,5,6,7])\nprint(ret)   \nfor i in ret:\n    print(i)\nmap:会根据提供的函数对指定序列做映射，返回的是一个迭代器。\n>>>def square(x) :            # 计算平方数\n...     return x ** 2\n... \n>>> map(square, [1,2,3,4,5])   # 计算列表各个元素的平方\n[1, 4, 9, 16, 25]\n>>> map(lambda x: x ** 2, [1, 2, 3, 4, 5])  # 使用 lambda 匿名函数\n[1, 4, 9, 16, 25]\n \n# 提供了两个列表，对相同位置的列表数据进行相加\n>>> map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10])\n[3, 7, 11, 15, 19]\n\n#map返回的是一个生成器，，取值要用for循环\nfor i in  map(lambda n:n+'_sb',['oldboy','alex','wusir']):\n    print(i)\n匿名函数\n匿名函数：为了解决那些功能很简单的需求而设计的一句话函数。\ndef calc(n):\n    return n**n\nprint(calc(10))\n \n#换成匿名函数\ncalc = lambda n:n**n\nprint(calc(10))\n\n上面是我们对calc这个匿名函数的分析，下面给出了一个关于匿名函数格式的说明函数名 = lambda 参数 ：返回值\n- 参数可以有多个，用逗号隔开\n- 匿名函数不管逻辑多复杂，只能写一行，且逻辑执行结束后的内容就是返回值\n- 返回值和正常的函数一样可以是任意数据类型\n\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}