{"title": "Redis入门教程 - 人生苦短，我用Python ", "index": "python,linux,mysql,人工智能,区块链", "content": "推荐本人的《Python 自动化运维实战》课程，提供在线实验环境，边敲代码边学习。\n一、基础知识\n1.1 数据库\n在Redis里，数据库简单的使用一个数字编号来进行辨认，默认数据库的数字编号是0。如果你想切换到一个不同的数据库，你可以使用select命令来实现。在命令行界面里键入select 1，Redis应该会回复一条OK的信息，然后命令行界面里的提示符会变成类似redis 127.0.0.1:6379[1]>这样。如果你想切换回默认数据库，只要在命令行界面键入select 0即可\n1.2 命令、关键字和值\nRedis不仅仅是一种简单的关键字-值型存储，从其核心概念来看，Redis的5种数据结构中的每一个都至少有一个关键字和一个值\n关键字（Keys）是用来标识数据块，值（Values）是关联于关键字的实际值，可以是字符串、整数、序列化对象（使用JSON、XML或其他格式）\nRedis命令的基本构成，如：set users:leto \"{name: leto, planet: dune, likes: [spice]}\"\n关键字和值的是Redis的基本概念，而get和set命令是对此最简单的使用\n1.3 Redis查询\n对于Redis而言，关键字就是一切，而值是没有任何意义。Redis不允许通过值来进行查询\n1.4 存储器和持久化\nRedis是一种持久化的存储器内存储（in-memory persistent store）默认情况下，Redis会根据已变更的关键字数量来进行判断，然后在磁盘里创建数据库的快照（snapshot）。你可以对此进行设置，如果X个关键字已变更，那么每隔Y秒存储数据库一次。默认情况下，如果1000个或更多的关键字已变更，Redis会每隔60秒存储数据库；而如果9个或更少的关键字已变更，Redis会每隔15分钟存储数据库\n至于存储器，Redis会将所有数据都保留在存储器中。显而易见，运行Redis具有不低的成本：因为RAM仍然是最昂贵的服务器硬件部件\n1.5 小结\n关键字（Keys）是用于标识一段数据的一个字符串\n值（Values）是一段任意的字节序列，Redis不会关注它们实质上是什么\nRedis展示了（也实现了）5种专门的数据结构\n上面的几点使得Redis快速而且容易使用，但要知道Redis并不适用于所有的应用场景\n二、Redis的数据结构\n关于key\n\nkey不要太长，尽量不要超过1024字节，这不仅消耗内存，而且会降低查找的效率\nkey也不要太短，太短的话，key的可读性会降低\n在一个项目中，key最好使用统一的命名模式，例如user:10000:passwd\n\n2.1 字符串strings\n127.0.0.1:6379> set mynum \"2\"\nOK\n127.0.0.1:6379> get mynum\n\"2\"\n127.0.0.1:6379> incr mynum\n(integer) 3\n127.0.0.1:6379> get mynum\n\"3\"\n由于INCR等指令本身就具有原子操作的特性，所以我们完全可以利用redis的INCR、INCRBY、DECR、DECRBY等指令来实现原子计数的效果，假如，在某种场景下有3个客户端同时读取了mynum的值（值为2），然后对其同时进行了加1的操作，那么，最后mynum的值一定是5。不少网站都利用redis的这个特性来实现业务上的统计计数需求。\n2.2 列表lists\nlists的常用操作包括LPUSH、RPUSH、LRANGE等。我们可以用LPUSH在lists的左侧插入一个新元素，用RPUSH在lists的右侧插入一个新元素，用LRANGE命令从lists中指定一个范围来提取元素。\n//新建一个list叫做mylist，并在列表头部插入元素\"1\"\n127.0.0.1:6379> lpush mylist \"1\"\n//返回当前mylist中的元素个数\n(integer) 1\n//在mylist右侧插入元素\"2\"\n127.0.0.1:6379> rpush mylist \"2\"\n(integer) 2\n//在mylist左侧插入元素\"0\"\n127.0.0.1:6379> lpush mylist \"0\"\n(integer) 3\n//列出mylist中从编号0到编号1的元素\n127.0.0.1:6379> lrange mylist 0 1\n1) \"0\"\n2) \"1\"\n//列出mylist中从编号0到倒数第一个元素\n127.0.0.1:6379> lrange mylist 0 -1\n1) \"0\"\n2) \"1\"\n3) \"2\"\nlists的应用相当广泛，随便举几个例子：\n\n我们可以利用lists来实现一个消息队列，而且可以确保先后顺序，不必像MySQL那样还需要通过ORDER BY来进行排序。\n利用LRANGE还可以很方便的实现分页的功能。\n在博客系统中，每片博文的评论也可以存入一个单独的list中。\n\n2.3 集合sets\nredis的集合，是一种无序的集合，集合中的元素没有先后顺序。集合相关的操作也很丰富，如添加新元素、删除已有元素、取交集、取并集、取差集等.\n//向集合myset中加入一个新元素\"one\"\n127.0.0.1:6379> sadd myset \"one\"\n(integer) 1\n127.0.0.1:6379> sadd myset \"two\"\n(integer) 1\n//列出集合myset中的所有元素\n127.0.0.1:6379> smembers myset\n1) \"one\"\n2) \"two\"\n//判断元素1是否在集合myset中，返回1表示存在\n127.0.0.1:6379> sismember myset \"one\"\n(integer) 1\n//判断元素3是否在集合myset中，返回0表示不存在\n127.0.0.1:6379> sismember myset \"three\"\n(integer) 0\n//新建一个新的集合yourset\n127.0.0.1:6379> sadd yourset \"1\"\n(integer) 1\n127.0.0.1:6379> sadd yourset \"2\"\n(integer) 1\n127.0.0.1:6379> smembers yourset\n1) \"1\"\n2) \"2\"\n//对两个集合求并集\n127.0.0.1:6379> sunion myset yourset\n1) \"1\"\n2) \"one\"\n3) \"2\"\n4) \"two\"\n对于集合的使用，也有一些常见的方式，比如，QQ有一个社交功能叫做“好友标签”。\n2.4 有序集合sorted sets\nredis还提供了有序集合（sorted sets）。有序集合中的每个元素都关联一个序号（score），这便是排序的依据。很多时候，我们都将redis中的有序集合叫做zsets，这是因为在redis中，有序集合相关的操作指令都是以z开头的，比如zrange、zadd、zrevrange、zrangebyscore等等\n//新增一个有序集合myzset，并加入一个元素baidu.com，给它赋予的序号是1：\n127.0.0.1:6379> zadd myzset 1 baidu.com\n(integer) 1\n//向myzset中新增一个元素360.com，赋予它的序号是3\n127.0.0.1:6379> zadd myzset 3 360.com\n(integer) 1\n//向myzset中新增一个元素google.com，赋予它的序号是2\n127.0.0.1:6379> zadd myzset 2 google.com\n(integer) 1\n//列出myzset的所有元素，同时列出其序号，可以看出myzset已经是有序的了。\n127.0.0.1:6379> zrange myzset 0 -1 withscores\n1) \"baidu.com\"\n2) \"1\"\n3) \"google.com\"\n4) \"2\"\n5) \"360.com\"\n6) \"3\"\n//只列出myzset的元素\n127.0.0.1:6379> zrange myzset 0 -1\n1) \"baidu.com\"\n2) \"google.com\"\n3) \"360.com\"\n2.5 哈希hashes\nhashes存的是字符串和字符串值之间的映射，比如一个用户要存储其全名、姓氏、年龄等等，就很适合使用哈希\n//建立哈希，并赋值\n127.0.0.1:6379> HMSET user username antirez password P1pp0 age 34\nOK\n//列出哈希的内容\n127.0.0.1:6379> HGETALL user\n1) \"username\"\n2) \"antirez\"\n3) \"password\"\n4) \"P1pp0\"\n5) \"age\"\n6) \"34\"\n//更改哈希中的某一个值\n127.0.0.1:6379> HSET user password 12345\n(integer) 0\n//再次列出哈希的内容\n127.0.0.1:6379> HGETALL user\n1) \"username\"\n2) \"antirez\"\n3) \"password\"\n4) \"12345\"\n5) \"age\"\n6) \"34\"\n三、Redis持久化-RDB和AOF\n持久化不属于入门范围，找了几篇比较好的文章，有兴趣欢迎阅读\n\nredis持久化RDB和AOF\n\n[Redis持久化RDB和AOF相比较]\n\n[redis系列：RDB持久化与AOF持久化]\n\n四、redis.conf文件配置项\nredis.conf 配置项说明如下：\n\nRedis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程daemonize no\n\n当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定pidfile /var/run/redis.pid\n\n指定Redis监听端口，默认端口为6379，这里有个故事，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字port 6379\n\n绑定的主机地址bind 127.0.0.1\n\n当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能timeout 30\n\n指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verboseloglevel verbose\n\n日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/nulllogfile stdout\n\n设置数据库的数量，默认数据库为0，可以使用SELECT <dbid>命令在连接上指定数据库iddatabases 16\n\n指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合save <seconds> <changes>  Redis默认配置文件中提供了三个条件：  `save 900 1  save 300 10  save 60 10000`  分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。\n指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大rdbcompression yes\n\n指定本地数据库文件名，默认值为dump.rdbdbfilename dump.rdb\n\n\n指定本地数据库存放目录\n`dir ./`\n\n\n\n设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步\n`slaveof <masterip> <masterport>`\n\n\n\n当master服务设置了密码保护时，slav服务连接master的密码\n`masterauth <master-password>`\n\n\n\n设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH <password>命令提供密码，默认关闭\n`requirepass foobared`\n\n\n设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息maxclients 128\n\n\n指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区\n`maxmemory <bytes>`\n\n\n指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为noappendonly no\n\n指定更新日志文件名，默认为appendonly.aofappendfilename appendonly.aof\n\n\n指定更新日志条件，共有3个可选值：\nno：表示等操作系统进行数据缓存同步到磁盘（快）  always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）  everysec：表示每秒同步一次（折衷，默认值） appendfsync everysec\n\n指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中vm-enabled no\n\n虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享vm-swap-file /tmp/redis.swap\n\n将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0vm-max-memory 0\n\nRedis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值vm-page-size 32\n\n设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。vm-pages 134217728\n\n设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4vm-max-threads 4\n\n设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启glueoutputbuf yes\n\n指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法   `hash-max-zipmap-entries 64   hash-max-zipmap-value 512`\n指定是否激活重置哈希，默认为开启activerehashing yes\n\n指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件include /path/to/local.conf\n\n\n什么是守护进程？守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是 Linux 中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。守护进程是个特殊的孤儿进程，这种进程脱离终端，为什么要脱离终端呢？之所以脱离于终端是为了避免进程被任何终端所产生的信息所打断，其在执行过程中的信息也不在任何终端上显示。由于在 linux 中，每一个系统与用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依附于这个终端，这个终端就称为这些进程的控制终端，当控制终端被关闭时，相应的进程都会自动关闭。\n五、 事务处理\nMULTI、EXEC、DISCARD、WATCH指令构成了redis事务处理的基础\nMULTI用来组装一个事务；\nEXEC用来执行一个事务；\nDISCARD用来取消一个事务；\nWATCH用来监视一些key，一旦这些key在事务执行之前被改变，则取消事务的执行。\n推荐本人的《Python 自动化运维实战》课程，提供在线实验环境，边敲代码边学习。\n\n                ", "mainLikeNum": ["42 "], "mainBookmarkNum": "35"}