{"title": " 【Leetcode】79.单词搜索 - LeetCode题解 ", "index": "python,java,数据结构,数据结构与算法,面试技巧", "content": "题目\n给定一个二维网格和一个单词，找出该单词是否存在于网格中。\n单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。\n示例:\nboard =[  ['A','B','C','E'],  ['S','F','C','S'],  ['A','D','E','E']]\n给定 word = \"ABCCED\", 返回 true.给定 word = \"SEE\", 返回 true.给定 word = \"ABCB\", 返回 false.\n题解\n这个题目拿到题目就应该能想到是用DFS的题目，因为这完完全全就是DFS，没有做任何的变形，关于DFS，这里就不重复讲解。\n推荐一个b站上的视频，不熟悉的同学可以回顾一下。\nhttps://www.bilibili.com/vide...\n熟悉的同学直接看代码吧\njava\nclass Solution {\n    public boolean exist(char[][] board, String word) {\n        if (word == null || word.length() == 0) {\n            return true;\n        }\n        char[] chs = word.toCharArray();\n        for (int i = 0; i < board.length; i++) {\n            for (int j = 0; j < board[0].length; j++) {\n                if (dfs(board, chs, 0, i, j)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private boolean dfs(char[][] board, char[] words, int index, int x, int y) {\n        if (index == words.length) {\n            return true;\n        }\n        if (x < 0 || x == board.length || y < 0 || y == board[0].length) {\n            return false;\n        }\n        if (board[x][y] != words[index]) {\n            return false;\n        }\n        char source = board[x][y];\n        board[x][y] = '\\0';\n        boolean exist = dfs(board, words, index + 1, x, y + 1)\n                || dfs(board, words, index + 1, x, y - 1)\n                || dfs(board, words, index + 1, x + 1, y)\n                || dfs(board, words, index + 1, x - 1, y);\n        board[x][y] = source;\n        return exist;\n    }\n}\npython\nclass Solution:\n    def dfs(self, board, word, index, x, y):\n        if not board or index == len(word):\n            return True\n        if x < 0 or x == len(board) or y < 0 or y == len(board[0]):\n            return False\n        if board[x][y] != word[index]:\n            return False\n        source = board[x][y]\n        board[x][y] = '\\0'\n        exist = self.dfs(board, word, index + 1, x, y + 1) or self.dfs(board, word, index + 1, x, y - 1) or self.dfs(\n            board, word, index + 1, x + 1, y) or self.dfs(board, word, index + 1, x - 1, y)\n        board[x][y] = source\n        return exist\n\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        if len(word) == 0:\n            return False\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if self.dfs(board, word, 0, i, j):\n                    return True\n        return False\n热门阅读\n\nMySQL索引背后的数据结构及算法原理\n【Leetcode】78. 子集\n【Leetcode】77. 组合\n\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}