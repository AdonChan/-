{"title": "Python - 装饰器使用过程中的误区 - OneAPM 官方技术专栏 ", "index": "python", "content": "装饰器基本概念\n\n大家都知道装饰器是一个很著名的设计模式，经常被用于 AOP (面向切面编程)的场景，较为经典的有插入日志，性能测试，事务处理，Web权限校验， Cache等。\n\nPython 语言本身提供了装饰器语法（@），典型的装饰器实现如下：\n\n    @function_wrapper\n    def function():\n       pass\n\n\n@实际上是 python2.4 才提出的语法糖，针对 python2.4 以前的版本有另一种等价的实现：\n\n    def function():\n        pass\n\n    function = function_wrapper(function)\n\n\n装饰器的两种实现\n\n函数包装器 - 经典实现\n\n    def function_wrapper(wrapped):\n        def _wrapper(*args, **kwargs):\n            return wrapped(*args, **kwargs)\n        return _wrapper \n\n    @function_wrapper\n    def function():\n        pass\n\n\n类包装器 - 易于理解\n\n    class function_wrapper(object):\n        def __init__(self, wrapped):\n            self.wrapped = wrapped\n        def __call__(self, *args, **kwargs):\n            return self.wrapped(*args, **kwargs)\n\n    @function_wrapper\n    def function():\n        pass\n\n\n函数（function）自省\n\n当我们谈到一个函数时，通常希望这个函数的属性像其文档上描述的那样，是被明确定义的，例如__name__ 和__doc__   。\n\n针对某个函数应用装饰器时，这个函数的属性就会发生变化，但这并不是我们所期望的。\n\n    def function_wrapper(wrapped):\n        def _wrapper(*args, **kwargs):\n            return wrapped(*args, **kwargs)\n        return _wrapper \n\n    @function_wrapper\n    def function():\n        pass \n\n    >>> print(function.__name__)\n    _wrapper\n\n\npython 标准库提供了functools.wraps()，来解决这个问题。\n\n    import functools \n\n    def function_wrapper(wrapped):\n        @functools.wraps(wrapped)\n        def _wrapper(*args, **kwargs):\n            return wrapped(*args, **kwargs)\n        return _wrapper \n\n    @function_wrapper\n    def function():\n        pass \n\n    >>> print(function.__name__)\n    function\n\n\n然而，当我们想要获取被包装函数的参数（argument）或源代码（source code）时，同样不能得到我们想要的结果。\n\n    import inspect \n\n    def function_wrapper(wrapped): ...\n\n    @function_wrapper\n    def function(arg1, arg2): pass \n\n    >>> print(inspect.getargspec(function))\n    ArgSpec(args=[], varargs='args', keywords='kwargs', defaults=None)\n\n    >>> print(inspect.getsource(function))\n        @functools.wraps(wrapped)\n        def _wrapper(*args, **kwargs):\n            return wrapped(*args, **kwargs)\n\n\n包装类方法（@classmethod）\n\n当包装器（@function_wrapper）被应用于@classmethod时，将会抛出如下异常：\n\n    class Class(object):\n        @function_wrapper\n        @classmethod\n        def cmethod(cls):\n            pass \n\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n      File \"<stdin>\", line 3, in Class\n      File \"<stdin>\", line 2, in wrapper\n      File \".../functools.py\", line 33, in update_wrapper\n        setattr(wrapper, attr, getattr(wrapped, attr))\n    AttributeError: 'classmethod' object has no attribute '__module__'\n\n\n因为@classmethod在实现时，缺少functools.update_wrapper需要的某些属性。这是functools.update_wrapper在 python2 中的 bug，3.2版本已被修复，参考 http://bugs.python.org/issue3445。\n\n然而，在 python3 下执行，另一个问题出现了：\n\n    class Class(object):\n        @function_wrapper\n        @classmethod\n        def cmethod(cls):\n            pass \n\n    >>> Class.cmethod() \n    Traceback (most recent call last):\n      File \"classmethod.py\", line 15, in <module>\n        Class.cmethod()\n      File \"classmethod.py\", line 6, in _wrapper\n        return wrapped(*args, **kwargs)\n    TypeError: 'classmethod' object is not callable\n\n\n这是因为包装器认定被包装的函数（@classmethod   ）是可以直接被调用的，但事实并不一定是这样的。被包装的函数实际上可能是描述符（descriptor ），意味着为了使其可调用，该函数（描述符）必须被正确地绑定到某个实例上。关于描述符的定义，可以参考 https://docs.python.org/2/howto/descriptor.html。\n\n总结 - 简单并不意味着正确\n\n尽管大家实现装饰器所用的方法通常都很简单，但这并不意味着它们一定是正确的并且始终能正常工作。\n\n如同上面我们所看到的，functools.wraps()  可以帮我们解决__name__   和__doc__     的问题，但对于获取函数的参数（argument）或源代码（    source code   ）则束手无策。\n\n以上问题，wrapt 都可以帮忙解决，详细用法可参考其官方文档：http://wrapt.readthedocs.org\n\n\n本文作者系OneAPM 工程师曾灵敏 ，想阅读更多好的技术文章，请访问 OneAPM 官方技术博客。\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "28"}