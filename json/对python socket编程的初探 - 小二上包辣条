{"title": "对python socket编程的初探 - 小二上包辣条 ", "index": "网络编程,socket,python", "content": "对于python网络编程来说，免不了要用到socket模块。下面分享一下个人对python socket的一些理解。\nsocket编程步骤\n\n服务端创建一个socket，绑定地址和端口，然后监听端口上传入的连接,一旦有连接进来，就通过accept函数接收传入的连接。\n客户端也是创建一个socket。绑定远程地址和端口，然后建立连接，发送数据。\n\n服务端socket\n下面通过一段实例代码来详细说明 服务端 socker_server.py\nimport socket\nimport sys\n\nHOST = \"127.0.0.1\"               \nPORT = 10000              \ns = None\nfor res in socket.getaddrinfo(HOST, PORT, socket.AF_UNSPEC,\n                              socket.SOCK_STREAM, 0, socket.AI_PASSIVE):\n    af, socktype, proto, canonname, sa = res\n    try:\n        s = socket.socket(af, socktype, proto)\n    except socket.error as msg:\n        s = None\n        continue\n    try:\n        s.bind(sa)\n        s.listen(5)\n    except socket.error as msg:\n        s.close()\n        s = None\n        continue\n    break\nif s is None:\n    print 'could not open socket'\n    sys.exit(1)\nconn, addr = s.accept()\nprint 'Connected by', addr\nwhile 1:\n    data = conn.recv(1024)\n    if not data: break\n    conn.send(data)\nconn.close()\n\n首先我们通过socket.getaddrinnfo函数将host/port转换成一个包含5元组的序列。这个5元组包含我们创建一个socket连接所需要的所有必要参数。返回的5元组分别是 (family, sockettype, proto, canonname, sockaddr)\nfamily 地址簇，用与socket()函数的第一个参数。主要有以下几个\nsocket.AF_UNIX 用与单一机器下的进程通信socket.AF_INET 用与服务器之间相互通信，通常都用这个。socket.AF_INET6 支持IPv6sockettype socket类型，用与socket()函数的第二个参数，常用的有\nsocket.SOCK_STREAM 默认，用于TCP协议socket.SOCK_DGRAM 用于UDP协议proto 协议，用于socket()函数的第三个参数。 getaddrinnfo函数会根据地址格式和socket类型,返回合适的协议\ncanonname 一个规范化的host name。\nsockaddr 描述了一个socket address .是一个二元组,主要用于bind()和connect()函数\n接下来创建一个socket对象，传入getaddrinnfo函数返回的af,sockettype,proto。\n s = socket.socket(af, socktype, proto)\n\n然后绑定我的socket address\ns.bind(sa)\n\n开启监听模式\ns.listen(5)\n\nlisten函数会监听连接到socket上的连接，参数表示在拒绝连接之前系统可以挂起的最大连接队列数量为5。这些连接还没有被accept处理。数量不能无限大，通常指定5。\n一旦我们监听到了连接，就会调用accept函数接收连接\nconn, addr = s.accept()\n\naccept函数返回一个二元组，conn是一个新的socket对象，用来接收和发送数据。addr表示另一端的socket地址。\n接下来我们就可以用conn对象发送和接收数据了\n data = conn.recv(1024) # 接收数据, 这里指定一次最多接收的字符数量为1024\n conn.send(data) # 发送数据\n\n这里我们接收到一个连接socket就会停止运行，所以如果要循环连接的话，将accept函数放入到一个死循环里。\n客户端socket\n客户端socket编程相对比较简单，通过connect和服务端建立连接之后，就可以相互通信了。socket_client.py如下\nfor res in socket.getaddrinfo(HOST, PORT, socket.AF_UNSPEC, socket.SOCK_STREAM):\n    af, socktype, proto, canonname, sa = res\n    try:\n        s = socket.socket(af, socktype, proto)\n    except socket.error as msg:\n        s = None\n        continue\n    try:\n        s.connect(sa)\n    except socket.error as msg:\n        s.close()\n        s = None\n        continue\n    break\nif s is None:\n    print 'could not open socket'\n    sys.exit(1)\ns.sendall('Hello, world')\ndata = s.recv(1024)\ns.close()\nprint 'Received', repr(data)\n\n备注： 对于getaddrinfo函数，可以参考下http://baike.baidu.com/link?u... 这个函数的作用是把协议相关性安全隐藏在这个底层库函数内部。应用程序只要处理由getaddrinfo函数返回的数据即可。\n以上主要是针对TCP流数据的socket编程。对于UDP协议的数据，处理略有不同。譬如发送接收UDP数据包处理函数为:\nsocket.sendto(string, flags, address)\nsocket.recvfrom(bufsize[, flags]) #返回(string, address)，string是返回的数据，address是发送方的socket地址\n\n其他详细内容可以参考 http://python.usyiyi.cn/trans...\nSocketServer模块\npython中网络编程除了socket模块还提供了SocketServer模块，这一模块主要是对socket模块进行了封装，将socket的对象的创建，绑定，连接，接收，发送，关闭都封装在里面，大大简化了网络服务的编程。\n此模块提供了以下2个主要的网络服务类，用于创建相应的套接字流\n\nTCPServer 创建TCP协议的套接字流\nUDPServer 创建UDP协议的套接字流\n\n我们有了套接字流对象，还需要一个请求处理类。SocketServer模块提供了请求处理类有BaseRequestHandler，以及它的派生类StreamRequestHandler和DatagramRequestHandler。所以只要继承这3个类中的一个，然后重写handle函数，此函数将用来处理接收到的请求。下面看一个服务端的代码示例\nimport SocketServer\n\nclass MyTCPHandler(SocketServer.StreamRequestHandler):\n   \"\"\"创建请求处理类，重写handle方法。此外也可以重写setup()和finish()来做一些请求处理前和处理后的一些工作\"\"\"\n    def handle(self):\n        # self.request is the TCP socket connected to the client\n        self.data = self.request.recv(1024).strip()\n        print \"{} wrote:\".format(self.client_address[0])\n        print self.data\n        # just send back the same data, but upper-cased\n        self.request.sendall(self.data.upper())\n\nif __name__ == \"__main__\":\n    HOST, PORT = \"localhost\", 10000\n\n    server = SocketServer.TCPServer((HOST, PORT), MyTCPHandler)\n\n    # Activate the server; this will keep running until you\n    # interrupt the program with Ctrl-C\n    # server.shutdown()\n    server.serve_forever()  # 一直循环接收请求\n    # server.handle_request() # 只处理一次请求就退出\n\n看着是不是代码简单了很多，而且SocketServer模块内部使用了多路复用IO技术，可以实现更好的连接性能。看serve_forever函数的源代码用到了select模块。通过传入socket对象调用select.select()来监听socket对象的文件描述符，一旦发现socket对象就绪，就通知应用程序进行相应的读写操作。源代码如下：\ndef serve_forever(self, poll_interval=0.5):\n        \"\"\"Handle one request at a time until shutdown.\n\n        Polls for shutdown every poll_interval seconds. Ignores\n        self.timeout. If you need to do periodic tasks, do them in\n        another thread.\n        \"\"\"\n        self.__is_shut_down.clear()\n        try:\n            while not self.__shutdown_request:\n                # XXX: Consider using another file descriptor or\n                # connecting to the socket to wake this up instead of\n                # polling. Polling reduces our responsiveness to a\n                # shutdown request and wastes cpu at all other times.\n                r, w, e = _eintr_retry(select.select, [self], [], [],\n                                       poll_interval)\n                if self in r:\n                    self._handle_request_noblock()\n        finally:\n            self.__shutdown_request = False\n            self.__is_shut_down.set()\n\n即使使用了select技术，TCPServer，UDPServer处理请求仍然是同步的，意味着一个请求处理完，才能处理下一个请求。但SocketServer模块提供了另外2个类用来支持异步的模式。\n\nForkingMixIn 利用多进程实现异步\nThreadingMixIn 利用多线程实现异步\n\n看名字就知道使用了mixin模式。而mixin模式可以通过多继承来实现，所以通过对网络服务类进行多继承的方式就可以实现异步模式\nclass ThreadedTCPServer(SocketServer.ThreadingMixIn, SocketServer.TCPServer):\n    pass\n\n针对ThreadindMixIn,实现异步的原理也就是在内部对每个请求创建一个线程来处理。看源码\ndef process_request(self, request, client_address):\n        \"\"\"Start a new thread to process the request.\"\"\"\n        t = threading.Thread(target = self.process_request_thread,\n                             args = (request, client_address))\n        t.daemon = self.daemon_threads\n        t.start()\n\n下面提供一个异步模式的示例\nimport socket\nimport threading\nimport SocketServer\n\nclass ThreadedTCPRequestHandler(SocketServer.BaseRequestHandler):\n\n    def handle(self):\n        data = self.request.recv(1024)\n        cur_thread = threading.current_thread()\n        response = \"{}: {}\".format(cur_thread.name, data)\n        self.request.sendall(response)\n\nclass ThreadedTCPServer(SocketServer.ThreadingMixIn, SocketServer.TCPServer):\n    pass\n\ndef client(ip, port, message):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((ip, port))\n    try:\n        sock.sendall(message)\n        response = sock.recv(1024)\n        print \"Received: {}\".format(response)\n    finally:\n        sock.close()\n\nif __name__ == \"__main__\":\n    # Port 0 means to select an arbitrary unused port\n    HOST, PORT = \"localhost\", 0\n\n    server = ThreadedTCPServer((HOST, PORT), ThreadedTCPRequestHandler)\n    ip, port = server.server_address\n\n    # Start a thread with the server -- that thread will then start one\n    # more thread for each request\n    server_thread = threading.Thread(target=server.serve_forever)\n    # Exit the server thread when the main thread terminates\n    server_thread.daemon = True\n    server_thread.start()\n    print \"Server loop running in thread:\", server_thread.name\n\n    client(ip, port, \"Hello World 1\")\n    client(ip, port, \"Hello World 2\")\n    client(ip, port, \"Hello World 3\")\n\n    server.shutdown()\n    server.server_close()\n\n更多对SocketServer模块的了解参考https://docs.python.org/2/lib... 本文所使用的示例就来自官网。毕竟官网的例子实在太好了。\n以上是本人对socket相关的理解，有什么不当或错误之处，还请指出。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "4"}