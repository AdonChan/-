{"title": "Pandas学习笔记（一） - Dereen的学习笔记 ", "index": "python", "content": "\npandas is an open source, BSD-licensed library providing high-performance, easy-to-use data structures and data analysis tools for the Python programming language.这段话是pandas官方网站对于Pandas的介绍，翻译过来就是：pandas是一个开源的，BSD许可的库，为Python编程语言提供高性能，易于使用的数据结构和数据分析工具。\n\nSeries一维数组\n创建一个pandas一维数组\npandas.Series()创建的是带有标签的一维数组。例如：\nIn [1]: import numpy as np\n\nIn [2]: import string\n\nIn [3]: import pandas as pd\n# 第一种创建方法，传入两个列表\nIn [4]: pd.Series([1, 2, 3, 4, 5, 6], index =list(\"abcdef\"))\nOut[4]:\na    1\nb    2\nc    3\nd    4\ne    5\nf    6\ndtype: int64\n# 第二种创建方法，传入一个字典\nIn [5]: temp_dict = {\"name\":\"xiaohong\", \"age\":\"13\", \"address\":\"binxian\"}\n\nIn [6]: pd.Series(temp_dict)\nOut[6]:\nname       xiaohong\nage              13\naddress     binxian\ndtype: object\n# 第三种创建方法，利用string.ascii_uppercase生成一个字典，再传入生成一个带标签数组\nIn [7]: a = {string.ascii_uppercase[i]:i for i in range(10)}\n\nIn [8]: a\nOut[8]:\n{'A': 0,\n 'B': 1,\n 'C': 2,\n 'D': 3,\n 'E': 4,\n 'F': 5,\n 'G': 6,\n 'H': 7,\n 'I': 8,\n 'J': 9}\n\nIn [9]: pd.Series(a)\nOut[9]:\nA    0\nB    1\nC    2\nD    3\nE    4\nF    5\nG    6\nH    7\nI    8\nJ    9\ndtype: int64\n# 当有标签的地方没有值时，该位置的元素值就被置为NaN\nIn [10]: pd.Series(a, index=list(string.ascii_uppercase[5:15]))\nOut[10]:\nF    5.0\nG    6.0\nH    7.0\nI    8.0\nJ    9.0\nK    NaN\nL    NaN\nM    NaN\nN    NaN\nO    NaN\ndtype: float64\n\npandas数组元素类型修改\n要修改pandas数组中元素的类型与numpy中是一样的：\nIn [11]: pd.Series(a).astype(\"float64\")\nOut[11]:\nA    0.0\nB    1.0\nC    2.0\nD    3.0\nE    4.0\nF    5.0\nG    6.0\nH    7.0\nI    8.0\nJ    9.0\ndtype: float64\n\n取一维数组的值或标签\n这个操作大体也与numpy中相应的操作相同：\nIn [16]: a = pd.Series(a)\n\nIn [17]: a\nOut[17]:\nA    0\nB    1\nC    2\nD    3\nE    4\nF    5\nG    6\nH    7\nI    8\nJ    9\ndtype: int64\n\nIn [18]: a[0:7]\nOut[18]:\nA    0\nB    1\nC    2\nD    3\nE    4\nF    5\nG    6\ndtype: int64\n\nIn [19]: a[[1,3,4]]\nOut[19]:\nB    1\nD    3\nE    4\ndtype: int64\n\nIn [20]: a[[\"A\",\"E\",\"G\"]]\nOut[20]:\nA    0\nE    4\nG    6\ndtype: int64\n\nIn [21]: a[a>4]\nOut[21]:\nF    5\nG    6\nH    7\nI    8\nJ    9\ndtype: int64\n\npandas一维数组的组成\nIn [22]: a.index\nOut[22]: Index(['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'], dtype='object\n')\n\nIn [23]: a.values\nOut[23]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], dtype=int64)\n\nIn [24]: type(a.index)\nOut[24]: pandas.core.indexes.base.Index\n\nIn [25]: type(a.values)\nOut[25]: numpy.ndarray\n\n由上面的代码可以看出，pandas Series一维数组实际上是由一个numpy一维数组和类型为pandas.core.indexes.base.Index的一维数组拼成的。\nDataFrame多维数组\n创建DataFrame多维数组\n# 要创建一个DataFrame数组，我们只需给pd.DataFrame（）中传入一个数组即可\nIn [1]: import pandas as pd\n\nIn [2]: import numpy as np\n\nIn [3]: pd.DataFrame(np.arange(0, 12).reshape(3, 4))\nOut[3]: \n   0  1   2   3\n0  0  1   2   3\n1  4  5   6   7\n2  8  9  10  11\n# 既然DataFrame是带标签的数组，那我们如何定义它的标签？看下面的代码：\nIn [6]:  a = pd.DataFrame(np.arange(12).reshape(3,4),index=list(\"abc\"),columns=\n   ...: list(\"defg\"))\n# 从结果可以看出：index插入的是行标签，columns插入的是列标签\nIn [7]: a\nOut[7]:\n   d  e   f   g\na  0  1   2   3\nb  4  5   6   7\nc  8  9  10  11\n# 除了传入数组，我们也可以传入字典作为参数，来创建一个DataFrame数组\n\nIn [9]: d1 = {\"name\":[\"chenpi\",\"dufu\"],\"age\":[1,3],\"color\":[\"orange\",\"white\"]}\n\nIn [10]: pd.DataFrame(d1)\nOut[10]:\n     name  age   color\n0  chenpi    1  orange\n1    dufu    3   white\n\n查看多维数组的参数\nIn [13]: d2 = pd.DataFrame(d1)\n\nIn [14]: d2\nOut[14]: \n     name  age   color\n0  chenpi    1  orange\n1    dufu    3   white\n# 查看行索引\nIn [15]: d2.index\nOut[15]: RangeIndex(start=0, stop=2, step=1)\n# 查看列索引\nIn [16]: d2.columns\nOut[16]: Index(['name', 'age', 'color'], dtype='object')\n# 查看值，可以看到DataFrame数组的值其实就是一个numpy同维数组\nIn [17]: d2.values\nOut[17]: \narray([['chenpi', 1, 'orange'],\n       ['dufu', 3, 'white']], dtype=object)\n# 查看形状\nIn [18]: d2.shape\nOut[18]: (2, 3)\n# 查看类型\nIn [19]: d2.dtypes\nOut[19]: \nname     object\nage       int64\ncolor    object\ndtype: object\n# 查看维度\nIn [20]: d2.ndim\nOut[20]: 2\n\n数组切片\n使用head()、tail()方法取头或尾连续多行\n# 取第一行\nIn [42]: d2.head(1)\nOut[42]: \n     name  age   color\n1  chenpi    1  orange\n# 取前二行\nIn [43]: d2.head(2)\nOut[43]: \n     name  age   color\n1  chenpi    1  orange\n2    dufu    3   white\n# 如果不给head()指定参数则默认取前5行，这里因为整个数组只有2行\nIn [45]: d2.head()\nOut[45]: \n     name  age   color\n1  chenpi    1  orange\n2    dufu    3   white\n# 用tail()方法从后往前取行\nIn [46]: d2.tail(1)\nOut[46]: \n   name  age  color\n2  dufu    3  white\n# 如果不想要索引可以这样取（values后面的参数同numpy中相同）\nIn [49]: d2.values[1]\nOut[49]: array(['dufu', 3, 'white'], dtype=object)\n\n利用列表的切片功能\n# 先建立一个数组如下\nIn [71]: t1 = pd.DataFrame(np.arange(100).reshape(10, 10), index=list(\"ABCDEFGHI\n    ...: J\"), columns=list(\"KLMNOPQRST\"))\nIn [72]: t1\nOut[72]: \n    K   L   M   N   O   P   Q   R   S   T\nA   0   1   2   3   4   5   6   7   8   9\nB  10  11  12  13  14  15  16  17  18  19\nC  20  21  22  23  24  25  26  27  28  29\nD  30  31  32  33  34  35  36  37  38  39\nE  40  41  42  43  44  45  46  47  48  49\nF  50  51  52  53  54  55  56  57  58  59\nG  60  61  62  63  64  65  66  67  68  69\nH  70  71  72  73  74  75  76  77  78  79\nI  80  81  82  83  84  85  86  87  88  89\nJ  90  91  92  93  94  95  96  97  98  99\n# 取前5行\nIn [73]: t1[:5]\nOut[73]: \n    K   L   M   N   O   P   Q   R   S   T\nA   0   1   2   3   4   5   6   7   8   9\nB  10  11  12  13  14  15  16  17  18  19\nC  20  21  22  23  24  25  26  27  28  29\nD  30  31  32  33  34  35  36  37  38  39\nE  40  41  42  43  44  45  46  47  48  49\n# 取前5行“Q”列\nIn [74]: t1[:5][\"Q\"]\nOut[74]: \nA     6\nB    16\nC    26\nD    36\nE    46\nName: Q, dtype: int64\n# 取“Q”列数据\nIn [79]: t1[\"Q\"]\nOut[79]: \nA     6\nB    16\nC    26\nD    36\nE    46\nF    56\nG    66\nH    76\nI    86\nJ    96\nName: Q, dtype: int64\n# 单列数组的类型是Series一维数组\nIn [80]: type(t1[\"Q\"])\nOut[80]: pandas.core.series.Series\n\nloc()函数切片\n\ndf.loc()通过标签索引行数据\n# 使用loc函数进行切片与numpy中切片的方式是相同的\nIn [86]: t1.loc[\"D\", \"K\"]\nOut[86]: 30\n# 取“C”行\nIn [87]: t1.loc[\"C\", :]\nOut[87]: \nK    20\nL    21\nM    22\nN    23\nO    24\nP    25\nQ    26\nR    27\nS    28\nT    29\nName: C, dtype: int64\n# 取“O”列\nIn [88]: t1.loc[:, \"O\"]\nOut[88]: \nA     4\nB    14\nC    24\nD    34\nE    44\nF    54\nG    64\nH    74\nI    84\nJ    94\nName: O, dtype: int64\n# 取多行多列\nIn [89]: t1.loc[[\"D\", \"H\"], [\"O\", \"Q\"]]\nOut[89]: \n    O   Q\nD  34  36\nH  74  76\n# 取“A”到“J”行，（这里需要注意的是，与一般的切片不同，这里的“J”是可以取到的）\nIn [90]: t1.loc[\"A\":\"J\"]\nOut[90]: \n    K   L   M   N   O   P   Q   R   S   T\nA   0   1   2   3   4   5   6   7   8   9\nB  10  11  12  13  14  15  16  17  18  19\nC  20  21  22  23  24  25  26  27  28  29\nD  30  31  32  33  34  35  36  37  38  39\nE  40  41  42  43  44  45  46  47  48  49\nF  50  51  52  53  54  55  56  57  58  59\nG  60  61  62  63  64  65  66  67  68  69\nH  70  71  72  73  74  75  76  77  78  79\nI  80  81  82  83  84  85  86  87  88  89\nJ  90  91  92  93  94  95  96  97  98  99\n\n\ndf.iloc()通过位置索引行数据\n# 使用iloc进行切片与numpy中完全相同\nIn [91]: t1.iloc[[1, 3, 5], [2, 4, 6]]\nOut[91]: \n    M   O   Q\nB  12  14  16\nD  32  34  36\nF  52  54  56\n# 0：10依然包含第10列\nIn [94]: t1.iloc[0:10]\nOut[94]: \n    K   L   M   N   O   P   Q   R   S   T\nA   0   1   2   3   4   5   6   7   8   9\nB  10  11  12  13  14  15  16  17  18  19\nC  20  21  22  23  24  25  26  27  28  29\nD  30  31  32  33  34  35  36  37  38  39\nE  40  41  42  43  44  45  46  47  48  49\nF  50  51  52  53  54  55  56  57  58  59\nG  60  61  62  63  64  65  66  67  68  69\nH  70  71  72  73  74  75  76  77  78  79\nI  80  81  82  83  84  85  86  87  88  89\nJ  90  91  92  93  94  95  96  97  98  99\n\npandas之NaN\nIn [128]: t2 = t1.iloc[:4,:4]\n\nIn [129]: t2\nOut[129]: \n    K   L   M   N\nA   0   1   2   3\nB  10   11  12  13\nC  20   21  22  23\nD  30   31  32  33\n\n# 我们可以发现与在numpy中不同的是，在pandas中我们要将一个整型元素变为NaN，不需要在预先对其进行类型转换，pandas会帮我们将这一列的数据自动转换为float类型\nIn [130]: t2.iloc[1, 1] = np.nan\nIn [131]: t2\nOut[131]: \n    K     L   M   N\nA   0   1.0   2   3\nB  10   NaN  12  13\nC  20  21.0  22  23\nD  30  31.0  32  33\n# 使用isnull可以判别该位置的值是否是NaN\nIn [132]: pd.isnull(t2)\nOut[132]: \n       K      L      M      N\nA  False  False  False  False\nB  False   True  False  False\nC  False  False  False  False\nD  False  False  False  False\n# notnull则是反效果\nIn [133]: pd.notnull(t2)\nOut[133]: \n      K      L     M     N\nA  True   True  True  True\nB  True  False  True  True\nC  True   True  True  True\nD  True   True  True  True\n# 选择L列中不为NaN的行\nIn [10]: t2[pd.notnull(t2[\"L\"])]\nOut[10]: \n    K     L   M   N\nA   0   1.0   2   3\nC  20  21.0  22  23\nD  30  31.0  32  33\n# 我们可以使用dropna方法来删除包含NaN的行或列\nIn [11]: t2.dropna(axis=0)\nOut[11]: \n    K     L   M   N\nA   0   1.0   2   3\nC  20  21.0  22  23\nD  30  31.0  32  33\n# 添加参数how=\"all\"可以指定删除全为NaN的行\nIn [12]: t2.dropna(axis=0, how=\"all\")\nOut[12]: \n    K     L   M   N\nA   0   1.0   2   3\nB  10   NaN  12  13\nC  20  21.0  22  23\nD  30  31.0  32  33\n# 此外，我们可以使用参数inplace=True来进行原地操作，改变t2的值\nIn [13]: t2.dropna(axis=0, inplace=True)\n\nIn [14]: t2\nOut[14]: \n    K     L   M   N\nA   0   1.0   2   3\nC  20  21.0  22  23\nD  30  31.0  32  33\n# 我们可以使用fill.na来对值为NaN的位置进行重新赋值\nIn [18]: t2.fillna(0)\nOut[18]: \n    K     L     M   N\nA   0   0.0   0.0   3\nC  20  21.0  22.0  23\nD  30   0.0   0.0  33\n# 这里可以看出这个操作是有返回值的非原地操作，如果需要原地操作，需要加参数inplace=True\nIn [19]: t2\nOut[19]: \n    K     L     M   N\nA   0   NaN   NaN   3\nC  20  21.0  22.0  23\nD  30   NaN   NaN  33\n# 当然，我们还可以填充每列的最大最小值、均值等等\nIn [20]: t2.fillna(t2.mean())\nOut[20]: \n    K     L     M   N\nA   0  21.0  22.0   3\nC  20  21.0  22.0  23\nD  30  21.0  22.0  33\nIn [21]: t2\nOut[21]: \n    K     L     M   N\nA   0   NaN   NaN   3\nC  20  21.0  22.0  23\nD  30   NaN   NaN  33\n# 这里有个和numpy不同的地方：pandas在计算均值时遇到NaN会自动忽略，而不是将NaN作为计算结果\nIn [22]: t2.mean()\nOut[22]: \nK    16.666667\nL    21.000000\nM    22.000000\nN    19.666667\ndtype: float64\n\n布尔索引\n# 在狗的名字和使用次数统计的数组中进行布尔索引\nIn [95]: df = pd.read_csv(\"~/桌面/dogNames2.csv\")\nIn [97]: df = df.sort_values(by=\"Count_AnimalName\", ascending=False)\n# 取使用次数大于800并且小于1000次的行\nIn [99]: df[(800<df[\"Count_AnimalName\"])&(df[\"Count_AnimalNam\n    ...: e\"]<1000)]\nOut[99]: \n      Row_Labels  Count_AnimalName\n2660     CHARLIE               856\n3251        COCO               852\n12368      ROCKY               823\n# 取使用次数大于800或者小于1次的行\nIn [100]: df[(800<df[\"Count_AnimalName\"])|(df[\"Count_AnimalNa\n     ...: me\"]<1)]\nOut[100]: \n      Row_Labels  Count_AnimalName\n1156       BELLA              1195\n9140         MAX              1153\n2660     CHARLIE               856\n3251        COCO               852\n12368      ROCKY               823\npandas读外部数据\n读取CSV文件\n我们可以使用pandas.read_后接文件类型如pandas.read_csv来读取csv文件。\nimport pandas as pd\n# 读取当前目录下的dogNames2文件\ndf = pd.read_csv(\"./dogNames2.csv\")\nprint(df)\n读取数据库文件\n对于数据库文件，该如何读取呢？\n# 读关系数据库\npd.read_sql(sql_sentence.connection)\n对于非关系数据库如mongodb：\nfrom pymongo import MongoClient\nimport pandas as pd\n# 读取douban数据库中tv1数据\nclient = MongoClient()\ncollection = client[\"douban\"][\"tv1\"]\ndata = list(collection.find())\n# 要是想取第一行的数据，可以使用如下语句\nt1 = data[0]\nt1 = pd.Series(t1)\nprint(t1)\n# 使用DataFrame读取\ndf = pd.DataFrame(data)\nprint(df)\n# 结果是一个[2379 rows x 26 columns]的数组\n\n# 如果要取特定的列\n# 我们先取一行，打印一下看我们需要哪些信息\nfor i in data:\n    print(i)\n    break\n# 打印结果如下：\n> {'_id': ObjectId('59ba7f9b421aa91b08a43faa'), 'info': '王伟/潘粤明/王泷正/梁缘/剧情/犯罪/悬疑/2017-08-30(中国大陆)', 'original_price': None, 'release_date': '08.30', 'rating': {'count': 23043, 'max': 10, 'value': 9}, 'description': '', 'title': '白夜追凶', 'url': 'https://m.douban.com/movie/subject/26883064/', 'price': None, 'cover': {'url': 'https://qnmob2.doubanio.com/view/movie_poster_cover/lpst/public/p2483150767.jpg?imageView2/0/q/80/w/9999/h/400/format/jpg', 'width': 1200, 'shape': 'rectangle', 'height': 2134}, 'uri': 'douban://douban.com/tv/26883064', 'actions': ['可播放'], 'label': None, 'subtype': '', 'directors': ['王伟'], 'actors': ['潘粤明', '王泷正', '梁缘'], 'date': None, 'reviewer_name': '', 'forum_info': {'id': 'tv/26883064', 'participant_count': 4536, 'uri': 'douban://douban.com/tv/26883064/forum_topics'}, 'type': 'tv', 'id': '26883064', 'tv_category': 'chinese', 'tv_url_parameter': 'filter_tv_domestic_hot', 'total_num': None, 'parse_url': 'https://m.douban.com/rexxar/api/v2/subject_collection/filter_tv_domestic_hot/items?os=ios&for_mobile=1&start=0&count=50&_=0', 'total': 2123}\n# 使用如下语句取特定列\nfor i in data:\n    temp = {}\n    temp[\"info\"] = i[\"info\"]\n    temp[\"rating_count\"] = i[\"rating\"][\"count\"]\n    temp[\"rating_value\"] = i[\"rating\"][\"value\"]\n    temp[\"title\"] = i[\"title\"]\n    temp[\"country\"] = i[\"tv_category\"]\n    temp[\"actors\"] = i[\"actors\"]\n    temp[\"directors\"] = i[\"directors\"]\n    data_list.append(temp)\ndf = pd.DataFrame(data_list)\ndf.to_csv(\"./douban.csv\")\n# 这样就将以上的列提取了出来并储存在了当前文件夹的csv文件里\n结果如下：\n\n此外，我们还可以借助describe()函数帮助我们统计常用的数值\nprint(df.describe())\n# 结果如下：\n        rating_count  rating_value\ncount    2379.000000   2379.000000\nmean     9079.419084      7.722783\nstd     16613.297194      1.068567\nmin       211.000000      2.800000\n25%       807.000000      7.100000\n50%      2573.000000      7.800000\n75%      9256.000000      8.500000\nmax    170243.000000      9.800000\n数组行排序\nsort_values()函数可以帮我们对数组进行行排序：以上面的df数组为例，假如我们要找出评分最高的电视剧\n# by=\"rating_value\"参数表示我们根据评分值进行排序，ascending=False表示逆序\ndf = df.sort_values(by=\"rating_value\", ascending=False)\nprint(df.head(1))\n# 结果是探险活宝第八季 9.8分\n字符串方法\n\n\n方法\n说明\n\n\n\ncat\n实现元素级字符串连接操作，可指定分隔符\n\n\ncontains\n返回表示各字符串是否含有指定模式的布尔型数组\n\n\ncount\n模式的出现次数\n\n\nendswith、startswith\n相当于对各个元素执行x.endswith(pattern)或x.startswith(pattern)\n\n\nfindall\n计算各字符串的模式列表\n\n\nget\n获取各元素的第i个字符\n\n\njoin\n根据指定的分隔符将Series中各元素的字符串连接起来\n\n\nlen\n计算各字符串的长度\n\n\nlower、upper\n转换大小写。相当于对各个元素执行x.lower()或x.upper()\n\n\nmatch\n根据指定的正则表达式对各个元素执行re.match\n\n\npad\n在字符串的左边、右边或左右两边添加空白符\n\n\ncenter\n相当于pad(side='both')\n\n\nrepeat\n重复值。例如，s.str.repeat(3)相当于对各个字符串执行x*3\n\n\nreplace\n用指定字符串替换找到的模式\n\n\nslice\n对Series中的各个字符串进行子串截取\n\n\nsplit\n根据分隔符或正则表达式对字符串进行拆分\n\n\nstrip、rstrip、lstrip\n去除空白符，包含换行符。\n\n\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}