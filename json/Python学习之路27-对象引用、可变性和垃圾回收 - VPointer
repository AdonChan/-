{"title": "Python学习之路27-对象引用、可变性和垃圾回收 - VPointer ", "index": "python,对象,引用,垃圾回收机制", "content": "《流畅的Python》笔记本篇是“面向对象惯用方法”的第一篇，一共六篇。本篇主要是一些概念性的讨论，内容有：Python中的变量，对象标识，值，别名，元组的某些特性，深浅复制，引用，函数参数，垃圾回收，del命令，弱引用等，比较枯燥，但却能解决程序中不易察觉的bug。\n\n1. 变量、标识、相等性和别名\n先用一个形象的比喻来说明Python中的变量：变量是标注而不是盒子。也就是说，Python中的变量更像C++中的引用，最能说明这一点的就是多个变量指向同一个列表，但也有例外，在遇到某些内置类型，比如字符串str时，变量则变成了“盒子”：\n# 代码1\n>>> a = [1, 2]  \n>>> b = a  # 标注，引用\n>>> a.append(3)\n>>> b\n[1, 2, 3]\n>>> c = \"c\"  \n>>> d = c  # “盒子”\n>>> c = \"cc\"\n>>> d\n'c'\n补充：说到了赋值方式，Python和C++一样，也是等号右边先执行。\n1.1 相等性( == )与标识( is )\n用一个更学术的词来替换“标注”，那就是“别名”。在C++中，引用就是变量的别名，Python中也是，比如代码1中的变量b就是变量a的别名，但如果是以下形式，变量b则不是a的别名：\n# 代码2\n>>> a = [1, 2]\n>>> b = [1, 2]\n>>> a == b   # a和b的值相等\nTrue\n>>> a is b   # a和b分别绑定了不同的对象，虽然对象的值相等 \nFalse\n==检测对象的值是否相等，is运算符检测对象的标识（ID）是否相等，id()返回对象标识的整数表示。一般判断两对象的标识是否相等并不直接使用id()，更多的是使用is运算符。\n对象ID在不同的实现中有所不同：在CPython中，id()返回对象的内存地址，但在其他Python解释器中可能是别的值。但不管怎么，对象的ID一定唯一，且在生命周期中保持不变。\n通常我们关心的是值，而不是标识，所以==出现的频率比is高。但在变量和单例值之间比较时，应该使用is。目前，最常使用is检测变量绑定的值是不是None，推荐的写法是：\n# 代码3\nx is None  # 并非 x == None\nx is not None  # 并非 x != None\nis运算符比==速度快，因为它不能重载，所以Python不用寻找并调用特殊方法，而是直接比较两个对象的ID。a == b其实是语法糖，实际调用a.__eq__(b)。虽然继承自object的__eq__方法也是比较对象的ID，结果和is一样，但大多数内置类型覆盖了该方法，处理过程更复杂，这就是为什么is比==快。\n1.2 元组的相对不可变性\n元组和大多数Python集合一样，保存的是对象的引用。元组的不可变性其实是指tuple数据结构的物理内容（即保存的引用）不可变，与引用的对象无关。如果引用的对象可变，即便元组本身不可变，元素依然可变，不变的是元素的标识：\n# 代码4\n>>> t1 = (1, 2, [30, 40])\n>>> t2 = (1, 2, [30, 40])\n>>> t1 == t2\nTrue\n>>> id(t1[-1])\n2019589413704\n>>> t1[-1].append(99)\n>>> t1\n(1, 2, [30, 40, 99])\n>>> id(t1[-1])  # 内容变了，标识没有变\n2019589413704\n>>> t1 == t2\nFalse\n这同时也说明，并不是每个元组都是可散列的！\n2.深浅复制\n复制对象时，相等性和标识之间的区别有更深入的影响。副本与源对象相等，但ID不同。而如果对象内部还有其他对象，这就涉及到了深浅复制的问题：到底是复制内部对象呢还是共享内部对象？\n2.1 默认做浅复制\n对列表和其他可变序列来说，我们可以使用构造方法或[:]来创建副本。然而，这两种方法做的都是浅复制，它们只复制了最外层的容器，副本中的元素是源容器中元素的引用。如果所有元素都是不可变的，那这样做没问题，还能节省内存；但如果其中有可变元素，这么做就可能出问题：\n# 代码5\nl1 = [3, [11, 22], (7, 8)]\nl2 = list(l1)      # <1>\nl1.append(100)\nl1[1].remove(22)\nprint(\"l1:\", l1, \"\\nl2:\", l2)\nl2[1] += [33, 44]  # <2>\nl2[2] += (10, 11)  # <3>\nprint(\"l1:\", l1, \"\\nl2:\", l2)\n\n# 结果\nl1: [3, [11], (7, 8), 100]  # 追加元素只影响了l1\nl2: [3, [11], (7, 8)]       # 但删除l1[1]中的元素影响了两个列表\nl1: [3, [11, 33, 44], (7, 8), 100]     # +=对可变对象是就地操作，影响了两个列表\nl2: [3, [11, 33, 44], (7, 8, 10, 11)]  # +=对不可变对象会创建新对象，只影响了l2\n以上代码有3点需要解释：\n\n<1>：l1[1]和l2[1]指向同一列表，l1[2]和l2[2]指向同一元组。因为是浅复制，只是复制引用；\n<2>：+=运算对可变对象来说是就地运算，不会创建新对象，所以对两个列表都有影响；\n<3>：+=运算对元组这样的不可变对象来说，等同于l2[2] = l2[2] + (10, 11)，此操作隐式地创建了新对象，l2[2]重新绑定到了新对象，所以只有列表l2[2]发生了改变，而l1[2]没有改变。\n\n2.2 为任意对象做深复制和浅复制\n浅复制并非是一种错误，只是一种选择。而有时我们需要的是深复制，即副本不共享内部对象的引用。copy模块提供的deepcopy和copy函数能为任意对象做深复制和浅复制。\n# 代码6\nimport copy\n\nl1 = [3, [11, 22]]\nl2 = copy.copy(l1)      # 浅复制\nl3 = copy.deepcopy(l1)  # 深复制\nl1[1].append(33)    # 影响了l2，但没有影响l3\nprint(\"l1:\", l1, \"\\nl2:\", l2, \"\\nl3:\", l3)\n\n# 结果\nl1: [3, [11, 22, 33]] \nl2: [3, [11, 22, 33]] \nl3: [3, [11, 22]]\n在做深复制时，如果对象之间有循环引用，朴素的深复制算法（换句话说就是你自己写的深复制算法）很可能会陷入无限循环，然后报错。deepcopy会记住已经复制的对象，而不会进入无限循环：\n# 代码7\n>>> a = [10, 20]\n>>> b = [a, 30]  # 包含a的引用\n>>> b\n[[10, 20], 30]\n>>> a.append(b)  # 相互引用\n>>> a\n[10, 20, [[...], 30]]\n>>> a[2][0]\n[10, 20, [[...], 30]]\n>>> a[2][0][2][0]\n[10, 20, [[...], 30]]\n>>> from copy import deepcopy\n>>> c = deepcopy(a) # 不会报错，能正确处理相互引用的问题\n>>> c\n[10, 20, [[...], 30]]\n此外，深复制有时可能太深了。例如，对象可能会引用不该复制的外部资源或单例值，这时，深复制就不应该复制这些值。如果要控制copy和deepcopy的行为，我们可以在对象中重写特殊方法__copy__和__deepcopy__，具体内容这里就不展开了，大家可以参考copy模块的官方文档。\n3. 函数参数\n通过别名共享对象还能解释Python中传递参数的方式，以及使用可变类型作为参数默认值引起的问题。\n3.1 函数的参数作为引用时\nPython唯一支持的参数传递模式是共享传参（call by sharing），它指函数的形参获得实参中各个引用的副本，即形参是实参的别名。这种方案的结果就是，函数可能会修改作为参数传入的可变对象，但无法修改这些对象的标识（不能把一个对象替换成另一个对象）：\n# 代码8\ndef f(a, b):\n    a += b\n    return a\n\nx, y = 1, 2\nprint(f(x, y), x, y)\na, b = [1, 2], [3, 4]\nprint(f(a, b), a, b)\nt, u = (10, 20), (30, 40)\nprint(f(t, u), t, u)\n\n# 结果\n3 1 2 # x, y是不可变对象，没有影响到x, y\n[1, 2, 3, 4] [1, 2, 3, 4] [3, 4]   # x是可变对象，影响到了x\n(10, 20, 30, 40) (10, 20) (30, 40) # x没有指向新的元组，但形参a指向了新的元组\n3.2 参数默认值\n不要使用可变类型作为参数的默认值！其实这个问题在之前的文章“Python学习之路7-函数”的2.3小节中有所提及。现在我们来看下面这个例子：\n首先定义一个类：\n# 代码9\nclass Bus:\n    def __init__(self, passengers=[]):  # 默认值是个可变对象\n        self.passengers = passengers\n        \n    def pick(self, name):\n        self.passengers.append(name)\n    \n    def drop(self, name):\n        self.passengers.remove(name)\n下面是这个类的行为：\n# 代码10\n>>> bus1 = Bus([\"Alice\", \"Bill\"]) # 直到第8行Bus的表现都是正常的\n>>> bus1.passengers\n['Alice', 'Bill']\n>>> bus1.pick(\"Charlie\")\n>>> bus1.drop(\"Alice\")\n>>> bus1.passengers\n['Bill', 'Charlie']\n>>> bus2 = Bus()  # 使用默认值\n>>> bus2.pick(\"Carrie\")\n>>> bus2.passengers\n['Carrie']   # 到目前为止也是正常的\n>>> bus3 = Bus()  # 也是用默认值\n>>> bus3.passengers\n['Carrie']   # 不正常了！\n>>> bus3.pick(\"Dave\")\n>>> bus2.passengers\n['Carrie', 'Dave']  # bus2的值也被改变了\n>>> bus2.passengers is bus3.passengers  # 这俩是同一对象的别名\nTrue\n>>> bus1.passengers # bus1依然正常\n['Bill', 'Charlie']\n上述行为的原因在于，参数的默认值在导入模块时计算，方法或函数的形参指向这个默认值。而在上面这个例子中，类的属性self.passengers实际上是形参passengers所指向的对象（所指对象，referent）的别名。而bus1行为正常是因为从一开始它的passengers就没有指向默认值。\n这里有点像单例模式：参数的默认值是唯一的，只要采用默认值，不管创建多少个Bus的实例，它们的self.passengers都是同一个空列表[]对象的别名，不会为每一个实例单独创建一个专属的[]。\n运行上述代码之后，可以查看Bus.__init__对象的__defaults__属性，它存储了参数的默认值：\n# 代码11\n>>> Bus.__init__.__defaults__\n(['Carrie', 'Dave'],)\n>>> Bus.__init__.__defaults__[0] is bus2.passengers  # self.passengers就是一个别名！\nTrue\n这也说明了为什么要用None作为接收可变值的参数的默认值：\n# 代码12\nclass Bus:\n    def __init__(self, passengers=None):  # 默认值是个可变对象\n        if passengers is None:  # 并不推荐 if passengers == None 这种写法\n            self.passengers = []\n        else:\n            self.passengers = list(passengers)  # 注意这里！\n    -- snip --\n代码12中的第7行并不是直接把形参passengers赋值给self.passengers，而是形参的副本（这里是浅复制）。如果直接赋值，即self.passengers = passengers（self.passengers变成了用户传入的参数的别名），则用户传入的参数在运行过程中可能会被修改，而这并不一定是用户想要的，这便违反了\"最少惊讶原则\"（居然还真有这么个原则）\n4. del和垃圾回收\n对象绝不会自行销毁；然而，无法得到对象时，可能会被当做垃圾回收。——Python语言参考手册\ndel语句删除变量（即\"引用\"），而不是对象。del命令可能导致对象被当做垃圾回收，但这仅发生在当删除的变量保存的是对象的最后一个引用，或者无法得到对象时（如果两个对象相互引用，如代码7，当它们的引用只存在二者之间时，垃圾回收程序会判定它们都无法获取，进而把它们都销毁）。重新绑定也可能会导致对象的引用数量归零，进而对象被销毁。\n在CPython中，垃圾回收使用的主要算法是引用计数。实际上，每个对象都会统计有多少个引用指向自己。当引用计数归零时，对象立即被销毁。但在其他Python解释器中则不一定是引用计数算法。\n补充：有个__del__特殊方法，它不是用来销毁实例的，而是在实例被销毁前用来执行一些最后的操作，比如释放外部资源等。我们不应该在代码中调用它，Python解释器会在销毁实例时先调用它（如果定义了），然后再释放内存。它相当于C++中的析构函数。\n我们可以使用weakref.finalize来演示对象被销毁时的情况：\n# 代码13\n>>> import weakref\n>>> s1 = {1, 2, 3}\n>>> s2 = s1\n>>> def bye(): # 它充当一个回调函数\n...     print(\"Gone with the wind...\")\n# 一定不要传入待销毁对象的绑定方法，否则会有一个指向对象的引用\n>>> ender = weakref.finalize(s1, bye) # 在s1引用的对象上注册bye回调\n>>> ender.alive\nTrue\n>>> del s1\n>>> ender.alive\nTrue  # 说明 del s1并没有删除对象\n>>> s2 = \"spam\" \nGone with the wind...  # 引用计数为零，对象被删除\n>>> ender.alive\nFalse\n5. 弱引用\n不知道大家看到上述代码第15行时会不会产生如下疑惑：第8行代码明明把s1引用传给了finalize函数（为了监控对象和调用回调，必须要有引用），那么对象{1, 2, 3}则应该至少有三个引用，可为什么最后它还是被销毁了呢？这就牵扯到了弱引用这个概念。\n5.1 weakref.ref\n弱引用不会妨碍所指对象被当做垃圾回收，即弱引用不会增加对象的引用计数。（弱引用常被用于缓存，但具体用在缓存的哪些地方目前笔者还不清楚.....）\n弱引用还是可调用对象，下面的代码展示了如何使用weakref.ref实例获取所指对象。\n补充在代码之前：Python控制台会自动把结果不为None的表达式的结果绑定到变量_（下划线）上。这也说明了一个问题：微观管理内存时，隐式赋值会为对象创建新引用，而这有可能会导致一些意外结果。\n# 代码14\n>>> import weakref\n>>> a_set = {1, 2} # 对象{1, 2}的引用数+1\n>>> wref = weakref.ref(a_set) # 并没有增加所指对象的引用数\n>>> wref\n<weakref at 0x0000013D739E2D18; to 'set' at 0x0000013D739BE588>\n>>> wref() # 弱引用是个可调用对象\n{1, 2} # 发生了隐式赋值，变量 _ 指向了对象{1, 2}，引用数+1\n>>> a_set = {2, 3} # 引用数 -1\n>>> wref() # 所指对象依然存在，还没有被销毁\n{1, 2}\n>>> wref() is None  # 此时所指对象依然存在\nFalse # 变量 _ 指向了对象False，对象{1, 2}引用数归零，销毁\n>>> wref() is None  # 验证所指对象已被销毁\nTrue\n5.2 weakref集合\nweakref.ref类其实是底层接口，供高级用途使用，一般程序最好使用werakref集合和finalize函数，即最好使用WeakKeyDictionary、WeakValueDictionary、WeakSet和finalize（它们在内部使用弱引用），不推荐自己动手创建并处理weakref.ref实例，除非你的工作就是专门和这些东西打交道的。\nWeakValueDictionary类实现的是一种可变映射，里面的值（\"键值对\"中的\"值\"，而不是字典中的\"值\"）是对象的弱引用。被引用的对象在程序中的其他地方被当做垃圾回收后，对应的键会自动从WeakValueDictionary中删除。因此，它经常用于缓存。（查看缓存中变量是否依然存在？给框架用？）\n# 代码15\n>>> import weakref\n>>> class Cheese:\n...     def __init__(self, kind):\n...         self.kind = kind\n...\n>>> stock = weakref.WeakValueDictionary()\n>>> catalog = [Cheese(\"Red Leicester\"), Cheese(\"Parmesan\")]\n>>> for cheese in catalog:\n...     stock[cheese.kind] = cheese\n...\n>>> sorted(stock.keys())  \n['Red Leicester', 'Parmesan']   # 表现正常\n>>> del catalog\n>>> sorted(stock.keys())\n['Parmesan']  # 这是怎么回事？\n>>> del cheese  # 这是问题所在\n>>> sorted(stock.keys())\n[]\n临时变量引用了对象，这可能会导致该变量的存在时间比预期长。通常，这对局部变量来说不是问题，因为它们在函数返回时会被销毁。但上述代码中，for循环中的变量cheese是全局变量，除非显示删除，否则不会消失。\n与WeakValueDictionary对应的是WeakKeyDictionary，后者的键是弱引用，它的一些可能用途如下：\n它的实例可以为应用中其他部分拥有的对象附加数据，这样就无需为对象添加属性。这对属性访问受限的对象尤其有用。\nWeakSet类的用途则很简单：\"保存元素弱引用的集合。当某元素没有强引用时，集合会把它删除。\"如果一个类需要知道它的所有实例，一种好的方案是创建一个WeakSet类型的类属性，保存实例的弱引用。\n5.3 弱引用的局限\nweakref集合以及一般的弱引用，能处理的对象类型有限：\n\n\n基本的list和dict实例不能作为弱引用的所指对象，但它们的子类则可以；\nclass MyList(list):\n    \"\"\"MyList的实例可作为弱引用的所指对象\"\"\"\n\n\nset的实例可作为所指对象；\n自定义类的实例可以；\n\nint和tuple的实例不能作为弱引用的所指对象，它们的子类也不行。\n\n但这些局限基本上是CPython的实现细节，其他Python解释器的情况可能不同。\n6. CPython对不可变类型走的捷径\n本节内容是Python实现的细节，可以跳过。\n这些细节是CPython核心开发者走的捷径和优化措施，利用这些细节写的代码在其他Python解释器中可能没用，在CPython未来的版本中也可能没用。下面是具体内容：\n\n对元组t来说，t[:]和tuple(t)不创建副本，而是返回同一个对象的引用；\n\nstr、bytes和frozenset实例也是如此，并且frozenset的copy方法返回的也不是副本（注意，frozenset的实例fs不能用fs[:]，因为fs不是序列）；\n\nstr的实例还有共享字符串字面量的行为：\n>>> s1 = \"ABC\"\n>>> s2 = \"ABC\"\n>>> s1 is s2\nTrue\n这叫做\"驻留\"（interning），这是一种优化措施。CPython还会在小的整数上使用这种优化，防止重复创建常用数字，如0，-1。但CPython不会驻留所有字符串和数字，驻留的条件是实现细节，而且没有文档说明。所以千万不要依赖这个特性！（比较字符串或数字请用==，而不是is！）\n\n\n7. 总结\n每个Python对象都有标识、类型和值，只有对象的值可能变化。\n变量保存的是引用，这对Python编程有很多实际的影响：\n\n简单的赋值不会创建副本；\n对+=或*=等运算符来说，如果左边的变量绑定了不可变对象，则会创建新对象，然后重新绑定；如果是可变对象，则就地修改；\n对现有的变量赋予新值不会修改之前绑定的对象。这叫重新绑定：现有变量绑定了其它对象。如果变量是之前那个对象的最后一个引用，该对象会被回收；\n函数的参数以别名的形式传递，这意味着，函数可能会修改通过参数传入的可变对象。这一行为无法避免，除非在函数内部创建副本，或者使用不可变对象；\n不要使用可变类型作为函数的默认值！\n\n==用于比较值，is用于比较引用。\n\n某些情况下，可能需要保存对象的引用，但不留存对象本身，比如记录某个类的所有实例，这可以用弱引用解决。\n\n迎大家关注我的微信公众号\"代码港\" & 个人网站 www.vpointer.net ~\n\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "3"}