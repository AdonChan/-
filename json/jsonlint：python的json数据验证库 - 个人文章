{"title": "jsonlint：python的json数据验证库 - 个人文章 ", "index": "flask,python", "content": "随着前后端分离和 REST APIs 的火热，开发者不断寻找着一种灵活的、优雅的方式验证 json 数据。有直接手动获取数据验证的，也有使用 json scheme 验证的。前者容易使得函数变得冗长，还可能存在不少重复的验证；后者验证又不灵活。\n本文介绍的 jsonlint 启发自 python 的表单验证工具 wtforms，wtforms 通过继承 Form 类也能进行 json 数据验证，但是 wtforms 对于 json 的数组（Array）类型处理有着很诡异的行为，需要通过 a-1 、 a-2 这样来传递数组数据，常常不能有效的处理数组数据。 jsonlint 大部分代码来着 wtforms，可以视为 wtforms 的一个分支。但 jsonlint 删去了 wtforms 的表单渲染部分，更改了传入的数据格式，最重要的是使用正确的逻辑验证数组（Array）和对象（Object）类型。下面是一些例子：\n基本的字符串类型json验证\n对于基本的字符串类型，我们只需要创建一个 Json 的子类，填写对应的 Field 即可。使用方式和 wtforms 类型：\nfrom jsonlint import Json\nfrom jsonlint.fields import StringField\nfrom jsonlint.validators import DataRequired\n\nclass MyLint(Json):\n    name = StringField(validators=[DataRequired()])\n\nmylint = MyLint({'name': 'demo'})\nprint mylint.validate()  # True\nprint mylint.name.data  # demo\n更灵活的验证 json 数据\njsonlint 继承了 wtforms 的优点，可以进行一些更灵活的自定义json数据验证，只要将 field 类的实例名写成函数 validate_fieldname ，即可自定义验证改字段：\nfrom jsonlint import Json\nfrom jsonlint.fields import IntegerField\nfrom jsonlint.validators import ValidationError\n\nclass AgeLint(Json):\n    age = IntegerField()\n\n    def validate_age(form, field):\n        if field.data &lt; 13:\n            raise ValidationError(\"We're sorry, you must be 13 or older to register\")\n\nagelint = AgeLint({'age': 12})\nprint agelint.validate()  # False\nprint agelint.age.errors  # [\"We're sorry, you must be 13 or older to register\"]\n对数组类型进行验证\njsonlint 诞生可以说主要就是为了解决如何验证数组类型的问题，在jsonlint这很容易实现：\nfrom jsonlint import Json\nfrom jsonlint.fields import StringField, ListField\nfrom jsonlint.validators import DataRequired, ValidationError\n\nclass ListLint(Json):\n    cars = ListField(StringField(validators=[DataRequired()]))\n\n    def validate_cars(form, field):\n        if 'BMW' in field.data:\n            raise ValidationError(\"We're sorry, you cannot drive BMW\")\n\nlistlint = ListLint({'cars': ['Benz', 'BMW', 'Audi']})\nprint listlint.validate()  # False\nprint listlint.cars.errors  # [\"We're sorry, you cannot drive BMW\"]\nListField 类作为一个 Field 容器，容纳其它类型 Field 的数组，将对应类型的数组直接传入，即可有效的验证；ListField 同样也可以进行自定义验证。\n对对象类型进行验证\n对象类型在一些 REST APIs 的 web 应用中也经常存在，对此 jsonlint 也作了支持。只要将 Json 子类传入 ObjectField 中即可进行验证：\nfrom jsonlint import Json\nfrom jsonlint.fields import ObjectField, IntegerField, BooleanField\n\nclass T(Json):\n    status = BooleanField()\n    code = IntegerField()\n\nclass DataLint(Json):\n    data = ObjectField(T)\n\ndatalint = DataLint({'data': {'status': True, 'code': 200}})\nprint datalint.validate()  # False\nprint datalint.data.code.data  # 200\n写在最后\njsonlint 诞生初衷就是因为本人想用类似 wtforms 的方式来验证json，这样不但有着良好的验证方式，还可以分割业务，避免接口主函数变得十分冗长。例如，可以定义类：\nclass RegisterLint(UserLint):\n    def validata_nickname(self, field):\n        ...\n\n    def validate_account(self, field):\n        ...\n\n    def create_user(self):\n        ...\n\nuser = RegisterLint()\n这样既可以使用 RegisterLint 的实例 user 验证数据，同时又能直接执行 user.create_user() 进行数据库操作，将数据库逻辑更好的封装。这样可以说是在 MVC 设计模式的基础上独立出了一层。\n想要尝试使用 jsonlint 可以直接使用 pip 安装：\npip install jsonlint\n最后，jsonlint 开源在 Github ： https://github.com/tangwz/jso...\njsonlint 现阶段仅由我一人维护，虽然单元测试覆盖率尽可能的全覆盖，但也不代表没有bug，希望您提出您宝贵的意见，或一起维护、迭代jsonlint：https://github.com/tangwz/jso...\n如果使用 Flask 进行 web 开发，也可以使用封装好的结合了 Flask 和 jsonlint 的库： Flask-Lint\n原文地址：http://tangwz.com/2017/11/28/...\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}