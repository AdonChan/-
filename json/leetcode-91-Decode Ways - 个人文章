{"title": "leetcode-91-Decode Ways - 个人文章 ", "index": "python", "content": "描述\nA message containing letters from A-Z is being encoded to numbersusing the following mapping:'A' -> 1 'B' -> 2 ... 'Z' -> 26 Given an encoded message containingdigits, determine the total number of ways to decode it.\n\nFor example,\nGiven encoded message \"12\", it could be decoded as \"AB\" (1 2) or \"L\"(12).The number of ways decoding \"12\" is 2.\n\n\nclass Solution:\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if not s:\n            return 0\n        if s[0]=='0' :\n            return 0\n        elif len(s)==1:\n            return 1\n\n        length=len(s)\n        dp=[0 for _ in range(length+1)]\n        print('dp:==>',dp)\n        dp[0]=1\n        dp[1]=1\n        for i in range(2,length+1):\n            l2=int(s[i-2:i])\n            l1=int(s[i-1:i])\n            if 10<l2<27  and s[i-1]!='0':\n                dp[i]=dp[i-1]+dp[i-2]\n            elif l2==10 or l2==20:\n                dp[i]=dp[i-2]\n            elif s[i-1]!='0':\n                dp[i]=dp[i-1]\n            else:\n                return 0\n        # print(dp[length-1]+dp[length-2])\n        # print('dp=-=>',dp)\n        out=dp[length]\n        return out\nif __name__=='__main__':\n    st=Solution()\n    num='2626'\n    num='0'\n    num='11'\n    num='1'\n    num='0'\n    num='11'\n    num='110'\n    out=st.numDecodings(num)\n    print(out)\n解释：本地是动态规划解决，所以需要分清楚往后叠加增加字符时的数目之间的变化规律。经总结，发现当前字符前面的两个字符和一个字符可以拿出来进行分析。 当前的数目可以作为cur_index-2和cur_index-1的数目的叠加。只跟前两个位置的字符处产生的数目有关系。所以dp关系式是：dp[n]=dp[n-1]+dp[n-2].其他的特殊情况可以进行特殊处理。比如10，20，位数为1的情况。 需要注意的是：如果钱两位是10，20，则这两位作废，不能计入其他情况的统计，即                dp[i]=dp[i-2]。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}