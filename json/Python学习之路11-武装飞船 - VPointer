{"title": "Python学习之路11-武装飞船 - VPointer ", "index": "python,pygame", "content": "《Python编程：从入门到实践》笔记。本章主要学习如何使用pygame编写一个简单的小飞机打外星人的游戏，由于本人对用python写游戏并不是特别感兴趣，所以主要是看代码的构建和一些编程规范，代码会有所简略。\n1. 准备工作\nPython标准库中并没有自带pygame模块，所以需要自行安装，可以在控制台（Windows下是cmd）上使用命令行安装：pip install pygame。如果你是用的PyCharm，也可以在设置中安装：\n\n点击右边的加号，在弹出的窗口中输入pygame，然后安装即可。\n\n该项目中需要使用一些书中的图片，这些图片都可以在 http://www.ituring.com.cn/boo... 中下载到。\n2. 游戏基本内容\n首先需要新建一个项目，笔者取名为“alien_invasion”，并在该项目的根目录下新建一个images文件夹，用于存放项目中用到的图片。在本节中，我们将先创建4个文件：\nalien_invasion.py：游戏主程序\nsettings.py：游戏的配置文件\ngame_functions.py：存放游戏的控制函数，比如响应鼠标、键盘等\nship.py：飞船类\n2.1 alien_invasion.py模块：\n该模块经过重构后的代码如下：\nimport pygame\n\nimport game_functions as gf\nfrom settings import Settings\nfrom ship import Ship\n\ndef run_game():\n    # 初始化游戏并创建一个屏幕对象\n    pygame.init()   # 初始化背景设置，让pygame能正常工作\n    ai_settings = Settings()  # 实例化一个游戏配置类\n    # 返回一个游戏窗口\n    screen = pygame.display.set_mode(\n        (ai_settings.screen_width, ai_settings.screen_height))\n    pygame.display.set_caption(\"Alien Invasion\")   # 给这个游戏窗口设置一个标题\n\n    ship = Ship(ai_settings, screen)   # 实例化一个飞船类，传入了参数ai_settings和屏幕对象screen\n\n    # 开始游戏的主循环\n    while True:\n        gf.check_events(ship)  # 用于响应游戏事件\n        ship.update()   # 更新飞船状态\n        gf.update_screen(ai_settings, screen, ship)  # 重绘screen\n\nrun_game()\n①代码第1行导入pygame模块，它包含开发游戏所需的基本功能；\n②代码3到5行导入的是自行编写且经过重构的模块；\n③第9行代码执行游戏的初始化工作，比如初始化游戏背景等；\n④第10行实例化一个游戏配置类，用于配置游戏参数，该类的具体实现见本篇后面的内容；\n⑤代码第12-13行用于生成一个名为screen的显示窗口，长宽从配置对象ai_settings中读出；display.set_mode()返回的是一个surface，在pygame中，surface是屏幕的一部分，用于显示游戏元素，这里的screen表示的是整个游戏窗口。我们激活游戏的循环后，每经过一次循环pygame都将重绘这个screen。\n⑥代码第20行的check_events()函数用于响应游戏中发生的时间，比如鼠标，键盘，关闭窗口等。\n⑦代码第21行用于更新飞船的信息，如飞船位置\n⑧最后一行用于启动游戏，即初始化游戏，并开始主循环。\n2.2 settings.py模块\n该文件主要是游戏的配置信息，存放游戏的各种参数。\nclass Settings:\n    \"\"\"存储《外星人入侵》的所有设置的类\"\"\"\n\n    def __init__(self):\n        \"\"\"初始化游戏的设置\"\"\"\n        # 屏幕设置\n        self.screen_width = 1200   # 游戏窗口宽度\n        self.screen_height = 800   # 游戏窗口高度\n        self.bg_color = (230, 230, 230)  # 游戏背景颜色\n        self.ship_speed_factor = 1.5  # 飞船的移动速度\n这里故意将飞船的速度设置为浮点数，也可以是整数。在设置游戏元素的位置时，如果直接使用浮点数，则只会截取整数部分。\n2.3 ship.py模块\n该模块描述了一个飞船类的基本内容：\nimport pygame\n\nclass Ship:\n    def __init__(self, ai_settings, screen):\n        \"\"\"初始化飞机并设置其初始位置\"\"\"\n        self.screen = screen\n        self.ai_settings = ai_settings\n\n        # 加载飞机图片并获取其外接矩形\n        self.image = pygame.image.load(\"images/ship.bmp\")\n        self.rect = self.image.get_rect()\n        self.screen_rect = screen.get_rect()\n\n        # 将每艘新飞船放在屏幕底部中央\n        self.rect.centerx = self.screen_rect.centerx\n        self.rect.bottom = self.screen_rect.bottom\n\n        # 自定义一个能存储浮点数的临时变量,x坐标\n        self.center = float(self.rect.centerx)\n        \n        # 标志，用于表示是否正在向某个方向移动\n        self.moving_right = False\n        self.moving_left = False\n\n    def update(self):\n        \"\"\"根据移动标志调整飞船的位置\"\"\"\n        if self.moving_right and self.rect.right < self.screen_rect.right:\n            self.center += self.ai_settings.ship_speed_factor\n        if self.moving_left and self.rect.left > 0:\n            self.center -= self.ai_settings.ship_speed_factor\n\n        # 用临时变量更新rect的centerx，截取截取整数部分\n        self.rect.centerx = self.center\n\n    def blitme(self):\n        \"\"\"在指定位置绘制飞船\"\"\"\n        self.screen.blit(self.image, self.rect)\n①__init__()中的self.center属性，代码将self.rect.centerx即飞船的中心x坐标转换成浮点数，并将其存储在self.center中。之所以转换成浮点数，是因为在settings.py文件中，我们将飞船移动速度设置成了浮点数。\n②self.moving_right和self.moving_left标志，用于表示飞船是否正在移动，用于实现飞船在不松开按键下连续移动。\n③udpate()方法，用于增减飞船的中心位置x坐标（因为飞船只能在底部移动，所以不用改y坐标），并防止飞船移动出游戏窗口。\n④重写了blitme()函数，用于绘制飞船\n2.4 game_functions.py模块\n该模块主要是集中处理游戏中发生的各种事件。\nimport sys\nimport pygame\n\ndef check_keydown_event(event, ship):\n    \"\"\"响应按下按键\"\"\"\n    if event.key == pygame.K_RIGHT:\n        ship.moving_right = True\n    if event.key == pygame.K_LEFT:\n        ship.moving_left = True\n\ndef check_keyup_event(event, ship):\n    \"\"\"响应松开按键\"\"\"\n    if event.key == pygame.K_RIGHT:\n        ship.moving_right = False\n    if event.key == pygame.K_LEFT:\n        ship.moving_left = False\n\ndef check_events(ship):\n    \"\"\"响应按键和鼠标事件\"\"\"\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            sys.exit()\n        elif event.type == pygame.KEYDOWN:\n            check_keydown_event(event, ship)\n\n        elif event.type == pygame.KEYUP:\n            check_keyup_event(event, ship)\n\ndef update_screen(ai_settings, screen, ship):\n    \"\"\"更新屏幕上的图像，并切换到新屏幕\"\"\"\n    # 每次循环时都重绘屏幕\n    screen.fill(ai_settings.bg_color)\n    ship.blitme()\n\n    # 让最近绘制的屏幕可见\n    pygame.display.flip()\n①在pygame中，用K_RIGHT，K_LEFT表示方向按键，其实键盘上每个键在pygame中都有所对于，以K_开头。check_keydown_event()函数和check_keyup_event()函数都是对下面的check_event()的进一步简化，这两个函数的代码均可以放在check_event()中，但这样代码将会很臃肿，结构不清晰。\n②check_event()函数用于监听游戏的事件，比如pygame.QUIT，它表示游戏推出事件；pygame.KEYDOWN和pygame.KEYUP分别表示键盘按下与松开事件。本次大循环中（外层的while循环）发生的所有事件都存储在pygame.event中，我们使用get()方法获得这些事件。\n③在update_screen()函数中，我们使用screen的fill()方法填充窗体的背景色，调用blitme()方法来在窗体中绘制飞船，最后，调用pygame.display.flip()方法让最近的绘制在窗体中可见。\n2.5 运行游戏\n现在我们运行alien_invasion.py文件，我们将得到如下窗体：\n\n目前功能还比较简单，只能实现飞船的左右移动。\n3. 添加射击功能\n为了添加射击功能，需要先添加一个子弹类。\n3.1 Bullet.py\nimport pygame\nfrom pygame.sprite import Sprite\n\nclass Bullet(Sprite):  # 使用精灵\n    \"\"\"一个对飞船发射的子弹进行管理的类\"\"\"\n\n    def __init__(self, ai_settings, screen, ship):\n        \"\"\"在飞船所处的位置创建一个子弹对象\"\"\"\n        super(Bullet, self).__init__()\n        self.screen = screen\n\n        # 在（0,0）处创建一个表示子弹的矩形，再设置正确的位置\n        self.rect = pygame.Rect(0, 0, ai_settings.bullet_width,\n                                ai_settings.bullet_height)\n        self.rect.centerx = ship.rect.centerx   # 从飞机的中央位置射出\n        self.rect.top = ship.rect.top           # 从飞机的顶部射出\n\n        # 存储用浮点数表示的子弹位置，因为子弹只在y轴上运动，所以不需要x坐标\n        self.y = float(self.rect.y)\n\n        self.color = ai_settings.bullet_color   # 子弹颜色\n        self.speed_factor = ai_settings.bullet_speed_factor   # 子弹速度\n\n    def update(self):\n        \"\"\"向上移动子弹\"\"\"\n        # 更新表示子弹位置的浮点数值\n        self.y -= self.speed_factor\n        # 更新表示子弹的rect的位置\n        self.rect.y = self.y\n\n    def draw_bullet(self):\n        \"\"\"在屏幕上绘制子弹\"\"\"\n        pygame.draw.rect(self.screen, self.color, self.rect)\n首先我们需要导入pygame模块以及其中的Sprite类（直译的话叫做“精灵类”，然而这名字叫的真的很尴尬），它可以让我们在后面方便批量处理相同类型的同一操作，子弹类继承自Sprite类。该子弹类并没有使用图片，而是直接在screen上绘制矩形用于表示子弹。update()方法用于更新子弹的位置。pygame.draw.rect()用于在screen上绘制子弹。\n3.2 修改settings.py\n在该模块中添加子弹类的参数：\nclass Settings:\n    def __init__(self):\n        -- snip --\n        # 子弹设置\n        self.bullet_speed_factor = 1\n        self.bullet_width = 3\n        self.bullet_height = 15\n        self.bullet_color = 60, 60, 60\n        # 表示窗口中最多允许存在的子弹数，当然你也可以将其去掉\n        self.bullets_allowed = 3   \n3.3 修改game_functions.py\n游戏中我们按空格键发射子弹，并发射子弹的过程单独写在一个函数fire_bullet()中。为了响应空格键，需要修改check_event()函数和check_keydown_event()函数，前者只修改了参数，后者在判断结构中添加了一个判断。有了子弹类，那我们还需要在screen中绘制子弹，所以还需要修改update_screen()函数，而子弹自身信息（比如子弹的移动）的修改则放在了一个新的函数update_bullets()中。\nimport sys\nimport pygame\nfrom Bullet import Bullet\n\n# 新增函数！\ndef fire_bullet(ai_settings, screen, ship, bullets):\n    \"\"\"如果还没有到达限制，就发射一颗子弹\"\"\"\n    # 创建新子弹，并将其加入到编组bullets中\n    # 如果你想让飞船能无限发射子弹，可以将判断语句删除\n    if len(bullets) < ai_settings.bullets_allowed:\n        new_bullet = Bullet(ai_settings, screen, ship)\n        bullets.add(new_bullet)\n\n# 修改了参数！\ndef check_keydown_event(event, ship, ai_settings, screen, bullets):\n    -- snip --\n    # 按空格键发射子弹\n    elif event.key == pygame.K_SPACE:\n        fire_bullet(ai_settings, screen, ship, bullets)\n\n# 修改了参数！\ndef check_events(ai_settings, screen, ship, bullets):\n    \"\"\"响应按键和鼠标事件\"\"\"\n    for event in pygame.event.get():\n        -- snip -- \n        elif event.type == pygame.KEYDOWN:\n            # 增加了参数\n            check_keydown_event(event, ship, ai_settings, screen, bullets)\n        -- snip --\n\n# 修改了函数！\ndef update_screen(ai_settings, screen, ship, bullets):\n    -- snip --\n    # 绘制子弹\n    for bullet in bullets.sprites():\n        bullet.draw_bullet()\n    -- snip --\n\n# 新增函数\ndef update_bullets(bullets):\n    \"\"\"更新子弹的位置，并删除已消失的子弹\"\"\"\n    # 更新子弹的位置\n    # bullets是个Group对象，调用一次update()就会调用其中所有Sprite对象的update()\n    # 相当于你不用自己写for循环了\n    bullets.update()\n\n    # 删除已消失的子弹\n    for bullet in bullets.copy():\n        if bullet.rect.bottom <= 0:\n            bullets.remove(bullet)\n当子弹从窗口中消失时，它并没有从内存中消失，如果对于已经从屏幕中消失的子弹不做处理的话，时间一长，子弹数一多，光子弹一项的内存占用就会越来越多（土豪请忽略），虽然只是线性增长，但作为一个合格的程序员，应该避免这种无谓的浪费。\n3.4 修改alien_invation.py\n最后，我们修改主程序，在其中添加一个pygame.sprite中的Group对象用于表示子弹集合，以及对该对象的操作代码。\nimport pygame\nfrom pygame.sprite import Group   # 导入一个新类\n\nimport game_functions as gf\nfrom settings import Settings\nfrom ship import Ship\n\ndef run_game():\n    -- snip --\n    bullets = Group()\n\n    # 开始游戏的主循环\n    while True:\n        gf.check_events(ai_settings, screen, ship, bullets)\n        ship.update()\n        gf.update_bullets(bullets)\n        gf.update_screen(ai_settings, screen, ship, bullets)\n3.5运行新代码\n以下是运行截图：\n\n4. 小结\n自此，我们创建了一个能开火的小飞机，在下一篇文章中我们将向其中添加外星人。\n本篇中的代码都是经过了重构后的代码，但是，当我们自己在编程时，如果对某一框架还是小白，搞不清楚该如何组织代码，那就把所有代码都写在一个或几个文件里（虽然这种习惯很不好），也暂时不用考虑代码结构之类的问题，因为你的任务是造东西，而不是写漂亮代码，用精巧结构，用别人没看过的语法。两者能兼备当然更好，但每个人都有当小白的时期，有一定熟练度后，再来考虑代码重构的问题。\n\n迎大家关注我的微信公众号\"代码港\" & 个人网站 www.vpointer.net ~\n\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "2"}