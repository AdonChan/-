{"title": "Python装饰器的另类用法 - Python测试开发 ", "index": "python", "content": "之前有比较系统介绍过Python的装饰器（请查阅《详解Python装饰器》），本文算是一个补充。今天我们一起探讨一下装饰器的另类用法。\n语法回顾\n开始之前我们再将Python装饰器的语法回顾一下。\n@decorate\ndef f(...):\n    pass\n等同于:\ndef f(...):\n    pass\n\nf = decorate(f)\n@语法的好处在于：\n\n相同的函数名只出现一次，避免了f = decorate(f)这样的语句。\n可读性更高，让读代码的人一眼就明白函数被装饰了哪些功能。\n\n@call()装饰器\n假设你要创建一个整数平方的列表，你可以这样写：\n>>> table = [0, 1, 4, 9, 16]\n>>> len(table), table[3]\n(5, 9)\n也可以使用列表表达式，因为我们要实现比较简单。\n>>> table = [i * i for i in range(5)]\n>>> len(table), table[3]\n(5, 9)\n但是假如这个列表的逻辑比较复杂的时候，最好是写成一个方法，这样会更好维护。\n>>> def table(n):\n...     value = []\n...     for i in range(n):\n...         value.append(i*i)\n...     return value\n>>> table = table(5)\n注意看最后一句，是不是很符合装饰器的语法规则？什么情况下你会写这样的代码呢？\n\n你需要把相对复杂业务写成一个方法。\n这个方法和返回值可以同名，而且你不希望对外公开此方法，只公开结果。\n你想尽量使用装饰器。（无厘头的理由）\n\n那么这时候@call()装饰器就登场了。\ndef call(*args, **kwargs):\n    def call_fn(fn):\n        return fn(*args, **kwargs)\n    return call_fn\n这个装饰器会把你传入的参数送给目标函数然后直接执行。\n@call(5)\ndef table(n):\n    value = []\n    for i in range(n):\n        value.append(i*i)\n    return value\n\nprint len(table), table[3]  # 5 9\n@call()装饰器适用于任何函数，你传入的参数会被直接使用然后结果赋值给同名函数。这样避免了你重新定义一个变量来存储结果。\n\n@list 装饰器\n假如你有一个这样一个生成器函数。\ndef table(n):\n    for i in range(n):\n        yield i\n当你要生成n=5的序列时，可以直接调用。\ntable = table(5)\nprint table  # <generator object table at 0x027DAC10>\n使用上节提到的@call()装饰器，也能得到一样的结果。\n@call(5)\ndef table(n):\n    for i in range(n):\n        yield i\n\nprint table  # <generator object table at 0x0340AC10>\n你还可以直接将其转换成列表。（使用list(generator_object)函数）\n@list\n@call(5)\ndef table(n):\n    for i in range(n):\n        yield i\n\nprint table  # [0, 1, 2, 3, 4]\n相信不少同学第一次看到这个用法应该是懵逼的。这等同于列表表达式，但是可读性也许差了不少。例子本身只是演示了装饰器的一种用法，但不是推荐你就这样使用装饰器。你这样用也许会被其他同事拖到墙角里打死。\n类装饰器\n在Python 2.6以前，还不支持类装饰器。也就是说，你不能使用这样的写法。\n@decorator\nclass MyClass(object):\n    pass\n你必须这样写：\nclass MyClass(object):\n    pass\n\nMyClass = decorator(MyClass)\n也就是说，@语法对类是做了特殊处理的，类不一定是一个callable对象（尽管它有构造函数），但是也允许使用装饰器。那么基于以上语法，你觉得类装饰器能实现什么功能呢？\n举一个例子，ptest中的@TestClass()用于声明一个测试类，其源代码大致如此。\ndef TestClass(enabled=True, run_mode=\"singleline\"):\n    def tracer(cls):\n        cls.__pd_type__ ='test'\n        cls.__enabled__ = enabled\n        cls.__run_mode__ = run_mode.lower()\n        return cls\n    return tracer\n当我们在写一个测试类时，发生了什么？\n@TestClass()\nclass TestCases(object):\n    # your test case ...\n\nprint TestCases.__dict__  # {'__module__': '__main__', '__enabled__': True, '__pd_type__': 'test', '__run_mode__': 'singleline', ...}\n居然装饰器的参数全都变成了变成这个类的属性，好神奇！我们把语法糖一一展开。\nclass TestCases(object):\n    pass\n\ndecorator = TestClass()\nprint decorator  # <function tracer at 0x033128F0>\n\nTestCases = decorator(TestCases)\nprint TestCases  # <class '__main__.TestCases'>\n\nprint TestCases.__dict__  # {'__module__': '__main__', '__enabled__': True, '__pd_type__': 'test', '__run_mode__': 'singleline', ...}\n当装饰器在被使用时，TestClass()函数会马上被执行并返回一个装饰器函数，这个函数是一个闭包函数，保存了enabled和run_mode两个变量。另外它还接受一个类作为参数，并使用之前保存的变量为这个类添加属性，最后返回。所以经过@TestClass()装饰过的类都会带上__enabled__、__pd_type__以及__run_mode__的属性。\n由此可见，类装饰器可以完成和Java类似的注解功能，而且要比注解强大的多。\n后记\n装饰器就是一个语法糖，当你看不懂一个装饰器时，可以考虑将其依次展开，分别带入。这个语法糖给了我们不少方便，但是也要慎用。毕竟可维护的代码才是高质量的代码。\n\n关于作者：Python技术爱好者，目前从事测试开发相关工作，转载请注明原文出处。\n欢迎关注我的博客 http://betacat.online，你可以到我的公众号中去当吃瓜群众。\n\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "7"}