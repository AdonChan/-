{"title": "使用 Vue.js 和 Flask 来构建一个单页的App - 个人文章 ", "index": "python,vue-router,vuex,flask,vue.js", "content": "在这个教程中，我们将讲解如何将vue.js单页应用与Flask后端进行连接。\n一般来说，如果你只是想通过Flask模板使用vue.js库也是没有问题的。但是，实际上是一个很明显的问题那就是，Jinja（模板引擎）也和Vue.js一样采用双大括号用于渲染，但只是一个还算过的去的解决方案。\n我想要一个不同的例子。如果我需要建立一个单页应用程序（应用程序使用单页组成，vue-router在HTML5的History-mode以及其他更多好用的功能）用vue.js，由Flask提供Web服务？简单地说应该这样，如下所示：\nFlask为index.html服务，index.html包含我的vue.js App。\n在前端开发中我使用Webpack，它提供了所有很酷的功能。\nFlask有API端，我可以从我的SPA访问。\n我可以访问API端，甚至当我为了前端开发而运行Node.js的时候。\n听起来是不是很有趣？那让我们这样动手做做吧。\n完整的源代码，你可以在这里找到：\nhttps://github.com/oleg-agapo...\n客户端\n我将使用Vue CLI产生基本vue.js App。如果你还没有安装它，请运行：\n$ npm install -g vue-cli\n客户端和后端代码将被拆分到不同的文件夹。初始化前端部分运行跟踪：\n$ mkdir flaskvue\n$ cd flaskvue\n$ vue init webpack frontend\n通过安装向导。我的设置是：\n\nVue 只在运行时构建。 \n安装Vue-router。\n使用ESLint检查代码。\n选择一个ESLint 标准预设 。\n不试用Karma + Mocha进行单位测试。\n不使用Nightwatch建立端到端的测试。\n\nok，接着来：\n$ cd frontend\n$ npm install\n# after installation\n$ npm run dev\n这就可以开始安装vue.js应用程序。让我们从添加一些页面开始吧。\n添加home.vue和about.vue到frontend/src/components文件夹。它们非常简单，像这样：\n// Home.vue\n\n<template>\n<div>\n<p>Home page</p>\n</div>\n</template>\nand\n// About.vue\n\n<template>\n<div>\n<p>About</p>\n</div>\n</template>\n我们将使用它们正确地识别我们当前的位置（根据地址栏）。现在我们需要改变frontend/src/router/index.js文件以便使用我们的新组件：\nimport Vue from 'vue'\nimport Router from 'vue-router'\nconst routerOptions = [\n{ path: '/', component: 'Home' },\n{ path: '/about', component: 'About' }\n]\n\nconst routes = routerOptions.map(route => {\nreturn {\n...route,\ncomponent: () => import(`@/components/${route.component}.vue`)\n}\n\n})\n\nVue.use(Router)\nexport default new Router({\nroutes,\nmode: 'history'\n})\n如果你试着输入localhost:8080 和 localhost:8080/about，你应该看到相应的页面。\n\n我们几乎已经准备好构建一个项目，并且能够创建一个静态资源文件包。在此之前，让我们为它们重新定义一下输出目录。在frontend/config/index.js找到下一个设置：\nindex: path.resolve(__dirname, '../dist/index.html'),\nassetsRoot: path.resolve(__dirname, '../dist'),\n把它们改为\nindex: path.resolve(__dirname, '../../dist/index.html'),\nassetsRoot: path.resolve(__dirname, '../../dist'),\n所以/dist文件夹的HTML、CSS、JS会在同一级目录/frontend 。现在你可以运行 $ npm run build 创建一个包。\n\n后端\n对于Flask服务器，我将使用Python版本3.6。在 /flaskvue创建新的子文件夹存放后端代码并初始化虚拟环境：\n$ mkdir backend\n$ cd backend\n$ virtualenv -p python3 venv\n为了使虚拟环境中运行（MacOS）：\n$ source venv/bin/activate\n在Windows中需要激活此文档（http://pymote.readthedocs.io/...）。\n在虚拟环境下安装：\n(venv) pip install Flask\n现在让我们为Flask服务端编写代码。创建根目录文件run.py：\n(venv) cd ..\n(venv) touch run.py\n向这个文件添加下一个代码：\nfrom flask import Flask, render_template\napp = Flask(__name__,\nstatic_folder = \"./dist/static\",\ntemplate_folder = \"./dist\")\n\n@app.route('/')\ndef index():\nreturn render_template(\"index.html\")\n这段代码与Flask的 “Hello World”代码略有不同。主要的区别是，我们指定存储静态文件和模板位置在文件夹 /dist，以便和我们的前端文件夹区别开。在根文件夹中运行Flask服务端：\n(venv) FLASK_APP=run.py FLASK_DEBUG=1 flask run\n这将启动本地主机上的Web服务器：localhost:5000 上的FLASK_APP服务器端的启动文件，flask_debug = 1将运行在调试模式。如果一切正确，你会看到熟悉的主页，你已经完成了对Vue的设置。\n同时，如果您尝试输入/about页面，您将面临一个错误。Flask抛出一个错误，说找不到请求的URL。事实上，因为我们使用了HTML5的History-Mode在Vue-router需要配置Web服务器的重定向，将所有路径指向index.html。用Flask做起来很容易。将现有路由修改为以下：\n@app.route('/', defaults={'path': ''})\n@app.route('/<path:path>')\ndef catch_all(path):\nreturn render_template(\"index.html\")\n现在输入网址localhost:5000/about 将重新定向到index.html和vue-router将处理路由。\n添加404页\n因为我们有一个包罗万象的路径，我们的Web服务器在现在已经很难赶上404错误，Flask将所有请求指向index.html（甚至不存在的页面）。所以我们需要处理未知的路径在vue.js应用。当然，所有的工作都可以在我们的路由文件中完成。\n在frontend/src/router/index.js添加下一行：\nconst routerOptions = [\n{ path: '/', component: 'Home' },\n{ path: '/about', component: 'About' },\n{ path: '*', component: 'NotFound' }\n]\n这里的路径'*'是一个通配符，Vue-router就知道除了我们上面定义的所有其他任何路径。现在我们需要更多的创造NotFound.vue文件在/components目录。试一下很简单：\n// NotFound.vue\n\n<template>\n<div>\n<p>404 - Not Found</p>\n</div>\n</template>\n现在运行的前端服务器再次npm run dev，尝试进入一些毫无意义的地址例如：localhost:8080/gljhewrgoh。您应该看到我们的“未找到”消息。\n添加API端\n我们的vue.js/flask教程的最后一个例子将是服务器端API创建和调度客户端。我们将创建一个简单的Api，它将从1到100返回一个随机数。\n打开run.py并添加：\nfrom flask import Flask, render_template, jsonify\nfrom random import *\n\napp = Flask(__name__,\nstatic_folder = \"./dist/static\",\ntemplate_folder = \"./dist\")\n\n@app.route('/api/random')\n\ndef random_number():\nresponse = {\n'randomNumber': randint(1, 100)\n}\nreturn jsonify(response)\n\n@app.route('/', defaults={'path': ''})\n@app.route('/<path:path>')\ndef catch_all(path):\n\nreturn render_template(\"index.html\")\n首先我导入random库和jsonify函数从Flask库中。然后我添加了新的路由 /api/random来返回像这样的JSON：\n{\n\"randomNumber\": 36\n}\n你可以通过本地浏览测试这个路径：localhost:5000/api/random。\n此时服务器端工作已经完成。是时候在客户端显示了。我们来改变home.vue组件显示随机数：\n<template>\n<div>\n<p>Home page</p>\n<p>Random number from backend: {{ randomNumber }}</p>\n<button @click=\"getRandom\">New random number</button>\n</div>\n\n</template>\n<script>\nexport default {\ndata () {\nreturn {\nrandomNumber: 0\n}\n},\n\nmethods: {\ngetRandomInt (min, max) {\nmin = Math.ceil(min)\nmax = Math.floor(max)\nreturn Math.floor(Math.random() * (max - min + 1)) + min\n},\n\ngetRandom () {\nthis.randomNumber = this.getRandomInt(1, 100)\n}\n},\n\ncreated () {\nthis.getRandom()\n}\n\n}\n\n</script>\n在这个阶段，我们只是模仿客户端的随机数生成过程。所以，这个组件就是这样工作的：\n\n在初始化变量 randomNumber等于0。\n在methods部分我们通过getRandomInt(min, max)功能来从指定的范围内返回一个随机数，getrandom函数将生成随机数并将赋值给randomNumber\n\n组件方法getrandom创建后将会被调用来初始化随机数\n在按钮的单击事件我们将用getrandom方法得到新的随机数\n\n现在在主页上，你应该看到前端显示我们产生的随机数。让我们把它连接到后端。\n为此目的，我将用axios库。它允许我们用响应HTTP请求并用Json返回JavaScript Promise。我们安装下它：\n(venv) cd frontend\n(venv) npm install --save axios\n打开 home.vue 再在 <script> 部分添加一些变化：\nimport axios from 'axios'\nmethods: {\ngetRandom () {\n// this.randomNumber = this.getRandomInt(1, 100)\nthis.randomNumber = this.getRandomFromBackend()\n},\n\ngetRandomFromBackend () {\nconst path = `http://localhost:5000/api/random`\naxios.get(path)\n.then(response => {\nthis.randomNumber = response.data.randomNumber\n})\n.catch(error => {\nconsole.log(error)\n})\n\n}\n\n}\n在顶部，我们需要引用Axios库。然后有一个新的方法getrandomfrombackend将使用Axios异步调用API和检索结果。最后，getrandom方法现在应该使用getrandomfrombackend函数得到一个随机值。\n保存文件，到浏览器，运行一个开发服务器再次刷新 localhost:8080。你应该看到控制台错误没有随机值。但别担心，一切都正常。我们得到了CORS的错误意味着Flask服务器API默认会关闭其他Web服务器（在我们这里，vue.js App是在 Node.js服务器上运行的应用程序）。如果你npm run build 项目，那在localhost:5000（如Flask服务器）你会看到App在工作的。但是，每次对客户端应用程序进行一些更改时，都创建一个包并不十分方便。\n让我们用打包了CORS插件的Flask，将使我们能够创建一个API访问规则。插件叫做FlaskCORS，让我们安装它：\n(venv) pip install -U flask-cors\n你可以阅读文档，更好的解释你要使你的服务器怎么样使用CORS。我将使用特定的方法，并将{“origins”: “”}应用于所有/api/路由（这样每个人都可以使用我的API端）。在run.py加上：\nfrom flask_cors import CORS\napp = Flask(__name__,\nstatic_folder = \"./dist/static\",\ntemplate_folder = \"./dist\")\ncors = CORS(app, resources={r\"/api/*\": {\"origins\": \"*\"}})\n有了这种改变，您就可以从前端调用服务端。\n更新:\n事实上，如果你想通过Flask提供静态文件不需要CORS。感谢Carson Gee的下面的这一招。\n这个主意是这样的。如果应用程序在调试模式下，它只会代理我们的前端服务器。否则（在生产中）只为静态文件服务。所以我们这样做：\nimport requests\n@app.route('/', defaults={'path': ''})\n@app.route('/<path:path>')\ndef catch_all(path):\n\nif app.debug:\n\nreturn requests.get('http://localhost:8080/{}'.format(path)).text\n\nreturn render_template(\"index.html\")\n很优雅的魔法✨！\n现在有了一个完整的全栈（full-stack）应用程序，用您最喜爱Vue.js和Flask技术构建。\n\n\n后记\n最后，我想就如何改进这个解决方案谈几句话。\n首先利用CORS，如果你想让你的API端访问外部的服务器。否则的话只需要使用代理服务器与前端开发技巧。\n另一个改进是避免客户端硬编码API路由。也许你需要考虑一些API端点的字典。因此，当您更改API路由时，只需刷新一个字典即可。前端仍然有一个有效的端点。\n通常在开发过程中，你将至少有2个终端窗口：一个是Flask和另一个是vue.js。在生产中可以摆脱Vue而只单独运行Node.js服务器。\n源代码：https://github.com/oleg-agapo...\n谢谢你的阅读！\n分享一个Vue.js 2 的入门级全家桶系列教程：\n\nvue.js 2 入门与提高: http://xc.hubwiz.com/course/vue.js\n\nvuex 2 入门与提高: http://xc.hubwiz.com/course/vuex\n\nvue-router 2 入门与提高: http://xc.hubwiz.com/course/vuerouter\n\nvue.js 2 工程化实践: http://xc.hubwiz.com/course/vuegch\n\n\n另外推荐一个flask的入门教程：\n深入浅出 flask  http://xc.hubwiz.com/course/562427361bc20c980538e26f\n\n                ", "mainLikeNum": ["7 "], "mainBookmarkNum": "5"}