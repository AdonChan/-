{"title": "Python-Decorator - ormsf ", "index": "python", "content": "面向对象思想的实现\nclass Averager():\n    def __init__(self):\n    self.series = []\n\n    def __call__(self, new_value):\n        self.series.append(new_value)\n        total = sum(self.series)\n        return total/len(self.series)\n>>> avg(10)\n10.0\n>>> avg(11)\n10.5\n>>> avg(12)\n11.0\n函数式编程思想的实现\ndef make_averager():\n    series = []\n    def averager(new_value):\n        series.append(new_value)\n        total = sum(series)\n        return total/len(series)\n    return averager\n>>> avg = make_averager()\n>>> avg(10)\n10.0\n>>> avg(11)\n10.5\n>>> avg(12)\n11.0\nnonlocal关键字\ndef make_averager():\n    count = 0\n    total = 0\n    def averager(new_value):\n        count += 1\n        total += new_value\n        return total / count\n    return averager\n>>> avg = make_averager()\n>>> avg(10)\nTraceback (most recent call last):\n ...\nUnboundLocalError: local variable 'count' referenced before assignment\n>>>\nThe problem is that the statement count += 1 actually means the same as count = count + 1, when count is a number or any immutable type. So we are actually assigning to count in the body of averager, and that makes it a local variable. The same problem affects the total variable.\nWe did not have this problem in the example because we never assigned to the series list, we only called series.append and invoked sum and len on it. So we took  advantage of the fact that lists are mutable. But with immutable types like numbers, strings, tuples etc., all you can is read, but never update. If you try to rebind them, as in count = count + 1, then you are implicitly creating a local variable count. It is no longer a free variable, therefore it is not saved in the closure.\nTo work around this the nonlocal declaration was introduced in Python 3. It lets you flag a variable as a free variable even when it is assigned a new value within the function. If a new value is assigned to a nonlocal variable, the binding stored in the closure is changed.\ndef make_averager():\n    count = 0\n    total = 0\n    def averager(new_value):\n        nonlocal count, total\n        count += 1\n        total += new_value\n        return total / count\n    return averager\n带参数的装饰器\ndef use_logging(level):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            if level == \"warn\":\n                logging.warn(\"%s is running\" % func.__name__)\n            elif level == \"info\":\n                logging.info(\"%s is running\" % func.__name__)\n            return func(*args)\n        return wrapper\n    return decorator\n\n@use_logging(level=\"warn\")\ndef foo(name='foo'):\n    print(\"i am %s\" % name)\n\nfoo()\nStacked decorators\n@d1\n@d2\ndef f():\n    print('f')\n\n# equivalent to\ndef f():\n    print('f')\nf = d1(d2(f))\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}