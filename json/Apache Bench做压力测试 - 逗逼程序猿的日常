{"title": "Apache Bench做压力测试 - 逗逼程序猿的日常 ", "index": "python,apachebentch", "content": "\n前言\n\nApache Bench是一个简单易用的压力测试工具，在这里我不想多讲。今天主要说的是写一个py脚本来自动化测试过程，以及中间遇到的一些奇葩问题。\n\n测试脚本\n\npython#!/usr/bin/env python\n# encoding: utf-8\nimport sys\nimport subprocess as sub\nimport json\nimport re\nimport time\nstore=open(sys.argv[1],'w')\nif len(sys.argv)>2:\n    total=sys.agrv[2]\nelse:\n    total=10000\nif len(sys.argv)>3:\n    hostPath=sys.argv[3]\nelse:\n    hostPath='http://127.0.0.1:3000/'\n#url=['index','str','json','read','write','chain']\n#cocurrency=[8,16,32,64,128,256]\nurl=['str','json','chain'];cocurrency=[16]\nresult=dict.fromkeys(url,{})\ndef parseAB(src,dst):\n    src=src.split('\\n')\n    pattern=re.compile(r'\\d+\\.{0,1}\\d{0,10}')\n    for i in range(15,len(src)-10):\n        if(src[i].count(':')==0):\n            continue\n        tmp=src[i].split(':')\n        key=tmp[0]\n        data=pattern.findall(tmp[1])\n        if not data:\n            continue\n        elif(len(data)>1):\n            dst[key]=[]\n            for j in data:\n                dst[key]=dst[key]+[float(j)]\n        else:\n            dst[key]=float(data[0])\n        dst['percentage']={}\n    for i in range(len(src)-10,len(src)):\n        tmp=pattern.findall(src[i])\n        if(len(tmp)!=2):\n            continue\n        dst['percentage'][int(tmp[0])]=int(tmp[1])\n    return dst\n\nfor item in url:\n    for c in cocurrency:\n        child=sub.check_output('ab -k -n '+str(total)+' -c '+str(c)+' '+hostPath+item,shell=True,close_fds=True)\n        #child=sub.Popen('ab -k -n '+str(total)+' -c '+str(c)+' '+hostPath+item,shell=True,close_fds=True,stdout=sub.PIPE)\n        result[item][c]={}\n        parseAB(child,result[item][c])\n        time.sleep(5)\n\nstore.write(json.dumps(result));\nstore.close()\n\n\n\n最终得到了一个包含该框架所有测试信息的json文件，之所以采用json这种数据格式，是为了方便下一步处理。\n\n解析脚本\n\npython#!/usr/bin/env python\n# encoding: utf-8\n\nimport sys\nimport json\n\nbasePath=''\nframe=['express']\ndata={}\n\nfor f in frame:\n    data[f]=json.loads(open(basePath+f+'.json','r').read())\nurl=data[frame[0]].keys()\ncocurrency=data[frame[0]][url[0]].keys()\nkeyList=data[frame[0]][url[0]][cocurrency[0]].keys()\nprint 'you can get these key:   '+str(keyList)\ncompare=dict.fromkeys(frame,dict.fromkeys(url,{}))\nfor f in frame:\n    for u in url:\n        for k in keyList:\n            dataType=type(data[f][u][cocurrency[0]][k])\n            if dataType==int or dataType==float:\n                tmp=[]\n                for c in cocurrency:\n                    tmp=tmp+[dataType(data[f][u][c][k])]\n                compare[f][u][k]=tmp\n            elif dataType==dict:\n                percent=data[f][u][cocurrency[0]][k].keys()\n                tmp=dict.fromkeys(percent,[])\n                for p in percent:\n                    for c in cocurrency:\n                        tmp[p]=tmp[p]+[data[f][u][c][k][p]]\n                compare[f][u][k]=tmp\n            elif dataType==list:\n                sta=['min','mean','sd','median','max']\n                tmp=dict.fromkeys(sta,[])\n                for i in range(len(sta)):\n                    for c in cocurrency:\n                        s=sta[i]\n                        tmp[s]=tmp[s]+[data[f][u][c][k][i]]\n                compare[f][u][k]=tmp\n\ndef get(f,u,k,index=None):\n    if k=='percentage':\n        if not index:\n            return compare[f][u][k]['95']\n        else:\n            return compare[f][u][k][str(index)]\n    elif type(compare[f][u][k])==dict:\n        if not index:\n            return compare[f][u][k]['mean']\n        else:\n            return compare[f][u][k][index]\n    else:\n        return compare[f][u][k]\n\n\n最终暴露出一个API接口\n\npythonimport handle\nhandle.get('express','json','Time per request')\n//return an array for all cocurrency you choose\n\n\n遇到的问题\n\n在测试过程中（开始的脚本不是这个样子的，有略微的改变）到16000+请求的时候会卡主，并最终抛出socket timeout的错误，错误码60.为什么会这样子呢？\n\n是由于系统资源的限制，socket在unix系统下也是利用文件描述符的，socket的数量是有限制的，对于本人的MAC是16387，据说对于linux系统是32000+，好，找到了问题所在，看来是子进程退出时没有关闭socket。在python的bug报告里提到了这个问题，在subprocess的调用中加一句close_fds=True可以在子进程执行之前关闭除了0，1，2的所有文件描述符，自然就关闭了上次操作的所有sockets。\n\n不过，这样依旧不行。。。为什么呢？因为不要忘了服务器是localhost，关闭这些文件描述符只是客户端的socket.close()，意味着文件描述符可以被再次分配，但服务端依然保有socket，它的资源没有被释放，限制依旧存在。想要立即释放，我们应该用socket.shutdown()，不过这样恐怕需要改写subprocess，显然蛋疼。\n\n然后我就发现了我的测试语句\n\nshab -c 8 -n 10000 http://127.0.0.1:3000/json\n\n\n对，木有用-k，keep-alive选项允许socket被复用，不只是用于一个http请求。同时我还在循环末尾加了一句sleep以等待资源被释放。剩下的就只能听天由命了。\n\n还有一个非常常见的错误。\n\nshab -c 8 -n 10000 http://localhost:3000/json\n\n\n写成这样也会报错哦！\n\n结语\n\n最后向大家提一个问题，为什么用Jmeter做压力测试的时候，吞吐量会一开始很高，然后一直在下降？\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "5"}