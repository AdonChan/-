{"title": "自定义字体混淆信息的自动化破解 - 个人文章 ", "index": "ocr,网页爬虫,自动化,python", "content": "注意：本示例仅供学习参考～\n\n混淆原理\n出于某种原因，明文信息通过自定义字体进行渲染，达到混淆目的。\n举个例子：网页源码 <p>123</p> 在正常字体的渲染下，浏览者看到的是 123 这 3 个数字。如果创建一种自定义字体，把 1 渲染成 5，那么浏览者看到的便是 523 这 3 个数字。这样便达到混淆信息的效果，常见于对付爬虫之类的自动化工具。\n破解方法\n\n下载自定义字体文件（通常在 css @font-face 中找到），保存成 a.ttf 文件。\n\n安装以下依赖项目\n\ntesseract 4.0 及以上版本，以及简体中文(chi_sim)和英文(eng)数据文件。\npython tesserocr 最新源码(github)版本。\npython fonttools 库。\npython pillow 库。\n\n\n运行以下代码\n\n# -*- coding: utf-8 -*-\n本例采用 tesseract OCR 引擎，根据字体文件自动生成密文与明文的字符映射表，实现解密功能。\n\n@author: 李毅\n'''\nfrom tesserocr import PyTessBaseAPI, PSM\nfrom PIL import Image, ImageDraw, ImageFont\nfrom fontTools.ttLib import TTFont\nimport string\n\n\nclass OCR(object):\n    default_config = {\n        # ocr engine\n        'data_path': None,\n        'lang': 'chi_sim',\n        'white_list': None,\n        'black_list': None,\n        # image\n        'font': None,\n        'image_size': (60, 60),\n        'font_size': 30,\n        'text_offset': (15, 15),\n    }\n\n    def __init__(self, config={}):\n        c = dict(self.default_config)\n        c.update(config)\n        self.api = PyTessBaseAPI(path=c['data_path'], lang=c['lang'], psm=PSM.SINGLE_CHAR)\n        self.img = Image.new('RGB', c['image_size'], color='white')\n        self.draw = ImageDraw.Draw(self.img)\n        self.font = ImageFont.truetype(c['font'], size=c['font_size'])\n        self.text_offset = c['text_offset']\n        if c['white_list']:\n            self.api.SetVariable('tessedit_char_whitelist', c['white_list'])\n        if c['black_list']:\n            self.api.SetVariable('tessedit_char_blacklist', c['black_list'])\n        self.font_tool = TTFont(c['font'])\n        self.empty_char = self._predict_empty_char()\n\n    def _predict_empty_char(self):\n        self.api.SetImage(self.img)\n        return self.api.GetUTF8Text().strip()\n\n    def is_char_in_font(self, char):\n        for t in self.font_tool['cmap'].tables:\n            if t.isUnicode():\n                if ord(char) in t.cmap:\n                    return True\n        return False\n\n    def predict(self, char):\n        ''' 返回转换后的字符，或空串'' '''\n        if not self.is_char_in_font(char):\n            return char  # 若字体无法渲染该字符，则原样返回。此处可酌情移除。\n        self.img.paste('white', (0, 0, self.img.size[0], self.img.size[1]))\n        self.draw.text(self.text_offset, char, fill='black', font=self.font)\n        self.api.SetImage(self.img)\n        c2 = self.api.GetUTF8Text().strip()\n        if c2 == self.empty_char:\n            return ''  # 某些字符可能渲染成空白，此时返回空串。\n        return c2\n\n\nclass Decoder(object):\n    def __init__(self, data_path, font):\n        self.cache = {}  # 缓存已知的映射关系。\n        OCR.default_config.update(dict(data_path=data_path, font=font))\n        self.ocr_digit = OCR(dict(\n            lang='eng',\n            white_list=string.digits,\n            black_list=string.ascii_letters,\n        ))\n        self.ocr_letter = OCR(dict(\n            lang='eng',\n            black_list=string.digits,\n            white_list=string.ascii_letters,\n        ))\n        self.ocr_other = OCR()\n\n    def decode(self, char):\n        if char not in self.cache:\n            c2 = self._decode_when_cache_miss(char)\n            self.cache[char] = c2 or char\n        return self.cache[char]\n\n    def _decode_when_cache_miss(self, char):\n        ocr = self.ocr_other\n        if char in string.digits:\n            ocr = self.ocr_digit\n        elif char in string.ascii_letters:\n            ocr = self.ocr_letter\n        return ocr.predict(char)\n\n\nif __name__ == '__main__':\n    s = '''你好，青划长务, 8175-13-79'''\n    d = Decoder('tessdata/', 'a.ttf')\n    print(''.join(map(d.decode, s)))\n\n                ", "mainLikeNum": ["6 "], "mainBookmarkNum": "4"}