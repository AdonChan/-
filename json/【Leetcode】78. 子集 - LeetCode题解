{"title": "【Leetcode】78. 子集 - LeetCode题解 ", "index": "leetcode,面试,数据结构和算法,java,python", "content": "题目\n给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。\n说明：解集不能包含重复的子集。\n示例:\n输入: nums = [1,2,3]\n输出:\n[\n  [3],\n  [1],\n  [2],\n  [1,2,3],\n  [1,3],\n  [2,3],\n  [1,2],\n  []\n]\n题解\n全排列，部分排列这些问题都是回溯的题目。这个题目每个状态都是解，包括空list也是解，所以直接都加进去就好。\njava\nclass Solution {\n    public List<List<Integer>> subsets(int[] nums) {\n        List<List<Integer>> list = new ArrayList<>();\n        Arrays.sort(nums);\n        backtrack(list, new ArrayList<>(), nums, 0);\n        return list;\n    }\n\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] nums, int start) {\n        list.add(new ArrayList<>(tempList));\n        for (int i = start; i < nums.length; i++) {\n            tempList.add(nums[i]);\n            backtrack(list, tempList, nums, i + 1);\n            tempList.remove(tempList.size() - 1);\n        }\n    }\n}\npython\nclass Solution:\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        list = []\n        nums.sort()\n        self.bracktrack(list, [], nums, 0)\n        return list\n\n    def bracktrack(self, list, tempList, nums, start):\n        list.append(tempList.copy())\n        for i in range(start, len(nums)):\n            tempList.append(nums[i])\n            self.bracktrack(list, tempList, nums, i + 1)\n            tempList.pop()\n回溯题目汇总\n\n【Leetcode】77. 组合\n【Leetcode】60. 第k个排列\n【Leetcode】47. 全排列 II\n【Leetcode】46.全排列\n\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}