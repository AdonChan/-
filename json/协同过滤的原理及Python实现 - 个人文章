{"title": "协同过滤的原理及Python实现 - 个人文章 ", "index": "python", "content": "提到ALS相信大家应该都不会觉得陌生，它是协同过滤的一种，并被集成到Spark的Mllib库中。本文就ALS的基本原理进行讲解，并手把手、肩并肩地带您实现这一算法。\n完整代码需要的朋友可以加我君羊705673780联系管理，免费获取。\n原理篇\n我们用人话而不是大段的数学公式来讲讲ALS是怎么一回事。\n1.1 你听说过推荐算法么\n假如我是豆瓣的CEO，很多豆瓣的用户在豆瓣电影上都会对电影进行评分。那么根据这个评分数据，我们有可能知道这些用户除了自己评过分的电影之外还喜欢或讨厌哪些电影吗？这就是一个典型的推荐问题，解决这一类问题的算法被称为推荐算法。\n1.2 什么是协同过滤\n协同过滤的英文全称是Collaborative Filtering，简称CF。注意，这不是一款游戏！从字面上分析，协同就是寻找共同点，过滤就是筛选出优质的内容。\n1.3 协同过滤的分类\n一般来说，协同过滤推荐分为三种类型：\n基于用户(user-based)的协同过滤，通过计算用户和用户的相似度找到跟用户A相似的用户B, C, D…再把这些用户喜欢的内容推荐给A；\n2.基于物品(item-based)的协同过滤，通过计算物品和物品的相似度找到跟物品1相似的物品2, 3, 4…再把这些物品推荐给看过物品1的用户们；\n基于模型(model based)的协同过滤。主流的方法可以分为：矩阵分解，关联算法，聚类算法，分类算法，回归算法，神经网络。\n1.4 矩阵分解\n矩阵分解 (decomposition, factorization)是将矩阵拆解为数个矩阵的乘积。比如豆瓣电影有m个用户，n个电影。那么用户对电影的评分可以形成一个m行n列的矩阵R，我们可以找到一个m行k列的矩阵U，和一个k行n列的矩阵I，通过U * I来得到矩阵R。\n1.5 ALS\n如果想通过矩阵分解的方法实现基于模型的协同过滤，ALS是一个不错的选择，其英文全称是Alternating Least Square，翻译过来是交替最小二乘法。假设用户为a，物品为b，评分矩阵为R(m, n)，可分解为用户矩阵U(k, m)和物品矩阵I(k, n)，其中m, n, k代表矩阵的维度。前方小段数学公式低能预警：\n\n1.6 求解用户矩阵U和物品矩阵I\n矩阵R是已知的，我们随机生成用户矩阵U， 1. 利用1.5中的式5、R和U求出I 2. 利用1.5中的式6、R和I求出U\n如此交替地执行步骤1和步骤2，直到算法收敛或者迭代次数超过了最大限制，最终我们用RMSE来评价模型的好坏。\n实现篇\n本人用全宇宙最简单的编程语言——Python实现了ALS算法，没有依赖任何第三方库，便于学习和使用。简单说明一下实现过程，更详细的注释请参考本人github上的代码。\n注：代码中用到的Matrix类是我写的一个矩阵类，可以取出矩阵的行或列，计算矩阵的乘法、转置和逆。代码链接：matrix.py\n2.1 创建ALS类\n初始化，存储用户ID、物品ID、用户ID与用户矩阵列号的对应关系、物品ID与物品矩阵列号的对应关系、用户已经看过哪些物品、评分矩阵的Shape以及RMSE。\nclassALS(object):\n\ndef__init__(self):\n\nself.user_ids =None\n\nself.item_ids =None\n\nself.user_ids_dict =None\n\nself.item_ids_dict =None\n\nself.user_matrix =None\n\nself.item_matrix =None\n\nself.user_items =None\n\nself.shape =None\n\nself.rmse =None\n\n2.2 数据预处理\n对训练数据进行处理，得到用户ID、物品ID、用户ID与用户矩阵列号的对应关系、物品ID与物品矩阵列号的对应关系、评分矩阵的Shape、评分矩阵及评分矩阵的转置。\ndef _process_data(self, X):\n\nself.user_ids = tuple((set(map(lambda x: x[0], X))))\n\nself.user_ids_dict = dict(map(lambda x: x[::-1],\n\nenumerate(self.user_ids)))\n\nself.item_ids = tuple((set(map(lambda x: x[1], X))))\n\nself.item_ids_dict = dict(map(lambda x: x[::-1],\n\nenumerate(self.item_ids)))\n\nself.shape = (len(self.user_ids),len(self.item_ids))\n\nratings = defaultdict(lambda: defaultdict(int))\n\nratings_T = defaultdict(lambda: defaultdict(int))\n\nforrowinX:\n\nuser_id, item_id, rating =row\n\nratings[user_id][item_id] = rating\n\nratings_T[item_id][user_id] = rating\n\nerr_msg =\"Length of user_ids %d and ratings %d not match!\"% (\n\nlen(self.user_ids),len(ratings))\n\nassertlen(self.user_ids) ==len(ratings), err_msg\n\nerr_msg =\"Length of item_ids %d and ratings_T %d not match!\"% (\n\nlen(self.item_ids),len(ratings_T))\n\nassertlen(self.item_ids) ==len(ratings_T), err_msg\n\nreturnratings, ratings_T\n\n2.3 用户矩阵乘以评分矩阵\n实现稠密矩阵与稀疏矩阵的矩阵乘法，得到用户矩阵与评分矩阵的乘积。\ndef_users_mul_ratings(self, users, ratings_T):\n\ndeff(users_row, item_id):\n\nuser_ids = iter(ratings_T[item_id].keys())\n\nscores = iter(ratings_T[item_id].values())\n\ncol_nos = map(lambdax:self.user_ids_dict[x], user_ids)\n\n_users_row = map(lambdax:users_row[x], col_nos)\n\nreturnsum(a * bfora, binzip(_users_row, scores))\n\nret = [[f(users_row, item_id)foritem_idinself.item_ids]\n\nforusers_rowinusers.data]\n\nreturnMatrix(ret)\n\n2.4 物品矩阵乘以评分矩阵\n实现稠密矩阵与稀疏矩阵的矩阵乘法，得到物品矩阵与评分矩阵的乘积。\ndef_items_mul_ratings(self, items, ratings):\n\ndeff(items_row, user_id):\n\nitem_ids = iter(ratings[user_id].keys())\n\nscores = iter(ratings[user_id].values())\n\ncol_nos = map(lambdax:self.item_ids_dict[x], item_ids)\n\n_items_row = map(lambdax:items_row[x], col_nos)\n\nreturnsum(a * bfora, binzip(_items_row, scores))\n\nret = [[f(items_row, user_id)foruser_idinself.user_ids]\n\nforitems_rowinitems.data]\n\nreturnMatrix(ret)\n\n2.5 生成随机矩阵\ndef_gen_random_matrix(self, n_rows, n_colums):\n\ndata = [[random()for_inrange(n_colums)]for_inrange(n_rows)]\n\nreturnMatrix(data)\n\n2.6 计算RMSE\ndef_get_rmse(self, ratings):\n\nm, n = self.shape\n\nmse = 0.0\n\nn_elements = sum(map(len, ratings.values()))\n\nfor i in range(m):\n\nfor j in range(n):\n\nuser_id = self.user_ids[i]\n\nitem_id = self.item_ids[j]\n\nrating = ratings[user_id][item_id]\n\nif rating > 0:\n\nuser_row = self.user_matrix.col(i).transpose\n\nitem_col = self.item_matrix.col(j)\n\nrating_hat = user_row.mat_mul(item_col).data[0][0]\n\nsquare_error = (rating - rating_hat) ** 2\n\nmse += square_error / n_elements\n\nreturn mse ** 0.5\n\n2.7 训练模型\n1.数据预处理\n2.变量k合法性检查\n3.生成随机矩阵U\n4.交替计算矩阵U和矩阵I，并打印RMSE信息，直到迭代次数达到max_iter\n5.保存最终的RMSE\ndeffit(self, X, k, max_iter=10):\n\nratings, ratings_T =self._process_data(X)\n\nself.user_items = {k:set(v.keys())fork, vinratings.items()}\n\nm, n =self.shape\n\nerror_msg =\"Parameter k must be less than the rank of original matrix\"\n\nassert k < min(m, n), error_msg\n\nself.user_matrix =self._gen_random_matrix(k, m)\n\nforiinrange(max_iter):\n\nifi %2:\n\nitems =self.item_matrix\n\nself.user_matrix =self._items_mul_ratings(\n\nitems.mat_mul(items.transpose).inverse.mat_mul(items),\n\nratings\n\n)\n\nelse:\n\nusers =self.user_matrix\n\nself.item_matrix =self._users_mul_ratings(\n\nusers.mat_mul(users.transpose).inverse.mat_mul(users),\n\nratings_T\n\n)\n\nrmse =self._get_rmse(ratings)\n\nprint(\"Iterations: %d, RMSE: %.6f\"% (i +1, rmse))\n\nself.rmse = rmse\n\n2.8 预测一个用户\n预测一个用户感兴趣的内容，剔除用户已看过的内容。然后按感兴趣分值排序，取出前n_items个内容。\ndef_predict(self, user_id, n_items):\n\nusers_col =self.user_matrix.col(self.user_ids_dict[user_id])\n\nusers_col = users_col.transpose\n\nitems_col = enumerate(users_col.mat_mul(self.item_matrix).data[0])\n\nitems_scores = map(lambdax:(self.item_ids[x[0]], x[1]), items_col)\n\nviewed_items =self.user_items[user_id]\n\nitems_scores = filter(lambdax:x[0]notinviewed_items, items_scores)\n\nreturnsorted(items_scores, key=lambdax:x[1], reverse=True)[:n_items]\n\n2.9 预测多个用户\n循环调用2.8，预测多个用户感兴趣的内容。\ndefpredict(self, user_ids, n_items=10):\n\nreturn[self._predict(user_id, n_items)foruser_idinuser_ids]\n\n3 效果评估\n3.1 main函数\n使用电影评分数据集，训练模型并统计RMSE。\n@run_time\n\ndefmain():\n\nprint(\"Tesing the accuracy of ALS...\")\n\nX = load_movie_ratings()\n\nmodel = ALS()\n\nmodel.fit(X, k=3, max_iter=5)\n\nprint()\n\nprint(\"Showing the predictions of users...\")\n\nuser_ids = range(1,5)\n\npredictions = model.predict(user_ids, n_items=2)\n\nforuser_id, predictioninzip(user_ids, predictions):\n\n_prediction = [format_prediction(item_id, score)\n\nforitem_id, scoreinprediction]\n\nprint(\"User id:%d recommedation: %s\"% (user_id, _prediction))\n\n3.2 效果展示\n设置k=3，迭代5次，并展示了前4个用户的推荐内容，最终RMSE为0.370，运行时间46.5秒，效果还算不错~\n\n3.3 工具函数\n本人自定义了一些工具函数，可以在github上查看\n1.run_time - 测试函数运行时间\n2.load_movie_ratings - 加载电影评分数据\n总结\nALS的原理：鸡生蛋、蛋生鸡\nALS的实现：基本上就是矩阵乘法\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}