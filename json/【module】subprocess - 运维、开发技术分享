{"title": "【module】subprocess - 运维、开发技术分享 ", "index": "python", "content": "subprocess\nsubprocess模块是python从2.4版本开始引入的模块。主要用来取代 一些旧的模块方法，如os.system、os.spawn、os.popen、commands.*等subprocess通过子进程来执行外部指令，并通过input/output/error管道，获取子进程的执行的返回信息。\n使用方法：\n运行外部命令：subprocess.call（command）\nsubprocess的call方法可以用于执行一个外部命令，但该方法不能返回执行的结果，只能返回执行的状态码： 成功（0） 或 错误（非0）\n方法一：\nsubprocess.call(['ls','-l'])\n总用量 4\n-rw-r--r-- 1 liangml liangml  0 3月   7 15:38 mark.md\n-rw-r--r-- 1 liangml liangml 68 3月  11 13:39 php-fpm.py\n0\n方法二：\nsubprocess.call(\"ls -l\",shell=True)\n总用量 4\n-rw-r--r-- 1 liangml liangml  0 3月   7 15:38 mark.md\n-rw-r--r-- 1 liangml liangml 68 3月  11 13:39 php-fpm.py\n0\n\n上面示例是在终端中运行，虽然可以看到运行结果，但实际取值只是状态码\na = subprocess.call(\"ls -l\",shell=True)\n总用量 4\n-rw-r--r-- 1 liangml liangml  0 3月   7 15:38 mark.md\n-rw-r--r-- 1 liangml liangml 81 3月  11 13:44 php-fpm.py\nprint(a)\n0\n错误处理：subprocess.check_call（）\n我们说过call执行返回一个状态码,我们可以通过check_call()函数来检测命令的执行结果，如果不成功将返回 subprocess.CalledProcessError 异常\n示例：\nimport subprocess\ntry:\n    subprocess.check_call(\"sdf\",shell=True)\nexcept subprocess.CalledProcessError as err:\n    print(\"Command Error\"，err)\n捕获输出结果：subprocess.check_output（）\ncall()方法启动的进程，其标准输入输出会绑定到父进程的输入和输出。调用程序无法获取命令的输出结果。但可以通过check_output()方法来捕获输出。\n示例：\noutput = subprocess.check_output(\"ls -l\",shell=True)\nprint(output.decode('utf-8'))\nimport subprocess\ntry:\n    output = subprocess.check_output(\"lT -l\",shell=True,stderr=subprocess.STDOUT)\nexcept subprocess.CalledProcessError as err:\n    print(\"Command Error\",err)\n#执行结果\nCommand Error Command 'lT -l' returned non-zero exit status 127\n直接处理管道：subprocess.Popen（）\n函数call(), check_call() 和  check_output() 都是Popen类的包装器。直接使用Popen会对如何运行命令以及如何处理其输入输出有更多控制。如通过为stdin, stdout和stderr传递不同的参数。\n与进程的单向通信：通过Popen()方法调用命令后执行的结果,可以设置stdout值为PIPE，再调用communicate()获取结果,返回结果为tuple. 在python3中结果为byte类型，要得到str类型需要decode转换一下\n输出结果（读）\n# 直接执行命令输出到屏幕\n>>> subprocess.Popen(\"ls -l\",shell=True)\n<subprocess.Popen object at 0x7fe38cd67f98>\n总用量 4\n-rw-r--r-- 1 liangml liangml  0 3月   7 15:38 mark.md\n-rw-r--r-- 1 liangml liangml 76 3月  11 13:59 php-fpm.py\n# 不输出到屏幕，输出到变量\n>>> proc = subprocess.Popen(['echo','\"Stdout\"'],stdout=subprocess.PIPE)\n# communicate返回标准输出或标准出错信息\n>>> stdout_value = proc.communicate()\n>>> stdout_value\n(b'\"Stdout\"\\n', None)\n\n\n\n>>> proc = subprocess.Popen(['ls','-l'],stdout=subprocess.PIPE)\n>>> stdout_value = proc.communicate()\n>>> stdout_value\n(b'\\xe6\\x80\\xbb\\xe7\\x94\\xa8\\xe9\\x87\\x8f 48\\ndrwxr-xr-x  3 liangml liangml 4096 3\\xe6\\x9c\\x88  10 14:57 Desktop\\ndrwxr-xr-x  6 liangml liangml 4096 3\\xe6\\x9c\\x88   4 22:00 Documents\\ndrwxr-xr-x  2 liangml liangml 4096 3\\xe6\\x9c\\x88   8 18:32 Downloads\\ndrwxr-xr-x  3 liangml liangml 4096 3\\xe6\\x9c\\x88   3 11:10 GitBook\\ndrwxr-xr-x  3 liangml liangml 4096 2\\xe6\\x9c\\x88  22 17:52 Music\\ndrwxr-xr-x  3 liangml liangml 4096 2\\xe6\\x9c\\x88  22 17:48 Pictures\\ndrwxr-xr-x  3 liangml liangml 4096 2\\xe6\\x9c\\x88  26 18:29 PycharmProjects\\ndrwxr-xr-x  3 liangml liangml 4096 2\\xe6\\x9c\\x88  22 18:01 Steam\\ndrwxr-xr-x 10 liangml liangml 4096 2\\xe6\\x9c\\x88  27 11:21 svn\\ndrwxr-xr-x  2 liangml liangml 4096 2\\xe6\\x9c\\x88  22 17:48 Templates\\ndrwxr-xr-x  2 liangml liangml 4096 2\\xe6\\x9c\\x88  22 17:24 Videos\\ndrwxr-xr-x  3 liangml liangml 4096 3\\xe6\\x9c\\x88   7 21:00 vnote_notebooks\\n', None)\n\n\n\n\n# 结果输出到文件\n>>> file_handle = open('/home/liangml/t.log','w+')\n>>> subprocess.Popen('ls -l',shell=True,stdout=file_handle)\n>>> subprocess.call(\"ls -l\",shell=True)\n总用量 52\n-rw-r--r--  1 liangml liangml  779 3月  11 14:14 t.log\nvnote_notebooks\n与进程的双向通信\nproc = subprocess.Popen('cat', shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE)\nmsg = 'hello world'.encode('utf-8')\n# 写入到输入管道\nproc.stdin.write(msg)\n11  # 输入结果\nstdout_value = proc.communicate()\nstdout_value\n(b'hello world', None)  # 输出结果\n\n# 在需要进行相互交互的输入输出过程也可以使用shtin来实现\n# 以下实现打开python3的终端，执行一个print命令\nproc = subprocess.Popen(['python3'],stdin=subprocess.PIPE,stdout=subprocess.PIPE, stderr=subprocess.PIPE,)\nproc.stdin.write('print(\"helloworld\")'.encode('utf-8'))\nout_value,err_value=proc.communicate()\nprint(out_value)\nb'helloworld\\n'\nprint(err_value)\nb''\nPopen.communicate()方法用于和子进程交互：发送数据到stdin，并从stdout和stderr读数据，直到收到EOF。等待子进程结束。\n捕获错误输出\nproc = subprocess.Popen(['python3'],stdin=subprocess.PIPE,stdout=subprocess.PIPE, stderr=subprocess.PIPE,)\nproc.stdin.write('print \"helloworld\"'.encode('utf-8'))\n18\nout_value,err_value=proc.communicate()\nout_value\nb''\nprint(err_value.decode('utf-8'))\n  File \"<stdin>\", line 1\n    print \"helloworld\"\n                     ^\nSyntaxError: Missing parentheses in call to 'print'\nPopen其他方法\n\nPopen.pid 查看子进程ID\nPopen.returncode 获取子进程状态码，0表示子进程结束，None未结束\n\n在使用Popen调用系统命令式，建议使用communicate与stdin进行交互并获取输出（stdout），这样能保证子进程正常退出而避免出现僵尸进程：\n示例：\nproc = subprocess.Popen('ls -l', shell=True, stdout=subprocess.PIPE)\n# 当前子进程ID\nproc.pid\n5919\n# 返回状态None，进程未结束\nprint(proc.returncode)\nNone\n# 通过communicate提交后\nout_value = proc.communicate()\nproc.pid\n5919\n# 返回状态为0，子进程自动结束\nprint(proc.returncode)\n0\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}