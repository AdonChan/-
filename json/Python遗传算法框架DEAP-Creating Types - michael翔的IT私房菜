{"title": "Python遗传算法框架DEAP-Creating Types - michael翔的IT私房菜 ", "index": "机器学习,数据挖掘,python", "content": "DEAP是一个python遗传算法框架，这里是它的简介。DEAP documentation今天整理一下DEAP的概览，大体了解一下它的流程。初学，不严谨，仅作为自己的备忘学习笔记。\nThis tutorial shows how types are created using the creator and initialized using the toolbox.这个教程展示的是使用creator创建类型和使用toolbox初始化。\nFitness（适应度）\nThe provided Fitness class is an abstract class that needs a weights attribute in order to be functional. A minimizing fitness is built using negatives weights, while a maximizing fitness has positive weights. For example, the following line creates, in the creator, a ready to use single objective minimizing fitness named FitnessMin.Fitness类提供了weight属性。最小化问题使用负值的的weight,最大化问题用正值。例如下面的例子，利用creator，创建了一个单目标最小问题，命名为：FitnessMin。\ncreator.create(\"FitnessMin\", base.Fitness, weights=(-1.0,))\nAs specified in the Fitness documentation, the weights attribute must be a tuple so that multi-objective and single objective fitnesses can be treated the same way. A FitnessMulti would be created the same way but using:正如在library中叙述，这个weight属性必须是以tuple的形式给出，如果创建的是多目标问题，可以参考下面例子：\ncreator.create(\"FitnessMulti\", base.Fitness, weights=(-1.0, 1.0))\n可见，是一个多目标，一个最小值，一个最大值。An example of where the weights can be useful is in the crowding distance sort made in the NSGA-II selection algorithm.weight属性的使用可以参考使用NSGA-II选择算法进行拥挤距离排序的例子中。\nIndividual（个体）\nList of Floats\nThe first individual created will be a simple list containing floats. In order to produce this kind of individual, we need to create an Individual class, using the creator, that will inherit from the standard list type and have a fitness attribute第一个个体是个包含浮点数的简单列表。为了创造这样的个体，我们需要创建一个Individual类，使用creator，这个将会继承标准list类型，并拥有一个fitness属性。\nimport random\n\nfrom deap import base\nfrom deap import creator\nfrom deap import tools\n\ncreator.create(\"FitnessMax\", base.Fitness, weights=(1.0,))\ncreator.create(\"Individual\", list, fitness=creator.FitnessMax)\n\nIND_SIZE=10\n\ntoolbox = base.Toolbox()\ntoolbox.register(\"attr_float\", random.random)\ntoolbox.register(\"individual\", tools.initRepeat, creator.Individual,\n                 toolbox.attr_float, n=IND_SIZE)\nThe newly introduced register() method takes at least two arguments; an alias and a function assigned to this alias. Any subsequent argument is passed to the function when called (à la functools.partial()). Thus, the preceding code creates two aliases in the toolbox; attr_float and individual.新引进的register方法需要至少两个参数。一个别名，一个赋予到这个别名的函数。当被调用时，随后的参数都被传进给这个函数。因此，前面的代码在toolbox中创建了两个别名函数attr_float和individual。\nThe first one redirects to the random.random() function. The second one is a shortcut to the initRepeat() function, fixing its container argument to the creator.Individual class, its func argument to the toolbox.attr_float() function, and its number of repetitions argument to IND_SIZE.第一个函数指向random.random函数。第二个指向initRepeat函数，向creator固定了它的容器参数。Individual类的函数参数是attr_float函数，和它的重复数参数IND_SIZE。\nNow, calling toolbox.individual() will call initRepeat() with the fixed arguments and return a complete creator.Individual composed of IND_SIZE floating point numbers with a maximizing single objective fitness attribute.现在调用toolbox.individual()函数将会使用固定参数调用initRepeat()，返回完整的creator.Individual(由IND_SIZE个浮点数组成，有一个最大化单目标fitness attribute)。\n略\nPopulation（种群）\nPopulations are much like individuals. Instead of being initialized with attributes, they are filled with individuals, strategies or particles.种群横线个体。它不像个体一样，有很多attribute，种群是由很多个体、策略、粒子组成的。\nBag\nA bag population is the most commonly used type. It has no particular ordering although it is generally implemented using a list. Since the bag has no particular attribute, it does not need any special class. The population is initialized using the toolbox and the initRepeat() function directly.背包种群是最常使用的类型。它没有特定的顺序虽然通常使用列表来实现。因为背包没特定的属性，它不需要任何特殊的类。这个种群是直接使用toolbox和initRepeat()函数来初始化的。\ntoolbox.register(\"population\", tools.initRepeat, list, toolbox.individual)\nCalling toolbox.population() will readily return a complete population in a list, providing a number of times the repeat helper must be repeated as an argument of the population function. The following example produces a population with 100 individuals.调用toolbox.population()将会返回一个完整的列表形式的种群，提供重复次数是种群函数的参数。下面例子生产了100个个体：\ntoolbox.population(n=100)\n\nGrid(网格）\nA grid population is a special case of structured population where neighbouring individuals have a direct effect on each other. The individuals are distributed in the grid where each cell contains a single individual. However, its implementation only differs from the list of the bag population, in that it is composed of lists of individuals.网格种群是一个特殊结构种群的例子，相邻的个体对彼此有直接的影响。个体之间分布在网格中（每个格子包含一个个体）。然而，它的实现只和和背包种群的列表不同--它是由个体们的列表组成的。\ntoolbox.register(\"row\", tools.initRepeat, list, toolbox.individual, n=N_COL)\ntoolbox.register(\"population\", tools.initRepeat, list, toolbox.row, n=N_ROW)\nCalling toolbox.population() will readily return a complete population where the individuals are accessible using two indices, for example popr. 调用toolbox.population将会返回一个种群，个体是使用两个索引可获得的。例如:pop[r][c]。\n略。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "4"}