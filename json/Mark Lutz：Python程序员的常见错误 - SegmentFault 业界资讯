{"title": "Mark Lutz：Python程序员的常见错误 - SegmentFault 业界资讯 ", "index": "python", "content": "译注：Mark Lutz 是《Learning Python | 学习Python》的作者之一。\n\n在这篇文章中，我将总结新老Python程序员常犯的一些错误，以帮助你们在自己的工作避免犯同样或类似错误。\n\n首先我要说明一下的是，这些都是来源于第一手的经验。我以讲授Python的知识为生。在过去的7年里，我已经给上千名学生讲授上百堂Python的课程，同时看着这些学生们犯同样的错。也就是说，这些是我看着Python初学者活生生犯的错，千百次的错。事实上，这些错误实在是太普遍了以至于我敢保证你刚开始学的时候是一定会犯的。\n\n“那么是什么呢？”你会问，“你也会在Python里犯那么多错么？”是的。Python可能是最简单、最灵活的语言之一，但它终究还是一门编程语言。它仍然有语法，数据类型，以及巫师蒂姆居住的黑暗角落。\n\n（典故出自《蒙蒂派森与圣杯》中的魔法师蒂姆，他主角们指点在洞穴的墙壁上记录的圣杯位置，作者在此处的意思是Python语言里容易犯错的地方。另，Python语言得名于作者Guido van Rossum特别喜欢的《蒙蒂派森飞行马戏团（Monty Python’s Flying Circus）》——译者注）\n\n好事情是多亏了Python那干净的设计，一旦你学会了Python，你就能自动的避开很多陷阱。Python在其各组件之间有着最小的互动，这能有效的减少bug。它也拥有十分简单的语法，这意味着在一开始你就有更小的概率犯错。当你实在是犯了错的时候，Python的即时错误检测和报告能帮你迅速的恢复。\n\n但用Python编程也不是个自动完成的活儿，很多事还是要早做准备。那么废话不多说了，让我们直切正题。在接下来的三节里我们将这些错误分为语用、代码，以及编程三个大类。如果你想读到更多的Python的常见错误以及如何避免它们，那么在O’Reilly系列丛书的《Learning Python》里有详细的解读。（译注：Learning Python 已经是第五版了）\n\n语用错误\n\n让我们从基础开始，从那些刚学习编程的人钻研语法之前碰到的事情开始。如果你已经编过一些程了，那么以下这些可能看起来十分的简单；如果你曾经尝试过教新手们怎么编程，它们可能就不这么简单了。\n\n在交互提示符中输入Python代码\n\n在>>>交互提示符中你只能输入Python代码，而不是系统命令。时常有人在这个提示符下输入emacs，ls，或者edit之类的命令，这些可不是Python代码。在Python代码中确实有办法来调用系统命令（例如os.system和os.popen），但可不是像直接输入命令这么直接。如果你想要在交互提示符中启动一个Python文件，请用import file，而不是系统命令python file.py。\n\nPrint语句（仅仅）是在文件中需要\n\n因为交互解释器会自动的讲表达式的结果输出，所以你不需要交互的键入完整的print语句。这是个很棒的功能，但是记住在代码文件里，通常你只有用print语句才能看得到输出。\n\n小心Windows里的自动扩展名\n\n如果你在Windows里使用记事本来编辑代码文件的话，当你保持的时候小心选择“所有文件”（All Files）这个类型，并且明确的给你的文件加一个.py的后缀。不然的话记事本会给你的文件加一个.txt的扩展名，使得在某些启动方法中没法跑这个程序。更糟糕的是，像Word或者是写字板一类的文字处理软件还会默认的加上一些格式字符，而这些字符Python语法是不认的。所以记得，在Windows下总是选“所有文件”（All Files），并保存为纯文本，或者使用更加“编程友好”的文本编辑工具，比如IDLE。在IDLE中，记得在保存时手动加上.py的扩展名。\n\n在Windows下点击图标的问题\n\n在Windows下，你能靠点击Python文件来启动一个Python程序，但这有时会有问题。首先，程序的输出窗口在程序结束的瞬间也就消失了，要让它不消失，你可以在文件最后加一条raw_input()的调用。另外，记住如果有错的话，输出窗口也就立即消失了。要看到你的错误信息的话，用别的方法来调用你的程序：比如从系统命令行启动，通过提示符下用import语句，或者IDLE菜单里的选项，等等。\n\nImport只在第一次有效\n\n你可以在交互提示符中通过import一个文件来运行它，但是这只会在一个会话中起一次作用；接下来的import仅仅是返回这个已经加载的模块。要想强制Python重新加载一个文件的代码，请调用函数reload(module)来达到这个目的。注意对reload请使用括号，而import不要使用括号。\n\n空白行（仅仅）在交互提示符中有作用\n\n在模块文件中空白行和注释统统会被忽略掉，但是在交互提示符中键入代码时，空白行表示一个复合语句的结束。换句话说，空白行告诉交互提示符你完成了一个复合语句；在你真正完成之前不要键入回车。事实上当你要开始一个新的语句时，你需要键入一个空行来结束当前的语句——交互提示符一次只运行一条语句。\n\n代码错误\n\n一旦你开始认真写Python代码了，接下来了一堆陷阱就更加危险了——这些都是一些跨语言特性的基本代码错误，并常常困扰不细心的程序员。\n\n别忘了冒号\n\n这是新手程序员最容易犯的一个错误：别忘了在复合语句的起始语句（if，while， for等语句的第一行）结束的地方加上一个冒号“：”。也许你刚开始会忘掉这个，但是到了很快这就会成为一个下意识的习惯。课堂里75%的学生当天就可以记住这个。\n\n初始化变量\n\n在Python里，一个表达式中的名字在它被赋值之前是没法使用的。这是有意而为的：这样能避免一些输入失误，同时也能避免默认究竟应该是什么类型的问题（0，None，””，[]，?）。记住把计数器初始化为0，列表初始化为[]，以此类推。\n\n从第一列开始\n\n确保把顶层的，未嵌套的代码放在最左边第一列开始。这包括在模块文件中未嵌套的代码，以及在交互提示符中未嵌套的代码。Python使用缩进的办法来区分嵌套的代码段，因此在你代码左边的空格意味着嵌套的代码块。除了缩进以外，空格通常是被忽略掉的。\n\n缩进一致\n\n在同一个代码块中避免讲tab和空格混用来缩进，除非你知道运行你的代码的系统是怎么处理tab的。否则的话，在你的编辑器里看起来是tab的缩进也许Python看起来就会被视作是一些空格。保险起见，在每个代码块中全都是用tab或者全都是用空格来缩进；用多少由你决定。\n\n在函数调用时使用括号\n\n无论一个函数是否需要参数，你必须要加一对括号来调用它。即，使用function()，而不是function。Python的函数简单来说是具有特殊功能（调用）的对象，而调用是用括号来触发的。像所有的对象一样，他们也可以被赋值给变量，并且间接的使用他们：x=function:x()。\n在Python的培训中，这样的错误常常在文件的操作中出现。通常会看到新手用file.close来关闭一个问题，而不是用file.close()。因为在Python中引用一个函数而不调用它是合法的，因此不使用括号的操作（file.close）无声的成功了，但是并没有关闭这个文件！\n\n在Import时不要使用表达式或者路径\n\n在系统的命令行里使用文件夹路径或者文件的扩展名，但不要在import语句中使用。即，使用import mod，而不是import mod.py，或者import dir/mod.py。在实际情况中，这大概是初学者常犯的第二大错误了。因为模块会有除了.py以为的其他的后缀（例如，.pyc），强制写上某个后缀不仅是不合语法的，也没有什么意义。\n和系统有关的目录路径的格式是从你的模块搜索路径的设置里来的，而不是import语句。你可以在文件名里使用点来指向包的子目录（例如，import dir1.dir2.mod），但是最左边的目录必须得通过模块搜索路径能够找到，并且没有在import中没有其他路径格式。不正确的语句import mod.py被Python认为是要记在一个包，它先加载一个模块mod，然后试图通过在一个叫做mod的目录里去找到叫做py的模块，最后可能什么也找不到而报出一系列费解的错误信息。\n\n不要在Python中写C代码\n\n以下是给不熟悉Python的C程序员的一些备忘贴士：\n\n\n在if和while中条件测试时，不用输入括号（例如，if (X==1):）。如果你喜欢的话，加上括号也无妨，只是在这里是完全多余的。\n不要用分号来结束你的语句。从技术上讲这在Python里是合法的，但是这毫无用处，除非你要把很多语句放在同一行里（例如，x=1; y=2; z=3）。\n不要在while循环的条件测试中嵌入赋值语句（例如，while ((x=next() != NULL)）。在Python中，需要表达式的地方不能出现语句，并且赋值语句不是一个表达式。\n\n编程错误\n\n下面终于要讲到当你用到更多的Python的功能（数据类型，函数，模块，类等等）时可能碰到的问题了。由于篇幅有限，这里尽量精简，尤其是对一些高级的概念。要想了解更多的细节，敬请阅读Learning Python, 2nd Edition的“小贴士”以及“Gotchas”章节。\n\n打开文件的调用不使用模块搜索路径\n\n当你在Python中调用open()来访问一个外部的文件时，Python不会使用模块搜索路径来定位这个目标文件。它会使用你提供的绝对路径，或者假定这个文件是在当前工作目录中。模块搜索路径仅仅为模块加载服务的。\n\n不同的类型对应的方法也不同\n\n列表的方法是不能用在字符串上的，反之亦然。通常情况下，方法的调用是和数据类型有关的，但是内部函数通常在很多类型上都可以使用。举个例子来说，列表的reverse方法仅仅对列表有用，但是len函数对任何具有长度的对象都适用\n\n不能直接改变不可变数据类型\n\n记住你没法直接的改变一个不可变的对象（例如，元组，字符串）：\n\nT = (1, 2, 3)\nT[2] = 4          # 错误\n\n\n用切片，联接等构建一个新的对象，并根据需求将原来变量的值赋给它。因为Python会自动回收没有用的内存，因此这没有看起来那么浪费：\n\nT = T[:2] + (4,)  # 没问题了: T 变成了 (1, 2, 4)\n\n\n使用简单的for循环而不是while或者range\n\n当你要从左到右遍历一个有序的对象的所有元素时，用简单的for循环（例如，for x in seq:）相比于基于while-或者range-的计数循环而言会更容易写，通常运行起来也更快。除非你一定需要，尽量避免在一个for循环里使用range：让Python来替你解决标号的问题。在下面的例子中三个循环结构都没有问题，但是第一个通常来说更好；在Python里，简单至上。\n\nS = \"lumberjack\"\n\nfor c in S: print c                   # 最简单\n\nfor i in range(len(S)): print S[i]    # 太多了\n\ni = 0                                 # 太多了\nwhile i < len(S): print S[i]; i += 1\n\n\n不要试图从那些会改变对象的函数得到结果\n\n诸如像方法list.append()和list.sort()一类的直接改变操作会改变一个对象，但不会将它们改变的对象返回出来（它们会返回None）；正确的做法是直接调用它们而不要将结果赋值。经常会看见初学者会写诸如此类的代码：\n\nmylist = mylist.append(X)\n\n\n目的是要得到append的结果，但是事实上这样做会将None赋值给mylist，而不是改变后的列表。更加特别的一个例子是想通过用排序后的键值来遍历一个字典里的各个元素，请看下面的例子：\n\nD = {...}\nfor k in D.keys().sort(): print D[k]\n\n\n差一点儿就成功了——keys方法会创建一个keys的列表，然后用sort方法来将这个列表排序——但是因为sort方法会返回None，这个循环会失败，因为它实际上是要遍历None（这可不是一个序列）。要改正这段代码，将方法的调用分离出来，放在不同的语句中，如下：\n\nKs = D.keys()\nKs.sort()\nfor k in Ks: print D[k]\n\n\n只有在数字类型中才存在类型转换\n\n在Python中，一个诸如123+3.145的表达式是可以工作的——它会自动将整数型转换为浮点型，然后用浮点运算。但是下面的代码就会出错了：\n\nS = \"42\"\nI = 1\nX = S + I        # 类型错误\n\n\n这同样也是有意而为的，因为这是不明确的：究竟是将字符串转换为数字（进行相加）呢，还是将数字转换为字符串（进行联接）呢？在Python中，我们认为“明确比含糊好”（即，EIBTI（Explicit is better than implicit）），因此你得手动转换类型：\n\nX = int(S) + I   # 做加法: 43\nX = S + str(I)   # 字符串联接: \"421\"\n\n\n循环的数据结构会导致循环\n\n尽管这在实际情况中很少见，但是如果一个对象的集合包含了到它自己的引用，这被称为循环对象（cyclic object）。如果在一个对象中发现一个循环，Python会输出一个[…]，以避免在无限循环中卡住：\n\n>>> L = ['grail']  # 在 L中又引用L自身会\n>>> L.append(L)    # 在对象中创造一个循环\n>>> L\n['grail', [...]]\n\n\n除了知道这三个点在对象中表示循环以外，这个例子也是很值得借鉴的。因为你可能无意间在你的代码中出现这样的循环的结构而导致你的代码出错。如果有必要的话，维护一个列表或者字典来表示已经访问过的对象，然后通过检查它来确认你是否碰到了循环。\n赋值语句不会创建对象的副本，仅仅创建引用\n\n这是Python的一个核心理念，有时候当行为不对时会带来错误。在下面的例子中，一个列表对象被赋给了名为L的变量，然后L又在列表M中被引用。内部改变L的话，同时也会改变M所引用的对象，因为它们俩都指向同一个对象。\n\n>>> L = [1, 2, 3]        # 共用的列表对象\n>>> M = ['X', L, 'Y']    # 嵌入一个到L的引用\n>>> M\n['X', [1, 2, 3], 'Y']\n\n>>> L[1] = 0             # 也改变了M\n>>> M\n['X', [1, 0, 3], 'Y']\n\n\n通常情况下只有在稍大一点的程序里这就显得很重要了，而且这些共用的引用通常确实是你需要的。如果不是的话，你可以明确的给他们创建一个副本来避免共用的引用；对于列表来说，你可以通过使用一个空列表的切片来创建一个顶层的副本：\n\n>>> L = [1, 2, 3]\n>>> M = ['X', L[:], 'Y']   # 嵌入一个L的副本\n\n>>> L[1] = 0               # 仅仅改变了L，但是不影响M\n>>> L\n[1, 0, 3]\n>>> M\n['X', [1, 2, 3], 'Y']\n\n\n切片的范围起始从默认的0到被切片的序列的最大长度。如果两者都省略掉了，那么切片会抽取该序列中的所有元素，并创造一个顶层的副本（一个新的，不被公用的对象）。对于字典来说，使用字典的dict.copy()方法。\n\n静态识别本地域的变量名\n\nPython默认将一个函数中赋值的变量名视作是本地域的，它们存在于该函数的作用域中并且仅仅在函数运行的时候才存在。从技术上讲，Python是在编译def代码时，去静态的识别本地变量，而不是在运行时碰到赋值的时候才识别到的。如果不理解这点的话，会引起人们的误解。比如，看看下面的例子，当你在一个引用之后给一个变量赋值会怎么样：\n\n>>> X = 99\n>>> def func():\n...     print X      # 这个时候还不存在\n...     X = 88       # 在整个def中将X视作本地变量\n...\n>>> func( )          # 出错了！\n\n\n你会得到一个“未定义变量名”的错误，但是其原因是很微妙的。当编译这则代码时，Python碰到给X赋值的语句时认为在这个函数中的任何地方X会被视作一个本地变量名。但是之后当真正运行这个函数时，执行print语句的时候，赋值语句还没有发生，这样Python便会报告一个“未定义变量名”的错误。\n\n事实上，之前的这个例子想要做的事情是很模糊的：你是想要先输出那个全局的X，然后创建一个本地的X呢，还是说这是个程序的错误？如果你真的是想要输出这个全局的X，你需要将它在一个全局语句中声明它，或者通过包络模块的名字来引用它。\n默认参数和可变对象\n\n在执行def语句时，默认参数的值只被解析并保存一次，而不是每次在调用函数的时候。这通常是你想要的那样，但是因为默认值需要在每次调用时都保持同样对象，你在试图改变可变的默认值（mutable defaults）的时候可要小心了。例如，下面的函数中使用一个空的列表作为默认值，然后在之后每一次函数调用的时候改变它的值：\n\n>>> def saver(x=[]):   # 保存一个列表对象\n...     x.append(1)    # 并每次调用的时候\n...     print x     # 改变它的值\n...\n>>> saver([2])         # 未使用默认值\n[2, 1]\n>>> saver()            # 使用默认值\n[1]\n>>> saver()            # 每次调用都会增加！\n[1, 1]\n>>> saver()\n[1, 1, 1]\n\n\n有的人将这个视作Python的一个特点——因为可变的默认参数在每次函数调用时保持了它们的状态，它们能提供像C语言中静态本地函数变量的类似的一些功能。但是，当你第一次碰到它时会觉得这很奇怪，并且在Python中有更加简单的办法来在不同的调用之间保存状态（比如说类）。\n\n要摆脱这样的行为，在函数开始的地方用切片或者方法来创建默认参数的副本，或者将默认值的表达式移到函数里面；只要每次函数调用时这些值在函数里，就会每次都得到一个新的对象：\n\n>>> def saver(x=None):\n...     if x is None: x = []   # 没有传入参数？\n...     x.append(1)            # 改变新的列表\n...     print x\n...\n>>> saver([2])                 # 没有使用默认值\n[2, 1]\n>>> saver()                    # 这次不会变了\n[1]\n>>> saver()\n[1]\n\n\n其他常见的编程陷阱\n\n下面列举了其他的一些在这里没法详述的陷阱：\n\n\n在顶层文件中语句的顺序是有讲究的：因为运行或者加载一个文件会从上到下运行它的语句，所以请确保将你未嵌套的函数调用或者类的调用放在函数或者类的定义之后。\nreload不影响用from加载的名字：reload最好和import语句一起使用。如果你使用from语句，记得在reload之后重新运行一遍from，否则你仍然使用之前老的名字。\n在多重继承中混合的顺序是有讲究的：这是因为对superclass的搜索是从左到右的，在类定义的头部，在多重superclass中如果出现重复的名字，则以最左边的类名为准。\n在try语句中空的except子句可能会比你预想的捕捉到更多的错误。在try语句中空的except子句表示捕捉所有的错误，即便是真正的程序错误，和sys.exit()调用，也会被捕捉到。\n兔子可能会比他们看起来更加危险。（原句Bunnies can be more dangerous than they seem. 意思是一些看起来比较细微的问题实际上可能更危险。——译者注）\n\n作者Mark Lutz系世界领先的Python教育者，Python最早的畅销教材的作者，并且从1992年开始便长期贡献于Python社区。\n\n\n原文：When Pythons Attack - Common Mistakes of Python Programmers by Mark Lutz\n译文：Mark Lutz：Python程序员的常见错误 by datorhjaelten\n责任编辑：SegmentFault-沙渺\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "3"}