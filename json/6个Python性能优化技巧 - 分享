{"title": "6个Python性能优化技巧 - 分享 ", "index": "python", "content": "Python是一门非常酷的语言，因为很少的Python代码可以在短时间内做很多事情，并且，Python很容易就能支持多任务和多重处理。\n\nPython的批评者声称Python性能低效、执行缓慢，但实际上并非如此：尝试以下6个小技巧，可以加快Pytho应用程序。\n\n\n\n1、关键代码可以依赖于扩展包\n\nPython使许多编程任务变得简单，但是对于很关键的任务并不总是提供最好的性能。使用C、C++或者机器语言扩展包来执行关键任务能极大改善性能。这些包是依赖于平台的，也就是说，你必须使用特定的、与你使用的平台相关的包。简而言之,该解决方案提供了一些应用程序的可移植性,以换取性能,您可以获得只有通过直接向底层主机编程。下面这些扩展包你可以考虑添加到你的个人扩展库中：\n\nCythonPyInlnePyPyPyrex\n\n这些包有不同的作用和执行方式。例如，Pyrex 让Python处理一些内存任务变得简单高效；PyInline可以直接让你在Python应用程序中使用C代码，虽然内联代码被单独编译，但是如果你能高效的利用C代码，它可以在同一个地方处理每一件事情。\n\n2、使用关键字排序\n\n有很多古老的Python代码在执行时将花费额外的时间去创建一个自定义的排序函数。最好的排序方式是使用关键字和默认的sort()方法，看看下面的示例：\n\nimport operator\nsomelist = [(1, 5, 8), (6, 2, 4), (9, 7, 5)]\nsomelist.sort(key=operator.itemgetter(0))\nsomelist\n#Output = [(1, 5, 8), (6, 2, 4), (9, 7, 5)]\nsomelist.sort(key=operator.itemgetter(1))\nsomelist\n#Output = [(6, 2, 4), (1, 5, 8), (9, 7, 5)]\nsomelist.sort(key=operator.itemgetter(2))\nsomelist\n#Output = [(6, 2, 4), (9, 7, 5), (1, 5, 8)],\n\n\n每一个案例的列表是根据你选择作为关键字参数的索引排序的，这种方式对字符串和数字排序同样适用。\n\n3、优化循环\n\n每一种编程语言都强调循环语句的优化，Python也是一样的。尽管你可以依赖于丰富的技术让循环运行的更快，然而，开发者经常忽略的一个方法是避免在循环内部使用点拼接字符串。对于下面的示例：\n\nlowerlist = ['this', 'is', 'lowercase']\nupper = str.upper\nupperlist = []\nappend = upperlist.append\nfor word in lowerlist:\n    append(upper(word))\n    print(upperlist)\n    #Output = ['THIS', 'IS', 'LOWERCASE']\n\n\n每一次调用str.upper，Python都会去求这个方法的值。但是如果你把求值的结果放入一个变量中，就能提高程序的性能。这个关键是减少Python内执行的循环次数,因为Python解析这些实例是比较慢的。\n\n4、使用新版本\n\n任何一个在线上搜索Python资料的人都会发现无数关于Python版本迁移的信息。通常，Python每一个版本都针对之前的一个版本做了优化和改进，以让Python运行的更快。限制因素是你喜欢的函数库是否也针对Python的新版本做了改进。\n\n当你使用了新的函数库，获得了Python的新版本，你需要保证代码依然能够运行，检查应用，修正差异。\n\n然后，如果你仅仅是保证应用能够在新版本上运行，你可能错过新功能的更新。一旦你做了改进，在新版本下配置应用程序，检查问题区域并优先使用新功能更新，对于之前的升级，用户将看到更大性能的提升。\n\n5、尝试多种编程方法\n\n每一次你创建应用的时候，都使用同一种编程方法，在某些情况下降导致程序运行会比预期的慢。在分析的过程中做一些小试验。例如，当管理字典中的数据项时，可以采用安全的方法确定数据项是否已经存在并需要更新它，或者你可以直接添加条目,然后处理项目根本不存在的情况。\n\nn = 16\nmyDict = {}\nfor i in range(0, n):\n    char = 'abcd'[i%4]\n    if char not in myDict:\n        myDict[char] = 0\n        myDict[char] += 1\n        print(myDict)\n\n\n当myDict是空时，上述的代码通常会运行的更快。但当myDict已经有数据填充时，就有更好的方法可以选择：\n\nn = 16\nmyDict = {}\nfor i in range(0, n):\n    char = 'abcd'[i%4]\n    try:\n        myDict[char] += 1\n    except KeyError:\n        myDict[char] = 1\n    print(myDict)\n\n\n两种情况下都输出{'d': 4, 'c': 4, 'b': 4, 'a': 4}，唯一的差异是输出是怎么获得的。站在盒子外考虑和创建新的编程技巧都能让你的程序获得更快的运行速度。\n\n6、交叉编译程序\n\n开发者有时会忘记计算机不能识别任何一种现在应用程序语言，它只识别机器代码。为了运行程序，需要一个应用将人类可读的代码转换成计算机能识别的代码。当用一种语言写程序时，例如Python，然后用另外一种语言来运行它，例如C++，从性能角度看是有道理的。这个取决于你想要用这个应用做什么和主机系统能够提供什么资源。\n\n一个有趣的交叉编译器，Nuitka, 能将Python转换成C++代码，结果是你可以再本机模式下执行应用，而不是依赖于解释器。根据平台和任务中,你可以看到显著的性能提高。\n\n译文链接：http://www.ido321.com/1433.html\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "9"}