{"title": "python大佬养成计划----分布式进程 - python太阳花 ", "index": "python", "content": "分布式进程\n在Thread和Process中，应当优选Process，因为Process更稳定，而且，Process可以分布到多台机器上，而Thread最多只能分布到同一台机器的多个CPU上。\nPython的 multiprocessing 模块不但支持多进程， 其中 managers 子模块还支持把多进程分布到多台机器上。一个服务进程可以作为调度者，将任务分布到其他多个进程中，依靠网络通信。由于managers模块封装很好，不必了解网络通信的细节，就可以很容易地编写分布式多进程程序。\n通过managers模块把Queue通过网络暴露出去，就可以让其他机器的进程访问Queue了。先看服务进程，服务进程负责启动Queue，把Queue注册到网络上，然后往Queue里面写入任务。\nBaseManager： 提供了不同机器进程之间共享数据的一种方法;\n(重要的点: ip:port)\n# task_master.py\n\nimport random\nfrom multiprocessing import freeze_support\nfrom queue import Queue\nfrom multiprocessing.managers import  BaseManager\n# 1. 创建需要的队列\n# task_queue：发送任务的队列\n# coding=utf-8\n\nimport random,time\nfrom queue import Queue\nfrom multiprocessing.managers import BaseManager\nfrom multiprocessing import freeze_support\n\ntask_queue =  Queue()  # 发送任务的队列:\nresult_queue = Queue() # 接收结果的队列:\nclass QueueManager(BaseManager):  # 从BaseManager继承的QueueManager:\n    pass\n# windows下运行\ndef return_task_queue():\n    global task_queue\n    return task_queue  # 返回发送任务队列\ndef return_result_queue ():\n    global result_queue\n    return result_queue # 返回接收结果队列\n\ndef test():\n    # 把两个Queue都注册到网络上, callable参数关联了Queue对象,它们用来进行进程间通信，交换对象\n    #QueueManager.register('get_task_queue', callable=lambda: task_queue)\n    #QueueManager.register('get_result_queue', callable=lambda: result_queue)\n    QueueManager.register('get_task_queue', callable=return_task_queue)\n    QueueManager.register('get_result_queue', callable=return_result_queue)\n    # 绑定端口4000, 设置验证码'sheenstar':\n    #manager = QueueManager(address=('', 4000), authkey=b'sheenstar')\n    # windows需要写ip地址\n    manager = QueueManager(address=('192.168.1.160', 4000), authkey=b'sheenstar')\n    manager.start()  # 启动Queue:\n    # 获得通过网络访问的Queue对象:\n    task = manager.get_task_queue()\n    result = manager.get_result_queue()\n    for i in range(13):   # 放几个任务进去:\n        n = random.randint(0, 10000)\n        print('Put task %d...' % n)\n        task.put(n)\n    # 从result队列读取结果:\n    print('Try get results...')\n    for i in range(13):\n        r = result.get(timeout=10)\n        print('Result: %s' % r)\n\n    # 关闭:\n    manager.shutdown()\n    print('master exit.')\nif __name__=='__main__':\n    freeze_support()\n    print('start!')\n    test()\n\n运行程序，会等待执行结果10s，如果没有worker端获取任务，返回结果，程序将报错。\n\n当我们在一台机器上写多进程程序时，创建的 Queue 可以直接拿来用，但是，在分布式多进程环境下，添加任务到Queue不可以直接对原始的 task_queue 进行操作，那样就绕过了QueueManager 的封装，必须通过manager.get_task_queue()获得的 Queue 接口添加。\n# coding=utf-8\nimport time, sys\nfrom queue import Queue\nfrom multiprocessing.managers import BaseManager\n\n# 创建类似的QueueManager:\nclass QueueManager(BaseManager):\n    pass\n\n# 由于这个QueueManager只从网络上获取Queue，所以注册时只提供名字:\nQueueManager.register('get_task_queue')\nQueueManager.register('get_result_queue')\n\n# 连接到服务器，也就是运行task_master.py的机器:\nserver_addr = '192.168.1.160'\nprint('Connect to server %s...' % server_addr)\n# 端口和验证码注意保持与task_master.py设置的完全一致:\nm = QueueManager(address=(server_addr, 4000), authkey=b'sheenstar')\n# 从网络连接:\ntry:\n    m.connect()\nexcept:\n    print('请先启动task_master.py!')\n    #sys.exit(\"sorry, goodbye!\");\n# 获取Queue的对象:\ntask = m.get_task_queue()\nresult = m.get_result_queue()\n# 从task队列取任务,并把结果写入result队列:\nfor i in range(13):\n    try:\n        n = task.get()\n        print('run task %d * %d...' % (n, n))\n        r = '%d * %d = %d' % (n, n, n*n)\n        time.sleep(1)\n        result.put(r)\n    except ConnectionResetError as e:\n        print(\"任务执行结束，自动断开连接\")\n# 处理结束:\nprint('worker exit.')\n使用命令行运行程序，结果更直观     \n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "0"}