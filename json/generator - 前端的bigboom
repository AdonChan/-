{"title": "generator - 前端的bigboom ", "index": "python,generator", "content": "前文我们了解如果书写一个Iterator,以及怎样在一个类中安装一个Iterator. 但,有时候我们只想要一个简单的iterator, 而且并不想这么复杂. 处于这个目的, 变成语言里面出现了generator 这个概念. 根据wiki的解释:\nIn fact, all generators are iterators\ngenerator 同样也有iteartor的优势, 在输出值的过程中,是分散性的, 即他不会保存每一次输出值, 这样在循环里面更高效, 并且更节省效率.\ngenerator syntax\ngenerator的格式和一个函数非常类似, 他使用yield代替return, 来返回一个expression.\ndef a_gen:\n    yield 1\n    yield 2\n使用generator实际上就和使用iteartor对象一样. 因为generator 返回的就是iterator:\ngen = a_gen()\nprint(next(gen))\n既然, generator是Iterator, 那我们能不能在上面使用for...in...循环呢？ Yes~\nfor x in a_gen():\n    print(x)\n另外, 在python中, 提供了一个常见匿名generator的办法. 使用 ( ) 即可. 里面放的就是 list comprehension.\na = (x for x in range(10))\n这里需要注意, 上面 匿名 generator的返回值是一个generator object. 这点很重要, 这也是区分list comrehension 的关键点. generator 延续着iterator的特性: 你要我才给 . 这样, 不必先生成大量的数据. 所以,generator 这个也常常用于处理数据较大的集合中.如果仅仅是造了一个语法糖, 那generator的存在不就无意义了吗？  所以,generator的优势,或者说用途还是挺广泛的.\nwhen we can use generator\n用来快速生成Iterator对象. 即, 以前需要这样写,才能生成一个Iterator.\n class Xlist:\n     def __init__(self,a_list):\n         self.list = a_list\n         self.index = 0\n     def __iter__(self):\n         return self\n     def __next__(self):\n         length = len(self.list)\n         if(length==self.index):\n             # 提出异常\n             raise StopIteration\n         else:\n             result = self.list[self.index]\n             self.index += 1\n             return result\n现在只需要, 使用generator即可\ndef Xlist(arr):\n    for x in arr:\n        yield x\n省略的不止一点点\n2.异步序列的操作在python中,有时候读取文件,可能会存在异步方式的读取. 而且,现在主流的后台处理程序都是NodeJS, 一种完全异步的编程语言. 而generator 本省就继承了Iterator的特性, 有一种状态暂停的效果. 这种效果, 也可以用来作为异步序列的处理. 比如我们这里可以编写一个普通串行:\ndef co(*callback):\n    length = 0\n    while length!=len(callback):\n        yield callback[length]()\n        length+=1\n\n\nfor x in co(lambda :1,lambda: 2):\n    print(x)\n简单总结:\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "2"}