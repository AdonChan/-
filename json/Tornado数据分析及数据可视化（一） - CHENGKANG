{"title": "Tornado数据分析及数据可视化（一） - CHENGKANG ", "index": "xlrd,excel,tornado,python", "content": "前面的话\n\n今天公司突然有个紧急任务是读取excel表格，然后清洗并展示里面的数据。\n分配给我的任务是！！！\n\n写网页前端表单=。=\n\n妈蛋，可是我很想分析一下数据啊！！！\n\n然后突然想起来协会（大学的社团）的指纹考勤机一直没怎么用好，要不就把打卡数据拷出来分析吧！！做成每天、每周、每月、每年的考勤记录分析！！！\n恰好前几天上级让我学习可视化，顺带练练手。\n\n哟西，开干！\n\n所用拓展模块\n\n\n\nxlrd:\n\nPython语言中，读取Excel的扩展工具。可以实现指定表单、指定单元格的读取。\n使用前须安装。\n下载地址：https://pypi.python.org/pypi/xlrd\n解压后cd到解压目录，执行 python setup.py install 即可\n\n\n\ndatetime:\n\nPython内置用于操作日期时间的模块\n\n\n\n拟实现功能模块\n\n\n读xls文件并录入数据库\n根据年、月、日三个参数获取当天的值班情况\n饼状图（当天完成值班任务人数/当天未完成值班任务人数）\n瀑布图（当天所有值班人员的值班情况）\n\n\n根据年、月两个参数获取当月的值班情况\n根据年参数获取当年的值班情况\n\n值班制度\n\n\n每天一共有6班：\n\n\n8：00 - 9：45\n9：45 - 11：20\n13：30 - 15：10\n15：10 - 17：00\n17：00 - 18：35\n19：00 - 22：00\n\n\n每个人每天最多值一班。\n仅值班时间及前后半个小时内打卡有效。\n上班、下班均须打卡，缺打卡则视为未值班。\n\n分析Excel表格\n\n我的指纹考勤机可以一次导出最多一个月的打卡记录。有一个问题是，这一个月可能横跨两个月，也可能横跨一年。比如：2015年03月21日-2015年04月20日、2014年12月15日-2015年01月05日。所以写处理方法的时候一定要注意这个坑。\n\n导出的表格如图所示：\n\n\n  =。=看起来好像基本没人值班，对，就是这样。\n  大家都好懒T。T\n  Sign...\n\n\n简单分析一下，\n\n\n\n考勤记录表是文件的第三个sheet\n\n第三行有起止时间\n\n第四行是所有日期的数字\n接下来每两行：第一行为用户信息；第二行为考勤记录\n\n\n思路\n\n决定用3个collection分别储存相关信息：\n\n\n\nuser：用户信息，包含id、name、dept\n\n\nrecord：考勤记录，包含id（用户id）、y（年）、m（月）、d（日）、check（打卡记录）\n\nduty：值班安排，包含id（星期数，例：1表示星期一）、list（值班人员id列表）、user_id：[\"start_time\",\"end_time\"]（用户值班开始时间和结束时间）\n\n读取xls文件，将新的考勤记录和新的用户存入数据库。\n\n根据年月日参数查询对应record，查询当天的值班安排，匹配获得当天值班同学的考勤记录。将值班同学的打卡时间和值班时间比对，判断是否正常打卡，计算实际值班时长、实际值班百分比。\n\n之后输出json格式数据，用echarts生成图表。\n\n分析当月、当年的考勤记录同理，不过可能稍微复杂一些。\n\n\n  所有的讲解和具体思路都放在源码注释里，请继续往下看源码吧~\n\n\n源码\n\n\n  main.py\n\n\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport os.path\n\nimport tornado.auth\nimport tornado.escape\nimport tornado.httpserver\nimport tornado.ioloop\nimport tornado.options\nimport tornado.web\nfrom tornado.options import define, options\n\nimport pymongo\nimport time\nimport datetime\nimport xlrd\n\ndefine(\"port\", default=8007, help=\"run on the given port\", type=int)\n\nclass Application(tornado.web.Application):\n    def __init__(self):\n        handlers = [\n            (r\"/\", MainHandler),\n            (r\"/read\", ReadHandler),\n            (r\"/day\", DayHandler),\n        ]\n        settings = dict(\n            template_path=os.path.join(os.path.dirname(__file__), \"templates\"),\n            static_path=os.path.join(os.path.dirname(__file__), \"static\"),\n            debug=True,\n            )\n        conn = pymongo.Connection(\"localhost\", 27017)\n        self.db = conn[\"kaoqin\"]\n        tornado.web.Application.__init__(self, handlers, **settings)\n\n\nclass MainHandler(tornado.web.RequestHandler):\n    def get(self):\n        pass\n\nclass ReadHandler(tornado.web.RequestHandler):\n    def get(self):\n        #获取collection\n        coll_record = self.application.db.record\n        coll_user = self.application.db.user\n        #读取excel表格\n        table = xlrd.open_workbook('/Users/ant/Webdev/python/excel/data.xls')\n        #读取打卡记录sheet\n        sheet=table.sheet_by_index(2)\n        #读取打卡月份范围\n        row3 = sheet.row_values(2)\n        m1 = int(row3[2][5:7])\n        m2 = int(row3[2][18:20])\n        #设置当前年份\n        y = int(row3[2][0:4])\n        #设置当前月份为第一个月份\n        m = m1\n        #读取打卡日期范围\n        row4 = sheet.row_values(3)\n        #初始化上一天\n        lastday = row4[0]\n        #遍历第四行中的日期\n        for d in row4:\n            #如果日期小于上一个日期\n            #说明月份增大，则修改当前月份为第二个月份\n            if d < lastday:\n                m = m2\n                #如果当前两个月份分别为12月和1月\n                #说明跨年了，所以年份 +1\n                if m1 == 12 and m2 == 1:\n                    y = y + 1\n            #用n计数，范围为 3 到（总行数/2+1）\n            #（总行数/2+1）- 3 = 总用户数\n            #即遍历所有用户\n            for n in range(3, sheet.nrows/2+1):\n                #取该用户的第一行，即用户信息行\n                row_1 = sheet.row_values(n*2-2)\n                #获取用户id\n                u_id = row_1[2]\n                #获取用户姓名\n                u_name = row_1[10]\n                #获取用户部门\n                u_dept = row_1[20]\n                #查询该用户\n                user = coll_user.find_one({\"id\":u_id})\n                #如果数据库中不存在该用户则创建新用户\n                if not user:\n                    user = dict()\n                    user['id'] = u_id\n                    user['name'] = u_name\n                    user['dept'] = u_dept\n                    coll_user.insert(user)\n                #取该用户的第二行，即考勤记录行\n                row_2 = sheet.row_values(n*2-1)\n                #获取改当前日期的下标\n                idx = row4.index(d)\n                #获取当前用户当前日期的考勤记录\n                check_data = row_2[idx]\n                #初始化空考勤记录列表\n                check = list()\n                #5个字符一组，遍历考勤记录并存入考勤记录列表\n                for i in range(0,len(check_data)/5):\n                    check.append(check_data[i*5:i*5+5])\n                #查询当前用户当天记录\n                record = coll_record.find_one({\"y\":y, \"m\":m, \"d\":d, \"id\":user['id']})\n                #如果记录存在则更新记录\n                if record:\n                    for item in check:\n                        #将新的考勤记录添加进之前的记录\n                        if item not in record['check']:\n                            record['check'].append(item)\n                            coll_record.save(record)\n                #如果记录不存在则插入新纪录\n                else:\n                    record = {\"y\":y, \"m\":m, \"d\":d, \"id\":user['id'], \"check\":check}\n                    coll_record.insert(record)\n\n\n\n\n\nclass DayHandler(tornado.web.RequestHandler):\n    def get(self):\n        #获取年月日参数\n        y = self.get_argument(\"y\",None)\n        m = self.get_argument(\"m\",None)\n        d = self.get_argument(\"d\",None)\n        #判断参数是否设置齐全\n        if y and m and d:\n            #将参数转换为整型数，方便使用\n            y = int(y)\n            m = int(m)\n            d = int(d)\n            #获取当天所有记录\n            coll_record = self.application.db.record\n            record = coll_record.find({\"y\":y, \"m\":m, \"d\":d})\n            #获取当天为星期几\n            weekday = datetime.datetime(y,m,d).strftime(\"%w\")\n            #获取当天值班表\n            coll_duty = self.application.db.duty\n            duty = coll_duty.find_one({\"id\":int(weekday)})\n            #初始化空目标记录（当天值班人员记录）\n            target = list()\n            #遍历当天所有记录\n            for item in record:\n                #当该记录的用户当天有值班任务时，计算并存入target数组\n                if int(item['id']) in duty['list']:\n                    #通过用户id获取该用户值班起止时间\n                    start = duty[item['id']][0]\n                    end = duty[item['id']][1]\n                    #计算值班时长/秒\n                    date1 = datetime.datetime(y,m,d,int(start[:2]),int(start[-2:]))\n                    date2 = datetime.datetime(y,m,d,int(end[:2]),int(end[-2:]))\n                    item['length'] = (date2 - date1).seconds\n                    #初始化实际值班百分比\n                    item['per'] = 0\n                    #初始化上下班打卡时间\n                    item['start'] = 0\n                    item['end'] = 0\n                    #遍历该用户打卡记录\n                    for t in item['check']:\n                        #当比值班时间来得早\n                        if t < start:\n                            #计算时间差\n                            date1 = datetime.datetime(y,m,d,int(start[:2]),int(start[-2:]))\n                            date2 = datetime.datetime(y,m,d,int(t[:2]),int(t[-2:]))\n                            dif = (date1 - date2).seconds\n                            #当打卡时间在值班时间前半小时内\n                            if dif <= 1800:\n                                #上班打卡成功\n                                item['start'] = start\n                        elif t < end:\n                            #如果还没上班打卡\n                            if not item['start']:\n                                #则记录当前时间为上班打卡时间\n                                item['start'] = t\n                            else:\n                                #否则记录当前时间为下班打卡时间\n                                item['end'] = t\n                        else:\n                            #如果已经上班打卡\n                            if item['start']:\n                                #计算时间差\n                                date1 = datetime.datetime(y,m,d,int(end[:2]),int(end[-2:]))\n                                date2 = datetime.datetime(y,m,d,int(t[:2]),int(t[-2:]))\n                                dif = (date1 - date2).seconds\n                                #当打卡时间在值班时间后半小时内\n                                if dif <= 1800:\n                                    #下班打卡成功\n                                    item['end'] = end\n                    #当上班下班均打卡\n                    if item['start'] and item['end']:\n                        #计算实际值班时长\n                        date1 = datetime.datetime(y,m,d,int(item['start'][:2]),int(item['start'][-2:]))\n                        date2 = datetime.datetime(y,m,d,int(item['end'][:2]),int(item['end'][-2:]))\n                        dif = (date2 - date1).seconds\n                        #计算（实际值班时长/值班时长）百分比\n                        item['per'] = int(dif/float(item['length']) * 100)\n                    else:\n                        #未正常上下班则视为未值班\n                        item['start'] = 0\n                        item['end'] = 0\n                    #将记录添加到target数组中\n                    target.append(item)\n            #输出数据\n            self.render(\"index.html\",\n                target = target\n                )\n\n\ndef main():\n    tornado.options.parse_command_line()\n    http_server = tornado.httpserver.HTTPServer(Application())\n    http_server.listen(options.port)\n    tornado.ioloop.IOLoop.instance().start()\n\n\nif __name__ == \"__main__\":\n    main()\n\n\n\n  index.html\n\n\n{\n{% for item in target %}\n    {\n     'id':{{ item['id'] }},\n     'start':{{ item['start'] }},\n     'end':{{ item['end'] }},\n     'length':{{ item['length'] }}, \n     'per':{{ item['per'] }}\n     }\n{% end %}\n}\n\n\n最后\n\n暂时只写到读文件和查询某天值班情况，之后会继续按照之前的计划把这个小应用写完的。\n\n因为涉及到一堆小伙伴的隐私，所以没有把测试文件发上来。不过如果有想实际运行看看的同学可以跟我说，我把文件发给你。\n\n可能用到的一条数据库插入语句：db.duty.insert({\"id\":5,\"list\":[1,2],1:[\"19:00\",\"22:00\"],2:[\"19:00\",\"22:00\"]})\n\n希望对像我一样的beginner们有帮助！\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "7"}