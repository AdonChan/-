{"title": "Python 数据分析之 pandas 进阶(二) - 个人文章 ", "index": "python", "content": "六、分组\n对于“group by”操作，我们通常是指以下一个或多个操作步骤：（Splitting）按照一些规则将数据分为不同的组（Applying）对于每组数据分别执行一个函数（Combining）将结果组合刀一个数据结构中将要处理的数组是：\n    df = pd.DataFrame({\n            'A': ['foo', 'bar', 'foo', 'bar', 'foo', 'bar', 'foo', 'foo'],\n            'B': ['one', 'one', 'two', 'three', 'two', 'two', 'one', 'three'],\n            'C': np.random.randn(8),\n            'D': np.random.randn(8)\n        })\n    df\n     \n        A    B    C            D\n    0    foo    one    0.961295    -0.281012\n    1    bar    one    0.901454    0.621284\n    2    foo    two    -0.584834    0.919414\n    3    bar    three    1.259104    -1.012103\n    4    foo    two    0.153107    1.108028\n    5    bar    two    0.115963    1.333981\n    6    foo    one    1.421895    -1.456916\n    7    foo    three    -2.103125    -1.757291\n1、分组并对每个分组执行sum函数：\n    df.groupby('A').sum()\n     \n        C            D\n    A        \n    bar    2.276522    0.943161\n    foo    -0.151661    -1.467777 \n2、通过多个列进行分组形成一个层次索引，然后执行函数：\n    df.groupby(['A', 'B']).sum()\n     \n            C            D\n    A    B        \n    bar    one    0.901454    0.621284\n            three    1.259104        -1.012103\n            two    0.115963        1.333981\n    foo    one    2.383191    -1.737928\n            three    -2.103125    -1.757291\n            two    -0.431727    2.027441   \n七、Reshaping\nStack\n    tuples = list(zip(*[['bar', 'bar', 'baz', 'baz',\n                         'foo', 'foo', 'qux', 'qux'],\n                        ['one', 'two', 'one', 'two',\n                         'one', 'two', 'one', 'two']]))\n    tuples\n     \n    [('bar', 'one'),\n     ('bar', 'two'),\n     ('baz', 'one'),\n     ('baz', 'two'),\n     ('foo', 'one'),\n     ('foo', 'two'),\n     ('qux', 'one'),\n     ('qux', 'two')]    \n    index = pd.MultiIndex.from_tuples(tuples, names=['first', 'second'])\n    df = pd.DataFrame(np.random.randn(8, 2), index=index, columns=['A', 'B'])\n    df2 = df[:4]\n    df2\n     \n             A            B\n    first    second        \n    bar    one    -0.907306    -0.009961\n            two    0.905177    -2.877961\n    baz    one    -0.356070    -0.373447\n            two    -1.496644    -1.958782\n    stacked = df2.stack()\n    stacked \n     \n    first  second   \n    bar    one     A   -0.907306\n                   B   -0.009961\n           two     A    0.905177\n                   B   -2.877961\n    baz    one     A   -0.356070\n                   B   -0.373447\n           two     A   -1.496644\n                   B   -1.958782\n    dtype: float64\n    stacked.unstack()\n     \n            A            B\n    first    second        \n    bar    one    -0.907306    -0.009961\n            two    0.905177    -2.877961\n    baz    one    -0.356070    -0.373447\n            two    -1.496644    -1.958782\n    stacked.unstack(1)\n     \n        second    one           two\n    first            \n    bar    A    -0.907306    0.905177\n            B    -0.009961    -2.877961\n    baz    A    -0.356070    -1.496644\n            B    -0.373447    -1.958782    \n八、相关操作\n要处理的数组为：\n    df\n     \n                A            B            C            D    F\n    2013-01-01    0.000000    0.000000    0.135704    5    NaN\n    2013-01-02    0.139027    1.683491    -1.031190    5    1\n    2013-01-03    -0.596279    -1.211098    1.169525    5    2\n    2013-01-04    0.367213    -0.020313    2.169802    5    3\n    2013-01-05    0.224122    1.003625    -0.488250    5    4\n    2013-01-06    0.186073    -0.537019    -0.252442    5    5\n(一)、统计\n1、执行描述性统计：\n    df.mean()\n     \n    A    0.053359\n    B    0.153115\n    C    0.283858\n    D    5.000000\n    F    3.000000\n    dtype: float64   \n2、在其他轴上进行相同的操作：\n    df.mean(1)\n     \n    2013-01-01    1.283926\n    2013-01-02    1.358266\n    2013-01-03    1.272430\n    2013-01-04    2.103341\n    2013-01-05    1.947899\n    2013-01-06    1.879322\n    Freq: D, dtype: float64\n3、对于拥有不同维度，需要对齐的对象进行操作，pandas会自动的沿着指定的维度进行广播\n    dates\n    s = pd.Series([1,3,4,np.nan,6,8], index=dates).shift(2)\n    s\n     \n    DatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04',\n                   '2013-01-05', '2013-01-06'],\n                  dtype='datetime64[ns]', freq='D')\n     \n    2013-01-01   NaN\n    2013-01-02   NaN\n    2013-01-03     1\n    2013-01-04     3\n    2013-01-05     4\n    2013-01-06   NaN\n    Freq: D, dtype: float64\n(二)、Apply\n对数据应用函数：\n    df.apply(np.cumsum)\n     \n                A            B            C            D    F\n    2013-01-01    0.000000    0.000000    0.135704    5    NaN\n    2013-01-02    0.139027    1.683491    -0.895486    10    1\n    2013-01-03    -0.457252    0.472393    0.274039    15    3\n    2013-01-04    -0.090039    0.452081    2.443841    20    6\n    2013-01-05    0.134084    1.455706    1.955591    25    10\n    2013-01-06    0.320156    0.918687    1.703149    30    15\n    df.apply(lambda x: x.max() - x.min())\n     \n    A    0.963492\n    B    2.894589\n    C    3.200992\n    D    0.000000\n    F    4.000000\n    dtype: float64\n(三)、字符串方法\nSeries对象在其str属性中配备了一组字符串处理方法，可以很容易的应用到数组中的每个元素。\n    s = pd.Series(['A', 'B', 'C', 'Aaba', 'Baca', np.nan, 'CABA', 'dog', 'cat'])\n    s.str.lower()\n     \n    0       a\n    1       b\n    2       c\n    3    aaba\n    4    baca\n    5     NaN\n    6    caba\n    7     dog\n    8     cat\n    dtype: object\n九、时间序列\n1、时区表示：\n    rng = pd.date_range('3/6/2012 00:00', periods=5, freq='D')\n    ts = pd.Series(np.random.randn(len(rng)), rng)\n    ts\n     \n    2012-03-06   -0.932261\n    2012-03-07   -1.405305\n    2012-03-08    0.809844\n    2012-03-09   -0.481539\n    2012-03-10   -0.489847\n    Freq: D, dtype: float64\n    ts_utc = ts.tz_localize('UTC')\n    ts_utc\n     \n    2012-03-06 00:00:00+00:00   -0.932261\n    2012-03-07 00:00:00+00:00   -1.405305\n    2012-03-08 00:00:00+00:00    0.809844\n    2012-03-09 00:00:00+00:00   -0.481539\n    2012-03-10 00:00:00+00:00   -0.489847\n    Freq: D, dtype: float64\n2、时区转换\n    ts_utc.tz_convert('US/Eastern')\n     \n    2012-03-05 19:00:00-05:00   -0.932261\n    2012-03-06 19:00:00-05:00   -1.405305\n    2012-03-07 19:00:00-05:00    0.809844\n    2012-03-08 19:00:00-05:00   -0.481539\n    2012-03-09 19:00:00-05:00   -0.489847\n    Freq: D, dtype: float64\n3、时区跨度转换\n    rng = pd.date_range('1/1/2012', periods=5, freq='M')\n    ts = pd.Series(np.random.randn(len(rng)), index=rng)\n    ps = ts.to_period()\n    ts\n    ps\n    ps.to_timestamp()\n     \n    2012-01-31    0.932519\n    2012-02-29    0.247016\n    2012-03-31   -0.946069\n    2012-04-30    0.267513\n    2012-05-31   -0.554343\n    Freq: M, dtype: float64\n   \n  \n    2012-01    0.932519\n    2012-02    0.247016\n    2012-03   -0.946069\n    2012-04    0.267513\n    2012-05   -0.554343\n    Freq: M, dtype: float64\n     \n    2012-01-01    0.932519\n    2012-02-01    0.247016\n    2012-03-01   -0.946069\n    2012-04-01    0.267513\n    2012-05-01   -0.554343\n    Freq: MS, dtype: float64\n十、画图\n    ts = pd.Series(np.random.randn(1000), index=pd.date_range('1/1/2000', periods=1000))\n    ts = ts.cumsum()\n    ts\n图片描述\n十一、Categorical\n从0.15版本开始，pandas可以在DataFrame中支持Categorical类型的数据。\n    df = pd.DataFrame({\n            'id':[1,2,3,4,5,6],\n            'raw_grade':['a','b','b','a','a','e']\n        })\n    df\n     \n        id    raw_grade\n    0    1    a\n    1    2    b\n    2    3    b\n    3    4    a\n    4    5    a\n    5    6    e\n1、将原始的grade转换为Categorical数据类型：\n    df['grade'] = df['raw_grade'].astype('category', ordered=True)\n    df['grade'] \n     \n    0    a\n    1    b\n    2    b\n    3    a\n    4    a\n    5    e\n    Name: grade, dtype: category\n    Categories (3, object): [a < b < e]\n2、将Categorical类型数据重命名为更有意义的名称：\n    df['grade'].cat.categories = ['very good', 'good', 'very bad']\n3、对类别进行重新排序，增加缺失的类别：\n    df['grade'] = df['grade'].cat.set_categories(['very bad', 'bad', 'medium', 'good', 'very good'])\n    df['grade']\n     \n    0    very good\n    1         good\n    2         good\n    3    very good\n    4    very good\n    5     very bad\n    Name: grade, dtype: category\n    Categories (5, object): [very bad < bad < medium < good < very good]\n4、排序是按照Categorical的顺序进行的而不是按照字典顺序进行：\n    df.sort('grade')\n     \n        id    raw_grade    grade\n    5    6    e            very bad\n    1    2    b            good\n    2    3    b            good\n    0    1    a            very good\n    3    4    a            very good\n    4    5    a            very good\n5、对Categorical列进行排序时存在空的类别：\n    df.groupby(\"grade\").size()\n     \n    grade\n    very bad     1\n    bad          0\n    medium       0\n    good         2\n    very good    3\n    dtype: int64\n以上代码不想自己试一试吗？镭矿 raquant提供 jupyter(研究） 在线练习学习 python 的机会，无需安装 python 即可运行 python 程序。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "3"}