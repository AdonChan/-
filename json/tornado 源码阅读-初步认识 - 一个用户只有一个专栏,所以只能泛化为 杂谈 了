{"title": "tornado 源码阅读-初步认识 - 一个用户只有一个专栏,所以只能泛化为 杂谈 了 ", "index": "tornado,python", "content": "序言\n\n最近闲暇无事,阅读了一下tornado的源码,对整体的结构有了初步认识,与大家分享\n不知道为什么右边的目录一直出不来,非常不舒服.\n不如移步到oschina吧....[http://my.oschina.net/abc2001x/blog/476349][1]\n\n\nioloop\n\n`ioloop`是`tornado`的核心模块,也是个调度模块,各种异步事件都是由他调度的,所以必须弄清他的执行逻辑\n\n\n源码分析\n\n而`ioloop`的核心部分则是 `while True`这个循环内部的逻辑,贴上他的代码如下\n\n\n   def start(self):\n        if self._running:\n            raise RuntimeError(\"IOLoop is already running\")\n        self._setup_logging()\n        if self._stopped:\n            self._stopped = False\n            return\n        old_current = getattr(IOLoop._current, \"instance\", None)\n        IOLoop._current.instance = self\n        self._thread_ident = thread.get_ident()\n        self._running = True\n\n        old_wakeup_fd = None\n        if hasattr(signal, 'set_wakeup_fd') and os.name == 'posix':\n\n            try:\n                old_wakeup_fd = signal.set_wakeup_fd(self._waker.write_fileno())\n                if old_wakeup_fd != -1:\n\n                    signal.set_wakeup_fd(old_wakeup_fd)\n                    old_wakeup_fd = None\n            except ValueError:\n\n                old_wakeup_fd = None\n\n        try:\n            while True:\n\n                with self._callback_lock:\n                    callbacks = self._callbacks\n                    self._callbacks = []\n\n                due_timeouts = []\n\n                if self._timeouts:\n                    now = self.time()\n                    while self._timeouts:\n                        if self._timeouts[0].callback is None:\n\n                            heapq.heappop(self._timeouts)\n                            self._cancellations -= 1\n                        elif self._timeouts[0].deadline <= now:\n                            due_timeouts.append(heapq.heappop(self._timeouts))\n                        else:\n                            break\n                    if (self._cancellations > 512\n                            and self._cancellations > (len(self._timeouts) >> 1)):\n                        self._cancellations = 0\n                        self._timeouts = [x for x in self._timeouts\n                                          if x.callback is not None]\n                        heapq.heapify(self._timeouts)\n\n                for callback in callbacks:\n                    self._run_callback(callback)\n                for timeout in due_timeouts:\n                    if timeout.callback is not None:\n                        self._run_callback(timeout.callback)\n\n                callbacks = callback = due_timeouts = timeout = None\n\n                if self._callbacks:\n\n                    poll_timeout = 0.0\n                elif self._timeouts:\n\n                    poll_timeout = self._timeouts[0].deadline - self.time()\n                    poll_timeout = max(0, min(poll_timeout, _POLL_TIMEOUT))\n                else:\n\n                    poll_timeout = _POLL_TIMEOUT\n\n                if not self._running:\n                    break\n\n                if self._blocking_signal_threshold is not None:\n\n                    signal.setitimer(signal.ITIMER_REAL, 0, 0)\n\n                try:\n                    event_pairs = self._impl.poll(poll_timeout)\n                except Exception as e:\n\n                    if errno_from_exception(e) == errno.EINTR:\n                        continue\n                    else:\n                        raise\n\n                if self._blocking_signal_threshold is not None:\n                    signal.setitimer(signal.ITIMER_REAL,\n                                     self._blocking_signal_threshold, 0)\n\n                self._events.update(event_pairs)\n                while self._events:\n                    fd, events = self._events.popitem()\n                    try:\n                        fd_obj, handler_func = self._handlers[fd]\n                        handler_func(fd_obj, events)\n                    except (OSError, IOError) as e:\n                        if errno_from_exception(e) == errno.EPIPE:\n\n                            pass\n                        else:\n                            self.handle_callback_exception(self._handlers.get(fd))\n                    except Exception:\n                        self.handle_callback_exception(self._handlers.get(fd))\n                fd_obj = handler_func = None\n\n        finally:\n\n            self._stopped = False\n            if self._blocking_signal_threshold is not None:\n                signal.setitimer(signal.ITIMER_REAL, 0, 0)\n            IOLoop._current.instance = old_current\n            if old_wakeup_fd is not None:\n                signal.set_wakeup_fd(old_wakeup_fd)\n\n\n除去注释,代码其实没多少行. 由while 内部代码可以看出ioloop主要由三部分组成:\n\n\n1.回调 callbacks\n\n他是ioloop回调的基础部分,通过IOLoop.instance().add_callback()添加到self._callbacks\n他们将在每一次loop中被运行.\n\n主要用途是将逻辑分块,在适合时机将包装好的callback添加到self._callbacks让其执行.\n\n例如ioloop中的add_future\n\ndef add_future(self, future, callback):\n        \"\"\"Schedules a callback on the ``IOLoop`` when the given\n        `.Future` is finished.\n\n        The callback is invoked with one argument, the\n        `.Future`.\n        \"\"\"\n        assert is_future(future)\n        callback = stack_context.wrap(callback)\n        future.add_done_callback(\n            lambda future: self.add_callback(callback, future))\n\n\nfuture对象得到result的时候会调用future.add_done_callback添加的callback,再将其转至ioloop执行\n\n2.定时器 due_timeouts\n\n这是定时器,在指定的事件执行callback.\n跟1中的callback类似,通过IOLoop.instance().add_callback\n\n在每一次循环,会计算timeouts回调列表里的事件,运行已到期的callback.\n当然不是无节操的循环.\n\n因为poll操作会阻塞到有io操作发生,所以只要计算最近的timeout,\n然后用这个时间作为self._impl.poll(poll_timeout) 的 poll_timeout ,\n就可以达到按时运行了\n\n但是,假设poll_timeout的时间很大时,self._impl.poll一直在堵塞中(没有io事件,但在处理某一个io事件),\n那添加刚才1中的callback不是要等很久才会被运行吗? 答案当然是不会.ioloop中有个waker对象,他是由两个fd组成,一个读一个写.ioloop在初始化的时候把waker绑定到epoll里了,add_callback时会触发waker的读写.\n这样ioloop就会在poll中被唤醒了,接着就可以及时处理timeout callback了\n\n用这样的方式也可以自己封装一个小的定时器功能玩玩\n\n3.io事件的event loop\n\n处理epoll事件的功能\n通过IOLoop.instance().add_handler(fd, handler, events)绑定fd event的处理事件\n在httpserver.listen的代码内,netutil.py中的netutil.py的add_accept_handler绑定accept handler处理客户端接入的逻辑\n\n如法炮制,其他的io事件也这样绑定,业务逻辑的分块交由ioloop的callback和future处理\n\n关于epoll的用法的内容.详情见我第一篇文章吧,哈哈\n\n总结\n\nioloop由callback(业务分块), timeout callback(定时任务) io event(io传输和解析) 三块组成,互相配合完成异步的功能,构建gen,httpclient,iostream等功能\n\n串联大致的流程是,tornado 绑定io event,处理io传输解析,传输完成后(结合Future)回调(callback)业务处理的逻辑和一些固定操作 . 定时器则是较为独立的模块\n\nFutrue\n\n个人认为Future是tornado仅此ioloop重要的模块,他贯穿全文,所有异步操作都有他的身影\n顾名思义,他主要是关注日后要做的事,类似jquery的Deferred吧\n\n一般的用法是通过ioloop的add_future定义future的done callback,\n当future被set_result的时候,future的done callback就会被调用.\n从而完成Future的功能.\n\n具体可以参考gen.coroutine的实现,本文后面也会讲到\n\n他的组成不复杂,只有几个重要的方法\n最重要的是 add_done_callback , set_result\n\ntornado用Future和ioloop,yield实现了gen.coroutine\n\n1. add_done_callback\n\n跟ioloop的callback类似 , 存储事件完成后的callback在self._callbacks里\n\ndef add_done_callback(self, fn):\n        if self._done:\n            fn(self)\n        else:\n            self._callbacks.append(fn)\n\n\n2.set_result\n\n设置事件的结果,并运行之前存储好的callback\n\ndef set_result(self, result):\n        self._result = result\n        self._set_done()\n\ndef _set_done(self):\n        self._done = True\n        for cb in self._callbacks:\n            try:\n                cb(self)\n            except Exception:\n                app_log.exception('Exception in callback %r for %r',\n                                  cb, self)\n        self._callbacks = None\n\n\n为了验证之前所说的,上一段测试代码\n\n#! /usr/bin/env python\n#coding=utf-8\n\nimport tornado.web\nimport tornado.ioloop\n\nfrom tornado.gen import coroutine\nfrom tornado.concurrent import Future\n\n\ndef test():\n    def pp(s):\n        print s\n\n    future = Future()\n    iol = tornado.ioloop.IOLoop.instance()\n\n    print 'init future %s'%future\n\n    iol.add_future(future, lambda f: pp('ioloop callback after future done,future is %s'%f))\n\n    #模拟io延迟操作\n    iol.add_timeout(iol.time()+5,lambda:future.set_result('set future is done'))\n\n    print 'init complete'\n    tornado.ioloop.IOLoop.instance().start()\n\nif __name__ == \"__main__\":\n    test()  \n\n\n运行结果:\n\n\n\ngen.coroutine\n\n接着继续延伸,看看coroutine的实现gen.coroutine实现的功能其实是将原来的callback的写法,用yield的写法代替. 即以yield为分界,将代码分成两部分.\n如:\n\n#! /usr/bin/env python\n#coding=utf-8\n\nimport tornado.ioloop\nfrom tornado.gen import coroutine\nfrom tornado.httpclient import AsyncHTTPClient\n\n@coroutine\ndef cotest():\n    client = AsyncHTTPClient()\n    res = yield client.fetch(\"http://www.segmentfault.com/\")\n    print res\n\nif __name__ == \"__main__\":\n    f = cotest()    \n    print f #这里返回了一个future哦\n    tornado.ioloop.IOLoop.instance().start()\n\n\n\n运行结果:\n\n\n\n源码分析\n\n接下来分析下coroutine的实现\n\ndef _make_coroutine_wrapper(func, replace_callback):\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        future = TracebackFuture()\n\n        if replace_callback and 'callback' in kwargs:\n            callback = kwargs.pop('callback')\n            IOLoop.current().add_future(\n                future, lambda future: callback(future.result()))\n\n        try:\n            result = func(*args, **kwargs)\n        except (Return, StopIteration) as e:\n            result = getattr(e, 'value', None)\n        except Exception:\n            future.set_exc_info(sys.exc_info())\n            return future\n        else:\n            if isinstance(result, types.GeneratorType):\n                try:\n                    orig_stack_contexts = stack_context._state.contexts\n                    yielded = next(result)\n                    if stack_context._state.contexts is not orig_stack_contexts:\n                        yielded = TracebackFuture()\n                        yielded.set_exception(\n                            stack_context.StackContextInconsistentError(\n                                'stack_context inconsistency (probably caused '\n                                'by yield within a \"with StackContext\" block)'))\n                except (StopIteration, Return) as e:\n                    future.set_result(getattr(e, 'value', None))\n                except Exception:\n                    future.set_exc_info(sys.exc_info())\n                else:\n                    Runner(result, future, yielded)\n                try:\n                    return future\n                finally:\n                    future = None\n        future.set_result(result)\n        return future\n    return wrapper\n\n\n如源码所示,func运行的结果是GeneratorType ,yielded = next(result),\n运行至原函数的yield位置,返回的是原函数func内部 yield 右边返回的对象(必须是Future或Future的list)给yielded.\n经过Runner(result, future, yielded) 对yielded进行处理.\n在此就 贴出Runner的代码了.\nRunner初始化过程,调用handle_yield, 查看yielded是否已done了,否则add_future运行Runner的run方法,run方法中如果yielded对象已完成,用对它的gen调用send,发送完成的结果.\n所以yielded在什么地方被set_result非常重要,\n当被set_result的时候,才会send结果给原func,完成整个异步操作\n\n详情可以查看tornado 中重要的对象 iostream,源码中iostream的  _handle_connect,如此设置了连接的result.\n\ndef _handle_connect(self):\n        err = self.socket.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)\n        if err != 0:\n            self.error = socket.error(err, os.strerror(err))\n            if self._connect_future is None:\n                gen_log.warning(\"Connect error on fd %s: %s\",\n                                self.socket.fileno(), errno.errorcode[err])\n            self.close()\n            return\n        if self._connect_callback is not None:\n            callback = self._connect_callback\n            self._connect_callback = None\n            self._run_callback(callback)\n        if self._connect_future is not None:\n            future = self._connect_future\n            self._connect_future = None\n            future.set_result(self)\n        self._connecting = False\n\n\n最后贴上一个简单的测试代码,演示coroutine,future的用法\n\nimport tornado.ioloop\nfrom tornado.gen import coroutine\nfrom tornado.concurrent import Future\n\n@coroutine\ndef asyn_sum(a, b):\n    print(\"begin calculate:sum %d+%d\"%(a,b))\n    future = Future()\n    future2 = Future()\n    iol = tornado.ioloop.IOLoop.instance()\n\n    print future\n\n    def callback(a, b):\n        print(\"calculating the sum of %d+%d:\"%(a,b))\n        future.set_result(a+b)\n\n        iol.add_timeout(iol.time()+3,lambda f:f.set_result(None),future2)\n    iol.add_timeout(iol.time()+3,callback, a, b)\n\n    result = yield future\n\n    print(\"after yielded\")\n    print(\"the %d+%d=%d\"%(a, b, result))\n\n    yield future2\n\n    print 'after future2'\n\ndef main():\n    f =  asyn_sum(2,3)\n\n    print ''\n    print f\n    tornado.ioloop.IOLoop.instance().start()\n\nif __name__ == \"__main__\":\n    main()\n\n\n\n运行结果:\n\n\n\n为什么代码中个yield都起作用了? 因为Runner.run里,最后继续用handle_yield处理了send后返回的yielded对象,意思是func里可以有n干个yield操作\n\nif not self.handle_yield(yielded):\n                    return\n\n\n总结\n\n至此,已完成tornado中重要的几个模块的流程,其他模块也是由此而来.写了这么多,越写越卡,就到此为止先吧,\n\n最后的最后的最后\n\n啊~~~~~~好想有份工作 和女朋友啊~~~~~\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "26"}