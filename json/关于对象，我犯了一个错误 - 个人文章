{"title": "关于对象，我犯了一个错误 - 个人文章 ", "index": "对象,python", "content": "在我的一个业务逻辑代码中，我不幸需要编写以下类(这里我们用抽象的A, B, C表示)\nclass A:\n   value = 0\n   def __init__(self, b):\n                self.b = b\n    \n   def set_1(self):\n        self.value = 1\n        \nclass B:\n        \n    def __init__(self):\n        pass\n        \n    def reset(self):\n        self.a = A(self)\n \n这是两个没有什么问题的对象，不过在创建B的实例时，会让自己的属性a指向一个A的实例，而a中的属性b又指向该B实例所以我们可以像下面这样访问：\nb = B()\na = b.a\nassert b.a.b is b\nassert b.a.b.a is a\n这样能够使得b拥有a的控制权，也同时使得a拥有b的控制权。\n但是当我试图用一个类C来代理实例b时，却犯了一个错误\nclass C:\n    b = B()\n    a = b.a\n \n    def __init__(self):\n        pass\n \n    def read_a(self):\n        return self.b.a.value\n \n \nc = C()\nassert c.read_a() == 0\nc.a.set_1()\nassert c.read_a() == 1\n \nc.b.reset()\nassert c.read_a() == 0\nassert c.a == 0  # AssertionError\n为什么这里我会脑子抽断言 c.a == 0呢？因为我主观地认为这里实例b执行了reset函数，于是重新实例化了属性b.a=A(self)那么a在实例过程中，会让a.value = 0所以 c.b.a.value == 0而我们的c.a = b.a所以c.a.value == c.b.a.value == 0几乎完美的推理!!!\n但是我忽略了，这里的c.a is not c.b.a !!!原因如下：假设一开始实例化A, B 为 a1, b1c.a -> a1c.b -> b1那么当b1.reset() 的时候，a是重新实例化的一个A对象，用JAVA的话来说，就是重新new 了一个Ab1.a -> a2故c.b.a == c.b1.a == a2而c.a == a1a1.value在a1.set_1()之后，赋值为 1a2.value在b1.reset()之后，赋值为 0所以断言错误\n记录这个错误警告自己在今后的编码过程中不要一味主观地用数学观点，而要弄清楚具体对象。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}