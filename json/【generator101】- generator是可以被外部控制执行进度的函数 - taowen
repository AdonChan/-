{"title": "【generator101】- generator是可以被外部控制执行进度的函数 - taowen ", "index": "coroutine,python", "content": "很多码农终其一生可能在代码上干的事情无非就是追求两件事情：Logic Locality 和 Data Locality。前者决定了开发效率，后者决定了运行效率。协程是用来处理I/O阻塞和流程阻塞这两个普世问题的得力工具，可以达到比较好的Logic Locality。\n\ndef demo_before_and_after():\n    print('before')\n    yield\n    print('after')\n\ngen = demo_before_and_after()\ngen.next()\ngen.next()\n\n\n这段代码执行的输出是\n\ngen created\nbefore\nafter\nTraceback (most recent call last):\n...\nStopIteration\n\n\n通过这个例子，可以了解到Python的generator的两个特性。\n首先，demo_before_and_after()的时候，before并没有被打印出来。说明demo_before_and_after这个函数在这个时候还没有真正开始执行。gen.next()被调用一次，函数就往前执行一步。通过控制gen.next()，可以从外面控制函数内部的执行进度。\n其次，Python的generator没有类似Java的Iterator.hasNext这样的设计，直接以抛出StopIteration来传达“到尾巴了”这个消息。\n\n利用generator这个特性，Python的标准库提供了一个非常方便的contextmanager的设计\n\nimport contextlib\n\n@contextlib.contextmanager\ndef demo_before_and_after():\n    print('before')\n    yield\n    print('after')\n\nwith demo_before_and_after():\n    print('inside')\n\n\n输出结果是\n\nbefore\ninside\nafter\n\n\n很多需要获得资源，使用资源，然后确保资源被正确释放的场合（类似C++的RAII），都可以用上面的写法来实现。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "4"}