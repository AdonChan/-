{"title": "head first python（第三章）–学习笔记 - 线上猛如虎，线下怂如鼠（WhyNotBetter） ", "index": "python", "content": "1.介绍基础文件，输入，输出\n\nopen()\n打开文件，一次传入一行数据，可以结合for循环和readline()来使用\n\nclose()\n用来关闭open打开的文件\n\nthe_file = open('sketch.txt')\n\nthe_file.close()\n\n\n例子：\n\n>>> data = open('/root/python_test/site_list.txt')\n>>> print(data.readline())\nwww.godblessyuan.com\n\n\n一些基础的目录管理函数\n\n>>> import os\n>>> os.getcwd()   #获取当前目录\n'/root'\n>>> os.chdir('/root/python_test')  #切换目录\n>>> os.getcwd()\n'/root/python_test'\n>>> \n\n\n2.需要对数据做一些处理，例如像分隔它，以冒号为分界符\n\n>>> data = open('/root/python_test/headfirstpython/sketch.txt')\n>>> for each_line in data:\n...     (role,line_spoken) = each_line.split(':')   #这里使用idel时候，需要注意的是代码之间的缩进\n...     print role\n...     print line_spoken\n... \n\nOther Man\n Anyway, I did.\n\nMan\n You most certainly did not!\n\nTraceback (most recent call last):\n  File \"<stdin>\", line 2, in <module>\nValueError: too many values to unpack\n\n\n遇到报错了，报错意思大概是太多值导致没有被处理，检查发现是因为有些数据是超过一个冒号的，所以这些数据会出错，因为split()处理不了,但是检查了split函数的使用说明，发现是可以支持这种情况的，\n\n>>> help(each_line.split)\nHelp on built-in function split:\n\nsplit(...)\nS.split([sep [,maxsplit]]) -> list of strings\n\nReturn a list of the words in the string S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are removed\nfrom the result.\n(END) \n\n\n\n  1.检查方式可以参考上面的方法。\n  \n  2.支持这种情况的参数是一个叫maxsplit的参数，如果有maxsplit的话，那么至多是maxsplit的数量以上的分界符才会被处理，这样就很好的避免太多分界符的情况了。\n\n\n如这样：\n\ndata = open('sketch.txt')\n\nfor each_line in data:\n    (role, line_spoken) = each_line.split(':', 1)\n    print role\n    print line_spoken\n\ndata.close()\n\n\n不过，即使加了参数，还是遇到报错了\n\nMan\n Oh no you didn't!\n\nOther Man\n Oh yes I did!\n\nMan\n Oh look, this isn't an argument!\n\nTraceback (most recent call last):\n  File \"<stdin>\", line 2, in <module>\nValueError: need more than 1 value to unp\n\n\n这里是说需要超过一个值去处理，查看了数据，发现是有些数据没有冒号导致程序处理失败。\n\n3.增加逻辑来处理\n\n首先通过观察find()方法对于不同的数据返回的值是不同的。\n\n>>> each_line = 'iiiii' \n>>> each_line.find(':')\n-1\n>>> each_line = 'iiiii:'\n>>> each_line.find(':') \n5\n>>> \n\n\n然后可以使用的逻辑有2种，一种是if判断，另外一种是try：expoet\n\ntry:\n    你的代码（可能会导致运行错误的）\nexcept:\n    错误回复代码\n\n\n这种方式的机制是通过捕获某代码的错误，然后执行响应的修复代码，例子：\n\ndata = open('sketch.txt')\n\nfor each_line in data:\n    try:\n        (role, line_spoken) = each_line.split(':', 1)\n        print role\n        print line_spoken\n    except:\n        pass\n\ndata.close()\n\n\n如果\n\n        (role, line_spoken) = each_line.split(':', 1)\n        print role\n        print line_spoken\n\n\n这里有其中一句代码是执行失败的，都会转到pass里面去，pass代表空语句，或者null，什么也不做。\n\n或者就是使用最简单的if判断\n\nfor each_line in data:\n    if not each_line.find(':') == -1:   #not关键字是将一个条件取反\n        (role, line_spoken) = each_line.split(':', 1)\n        print(role, end='')\n        print(' said: ', end='')\n        print(line_spoken, end='')\n\ndata.close()\n\n\n不过需要注意的是，像下面这种多重try：except的代码是很容易影响到我们判断那一部分代码才是真正有问题的代码，因为无论里面和外面的try出错了，都会返回 print('The datafile is missing!')，这样就不能判断是那部分代码有问题了。\n\ntry:\n    data = open('sketch.txt')\n\n    for each_line in data:\n        try:\n            (role, line_spoken) = each_line.split(':', 1)\n            print role\n            print line_spoken\n        except:\n            pass\n\n    data.close()\nexcept:\n    print('The datafile is missing!')\n\n\n所以需要加一些标记，标识（ValueError-数据不符合期望的格式时会出现,IOError-数据无法正常访问时会出现。）\n\ntry:\n    data = open('sketch.txt')\n\n    for each_line in data:\n        try:\n            (role, line_spoken) = each_line.split(':')\n            print role\n            print line_spoken\n        except ValueError:\n            pass\n\n    data.close()\nexcept IOError:\n    print('The datafile is missing!')\n\n\n\nhttp://www.godblessyuan.com/2015/04/20/head_first_python_chapter_3_lea...\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "4"}