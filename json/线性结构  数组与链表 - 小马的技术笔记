{"title": "线性结构  数组与链表 - 小马的技术笔记 ", "index": "es6,数据结构,javascript,python", "content": "线性结构  数组与链表\n线性结构\n线性数据结构有两端，有时被称为左右，某些情况被称为前后。你也可以称为顶部和底部，名字都不重要。将两个线性数据结构区分开的方法是添加和移除项的方式，特别是添加和移除项的位置。例如一些结构允许从一端添加项，另一些允许从另一端移除项。\n数组或列表\n数组(Array)是编程界最常见的数据结构，有些编程语言被称作位列表(List)。几乎所有编程语言都原生内置数组类型，只是形式向略有不同，因为数组是最简单的内存数据结构。\n数组的定义是：一个存储元素的线性集合(Collection)，元素可以通过索引(Index)来任意存取，索引通常是数字，用来计算元素之间存储位置的偏移量。\n链表\n数组的缺点：要存储多个元素，数组(或列表)可能是最常见的数据结构。但是数组不总是组织数据的最佳结构。在大多数编程语言中，数组的大小是固定的，所以当数组被填满时，再要加入新的元素会非常困难。并且从数组起点或中间插入或移除元素的成本很高，因为需要将数组中的其他元素向前后平移。\n链表(Linked list)中的元素在内存中不是连续存放的。链表是由一组节点(Node)组成的集合，每个节点由元素本身和一个指向下一个元素的引用(也被称作链接或指针)组成。相对于数组，链表的好处在于，添加或移除元素的时候不需要移动其他元素。\n链表的种类\n单向链表(Singly linked list)：是最基本的链表，每个节点一个引用，指向下一个节点。单向链表的第一个节点称为头节点(head node)，最后一个节点称为尾节点(tail node)，尾节点的引用为空（None），不指向下一个节点。\n双向链表(Doubly linked list)和单向链表的区别在于，在链表中的节点引用是双向的，一个指向下一个元素，一个指向上一个元素。\n循环链表(Circular linked list)和单向链表类似，节点类型都一样。唯一的区别是    ，链表的尾节点引用指向头节点。\n双向循环链表：类似于双向链表，尾节点的后置引用指向头节点，头节点的前置引用指向尾节点。\n单向链表的操作\n\n\n方法\n操作\n\n\n\nappend\n向链表尾部添加一个元素\n\n\ninsert\n在链表的指定位置插入一个元素\n\n\npop\n从链表特定位置删除并返回元素\n\n\nremove\n从链表中删除给定的元素\n\n\nfind\n返回元素的索引\n\n\niter\n迭代链表元素\n\n\nsize\n获取链表大小\n\n\nclear\n清空链表\n\n\n\nPython实现单向链表\n# python3\nclass Node:\n    def __init__(self, value=None, next=None):\n        self.value = value\n        self.next = next\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n        self.tail = None\n        self.size = 0\n\n    def append(self, value):\n        node = Node(value)\n        if self.head is None:\n            self.head = node\n            self.tail = node\n        else:\n            self.tail.next = node\n            self.tail = node\n        self.size += 1\n\n    def insert(self, index, value):\n        if 0 <= index <= self.size:\n            node = Node(value)\n            current = self.head\n            previous = Node(next=current)\n            count = 0\n            while count < index:\n                previous = current\n                current = current.next\n                count += 1\n            previous.next = node\n            node.next = current\n            if previous.value is None:\n                self.head = node\n            if node.next is None:\n                self.tail = node\n            self.size += 1\n            return True\n        else:\n            return False\n\n    def pop(self, index):\n        if 0 <= index <= self.size and self.head is not None:\n            current = self.head\n            previous = Node(next=current)\n            count = 0\n            while count < index:\n                previous = current\n                current = current.next\n                count += 1\n            previous.next = current.next\n            if previous.value is None:\n                self.head = current.next\n            if current.next is None:\n                self.tail = previous\n            self.size -= 1\n            return current.value\n        else:\n            return None\n\n    def remove(self, item):\n        found = False\n        current = self.head\n        previous = Node(next=current)\n        index = 0\n        while not found and current is not None:\n            if current.value == item:\n                found = True\n            else:\n                previous = current\n                current = current.next\n            index += 1\n        if found:\n            previous.next = current.next\n            if previous.value is None:\n                self.head = current.next\n            if current.next is None:\n                self.tail = previous\n            self.size -= 1\n            return index\n        else:\n            return -1\n\n    def find(self, item):\n        current = self.head\n        count = 0\n        while current is not None:\n            if current.value == item:\n                return count\n            else:\n                current = current.next\n                count += 1\n        return -1\n        \n    def iter(self):\n        current = self.head\n        while current is not None:\n            yield current.value\n            current = current.next\n\n    def size(self):\n        return self.size\n\n    def clear(self):\n        self.head = None\n        self.tail = None\n        self.size = 0\n\n    def is_empty(self):\n        return self.size == 0\n        \n    def __len__(self):\n        return self.size()\n\n    def __iter__(self):\n        iter self.iter()\n\n    def __getitem__(self, index):\n        return self.find(index)\n\n    def __contains__(self, item):\n        return self.find(item) != -1\nJavaScript实现单向链表\n// ES6\nclass Node {\n    constructor(value=null, next=null) {\n        this.value = value;\n        this.next = next;\n    }\n}\n\nclass LinkedList {\n    constructor() {\n        this.head = null;\n        this.tail = null;\n        this.size = 0;\n    }\n    append(value) {\n        let node = new Node(value);\n        if (this.head === null) {\n            this.head = node;\n            this.tail = node;\n        } else {\n            this.tail.next = temp;\n            this.tail = temp;\n        }\n        this.size += 1;\n    }\n    insert(index, value) {\n        if (0 <= index <= this.size) {\n            let node = new Node(value);\n            let current = this.head;\n            let previous = new Node(next=current);\n            let count = 0;\n            while (count < index) {\n                previous = current;\n                current = current.next;\n                count += 1;\n            }\n            previous.next = node\n            node.next = current\n            if (previous.value === null) {\n                this.head = node;\n            }\n            if (node.next === null) {\n                this.tail = node;\n            }\n            this.size += 1\n            return true;\n        } else {\n            return false;\n        }\n    }\n    pop(index) {\n        if (0 <= index <= self.size && this.head === null) {\n            let current = this.head;\n            let previous = new Node(next=current);\n            let count = 0;\n            while (count < index) {\n                previous = current;\n                current = current.next;\n                count += 1;\n            }\n            previous.next = current.next;\n            if (previous.value === null) {\n                this.head = current.next;\n            }\n            if (current.next === null) {\n                this.tail = previous;\n            }\n            this.size -= 1;\n            return current.value;\n        } else {\n            return null;\n        }\n    }\n    remove(item) {\n        let found = false;\n        let current = this.head;\n        let previous = new Node(next=current);\n        let index = 0;\n        while (! found && current !== null) {\n            if (current.value === item) {\n                found = true;\n            } else {\n                previous = current;\n                current = current.next;\n            }\n            index += 1\n        }\n        if (found) {\n            previous.next = current.next;\n            if (previous.value === null) {\n                this.head = current.next;\n            }\n            if (current.next === null) {\n                this.tail = previous;\n            }\n            this.size -= 1;\n            return index;\n        } else {\n            return -1;\n        }\n    }\n    find(item) {\n        let current = this.head;\n        let count = 0;\n        while (current !== null) {\n            if (current.value === item) {\n                return count;\n            } else {\n                current = current.next;\n                count += 1;\n            }\n        }\n        return -1;\n    }\n    iter() {\n        let current = this.head;\n        while (current !== null) {\n            yield current.value;\n            current = current.next;\n        }\n    }\n    size() {\n        return this.size;\n    }\n    clear() {\n        this.head = null;\n        this.tail = null;\n        this.size = 0;\n    }\n    isEmpty() {\n        return this.size === 0;\n    }\n}\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}