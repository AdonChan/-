{"title": "python---进程 - python学习 ", "index": "python", "content": "理论知识\n操作系统背景知识\n顾名思义，进程即正在执行的一个过程。进程是对正在运行程序的一个抽象。进程的概念起源于操作系统，是操作系统最核心的概念，也是操作系统提供的最古老也是最重要的抽象概念之一。操作系统的其他所有内容都是围绕进程的概念展开的。所以想要真正了解进程，必须事先了解操作系统，点击进入\nPS：即使可以利用的cpu只有一个（早期的计算机确实如此），也能保证支持（伪）并发的能力。将一个单独的cpu变成多个虚拟的cpu（多道技术：时间多路复用和空间多路复用+硬件上支持隔离），没有进程的抽象，现代计算机将不复存在。必备的理论基础：\n#一 操作系统的作用：\n    1：隐藏丑陋复杂的硬件接口，提供良好的抽象接口\n    2：管理、调度进程，并且将多个进程对硬件的竞争变得有序\n\n#二 多道技术：\n    1.产生背景：针对单核，实现并发\n    ps：\n    现在的主机一般是多核，那么每个核都会利用多道技术\n    有4个cpu，运行于cpu1的某个程序遇到io阻塞，会等到io结束再重新调度，会被调度到4个\n    cpu中的任意一个，具体由操作系统调度算法决定。\n    \n    2.空间上的复用：如内存中同时有多道程序\n    3.时间上的复用：复用一个cpu的时间片\n       强调：遇到io切，占用cpu时间过长也切，核心在于切之前将进程的状态保存下来，这样\n            才能保证下次切换回来时，能基于上次切走的位置继续运行\n什么是进程\n进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。\n狭义定义：进程是正在运行的程序的实例（an instance of a computer program that is being executed）。广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。\n1.进程的概念\n第一，进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。\n第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体，我们称其为进程。[3] \n进程是操作系统中最基本、重要的概念。是多道程序系统出现后，为了刻画系统内部出现的动态情况，描述系统内部各道程序的活动规律引进的一个概念,所有多道程序设计操作系统都建立在进程的基础上。\n2.操作系统引入进程的概念的原因\n从理论角度看，是对正在运行的程序过程的抽象；\n从实现角度看，是一种数据结构，目的在于清晰地刻画动态系统的内在规律，有效管理和调度进入计算机系统主存储器运行的程序。\n3.进程的特征\n动态性：进程的实质是程序在多道程序系统中的一次执行过程，进程是动态产生，动态消亡的。\n并发性：任何进程都可以同其他进程一起并发执行\n独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位；\n异步性：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进\n结构特征：进程由程序、数据和进程控制块三部分组成。\n多个不同的进程可以包含相同的程序：一个程序在不同的数据集里就构成不同的进程，能得到不同的结果；但是执行过程中，程序不能发生改变。\n4.进程与程序中的区别\n程序是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。\n而进程是程序在处理机上的一次执行过程，它是一个动态的概念。\n程序可以作为一种软件资料长期存在，而进程是有一定生命期的。\n程序是永久的，进程是暂时的。\n注意：同一个程序执行两次，就会在操作系统中出现两个进程，所以我们可以同时运行一个软件，分别做不同的事情也不会混乱\n进程调度\n要想多个进程交替运行，操作系统必须对这些进程进行调度，这个调度也不是随即进行的，而是需要遵循一定的法则，由此就有了进程的调度算法。1.先来先服务调度算法\n先来先服务（FCFS）调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。FCFS算法比较有利于长作业（进程），而不利于短作业（进程）。由此可知，本算法适合于CPU繁忙型作业，而不利于I/O繁忙型的作业（进程）。\n2.短作业优先调度算法\n短作业（进程）优先调度算法（SJ/PF）是指对短作业或短进程优先调度的算法，该算法既可用于作业调度，也可用于进程调度。但其对长作业不利；不能保证紧迫性作业（进程）被及时处理；作业的长短只是被估算出来的。\n3.时间片轮转法\n时间片轮转(Round Robin，RR)法的基本思路是让每个进程在就绪队列中的等待时间与享受服务的时间成比例。在时间片轮转法中，需要将CPU的处理时间分成固定大小的时间片，例如，几十毫秒至几百毫秒。如果一个进程在被调度选中之后用完了系统规定的时间片，但又未完成要求的任务，则它自行释放自己所占有的CPU而排到就绪队列的末尾，等待下一次调度。同时，进程调度程序又去调度当前就绪队列中的第一个进程。\n      显然，轮转法只能用来调度分配一些可以抢占的资源。这些可以抢占的资源可以随时被剥夺，而且可以将它们再分配给别的进程。CPU是可抢占资源的一种。但打印机等资源是不可抢占的。由于作业调度是对除了CPU之外的所有系统硬件资源的分配，其中包含有不可抢占资源，所以作业调度不使用轮转法。\n在轮转法中，时间片长度的选取非常重要。首先，时间片长度的选择会直接影响到系统的开销和响应时间。如果时间片长度过短，则调度程序抢占处理机的次数增多。这将使进程上下文切换次数也大大增加，从而加重系统开销。反过来，如果时间片长度选择过长，例如，一个时间片能保证就绪队列中所需执行时间最长的进程能执行完毕，则轮转法变成了先来先服务法。时间片长度的选择是根据系统对响应时间的要求和就绪队列中所允许最大的进程数来确定的。\n      在轮转法中，加入到就绪队列的进程有3种情况：\n      一种是分给它的时间片用完，但进程还未完成，回到就绪队列的末尾等待下次调度去继续执行。\n      另一种情况是分给该进程的时间片并未用完，只是因为请求I/O或由于进程的互斥与同步关系而被阻塞。当阻塞解除之后再回到就绪队列。\n      第三种情况就是新创建进程进入就绪队列。\n      如果对这些进程区别对待，给予不同的优先级和时间片从直观上看，可以进一步改善系统服务质量和效率。例如，我们可把就绪队列按照进程到达就绪队列的类型和进程被阻塞时的阻塞原因分成不同的就绪队列，每个队列按FCFS原则排列，各队列之间的进程享有不同的优先级，但同一队列内优先级相同。这样，当一个进程在执行完它的时间片之后，或从睡眠中被唤醒以及被创建之后，将进入不同的就绪队列。  \n4.多级反馈队列\n前面介绍的各种用作进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程，而且如果并未指明进程的长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。\n而多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，而且还可以满足各种类型进程的需要，因而它是目前被公认的一种较好的进程调度算法。在采用多级反馈队列调度算法的系统中，调度算法的实施过程如下所述。\n(1) 应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第i+1个队列的时间片要比第i个队列的时间片长一倍。\n(2) 当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第n队列后，在第n 队列便采取按时间片轮转的方式运行。\n\n(3) 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1～(i-1)队列均空时，才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列(第1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i队列的末尾，把处理机分配给新到的高优先权进程。\n进程的并行与并发\n并行 : 并行是指两者同时执行，比如赛跑，两个人都在不停的往前跑；（资源够用，比如三个线程，四核的CPU ）并发 : 并发是指资源有限的情况下，两者交替轮流使用资源，比如一段路(单核CPU资源)同时只能过一个人，A走一段后，让给B，B用完继续给A ，交替使用，目的是提高效率。区别:并行是从微观上，也就是在一个精确的时间片刻，有不同的程序在执行，这就要求必须有多个处理器。并发是从宏观上，在一个时间段上可以看出是同时执行的，比如一个服务器同时处理多个session。\n同步异步阻塞非阻塞\n状态介绍：\n\n在了解其他概念之前，我们首先要了解进程的几个状态。在程序运行的过程中，由于被操作系统的调度算法控制，程序会进入几个状态：就绪，运行和阻塞。1.就绪(Ready)状态\n- 当进程已分配到除CPU以外的所有必要的资源，只要获得处理机便可立即执行，这时的进程状态称为就绪状态。\n\n2.执行/运行（Running）状态\n- 当进程已获得处理机，其程序正在处理机上执行，此时的进程状态称为执行状态。\n\n3.阻塞(Blocked)状态\n- 正在执行的进程，由于等待某个事件发生而无法执行时，便放弃处理机而处于阻塞状态。引起进程阻塞的事件可有多种，例如，等待I/O完成、申请缓冲区不能满足、等待信件(信号)等。\n\n\n\n同步和异步\n所谓同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。要么成功都成功，失败都失败，两个任务的状态可以保持一致。\n　　所谓异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。\n例子：\n比如我去银行办理业务，可能会有两种方式：\n第一种 ：选择排队等候；\n第二种 ：选择取一个小纸条上面有我的号码，等到排到我这一号时由柜台的人通知我轮到我去办理业务了；\n\n第一种：前者(排队等候)就是同步等待消息通知，也就是我要一直在等待银行办理业务情况；\n\n第二种：后者(等待别人通知)就是异步等待消息通知。在异步消息处理中，等待消息通知者(在这个例子中就是等待办理业务的人)往往注册一个回调机制，在所等待的事件被触发时由触发机制(在这里是柜台的人)通过某种机制(在这里是写在小纸条上的号码，喊号)找到等待该事件的人。\n阻塞与非阻塞\n阻塞和非阻塞这两个概念与程序（线程）等待消息通知(无所谓同步或者异步)时的状态有关。也就是说阻塞与非阻塞主要是程序（线程）等待消息通知时的状态角度来说的继续上边的例子：\n继续上面的那个例子，不论是排队还是使用号码等待通知，如果在这个等待的过程中，等待者除了等待消息通知之外不能做其它的事情，那么该机制就是阻塞的，表现在程序中,也就是该程序一直阻塞在该函数调用处不能继续往下执行。\n相反，有的人喜欢在银行办理这些业务的时候一边打打电话发发短信一边等待，这样的状态就是非阻塞的，因为他(等待者)没有阻塞在这个消息通知上，而是一边做自己的事情一边等待。\n\n注意：同步非阻塞形式实际上是效率低下的，想象一下你一边打着电话一边还需要抬头看到底队伍排到你了没有。如果把打电话和观察排队的位置看成是程序的两个操作的话，这个程序需要在这两种不同的行为之间来回的切换，效率可想而知是低下的；而异步非阻塞形式却没有这样的问题，因为打电话是你(等待者)的事情，而通知你则是柜台(消息触发机制)的事情，程序没有在两种不同的操作中来回切换。\n同步/异步与阻塞/非阻塞\n1.同步阻塞形式\n- 效率最低。拿上面的例子来说，就是你专心排队，什么别的事都不做。\n2.异步阻塞形式\n- 如果在银行等待办理业务的人采用的是异步的方式去等待消息被触发（通知），也就是领了一张小纸条，假如在这段时间里他不能离开银行做其它的事情，那么很显然，这个人被阻塞在了这个等待的操作上面；\n　　- 异步操作是可以被阻塞住的，只不过它不是在处理消息时阻塞，而是在等待消息通知时被阻塞。3.同步非阻塞形式\n- 实际上是效率低下的。想象一下你一边打着电话一边还需要抬头看到底队伍排到你了没有，如果把打电话和观察排队的位置看成是程序的两个操作的话，这个程序需要在这两种不同的行为之间来回的切换，效率可想而知是低下的。\n4.异步非阻塞形式\n- 效率更高\n- 因为打电话是你(等待者)的事情，而通知你则是柜台(消息触发机制)的事情，程序没有在两种不同的操作中来回切换。\n- 比如说，这个人突然发觉自己烟瘾犯了，需要出去抽根烟，于是他告诉大堂经理说，排到我这个号码的时候麻烦到外面通知我一下，那么他就没有被阻塞在这个等待的操作上面，自然这个就是异步+非阻塞的方式了。\n- 很多人会把同步和阻塞混淆，是因为很多时候同步操作会以阻塞的形式表现出来，同样的，很多人也会把异步和非阻塞混淆，因为异步操作一般都不会在真正的IO操作处被阻塞。\n\n进程的创建与结束\n1.进程的创建但凡是硬件，都需要有操作系统去管理，只要有操作系统，就有进程的概念，就需要有创建进程的方式，一些操作系统只为一个应用程序设计，比如微波炉中的控制器，一旦启动微波炉，所有的进程都已经存在。而对于通用系统（跑很多应用程序），需要有系统运行过程中创建或撤销进程的能力，主要分为4中形式创建新的进程：　　1. 系统初始化（查看进程linux中用ps命令，windows中用任务管理器，前台进程负责与用户交互，后台运行的进程与用户无关，运行在后台并且只在需要时才唤醒的进程，称为守护进程，如电子邮件、web页面、新闻、打印）　　2. 一个进程在运行过程中开启了子进程（如nginx开启多进程，os.fork,subprocess.Popen等）　　3. 用户的交互式请求，而创建一个新进程（如用户双击暴风影音）　　4. 一个批处理作业的初始化（只在大型机的批处理系统中应用）无论哪一种，新进程的创建都是由一个已经存在的进程执行了一个用于创建进程的系统调用而创建的。\n1. 在UNIX中该系统调用是：fork，fork会创建一个与父进程一模一样的副本，二者有相同的存储映像、同样的环境字符串和同样的打开文件（在shell解释器进程中，执行一个命令就会创建一个子进程）\n\n　　2. 在windows中该系统调用是：CreateProcess，CreateProcess既处理进程的创建，也负责把正确的程序装入新进程。\n\n　　关于创建子进程，UNIX和windows\n\n　　1.相同的是：进程创建后，父进程和子进程有各自不同的地址空间（多道技术要求物理层面实现进程之间内存的隔离），任何一个进程的在其地址空间中的修改都不会影响到另外一个进程。\n\n　　2.不同的是：在UNIX中，子进程的初始地址空间是父进程的一个副本，提示：子进程和父进程是可以有只读的共享内存区的。但是对于windows系统来说，从一开始父进程与子进程的地址空间就是不同的。\n2.进程的结束\n正常退出（自愿，如用户点击交互式页面的叉号，或程序执行完毕调用发起系统调用正常退出，在linux中用exit，在windows中用ExitProcess）\n　　- 出错退出（自愿，python a.py中a.py不存在）　　- 严重错误（非自愿，执行非法指令，如引用不存在的内存，1/0等，可以捕捉异常，try...except...）\n被其他进程杀死（非自愿，如kill -9）\n在python程序中的进程操作\nprocess模块介绍\nprocess模块是一个创建进程的模块，借助这个模块，就可以完成进程的创建。\nProcess([group [, target [, name [, args [, kwargs]]]]])，由该类实例化得到的对象，表示一个子进程中的任务（尚未启动）\n\n强调：\n1. 需要使用关键字的方式来指定参数\n2. args指定的为传给target函数的位置参数，是一个元组形式，必须有逗号\n\n参数介绍：\n1 group参数未使用，值始终为None\n2 target表示调用对象，即子进程要执行的任务\n3 args表示调用对象的位置参数元组，args=(1,2,'egon',)\n4 kwargs表示调用对象的字典,kwargs={'name':'egon','age':18}\n5 name为子进程的名称\n1.方法介绍\n1 p.start()：启动进程，并调用该子进程中的p.run() \n2 p.run():进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法  \n3 p.terminate():强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成了僵尸进程，使用该方法需要特别小心这种情况。如果p还保存了一个锁那么也将不会被释放，进而导致死锁\n4 p.is_alive():如果p仍然运行，返回True\n5 p.join([timeout]):主线程等待p终止（强调：是主线程处于等的状态，而p是处于运行的状态）。timeout是可选的超时时间，需要强调的是，p.join只能join住start开启的进程，而不能join住run开启的进程\n2.属性介绍\n1 p.daemon：默认值为False，如果设为True，代表p为后台运行的守护进程，当p的父进程终止时，p也随之终止，并且设定为True后，p不能创建自己的新进程，必须在p.start()之前设置\n2 p.name:进程的名称\n3 p.pid：进程的pid\n4 p.exitcode:进程在运行时为None、如果为–N，表示被信号N结束(了解即可)\n5 p.authkey:进程的身份验证键,默认是由os.urandom()随机生成的32字符的字符串。这个键的用途是为涉及网络连接的底层进程间通信提供安全性，这类连接只有在具有相同的身份验证键时才能成功（了解即可）\n3.在windows中使用process模块的注意事项\n在Windows操作系统中由于没有fork(linux操作系统中创建进程的机制)，在创建子进程的时候会自动 import 启动它的这个文件，而在 import 的时候又执行了整个文件。因此如果将process()直接写在文件中就会无限递归创建子进程报错。所以必须把创建子进程的部分使用if __name__ ==‘__main__’ 判断保护起来，import 的时候  ，就不会递归运行了。\n使用process模块创建进程\n在一个python进程中开启子进程，start方法和并发效果。1.在python中启动的第一个子进程\nimport time\nfrom multiprocessing import Process\n\ndef f(name):\n    print('hello', name)\n    print('我是子进程')\n\nif __name__ == '__main__':\n    p = Process(target=f, args=('bob',))\n    p.start()\n    time.sleep(1)\n    print('执行主进程的内容了')\n \n2.join方法\nimport time\nfrom multiprocessing import Process\n\ndef f(name):\n    print('hello', name)\n    time.sleep(1)\n    print('我是子进程')\n\n\nif __name__ == '__main__':\n    p = Process(target=f, args=('bob',))\n    p.start()\n    p.join()\n    print('我是父进程')\n3.查看主进程和子进程的进程号\nimport os\nfrom multiprocessing import Process\n\ndef f(x):\n    print('子进程id ：',os.getpid(),'父进程id ：',os.getppid())\n    return x*x\n\nif __name__ == '__main__':\n    print('主进程id ：', os.getpid())\n    p_lst = []\n    for i in range(5):\n        p = Process(target=f, args=(i,))\n        p.start()\n进阶，多个进程同时运行（注意，子进程的执行顺序不是根据启动顺序决定的1.多个进程同时运行\nimport time\nimport os\nfrom multiprocessing import Process\n\n\ndef f(name):\n    print('hello', name,'子进程id',os.getpid())\n    time.sleep(1)\n\n\nif __name__ == '__main__':\n    p_lst = []\n    for i in range(5):\n        p = Process(target=f, args=('bob',))\n        p.start()\n        p_lst.append(p)\n    print(\"主进程id\",os.getpid())\n2.多个进程同时运行，再谈join方法(1)\nimport time\nimport os\nfrom multiprocessing import Process\n\n\ndef f(name):\n    print('hello', name,\"子进程pid\",os.getpid())\n    time.sleep(1)\n\n\nif __name__ == '__main__':\n    p_lst = []\n    for i in range(5):\n        p = Process(target=f, args=('bob',))\n        p.start()\n        p_lst.append(p)\n        p.join()\n    print('父进程在执行')\n3.多个进程同时运行，再谈join方法(2)\nimport time\nimport os\nfrom multiprocessing import Process\n\ndef f(name):\n    print('hello', name,\"子进程pid\",os.getpid())\n    time.sleep(1)\n\nif __name__ == '__main__':\n    p_lst = []\n    for i in range(5):\n        p = Process(target=f, args=('bob',))\n        p.start()\n        p_lst.append(p)\n    print('父进程在执行')\n除了上面这些开启进程的方法，还有一种以继承Process类的形式开启进程的方式\nimport os\nfrom multiprocessing import Process\n\n\nclass MyProcess(Process):\n    def __init__(self,name):\n        super().__init__()\n        self.name=name\n    def run(self):\n        print(\"子进程pid\",os.getpid())\n        print('%s 正在和女主播聊天' %self.name)\nif __name__ == '__main__':\n\n    p1=MyProcess('wupeiqi')\n    p2=MyProcess('yuanhao')\n    p3=MyProcess('nezha')\n\n    p1.start() #start会自动调用run\n    p2.start()\n    p3.start()\n    p1.join()\n    p2.join()\n    p3.join()\n    print('主线程')\n进程之间的数据隔离问题\nfrom multiprocessing import Process\n\ndef work():\n    global n\n    n=0\n    print('子进程内: ',n)\n\n\nif __name__ == '__main__':\n    n = 100\n    p=Process(target=work)\n    p.start()\n    print('主进程内: ',n)\n证明数据隔离，子进程想引用父进程的n\nfrom multiprocessing import Process\n\ndef work():\n    global n\n    print('子进程内: ',n)\n\n\nif __name__ == '__main__':\n    n = 100\n    p=Process(target=work)\n    p.start()\n    print('主进程内: ',n)\n错误：\nTraceback (most recent call last):\n  File \"D:\\python\\lib\\multiprocessing\\process.py\", line 258, in _bootstrap\n    self.run()\n  File \"D:\\python\\lib\\multiprocessing\\process.py\", line 93, in run\n    self._target(*self._args, **self._kwargs)\n  File \"E:\\python\\day11\\进程\\1.进程.py\", line 118, in work\n    print('子进程内: ',n)\nNameError: name 'n' is not defined\n守护进程\n会随着主进程的结束而结束。主进程创建守护进程　　其一：守护进程会在主进程代码执行结束后就终止　　其二：守护进程内无法再开启子进程,否则抛出异常：AssertionError: daemonic processes are not allowed to have children注意：进程之间是互相独立的，主进程代码运行结束，守护进程随即终止。1.守护进程的启动\nimport os\nimport time\nfrom multiprocessing import Process\n\nclass Myprocess(Process):\n    def __init__(self,person):\n        super().__init__()\n        self.person = person\n    def run(self):\n        print(os.getpid(),self.name)\n        print('%s正在和女主播聊天' %self.person)\n\nif __name__ == '__main__':\n\n    p=Myprocess('哪吒')\n    p.daemon=True #一定要在p.start()前设置,设置p为守护进程,禁止p创建子进程,并且父进程代码执行结束,p即终止运行\n    p.start()\n    time.sleep(10) # 在sleep时查看进程id对应的进程ps -ef|grep id\n    print('主进程结束')\n2.\nimport os\nimport time\nfrom multiprocessing import Process\ndef func2():\n    print('func2 before', os.getpid())\n    time.sleep(5)\n    print('func2 after',os.getpid())\n\ndef func():\n    print('in func before', os.getpid())\n    time.sleep(3)\n    print('in func after',os.getpid())\n\nif __name__ == '__main__':\n    p = Process(target=func)\n    p.daemon = True   # 将p设置为一个守护进程\n    p.start()\n    p = Process(target=func2)\n    p.start()\n    time.sleep(1)\n    print('主进程',os.getpid())\n# 主进程的代码执行完毕之后 守护进程就自动结束了  - 守护进程\nsocket聊天并发实例\n1.使用多进程实现socket聊天并发-server\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\nimport socket\nfrom socket import SOL_SOCKET,SO_REUSEADDR\nfrom multiprocessing import Process\n\n\nsk = socket.socket()\nsk.setsockopt(SOL_SOCKET,SO_REUSEADDR,1)\nsk.bind(('127.0.0.1',8080))\nsk.listen(5)\n\ndef talk(conn,client_addr):\n    while True:\n        try:\n            msg=conn.recv(1024)\n            if not msg:break\n            conn.send(msg.upper())\n        except Exception:\n            break\n\nif __name__ == '__main__': #windows下start进程一定要写到这下面\n    while True:\n        conn,client_addr=sk.accept()\n        p=Process(target=talk,args=(conn,client_addr))\n        p.start()\n2.客户端\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\nimport socket\n\nsk = socket.socket()\nsk.connect(('127.0.0.1',8080))\n\n\nwhile True:\n    msg=input('>>: ').strip()\n    if not msg:continue\n\n    sk.send(msg.encode('utf-8'))\n    msg=sk.recv(1024)\n    print(msg.decode('utf-8'))\n多进程中的其他方法1.进程对象的其他方法:terminate,is_alive\nfrom multiprocessing import Process\nimport time\nimport random\n\nclass Myprocess(Process):\n    def __init__(self,person):\n        super().__init__()\n        self.name=person\n\n    def run(self):\n        print('%s正在和网红脸聊天' %self.name)\n        time.sleep(random.randrange(1,5))\n        print('%s还在和网红脸聊天' %self.name)\nif __name__ == '__main__':\n\n\n    p1=Myprocess('哪吒')\n    p1.start()\n\n    p1.terminate()#关闭进程,不会立即关闭,所以is_alive立刻查看的结果可能还是存活\n    print(p1.is_alive()) #结果为True\n\n    print('开始')\n    print(p1.is_alive()) #结果为False\n2.进程对象的其他属性:pid和name\nimport time\nimport random\nimport os\nfrom  multiprocessing import Process\nclass Myprocess(Process):\n    def __init__(self,person):\n        self.name=person   # name属性是Process中的属性，标示进程的名字\n        super().__init__() # 执行父类的初始化方法会覆盖name属性\n        #self.name = person # 在这里设置就可以修改进程名字了\n        #self.person = person #如果不想覆盖进程名，就修改属性名称就可以了\n    def run(self):\n        print('%s正在和网红脸聊天' %self.name,os.getpid())\n        # print('%s正在和网红脸聊天' %self.person)\n        time.sleep(random.randrange(1,5))\n        print('%s正在和网红脸聊天' %self.name,os.getpid())\n        # print('%s正在和网红脸聊天' %self.person)\n\nif __name__ == '__main__':\n\n    p1=Myprocess('哪吒')\n    p1.start()\n    print(p1.pid)    #可以查看子进程的进程id\n进程同步(multiprocess.Lock、multiprocess.Semaphore、multiprocess.Event)\n锁 —— multiprocess.Lock\n通过刚刚的学习，我们千方百计实现了程序的异步，让多个任务可以同时在几个进程中并发处理，他们之间的运行没有顺序，一旦开启也不受我们控制。尽管并发编程让我们能更加充分的利用IO资源，但是也给我们带来了新的问题。　　当多个进程使用同一份数据资源的时候，就会引发数据安全或顺序混乱问题。1.多进程抢占输出资源\nimport os\nimport time\nimport random\nfrom multiprocessing import Process\n\ndef work(n):\n    print('%s: %s is running' %(n,os.getpid()))\n    time.sleep(random.random())\n    print('%s:%s is done' %(n,os.getpid()))\n\nif __name__ == '__main__':\n    for i in range(3):\n        p=Process(target=work,args=(i,))\n        p.start()\n2.使用锁维护执行顺序\n# 由并发变成了串行,牺牲了运行效率,但避免了竞争\nimport os\nimport time\nimport random\nfrom multiprocessing import Process,Lock\n\ndef work(lock,n):\n    lock.acquire()\n    print('%s: %s is running' % (n, os.getpid()))\n    time.sleep(random.random())\n    print('%s: %s is done' % (n, os.getpid()))\n    lock.release()\nif __name__ == '__main__':\n    lock=Lock()\n    for i in range(3):\n        p=Process(target=work,args=(lock,i))\n        p.start()\n上面这种情况虽然使用加锁的形式实现了顺序的执行，但是程序又重新变成串行了，这样确实会浪费了时间，却保证了数据的安全。1.多进程同时抢购余票\n#文件db的内容为：{\"count\":1}代表有一张票\n#注意一定要用双引号，不然json无法识别\n#并发运行，效率高，但竞争写同一文件，数据写入错乱\n\nimport time\nimport json\nimport random\nfrom multiprocessing import Process,Lock\ndef search():\n    dic=json.load(open('db'))\n    print('43m剩余票数%s' %dic['count'])\n\ndef get():\n    dic=json.load(open('db'))\n    time.sleep(random.randrange(1,5)) #模拟读数据的网络延迟\n    if dic['count'] >0:\n        dic['count']-=1\n        time.sleep(0.2) #模拟写数据的网络延迟\n        json.dump(dic,open('db','w'))\n        print('[43m购票成功')\n\ndef task():\n    search()\n    get()\n\nif __name__ == '__main__':\n    for i in range(5): #模拟并发5个客户端抢票\n        p=Process(target=task)\n        p.start()\n2.使用锁来保证数据安全\n#文件db的内容为：{\"count\":5}\n#注意一定要用双引号，不然json无法识别\n#并发运行，效率高，但竞争写同一文件，数据写入错乱\nimport os\nimport time\nimport json\nimport random\nfrom multiprocessing import Process,Lock\n\ndef serach():\n    dic = json.load(open(\"db\"))\n    print(\"进程：{id}，票数：{count}\".format(id=os.getpid(),count=dic[\"count\"]))\n\ndef get():\n    dic = json.load(open(\"db\"))\n    time.sleep(random.random()) #摸你网络延迟\n    if dic[\"count\"] > 0:\n        dic[\"count\"] -=1\n        time.sleep(random.random()) #模拟写数据的网络延迟\n        json.dump(dic,open(\"db\",\"w\"))\n        print(\"进程：{id}抢票成功,余票为{count}\".format(id=os.getpid(),count=dic[\"count\"]))\n    else:\n        print(\"进程：{id}抢票失败\".format(id=os.getpid()))\n\n\ndef task(lock):\n    serach()\n    lock.acquire()\n    get()\n    lock.release()\n\nif __name__ == '__main__':\n    lock = Lock()\n    for i in range(10):\n        p = Process(target=task,args=(lock,))\n        p.start()\nps:\n#加锁可以保证多个进程修改同一块数据时，同一时间只能有一个任务可以进行修改，即串行的修改，没错，速度是慢了，但牺牲了速度却保证了数据安全。\n虽然可以用文件共享数据实现进程间通信，但问题是：\n1.效率低（共享数据基于文件，而文件是硬盘上的数据）\n2.需要自己加锁处理\n\n#因此我们最好找寻一种解决方案能够兼顾：1、效率高（多个进程共享一块内存的数据）2、帮我们处理好锁问题。这就是mutiprocessing模块为我们提供的基于消息的IPC通信机制：队列和管道。\n队列和管道都是将数据存放于内存中\n队列又是基于（管道+锁）实现的，可以让我们从复杂的锁问题中解脱出来，\n我们应该尽量避免使用共享数据，尽可能使用消息传递和队列，避免处理复杂的同步和锁问题，而且在进程数目增多时，往往可以获得更好的可获展性。\n进程间通信——队列和管道（multiprocess.Queue、multiprocess.Pipe）\n进程间通信\nIPC(Inter-Process Communication)\n队列\n创建共享的进程队列，Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递\nQueue([maxsize]) \n创建共享的进程队列。\n参数 ：maxsize是队列中允许的最大项数。如果省略此参数，则无大小限制。\n底层队列使用管道和锁定实现。\n1.方法介绍\nQueue([maxsize]) \n创建共享的进程队列。maxsize是队列中允许的最大项数。如果省略此参数，则无大小限制。底层队列使用管道和锁定实现。另外，还需要运行支持线程以便队列中的数据传输到底层管道中。 \nQueue的实例q具有以下方法：\n\nq.get( [ block [ ,timeout ] ] ) \n返回q中的一个项目。如果q为空，此方法将阻塞，直到队列中有项目可用为止。block用于控制阻塞行为，默认为True. 如果设置为False，将引发Queue.Empty异常（定义在Queue模块中）。timeout是可选超时时间，用在阻塞模式中。如果在制定的时间间隔内没有项目变为可用，将引发Queue.Empty异常。\n\nq.get_nowait( ) \n同q.get(False)方法。\n\nq.put(item [, block [,timeout ] ] ) \n将item放入队列。如果队列已满，此方法将阻塞至有空间可用为止。block控制阻塞行为，默认为True。如果设置为False，将引发Queue.Empty异常（定义在Queue库模块中）。timeout指定在阻塞模式中等待可用空间的时间长短。超时后将引发Queue.Full异常。\n\nq.qsize() \n返回队列中目前项目的正确数量。此函数的结果并不可靠，因为在返回结果和在稍后程序中使用结果之间，队列中可能添加或删除了项目。在某些系统上，此方法可能引发NotImplementedError异常。\n\n\nq.empty() \n如果调用此方法时 q为空，返回True。如果其他进程或线程正在往队列中添加项目，结果是不可靠的。也就是说，在返回和使用结果之间，队列中可能已经加入新的项目。\n\nq.full() \n如果q已满，返回为True. 由于线程的存在，结果也可能是不可靠的（参考q.empty（）方法）。。\n2.其他方法了解\nq.close() \n关闭队列，防止队列中加入更多数据。调用此方法时，后台线程将继续写入那些已入队列但尚未写入的数据，但将在此方法完成时马上关闭。如果q被垃圾收集，将自动调用此方法。关闭队列不会在队列使用者中生成任何类型的数据结束信号或异常。例如，如果某个使用者正被阻塞在get（）操作上，关闭生产者中的队列不会导致get（）方法返回错误。\n\nq.cancel_join_thread() \n不会再进程退出时自动连接后台线程。这可以防止join_thread()方法阻塞。\n\nq.join_thread() \n连接队列的后台线程。此方法用于在调用q.close()方法后，等待所有队列项被消耗。默认情况下，此方法由不是q的原始创建者的所有进程调用。调用q.cancel_join_thread()方法可以禁止这种行为。\n代码实例：\nfrom multiprocessing import Queue,Process\n# IPC  Inter-process communication\ndef func(q):\n    print(q.get())\n\nif __name__ == '__main__':\n    q = Queue()\n    p = Process(target=func,args=(q,))\n    p.start()\n    q.put(12345)\n## 帮助你保证进程之间的数据安全\n生产者消费者模型\n在并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。\n为什么要使用生产者和消费者模式在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。\n什么是生产者消费者模式生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。基于队列实现生产者消费者模型\nfrom multiprocessing import Process,Queue\nimport time,random,os\ndef consumer(q):\n    while True:\n        res=q.get()\n        time.sleep(random.randint(1,3))\n        print('\\033[45m%s 吃 %s\\033[0m' %(os.getpid(),res))\n\ndef producer(q):\n    for i in range(10):\n        time.sleep(random.randint(1,3))\n        res='包子%s' %i\n        q.put(res)\n        print('\\033[44m%s 生产了 %s\\033[0m' %(os.getpid(),res))\n\nif __name__ == '__main__':\n    q=Queue()\n    #生产者们:即厨师们\n    p1=Process(target=producer,args=(q,))\n\n    #消费者们:即吃货们\n    c1=Process(target=consumer,args=(q,))\n\n    #开始\n    p1.start()\n    c1.start()\n    print('主')\n此时的问题是主进程永远不会结束，原因是：生产者p在生产完后就结束了，但是消费者c在取空了q之后，则一直处于死循环中且卡在q.get()这一步。\n解决方式无非是让生产者在生产完毕后，往队列中再发一个结束信号，这样消费者在接收到结束信号后就可以break出死循环。改良版——生产者消费者模型\nfrom multiprocessing import Process,Queue\nimport time,random,os\ndef consumer(q):\n    while True:\n        res=q.get()\n        if res is None:break #收到结束信号则结束\n        time.sleep(random.randint(1,3))\n        print('\\033[45m%s 吃 %s\\033[0m' %(os.getpid(),res))\n\ndef producer(q):\n    for i in range(10):\n        time.sleep(random.randint(1,3))\n        res='包子%s' %i\n        q.put(res)\n        print('\\033[44m%s 生产了 %s\\033[0m' %(os.getpid(),res))\n    q.put(None) #发送结束信号\nif __name__ == '__main__':\n    q=Queue()\n    #生产者们:即厨师们\n    p1=Process(target=producer,args=(q,))\n\n    #消费者们:即吃货们\n    c1=Process(target=consumer,args=(q,))\n\n    #开始\n    p1.start()\n    c1.start()\n    print('主')\n注意：结束信号None，不一定要由生产者发，主进程里同样可以发，但主进程需要等生产者结束后才应该发送该信号主进程在生产者生产完毕后发送结束信号None\nfrom multiprocessing import Process,Queue\nimport time,random,os\ndef consumer(q):\n    while True:\n        res=q.get()\n        if res is None:break #收到结束信号则结束\n        time.sleep(random.randint(1,3))\n        print('\\033[45m%s 吃 %s\\033[0m' %(os.getpid(),res))\n\ndef producer(q):\n    for i in range(2):\n        time.sleep(random.randint(1,3))\n        res='包子%s' %i\n        q.put(res)\n        print('\\033[44m%s 生产了 %s\\033[0m' %(os.getpid(),res))\n\nif __name__ == '__main__':\n    q=Queue()\n    #生产者们:即厨师们\n    p1=Process(target=producer,args=(q,))\n\n    #消费者们:即吃货们\n    c1=Process(target=consumer,args=(q,))\n\n    #开始\n    p1.start()\n    c1.start()\n\n    p1.join()\n    q.put(None) #发送结束信号\n    print('主')\n但上述解决方式，在有多个生产者和多个消费者时，我们则需要用一个很low的方式去解决\nfrom multiprocessing import Process,Queue\nimport time,random,os\ndef consumer(q):\n    while True:\n        res=q.get()\n        if res is None:break #收到结束信号则结束\n        time.sleep(random.randint(1,3))\n        print('\\033[45m%s 吃 %s\\033[0m' %(os.getpid(),res))\n\ndef producer(name,q):\n    for i in range(2):\n        time.sleep(random.randint(1,3))\n        res='%s%s' %(name,i)\n        q.put(res)\n        print('\\033[44m%s 生产了 %s\\033[0m' %(os.getpid(),res))\n\nif __name__ == '__main__':\n    q=Queue()\n    #生产者们:即厨师们\n    p1=Process(target=producer,args=('包子',q))\n    p2=Process(target=producer,args=('骨头',q))\n    p3=Process(target=producer,args=('泔水',q))\n\n    #消费者们:即吃货们\n    c1=Process(target=consumer,args=(q,))\n    c2=Process(target=consumer,args=(q,))\n\n    #开始\n    p1.start()\n    p2.start()\n    p3.start()\n    c1.start()\n\n    p1.join() #必须保证生产者全部生产完毕,才应该发送结束信号\n    p2.join()\n    p3.join()\n    q.put(None) #有几个消费者就应该发送几次结束信号None\n    q.put(None) #发送结束信号\nJoinableQueue([maxsize]) 创建可连接的共享进程队列。这就像是一个Queue对象，但队列允许项目的使用者通知生产者项目已经被成功处理。通知进程是使用共享的信号和条件变量来实现的。1.方法介绍\nJoinableQueue的实例p除了与Queue对象相同的方法之外，还具有以下方法：\n\nq.task_done() \n使用者使用此方法发出信号，表示q.get()返回的项目已经被处理。如果调用此方法的次数大于从队列中删除的项目数量，将引发ValueError异常。\n\nq.join() \n生产者将使用此方法进行阻塞，直到队列中所有项目均被处理。阻塞将持续到为队列中的每个项目均调用q.task_done()方法为止。 \n下面的例子说明如何建立永远运行的进程，使用和处理队列上的项目。生产者将项目放入队列，并等待它们被处理。\nJoinableQueue队列实现消费之生产者模型\nfrom multiprocessing import Process, JoinableQueue\nimport time, random, os\n\n\ndef consumer(q):\n    while True:\n        res = q.get()\n        time.sleep(random.randint(1, 3))\n        print('\\033[45m%s 吃 %s\\033[0m' % (os.getpid(), res))\n        q.task_done()  # 向q.join()发送一次信号,证明一个数据已经被取走了\n\n\ndef producer(name, q):\n    for i in range(2):\n        time.sleep(random.randint(1, 3))\n        res = '%s%s' % (name, i)\n        q.put(res)\n        print('\\033[44m%s 生产了 %s\\033[0m' % (os.getpid(), res))\n    q.join()  # 生产完毕，使用此方法进行阻塞，直到队列中所有项目均被处理。\n\n\nif __name__ == '__main__':\n    q = JoinableQueue()\n    # 生产者们:即厨师们\n    p1 = Process(target=producer, args=('包子', q))\n    p2 = Process(target=producer, args=('骨头', q))\n    p3 = Process(target=producer, args=('泔水', q))\n\n    # 消费者们:即吃货们\n    c1 = Process(target=consumer, args=(q,))\n    c2 = Process(target=consumer, args=(q,))\n    c1.daemon = True\n    c2.daemon = True\n\n    # 开始\n    p_l = [p1, p2, p3, c1, c2]\n    for p in p_l:\n        p.start()\n\n    p1.join()\n    p2.join()\n    p3.join()\n    print('主')\n\n    # 主进程等--->p1,p2,p3等---->c1,c2\n    # p1,p2,p3结束了,证明c1,c2肯定全都收完了p1,p2,p3发到队列的数据\n    # 因而c1,c2也没有存在的价值了,不需要继续阻塞在进程中影响主进程了。应该随着主进程的结束而结束,所以设置成守护进程就可以了。\n进程之间的数据共享\n展望未来，基于消息传递的并发编程是大势所趋\n即便是使用线程，推荐做法也是将程序设计为大量独立的线程集合，通过消息队列交换数据。\n这样极大地减少了对使用锁定和其他同步手段的需求，还可以扩展到分布式系统中。\n但进程间应该尽量避免通信，即便需要通信，也应该选择进程安全的工具来避免加锁带来的问题。\n以后我们会尝试使用数据库来解决现在进程之间的数据共享问题。Manager模块介绍\n进程间数据是独立的，可以借助于队列或管道实现通信，二者都是基于消息传递的\n虽然进程间数据独立，但可以通过Manager实现数据共享，事实上Manager的功能远不止于此\n\nA manager object returned by Manager() controls a server process which holds Python objects and allows other processes to manipulate them using proxies.\n\nA manager returned by Manager() will support types list, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Barrier, Queue, Value and Array.\nManager例子\nfrom multiprocessing import Manager,Process,Lock\ndef work(d,lock):\n    with lock: #不加锁而操作共享的数据,肯定会出现数据错乱\n        d['count']-=1\n\nif __name__ == '__main__':\n    lock=Lock()\n    with Manager() as m:\n        dic=m.dict({'count':100})\n        p_l=[]\n        for i in range(100):\n            p=Process(target=work,args=(dic,lock))\n            p_l.append(p)\n            p.start()\n        for p in p_l:\n            p.join()\n        print(dic)\n进程池和multiprocess.Pool模块\n进程池为什么要有进程池?进程池的概念。\n在程序实际处理问题过程中，忙时会有成千上万的任务需要被执行，闲时可能只有零星任务。那么在成千上万个任务需要被执行的时候，我们就需要去创建成千上万个进程么？首先，创建进程需要消耗时间，销毁进程也需要消耗时间。第二即便开启了成千上万的进程，操作系统也不能让他们同时执行，这样反而会影响程序的效率。因此我们不能无限制的根据任务开启或者结束进程。那么我们要怎么做呢？\n在这里，要给大家介绍一个进程池的概念，定义一个池子，在里面放上固定数量的进程，有需求来了，就拿一个池中的进程来处理任务，等到处理完毕，进程并不关闭，而是将进程再放回进程池中继续等待任务。如果有很多任务需要执行，池中的进程数量不够，任务就要等待之前的进程执行任务完毕归来，拿到空闲进程才能继续执行。也就是说，池中进程的数量是固定的，那么同一时间最多有固定数量的进程在运行。这样不会增加操作系统的调度难度，还节省了开闭进程的时间，也一定程度上能够实现并发效果。multiprocess.Pool模块\nPool([numprocess  [,initializer [, initargs]]]):创建进程池\n1.参数介绍\n1 numprocess:要创建的进程数，如果省略，将默认使用cpu_count()的值\n2 initializer：是每个工作进程启动时要执行的可调用对象，默认为None\n3 initargs：是要传给initializer的参数组\n2.主要方法\n1 p.apply(func [, args [, kwargs]]):在一个池工作进程中执行func(*args,**kwargs),然后返回结果。\n2 '''需要强调的是：此操作并不会在所有池工作进程中并执行func函数。如果要通过不同参数并发地执行func函数，必须从不同线程调用p.apply()函数或者使用p.apply_async()''' \n3 p.apply_async(func [, args [, kwargs]]):在一个池工作进程中执行func(*args,**kwargs),然后返回结果。\n4 '''此方法的结果是AsyncResult类的实例，callback是可调用对象，接收输入参数。当func的结果变为可用时，将理解传递给callback。callback禁止执行任何阻塞操作，否则将接收其他异步操作中的结果。''' \n5 p.close():关闭进程池，防止进一步操作。如果所有操作持续挂起，它们将在工作进程终止前完成 \n6 P.jion():等待所有工作进程退出。此方法只能在close（）或teminate()之后调用\n3.其他方法(了解）\n1 方法apply_async()和map_async（）的返回值是AsyncResul的实例obj。实例具有以下方法\n2 obj.get():返回结果，如果有必要则等待结果到达。timeout是可选的。如果在指定时间内还没有到达，将引发一场。如果远程操作中引发了异常，它将在调用此方法时再次被引发。\n3 obj.ready():如果调用完成，返回True\n4 obj.successful():如果调用完成且没有引发异常，返回True，如果在结果就绪之前调用此方法，引发异常\n5 obj.wait([timeout]):等待结果变为可用。\n6 obj.terminate()：立即终止所有工作进程，同时不执行任何清理或结束任何挂起工作。如果p被垃圾回收，将自动调用此函数\n代码实例1.进程池和多进程效率对比\n2.同步和异步\n\n    import os,time\nfrom multiprocessing import Pool\n\ndef work(n):\n    print('%s run' %os.getpid())\n    time.sleep(3)\n    return n\nif __name__ == '__main__':\n    p=Pool(3) #进程池中从无到有创建三个进程,以后一直是这三个进程在执行任务\n    res_l=[]\n    for i in range(1,3):\n        res=p.apply(work,args=(i,)) # 同步调用，直到本次任务执行完毕拿到res，等待任务work执行的过程中可能有阻塞也可能没有阻塞\n        res_l.append(res)                           # 但不管该任务是否存在阻塞，同步调用都会在原地等着\n    print(res_l)\n\n3.进程池的异步调用\nimport os\nimport time\nimport random\nfrom multiprocessing import Pool\n\ndef work(n):\n    print('%s run' %os.getpid())\n    time.sleep(random.random())\n    return n\n\nif __name__ == '__main__':\n    p=Pool(3) #进程池中从无到有创建三个进程,以后一直是这三个进程在执行任务\n    res_l=[]\n    for i in range(1,5):\n        res=p.apply_async(work,args=(i,)) # 异步运行，根据进程池中有的进程数，每次最多3个子进程在异步执行\n                                          # 返回结果之后，将结果放入列表，归还进程，之后再执行新的任务\n                                          # 需要注意的是，进程池中的三个进程不会同时开启或者同时结束\n                                          # 而是执行完一个就释放一个进程，这个进程就去接收新的任务。\n        res_l.append(res)\n\n    # 异步apply_async用法：如果使用异步提交的任务，主进程需要使用jion，等待进程池内任务都处理完，然后可以用get收集结果\n    # 否则，主进程结束，进程池可能还没来得及执行，也就跟着一起结束了\n    p.close()\n    p.join()\n    for res in res_l:\n        print(res.get()) #使用get来获取apply_aync的结果,如果是apply,则没有get方法,因为apply是同步执行,立刻获取结果,也根本无需get\n4.回调函数需要回调函数的场景：进程池中任何一个任务一旦处理完了，就立即告知主进程：我好了额，你可以处理我的结果了。主进程则调用一个函数去处理该结果，该函数即回调函数\n我们可以把耗时间（阻塞）的任务放到进程池中，然后指定回调函数（主进程负责执行），这样主进程在执行回调函数时就省去了I/O的过程，直接拿到的是任务的结果。1.如果在主进程中等待进程池中所有任务都执行完毕后，再统一处理结果，则无需回调函数\nfrom multiprocessing import Pool\nimport time,random,os\n\ndef work(n):\n    print(\"my is word pid\",os.getpid())\n    time.sleep(1)\n    return n\nif __name__ == '__main__':\n    p=Pool()\n\n    res_l=[]\n    for i in range(1,5):\n        res=p.apply_async(work,args=(i,))\n        res_l.append(res)\n\n    p.close()\n    p.join() #等待进程池中所有进程执行完毕\n\n    nums=[]\n    for res in res_l:\n        nums.append(res.get()) #拿到所有结果\n    print(nums) #主进程拿到所有的处理结果,可以在主进程中进行统一进行处理\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "0"}