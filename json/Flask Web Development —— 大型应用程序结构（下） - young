{"title": "Flask Web Development —— 大型应用程序结构（下） - young ", "index": "python,flask", "content": "4、启动脚本\n顶层目录中的manage.py文件用于启动应用。这个脚本会在示例7-8中展示。\n示例7-8. manage.py：启动脚本\n#!/usr/bin/env python\nimport os\nfrom app import create_app, db\nfrom app.models import User, Role\nfrom flask.ext.script import Manager, Shell\nfrom flask.ext.migrate import Migrate, MigrateCommand\n\napp = create_app(os.getenv('FLASK_CONFIG') or 'default') \nmanager = Manager(app)\nmigrate = Migrate(app, db)\n\ndef make_shell_context():\n    return dict(app=app, db=db, User=User, Role=Role)\n\nmanager.add_command(\"shell\", Shell(make_context=make_shell_context))\nmanager.add_command('db', MigrateCommand)\n\nif __name__ == '__main__': \n    manager.run()\n这个脚本开始于创建应用程序。使用环境变量FLASK_CONFIG，若它已经定义了则从中获取配置；如果没有，则是用默认配置。然后用于Python shell的Flask-Script、Flask-Migrate以及自定义上下文会被初始化。\n为了方便，会增加一行执行环境，这样在基于Unix的操作系统上可以通过./manage.py来执行脚本来替代冗长的python manage.py。\n5、需求文件\n应用程序必须包含requirements.txt文件来记录所有依赖包，包括精确的版本号。这很重要，因为可以在不同的机器上重新生成虚拟环境，例如在生产环境的机器上部署应用程序。这个文件可以通过下面的pip命令自动生成：\n(venv) $ pip freeze >requirements.txt\n\n当安装或更新一个包之后最好再更新一下这个文件。以下展示了一个需求文件示例：\nFlask==0.10.1\nFlask-Bootstrap==3.0.3.1\nFlask-Mail==0.9.0\nFlask-Migrate==1.1.0\nFlask-Moment==0.2.0\nFlask-SQLAlchemy==1.0\nFlask-Script==0.6.6\nFlask-WTF==0.9.4\nJinja2==2.7.1\nMako==0.9.1\nMarkupSafe==0.18\nSQLAlchemy==0.8.4\nWTForms==1.0.5\nWerkzeug==0.9.4\nalembic==0.6.2\nblinker==1.3\nitsdangerous==0.23\n\n当你需要完美复制一个虚拟环境的时候，你可以运行以下命令创建一个新的虚拟环境：\n(venv) $ pip install -r requirements.txt\n\n当你读到这时，示例requirements.txt文件中的版本号可能已经过时了。如果喜欢你可以尝试用最近发布的包。如果遇到任何问题，你可以随时回退到需求文件中与应用兼容的指定版本。\n6、单元测试\n这个应用非常小以至于不需要太多的测试，但是作为示例会在示例7-9中展示两个简单的测试定义。\n示例7-9. tests/test_basics.py：单元测试\nimport unittest\nfrom flask import current_app \nfrom app import create_app, db\n\nclass BasicsTestCase(unittest.TestCase): \n    def setUp(self):\n        self.app = create_app('testing')\n        self.app_context = self.app.app_context()\n        self.app_context.push()\n        db.create_all()\n\n    def tearDown(self): \n        db.session.remove() \n        db.drop_all() \n        self.app_context.pop()\n\n    def test_app_exists(self): \n        self.assertFalse(current_app is None)\n\n    def test_app_is_testing(self): \n        self.assertTrue(current_app.config['TESTING'])\n编写好的测试使用的是来自于Python标准库中标准的unittest包。setUp()和tearDown()方法在每个测试之前和之后运行，且任何一个方法必须以test_开头作为测试来执行。\n建议：如果你想要学习更多使用Python的unittest包来写单元测试的内容，请参阅官方文档。\nsetUp()方法尝试创建一个测试环境，类似于运行应用程序。首先它创建应用程序配置用于测试并激活上下文。这一步确保测试可以和常规请求一样访问current_app。然后，当需要的时候，可以创建一个供测试使用的全新数据库。数据库和应用程序上下文会在tearDown()方法中被移除。\n第一个测试确保应用程序实例存在。第二个测试确保应用程序在测试配置下运行。为了确保tests目录有效，需要在tests目录下增加__init__.py文件，不过该文件可以为空，这样unittest包可以扫描所有模块并定位测试。\n建议：如果你有克隆在GitHub上的应用程序，你现在可以运行git checkout 7a来切换到这个版本的应用程序。为了确保你已经安装了所有依赖集，需要运行pip install -r requirements.txt。\n为了运行单元测试，可以在manage.py脚本中增加一个自定义的命令。\n示例7-10展示如何添加测试命令。\n示例7-10. manage.pyt：单元测试启动脚本\n@manager.command\ndef test():\n    \"\"\"Run the unit tests.\"\"\"\n    import unittest\n    tests = unittest.TestLoader().discover('tests') \n    unittest.TextTestRunner(verbosity=2).run(tests)\nmanager.command装饰器使得它可以很容易的实现自定义命令。被装饰的函数名可以被当做命令名使用，且函数的文档字符串会显示帮助信息。test()函数的执行会调用unittest包中的测试运行器。\n单元测试可以像下面这样执行：\n(venv) $ python manage.py test\ntest_app_exists (test_basics.BasicsTestCase) ... ok\ntest_app_is_testing (test_basics.BasicsTestCase) ... ok\n\n.----------------------------------------------------------------------\nRan 2 tests in 0.001s\n\nOK\n\n7、数据库启动\n与单脚本的应用相比，重构后的应用使用不同数据库。\n从环境变量中获取的数据库URL作为首选，默认SQLite数据库作为可选。三个配置中的环境变量和SQLite数据库文件名是不一样的。例如，开发配置的URL是从DEV_DATABASE_URL环境变量中获取，如果没有定义则会使用名为data-dev.sqlite的SQLite数据库。\n无论数据库URL源的是哪一个，都必须为新的数据库创建数据库表。如果使用了Flask-Migrate来保持迁移跟踪，数据库表可以被创建或更新到最近的版本通过下面的命令：\n(venv) $ python manage.py db upgrade\n\n相信与否，已经到了第一部分结束的地方。你现在已经学到了Flask必要的基本要素，但是你不确定如何将这些零散的知识组合在一起形成一个真正的应用程序。第二部分的目的是通过开发一个完整的应用程序来带领你继续前行。\n注：前段时间才知道这本书已经由图灵社区出版翻译，已经开始预售了，并于12月19日到货。喜欢的朋友也可以[点我]购买一本。后面的章节就不再继续更新了，自己肯定也会去支持这本书的。\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "17"}