{"title": "Kaggle入门级赛题：泰坦尼克号生还者预测——数据分析篇 - 个人文章 ", "index": "python,数据分析", "content": "本次分享的项目来自 Kaggle 的经典赛题：泰坦尼克号生还者预测。分为数据分析和数据挖掘两部分介绍。本篇为数据分析篇。\n\n赛题解读\n比赛概述\nRMS 泰坦尼克号的沉没是历史上最为人熟知的海难事件之一。 1912 年 4 月 15 日，在她的处女航中，泰坦尼克号在与冰山相撞后沉没，在船上的 2224 名乘客和机组人员中，共造成 1502 人死亡。这场耸人听闻的悲剧震惊了国际社会，从而促进了船舶安全规定的完善。\n造成海难失事的原因之一是乘客和机组人员没有足够的救生艇。尽管在沉船事件中幸存下有一些运气因素，但有些人比其他人更容易存活下来，比如女人，孩子和上流社会。\n在这个挑战中，要求完成哪些人可能存活下来的分析。特别的，要求运用机器学习工具来预测哪些乘客能够幸免于悲剧。\n所需技巧\n\n二分类 (Binary classification)\nPython 和 R 的基础 (Python and R basics)\n\n最终目标\n\n预测一名乘客是否能够在泰坦尼克号沉没事件中幸存。\n对测试集中的每一个PassengerId，将其相应的Survived变量预测为值 0 或 1（这里 1 表示幸存，0 表示遇难）。\n\n数据分析\n数据描述\n首先，导入数据：\ndata_train = pd.read_csv('train.csv')\ndata_test = pd.read_csv('test.csv')\n数据需要进行转换能够作为模型输入。我们对训练集data_train进行变换，同样需要对测试集data_test进行变换，保证模型输入的一致性。\n合并在一起可以进行统一变换，变换后再拆分。也可使用之前没有经过变换的data_train。对数据集进行如下处理：\n# 将目标变量 Survived 单独提取，从特征变量中移除目标变量 Survived\ndf_target = data_train['Survived']\ndata_train_feature = data_train.drop(['Survived'], axis=1)\n\n# 合并 train 和 test 数据集，以方便数据处理对两个数据集同时进行\ndf = data_train_feature.append(data_test)\n合并后的数据集如下图所示：\n\n我们看到，共有 11 个特征：\n\n\nPassengerId： 乘客 ID\n\nPclass： 舱位等级 (1 = 1st, 2 = 2nd, 3 = 3rd)\n\nName： 乘客姓名\n\nSex： 性别\n\nAge： 年龄\n\nSibSp： 在船上的兄弟姐妹／配偶个数\n\nParch： 在船上的父母／小孩个数\n\nTicket： 船票信息\n\nFare： 票价\n\nCabin： 客舱\n\nEmbarked： 登船港口 (C = Cherbourg, Q = Queenstown, S = Southampton)\n\n以上就是对比赛和数据意义的解读，下面我们对数据进行探索，来达到最终目标。\n数据预处理\n特征分析\n\n我们已经在上一步查看了有哪些特征，接下来要做的是：\n\n查看哪些特征存在缺失值。\n判断哪些特征存在异常值，通过对数值型特征进行简单的描述性统计。\n判断这些特征的数据类型，从而为后面的可视化分析找到合适的方法。\n对数据进行可视化分析。\n分析得出有用的结论。\n\n\n1. 查看哪些特征存在缺失值查看 train 和 test 合并后的数据：\ndf.info()\n\n查看哪些特征存在缺失值，缺失程度是否严重：\nprint(pd.isnull(df).sum())\n\n可以看出 age，cabin，embarked 和 Fare 四个特征有缺失值，其中 cabin 的值缺失较严重。\n\n2. 判断哪些特征存在异常值\n对数值型特征进行简单的描述性统计，包括均值，中位数，标准差，最大值，最小值等，从而判断哪些特征存在异常值。\ndf.describe()\n\n观察上述值，其中 Age 的最小值为 0.17，表示的应该是婴儿的年龄，最大值为 80，年龄有些偏大。Fare 表示船票价格，它的平均值为 33.2，中位数 14，平均值比中位数大很多，说明该特征分布是严重的右偏，又有最大值约 512，所以这个值很可能是一个异常值。在 SibSp 和 Parch 中，Sibsp 最大值为 8，有可能是异常值，但 Parch 最大值也为 9。这两个特征同时出现相近的较大的数值，而又由二者所表示的含义，说明这个数值是有可能的，需要进一步的观察。\n由上所述，我们看到了一些可能的异常值，但还不能确定。需要我们进一步通过可视化来清楚的显示，并结合对业务的理解来确定。\n\n3. 判断特征的数据类型\n\n定类：Name, Sex, Ticket, Embarked, Cabin\n\n定序：Pclass\n\n定比：Age, Fare, SibSp, Parch\n\n\n根据以上对各个特征数据类型的判断，选择合适的可视化方法完成可视化。通过可视化可以：\n\n可以发现事实问题，并寻找出现的原因。\n更清晰的了解特征对目标变量的影响，有助于特征工程。\n可以发现不易发现的特征异常值。\n\n\n4. 数据可视化分析首先，定制画布风格：\nplt.style.use(\"bmh\")\n解决中文乱码问题：\nplt.rcParams['font.sans-serif'] = ['SimHei']\n# 或者用 plt.rc('font', family='SimHei', size=13)\n\n定类 / 定序特征分析\ncat_list = ['Pclass','Name','Sex','Embarked','Ticket','Cabin']\nfor n,i in enumerate(cat_list):  \n    Cabin_cat_num = df[i].value_counts().index.shape[0]\n    print('{0}. {1}特征的类型数量是: {2}'.format(n+1,i,Cabin_cat_num))\n\n在上面各特征值的类型中，一些比较少数量的特征如 Pclass，Sex，Embarked 等可进行可视化分析。剩下特征如 Ticket 和 Cabin 分类较多，进行可视化分析达不到想要效果，难以得到有用的结论。\n\n先对上面 3 种容易的分类进的特征行可视化，而对于 Name，Ticket，Cabin 等到后续进行进一步分析。\nf, [ax1,ax2,ax3] = plt.subplots(1,3,figsize=(20,5))\nsns.countplot(x='Sex', hue='Survived', data=data_train, ax=ax1)\nsns.countplot(x='Pclass', hue='Survived', data=data_train, ax=ax2)\nsns.countplot(x='Embarked', hue='Survived', data=data_train, ax=ax3)\nax1.set_title('Sex特征分析')\nax2.set_title('Pclass特征分析')\nax3.set_title('Embarked特征分析')\nf.suptitle('定类/定序数据类型特征分析', size=20, y=1.1)\n\nplt.show()\n\n通过分别观察各特征值的分布情况和与目标变量之间的关系，得出以下结论：\n\n\nSex：我们从 Sex 的特征分析图可以清晰的看，男性总人数大于女性总人数，但女性的存活率远远高于男性。\n\nPclass：3 等舱的存活率明显比 1 等舱和 2 等舱的低很多，这是由于 3 等舱的多为普通市民，而等级越高的舱位越有可能是当时社会地位较高的人。\n\nEmbarked：登陆港口 S 的数量最多，但获救率较低，而 C 港和 Q 港基本都有一半的人获救。\n\n其中，Sex 和 Pclass 两个特征影响力较大。\n\n以上是针对单独特征对生还与否的简单分析，但在实际问题中，往往是由多个因素共同决定对目标变量的影响。因此，我们需要知道在某个特定条件下的特征的影响（如 Pclass 是 1 的情况下男性和女性生还概率有何不同）才更加能帮助我们分析，即在数据集的子集内可视化变量的分布或多个变量之间的关系。这时就需要用到FacetGrid子集数据。\n在不同社会等级下，男性和女性在不同登陆港口下的数量对比：\ngrid = sns.FacetGrid(df, col='Pclass', hue='Sex', palette='seismic', size=4)\ngrid.map(sns.countplot, 'Embarked', alpha=0.8)\ngrid.add_legend()\n\n观察得到：\n\n在 Q 港口登陆的乘客中，3 等舱的乘客占了绝大多数，而其他两个舱位几乎没有乘客在该港口登陆，说明登陆港口可能与社会等级有关联。\n在 C 港口登陆的乘客中，女性乘客占大多数，这也间接的说明在 C 港口生还率很大。\n在 S 港口登陆的乘客中，3 等舱的乘客最多，且总的来说男性乘客占比也最多，因此可推测 S 港口生还率较小。\n\n\n定距/定比特征分析\n\nAge 特征的 kde 分布：\nf,ax = plt.subplots(figsize=(10,5))\nsns.kdeplot(data_train.loc[(data_train['Survived'] == 0),'Age'] , color='gray',shade=True,label='not survived')\nsns.kdeplot(data_train.loc[(data_train['Survived'] == 1),'Age'] , color='g',shade=True, label='survived')\nplt.title('Age特征分布', fontsize = 15)\nplt.xlabel(\"Age\", fontsize = 15)\nplt.ylabel('Frequency', fontsize = 15)\n\n根据 Age 特征得到不同性别生还与否的分布：\ndef plot_distribution( df , var , target , **kwargs ):\n    row = kwargs.get( 'row' , None )\n    col = kwargs.get( 'col' , None )\n    facet = sns.FacetGrid( df , hue=target , aspect=4 , row = row , col = col )\n    facet.map( sns.kdeplot , var , shade= True )\n    facet.set( xlim=( 0 , df[ var ].max() ) )\n    facet.add_legend()\nplot_distribution( data_train , var = 'Age' , target = 'Survived' , row = 'Sex' )\n\n整体观察得到，0 到十几岁的孩子生还率最高，20 岁到 30 岁左右的生还率较低，其他年龄段没有太大的区别。而对于男性来说，0 到十几岁的乘客生还率明显较高，20 岁到 30 岁左右的生还率较低；而对女性来说，反而是 30 岁到 40 岁的年龄段生还率相对较高，0 到十几岁生还率并不高，其它各年龄段的生还率没有较大差别。\n\nFare 特征:\n# 填充缺失值\ndata_test[\"Fare\"].fillna(data_test[\"Fare\"].median(), inplace=True)\n\ndata_train['Fare'] = data_train['Fare'].astype(int)\ndata_test['Fare'] = data_test['Fare'].astype(int)\n\n# 分别获得生还和遇难乘客的 Fare\nfare_not_survived = data_train[\"Fare\"][data_train[\"Survived\"] == 0]\nfare_survived = data_train[\"Fare\"][data_train[\"Survived\"] == 1]\n\n# 得到 Fare 的均值和方差\navgerage_fare = pd.DataFrame([fare_not_survived.mean(), fare_survived.mean()])\nstd_fare = pd.DataFrame([fare_not_survived.std(), fare_survived.std()])\n\ndata_train['Fare'].plot(kind='hist', figsize=(15,3),bins=100, xlim=(0,50))\n\navgerage_fare.index.names = std_fare.index.names = [\"Survived\"]\navgerage_fare.plot(yerr=std_fare,kind='bar',legend=False)\n\n容易观察得到 Fare 低的数量多，而 Fare 高的数量少，但生还率明显要比 Fare 低的高很多。这也符合实际情况，买得起高票价的有钱人居多，社会地位可能相对较高，更容易获救。\n\nSibSp 和 Parch 特征：\n\ndata_train['Family'] =  data_train[\"Parch\"] + data_train[\"SibSp\"]\ndata_train['Family'].loc[data_train['Family'] > 0] = 1\ndata_train['Family'].loc[data_train['Family'] == 0] = 0\n\ndata_test['Family'] =  data_test[\"Parch\"] + data_test[\"SibSp\"]\ndata_test['Family'].loc[data_test['Family'] > 0] = 1\ndata_test['Family'].loc[data_test['Family'] == 0] = 0\n\n# 删除 Parch 和 SibSp\ndata_train = data_train.drop(['SibSp','Parch'], axis=1)\ndata_test = data_test.drop(['SibSp','Parch'], axis=1)\n\n# 绘图\nfig, (axis1,axis2) = plt.subplots(1,2,sharex=True,figsize=(10,5))\n\nsns.countplot(x='Family', data=data_train, order=[1,0], ax=axis1)\n\n# 分为和家人一起、独自乘船两种情况\nfamily_perc = data_train[[\"Family\", \"Survived\"]].groupby(['Family'],as_index=False).mean()\nsns.barplot(x='Family', y='Survived', data=family_perc, order=[1,0], ax=axis2)\n\naxis1.set_xticklabels([\"With Family\",\"Alone\"], rotation=0)\n\n我们将 SibSp 和 Parch 这两个特征合并为了一个 Family 特征，表示该乘客是否有和家人一起乘船，来判断是否会增加生还率。\n可以明显的看出独自乘船的乘客人数大于和家人一起的乘客人数，但幸存人数相对而言较少。\n\n5. 总结\n将上述 6 个特征的相互关联图进行汇总，对角线为特征自身的 kde 分布，如下图所示：\ng = sns.pairplot(data_train[[u'Survived', u'Pclass', u'Sex', u'Age', u'Family', u'Fare', u'Embarked']], hue='Survived', palette = 'seismic',\n                 size=4,diag_kind = 'kde',diag_kws=dict(shade=True),plot_kws=dict(s=50) )\ng.set(xticklabels=[])\n\n\n数据分析部分就是这样了，根据个人的不同理解还可以有很多种不同的可视化方法，但最终目标都是为了帮助我们理解数据，进行挖掘分析。关于特征工程和建模的部分将在下一篇的数据挖掘中来介绍。\n\n参考链接：【Kaggle入门级竞赛top5%排名经验分享】— 分析篇样式美化matplotlib.pyplot.style.use定制画布风格mac下python matplotlib中文乱码解决方案Seaborn(sns)官方文档学习笔记（第六章 绘制数据网格）\n不足之处，欢迎指正。\n\n                ", "mainLikeNum": ["4 "], "mainBookmarkNum": "3"}