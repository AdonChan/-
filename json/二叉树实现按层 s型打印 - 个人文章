{"title": "二叉树实现按层 s型打印 - 个人文章 ", "index": "python", "content": "题目阐释：\ns型打印，重要的是将binary—tree 逐层遍历，获取每层的node。\n思路：\n将树的遍历转化为 压栈出栈。 每次将列表内的node全部出栈，获取子元素，然后全部再入栈。 如此反复迭代\n应用：\n当树有层次信息时候，可以如此操作。\n\n代码如下：\nclass Node(object):\n    def __init__(self, val):\n        self.left_node = None\n        self.right_node = None\n        self.value = val\n\n\nclass MakeNode(object):\n    def __init__(self):\n        pass\n\n    def make_series(self, root_val, value_list_in):\n        root = Node(root_val)\n        # cur_node=root\n        cur_nodes = list()\n        cur_nodes.append(root)\n        while cur_nodes:\n            nodes_iters = list()\n            while cur_nodes:\n                cur_node = cur_nodes.pop(0)\n                nodes_iters.append(cur_node)\n            for node_iter in nodes_iters:\n                if value_list_in:\n                    values_iter = value_list_in.pop(0)\n                    if values_iter[0]:\n                        node = Node(values_iter[0])\n                        node_iter.left_node = node\n                        cur_nodes.append(node)\n                    if values_iter[1]:\n                        node = Node(values_iter[1])\n                        node_iter.right_node = node\n                        cur_nodes.append(node)\n        # print(root)\n        return root\n\n\nclass BinaryTree(object):\n    def __init__(self):\n        pass\n    def stack(self,root):\n        nodes=[root]\n        flag=0\n        while nodes:\n            nodes_tmp=list()\n            while nodes:\n                nodes_tmp.append(nodes.pop(0))\n            # print('nodes_tmp==>',nodes_tmp)\n            if flag%2==0:\n                nodes_print=nodes_tmp\n            else:\n                nodes_print=nodes_tmp[::-1]\n            for val_node in nodes_print:\n                if val_node:\n                    print(val_node.value)\n            for node_iter in nodes_tmp:\n                if node_iter:\n                    # print(node_iter.value)\n                    nodes.extend([node_iter.left_node,node_iter.right_node])\n            flag+=1\n\n\n\nif __name__ == '__main__':\n    root = 1\n    values = [[2,3], [4, 5], [6, 7], [8, 9], [10, 11], [12, None], [None, 13]]\n    mn = MakeNode()\n    root=mn.make_series(root, values)\n    bt=BinaryTree()\n    bt.stack(root)\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}