{"title": "OAuth 2.0简单实战（以新浪开发平台为例） - ceclinux ", "index": "oauth2,python", "content": "背景\n\n本人去年在UCLA打酱油的时候曾经要求抓过新浪微博的有关数据。然而要读写这些微博信息和朋友关系，必须要在新浪围脖平台上注册应用。也就是要接触 OAuth 2.0 这个东西。当时基本不懂，今天看到了阮一峰博客上的这篇文章,决定自己动手一试。\n\n准备\n\n首先，你要把阮一峰博客上的这篇文章 粗略的读一遍。\n\n然后你要上 新浪开发平台 注册一个应用，我注册的是微连接 - 网页应用\n\n\n\n打开界面你可以看到App Key和App Secret，这是要用的东西\n\n好，接下来下载新浪微博python SDK，我们用Python进行分析\n\n分析\n\n首先，我们先根据微博API上面的HOW-TO 文档上来做\n\nfrom weibo import APIClient\n\nAPP_KEY = '1234567' # app key\nAPP_SECRET = 'abcdefghijklmn' # app secret\nCALLBACK_URL = 'http://www.example.com/callback' \nclient = APIClient(app_key=APP_KEY, app_secret=APP_SECRET, redirect_uri=CALLBACK_URL)\nurl = client.get_authorize_url()\n\n\n这样就拿到了URL了，你打开这个URL一看，正是提示你要授权应用（出现error:redirect_uri_mismatch 同学请到新浪微博开发界面填好redirect_uri)\n\n好，我们看看源码\n\nclass APIClient(object):\n    '''\n    API client using synchronized invocation.\n    '''\n    def __init__(self, app_key, app_secret, redirect_uri=None, response_type='code', domain='api.weibo.com', version='2'):\n        self.client_id = str(app_key)\n        self.client_secret = str(app_secret)\n        self.redirect_uri = redirect_uri\n        self.response_type = response_type\n        self.auth_url = 'https://%s/oauth2/' % domain\n        self.api_url = 'https://%s/%s/' % (domain, version)\n        self.access_token = None\n        self.expires = 0.0\n        self.get = HttpObject(self, _HTTP_GET)\n        self.post = HttpObject(self, _HTTP_POST)\n        self.upload = HttpObject(self, _HTTP_UPLOAD)\n\n    def get_authorize_url(self, redirect_uri=None, **kw):\n        '''\n        return the authorization url that the user should be redirected to.\n        '''\n        redirect = redirect_uri if redirect_uri else self.redirect_uri\n        if not redirect:\n            raise APIError('21305', 'Parameter absent: redirect_uri', 'OAuth2 request')\n        response_type = kw.pop('response_type', 'code')\n        return '%s%s?%s' % (self.auth_url, 'authorize', \\\n                _encode_params(client_id = self.client_id, \\\n                        response_type = response_type, \\\n                        redirect_uri = redirect, **kw))\n\n\nclient_id,redirect_url,app_key，好熟悉啊，仔细一看，原来是授权码模式的第一步\n\n\n  The client constructs the request URI by adding the following\n  parameters to the query component of the authorization endpoint URI\n  using the \"application/x-www-form-urlencoded\" format, per Appendix B:\n  \n  response_type\n           REQUIRED.  Value MUST be set to \"code\".\n  \n  client_id\n           REQUIRED.  The client identifier as described in Section 2.2.\n  \n  redirect_uri\n           OPTIONAL.  As described in Section 3.1.2.\n  \n  scope\n           OPTIONAL.  The scope of the access request as described by\n           Section 3.3.\n  \n  state\n           RECOMMENDED.  An opaque value used by the client to maintain\n           state between the request and callback.  The authorization\n           server includes this value when redirecting the user-agent back\n           to the client.  The parameter SHOULD be used for preventing\n           cross-site request forgery as described in Section 10.12.\n\n\n好了，当我们把账号密码填写好了之后验证成功后，你发现你的浏览器上面的URL发生了变化，到底是这么回事呢，请看第二步Authorization Response\n\n\n  If the resource owner grants the access request, the authorization\n  server issues an authorization code and delivers it to the client by\n  adding the following parameters to the query component of the\n  redirection URI using the \"application/x-www-form-urlencoded\" format,\n  per Appendix B:\n  \n  code\n           REQUIRED.  The authorization code generated by the\n           authorization server.  The authorization code MUST expire\n           shortly after it is issued to mitigate the risk of leaks.  A\n           maximum authorization code lifetime of 10 minutes is\n           RECOMMENDED.  The client MUST NOT use the authorization code more than once.  If an authorization code is used more than\n           once, the authorization server MUST deny the request and SHOULD\n           revoke (when possible) all tokens previously issued based on\n           that authorization code.  The authorization code is bound to\n           the client identifier and redirection URI.\n  \n  state\n           REQUIRED if the \"state\" parameter was present in the client\n           authorization request.  The exact value received from the\n           client.\n  \n  For example, the authorization server redirects the user-agent by\n  sending the following HTTP response:\n\n\n HTTP/1.1 302 Found\n Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA\n           &state=xyz\n\n\n然后我们继续按照API的指示做\n\n# 获取URL参数code:\ncode = your.web.framework.request.get('code')\nr = client.request_access_token(code)\n\ndef request_access_token(self, code, redirect_uri=None):\n        redirect = redirect_uri if redirect_uri else self.redirect_uri\n        if not redirect:\n            raise APIError('21305', 'Parameter absent: redirect_uri', 'OAuth2 request')\n        r = _http_post('%s%s' % (self.auth_url, 'access_token'), \\\n                client_id = self.client_id, \\\n                client_secret = self.client_secret, \\\n                redirect_uri = redirect, \\\n                code = code, grant_type = 'authorization_code')\n        return self._parse_access_token(r)\n\n\n这个获得code 方法通常可以有很多，但是我们既然是实验，就手动复制code 吧。\n\n哈哈，很明显request_access_token  这个方法就是发一个HTTP POST 包嘛\n\n第三步Access Token Request\n\n\n  The client makes a request to the token endpoint by sending the\n  following parameters using the \"application/x-www-form-urlencoded\"\n  format per Appendix B with a character encoding of UTF-8 in the HTTP\n  request entity-body:\n  \n  grant_type\n           REQUIRED.  Value MUST be set to \"authorization_code\".\n  \n  code\n           REQUIRED.  The authorization code received from the\n           authorization server.\n  \n  redirect_uri\n           REQUIRED, if the \"redirect_uri\" parameter was included in the\n           authorization request as described in Section 4.1.1, and their\n           values MUST be identical.\n  \n  client_id\n           REQUIRED, if the client is not authenticating with the\n           authorization server as described in Section 3.2.1.\n  \n  If the client type is confidential or the client was issued client\n  credentials (or assigned other authentication requirements), the\n  client MUST authenticate with the authorization server as described\n  in Section 3.2.1.\n  \n  For example, the client makes the following HTTP request using TLS\n  (with extra line breaks for display purposes only):\n\n POST /token HTTP/1.1\n Host: server.example.com\n Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\n Content-Type: application/x-www-form-urlencoded\n\n grant_type=authorization_code&code=SplxlOBeZQQYbYS6WxSbIA\n &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb\n\n\n\n最后一步\n\naccess_token = r.access_token # 新浪返回的token，类似abc123xyz456\nexpires_in = r.expires_in # token过期的UNIX时间：http://zh.wikipedia.org/wiki/UNIX%E6%97%B6%E9%97%B4\n# TODO: 在此可保存access token\nclient.set_access_token(access_token, expires_in)\n\n\n就是从服务器返回的HTTP 包中解析access_token 和 expire_in 数据\n\n同样来看RFC 文档中写的\n\n\n  If the access token request is valid and authorized, the\n  authorization server issues an access token and optional refresh\n  token as described in Section 5.1.  If the request client\n  authentication failed or is invalid, the authorization server returns\n  an error response as described in Section 5.2.\n  \n  An example successful response:\n\n HTTP/1.1 200 OK\n Content-Type: application/json;charset=UTF-8\n Cache-Control: no-store\n Pragma: no-cache\n\n {\n   \"access_token\":\"2YotnFZFEjr1zCsicMWpAA\",\n   \"token_type\":\"example\",\n   \"expires_in\":3600,\n   \"refresh_token\":\"tGzv3JOkF0XG5Qx2TlKWIA\",\n   \"example_parameter\":\"example_value\"\n }\n\n\n\n接下来就可以调用API啦~\n\n对于最后两步看的很累的话，可以自己尝试写一个\n\nimport urllib, urllib2\n\nAPP_KEY = '2613134348'\nAPP_SECRET = '5a14f41598a7444c7e0dc0422519b091' # app secret\nACCESS_TOKEN = '9cd1b3869e62491331caf444456953e8'\ndata = {\n        'grant_type' : 'authorization_code', \n        'code' :ACCESS_TOKEN, \n        'redirect_uri':'http://www.ceclinux.org',\n        'client_id':APP_KEY,\n        'client_secret':APP_SECRET   \n        }\nheaders = {'host':'api.weibo.com','Authorization':'OAuth2 %s' % ACCESS_TOKEN}\ndata = urllib.urlencode(data)\nrequest = urllib2.Request('https://api.weibo.com/oauth2/access_token', data, headers)\nresponse = urllib2.urlopen(request)\nprint response.read()\n\n\n\n运行这个文件\n最后也能得到一个包含access_token和expire_date的JSON文件\n\n没了～\n\n参考\n\n\nhttp://github.liaoxuefeng.com/sinaweibopy/\nhttps://github.com/michaelliao/sinaweibopy/wiki/OAuth2-HOWTO\nhttp://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "12"}