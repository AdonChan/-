{"title": "从零开始构造邻近分类器KNN - 编程进阶之路 ", "index": "python", "content": "起步\n本章介绍如何自行构造 KNN 分类器，这个分类器的实现上算是比较简单的了。不过这可能需要你之前阅读过这方面的知识。\n前置阅读\n分类算法之邻近算法:KNN（理论篇）\n分类算法之邻近算法:KNN（应用篇）\n欧拉公式衡量距离\n关于距离的测量方式有多种，这边采用欧拉距离的测量方式:\n$$\nd(x,y) = \\sqrt{\\sum_{i=0}^n(x_i-y_i)^2}\n$$\n对应的 python 代码:\nimport math\ndef euler_distance(point1: list, point2: list) -> float:\n    \"\"\"\n    计算两点之间的欧拉距离，支持多维\n    \"\"\"\n    distance = 0.0\n    for a, b in zip(point1, point2):\n        distance += math.pow(a - b, 2)\n    return math.sqrt(distance)\nKNN 分类器\nimport collections\nimport numpy as np\nclass KNeighborsClass(object):\n    def __init__(self, n_neighbors=5):\n        self.n_neighbors = n_neighbors\n\n    def fit(self, data_set, labels):\n        self.data_set = data_set\n        self.labels = labels\n\n    def predict(self, test_row):\n        dist = []\n        for v in self.data_set:\n            dist.append(euler_distance(v, test_row))\n        dist = np.array(dist)\n        sorted_dist_index = np.argsort(dist) # 根据元素的值从大到小对元素进行排序，返回下标\n\n        # 根据K值选出分类结果, ['A', 'B', 'B', 'A', ...]\n        class_list = [ self.labels[ sorted_dist_index[i] ] for i in range(self.n_neighbors)]\n        result_dict = collections.Counter(class_list)   # 计算各个分类出现的次数\n        ret = sorted(result_dict.items(), key=lambda x: x[1], reverse=True) # 采用多数表决，即排序后的第一个分类\n        return ret[0][0]\n这个分类器不需要训练，因此在 fit 函数中仅仅保存其数据集和结果集即可。在预测函数中，需要依次计算测试样本与数据集中每个样本的距离。筛选出前 K 个，采用多数表决的方式。\n测试\n还是使用 sklearn 中提供的虹膜数据。\nif __name__ == \"__main__\":\n    from sklearn import datasets\n    iris = datasets.load_iris()\n    knn = KNeighborsClass(n_neighbors=5)\n    knn.fit(iris.data, iris.target)\n    predict = knn.predict([0.1, 0.2, 0.3, 0.4])\n    print(predict)  # output: 1\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}