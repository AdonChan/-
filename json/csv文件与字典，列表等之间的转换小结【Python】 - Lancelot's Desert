{"title": "csv文件与字典，列表等之间的转换小结【Python】 - Lancelot's Desert ", "index": "List,csv,dictionary,python", "content": "本文针对前面利用Python 所做的一次数据匹配实验，整理了其中的一些对于csv文件的读写操作和常用的Python'数据结构'（如字典和列表）之间的转换(Python Version 2.7)\n\ncsv文件与列表之间的转换\n\n将列表转换为csv文件\n将嵌套字典的列表转换为csv文件\n\n将列表转换为csv文件\n最基本的转换，将列表中的元素逐行写入到csv文件中\ndef list2csv(list, file):\n    wr = csv.writer(open(file, 'wb'), quoting=csv.QUOTE_ALL)\n    for word in list:\n        wr.writerow([word])\n将嵌套字典的列表转换为csv文件\n这种属于典型的csv文件读写，常见的csv文件常常是第一行为属性栏，标明各个字段，接下来每一行都是对应属性的值，读取时常常用字典来存储（key为第一行的属性，value为对应行的值）,例如\nmy_list = [{'players.vis_name': 'Khazri', 'players.role': 'Midfielder', 'players.country': 'Tunisia',\n            'players.last_name': 'Khazri', 'players.player_id': '989', 'players.first_name': 'Wahbi',\n            'players.date_of_birth': '08/02/1991', 'players.team': 'Bordeaux'},\n           {'players.vis_name': 'Khazri', 'players.role': 'Midfielder', 'players.country': 'Tunisia',\n            'players.last_name': 'Khazri', 'players.player_id': '989', 'players.first_name': 'Wahbi',\n            'players.date_of_birth': '08/02/1991', 'players.team': 'Sunderland'},\n           {'players.vis_name': 'Lewis Baker', 'players.role': 'Midfielder', 'players.country': 'England',\n            'players.last_name': 'Baker', 'players.player_id': '9574', 'players.first_name': 'Lewis',\n            'players.date_of_birth': '25/04/1995', 'players.team': 'Vitesse'}\n           ]\n而最后所有的字典嵌套到一个列表中存储，而接下来是一个逆过程，即将这种嵌套了字典的列表还原为csv文件存储起来\n# write nested list of dict to csv\ndef nestedlist2csv(list, out_file):\n    with open(out_file, 'wb') as f:\n        w = csv.writer(f)\n        fieldnames=list[0].keys()  # solve the problem to automatically write the header\n        w.writerow(fieldnames)\n        for row in list:\n            w.writerow(row.values())\n注意其中的fieldnames用于传递key即第一行的属性\ncsv文件与字典之间的转换\n\n\ncsv文件转换为字典\n\n第一行为key，其余行为value\n每一行为key,value的记录\n\n\ncsv文件转换为二级字典\n\n字典转换为csv文件\n\n第一行为key，其余行为value\n每一行为key,value的记录\n\n\n\ncsv文件转换为字典\n第一行为key，其余行为value\n针对常见的首行为属性，其余行为值的情形\n# convert csv file to dict\n# @params:\n# key/value: the column of original csv file to set as the key and value of dict\ndef csv2dict(in_file,key,value):\n    new_dict = {}\n    with open(in_file, 'rb') as f:\n        reader = csv.reader(f, delimiter=',')\n        fieldnames = next(reader)\n        reader = csv.DictReader(f, fieldnames=fieldnames, delimiter=',')\n        for row in reader:\n            new_dict[row[key]] = row[value]\n    return new_dict\n其中的new_dict[row[key]] = row[value]中的'key'和'value'是csv文件中的对应的第一行的属性字段,需要注意的是这里假设csv文件比较简单，所指定的key是唯一的，否则直接从csv转换为dict文件会造成重复字段的覆盖而丢失数据，如果原始数据指定作为key的列存在重复的情况，则需要构建列表字典，将value部分设置为list，可参照列表字典的构建部分代码\n每一行为key,value的记录\n针对每一行均为键值对的特殊情形这里默认认为第一列为所构建的字典的key，而第二列对应为value，可根据需要进行修改\n# convert csv file to dict(key-value pairs each row)\ndef row_csv2dict(csv_file):\n    dict_club={}\n    with open(csv_file)as f:\n        reader=csv.reader(f,delimiter=',')\n        for row in reader:\n            dict_club[row[0]]=row[1]\n    return dict_club\n[更新]\n字典列表\n构造有值为列表的字典，主要适用于需要把csv中的某些列对应的值作为某一个列的值的情形或者说本身并不适合作为单纯的字典结构，同一个键对应的值不唯一\n# build a dict of list like {key:[...element of lst_inner_value...]}\n# key is certain column name of csv file\n# the lst_inner_value is a list of specific column name of csv file\ndef build_list_dict(source_file, key, lst_inner_value):\n    new_dict = {}\n    with open(source_file, 'rb')as csv_file:\n        data = csv.DictReader(csv_file, delimiter=\",\")\n        for row in data:\n            for element in lst_inner_value:\n                new_dict.setdefault(row[key], []).append(row[element])\n    return new_dict\n# sample:\n# test_club=build_list_dict('test_info.csv','season',['move from','move to'])\n# print test_club\ncsv文件转换为二级字典\n这个一般是特殊用途，将csv文件进一步结构化，将其中的某一列(属性)所对应的值作为key，然后将其余键值对构成子字典作为value，一般用于匹配时优先过滤来建立一种层级结构提高准确度例如我有csv文件的记录如下（以表格形式表示）\n\n\nid\nname\nage\ncountry\n\n\n\n1\ndanny\n21\nChina\n\n\n2\nLancelot\n22\nAmerica\n\n\n...\n...\n...\n...\n\n\n\n经过二级字典转换后（假设构建country-name两级）得到如下字典\ndct={'China':{'danny':{'id':'1','age':'21'}}\n     'America':{'Lancelot':{'id':'2','age':'22'}}}\n代码如下\n# build specific nested dict from csv files(date->name)\ndef build_level2_dict(source_file):\n    new_dict = {}\n    with open(source_file, 'rb')as csv_file:\n        data = csv.DictReader(csv_file, delimiter=\",\")\n        for row in data:\n            item = new_dict.get(row['country'], dict())\n            item[row['name']] = {k: row[k] for k in ('id','age')}\n            new_dict[row['country']] = item\n    return new_dict\n[更新]进一步改进后可以使用更加灵活一点的方法来构建二级字典，不用修改内部代码，二是指定传入的键和值，有两种不同的字典构建，按需查看\n构建的二级字典的各层级的键值均人为指定为某一列的值\n# build specific nested dict from csv files\n# @params:\n#   source_file\n#   outer_key:the outer level key of nested dict\n#   inner_key:the inner level key of nested dict\n#   inner_value:set the inner value for the inner key\ndef build_level2_dict2(source_file,outer_key,inner_key,inner_value):\n    new_dict = {}\n    with open(source_file, 'rb')as csv_file:\n        data = csv.DictReader(csv_file, delimiter=\",\")\n        for row in data:\n            item = new_dict.get(row[outer_key], dict())\n            item[row[inner_key]] = row[inner_value]\n            new_dict[row[outer_key]] = item\n    return new_dict\n指定第一层和第二层的字典的键，而将csv文件中剩余的键值对存储为最内层的值\n# build specific nested dict from csv files\n# @params:\n#   source_file\n#   outer_key:the outer level key of nested dict\n#   inner_key:the inner level key of nested dict,and rest key-value will be store as the value of inner key\ndef build_level2_dict(source_file,outer_key,inner_key):\n    new_dict = {}\n    with open(source_file, 'rb')as csv_file:\n        reader = csv.reader(csv_file, delimiter=',')\n        fieldnames = next(reader)\n        inner_keyset=fieldnames\n        inner_keyset.remove(outer_key)\n        inner_keyset.remove(inner_key)\n        csv_file.seek(0)\n        data = csv.DictReader(csv_file, delimiter=\",\")\n        for row in data:\n            item = new_dict.get(row[outer_key], dict())\n            item[row[inner_key]] = {k: row[k] for k in inner_keyset}\n            new_dict[row[outer_key]] = item\n    return new_dict\n还有另一种构建二级字典的方法，利用的是pop()方法，但是个人觉得不如这个直观，贴在下面\ndef build_dict(source_file):\n    projects = defaultdict(dict)\n    # if there is no header within the csv file you need to set the header \n    # and utilize fieldnames parameter in csv.DictReader method\n    # headers = ['id', 'name', 'age', 'country']\n    with open(source_file, 'rb') as fp:\n        reader = csv.DictReader(fp, dialect='excel', skipinitialspace=True)\n        for rowdict in reader:\n            if None in rowdict:\n                del rowdict[None]\n            nationality = rowdict.pop(\"country\")\n            date_of_birth = rowdict.pop(\"name\")\n            projects[nationality][date_of_birth] = rowdict\n    return dict(projects)\n\n[更新]另外另种构造二级字典的方法，主要是针对csv文件并不适合直接构造单纯的字典结构，某些键对应多个值，所以需要在内部用列表来保存值，或者对每一个键值对用列表保存\n用列表保存键值对\n# build specific nested dict from csv files\n# @params:\n#   source_file\n#   outer_key:the outer level key of nested dict\n#   lst_inner_value: a list of column name,for circumstance that the inner value of the same outer_key are not distinct\n#   {outer_key:[{pairs of lst_inner_value}]}\ndef build_level2_dict3(source_file,outer_key,lst_inner_value):\n    new_dict = {}\n    with open(source_file, 'rb')as csv_file:\n        data = csv.DictReader(csv_file, delimiter=\",\")\n        for row in data:\n            new_dict.setdefault(row[outer_key], []).append({k: row[k] for k in lst_inner_value})\n    return new_dict\n用列表保存值域\n# build specific nested dict from csv files\n# @params:\n#   source_file\n#   outer_key:the outer level key of nested dict\n#   lst_inner_value: a list of column name,for circumstance that the inner value of the same outer_key are not distinct\n#   {outer_key:{key of lst_inner_value:[...value of lst_inner_value...]}}\ndef build_level2_dict4(source_file,outer_key,lst_inner_value):\n    new_dict = {}\n    with open(source_file, 'rb')as csv_file:\n        data = csv.DictReader(csv_file, delimiter=\",\")\n        for row in data:\n            # print row\n            item = new_dict.get(row[outer_key], dict())\n            # item.setdefault('move from',[]).append(row['move from'])\n            # item.setdefault('move to', []).append(row['move to'])\n            for element in lst_inner_value:\n                item.setdefault(element, []).append(row[element])\n            new_dict[row[outer_key]] = item\n    return new_dict\n# build specific nested dict from csv files\n# @params:\n#   source_file\n#   outer_key:the outer level key of nested dict\n#   lst_inner_key:a list of column name\n#   lst_inner_value: a list of column name,for circumstance that the inner value of the same lst_inner_key are not distinct\n#   {outer_key:{lst_inner_key:[...lst_inner_value...]}}\ndef build_list_dict2(source_file,outer_key,lst_inner_key,lst_inner_value):\n    new_dict = {}\n    with open(source_file, 'rb')as csv_file:\n        data = csv.DictReader(csv_file, delimiter=\",\")\n        for row in data:\n            # print row\n            item = new_dict.get(row[outer_key], dict())\n            item.setdefault(row[lst_inner_key], []).append(row[lst_inner_value])\n            new_dict[row[outer_key]] = item\n    return new_dict\n\n# dct=build_list_dict2('test_info.csv','season','move from','move to')\n构造三级字典\n类似的，可以从csv重构造三级字典甚至多级字典，方法和上面的类似，就不赘述了，只贴代码\n# build specific nested dict from csv files\n# a dict like {outer_key:{inner_key1:{inner_key2:{rest_key:rest_value...}}}}\n# the params are extract from the csv column name as you like\ndef build_level3_dict(source_file,outer_key,inner_key1,inner_key2):\n    new_dict = {}\n    with open(source_file, 'rb')as csv_file:\n        reader = csv.reader(csv_file, delimiter=',')\n        fieldnames = next(reader)\n        inner_keyset=fieldnames\n        inner_keyset.remove(outer_key)\n        inner_keyset.remove(inner_key1)\n        inner_keyset.remove(inner_key2)\n        csv_file.seek(0)\n        data = csv.DictReader(csv_file, delimiter=\",\")\n        for row in data:\n            item = new_dict.get(row[outer_key], dict())\n            sub_item = item.get(row[inner_key1], dict())\n            sub_item[row[inner_key2]] = {k: row[k] for k in inner_keyset}\n            item[row[inner_key1]] = sub_item\n            new_dict[row[outer_key]] = item\n    return new_dict\n\n# build specific nested dict from csv files\n# a dict like {outer_key:{inner_key1:{inner_key2:inner_value}}}\n# the params are extract from the csv column name as you like\ndef build_level3_dict2(source_file,outer_key,inner_key1,inner_key2,inner_value):\n    new_dict = {}\n    with open(source_file, 'rb')as csv_file:\n        data = csv.DictReader(csv_file, delimiter=\",\")\n        for row in data:\n            item = new_dict.get(row[outer_key], dict())\n            sub_item = item.get(row[inner_key1], dict())\n            sub_item[row[inner_key2]] = row[inner_value]\n            item[row[inner_key1]] = sub_item\n            new_dict[row[outer_key]] = item\n    return new_dict\n这里同样给出两种根据不同需求构建字典的方法，一种是将剩余的键值对原封不动地保存为最内部的值，另一种是只取所需要的键值对保留。\n此外还有一种特殊情形，当你的最内部的值不是一个单独的元素而需要是一个列表来存储多个对应同一个键的元素，则只需要对于最内部的键值对进行修改\n# build specific nested dict from csv files\n# a dict like {outer_key:{inner_key1:{inner_key2:[inner_value]}}}\n# for multiple inner_value with the same inner_key2,thus gather them in a list\n# the params are extract from the csv column name as you like\ndef build_level3_dict3(source_file,outer_key,inner_key1,inner_key2,inner_value):\n    new_dict = {}\n    with open(source_file, 'rb')as csv_file:\n        data = csv.DictReader(csv_file, delimiter=\",\")\n        for row in data:\n            item = new_dict.get(row[outer_key], dict())\n            sub_item = item.get(row[inner_key1], dict())\n            sub_item.setdefault(row[inner_key2], []).append(row[inner_value])\n            item[row[inner_key1]] = sub_item\n            new_dict[row[outer_key]] = item\n    return new_dict\n其中的核心部分是这一句sub_item.setdefault(row[inner_key2], []).append(row[inner_value])\n字典转换为csv文件\n\n每一行为key,value的记录\n第一行为key，其余行为value\n输出列表字典\n\n每一行为key,value的记录\n前述csv文件转换为字典的逆过程，比较简单就直接贴代码啦\ndef dict2csv(dict,file):\n    with open(file,'wb') as f:\n        w=csv.writer(f)\n        # write each key/value pair on a separate row\n        w.writerows(dict.items())\n第一行为key，其余行为value\ndef dict2csv(dict,file):\n    with open(file,'wb') as f:\n        w=csv.writer(f)\n        # write all keys on one row and all values on the next\n        w.writerow(dict.keys())\n        w.writerow(dict.values())\n输出列表字典\n其实这个不太常用，倒是逆过程比较常见，就是从常规的csv文件导入到列表的字典（本身是一个字典，csv文件的首行构成键，其余行依次构成对应列下的键的值，其中值形成列表），不过如果碰到这种情形要保存为csv文件的话，做法如下\nimport csv\nimport pandas as pd\nfrom collections import OrderedDict\n\ndct=OrderedDict()\ndct['a']=[1,2,3,4]\ndct['b']=[5,6,7,8]\ndct['c']=[9,10,11,12]\n\nheader = dct.keys()\nrows=pd.DataFrame(dct).to_dict('records')\n\nwith open('outTest.csv', 'wb') as f:\n    f.write(','.join(header))\n    f.write('\\n')\n    for data in rows:\n        f.write(\",\".join(str(data[h]) for h in header))\n        f.write('\\n')\n这里用到了三个包，除了csv包用于常规的csv文件读取外，其中OrderedDict用于让csv文件输出后保持原有的列的顺序，而pandas则适用于中间的一步将列表构成的字典转换为字典构成的列表，举个例子\n[('a', [1, 2, 3, 4]), ('b', [5, 6, 7, 8]), ('c', [9, 10, 11, 12])]\nto\n[{'a': 1, 'c': 9, 'b': 5}, {'a': 2, 'c': 10, 'b': 6}, {'a': 3, 'c': 11, 'b': 7}, {'a': 4, 'c': 12, 'b': 8}]\n特殊的csv文件的读取\n这个主要是针对那种分隔符比较特殊的csv文件，一般情形下csv文件统一用一种分隔符是关系不大的（向上述操作基本都是针对分隔符统一用,的情形），而下面这种第一行属性分隔符是,而后续值的分隔符均为;的读取时略有不同，一般可逐行转换为字典在进行操作，代码如下:\ndef func(id_list,input_file,output_file):\n    with open(input_file, 'rb') as f:\n        # if the delimiter for header is ',' while ';' for rows\n        reader = csv.reader(f, delimiter=',')\n        fieldnames = next(reader)\n\n        reader = csv.DictReader(f, fieldnames=fieldnames, delimiter=';')        \n        rows = [row for row in reader if row['players.player_id'] in set(id_list)]\n        # operation on rows...\n可根据需要修改分隔符中的内容.\n关于csv文件的一些操作我在实验过程中遇到的问题大概就是这些啦，大部分其实都可以在stackoverflow上找到或者自己提问解决，上面的朋友还是很给力的，后续会小结一下实验过程中的一些对数据的其他处理如格式转换，除重，重复判断等等\n最后，源码我发布在github上的csv_toolkit里面，欢迎随意玩耍~\n\n更新日志1、2016-12-22： 改进了构建二级字典的方法，使其变得更加灵活2、2016-12-24 14:55:30： 加入构造三级字典的方法3、2017年1月9日11:26:59： 最内部可保存制定列的元素列表4、2017年1月16日10:29:44：加入了列表字典的构建；针对特殊二级字典的构建（需要保存对应同一个键的多个值）；5、2017年2月9日10:54:41： 加入新的二级列表字典的构建6、2017年2月10日11:18:01：改进了简单的csv文件到字典的构建代码\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "4"}