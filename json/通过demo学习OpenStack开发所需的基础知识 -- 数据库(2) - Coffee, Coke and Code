{"title": "通过demo学习OpenStack开发所需的基础知识 -- 数据库(2) - Coffee, Coke and Code ", "index": "python,openstack", "content": "在上一篇文章，我们介绍了SQLAlchemy的基本概念，也介绍了基本的使用流程。本文我们结合webdemo这个项目来介绍如何在项目中使用SQLAlchemy。另外，我们还会介绍数据库版本管理的概念和实践，这也是OpenStack每个项目都需要做的事情。\nWebdemo中的数据模型的定义和实现\n我们之前在webdemo项目中已经开发了一个user管理的API，可以在这里回顾。当时只是接收了API请求并且打印信息，并没有实际的进行数据存储。现在我们就要引入数据库操作，来完成user管理的API。\nUser数据模型\n在开发数据库应用前，需要先定义好数据模型。因为本文只是要演示SQLAlchemy的应用，所以我们定义个最简单的数据模型。user表的定义如下：\n\nid: 主键，一般由数据库的自增类型实现。\nuser_id: user id，是一个UUID字符串，是OpenStack中最常用来标记资源的方式，全局唯一，并且为该字段建立索引。\nname: user的名称，允许修改，全局唯一，不能为空。\nemail: user的email，允许修改，可以为空。\n\n搭建数据库层的代码框架\nOpenStack项目中我见过两种数据库的代码框架分隔，一种是Keystone的风格，它把一组API的API代码和数据库代码都放在同一个目录下，如下所示：\n\n采用Pecan框架的项目则大多把数据库相关代码都放在db目录下，比如Magnum项目，如下所示：\n\n由于webdemo采用的是Pecan框架，而且把数据库操作的代码放到同一个目录下也会比较清晰，所以我们采用和Magnum项目相同的方式来编写数据库相关的代码，创建webdemo/db目录，然后把数据库操作的相关代码都放在这个目录下，如下所示：\n\n由于webdemo项目还没有使用oslo_db库，所以代码看起来比较直观，没有Magnum项目复杂。接下来，我们就要开始写数据库操作的相关代码，分为两个步骤：\n\n在db/models.py中定义User类，对应数据库的user表。\n在db/api.py中实现一个Connection类，这个类封装了所有的数据库操作接口。我们会在这个类中实现对user表的CRUD等操作。\n\n定义User数据模型映射类\ndb/models.py中的代码如下：\nfrom sqlalchemy import Column, Integer, String\nfrom sqlalchemy.ext import declarative\nfrom sqlalchemy import Index\n\n\nBase = declarative.declarative_base()\n\n\nclass User(Base):\n    \"\"\"User table\"\"\"\n\n    __tablename__ = 'user'\n    __table_args__ = (\n        Index('ix_user_user_id', 'user_id'),\n    )\n    id = Column(Integer, primary_key=True)\n    user_id = Column(String(255), nullable=False)\n    name = Column(String(64), nullable=False, unique=True)\n    email = Column(String(255))\n我们按照我们之前定义的数据模型，实现了映射类。\n实现DB API\nDB通用函数\n在db/api.py中，我们先定义了一些通用函数，代码如下：\nfrom sqlalchemy import create_engine\nimport sqlalchemy.orm\nfrom sqlalchemy.orm import exc\n\nfrom webdemo.db import models as db_models\n\n\n_ENGINE = None\n_SESSION_MAKER = None\n\n\ndef get_engine():\n    global _ENGINE\n    if _ENGINE is not None:\n        return _ENGINE\n\n    _ENGINE = create_engine('sqlite://')\n    db_models.Base.metadata.create_all(_ENGINE)\n    return _ENGINE\n\n\ndef get_session_maker(engine):\n    global _SESSION_MAKER\n    if _SESSION_MAKER is not None:\n        return _SESSION_MAKER\n\n    _SESSION_MAKER = sqlalchemy.orm.sessionmaker(bind=engine)\n    return _SESSION_MAKER\n\n\ndef get_session():\n    engine = get_engine()\n    maker = get_session_maker(engine)\n    session = maker()\n\n    return session\n上面的代码中，我们定义了三个函数：\n\nget_engine：返回全局唯一的engine，不需要重复分配。\nget_session_maker：返回全局唯一的session maker，不需要重复分配。\nget_session：每次返回一个新的session，因为一个session不能同时被两个数据库客户端使用。\n\n这三个函数是使用SQLAlchemy中经常会封装的，所以OpenStack的oslo_db项目就封装了这些函数，供所有的OpenStack项目使用。\n这里需要注意一个地方，在get_engine()中：\n    _ENGINE = create_engine('sqlite://')\n    db_models.Base.metadata.create_all(_ENGINE)\n我们使用了sqlite内存数据库，并且立刻创建了所有的表。这么做只是为了演示方便。在实际的项目中，create_engine()的数据库URL参数应该是从配置文件中读取的，而且也不能在创建engine后就创建所有的表（这样数据库的数据都丢了）。要解决在数据库中建表的问题，就要先了解数据库版本管理的知识，也就是database migration，我们在下文中会说明。\nConnection实现\nConnection的实现就简单得多了，直接看代码。这里只实现了get_user()和list_users()方法。\nclass Connection(object):\n\n    def __init__(self):\n        pass\n\n    def get_user(self, user_id):\n        query = get_session().query(db_models.User).filter_by(user_id=user_id)\n        try:\n            user = query.one()\n        except exc.NoResultFound:\n            # TODO(developer): process this situation\n            pass\n\n        return user\n\n    def list_users(self):\n        session = get_session()\n        query = session.query(db_models.User)\n        users = query.all()\n\n        return users\n\n    def update_user(self, user):\n        pass\n\n    def delete_user(self, user):\n        pass\n在API Controller中使用DB API\n现在我们有了DB API，接下来就是要在Controller中使用它。对于使用Pecan框架的应用来说，我们定义一个Pecan hook，这个hook在每个请求进来的时候实例化一个db的Connection对象，然后在controller代码中我们可以直接使用这个Connection实例。关于Pecan hook的相关信息，请查看Pecan官方文档。\n首先，我们要实现这个hook，并且加入到app中。hook的实现代码在webdemo/api/hooks.py中：\nfrom pecan import hooks\n\nfrom webdemo.db import api as db_api\n\n\nclass DBHook(hooks.PecanHook):\n    \"\"\"Create a db connection instance.\"\"\"\n\n    def before(self, state):\n        state.request.db_conn = db_api.Connection()\n然后，修改webdemo/api/app.py中的setup_app()方法：\ndef setup_app():\n    config = get_pecan_config()\n\n    app_hooks = [hooks.DBHook()]\n    app_conf = dict(config.app)\n    app = pecan.make_app(\n        app_conf.pop('root'),\n        logging=getattr(config, 'logging', {}),\n        hooks=app_hooks,\n        **app_conf\n    )\n\n    return app\n现在，我们就可以在controller使用DB API了。我们这里要重新实现API服务(4)实现的GET /v1/users这个接口：\n...\nclass User(wtypes.Base):\n    id = int\n    user_id = wtypes.text\n    name = wtypes.text\n    email = wtypes.text\n\n\nclass Users(wtypes.Base):\n    users = [User]\n...\nclass UsersController(rest.RestController):\n\n    @pecan.expose()\n    def _lookup(self, user_id, *remainder):\n        return UserController(user_id), remainder\n\n    @expose.expose(Users)\n    def get(self):\n        db_conn = request.db_conn     # 获取DBHook中创建的Connection实例\n        users = db_conn.list_users()  # 调用所需的DB API\n        users_list = []\n        for user in users:\n            u = User()\n            u.id = user.id\n            u.user_id = user.user_id\n            u.name = user.name\n            u.email = user.email\n            users_list.append(u)\n        return Users(users=users_list)\n\n    @expose.expose(None, body=User, status_code=201)\n    def post(self, user):\n        print user\n现在，我们就已经完整的实现了这个API，客户端访问API时是从数据库拿数据，而不是返回一个模拟的数据。读者可以使用API服务(4)中的方法运行测试服务器来测试这个API。注意：由于数据库操作依赖于SQLAlchemy库，所以需要把它添加到requirement.txt中：SQLAlchemy<1.1.0,>=0.9.9。\n小结\n现在我们已经完成了数据库层的代码框架搭建，读者可以大概了解到一个OpenStack项目中是如何进行数据库操作的。上面的代码可以到https://github.com/diabloneo/webdemo下载。\n数据库版本管理\n数据库版本管理的概念\n上面我们在get_engine()函数中使用了内存数据库，并且创建了所有的表。在实际项目中，这么做肯定是不行的：\n\n实际项目中不会使用内存数据库，这种数据库一般只是在单元测试中使用。\n如果每次create_engine都把数据库的表重新创建一次，那么数据库中的数据就丢失了，绝对不可容忍。\n\n解决这个问题的办法也很简单：不使用内存数据库，并且在运行项目代码前先把数据库中的表都建好。这么做确实是解决了问题，但是看起来有点麻烦：\n\n如果每次都手动写SQL语句来创建数据库中的表，会很容易出错，而且很麻烦。\n如果项目修改了数据模型，那么不能简单的修改建表的SQL语句，因为重新建表会让数据丢失。我们只能增加新的SQL语句来修改现有的数据库。\n最关键的是：我们怎么知道一个正在生产运行的数据库是要执行那些SQL语句？如果数据库第一次使用，那么执行全部的语句是正确的；如果数据库已经在使用，里面有数据，那么我们只能执行那些修改表定义的SQL语句，而不能执行那些重新建表的SQL语句。\n\n为了解决这种问题，就有人发明了数据库版本管理的概念，也称为Database Migration。基本原理是：在我们要使用的数据库中建立一张表，里面保存了数据库的当前版本，然后我们在代码中为每个数据库版本写好所需的SQL语句。当对一个数据库执行migration操作时，会执行从当前版本到目标版本之间的所有SQL语句。举个例子：\n\n在Version 1时，我们在数据库中建立一个user表。\n在Version 2时，我们在数据库中建立一个project表。\n在Version 3时，我们修改user表，增加一个age列。\n\n那么在我们对一个数据库执行migration操作，数据库的当前版本Version 1，我们设定的目标版本是Version 3，那么操作就是：建立一个project表，修改user表，增加一个age列，并且把数据库当前版本设置为Version 3。\n数据库的版本管理是所有大型数据库项目的需求，每种语言都有自己的解决方案。OpenStack中主要使用SQLAlchemy的两种解决方案：sqlalchemy-migrate和Alembic。早期的OpenStack项目使用了sqlalchemy-migrate，后来换成了Alembic。做出这个切换的主要原因是Alembic对数据库版本的设计和管理更灵活，可以支持分支，而sqlalchemy-migrate只能支持直线的版本管理，具体可以看OpenStack的WiKi文档Alembic。\n接下来，我们就在我们的webdemo项目中引入Alembic来进行版本管理。\nAlembic\n要使用Alembic，大概需要以下步骤：\n\n安装Alembic\n在项目中创建Alembic的migration环境\n修改Alembic配置文件\n创建migration脚本\n执行迁移动作\n\n看起来步骤很复杂，其实搭建好环境后，新增数据库版本只需要执行最后两个步骤。\n安装Alembic\n在webdemo/requirements.txt中加入：alembic>=0.8.0。然后在virtualenv中安装即可。\n在项目中创建Alembic的migration环境\n一般OpenStack项目中，Alembic的环境都是放在db/sqlalchemy/目录下，因此，我们先建立目录webdemo/db/sqlalchemy/，然后在这个目录下初始化Alembic环境：\n(.venv)➜ ~/programming/python/webdemo git:(master) ✗ $ cd webdemo/db\n(.venv)➜ ~/programming/python/webdemo/webdemo/db git:(master) ✗ $ ls\napi.py  api.pyc  __init__.py  __init__.pyc  models.py  models.pyc  sqlalchemy\n(.venv)➜ ~/programming/python/webdemo/webdemo/db git:(master) ✗ $ cd sqlalchemy\n(.venv)➜ ~/programming/python/webdemo/webdemo/db/sqlalchemy git:(master) ✗ $ ls\n(.venv)➜ ~/programming/python/webdemo/webdemo/db/sqlalchemy git:(master) ✗ $ alembic init alembic\n  Creating directory /home/diabloneo/programming/python/webdemo/webdemo/db/sqlalchemy/alembic ... done\n  Creating directory /home/diabloneo/programming/python/webdemo/webdemo/db/sqlalchemy/alembic/versions ... done\n  Generating /home/diabloneo/programming/python/webdemo/webdemo/db/sqlalchemy/alembic/script.py.mako ... done\n  Generating /home/diabloneo/programming/python/webdemo/webdemo/db/sqlalchemy/alembic.ini ... done\n  Generating /home/diabloneo/programming/python/webdemo/webdemo/db/sqlalchemy/alembic/README ... done\n  Generating /home/diabloneo/programming/python/webdemo/webdemo/db/sqlalchemy/alembic/env.pyc ... done\n  Generating /home/diabloneo/programming/python/webdemo/webdemo/db/sqlalchemy/alembic/env.py ... done\n  Please edit configuration/connection/logging settings in '/home/diabloneo/programming/python/webdemo/webdemo/db/sqlalchemy/alembic.ini' before proceeding.\n(.venv)➜ ~/programming/python/webdemo/webdemo/db/sqlalchemy git:(master) ✗ $\n现在，我们就在webdemo/db/sqlalchemy/alembic/目录下建立了一个Alembic migration环境：\n\n修改Alembic配置文件\nwebdemo/db/sqlalchemy/alembic.ini文件是Alembic的配置文件，我们现在需要修改文件中的sqlalchemy.url这个配置项，用来指向我们的数据库。这里，我们使用SQLite数据库，数据库文件存放在webdemo项目的根目录下，名称是webdemo.db：\n# sqlalchemy.url = driver://user:pass@localhost/dbname\nsqlalchemy.url = sqlite:///../../../webdemo.db\n注意：实际项目中，数据库的URL信息是从项目配置文件中读取，然后通过动态的方式传递给Alembic的。具体的做法，读者可以参考Magnum项目的实现：https://github.com/openstack/magnum/blob/master/magnum/db/sqlalchemy/migration.py。\n创建migration脚本\n现在，我们可以创建第一个迁移脚本了，我们的第一个数据库版本就是创建我们的user表：\n(.venv)➜ ~/programming/python/webdemo/webdemo/db/sqlalchemy git:(master) ✗ $ alembic revision -m \"Create user table\"\n  Generating /home/diabloneo/programming/python/webdemo/webdemo/db/sqlalchemy/alembic/versions/4bafdb464737_create_user_table.py ... done\n现在脚本已经帮我们生成好了，不过这个只是一个空的脚本，我们需要自己实现里面的具体操作，补充完整后的脚本如下：\n\"\"\"Create user table\n\nRevision ID: 4bafdb464737\nRevises:\nCreate Date: 2016-02-21 12:24:46.640894\n\n\"\"\"\n\n# revision identifiers, used by Alembic.\nrevision = '4bafdb464737'\ndown_revision = None\nbranch_labels = None\ndepends_on = None\n\nfrom alembic import op\nimport sqlalchemy as sa\n\n\ndef upgrade():\n    op.create_table(\n        'user',\n        sa.Column('id', sa.Integer, primary_key=True),\n        sa.Column('user_id', sa.String(255), nullable=False),\n        sa.Column('name', sa.String(64), nullable=False, unique=True),\n        sa.Column('email', sa.String(255))\n    )\n\n\ndef downgrade():\n    op.drop_table('user')\n其实就是把User类的定义再写了一遍，使用了Alembic提供的接口来方便的创建和删除表。\n执行迁移操作\n我们需要在webdemo/db/sqlalchemy/目录下执行迁移操作，可能需要手动指定PYTHONPATH：\n(.venv)➜ ~/programming/python/webdemo/webdemo/db/sqlalchemy git:(master) ✗ $ PYTHONPATH=../../../ alembic upgrade head\nINFO  [alembic.migration] Context impl SQLiteImpl.\nINFO  [alembic.migration] Will assume non-transactional DDL.\nINFO  [alembic.migration] Running upgrade  -> 4bafdb464737, Create user table\nalembic upgrade head会把数据库升级到最新的版本。这个时候，在webdemo的根目录下会出现webdemo.db这个文件，可以使用sqlite3命令查看内容：\n(.venv)➜ ~/programming/python/webdemo git:(master) ✗ $ ls\nAUTHORS  build  ChangeLog  dist  LICENSE  README.md  requirements.txt  Session.vim  setup.cfg  setup.py  webdemo  webdemo.db  webdemo.egg-info\n(.venv)➜ ~/programming/python/webdemo git:(master) ✗ $ sqlite3 webdemo.db\nSQLite version 3.8.11.1 2015-07-29 20:00:57\nEnter \".help\" for usage hints.\nsqlite> .tables\nalembic_version  user\nsqlite> .schema alembic_version\nCREATE TABLE alembic_version (\n        version_num VARCHAR(32) NOT NULL\n);\nsqlite> .schema user\nCREATE TABLE user (\n        id INTEGER NOT NULL,\n        user_id VARCHAR(255) NOT NULL,\n        name VARCHAR(64) NOT NULL,\n        email VARCHAR(255),\n        PRIMARY KEY (id),\n        UNIQUE (name)\n);\nsqlite> .header on\nsqlite> select * from alembic_version;\nversion_num\n4bafdb464737\n测试新的数据库\n现在我们可以把之前使用的内存数据库换掉，使用我们的文件数据库，修改get_engine()函数：\ndef get_engine():\n    global _ENGINE\n    if _ENGINE is not None:\n        return _ENGINE\n\n    _ENGINE = create_engine('sqlite:///webdemo.db')\n    return _ENGINE\n现在你可以手动往webdemo.db中添加数据，然后测试下API：\n➜ ~/programming/python/webdemo git:(master) ✗ $ sqlite3 webdemo.db\nSQLite version 3.8.11.1 2015-07-29 20:00:57\nEnter \".help\" for usage hints.\nsqlite> .header on\nsqlite> select * from user;\nsqlite> .schema user\nCREATE TABLE user (\n        id INTEGER NOT NULL,\n        user_id VARCHAR(255) NOT NULL,\n        name VARCHAR(64) NOT NULL,\n        email VARCHAR(255),\n        PRIMARY KEY (id),\n        UNIQUE (name)\n);\nsqlite> insert into user values(1, \"user_id\", \"Alice\", \"alice@example.com\");\nsqlite> select * from user;\nid|user_id|name|email\n1|user_id|Alice|alice@example.com\nsqlite> .q\n➜ ~/programming/python/webdemo git:(master) ✗ $\n➜ ~/programming/python/webdemo git:(master) ✗ $ curl http://localhost:8080/v1/users\n{\"users\": [{\"email\": \"alice@example.com\", \"user_id\": \"user_id\", \"id\": 1, \"name\": \"Alice\"}]}% \n小结\n现在，我们就已经完成了database migration代码框架的搭建，可以成功执行了第一个版本的数据库迁移。OpenStack项目中也是这么来做数据库迁移的。后续，一旦修改了项目，需要修改数据模型时，只要新增migration脚本即可。这部分代码也可以在https://github.com/diabloneo/webdemo中看到。\n在实际生产环境中，当我们发布了一个项目的新版本后，在上线的时候，都会自动执行数据库迁移操作，升级数据库版本到最新的版本。如果线上的数据库版本已经是最新的，那么这个操作没有任何影响；如果不是最新的，那么会把数据库升级到最新的版本。\n关于Alembic的更多使用方法，请阅读官方文档Alembic。\n总结\n本文到这边就结束了，这两篇文章我们了解OpenStack中数据库应用开发的基础知识。接下来，我们将会了解OpenStack中单元测试的相关知识。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "13"}