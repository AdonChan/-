{"title": "python, ruby, javascript 浅析 - From SICP to Lisp ", "index": "javascript,node.js,ruby,python", "content": "本文原发于个人博客\n最近一直在看红宝石（ruby）语言，到现在为止，算是对其设计有一些了解。作为一动态语言，ruby 经常会拿来与 python 对比，确实这两门语言在语法层面、实现层面有很多共同的地方，但是它们也在很多设计理念上存在重要差异，通过对比这些相同点、异同点，更加有助于理解这两门语言。同时，Node.js、React Native 的出现，将 javascript 这门“前端”语言推向了全栈，同样作为一门动态语言，javascript 与 ruby、python 在很多概念上也存在很多相同点、异同点。\n本篇文章着重从编程语言设计的角度进行阐述，并不会涉及三门语言性能、使用场景相关的内容。希望对编程语言爱好者理解这三门语言有所帮助，做到融会贯通。\n讨论范围\nPython、Ruby、Javascript(ECMAScript) 准确说是一种语言规范，规范可以有多种实现，这体现在不同的解释器上。\n\nPython 的解释器主要有 CPython、IronPython、Jython、PyPy\nRuby 的解释器主要有 Ruby MRI(CRuby)、JRuby、MacRuby、IronRuby\nJavascript 的解释器主要有 Chakra, SpiderMonkey, V8\n\n本文主要讨论的是 CPython、CRuby，它们是其语言作者亲自设计的，也是应用场景最广的。Javascript 在语言设计之初根本没考虑到其应用范围会如此之广，所以相比其他语言，它语言内置的功能要弱很多，ES6 的出现就是为了解决这个问题，本文所涉及的 javascript 运行在基于 V8 引擎的 Node.js 中，且具备 ES6 语法。\n语言定义\n首先看一下 wikipedia 上对这三门语言的定义：\n\nPython is a widely used high-level, general-purpose, interpreted, dynamic programming language\nRuby is a dynamic, reflective, object-oriented, general-purpose programming language.\nJavaScript is a high-level, dynamic, untyped, and interpreted programming language.\n\n其实上面标红的关键字对于这三门语言来说都适用，只是每个语言的强调点不一样而已。\n通常会称这三门语言为动态语言，支持函数式、面向对象两种编程范式，这两点其实是最重要的。\n设计理念\n既轻量又强大是大多数动态语言相通的设计理念，关于 javascript 设计理念更多的介绍可以参考我的这篇文章介绍。至于 Python 与 Ruby 设计理念的区别，一句话即可概括：\n\nPython: 一件事情只有一种方法做\nRuby: 一件事情有多种方法做\n\n比如，Python 中 Tuple, Array, String 没有相应获取大小的方法，而是提供了统一的len来解决这个问题\n>>> len([1,2])\n2\n>>> len(\"hello world\")\n11\n>>> len((1,2))\n2\n至于 Ruby 的一件事情有多种方法做的理念，后面我在讲解 lambda 时再介绍。\n语法\n如果你之前没接触过 ruby、python 的语法，推荐先去了解下：\n\nRuby Essentials，两个小时绝对看完了\npython 最佳实践，应该用不了半个小时\n\njavascript 实在是太简单了，就不用特别看了。\n综合来说，python、javascript 还是比较中规中矩的，即使 ES6 里面加了很多花哨的语法糖衣，但是也比较直观，但是 ruby 这个语言就比较变态了，各种符号，像class Son < Father表示类的基础，\"hello\" << \" world\"表示字符串的拼接，@var表示对象的成员变量，@@var表示类的成员变量，$var表示全局变量。\n而且在 ruby 中，方法调用时的括号可有可无，即使有参数也可以省略：\n> def add(a, b)\n>     a + b\n> end\n>\n> add 1, 2\n=> 3\n如果你对 Scheme 熟悉，上面的代码还能像下面这么写，是不是很亲切\n> (def add a, b\n>     a + b\n> end)\n\n> (add 1, 2)\n=> 3\n这也就是充分说明，括号在 ruby 中只是起到了“分割”的作用，并没有什么语法含义。\n面向对象\n面向对象主要的核心是用对象来达到数据封装的目的。\n\njavascript 基于原型链实现面向对象，更详细的介绍可以参考《javascript中的面向对象编程》\npython、ruby 基于类来实现面向对象，和 java 类似，但是更纯粹些。\n\n$ python\n>>> def func(): return 1\n>>> type(func)\n<type 'function'>\n>>> func2 = lambda x: x\n>>> type(func2)\n<type 'function'>\n>>> type(1)\n<type 'int'>\n>>> dir(1)\n['__abs__', '__add__', .....]\n#--------------------------------------------------#\n$ irb\n> def add(a, b)\n>    a + b\n> end\n> method(:add)\n=> #<Method: Object#add>\n# 上面 ruby 的例子中，使用了 Symbol 来表示 add 方法，这是由于 ruby 中直接写 add 表示函数调用\n> 1.methods\n=> [:%, :&, :*, :+, :-, :/, .....]\n可以看到，在 python、ruby 中，像1这样的数字字面量也是对象。\nlambda 表达式\nlambda 表达式表示的是匿名函数，也就是我们通常说的闭包。由于在这三门语言中，函数均是一等成员，所以可以很方便的进行函数式编程\n$ node\n> [1,2,3].map((x) => x + 1)\n[ 2, 3, 4 ]\n#--------------------------------------------------#\n$ python\n>>> map(lambda x: x+1, [1,2,3])\n[2, 3, 4]\n#--------------------------------------------------#\n$ irb\n> [1,2,3].map &(lambda {|x| x+1})\n => [2, 3, 4]\nPython 的 lambda 表达式是这三者中最弱的一个，只能包含一个表达式，javascript 与 ruby 的则没有这种限制。\n细心的读者会发现上面 ruby 版本的 lambda 前有个&，这是必须的，否则会报下面的错误\nArgumentError: wrong number of arguments (given 1, expected 0)\n这是因为在 ruby 中，方法除了接受参数外，还可以接受一个代码块(block)，代码块在 ruby 中有两种写法：\n\n一行的话用{}\n多行的话用do ... end\n\n> [1,2,3].each { |num| print \"#{num}! \" }\n1! 2! 3!\n=>[1,2,3]\n> [1,2,3].each do |num|\n>    print \"#{num}!\"\n> end\n1! 2! 3!\n =>[1,2,3]         # Identical to the first case.\n& 的作用是告诉解释器，现在传入的不是正常的参数，而是一个代码块。这个传入的代码块在方法内通过yield进行调用。这里可以做个演示：\nclass Array\n  def my_each\n    i = 0\n    while i < self.size\n        yield(self[i])  \n        i+=1      \n    end\n    self\n  end\nend\n\n> [1,2,3].my_each { |num| print \"#{num}!\" }\n1! 2! 3!\n=> [1,2,3]\nRuby 中 lambda 表达式属于 Proc 类型，\n> lambda {|x| x}.class\n=> Proc\n这里可以看到，只是对于闭包的支持，Ruby 就提供了多种方案。更多可以参考：\n\nRuby Explained: Blocks, Procs, and Lambdas, aka \"Closures\"\nWeird Ruby Part 4: Code Pods (Blocks, Procs, and Lambdas)\n\nyield\n就像上面说的，ruby 中 yield 就是表示代码块的调用，没有其他含义。而在 python 与 javascript yield 是用来构造生成器（generator）的，都是用来控制程序运行流程，相当于用户态的“线程”：\n$ python\ndef iter():\n    for x in xrange(10):\n        yield x\n\nfoo = iter()\nprint next(foo)\nprint next(foo)\n#--------------------------------------------------#\n\n$ node\nfunction* iter() {\n for (var i = 0; i < 10; i++)\n    yield i\n}\nvar foo = iter()\nconsole.log(foo.next().value)\nconsole.log(foo.next().value)\n\n上面两份代码都依次打印出0, 1。\n关于生成器的更多资料，可以参考：\n\nGenerators in Node.js: Common Misconceptions and Three Good Use Cases\nMore details on Python generators and coroutines（强烈推荐 Python 读者看）\n\n在 ruby 中，与生成器对应的概念是 Fiber，例如：\niter = Fiber.new do\n  (0..10).each do |x|\n    Fiber.yield x\n  end\nend\n\nputs iter.resume\nputs iter.resume\n上面的代码也依次打印出0, 1。\n关于生成器与 Fiber 的关系，可以参考：\n\nOverview of Modern Concurrency and Parallelism Concepts （需翻墙，强烈推荐读者看）\nhttp://merbist.com/2011/02/22/concurrenc...\n\n其实，生成器、Fiber 以及相关概念背后的理论基础是 continuation，continuation 的应用场景非常广泛，各种编程语言中的异常处理也是基于它来实现的。鉴于这个话题比较大，这里不再展开叙述，感兴趣的读者可以参考这篇文章，后面我也会单独再写一篇文章进行介绍。这里仅仅给出 continuation 的一个简单示例以飨读者：\n; Scheme 语言中没有 return 语句，利用 continuation 可以模拟 return\n(define (f return)\n  (return 2)\n  3)\n\n(display (f (lambda (x) x))) ; displays 3\n(display (call-with-current-continuation f)) ; displays 2\n关于这里例子详细的解释可以参考WIKI Call-with-current-continuation。\n字符串\n不可变性\n字符串作为对字符的一种抽象，在大部分语言实现中都是不可变对象。在 Python 可以通过id()函数证明，在 Ruby 中可以通过__id__ 函数证明，javascript 中无类似方法。\n$ python\n>>> str = 'a'\n>>> id(str)\n4351841824\n>>> str = 'b'\n>>> id(str)\n4351841864\n#------------------------------#\n$ irb\n> str = 'a'\n> str.__id__\n=> 70116314615020\n> str = 'b'\n> str.__id__\n=> 70116318601060\n拼接\n大多数语言都可以直接通过+进行字符串的拼接，但是这样做既不优雅，效率也低，所以一些语言会有些替代方案。Ruby 与 Python 中对这块的支持比较强大，ES6 中借鉴了以上两门语言的语法，引入了 template_string，这在极大程度上方便了字符串的拼接。\n$ node\n> var a = 5;\n> var b = 10;\n> console.log(`Fifteen is ${a + b} and\\nnot ${2 * a + b}.`);\n// \"Fifteen is 15 and\n// not 20.\"\n#--------------------------------------------------#\n$ python\n> long_string = \"\"\"\n> my name is {username},\n> my age is {age}\n> \"\"\".format(username=\"zhangsan\", age=10)\n#--------------------------------------------------#\n$ irb\n> long_string = \"\"\"\n> my name is %{username},\n> my age is %{age}\n> \"\"\" % {username: \"zhangsan\", age:10}\n查看值类型\n动态语言最主要的特点就是变量无类型，利用反射机制可以查看运行时变量的值的类型。\n$ node\n> str = \"hello world\"\n> typeof str     \n'string'\n#------------------------------#\n$ irb\n> str = \"hello world\"\n> str.class\nString\n#------------------------------#\n$ python\n> str = \"hello world\"\n> type(str)\n<type 'str'>\n包管理\n\nPython，PyPI，多版本兼容推荐使用 virtualenv 管理\nRuby， GEMS，多版本兼容，推荐使用 rvm + bundler 管理\nNode.js，由于 Node.js 出现较晚，它避免了Python、Ruby 包全局污染的问题，而是选择将第三份模块安装在项目内的node_modules文件夹内\n\n总结\n经过上面简短的介绍，我相信大家对这三门语言有了全面的理解，多了解一门语言，也就是多个解决问题的思路。\n个人感觉，Python、Javascript 的语法比较中规中矩，适合大部分程序员学习。Ruby 更适合 geek 去学，因为它的很多奇特语法会让你思考语言的设计细节，而不仅仅是使用这么简单。\n最近我在看Ruby元编程，里面的很多内容就很有意思，一些内容在看 SICP 时就已经遇到，这种似曾相识的感觉很棒，我相信对编程语言的了解又加深了一步。谢谢 Yukihiro Matsumoto大叔，带给我们 ruby 这么美妙的语言。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "13"}