{"title": "这些函数简直是屌爆了 - 个人文章 ", "index": "函数,python", "content": "这篇文章我们来看几个很有用的 Python 内置函数 。这些函数简直是屌爆了，我认为每个 Pythoner 都应该知道这些函数。\n对于每个函数，我会使用一个普通的实现来和内置函数做对比。\n如果我直接引用了内置函数的文档，请理解，因为这些函数文档写的非常棒！\nall(iterable)\n如果可迭代的对象(数组，字符串，列表等，下同)中的元素都是 true (或者为空)的话返回 True 。\n_all = True\nfor item in iterable:\n    if not item:\n        _all = False\n        break\nif _all:\n    # do stuff\n\n更简便的写法是：\nif all(iterable):\n    # do stuff\nany(iterable)\n\n如果可迭代的对象中任何一个元素为 true 的话返回 True 。如果可迭代的对象为空则返回 False 。\n_any = False\nfor item in iterable:\n    if item:\n        _any = True\n        break\nif _any:\n    # do stuff\n\n更简便的写法是：\nif any(iterable):\n    # do stuff\ncmp(x, y)\n\n比较两个对象 x 和 y 。 x < y 的时候返回负数， x ==y 的时候返回 0， x > y 的时候返回正数。\ndef compare(x,y):\n    if x < y:\n        return -1\n    elif x == y:\n        return 0\n    else:\n        return 1\n\n你完全可以使用一句 cmp(x, y) 来替代。\ndict([arg])\n使用 arg 提供的条目生成一个新的字典。\narg 通常是未知的，但是它很方便！比如说，如果我们想把一个含两个元组的列表转换成一个字典，我们可以这么做。\nl = [('Knights', 'Ni'), ('Monty', 'Python'), ('SPAM', 'SPAAAM')]\nd = dict()\nfor tuple in l:\n    d[tuple[0]] = tuple[1]\n# {'Knights': 'Ni', 'Monty': 'Python', 'SPAM': 'SPAAAM'}\n\n或者这样：\nl = [('Knights', 'Ni'), ('Monty', 'Python'), ('SPAM', 'SPAAAM')]\nd = dict(l) # {'Knights': 'Ni', 'Monty': 'Python', 'SPAM': 'SPAAAM'}\nenumerate(iterable [,start=0])\n\n我真的是超级喜欢这个！如果你以前写过 C 语言，那么你可能会这么写：\nfor i in range(len(list)):\n    # do stuff with list[i], for example, print it\n    print i, list[i]\n\n噢，不用那么麻烦！你可以使用 enumerate() 来提高可读性。\nfor i, item in enumerate(list):\n    # so stuff with item, for example print it\n    print i, item\nisinstance(object, classinfo)\n\n如果 object 参数是 classinfo 参数的一个实例或者子类(直接或者间接)的话返回 True 。\n当你想检验一个对象的类型的时候，第一个想到的应该是使用 type() 函数。\nif type(obj) == type(dict):\n    # do stuff\nelif type(obj) == type(list):\n    # do other stuff\n...\n\n或者你可以这么写：\nif isinstance(obj, dict):\n    # do stuff\nelif isinstance(obj, list):\n    # do other stuff\n...\npow(x, y [,z])\n\n返回 x 的 y 次幂(如果 z 存在的话则以 z 为模)。\n如果你想计算 x 的 y 次方，以 z 为模，那么你可以这么写：\nmod = (x ** y) % z\n\n但是当 x=1234567， y=4567676， z=56 的时候我的电脑足足跑了 64 秒！\n不要用 ** 和 % 了，使用 pow(x, y, z) 吧！这个例子可以写成 pow(1234567, 4567676, 56) ，只用了 0.034 秒就出了结果！\nzip([iterable, ])\n这个函数返回一个含元组的列表，具体请看例子。\nl1 = ('You gotta', 'the')\nl2 = ('love', 'built-in')\nout = []\nif len(l1) == len(l2):\n    for i in range(len(l1)):\n        out.append((l1[i], l2[i]))\n# out = [('You gotta', 'love'), ('the', 'built-in)]\n\n或者这么写：\nl1 = ['You gotta', 'the']\nl2 = ['love', 'built-in']\nout = zip(l1, l2) # [('You gotta', 'love'), ('the', 'built-in)]\n\n如果你想得到倒序的话加上 * 操作符就可以了。\nprint zip(*out)\n# [('You gotta', 'the'), ('love', 'built-in')]\n\n结论\nPython 内置函数很方便，它们很快并且经过了优化，所以它们可能效率更高。\n我真心认为每个 Python 开发者都应该好好看看内置函数的文档(引言部分)。\n忘了说了，在 itertools 模块中有很多很不错的函数。再说一次，它们确实屌爆了。\n觉得文章还不错的朋友可以点赞收藏哦，主页有惊喜~\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}