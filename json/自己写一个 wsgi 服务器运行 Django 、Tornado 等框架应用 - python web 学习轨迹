{"title": "自己写一个 wsgi 服务器运行 Django 、Tornado 等框架应用 - python web 学习轨迹 ", "index": "wsgi,tornado,django,flask,python", "content": "前几天写了 浅谈cgi、wsgi、uwsgi 与 uWSGI 等一些 python web 开发中遇到的一些名词的理解，今天博主就根据 wsgi 标准实现一个 web server，并尝试用它来跑 Django、tornado 框架的 app。\n编写一个简单的 http server\n在实现 wsgi server 之前我们先要做一些准备工作。首先，http server 使用 http 协议，而 http  协议封装在 tcp 协议中，所以要建立一个 http server 我们先要建立一个 tcp server。要使用 tcp 协议我们不可能自己实现一个，现在比较流行的解决方案就是使用 socket 套接字编程， socket 已经帮我们实现了 tcp 协议的细节，我们可以直接拿来使用不用关心细节。 socket 编程是语言无关的，不管是以前博主用 MFC 写聊天室还是用 C# 写网络延迟计算还是现在写 http server，它的使用流程都是一样的：\nserver\n\n初始化 socket；\n绑定套接字到端口(bind)；\n监听端口(listen)；\n接受连接请求(accept)；\n通信(send/recv)；\n关闭连接(close)；\n\nclient\n\n初始化 socket；\n发出连接请求(connect)；\n通信(send/recv)；\n关闭连接(close)；\n\nserver 的具体实现：\n# coding: utf-8\n# server.py\n\nimport socket\n\nHOST, PORT = '', 8888\n# 初始化\nlisten_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nlisten_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n# 绑定\nlisten_socket.bind((HOST, PORT))\n# 监听\nlisten_socket.listen(1)\nprint 'Serving HTTP on port %s ...' % PORT\nwhile True:\n    # 接受请求\n    client_connection, client_address = listen_socket.accept()\n    # 通信\n    request = client_connection.recv(1024)\n    print request\n \n    http_response = \"\"\"\nHTTP/1.1 200 OK\n \nHello, World!\n\"\"\"\n    client_connection.sendall(http_response)\n    # 关闭连接\n    client_connection.close()\n而 client 不需要我们自己实现，我们的浏览器就是一个 client ，现在运行python server.py，然后在浏览器中打开 localhost:8888即可看到浏览器中显示 hello world!，这么快就实现了一个 http server 有木有 hin 激动！\n然而想要 Django 这类框架的 app 在我们写的 http server 中运行起来还远远不够，现在我们就需要引入 wsgi 规范，根据这个规范我们就可以让自己的 server 也能运行这些框架的 app啦。\n编写一个标准的 wsgi server\n首先，我们要看官方文档里 wsgi 的解释：PEP 3333嗯，就是一篇很长的英语阅读理解，大概意思就是如果你想让你的服务器和应用程序一起好好工作，你要遵循这个标准来写你的 web app 和 web server：\nserver--middleware--application\napplication\napplication 是一个接受接受两个参数environ, start_response的标准 wsgi app:\nenviron:          一个包含请求信息及环境信息的字典，server 端会详细说明\nstart_response:   一个接受两个参数`status, response_headers`的方法:\nstatus:           返回状态码，如http 200、404等\nresponse_headers: 返回信息头部列表\n具体实现：\ndef application(environ, start_response):\n    status = '200 OK'\n    response_headers = [('Content-Type', 'text/plain')]\n    start_response(status, response_headers)\n    return ['Hello world']\n\n这样一个标准的 wsgi app 就写好了，虽然这看上去和我们写的 Django app、 tornado app 大相径庭，但实际上这些 app 都会经过相应的处理来适配 wsgi 标准，这个之后会详谈。\nserver\nwsgi server 的实现要复杂一些，所以我先贴自己实现的 wsgi server 代码，然后再讲解：\n# server.py\n# coding: utf-8\nfrom __future__ import unicode_literals\n\nimport socket\nimport StringIO\nimport sys\nimport datetime\n\n\nclass WSGIServer(object):\n    socket_family = socket.AF_INET\n    socket_type = socket.SOCK_STREAM\n    request_queue_size = 10\n\n    def __init__(self, address):\n        self.socket = socket.socket(self.socket_family, self.socket_type)\n        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        self.socket.bind(address)\n        self.socket.listen(self.request_queue_size)\n        host, port = self.socket.getsockname()[:2]\n        self.host = host\n        self.port = port\n\n    def set_application(self, application):\n        self.application = application\n\n    def serve_forever(self):\n        while 1:\n            self.connection, client_address = self.socket.accept()\n            self.handle_request()\n\n    def handle_request(self):\n        self.request_data = self.connection.recv(1024)\n        self.request_lines = self.request_data.splitlines()\n        try:\n            self.get_url_parameter()\n            env = self.get_environ()\n            app_data = self.application(env, self.start_response)\n            self.finish_response(app_data)\n            print '[{0}] \"{1}\" {2}'.format(datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'),\n                                           self.request_lines[0], self.status)\n        except Exception, e:\n            pass\n\n    def get_url_parameter(self):\n        self.request_dict = {'Path': self.request_lines[0]}\n        for itm in self.request_lines[1:]:\n            if ':' in itm:\n                self.request_dict[itm.split(':')[0]] = itm.split(':')[1]\n        self.request_method, self.path, self.request_version = self.request_dict.get('Path').split()\n\n    def get_environ(self):\n        env = {\n            'wsgi.version': (1, 0),\n            'wsgi.url_scheme': 'http',\n            'wsgi.input': StringIO.StringIO(self.request_data),\n            'wsgi.errors': sys.stderr,\n            'wsgi.multithread': False,\n            'wsgi.multiprocess': False,\n            'wsgi.run_once': False,\n            'REQUEST_METHOD': self.request_method,\n            'PATH_INFO': self.path,\n            'SERVER_NAME': self.host,\n            'SERVER_PORT': self.port,\n            'USER_AGENT': self.request_dict.get('User-Agent')\n        }\n        return env\n\n    def start_response(self, status, response_headers):\n        headers = [\n            ('Date', datetime.datetime.now().strftime('%a, %d %b %Y %H:%M:%S GMT')),\n            ('Server', 'RAPOWSGI0.1'),\n        ]\n        self.headers = response_headers + headers\n        self.status = status\n\n    def finish_response(self, app_data):\n        try:\n            response = 'HTTP/1.1 {status}\\r\\n'.format(status=self.status)\n            for header in self.headers:\n                response += '{0}: {1}\\r\\n'.format(*header)\n            response += '\\r\\n'\n            for data in app_data:\n                response += data\n            self.connection.sendall(response)\n        finally:\n            self.connection.close()\n\n\nif __name__ == '__main__':\n    port = 8888\n    if len(sys.argv) < 2:\n        sys.exit('请提供可用的wsgi应用程序, 格式为: 模块名.应用名 端口号')\n    elif len(sys.argv) > 2:\n        port = sys.argv[2]\n\n\n    def generate_server(address, application):\n        server = WSGIServer(address)\n        server.set_application(TestMiddle(application))\n        return server\n\n\n    app_path = sys.argv[1]\n    module, application = app_path.split('.')\n    module = __import__(module)\n    application = getattr(module, application)\n    httpd = generate_server(('', int(port)), application)\n    print 'RAPOWSGI Server Serving HTTP service on port {0}'.format(port)\n    print '{0}'.format(datetime.datetime.now().\n                       strftime('%a, %d %b %Y %H:%M:%S GMT'))\n    httpd.serve_forever()\n\n首先我们看 WSGIServer 类__init__方法主要是初始化 socket 与服务器地址，绑定并监听端口;其次，serve_forever(self): 持续运行 server；handle_request(self):处理请求；最后，finish_response(self, app_data):返回请求响应。再来看__main__里是如何运行 WSGIServer的：获得地址和端口后先初始化 WSGIServer：server = WSGIServer(address)，然后设置加载的wsgi app：server.set_application(TestMiddle(application))，接着持续运行 server：httpd.serve_forever()那么根据以上信息，可以总结出 wsgi server 应该是这样一个过程：\n\n初始化，建立套接字，绑定监听端口；\n设置加载的 web app；\n开始持续运行 server；\n处理访问请求（在这里可以加入你自己的处理过程，比如我加入了打印访问信息，字典化访问头部信息等功能）；\n获取请求信息及环境信息（get_environ(self)）；\n用environ运行加载的 web app 得到返回信息；\n构造返回信息头部；\n返回信息；\n\n只要实现了以上过程，一个标准的 wsgi server 就写好了。仔细观察，其实一个 wsgi server 的重要之处就在于用environ去跑 web app 得到返回结果这一步，这一步和前面的 application 实现相辅相成，然后框架和服务器都根据这套标准，大家就可以愉快的一起工作了。现在运行python server.py app.app 8000, 然后浏览器访问localhost:8000：后端浏览器\n到此，我们的 wsgi server 已经可以正常运行了，这时我们再来看看 middleware：\nmiddleware\nmiddleware 中间件的作用就是在server 拿到请求数据给 application 前如果想做一些处理或者验证等等功能，这时候 middleware 就派上用场了，当然你愿意的话也可以写在你的 server 里，只是 wsgi 规范更建议把这些写在中间件里，下面我来实现一个检查请求'User-Agent'是否为正常浏览器，不是就把请求拒绝掉的中间件：\n# coding: utf-8\n# middleware.py\nfrom __future__ import unicode_literals\n\n\nclass TestMiddle(object):\n    def __init__(self, application):\n        self.application = application\n\n    def __call__(self, environ, start_response):\n        if 'postman' in environ.get('USER_AGENT'):\n            start_response('403 Not Allowed', [])\n            return ['not allowed!']\n        return self.application(environ, start_response)\n\n初始化用来接收 application，然后在__call__方法里写入处理过程，最后返回 application 这样我们的中间件就能像函数一样被调用了。\n然后引入中间件：\nfrom middleware import TestMiddle\n\n...\n\nserver.set_application(TestMiddle(application))\n现在重启 server 然后用 postman 访问服务器：可以看到，中间件起作用了！\n接下来，我们再谈谈 Django 和 tornado 对于 wsgi 的支持：\nDjango WSGI:\nDjango WSGI application\ndjango 本身的应用体系比较复杂，所以没有办法直接拿来用在我们写的 wsgi server 上，不过 Django 考虑到了这一点， 所以提供了 WSGIHandler：\nclass WSGIHandler(base.BaseHandler):\n    request_class = WSGIRequest\n\n    def __init__(self, *args, **kwargs):\n        super(WSGIHandler, self).__init__(*args, **kwargs)\n        self.load_middleware()\n\n    def __call__(self, environ, start_response):\n        set_script_prefix(get_script_name(environ))\n        signals.request_started.send(sender=self.__class__, environ=environ)\n        try:\n            request = self.request_class(environ)\n        except UnicodeDecodeError:\n            logger.warning(\n                'Bad Request (UnicodeDecodeError)',\n                exc_info=sys.exc_info(),\n                extra={\n                    'status_code': 400,\n                }\n            )\n            response = http.HttpResponseBadRequest()\n        else:\n            response = self.get_response(request)\n\n        response._handler_class = self.__class__\n\n        status = '%d %s' % (response.status_code, response.reason_phrase)\n        response_headers = [(str(k), str(v)) for k, v in response.items()]\n        for c in response.cookies.values():\n            response_headers.append((str('Set-Cookie'), str(c.output(header=''))))\n        start_response(force_str(status), response_headers)\n        if getattr(response, 'file_to_stream', None) is not None and environ.get('wsgi.file_wrapper'):\n            response = environ['wsgi.file_wrapper'](response.file_to_stream)\n        return response\n可以看到，这里 WSGIHandler 一样使用start_response(force_str(status), response_headers)把 Django app 封装成了 标准 wsgi app ，然后返回 response。\nDjango WSGI server\nDjango 同样也实现了 wsgi server：\nclass WSGIServer(simple_server.WSGIServer, object):\n    \"\"\"BaseHTTPServer that implements the Python WSGI protocol\"\"\"\n\n    request_queue_size = 10\n\n    def __init__(self, *args, **kwargs):\n        if kwargs.pop('ipv6', False):\n            self.address_family = socket.AF_INET6\n        self.allow_reuse_address = kwargs.pop('allow_reuse_address', True)\n        super(WSGIServer, self).__init__(*args, **kwargs)\n\n    def server_bind(self):\n        \"\"\"Override server_bind to store the server name.\"\"\"\n        super(WSGIServer, self).server_bind()\n        self.setup_environ()\n\n    def handle_error(self, request, client_address):\n        if is_broken_pipe_error():\n            logger.info(\"- Broken pipe from %s\\n\", client_address)\n        else:\n            super(WSGIServer, self).handle_error(request, client_address)\n基本全部继承于wsgiref.simple_server.WSGIServer:\nclass WSGIServer(HTTPServer):\n\n    \"\"\"BaseHTTPServer that implements the Python WSGI protocol\"\"\"\n\n    application = None\n\n    def server_bind(self):\n        \"\"\"Override server_bind to store the server name.\"\"\"\n        HTTPServer.server_bind(self)\n        self.setup_environ()\n\n    def setup_environ(self):\n        # Set up base environment\n        env = self.base_environ = {}\n        env['SERVER_NAME'] = self.server_name\n        env['GATEWAY_INTERFACE'] = 'CGI/1.1'\n        env['SERVER_PORT'] = str(self.server_port)\n        env['REMOTE_HOST']=''\n        env['CONTENT_LENGTH']=''\n        env['SCRIPT_NAME'] = ''\n\n    def get_app(self):\n        return self.application\n\n    def set_app(self,application):\n        self.application = application\n可以看到，和我们实现的 wsgi server 是差不多的。\nTornado WSGI\ntornado 直接从底层用 epoll 自己实现了 事件池操作、tcp server、http server，所以它是一个完全不同当异步框架，但 tornado 同样也提供了对 wsgi 对支持，不过这种情况下就没办法用 tornado 异步的特性了。\n与其说 tornado 提供了 wsgi 支持，不如说它只是提供了 wsgi 兼容，tornado 提供两种方式：\nWSGIContainer\n其他应用要在 tornado server 运行， tornado 提供 WSGIContainer。今天这里主要讨论 wsgi ，所以这里就不分析 tornado 这部分代码，之后做 tornado 源码分析会再分析这里。\nWSGIAdapter\ntornado 应用要在 wsgi server 上运行， tornado 提供 WSGIAdapter:\nclass WSGIAdapter(object):\n    def __init__(self, application):\n        if isinstance(application, WSGIApplication):\n            self.application = lambda request: web.Application.__call__(\n                application, request)\n        else:\n            self.application = application\n\n    def __call__(self, environ, start_response):\n        method = environ[\"REQUEST_METHOD\"]\n        uri = urllib_parse.quote(from_wsgi_str(environ.get(\"SCRIPT_NAME\", \"\")))\n        uri += urllib_parse.quote(from_wsgi_str(environ.get(\"PATH_INFO\", \"\")))\n        if environ.get(\"QUERY_STRING\"):\n            uri += \"?\" + environ[\"QUERY_STRING\"]\n        headers = httputil.HTTPHeaders()\n        if environ.get(\"CONTENT_TYPE\"):\n            headers[\"Content-Type\"] = environ[\"CONTENT_TYPE\"]\n        if environ.get(\"CONTENT_LENGTH\"):\n            headers[\"Content-Length\"] = environ[\"CONTENT_LENGTH\"]\n        for key in environ:\n            if key.startswith(\"HTTP_\"):\n                headers[key[5:].replace(\"_\", \"-\")] = environ[key]\n        if headers.get(\"Content-Length\"):\n            body = environ[\"wsgi.input\"].read(\n                int(headers[\"Content-Length\"]))\n        else:\n            body = b\"\"\n        protocol = environ[\"wsgi.url_scheme\"]\n        remote_ip = environ.get(\"REMOTE_ADDR\", \"\")\n        if environ.get(\"HTTP_HOST\"):\n            host = environ[\"HTTP_HOST\"]\n        else:\n            host = environ[\"SERVER_NAME\"]\n        connection = _WSGIConnection(method, start_response,\n                                     _WSGIRequestContext(remote_ip, protocol))\n        request = httputil.HTTPServerRequest(\n            method, uri, \"HTTP/1.1\", headers=headers, body=body,\n            host=host, connection=connection)\n        request._parse_body()\n        self.application(request)\n        if connection._error:\n            raise connection._error\n        if not connection._finished:\n            raise Exception(\"request did not finish synchronously\")\n        return connection._write_buffer\n\n可以看到 tornado 也是将自己的应用使用前文那个流程改为标准 wsgi app，最后我们来试试让我们自己的服务器运行 tornado app：\n# coding: utf-8\n# tornado_wsgi.py\n\nfrom __future__ import unicode_literals\n\nimport datetime\nimport tornado.web\nimport tornado.wsgi\n\nfrom middleware import TestMiddle\nfrom server import WSGIServer\n\n\nclass MainHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.write(\"this is a tornado wsgi application\")\n\n\nif __name__ == \"__main__\":\n    application = tornado.web.Application([\n        (r\"/\", MainHandler),\n    ])\n    wsgi_app = tornado.wsgi.WSGIAdapter(application)\n    server = WSGIServer(('', 9090))\n    server.set_application(TestMiddle(wsgi_app))\n    print 'RAPOWSGI Server Serving HTTP service on port {0}'.format(9090)\n    print '{0}'.format(datetime.datetime.now().\n                       strftime('%a, %d %b %Y %H:%M:%S GMT'))\n    server.serve_forever()\n运行：python tornado_wsgi.py，打开浏览器：localhost:9090，完美运行，中间件也运行正常：\n文中代码源码：simple_wsgi_server参考资料：Let’s Build A Web Server\n原文地址\n作者：rapospectre\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "31"}