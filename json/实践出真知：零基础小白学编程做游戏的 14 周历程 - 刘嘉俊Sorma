{"title": "实践出真知：零基础小白学编程做游戏的 14 周历程 - 刘嘉俊Sorma ", "index": "零基础,新手,python,游戏", "content": "人人都应该学编程吗？随着每个人的工作与电脑连结愈发紧密，也许这是真的。\n\n我是游戏设计师，在分工细致的国内网游业界，不需要研发或美术背景也能担当游戏设计重任的角色多了起来。有时候他们甚至只需负责撰写剧情文档或游戏文案，一切涉及程序的工作内容都有开发同学代为解决。不离开自己的 comfort zone 也能很好地完成任务。\n\n但在本职之外，了解程序如何工作，能带来许多好处：日常工作中重复的工序可以自行使用程序解决；易犯的错误可以通过程序避免；更不用提编写脚本的能力，能够让你直接控制你所设计的内容的每个细节，了解设计的边界及内部空间。\n\n毕竟，太初之时，只有程序。程序员想：「专职美术、策划、设计、产品经理是好的。」便有了他们一干人等。\n\n\n「每周一游」：每个星期快速开发一个游戏，连续进行数个星期。这是许多开发者们磨练自己想法和技巧的方式。\n\n我没有计算机背景或美术基础，但乘中国游戏行业大发展，却也幸运入行成为一名游戏策划。我希望在日常工作之余，用一个办法来锻炼自己对游戏系统设计和开发过程的理解。因此，我参加了 Coursera 上的几个课程，并且用课程提供的方便工具来实现设想中的功能。\n\n一开始的成果非常基本、非常简单，但到后面挑战等级逐渐上升，到最后已经能独立完成 600 行左右的程序。\n\n接下来我就给各位看看我在这近四个月中的成果，以及我从中学习和体会到的内容。我尽量省略比较枯燥的实现细节，一来可以避免无聊，二来需要下功夫的东西还是亲手实践比较有帮助。如有兴趣可来我的微博交流。\n\n第一周：包剪锤蜥史波克（Rock-paper-scissors-lizard-Spock）\n\n\nSheldon 喜欢的游戏。\n\n\n\n谢耳朵爱玩的游戏，石头剪子布的升级版。内容最最基本，只要在控制台里输入命令，命令通过 if-elif-else 转化成数字（0-4，分别代表出的5个东西）。\n\n电脑则会随机生成一个数字，转换成字符串。再根据双方数字，用 if-else 判断胜负即可。\n\n对我来说这是自己亲手编写的第一个游戏。它虽然简单，但包含了一个游戏必须的全部要素：它有着固定的开始和结束，以及胜负的规则。\n\n第二周：猜数字\n\n\n\n猜数字游戏就是由电脑随机生成指定范围内的一个数字，由你来猜，电脑告诉你是高还是低，一定次数后未猜中则输掉的游戏。\n\n在这个游戏中第一次引入全局变量的概念。初始化时，上下限以及允许你猜测的次数都是读取全局变量。这样一来，我们可以在游戏核心的方法之外，使用别的方法来修改全局变量，让玩家可以自己选择数字范围和猜测次数。游戏本身则依然是 if-elif-else 这样写成的。\n\n这是我亲手编写的第一个可以由玩家调整游戏设置的游戏。\n\n第三周：秒表游戏\n\n\n\n秒表游戏是个考反应的游戏。点击开始后秒表开始向前走，若你按停秒表时，秒表的时间恰巧停在整数（小数点后为0），则你得1分。游戏会记录你按停的总次数和得分数。\n\n这个游戏中涉及到为每个功能编写单独的方法。如玩家控制的按钮start()、stop()、reset()；游戏本身时间前进的tick()等。同时，为了让时间正确地显示在屏幕上，还有一个将时间转化为「A:BC:D」这种形式的方法。\n\n我们计时的方法是定义一个叫 time 的变量。由于这个游戏中最小的计时单位是 0.1 秒，所以每经过 100 毫秒我们就让这个数字 +1。与此同时，编写一个 format() 方法经过一系列计算将这个数字转化为分、秒和0.1秒，显示在屏幕上即可。判断玩家是否得分仍然使用 if-else 结构。\n\n这是第一次涉及到玩家进行的复杂操作，也是第一次认识到，在游戏画面的表象之下究竟应该有些什么机制在运行。\n\n第四周：乒乓（Pong）\n\n\n\n终于我们从小朋友玩的游戏进入了街机时代！\n\n传说 Pong 是世界上第一个电子游戏。在那个游戏机只有滚轴操作的年代，这个有着极简单画面的游戏启发了无限后来者。看着它在手下形成还有些小感动呢。\n\n这个游戏也是我制作的第一个不模拟现实中的「逻辑」，而是模拟「物理」的游戏。它的核心部分是球的速度变化、板子的速度变化，以及球与边界和板子的碰撞。\n\n为了让这个游戏不至于无限地进行下去，我让球的速度随着每一次板子碰撞上升。但上升的公式写成了指数函数，于是这球就啪啪啪越打越快每一回合很快就结束了。若改为对数函数，则会缓慢地趋近一个上限，令每一回合后期的双人对局非常紧张、充满变数。\n\n这是我第一次体会到游戏的「手感」到底是怎么回事。每一次对参数的细微调整对手感带来的变化，可以让设计者与游戏本身有着更深刻的接触。这是在目前分工充分的网游公司的日常工作中体会不到的感觉。\n\n除此之外，很快地你就能从一个简单原型中看出未来变化的可能。是否可以加入：\n\n\n「球击打在板子的不同部位，会弹向不同方向」？\n「当板子击球时，板子本身的速度会令球曲线飞出」？\n或者「连续击中球数次后玩家可以发出大招」？\n\n等等诸如此类。想到这里，这个游戏能成为数十年游戏业的起点，也是有其道理的。\n\n第五周：记忆游戏\n\n\n\n记忆游戏就是将多对牌打乱顺序朝下放置，玩家一次翻开两张，若相同则原样留着，若不同则翻回去。所有牌都翻开后玩家胜利。\n\n在这个游戏中，暂且用数字来代替扑克牌。我们用了一个 list （我有点搞不太清 list, array, tuple, set 几个词的中文翻译，不乱讲了……）来以 Boolean 值（True 和 False）记录每张牌是否翻开的状态。当设为翻开时，露出数字，否则在相应位置绘制一张牌背。\n\n这个游戏的逻辑方面比较 tricky 的地方就是整个游戏实际上有三种状态，需要分别处理：\n\n\n新游戏，一张牌都没翻开\n翻开了（本回合内）第一张牌，等待翻开第二张\n翻开了（本回合内）第二张牌，等待判断是否相同\n\n于是我使用一个叫做 state 的变量，分别以 0, 1, 2 代表三种状态。在核心方法中利用 state 的值来决定接下来要做什么。\n\n第六周：21点（Blackjack）\n\n\n\n啊，21 点。我人生中接触的第一个扑克游戏。是的，在我会打「拖拉机」之前，7岁的我就在DOS下的初代大航海时代的酒馆里学会了 21 点。这是年幼的我在那个游戏里玩懂的唯一一个系统……\n\n这是个赌博游戏。简单来说规则是：庄家给自己和玩家各发(deal)一张暗牌、一张明牌，玩家决定是否继续加牌(hit)；玩家加牌结束(stand)后庄家自行加牌，接着双方摊牌。拥有最高点数的玩家获胜，其点数必须等于或低于21点。\n\n在编写这个游戏的过程中第一次引入了类(class)概念。因为在游戏中许多物件都会重复出现，使用类可以很方便地重复制造它们：\n\n\n每一张牌是 Class Card；\n方法 get_suit() 可以获取它的花色；\n方法 get_rank() 可以获取它的数字；\n还有一个方法来把它绘制出来。\n\n\n手牌是 Class Hand；\n方法 add_card() 可以在手牌中增加一张牌；\n方法 get_value() 可以算出手牌的分数。\n\n\n牌库则是 Class Deck。\n方法 shuffle() 可以洗牌库；\n方法 deal_card() 用来发牌。\n\n\n\n规定好这些基础方法以后，重发牌、加牌、摊牌都可以通过这些功能的组合来实现。例如开局就是洗牌库，向双方发牌；双方手牌加上两张发出来的牌。等等。\n\n此外这个游戏还第一次涉及到怎样在画面上绘制固定的图形。整张牌表是一张大图，怎么样根据牌的值定位到对应的牌面也是要好好算一下。\n\n第七周：小行星（Asteroid）\n\n\n\n经典街机游戏的复刻版！大制作来临了！\n\n这回的游戏涉及的内容比以前多，除了控制小飞船打来打去之外，动画、音效、UI 等也都引入了游戏中。但每一部分的实现都可以通过之前尝试的小功能叠加实现。简单地了解游戏图像和声音到底怎么运作后，并无特别的困难。只是这一次我学着一个模块一个模块渐次开发和测试，一个功能调通无误，再进行下一个。\n\n反而是在游戏设计方面，制作这个游戏的过程给我带来很多思考。在这个游戏中可供调整的变量太多了：飞船需要推进和旋转；但推进是给飞船一个向前的加速度，而飞船本身还会有向着其他方向的速度。宇宙空间中微小的摩擦力、和陨石撞击后受到的力，都要考虑并且编入游戏中。\n\n这时你会发现，同样的一些参数，经过调整会让整个游戏变得彻底不同。这艘飞船到底是笨重、转向慢、射速慢、射程远的战列舰，还是轻盈、转向快、射速快、射程近的战斗机？你要躲闪的是从一个方向袭来的流星群（陨石都从一边来，而且向一个方向阻力特别大），还是四面八方出现的乱石？每一种选择，好像都挺好玩的……\n\n到这时我才了解到一个游戏设计者脑中「指挥意图」清晰的重要性。你到底要做一个什么样的游戏，给玩家带来什么样的情感？只有一个大概的「我要爽」是不够的：究竟是控制巨大战舰缓慢机动将将擦过一块流星的那种屏气凝神的爽，还是控制战斗机高速穿梭在流星群中那种险象环生的爽？有时候自己也会犹豫。只有记住一开始你要提供的是怎么样的情感，并且在全程中反复回看，才不会偏离目标。\n\n一个人制作尚且如此，当需要团队合作的时候，若不把一个确定的思路贯彻到底，怎么行呢？\n\n第八周：2048\n\n\n\n啊，HTML 小游戏。在这个星期，2048 游戏突然流行了起来。于是我也跟风复刻了一个。看似简单的游戏，真的要做出来，对于新手来说还是挺费脑筋的。\n\n第一个问题就是，这个网格怎么做呢？我采用的转化方法是使用一个二维的list。看起来就是：\n\n[[0, 1, 2, 3]\n[0, 1, 2, 3]\n[0, 1, 2, 3]\n[0, 1, 2, 3]]\n\n\n这样一来，如果我要定位到第三(2)行第一(0)个格子，我就读取这个 list 中的 List[2][0] 即可。这样一来看起来颇为直观，又能解决问题。\n\n接下来又有好几个问题需要一一解决。首先，当你按下一个方向键以后，所有行（列）的数字都会向着那个方向合并。这件事怎么办呢？\n\n首先我单独写了一个 merge() 方法。只要传来一个 list，就逐个 iterate 并将合并后的值返回去。然后在主要 Class 中间的移动方法 move() 中规定，向哪个方向移动，就以那个方向的四个格子为排头建立四个 list，传去 merge() 那边再替换回来。这样一来这个游戏的核心规则就实现完成，剩下的边边角角多测试修缮即可。当测试成功的那一刻真是有一种爆棚的成就感——很少有解谜游戏的谜题能这样让你研究琢磨几个小时。\n\n当你把游戏的每个部分分入不同的 Class 和方法中后，可以感觉到效率提升不少。例如你在制作模块 B ，此时要用到模块 A 中的功能，你可以完全不管模块 A 怎么实现的，只要把指定的数据传进去，等着它传出结果来就好了。\n\n第九周：Cookie Clicker（点击-放置游戏）\n\n\n\n这是个挺有病（误）的游戏。你只要点这块饼干就可以加饼干数，饼干可以买帮你加饼干的道具，越高级的道具加饼干越快，子子孙孙无穷匮也。听说最近这种放置类游戏在一些小圈子里挺流行的……\n\n游戏本身的设计相对简单。加饼干数，加加饼干速度，获取各种升级和冷却的时间，购买道具等等，并不复杂。\n\n但我们不想自己玩，我们想要电脑自动玩，算出最快速的策略，看看到底能获得多少饼干。\n\n为了这样，我们专门做了一个叫 simulator_clicker() 的方法，它会根据输入的策略，在合适的时间购买固定道具；而每个策略都可以另外定义。这样一来，这个方法里引用的方法又引用了别的方法，复杂性上了一个台阶。\n\n至于「策略」，就进入了 AI 的范畴。此时我们虽然只能使用最基本的条件判断，但反复计算应该让 AI 怎样动作，还是挺有挑战性的。只不过，发现让 AI 采用「纯随机策略」乱买道具出来的结果比你辛苦计算的结果还好，就有点蛋疼……\n\n第十周：Yahtzee\n\n\n\n这是个投骰的游戏，同样涉及自己的「手」概念。大家自己玩一玩这个就明白了。 这一次制作的只涉及分数表上半区的部分。\nYahtzee游戏打印出的策略\n\n为这个游戏编写 AI 最有趣的地方是涉及到了概率和期望。我手上还有这么些骰子，那么接下来可能出现的所有手我都要算一遍，列成一个树，然后找到概率最大的一种。我把列出所有可能手、为一手计算期望值、为一手计算分数和 AI 策略分别写在 4 个方法里。\n\n第十一周：僵尸末日\n\n\n一群人类（绿点）被僵尸（红点）包围在破败废墟中的场景。请自行脑补。\n\n啊，僵尸。也不知道谁规定的，僵尸及其变种的怪物成了无数影视游戏中人类可以毫无道德顾虑地击杀的游戏怪物。\n\n这个游戏的画面如上图所示：\n\n\n黑色是障碍物。可以理解为房子、篱笆、烂掉的车什么的；任何单位不能通过。\n红色是僵尸。它们可以向上下左右四个方向移动，会自动前往最近的人类。\n绿色是人类。他们可以向8个方向移动，会自动远离僵尸。请不要吐槽为什么颜色好像应该反过来。\n紫色是感染者。被僵尸抓到的人类就会这样，不会动。可以理解为啃翻在地上，过一会儿就要变成僵尸起来。\n\n所有的格子都是可以由玩家自行布置的。因此这是个乐趣在于 YY 的沙盒游戏。\n\n点击 \"humans flee\" 按钮则人类移动一回合，点击 \"zombies stalk\" 按钮则僵尸移动一回合。它们采取的寻路策略都是广度优先搜索。游戏不会结束，你可以在这个沙盒中给自己安排胜利条件。布置各种各样的场面看着它们行动，也还能支撑个半小时的乐趣，是到目前为止制作的可玩性最强的游戏……\n\n同样的，这个游戏也是一个具有充分扩展性的游戏。感染者会不会转化成僵尸？人类能不能拿到武器反击僵尸？僵尸中间会不会有特殊感染者，能够范围攻击、远程拉住人类、能跳来跳去或者会爆炸？玩家这个上帝的力量有多大？跳出「玩家扮演游戏中的某个角色」的框框，会发现沙盒类游戏的乐趣所在。\n\n第十二周：猜词游戏\n\n\n\n猜词游戏就是这样：你指定一个词，电脑会搜索词库，将这个词的字母能组成的所有词以星号遮住，你逐个尝试将他们列出来的游戏。\n\n这个游戏中第一次涉及到读取文件。\n\n为了成功的读取到输入的词汇并且匹配所有可能组成的词，我们需要使用一个 merge_sort() 方法来将一个打乱的列表变成有序的。这时我第一次接触到「递归(recursion)」。\n\n要理解递归，首先要理解递归（误）。也就是说这个方法自己不断引用自己。看起来就像\n\nmerge_sort(something):\n    ...\n    merge_sort(something_again)\n    ...\n\n\n这样。\n\n设计一个递归方法前，首先要明确停止递归的条件(base case)。在这个基础上推算每一步应该怎么办。可以拿一个简单的例子在纸上演示，无误后写出来看看效果。\n\n我的设想中，当给出一个 list 后，首先应当将其分成两半，当字母的个数小于等于 1 就应该停止递归。\n\n最后写成的方法看起来像这样：\n\ndef merge_sort(list1):\n    \"\"\"\n    Sort the elements of list1.\n    Return a new sorted list with the same elements as list1.\n    This function should be recursive.\n    \"\"\"\n    new_list = list(list1)\n    # base case: when length is 1 or 0\n    if len(new_list) <= 1:\n        return new_list\n    # recurrences:\n    if len(new_list) > 1:\n        # split in half\n        mid = len(new_list) / 2\n        half_list1 = new_list[0:mid]\n        half_list2 = new_list[mid:]\n        # call merge_sort on each half\n        list1_sorted = merge_sort(half_list1) \n        list2_sorted = merge_sort(half_list2)\n        # and merge each sorted <- 在这个方法中会对2个元素进行排序\n        return merge(list1_sorted, list2_sorted)\n\n\n对我来说递归还是挺复杂的。一个简单的递归就要想很久，不过想清楚了之后的效果还是不错的。不少复杂的游戏设计中都会出现类似的规则。\n\n当然，你也可以不使用递归，而是设定一些条件重复地调用一个方法。但那样的话代码量就变得很大，执行效率可能也会变慢。你是要牺牲易理解性换取效率，还是牺牲效率换取易理解性呢？很多时候玩家也会试图来理解你游戏的内在逻辑，能不能让他们轻松办到呢？\n\n第十三周：九宫格（tic-tac-toe）\n\n\n\n九宫格，世界各地的小朋友可能都玩过的经典游戏。放大到5连就是五子棋。\n\n为这个游戏编写电脑对手采用的是所谓的「蒙特卡罗方法」。也就是从目前这一步开始，推算出每一个可能的游戏结果。胜则加分，负则扣分，和则不加不减；最后选定分数最高的一步落子。这种算法在棋盘复杂的的情况下很难实用，但应付九宫格是绰绰有余。\n\n然后，为了测试这个对手到底强不强，我把游戏规则反了一下变成「逆九宫格」。也就是谁先连到 3 个就算输。这种模式下，没有下中间那个位置的不败手，更能看出电脑的实力。第一盘我还没反应过来，结果输掉了。\n\n\n\n逆九宫格：先达成三个一线者负\n\n到这里，我编写的 AI 就摆脱了特别直觉的 if-else 或者广度优先搜索规则，进入了一个发挥其强大计算力的时代。假如把棋盘扩大几倍，胜利条件相应放大，人类就很难战胜电脑了。\n\n第十四周：数字推盘游戏（n-Puzzle）\n\n\n\n一开始的游戏是15个方格，数字错乱了，需要你来把它们移动回正确的位置。有一种改进型就是拼图，首先你要找出图片的正确顺序，然后还要推回正确位置。\n\n游戏本身的规则不难，但要做一个自动解 Puzzle 的 AI 就有点意思了，根据反复试玩观察，一个盘面可以分为几个区域，各自有固定解法：\n\n\n第二行以下第一列右侧的的\n第二行以下最左边一列的\n第一行的\n第二行的\n最末阶段左上角的4个\n\n大家可以观察动画里面解开的过程，研究一下在这些区域我让电脑怎么动作的……\n\n一个个模块分别编写和测试，在内部再分情况讨论，真是件体力活！但只要测试无误，无论这个 puzzle 扩展到多大，解开它也就是时间问题。以后谁再拿这种东西为难你，只要把题目输入进去，就能看着电脑瞬间自动解开并且给你一个操作顺序了。\n\n\n\n结语\n\n在整个的 14 周过程中间，我从能写简单的几十行程序，逐渐进步到能完成较复杂的600行程序（不含UI部分）。在此过程中，我逐步学到和应用的知识有：\n\n\npython 基础语法\n变量\nlist\n方法(function)\n类(class)\n各种算法\n递归\n编程的 style 要求\n\n……等等，族繁不及备载。这些知识以及应用的方法有可能忘却，但在此过程中有着更多东西是令我体会深刻，很难忘记的：\n\n\n将「手感好」、「手感不好」等感觉分析成多个具体部分，进行调整。\n评估各种实现某个功能的手段，依据其复杂程度或者实现效率。\n分步计划并实现你期望的功能，最后组合成完整的游戏。\n\n这些是在布鲁姆教育目标分类法被列为比较高级的认知类型。知识可以被忘记，理解和应用的过程会让你有一些印象，而分析、评估、合成的过程则可以逐步内化成你自己的能力。你从别人那里听来的经验是知识，也许你在自己行事的过程中能够理解一些、应用一些，但更高级的认知，则非亲手实践不能取得。\n\n\n\n如果你在游戏或者互联网行业，但你并不知道程序同学们怎么工作、想些什么；或者总觉得自己的设想与实现之间有着一道障壁。也许自己亲手实现(implement)自己设想的过程会带给你启发。\n\n至少我在这 14 周每周做一个游戏的过程中，确实有这样的体会。除此之外，亲手实现设计的快感，掌握自己作品的快感，也是无可比拟的。\n\n                ", "mainLikeNum": ["9 "], "mainBookmarkNum": "38"}