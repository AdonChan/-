{"title": "Django搭建个人博客：改写View视图 - Django搭建个人博客 ", "index": "python,django", "content": "改写视图函数\n上一章我们感受了视图的工作流程。\n为了让视图真正发挥作用，改写article/views.py中的article_list视图函数：\narticle/views.py\n\nfrom django.shortcuts import render\n\n# 导入数据模型ArticlePost\nfrom .models import ArticlePost\n\ndef article_list(request):\n    # 取出所有博客文章\n    articles = ArticlePost.objects.all()\n    # 需要传递给模板（templates）的对象\n    context = { 'articles': articles }\n    # render函数：载入模板，并返回context对象\n    return render(request, 'article/list.html', context)\n代码同样很直白，分析如下：\n\n\n.models表示从当前文件夹的models.py文件中导入ArticlePost数据类\n\nArticlePost.objects.all()从ArticlePost数据类获得所有的对象（即博客文章），并传递给articles变量\n\ncontext定义了需要传递给模板的对象，即articles\n\n\n最后返回了render函数：\n\n第一个变量是固定的request对象，照着写就可以\n第二个变量定义了模板文件的位置、名称，即article/list.html\n\n第三个变量定义了需要传入模板文件的对象，即context\n\n\n\n\n视图函数这样就写好了。\n编写模板（template）\n在前面的视图中我们定义了模板的位置在article/list.html，因此在根目录下新建templates文件夹，再新建article文件夹，再新建list.html文件，即：\nmy_blog\n│  ...\n├─article\n│  ...\n└─my_blog\n│  ...\n└─templates\n    └─ article\n        └─ list.html\n细心的你肯定注意到了，之前的Django文件后缀都是.py，代表Python文件；这里的模板文件后缀是.html，这又是什么呢？\nHTML是一种用于创建网页的标记语言。它被用来结构化信息，标注哪些文字是标题、哪些文字是正文等（当然不仅仅这点功能）。也可以简单理解为“给数据排版”的文件，跟你写文档用的Office Word一样一样的 。\n在list.html文件中写入：\ntemplates/article/list.html\n\n{% for article in articles %}\n    <p>{{ article.title }}</p>\n{% endfor %}\n作为一个Web框架，Django通过模板来动态生成HTML，其中就包含描述动态内容的一些特殊语法：\n\n\n{% for article in articles %}：articles为视图函数的context传递过来的对象，即所有文章的集合。{% for %}循坏表示依次取出articles中的元素，命名为article，并分别执行接下来操作。末尾用{% endfor %}告诉Django循环结束的位置。\n使用.符号来访问变量的属性。这里的article为模型中的某一条文章；我们在前面的ArticlePost中定义了文章的标题叫title，因此这里可以用article.title来访问文章的标题。\n\n<p>...</p>即为html语言，中间包裹了一个段落的文字。\n\n在上一章中已经定义好了urls.py，因此不再需要改动。\n一切都很好，深吸一口气。保存所有文件，在浏览器中输入地址http://127.0.0.1:8000/article/article-list/，得到以下错误：\n\n似乎成功从来都不会很顺利。\n错误分析\n虽然出错了，但幸运的是Django提供了非常完善的错误处理系统，方便开发者快速找到Bug的蛛丝马迹。\n第一行就醒目地提示：TemplateDoesNotExist，说明Django没有找到list.html这个文件。仔细检查目录、文件的名称无误，没问题就往下继续看。\n然后发现有这么两行：\n...django\\contrib\\admin\\templates\\article\\list.html (Source does not exist)\n...django\\contrib\\auth\\templates\\article\\list.html (Source does not exist)\n似乎Django在这两个位置搜索，没有发现需要的文件，然后返回了“未发现模板文件”的错误。\n定位了问题的所在，接下来就是在哪里“告诉”Django我的模板的位置呢？\n答案就在settings.py中了，它保存了Django项目的各种初始配置。\n打开并找到这一段，加入代码os.path.join(BASE_DIR, 'templates')：\nmy_blog/settings.py\n\nTEMPLATES = [\n    {\n        ...\n        # 定义模板位置\n        'DIRS': [os.path.join(BASE_DIR, 'templates')],\n        ...\n    },\n]\n这就是说模板文件在项目根目录的templates文件夹中，去找找吧。\n很好，保存文件，重新启动服务器，刷新浏览器，如下：\n\n\n\n成功！\n虽然简陋，但是已经完全走通了MTV（model、template、view）整个环路。\n不要激动，精彩的还在后面。\n总结\n本章我们重写了视图，编写了简单的模板，和前面的模型成功关联起来。\n下一章将学习编写一个漂亮的网页模板。\n\n有疑问请在杜赛的个人网站留言，我会尽快回复。\n或Email私信我：dusaiphoto@foxmail.com\n项目完整代码：Django_blog_tutorial\n\n\n转载请告知作者并注明出处。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}