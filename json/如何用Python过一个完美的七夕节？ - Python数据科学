{"title": "如何用Python过一个完美的七夕节？ - Python数据科学 ", "index": "tkinter,七夕,python", "content": "作者：xiaoyu\n微信公众号：Python数据科学\n知乎：python数据分析师\n\n\n七夕礼物\n一年一度的七夕节又到了，每年重复的过，花样各种有，很多男同胞又开始发愁了，该准备点什么呢？前一段时间非常火的电影 “西红市首富” 突然给了我点灵感，男主全城放烟花俘获了女主的芳心。没错！就是放烟花，而且要全城放。\n可除了土豪，不是所有人都能在整个城市放烟花的。对于一个普通的不能再普通的我也只能想想了。虽然梦想很遥远，不过我还没放弃，我决定用Python来帮我实现一下这个愿望，毕竟Python是万能的。\n下面是Python实现的礼花动态效果。\n\nTkinter和代码实现\n这个动态效果是由 Tkinter库来完成的，属于Python的GUI编程部分。Python提供了多个图形开发界面的库，常用的有Tkinter，xwPython，Jython。Tkinter是Python的标准GUI库，内置在Python中，不需要额外安装，对于一些简单的图形界面可以轻松实现。\n下面是七夕节烟花效果的代码实现，首先导入所有需要的库：\n\n\nTkinter：最终的GUI实现；\n\nPIL：处理图像，在最后画布背景中使用；\n\ntime：处理时间，完成时间生命周期的更新迭代；\n\nrandom：随机产生数字，定义燃放过程中的随机变量；\n\nmath：数学函数方法，计算燃放移动使用；\n\nimport tkinter as tk\nfrom PIL import Image, ImageTk\nfrom time import time, sleep\nfrom random import choice, uniform, randint\nfrom math import sin, cos, radians\n然后定义一个通用的烟花颗粒的类（part），烟花颗粒的属性如下：\n\n\nid：每个烟花中颗粒的标识；\n\nx, y： 烟花的x，y轴；\n\nvx, vy：在x，y轴中颗粒的速度；\n\ntotal：每个烟花的颗粒数量；\n\nage：颗粒已经在背景度过的时间；\n\ncolor：颜色；\n\ncv：背景；\n\nlifespan：颗粒将在背景持续多久；\n\n然后在这个类中定义了烟花颗粒的一些类方法：\n\n\nupdate：通过判断颗粒状态更新颗粒的生命时间；\n\nexpand：定义爆炸的时间；\n\nalive：检查颗粒在生命周期内是否还存在；\n\n# 设置重力参数\nGRAVITY = 0.05\n# 设置随机的颜色列表\ncolors = ['red', 'blue', 'yellow', 'white', 'green', 'orange', 'purple', 'seagreen', 'indigo', 'cornflowerblue']\n\nclass part:\n    def __init__(self, cv, idx, total, explosion_speed, x=0., y=0., vx=0., vy=0., size=2., color='red', lifespan=2,\n                 **kwargs):\n        self.id = idx\n        self.x = x\n        self.y = y\n        self.initial_speed = explosion_speed\n        self.vx = vx\n        self.vy = vy\n        self.total = total\n        self.age = 0\n        self.color = color\n        self.cv = cv\n        self.cid = self.cv.create_oval(\n            x - size, y - size, x + size,\n            y + size, fill=self.color)\n        self.lifespan = lifespan\n\n    def update(self, dt):\n        self.age += dt\n\n        # 颗粒爆炸\n        if self.alive() and self.expand():\n            move_x = cos(radians(self.id * 360 / self.total)) * self.initial_speed\n            move_y = sin(radians(self.id * 360 / self.total)) * self.initial_speed\n            self.cv.move(self.cid, move_x, move_y)\n            self.vx = move_x / (float(dt) * 1000)\n\n        # 颗粒降落\n        elif self.alive():\n            move_x = cos(radians(self.id * 360 / self.total))\n     \n            self.cv.move(self.cid, self.vx + move_x, self.vy + GRAVITY * dt)\n            self.vy += GRAVITY * dt\n\n        # 如果颗超过最长持续时间，颗粒消失\n        elif self.cid is not None:\n            cv.delete(self.cid)\n            self.cid = None\n\n    # 定义爆炸的时间\n    def expand(self):\n        return self.age <= 1.2\n\n    # 检查颗粒在生命周内是否还存在\n    def alive(self):\n        return self.age <= self.lifespan\n上面完成了一个通用的烟花颗粒类的实现，下面就开始烟花燃放的模拟循环过程：通过递归不断循地在背景中产生新的烟花。\n首先定义一个 simulate 模拟的函数，在函数中定了一些参数：\n\n\nt：时间戳；\n\nexplode_points：烟花爆炸点列表，供后续更新使用；\n\nnum_explore：随机的烟花数量；\n\n然后在所有的烟花数量中循环创建所有的烟花颗粒类，当然在每次循环中颗粒类都需要设置一定的属性参数，参数多是随机产生：\n\n\nobjects：存放所有的颗粒对象；\n\nx_cordi，y_cordi：随机产生烟花在背景中的x，y坐标位置（50，550）；\n\nspeed：随机产生颗粒移动速度（0.5，1.5）；\n\nsize：随机产生颗粒大小（0.5，3）；\n\ncolor：选择颜色随机列表中的颜色；\n\ntotal_particles：随机产生每个烟花中所有颗粒的数量；\n\n有了这些参数，我们就可以定义循环产生每个颗粒对象了，并将每个烟花的所有颗粒对象储存在objects中。也就是说explore_points是列表中套列表，内层列表是每个烟花的所有颗粒对象，外层列表是所有烟花。\n所有的颗粒对象完成后，就开始对每个颗粒的生命时间进行更新，且总时间设定在1.8秒以内。最后通过root递归使烟花可以一直在背景中燃放。\ndef simulate(cv):\n    t = time()\n    explode_points = []\n    wait_time = randint(10, 100)\n    numb_explode = randint(6, 10)\n    # 循环创建所有的烟花颗粒\n    for point in range(numb_explode):\n        objects = []\n        x_cordi = randint(50, 550)\n        y_cordi = randint(50, 150)\n        speed = uniform(0.5, 1.5)\n        size = uniform(0.5, 3)\n        color = choice(colors)\n        explosion_speed = uniform(0.2, 1)\n        total_particles = randint(10, 50)\n        for i in range(1, total_particles):\n            r = part(cv, idx=i, total=total_particles, explosion_speed=explosion_speed, x=x_cordi, y=y_cordi,\n                     vx=speed, vy=speed, color=color, size=size, lifespan=uniform(0.6, 1.75))\n            objects.append(r)\n        explode_points.append(objects)\n\n    total_time = .0\n    # 保持在1.8秒内进行更新\n    while total_time < 1.8:\n        sleep(0.01)\n        tnew = time()\n        t, dt = tnew, tnew - t\n        for point in explode_points:\n            for item in point:\n                item.update(dt)\n        cv.update()\n        total_time += dt\n    # 通过递归持续不断的在背景中添加新烟花\n    root.after(wait_time, simulate, cv)\n\ndef close(*ignore):\n    \"\"\"停止模拟循环，关闭窗口\"\"\"\n    global root\n    root.quit()\n以上代码部分均与Tkinter无关，只是定义了颗粒对象以及模拟颗粒生命周期的全过程，下面将使用Tkinter完成最终的效果。\n\n\nroot：Tkinter类的对象；\n\ncv：定义了Tkinter中背景画布对象，其中height和width参数可根据实际进行调整；\n\nimage：打开的图像对象，图像将被作为画布中的背景，图像可根据自己喜好自行选择；\n\nphoto：使用ImageTk定义了Tkinter中的图像对象；\n\n然后将在画布对象上创建一个图像（使用定义的photo对象作为参数），最后调用Tkinter对象root进行持续不断地simulate模拟过程。\n\nif __name__ == '__main__':\n    root = tk.Tk()\n    cv = tk.Canvas(root, height=600, width=600)\n    # 自己选择一个好的图像背景填充画布\n    image = Image.open(\"image.jpg\")\n    photo = ImageTk.PhotoImage(image)\n    cv.create_image(0, 0, image=photo, anchor='nw')\n\n    cv.pack()\n    root.protocol(\"WM_DELETE_WINDOW\", close)\n\n    root.after(100, simulate, cv)\n\n    root.mainloop()\n注意：背景图片可根据自己的喜好进行更换，还不赶紧定制一个属于自己的烟花秀？\n七夕总结\n以上便是博主给大家的七夕节礼物了，代码不到100行，但却完成了一个超炫的GUI效果。完整代码可在公众号后台回复 “七夕” 获取，最后祝大家七夕节快乐。\nhttps://github.com/tuangauss/...\n\n关注微信公众号：Python数据科学，发现更多精彩内容。\n\n                ", "mainLikeNum": ["18 "], "mainBookmarkNum": "8"}