{"title": "python大佬养成计划----线程与多线程 - python太阳花 ", "index": "python", "content": "创建线程\n一个进程必有一个线程，进程也可由多个线程组成，但有一个线程为主线程。若一个任务需要花10Mins，当只有一个线程时，花费10Mins,当有十个线程时，可能就花费1Mins,所以多线程可以提升任务执行时间，提高工作效率。python里与线程有关的模块：\n\n_thread 底层\nthreading\n\n查看当前运行的线程个数：threading.current_thread()查看当前线程信息：threading.active_count()\nimport _thread\nimport threading\n\ndef job():\n\n    print(\"当前线程个数：\",threading.active_count())\n    print(\"当前线程信息\",threading.current_thread())\n\nif __name__=='__main__':\n    job()\n\n_thread创建多线程\n调用thread模块中的start_new_thread()函数来产生新线程。thread.start_new_thread(function,args = ())\n#_thread创建多线程\nimport _thread\nimport time\n\ndef job(name):\n    print(\"name:%s,time:%s\" %(name,time.ctime()))\n\nif __name__==\"__main__\":\n    # 创建多个线程, 但是没有开始执行任务\n    _thread.start_new_thread(job,('thread1',))\n    _thread.start_new_thread(job,('thread2',))\n    while True: #盲等待\n        pass\n\nthreading通过实例化Thread类创建多线程\n_thread模块提供了低级别的、原始的线程以及一个简单的锁。threading模块是对_thread再封装，对使用者更友好通过实例化Thread对象创建线程，Thread的方法有：\n\nrun() #Method representing the thread's activity.\nstart() #Start the thread's activity.\njoin() #Wait until the thread terminates.\nis_alive() #Return whether the thread is alive.\n\nimport threading\n\ndef job(name):\n    print(\"当前执行的任务名：\",name)\n    print(\"当前线程个数：\",threading.active_count())\n    print(\"当前线程信息：\",threading.current_thread())\n\nif __name__==\"__main__\":\n    t1 = threading.Thread(target=job,name='thread1',args=('job1',))\n    t2 = threading.Thread(target=job,name='thread2',args=('job2',))\n    t1.start()  #Start the thread's activity.\n    t2.start()\n\n使用多线程与不使用多线程的对比\n不使用多线程执行任务，程序会一直等待sleep时间过去，在执行下一条命令。\n#不使用多线程\nimport time\n\ndef music(name):\n    for i in range(2):\n        print(\"i am listening :\",name)\n        time.sleep(2)\ndef read(book):\n    for i in range(2):\n        print(\"i am reading :\",book)\n        time.sleep(1)\nif __name__ == '__main__':\n    start_time = time.time()\n    music(\"空空如也\")\n    read('面纱')\n    print(\"花费时间: %s\" %(time.time()-start_time))\n\n使用多线程执行任务，在遇到某一线程需要等待时，会执行其他线程Thread.join()会等待当前线程执行结束，再执行主线程。\nimport threading\nimport time\n\n\ndef music(name):\n    for i in range(2):\n        print(\"i am listening :\",name)\n        time.sleep(2)\ndef read(book):\n    for i in range(2):\n        print(\"i am reading :\",book)\n        time.sleep(1)\nif __name__==\"__main__\":\n    start_time = time.time()\n    t1 = threading.Thread(target=music,args=('空空如也',))\n    t2 = threading.Thread(target=read,args=('面纱',))\n    t1.start()\n    t2.start()\n    t1.join()   #等待线程执行结束，才执行主程序，防止主线程阻塞子线程\n    t2.join()\n    end_time = time.time()\n    print(\"任务执行时间：\",end_time-start_time)\n\n守护线程setDeamon\n当申明一个子线程为守护线程时，主线程结束时，子线程也结束。申明守护线程需要在开启线程之前。\nimport threading\nimport time\n\ndef music(name):\n    for i in range(2):\n        print(\"listening music :\",name)\n        time.sleep(4)\n\ndef code(pro):\n    for i in range(2):\n        print('i am coding :',pro)\n        time.sleep(5)\n\nif __name__=='__main__':\n    st_time = time.time()\n    t1 = threading.Thread(target=music,args=('hello',))\n    t2 = threading.Thread(target=code,args=('mydiff',))\n    #将线程申明为守护线程，如果设置为True，当主线程结束，子线程也结束\n    #必须在启动线程之前进行设置\n    t1.setDaemon(True)\n    t2.setDaemon(True)  #主线程执行结束之后，子线程还没来得及执行结束，整个程序就退出了\n    t1.start()\n    t2.start()\n    end_time = time.time()\n    print('运行时间:',end_time-st_time)\n\n线程同步\n如果多个线程共同对某个数据修改，则可能出现不可预料的结果，为了保证数据的正确性，需要对多个线程进行同步。 使用Thread对象的Lock和Rlock可以实现简单的线程同步，这两个对象都有acquire方法和release方法，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到acquire和release方法之间。\nimport threading\n\ndef add(lock):\n    #操作变量之前加锁\n    lock.acquire()\n    global money\n    for i in range(1389993):\n        money+=1\n    #变量操作完成之后，解锁\n    lock.release()\n\ndef reduce(lock):\n    #操作变量之前加锁\n    lock.acquire()\n    global money\n    for i in range(4728937):\n        money-=1\n    #变量操作完成之后，解锁\n    lock.release()\n\nif __name__==\"__main__\":\n    money = 0\n    lock = threading.Lock() #示例化一个锁对象\n    t1 = threading.Thread(target=add,args=(lock,))\n    t2 = threading.Thread(target=reduce,args=(lock,))\n    t1.start()\n    t2.start()\n\n    t1.join()\n    t2.join()\n    print('最终金额为：',money)\n\nGIL全局解释器锁\nPython 代码的执行由 Python 虚拟机(也叫解释器主循环)来控制。Python 在设计之初就考虑到要在主循环中，同时只有一个线程在执行，就像单 CPU 的系统中运行多个进程那样，内存中可以存放多个程序，但任意时刻，只有一个程序在 CPU 中运行。同样地，虽然 Python 解释器中可以“运行”，多个线程，但在任意时刻，只有一个线程在解释器中运行。\n对 Python 虚拟机的访问由全局解释器锁（GIL）来控制，正是这个锁能保证同一时刻只有一个线程在运行。\n执行过程:\n1). 设置GIL\n2). 切换到线程去运行对应的任务;\n3). 运行\n    - 执行完了\n    - time.sleep()\n    - 获取其他信息才能继续执行, eg: 从网络上获取网页信息等;\n3. 把线程设置为睡眠状态\n4. 解锁GIL\n5.再次重复执行上述内容;\n\n生产者消费者模型\n在工作中，某些模块生成一些数据，由另一些模块负责处理。产生数据的模块，就形象地称为生产者；而处理数据的模块，就称为消费者。在生产者与消费者之间在加个缓冲区，我们形象的称之为仓库，生产者负责往仓库了进商品，而消费者负责从仓库里拿商品，这就构成了生产者消费者模式。这里，我们用生产者消费者模型来实现多线程的网址访问，节省时间。\n#多线程实现生产者消费者模型\n#实现不同的网址或ip访问\nimport threading\nfrom urllib.request import urlopen\n\n\ndef create_data():\n    with open('ips.txt','w') as f:\n        f.write(\"www.baidu.com\\n\")\n        f.write(\"www.163.com\\n\")\n        for i in range(100):\n            f.write('172.25.254.%s\\n' %(i+1))\ndef creat_url(filename='ips.txt'):\n    ports=[80,443]\n    with open(filename) as f:\n        ips = [url_info.strip() for url_info in f.readlines()]\n    urls = ['http://%s:%s' %(ip,port) for ip in ips for port in ports]\n    return urls\n\ndef job(url):\n    try:\n        urlObj = urlopen(url)\n    except Exception as e :\n        print('Warnning!!!    %s不可访问' %(url))\n    else:\n        print(\"%s可以访问\" %(url))\n\nif __name__==\"__main__\":\n    urls = creat_url()\n    threads = []\n    for url in urls:\n        t = threading.Thread(target=job,args=(url,))\n        threads.append(t)\n        t.start()\n    [thread.join() for thread in threads]\n    print(\"任务执行结束\")\n\n再封装threading.Thread类\n无参版\n对threading.Thread类的再封装，执行时无需传递参数\nfrom threading import Thread\nclass IpThread(Thread):\n    def __init__(self):\n        super(IpThread, self).__init__()\n# 将多线程需要执行的任务重写到run方法中;\n    def run(self):\n        print(\"this is a JOB\")\n        print(type(self))\n\nt = IpThread()\nt.start()\n\n含参版\n实现访问Ip地址\nimport json\nfrom threading import Thread\nfrom urllib.request import urlopen\n\nclass IpThread(Thread):\n    #重写构造方法，如果执行的任务需要传递参数，那将参数与self绑定\n    def __init__(self,jobname,ip):\n        super(IpThread, self).__init__()\n        self.jobname = jobname\n        self.ip = ip\n    #将多线程需要执行的任务重写到run方法中\n    def run(self):\n        print('this is a %s job' %(self.jobname))\n        #需要有一个参数，传递ip\n        url = \"http://ip.taobao.com/service/getIpInfo.php?ip=%s\" % (self.ip)\n        try :\n            # 根据url获取网页的内容， 并且解码为utf-8格式， 识别中文;\n            result = urlopen(url).read().decode('utf-8')\n        except Exception as e:\n            print(\"访问%s失败\" %(self.ip))\n        else:\n             # 将获取的字符串类型转换为字典， 方便处理\n            d = json.loads(result)['data']\n            country = d['country']\n            city = d['city']\n        print(\"%s位于%s,城市为%s\" %(self.ip,country,city))\n\nif __name__==\"__main__\":\n    ips = ['172.25.254.22','8.8.8.8','89.31.136.0']\n    threads = []\n    for ip in ips :\n        t = IpThread(jobname='Clawer',ip=ip)\n        threads.append(t)\n        t.start()\n    [thread.join() for thread in threads]\n    print(\"程序执行结束\")\n\n线程池\n线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。\nfrom concurrent.futures import ThreadPoolExecutor\n\nimport time\n#需要执行的任务\ndef job():\n    print(\"morning sheen\")\n    return 'new day'\n\nif __name__=='__main__':\n    #示例化对象，线程池里最多有10个线程\n    pool = ThreadPoolExecutor(max_workers=10)\n    #往线程池里扔需要执行的任务，返回一个对象 _base.Future()示例化出来的\n    f1 = pool.submit(job)\n    f2 = pool.submit(job)\n    #判断任务是否执行结束\n    print(f1.done())\n    time.sleep(1)\n    print(f2.done())    #判断是否释放了线程\n    #获取执行任务的结果\n    print(f1.result())\n    print(f2.result())\n\n\n线程池循环执行任务\n略\n线程池执行任务方式\nconcurrent.futures.ThreadPoolExecutor，在提交任务的时候，有两种方式，一种是submit（）函数，另一种是map（）函数，两者的主要区别在于：\n\nmap可以保证输出的顺序, submit输出的顺序是乱的\n如果你要提交的任务的函数是一样的，就可以简化成map。但是假如提交的任务函数是不一样的，或者执行的过程之可能出现异常（使用map执行过程中发现问题会直接抛出错误）就要用到submit（）\nsubmit和map的参数是不同的，submit每次都需要提交一个目标函数和对应的参数，map只需要提交一次目标函数，目标函数的参数放在一个迭代器（列表，字典）里就可以。\n\nfrom urllib.error import HTTPError\nfrom urllib.request import urlopen\nfrom concurrent.futures import ThreadPoolExecutor,as_completed\nimport time\n\nURLS = ['http://httpbin.org', 'http://example.com/',\n        'https://api.github.com/']*3\ndef get_page(url,timeout = 0.3):   #爬取网页信息\n    try:\n        content = urlopen(url).read()\n        return {'url':url, 'len':len(content)}\n    except HTTPError as e:\n        return {'url':url, 'len':0}\n\n# 方法1： submit提交任务\nstart_time = time.time()\npool = ThreadPoolExecutor(max_workers=20)\n#submit返回的是Future对象,对于Future对象可以简单地理解为一个在未来完成的操作\nfuturesObj = [pool.submit(get_page, url) for url in URLS]\n# # 注意: 传递的是包含futures对象的序列, as_complete返回已经执行完任务的future对象，\n# # 直到所有的future对应的任务执行完成， 循环结束;\nfor finish_fs in as_completed(futuresObj):\n    print(finish_fs.result() )\n#submit返回值Future的方法result(self, timeout=None)\n\"\"\"Return the result of the call that the future represents.\nArgs:\n    timeout: The number of seconds to wait for the result if the future\n        isn't done. If None, then there is no limit on the wait time.\nReturns:\n    The result of the call that the future represents.\"\"\"\nprint(\"执行时间:%s\" %(time.time()-start_time))\n\n# 方法2：通过map方式执行\nstart2_time = time.time()\npool2 = ThreadPoolExecutor(max_workers=20)\nfor res in pool2.map(get_page, URLS):\n    print(res)\nprint(\"执行时间:%s\" %(time.time()-start2_time))\n\n\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "2"}