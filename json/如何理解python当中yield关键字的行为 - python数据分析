{"title": "如何理解python当中yield关键字的行为 - python数据分析 ", "index": "data-analysis,python", "content": "如何遍历pandas当中的行\n现有一个数据框pandas的dataframe:\nimport pandas as pd\ninp = [{'c1':10, 'c2':100}, {'c1':11,'c2':110}, {'c1':12,'c2':120}]\ndf = pd.DataFrame(inp)\nprint df\n\n期望输出\n   c1   c2\n0  10  100\n1  11  110\n2  12  120\n现在我想遍历这个数据框的每一行， 在每一行当中我想通过列名访问第一行的每一个元素，例如，实现以下效果：\nfor row in df.rows:\n   print row['c1'], row['c2']\n这里推送一个非常好用的函数：iterrows()这个函数同时返回 索引和行对象的生成器可以直接进行遍历\nIn [18]: for index, row in df.iterrows():\n   ....:     print row['c1'], row['c2']\n   ....:     \n10 100\n11 110\n12 120\n如何理解python当中的yield函数\n若要理解python当中的(yield)函数,首先必须理解什么是生成器(generators),在理解生成器之前必须先理解迭代器(iterators).\n迭代器\n当你创建一个列表list,可以一个元素一个元素逐个读他,这样的操作称为迭代 interation :\n>>> mylist = [1, 2, 3]\n>>> for i in mylist:\n...    print(i)\n1\n2\n3\n这里mylist就称之为一个可迭代对象,当你使用列表推导时(list comprehension),可以生成一个列表,列表推导的方法如下所示:\n>>> mylist = [x*x for x in range(3)]\n>>> for i in mylist:\n...    print(i)\n0\n1\n4\n所有可以用for ... in ... 操作的对象称之为可迭代对象.例如字符串列表文件集合等等.\n++列表这类可迭代对象还比较方便,但缺点就是需要存储在内存中的对象非常多,在值非常多的时候如果都使用这种方式,不是很好++.\n生成器\n生成器也是迭代器的一种,是一种只能遍历一次的可迭代对象.生成器不需要在内存当中存储所有的值,他们是即时生成值,性能更快.例如:\n>>> mygenerator = (x*x for x in range(3))\n>>> for i in mygenerator:\n...    print(i)\n0\n1\n4\n可以看到,除了使用[]替代()之外,其它都是一样的,但是以下的用法就是不允许的:\nfor i in mygenerator\n实际上他们先生成0,然后忘掉0,再生成1,丢弃1,一直往下,一个接一个进行处理.\nYield函数\nyield 函数有点像Return,区别在于这个函数返回的是迭代器.例如:\ndef createGenerator():\n    mylist = range(3)\n    print u'this will be executed only when for ... in ..called only once'\n    for i in mylist:\n        yield i*i\nmygenerator = createGenerator()\nprint 'test'\nfor i in mygenerator:\n    print(i)\n\n\n\ntest\nthis will be executed only when for ... in ..called only once\n0\n1\n4\n可以看出来,当你知道你的函数会返回数量非常大的元素供遍历时,并且只需读一次的时候,使用yield函数是非常合适的.\n若要掌握yield函数,你必须理解当你调用这个函数时,函数内部的代码实际是没有执行的.这个函数只是返回一个生成器的对象.当实际遍历时(for ... in  ... )  yield语句才会执行.\n这里是比较有意思的地方:第一次使用for访问这个生产器对象的时候,\"print u'this will be executed only when for ... in ..called only once'\"这句话才被打印出来,并且打印在\"test\"之后,说明yield之前的函数体会在for第一次循环时被调用一次且仅仅调用一次.但是,如果是这样情况又不同了:\ndef createGenerator():\n    mylist = range(3)\n    print u'this will be executed only when for ... in ..called only once'\n    for i in mylist:\n        print 'test3'\n        yield i*i\n    print 'test2'\nmygenerator = createGenerator()\nprint 'test'\nfor i in mygenerator:\n    print(i)\n结果现在变成了:\ntest\nthis will be executed only when for ... in ..called only once\ntest3\n0\ntest3\n1\ntest3\n4\ntest2\n可见如果在yield语句同级的代码块中的语句,其实外层for进行迭代时,每次都会执行.\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}