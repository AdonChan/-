{"title": "django官方文档1.11编翻：1-1-1概述 - 个人文章 ", "index": "python,django", "content": "django概述\n因为django是在快节奏的编辑环境下开发的，它旨在使常见的Web开发任务变得快速而简单。 这是一个关于如何用django编写数据库驱动的Web应用程序的非正式概述。\n本文档的目的是为您提供足够的技术细节来了解django的工作原理，但这不是一个教程或参考 - 但是我们已经有了！ 当您准备开始一个项目时，您可以从教程开始，或者直接进入更详细的文档。\n设计你的模型\n尽管您可以在没有数据库的情况下使用django，但它附带一个对象关系映射器，您可以在其中以python代码描述数据库布局。\n数据模型语法提供了许多丰富的代表模型的方法 - 到目前为止，它一直在解决多年的数据库模式问题。 这是一个快速的例子：\nmysite/news/models.py\nfrom django.db import models\n\nclass Reporter(models.Model):\n    full_name = models.CharField(max_length=70)\n\n    def __str__(self):              # __unicode__ on Python 2 即为在python2的语法中此处应该为def __unicode__(self):\n        return self.full_name\n\nclass Article(models.Model):\n    pub_date = models.DateField()\n    headline = models.CharField(max_length=200)\n    content = models.TextField()\n    reporter = models.ForeignKey(Reporter, on_delete=models.CASCADE)\n\n    def __str__(self):              # __unicode__ on Python 2\n        return self.headline\n\n安装它\n接下来，运行django命令行实用程序自动创建数据库表：\n$ python manage.py migrate\n\n其实在高版本的django中创建数据库表的完整步骤应该是，首先在命令窗口进入到项目文件的目录下有manage.py的那一层，先后运行：\npython manage.py makemigrations    # 生成数据库迁移文件\npython manage.py migrate           # 创建数据库表\n\nmigrate命令查看所有可用的模型，并在数据库中创建不存在的表以及可选地提供更丰富的模式控制的表。\n享受免费的API\n因此，您有一个免费且丰富的Python API来访问您的数据。 API是即时创建的，不需要代码生成：\n# Import the models we created from our \"news\" app\n>>> from news.models import Reporter, Article\n\n# No reporters are in the system yet.\n>>> Reporter.objects.all()\n<QuerySet []>\n\n# Create a new Reporter.\n>>> r = Reporter(full_name='John Smith')\n\n# Save the object into the database. You have to call save() explicitly.\n>>> r.save()\n\n# Now it has an ID.\n>>> r.id\n1\n\n# Now the new reporter is in the database.\n>>> Reporter.objects.all()\n<QuerySet [<Reporter: John Smith>]>\n\n# Fields are represented as attributes on the Python object.\n>>> r.full_name\n'John Smith'\n\n# Django provides a rich database lookup API.\n>>> Reporter.objects.get(id=1)\n<Reporter: John Smith>\n>>> Reporter.objects.get(full_name__startswith='John')\n<Reporter: John Smith>\n>>> Reporter.objects.get(full_name__contains='mith')\n<Reporter: John Smith>\n>>> Reporter.objects.get(id=2)\nTraceback (most recent call last):\n    ...\nDoesNotExist: Reporter matching query does not exist.\n\n# Create an article.\n>>> from datetime import date\n>>> a = Article(pub_date=date.today(), headline='Django is cool',\n...     content='Yeah.', reporter=r)\n>>> a.save()\n\n# Now the article is in the database.\n>>> Article.objects.all()\n<QuerySet [<Article: Django is cool>]>\n\n# Article objects get API access to related Reporter objects.\n>>> r = a.reporter\n>>> r.full_name\n'John Smith'\n\n# And vice versa: Reporter objects get API access to Article objects.  外键反向查询\n>>> r.article_set.all()\n<QuerySet [<Article: Django is cool>]>\n\n# The API follows relationships as far as you need, performing efficient\n# JOINs for you behind the scenes.\n# This finds all articles by a reporter whose name starts with \"John\".\n>>> Article.objects.filter(reporter__full_name__startswith='John')\n<QuerySet [<Article: Django is cool>]>\n\n# Change an object by altering its attributes and calling save().\n>>> r.full_name = 'Billy Goat'\n>>> r.save()\n\n# Delete an object with delete().\n>>> r.delete()\n\n一个动态的管理界面：它不只是脚手架 - 它是整个房子\n一旦您的模型被定义，Django可以自动创建一个专业的，生产就绪的管理界面 - 允许经过身份验证的用户添加，更改和删除对象的网站。 在管理员网站上注册您的模型非常简单：\nmysite/news/models.py\nfrom django.db import models\n\nclass Article(models.Model):\n    pub_date = models.DateField()\n    headline = models.CharField(max_length=200)\n    content = models.TextField()\n    reporter = models.ForeignKey(Reporter, on_delete=models.CASCADE)\nmysite/news/admin.py\nfrom django.contrib import admin\n\nfrom . import models\n\nadmin.site.register(models.Article)\n\n这里的理念是，您的网站由员工或客户端编辑，也可能仅仅是您编辑 - 而您不需要处理创建后端接口来管理内容。\n创建django应用程序的一个典型工作流程是创建模型并尽可能快地让管理站点运行起来，因此您的员工（或客户端）可以开始填充数据。 然后，开发数据呈现给公众的方式。\n设计您的网址\n一个干净，优雅的URL方案是高质量Web应用程序中的重要细节。 django鼓励漂亮的网址设计，并不会在URL中放置其他的东西，比如 .php 或 .asp 。\n要设计应用程序的URL，您可以创建一个名为URLconf的python模块。 您的应用程序的目录，它包含URL模式和python回调函数之间的简单映射。 URLconfs还用于将URL与python代码分离。\n以下是关于上面的 Reporter/Article 示例中的URLconf的内容：\nmysite/news/urls.py\nfrom django.conf.urls import url\n\nfrom . import views\n\nurlpatterns = [\n    url(r'^articles/([0-9]{4})/$', views.year_archive),\n    url(r'^articles/([0-9]{4})/([0-9]{2})/$', views.month_archive),\n    url(r'^articles/([0-9]{4})/([0-9]{2})/([0-9]+)/$', views.article_detail),\n]\n\n上面的代码将URL作为简单的正则表达式映射到python回调函数（\"views\"）的位置。 正则表达式使用括号来从URL\"捕获\"值。 当用户请求页面时，django按顺序运行每个模式，并在与所请求的URL匹配的第一个模式下停止。（如果没有匹配，Django会调用特殊情况的404视图。）这是非常快的，因为正则表达式是在加载时编译的。\n一旦正则表达式匹配，django会调用给定的视图，这是一个python函数。每个视图都会传递一个请求对象（包含请求元数据）以及在正则表达式中捕获的值。\n例如，如果用户请求URL \"/articles/2005/05/39323/\"，django将调用函数 news.views.article_detail(request, '2005', '05', '39323')。\n编写你的视图\n每个视图都负责执行以下两项操作之一：返回包含所请求页面内容的HttpResponse对象，或引发异常（如Http404）。其余的取决于你。\n通常，视图根据参数检索数据，加载模板并使用检索到的数据呈现模板。以下是上述year_archive的示例视图：\nmysite/news/views.py\nfrom django.shortcuts import render\n\nfrom .models import Article\n\ndef year_archive(request, year):\n    a_list = Article.objects.filter(pub_date__year=year)\n    context = {'year': year, 'article_list': a_list}\n    return render(request, 'news/year_archive.html', context)\n该示例使用django的模板系统，它具有几个强大的功能，但努力保持足够简单以便非程序员使用。\n设计你的模板\n上面的代码加载了 news/year_archive.html 模板。\ndjango具有模板搜索路径，可以最大程度地减少模板之间的冗余。在django设置中，您可以指定使用DIRS检查模板的目录列表。如果第一个目录中不存在模板，则会检查第二个目录，依此类推。\n假设发现 news/year_archive.html 模板。这可能是这样的：\nmysite/news/templates/news/year_archive.html\n{% extends \"base.html\" %}\n\n{% block title %}Articles for {{ year }}{% endblock %}\n\n{% block content %}\n<h1>Articles for {{ year }}</h1>\n\n{% for article in article_list %}\n    <p>{{ article.headline }}</p>\n    <p>By {{ article.reporter.full_name }}</p>\n    <p>Published {{ article.pub_date|date:\"F j, Y\" }}</p>\n{% endfor %}\n{% endblock %}\n\n变量被双花括号包围。 {{article.headline}} 表示\"输出文章headline属性的值\"，但是点不仅仅用于属性查找。他们还可以进行字典键查找，索引查找和函数调用。\n注意 {{article.pub_date | date：\"F j，Y\"}} 使用Unix风格的\"pipe\"（\"|\"字符）。这被称为模板过滤器，它是一种过滤变量值的方法。在这种情况下，日期过滤器会以给定的格式（同样可以在PHP的日期函数中找到）格式化python datetime对象。\n您可以将所需的过滤器链接在一起。您可以编写自定义模板过滤器。您可以编写自定义模板标签，该标签在幕后运行自定义的python代码。\n最后，django使用\"模板继承\"的概念。这就是 {% extends \"base.html\" %} 。这意味着\"首先加载名为'base'的模板，它定义了一堆块，并使用以下块填充块。\"简而言之，这样可以大大减少模板中的冗余：每个模板只能定义该模板有什么独特之处。\n以下是\"base.html\"模板，包括使用静态文件，可能如下所示：\nmysite/templates/base.html\n{% load static %}\n<html>\n<head>\n    <title>{% block title %}{% endblock %}</title>\n</head>\n<body>\n    <img src=\"{% static \"images/sitelogo.png\" %}\" alt=\"Logo\" />\n    {% block content %}{% endblock %}\n</body>\n</html>\n\n简单来说，它定义了网站的外观（与网站的徽标），并为子模板填充提供了\"洞\"。 这使得站点重新设计与更改单个文件（基本模板）一样简单。\n它还允许您创建多个版本的站点，具有不同的基本模板，同时重用子模板。django的创作者已经使用这种技术来创建惊人的不同的移动版本的网站 - 只需创建一个新的基本模板。\n请注意，如果您喜欢其他系统，则不必使用django的模板系统。虽然django的模板系统与django的模型层特别完美地结合在一起，但是没有什么会强制你使用它。为此，您不必使用django的数据库API。您可以使用另一个数据库抽象层，您可以读取XML文件，您可以从磁盘读取文件，或任何您想要的内容。每个django - 模型，视图，模板 - 与下一个分离。\n这只是表面\n这只是Django功能的简要概述。 一些更有用的功能：\n与memcached或其他后端集成的缓存框架。一个联合框架，使得创建RSS和Atom feed与编写一个小python类一样简单。更性感自动生成的管理功能 - 这个概述几乎没有触及表面。下一个明显的步骤是为您下载django，阅读教程并加入社区。 感谢您的关注！\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "1"}