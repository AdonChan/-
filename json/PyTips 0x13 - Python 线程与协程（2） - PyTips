{"title": "PyTips 0x13 - Python 线程与协程（2） - PyTips ", "index": "pytips,python3.5,python", "content": "项目地址：https://git.io/pytips\n我之前翻译了Python 3.5 协程原理这篇文章之后尝试用了 Tornado + Motor 模式下的协程进行异步开发，确实感受到协程所带来的好处（至少是语法上的:D）。至于协程的 async/await 语法是如何由开始的 yield 生成器一步一步上位至 Python 的 async/await 组合语句，前面那篇翻译的文章里面讲得已经非常详尽了。我们知道协程的本质上是：\nallowing multiple entry points for suspending and resuming execution at certain locations.\n允许多个入口对程序进行挂起、继续执行等操作，我们首先想到的自然也是生成器：\ndef jump_range(upper):\n    index = 0\n    while index < upper:\n        jump = yield index\n        if jump is None:\n            jump = 1\n        index += jump\njump = jump_range(5)\nprint(jump)\nprint(jump.send(None))\nprint(jump.send(3))\nprint(jump.send(None))\n<generator object jump_range at 0x10e283518>\n0\n3\n4\n\n后来又新增了 yield from 语法，可以将生成器串联起来：\ndef wait_index(i):\n    # processing i...\n    return (yield i)\ndef jump_range(upper):\n    index = 0\n    while index < upper:\n        jump = yield from wait_index(index)\n        if jump is None:\n            jump = 1\n        index += jump\njump = jump_range(5)\nprint(jump)\nprint(jump.send(None))\nprint(jump.send(3))\nprint(jump.send(None))\n<generator object jump_range at 0x10e22a780>\n0\n3\n4\n\nyield from/send 似乎已经满足了协程所定义的需求，最初也确实是用 @types.coroutine 修饰器将生成器转换成协程来使用，在 Python 3.5 之后则以专用的 async/await 取代了 @types.coroutine/yield from：\nclass Wait(object):\n    \"\"\"\n    由于 Coroutine 协议规定 await 后只能跟 awaitable 对象，\n    而 awaitable 对象必须是实现了 __await__ 方法且返回迭代器\n    或者也是一个协程对象，\n    因此这里临时实现一个 awaitable 对象。\n    \"\"\"\n    def __init__(self, index):\n        self.index = index\n    def __await__(self):\n        return (yield self.index)\nasync def jump_range(upper):\n    index = 0\n    while index < upper:\n        jump = await Wait(index)\n        if jump is None:\n            jump = 1\n        index += jump\njump = jump_range(5)\nprint(jump)\nprint(jump.send(None))\nprint(jump.send(3))\nprint(jump.send(None))\n<coroutine object jump_range at 0x10e2837d8>\n0\n3\n4\n\n与线程相比\n协程的执行过程如下所示：\nimport asyncio\nimport time\nimport types\n\n@types.coroutine\ndef _sum(x, y):\n    print(\"Compute {} + {}...\".format(x, y))\n    yield time.sleep(2.0)\n    return x+y\n@types.coroutine\ndef compute_sum(x, y):\n    result = yield from _sum(x, y)\n    print(\"{} + {} = {}\".format(x, y, result))\nloop = asyncio.get_event_loop()\nloop.run_until_complete(compute_sum(0,0))\nCompute 0 + 0...\n0 + 0 = 0\n\n\n这张图（来自: PyDocs: 18.5.3. Tasks and coroutines）清楚地描绘了由事件循环调度的协程的执行过程，上面的例子中事件循环的队列里只有一个协程，如果要与上一部分中线程实现的并发的例子相比较，只要向事件循环的任务队列中添加协程即可：\nimport asyncio\nimport time\n\n# 上面的例子为了从生成器过度，下面全部改用 async/await 语法\nasync def _sum(x, y):\n    print(\"Compute {} + {}...\".format(x, y))\n    await asyncio.sleep(2.0)\n    return x+y\nasync def compute_sum(x, y):\n    result = await _sum(x, y)\n    print(\"{} + {} = {}\".format(x, y, result))\n\nstart = time.time()\nloop = asyncio.get_event_loop()\ntasks = [\n    asyncio.ensure_future(compute_sum(0, 0)),\n    asyncio.ensure_future(compute_sum(1, 1)),\n    asyncio.ensure_future(compute_sum(2, 2)),\n]\nloop.run_until_complete(asyncio.wait(tasks))\nloop.close()\nprint(\"Total elapsed time {}\".format(time.time() - start))\nCompute 0 + 0...\nCompute 1 + 1...\nCompute 2 + 2...\n0 + 0 = 0\n1 + 1 = 2\n2 + 2 = 4\nTotal elapsed time 2.0042951107025146\n\n总结\n这两篇主要关于 Python 中的线程与协程的一些基本原理与用法，为此我搜索了不少参考文章与链接，对我自己理解它们的原理与应用场景也有很大的帮助（当然也有可能存在理解不到位的地方，欢迎指正）。当然在这里还是主要关注基于 Python 的语法与应用，如果想要了解更多底层实现的细节，可能需要从系统调度等底层技术细节开始学习（几年前我记得翻阅过《深入理解LINUX内核》这本书，虽然大部分细节已经记不清楚了，但对于理解其它人的分析、总结还是有一定帮助的）。这里讨论的基于协程的异步主要是借助于事件循环（由asyncio标准库提供），包括上文中的示意图，看起来很容易让人联想到 Node.js 的事件循环 & 回调，但是协程与回调也还是有区别的，具体就不在这里展开了，可以参考下面第一条参考链接。\n\n欢迎关注公众号 PyHub 每日推送\n\n参考\n\nPython 中的进程、线程、协程、同步、异步、回调\n我是一个线程\nConcurrency is not Parallelism\nA Curious Course on Coroutines and Concurrency\nPyDocs: 17.1. threading — Thread-based parallelism\nPyDocs: 18.5.3. Tasks and coroutines\n[译] Python 3.5 协程究竟是个啥\n协程的好处是什么？ - crazybie 的回答\nPy3-cookbook:第十二章：并发编程\nQuora: What are the differences between parallel, concurrent and asynchronous programming?\nReal-time apps with gevent-socketio\n\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "13"}