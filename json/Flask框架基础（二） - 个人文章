{"title": "Flask框架基础（二） - 个人文章 ", "index": "flask,python", "content": "1 程序的基本结构\n1.1初始化\n所有Flask 程序都必须创建一个程序实例。Web 服务器使用一种名为Web 服务器网关接口（Web Server Gateway Interface，WSGI）的协议，把接收自客户端的所有请求都转交给这个对象处理。程序实例是Flask 类的对象。\nfrom flask import Flask\napp = Flask(__name__)\n传入Flask构造方法的第一个参数是模块或者包的名称，我们应该使用特殊变量 __name __。Python会根据所处的模块来赋予 __ name __变量相应的值，对于我们程序来说，这个值为app\n1.2注册路由\n客户端（例如Web 浏览器）把请求发送给Web 服务器，Web 服务器再把请求发送给Flask程序实例。程序实例需要知道对每个URL 请求运行哪些代码，所以保存了一个URL 到Python 函数的映射关系。处理URL 和函数之间关系的程序称为路由。\n@app.route('/')\ndef index():\nreturn '<h1>Hello World!</h1>'\n在这个程序中，app.route()装饰器把根地址/和index（）函数绑定起来，当用户访问这个URL时就会触发index（）函数。视图函数index（）返回 \" Hello World! \"\nroute()装饰器的第一个参数是URL规则，用字符串表示，必须以/开始。这里的URL是相对的URL（又称内部URL），即不包含域名的URL，以域名www.google.com为例，“/”对应的是根地址，即www.google.com，如果把URL规则改为“/maps”，则实际的绝对地址为www.google.com/maps\n动态路由\n如果你仔细观察日常所用服务的某些URL 格式，会发现很多地址中都包含可变部分。例如， 你的Facebook 资料页面的地址是http://www.facebook.com/&lt;your-name>， 用户名（your-name）是地址的一部分。Flask 支持这种形式的URL，只需在route 修饰器中使用特殊的句法即可。下例定义的路由中就有一部分是动态名字：\n@app.route('/user/<name>')\ndef user(name):\nreturn '<h1>Hello, %s!</h1>' % name\n1.3启动服务器\n程序实例用run 方法启动Flask 集成的开发Web 服务器：\nif __name__ == '__main__':\napp.run(debug=True)\n name__==' main__'是Python 的惯常用法，在这里确保直接执行这个脚本时才启动开发Web 服务器。如果这个脚本由其他脚本引入，程序假定父级脚本会启动不同的服务器，因此不会执行app.run()。\n1.4完整的程序\n示例1.4　hello.py：一个完整的Flask 程序\nfrom flask import Flask\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    return '<h1>Hello World!</h1>'\n\n@app.route('/user/<name>')\ndef user(name):\n    return '<h1>Hello, %s!</h1>' % name\n\nif __name__ == '__main__':\n    app.run(debug=True)\n1.4 异常捕获\n使用装饰器的形式去捕获指定的错误码和异常\n@app.errorhandler(404)\ndef page_not_found(error):\n    return    '404'\n1.5请求钩子\n为了让每个视图函数避免编写重复功能的代码，Flask提供了通用设施的功能，即请求钩子。请求钩子是通过装饰器的形式实现，Flask支持如下四种请求钩子：\n\n\nbefore_first_request：注册一个函数，在处理第一个请求之前运行。\nbefore_request：注册一个函数，在每次请求之前运行。\nafter_request：注册一个函数，如果没有未处理的异常抛出，在每次请求之后运行。\nteardown_request：注册一个函数，即使有未处理的异常抛出，也在每次请求之后运行。\n\n--\n\n2 模板\n模板是一个包含响应文本的文件，其中包含用占位变量表示的动态部分，其具体值只在请求的上下文中才能知道。使用真实值替换变量，再返回最终得到的响应字符串，这一过程称为渲染。为了渲染模板，Flask 使用了一个名为Jinja2 的强大模板引擎。\n2.1 Jinja2模板引擎\n\nJinjia2是由python实现的\n是Flask内置的模板语言\n参照Django设计思想设计的，跟Django差不多\n\n2.1.1渲染模板\n默认情况下，Flask 在程序文件夹中的templates 子文件夹中寻找模板。Flask提供的 \n示例 hello.py : 渲染模板\nfrom flask import Flask, render_template\n# ...\n@app.route('/')\ndef index():\n    return render_template('index.html')\n@app.route('/user/<name>')\ndef user(name):\n    return render_template('user.html', name=name)\n示例　templates/index.html：Jinja2 模板\n<h1>Hello World!</h1>\n示例\n<h1>Hello, {{ name }}!</h1>\nrender_template 函数封装了该模板引擎render_template  函数的第一个参数是模板的文件名，后面的参数都是键值对，表示模板中变量对应的真实值\n2.1.2  变量\n在模板中使用的{{ name }} 结构表示一个变量，它是一种特殊的占位符，告诉模板引擎这个位置的值从渲染模板时使用的数据中获取。\n可以使用过滤器修改变量，过滤器名添加在变量名之后，中间使用竖线分隔。例如，下述模板以首字母大写形式显示变量name 的值：\nHello, {{ name|capitalize }}\nJinja2 提供的部分常用过滤器\n表 Jinja2变量过滤器\n\n\n过滤器名\n说明\n\n\n\nsafe\n渲染值时不转义\n\n\ncapitalize\n把值的首字母转换成大写，其他字母转换成小写\n\n\nlower\n把值转换成小写形式\n\n\nupper\n把值转换成大写形式\n\n\ntitle\n把值中每个单词的首字母都转换成大写\n\n\ntrim\n把值的首尾空格去掉\n\n\nstriptags\n渲染之前把值中所有的HTML 标签都删掉\n\n\n\n2.1.3 控制结构\nJinja2 提供了多种控制结构，可用来改变模板的渲染流程。\n条件控制：\n{% if user %}\n    Hello, {{ user }}!\n{% else %}\n    Hello, Stranger!\n{% endif %}\n循环控制：\n<ul>\n    {% for comment in comments %}\n        <li>{{ comment }}</li>\n    {% endfor %}\n</ul>\n宏\n<!--宏的定义-->\n{ % macro render_comment(comment) % }\n    <li>{{ comment }}</li>\n{ % endmacro % }\n<!--宏的使用-->\n<ul>\n    { % for comment in comments % }\n        <!--宏调用-->\n        {{ render_comment(comment) }}\n    { % endfor % }\n</ul>\n模板代码复用\n在模板中，可能会遇到以下问题\n\n多个模板具有完全相同的顶部和底部内容\n多个模板中具有相同的模板代码内容，但是内容中部分值不一样\n多个模板中具有完全相同的 html 代码块内容\n\n像遇到这种情况，可以使用 JinJa2 模板中的 宏、继承、包含来进行实现\n模板继承\n标签定义的内容\n{% block   %} {% endblock %}\n模板继承是为了重用模板中的公共内容。一般Web开发中，继承主要使用在网站的顶部菜单、底部。这些内容可以定义在父模板中，子模板直接继承，而不需要重复书写。\n首先创建一个名为base.html 的基模板\n<html>\n<head>\n    {% block head %}\n    <title>{% block title %}{% endblock %} - My Application</title>\n    {% endblock %}\n</head>\n<body>\n    {% block body %}\n    {% endblock %}\n</body>\n</html>\nblock 标签定义的元素可在衍生模板中修改。在本例中，我们定义了名为head、title 和body 的块。注意，title 包含在head 中。下面这个示例是基模板的衍生模板：\n{% extends \"base.html\" %}\n{% block title %}Index{% endblock %}\n{% block head %}\n    {{ super() }}\n    <style>\n    </style>\n{% endblock %}\n{% block body %}\n<h1>Hello, World!</h1>\n{% endblock %}\nextends 指令声明这个模板衍生自base.html。在extends 指令之后，基模板中的3 个块被重新定义，模板引擎会将其插入适当的位置。注意新定义的head 块，在基模板中其内容不是空的，所以使用super() 获取原来的内容。\n2.2 Flask-Bootstrap\nBootstrap（http://getbootstrap.com/）是Twitter 开发的一个开源框架，它提供的用户界面组件可用于创建整洁且具有吸引力的网页，而且这些网页还能兼容所有现代Web 浏览器。Bootstrap 是客户端框架，因此不会直接涉及服务器。服务器需要做的只是提供引用了Bootstrap 层叠样式表（CSS） 和JavaScript 文件的HTML 响应， 并在HTML、CSS 和JavaScript 代码中实例化所需组件。这些操作最理想的执行场所就是模板。\n初始化Flask-Bootstrap\nfrom flask.ext.bootstrap import Bootstrap\n# ...\nbootstrap = Bootstrap(app)\n初始化 Flask-Bootstrap 之后,就可以在程序中使用一个包含所有 Bootstrap 文件的基模板。这个模板利用Jinja2的模板继承机制,让程序扩展一个具有基本页面结构的基模板,其中就有用来引入 Bootstrap 的元素。官方教程\n{% extends \"bootstrap/base.html\" %}<!--extends 指 令 从 Flask-Bootstrap中导入bootstrap/base.html,实现模板继承。 -->\n\n{% block title %}Flasky{% endblock %}\n\n{% block navbar %}\n<div class=\"navbar navbar-inverse\" role=\"navigation\">\n    <div class=\"container\">\n        <div class=\"navbar-header\">\n            <button type=\"button\" class=\"navbar-toggle\" data-toggle=\"collapse\" data-target=\".navbar-collapse\">\n                <span class=\"sr-only\">Toggle navigation</span>\n                <span class=\"icon-bar\"></span>\n                <span class=\"icon-bar\"></span>\n                <span class=\"icon-bar\"></span>\n            </button>\n            <a class=\"navbar-brand\" href=\"/\">Flasky</a>\n        </div>\n        <div class=\"navbar-collapse collapse\">\n            <ul class=\"nav navbar-nav\">\n                <li><a href=\"/\">Home</a></li>\n            </ul>\n        </div>\n    </div>\n</div>\n{% endblock %}\n\n{% block content %}\n<div class=\"container\">\n    <div class=\"page-header\">\n        <h1>Hello, {{ name }}!</h1>\n    </div>\n</div>\n{% endblock %}\n\n2.3 自定义错误页面\n像常规路由一样，Flask 允许程序使用基于模板的自定义错误页面。最常见的错误代码有两个：404，客户端请求未知页面或路由时显示；500，有未处理的异常时显示。\n例 hello.py:自定义错误页面\n@app.errorhandler(404)\ndef page_not_found(e):\n    return render_template('404.html'), 404\n\n@app.errorhandler(500)\ndef internal_server_error(e):\n    return render_template('500.html'), 500\n2.4 链接\n在模板中直接编写简单路由的 URL 链接不难,但对于包含可变部分的动态路由,在模板中构建正确的 URL 就很困难。而且,直接编写 URL 会对代码中定义的路由产生不必要的依赖关系。如果重新定义路由,模板中的链接可能会失效。Flask 提供了 url_for() 辅助函数,它可以使用程序 URL 映射中保存的信息生成 URL。\n2.5 静态文件\n用静态文件,例如 HTML代码中引用的图片、JavaScript 源码文件和 CSS。默认设置下,Flask 在程序根目录中名为 static 的子目录中寻找静态文件。如果需要,可在static 文件夹中使用子文件夹存放文件。 如索引图标的位置{{ url_for('static', filename = 'favicon.ico') }}\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}