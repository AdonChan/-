{"title": "Python Socket Programming - wzyplus ", "index": "socket,python", "content": "本文介绍使用Python进行Socket网络编程，假设读者已经具备了基本的网络编程知识和Python的基本语法知识，本文中的代码如果没有说明则都是运行在Python 3.4下。\n\nPython的socket功能封装在socket库中，要使用socket，记得先import socket，socket库的详细介绍参见官方文档。\n\n创建Socket\n\n首先创建一个socket，使用socket库中得socket函数创建。\n\nPythonimport socket\n\n# create an INET, STREAM socket\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n\n例子中创建了一个TCP socket，socket.socket函数的前两个参数的默认值是socket.AF_INET和socket.SOCK_STREAM，创建TCP socket时可以直接写成socket.socket()。\n\n连接服务器\n\n使用socket的connect函数连接到服务器，以下几种参数都是合法的。\n\nPythons.connect(('localhost', 8000))\ns.connect(('127.0.0.1', 8000))\ns.connect(('www.baidu.com', 80))\n\n\n发送数据\n\n发送数据有两个方法send和sendall，send不能保证所有的数据都发送完了，它会返回已发送数据的长度，程序要循环发送数据直到所有数据都已发送完毕。\n\nPythondef mysend(s, msg):\n    total_len = len(msg)\n    total_sent = 0\n    while total_sent < total_len:\n        sent = s.send(msg[total_sent:])\n        if sent == 0:\n            raise RuntimeError(\"socket connection broken\")\n        total_sent += sent\n\n\nsendall能够保证所有的数据都已发送完毕，除非发送过程中出现了错误，它实际上也是循环发送数据直到所有数据发送完成。\n\n这里还要讲一个需要特别注意的地方，从一个例子开始吧：\n\nPythonimport socket\ns = socket.socket()\ns.connect(('www.baidu.com', 80))\ns.sendall('test')\n\n\n都是上面讲过的东西，没什么特别的，分别在Python 2和Python 3中执行以上的代码，结果是：\n\nPython# Python 2.7\n>>> import socket\n>>> s = socket.socket()\n>>> s.connect(('www.baidu.com', 80))\n>>> s.sendall('test')\n\n\nPython 2中执行成功。\n\nPython# Python 3.4\n>>> import socket\n>>> s = socket.socket()\n>>> s.connect(('www.baidu.com', 80))\n>>> s.sendall('test')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: 'str' does not support the buffer interface\n\n\nPython 3中却发生了异常。\n\n同样的代码换个环境却不能执行了，我没有写错呀，怒砸电脑。好吧，你确实没写错，是环境变了，导致这个结果的变化请移步官方的说明。\n\n接收数据\n\n使用recv函数接收数据：\n\nPythondata = s.recv(4096)\n\n\n在Python 3中返回的是bytes对象，在Python 2中返回的是string。注意函数返回的数据长度是小于或者等于参数指定的长度的，要接收到指定长度的数据，需要循环接收数据。\n\nPythondef myreceive(s, msglen):\n    chunks = []\n    bytes_recd = 0\n    while bytes_recd < msglen:\n        chunk = s.recv(min(msglen - bytes_recd, 2048))\n        if chunk == b'':\n            raise RuntimeError(\"socket connection broken\")\n        chunks.append(chunk)\n        bytes_recd = bytes_recd + len(chunk)\n    return b''.join(chunks)\n\n\n关闭连接\n\n当连接不再需要时可以使用close关闭socket连接，关闭后的连接不能再进行任何操作。当一个socket被回收时会自动关闭，但是不要依赖这种机制，不需要socket时就主动的close。\n\n服务端\n\n服务端程序执行的步骤：\n1. 创建服务端socket\n1. 将服务端socket绑定到指定的地址和端口\n1. 监听连接\n1. 接受客户端连接\n1. 处理客户端的数据\n1. 关闭客户端连接\n\n一个简单的echo server示例：\n\nPythonimport socket\n\nHOST = ''\nPORT = 10022\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.bind((HOST, PORT))\ns.listen(10)\nconn, addr = s.accept()\nwhile True:\n    data = conn.recv(1024)\n    if not data:\n        break\n    conn.sendall(data)\nconn.close()\n\n\n客户端程序：\n\nPythonimport socket\n\nHOST = 'localhost'\nPORT = 10022\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.connect((HOST, PORT))\ns.sendall(b'hello socket')\ndata = s.recv(1024)\nprint('Received', repr(data))\ns.close()\n\n\n错误处理\n\nsocket处理过程中发生错误会抛出异常，socket相关的异常有：\n- socket.error\n- socket.herror\n- socket.gaierror\n- socket.timeout\n\nPythonimport socket\n\nHOST = None\nPORT = 10022\n\ntry:\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.bind((HOST, PORT))\n    s.listen(10)\nexcept: socket.error as msg:\n    print(msg)\n\n\n参考资料\n\n\nSocket Programming HOWTO\nPorting Python 2 Code to Python 3\n\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "18"}