{"title": "集成阿里云滑动验证(python) - Ethan Sun的技术博客 ", "index": "阿里云,python", "content": "阿里云的服务 数据风控下面有项滑动验证, 适合有人机验证场景的应用接入.\n所谓滑动验证, 是在需要进行人机识别时, 前端出现验证滑块, 通过拖动滑块到末尾, 实现验证. 如果阿里云认为此次验证风险稍高, 可能出现点击汉字的认证等, 如果风险太高, 验证会直接拒绝.\n集成过程基本是按照 阿里云官方文档 来进行的.\n开通滑动验证服务之后, 阿里云控制台会给出前后端的示例代码, 其中appkey是根据用户不同分配的不通的key.\n前端代码如下所示:\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"UTF-8\">\n  <title>示例-WEB版</title>\n\n  <!-- 此段必须要引入 t为小时级别的时间戳 -->\n  <link type=\"text/css\" href=\"http://g.alicdn.com/sd/ncpc/nc.css?t=1502182314627\" rel=\"stylesheet\"/>\n  <script type=\"text/javascript\" src=\"http://g.alicdn.com/sd/ncpc/nc.js?t=1502182314627\"></script>\n  <!-- 引入结束 -->  \n\n</head>\n<body>\n\n<!-- 此段必须要引入 -->\n<div id=\"_umfp\" style=\"display:inline;width:1px;height:1px;overflow:hidden\"></div>\n<!-- 引入结束 -->\n\n<!-- 表单示例，请替换成您的业务表单 -->\n<div class=\"container\">\n  <form action=\"您提交的服务端地址\" method=\"post\">\n    <div class=\"ln\">\n      <span class=\"h\">用户名：</span>\n      <input type=\"text\" name=\"username\">\n    </div>\n\n    <div class=\"ln\">\n      <span class=\"h\">密码：</span>\n      <input type=\"password\" name=\"password\">\n    </div>\n\n    <div class=\"ln\">\n      <div id=\"dom_id\"></div>\n    </div>\n\n    <input type='hidden' id='csessionid' name='csessionid'/>\n    <input type='hidden' id='sig' name='sig'/>\n    <input type='hidden' id='token' name='token'/>\n    <input type='hidden' id='scene' name='scene'/>\n    <div class=\"ln\">\n      <input type=\"submit\" value=\"提交\">\n    </div>\n  </form>\n</div>\n<!-- 表单示例结束 -->\n\n<!-- 此段必须要引入 -->\n<script>\n  var nc = new noCaptcha();\n  var nc_appkey = '你的appkey';  // 应用标识,不可更改\n  var nc_scene = 'other';  //场景,不可更改\n  var nc_token = [nc_appkey, (new Date()).getTime(), Math.random()].join(':');\n  var nc_option = {\n    renderTo: '#dom_id',//渲染到该DOM ID指定的Div位置\n    appkey: nc_appkey,\n    scene: nc_scene,\n    token: nc_token,\n    trans: '{\"name1\":\"code0\"}',//测试用，特殊nc_appkey时才生效，正式上线时请务必要删除；code0:通过;code100:点击验证码;code200:图形验证码;code300:恶意请求拦截处理\n    callback: function (data) {// 校验成功回调\n      console.log(data.csessionid);\n      console.log(data.sig);\n      console.log(nc_token);\n\n      document.getElementById('csessionid').value = data.csessionid;\n      document.getElementById('sig').value = data.sig;\n      document.getElementById('token').value = nc_token;\n      document.getElementById('scene').value = nc_scene;\n    }\n  };\n  nc.init(nc_option);\n</script>\n<!-- 引入结束 -->\n\n</body>\n\n<!-- 样式示例，请替换成自己的样式 -->\n<style>\n    body {\n      background: #f5f5f5;\n      font-size: 14px;\n      line-height: 20px;\n      margin: 0;\n      padding: 0;\n    }\n    .container {\n      background: #fff;\n      padding: 20px;\n      margin: 20px;\n      width: 400px;\n    }\n    .ln {\n      padding: 5px 0;\n    }\n    .ln .h {\n      display: inline-block;\n      width: 4em;\n    }\n    .ln input {\n      border: solid 1px #999;\n      padding: 5px 8px;\n    }\n  </style>\n<!-- 样式示例结束 -->\n\n</html>\n\n其中标记不可更改的地方就不要更改. 可以看到, 在验证通过之后, console会打印出session, sig, token等几个验证返回变量, 连同scene一起, 通过表单返回业务后台, 由后台调用阿里云滑动验证服务进行校验.\npython后台方面, 首先需要\npip install aliyun-python-sdk-jaq\n安装阿里云滑动验证的python sdkpython的后台代码大致如下:\n# coding: utf-8\nimport requests\nfrom aliyunsdkcore import client\nfrom aliyunsdkjaq.request.v20161123 import AfsCheckRequest\nfrom aliyunsdkcore.profile import region_provider\nfrom app.libs.configure import config\n\nregion_provider.modify_point('Jaq', 'cn-hangzhou', 'jaq.aliyuncs.com')\n\nclt = client.AcsClient(config.ALIYUN_OSS_ACCESS_KEY, config.ALIYUN_OSS_ACCESS_SECRET, 'cn-hangzhou')\n\n\ndef check_aliyun_captcha(session, sig, token, scene):\n    request = AfsCheckRequest.AfsCheckRequest()\n    # 必填参数：请求来源： 1：Android端； 2：iOS端； 3：PC端及其他\n    request.set_Platform(3)\n    request.set_Session(session)\n    request.set_Sig(sig)\n    request.set_Token(token)\n    request.set_Scene(scene)\n    result = clt.do_action_with_exception(request)\n    print result\n这只是个简单示例, print出了返回结果. 这个返回结果是json序列化的string, 需要将其反序列化进行结果判定. 如果Data元素是true的话, 证明校验通过, 可以进行下面的业务逻辑.同样的, 这里还有一点没有处理, 就是do_action_with_exception的抛出ServerException的问题. 应当catch处理.\n如果验证通过的话, 阿里云返回:\n{\"Data\":true,\"ErrorMsg\":\"success.\",\"ErrorCode\":0}\n但只能验证一次, 第二次同样参数执行的话, 会返回:\n{\"Data\":false,\"ErrorMsg\":\"invalid sig parameter.\",\"ErrorCode\":400}\n是为了防止暴力尝试等.\n同时必须说明, 阿里云的这项服务我认为并不稳定, 集成中间出现了一直invalid sig的报错. 后来经与技术支持沟通才ok. 并且这块的文档友好程度等还比较欠缺.\n另: 我还按照阿里云api文档(滑动验证api, 公共参数, 签名机制)的说明写了段代码, 不使用aliyun-python-sdk, 手动拼接请求.同样发现了很多问题.比如文档中有一段\n这个签名值应当不是随便写的. 使用文档中要求的HMAC-SHA1签名算法, 无论是用python像如下这样书写:\nfrom hashlib import sha1\nimport hmac\nfrom base64 import b64encode\n\nhashed = hmac.new('testsecret&', string_to_sign, sha1)\nsignature = b64encode(hashed.digest())\nprint signature\n还是像如下用Java算签名:\nimport javax.crypto.Mac;  \nimport javax.crypto.SecretKey;  \nimport javax.crypto.spec.SecretKeySpec;\nimport org.apache.commons.codec.binary.Base64;  \n  \npublic class HMACSHA1 {  \n  \n    private static final String MAC_NAME = \"HmacSHA1\";    \n    private static final String ENCODING = \"UTF-8\";    \n\n    public static byte[] HmacSHA1Encrypt(String encryptText, String encryptKey) throws Exception {           \n        byte[] data=encryptKey.getBytes(ENCODING);  \n        SecretKey secretKey = new SecretKeySpec(data, MAC_NAME);   \n        Mac mac = Mac.getInstance(MAC_NAME);   \n        mac.init(secretKey);    \n        byte[] text = encryptText.getBytes(ENCODING);    \n        return mac.doFinal(text);    \n    }\n    \n    public static void main(String[] args) throws Exception{\n        byte[] bytes = HMACSHA1.HmacSHA1Encrypt(\"string_to_sign\", \"testsecret&\");\n        System.out.println(Base64.encodeBase64String(bytes));\n    }\n} \nstring_to_sign用文档中给出的替换, 我的两段程序算出的是一致的, 但都跟文档中给出的不一致. 不清楚为何基础算法会不一致, 难道是文档不够新.\n如果我用python如下根据api文档实现自己的后台请求方法的话:\nimport random\nfrom urllib import quote\nfrom hashlib import sha1\nimport hmac\nimport requests\nfrom base64 import b64encode\nimport datetime\n\ndef utcnow_isostr():\n    dt = datetime.datetime.utcnow()\n    return datetime.datetime.strftime(dt, '%Y-%m-%dT%H:%M:%SZ')\n\ndef quote_ali(element):\n    return quote(str(element)).replace('+', '20%').replace('*', '2A%').replace('%7E', '~')\n\ndef build_afs_check_request(session, sig, token, scene):\n    m = dict()\n    m['Action'] = 'AfsCheck'\n    m['Format'] = 'JSON'\n    m['Version'] = '2016-11-23'\n    m['AccessKeyId'] = config.ALIYUN_OSS_ACCESS_KEY\n    m['SignatureMethod'] = 'HMAC-SHA1'\n    m['Timestamp'] = utcnow_isostr()\n    m['SignatureVersion'] = '1.0'\n    m['SignatureNonce'] = str(int(random.random()*1000000))\n    m['token'] = token\n    m['sig'] = sig\n    m['session'] = session\n    m['scene'] = scene\n    m['platform'] = 3\n    ks = m.keys()\n    ks.sort()\n    query_list = list()\n    for k in ks:\n        query_list.append(k + '=' + quote_ali(m[k]))\n    string_to_sign = 'GET&%2F&' + '&'.join(query_list)\n    print string_to_sign\n    base_query_string = '&'.join(query_list)\n    hashed = hmac.new(config.ALIYUN_OSS_ACCESS_SECRET + '&', string_to_sign, sha1)\n    signature = b64encode(hashed.digest())\n    print signature\n    url = 'http://jaq.aliyuncs.com/?{}&Signature={}'.format(base_query_string, quote_ali(signature))\n    print url\n    return url\n\ndef custom_check_aliyun_captcha(session, sig, token, scene):\n    url = build_afs_check_request(session, sig, token, scene)\n    resp = requests.get(url)\n    print resp.content\n这么去请求的话会报Signature不一致, 果不出所料.\n基于以上诡异的表现, 我觉得阿里云滑动验证作为外部服务并不友好或成熟. 更倾向于用自己做的一些验证码服务, 虽然会简单些, 更容易被攻破, 至少稳定, 提供的qps更高.\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "2"}