{"title": "opencv python 光流法 - 个人文章 ", "index": "opencv-python,opencv,python", "content": "Optical Flow \n光流法\n光流是由对象或相机的移动引起的两个连续帧之间的图像对象的明显运动的模式.它是2D矢量场，其中每个矢量是位移矢量，表示从第一帧到第二帧的点的移动.\n\n上图表示的是一个球在连续的5帧图像中的运动,箭头显示其位移矢量.\n光流法原理的基础：\n\n目标像素强度在连续帧之间不变\n相邻像素具有相似的运动\n\n第一帧的像素I(x,y,t),在dt时间之后的下一帧中移动距离(dx，dy),因为这些像素是相同的,而且亮度不变,所以：\n$$\nI(x,y,t) = I(x+dx, y+dy, t+dt)\n$$\n然后采用右侧的泰勒级数展开，删除常用项并除以dt得到：\n$$\nI(x,y,t) = I(x+dx, y+dy, t+dt)\n$$\n在这里:\n$$\nf_x = \\frac{\\partial f}{\\partial x} \\; ; \\; f_y = \\frac{\\partial f}{\\partial y}\n$$\n$$\nu = \\frac{dx}{dt} \\; ; \\; v = \\frac{dy}{dt}\n$$\n上述方程称为光流方程.在其中,我们可以找到fx和fy,它们是图像渐变. 类似地,ft是沿时间的梯度,(u,v) 未知,我们无法用两个未知变量来解决这个方程.因此提供了几种方法来解决这个问题,其中一种方法是Lucas-Kanade.\nLucas-Kanade\n我们之前已经看到一个假设,即所有相邻像素将具有相似的运动.Lucas-Kanade方法需要窗口大小,所有9个点都有相同的动作,我们可以找到这9个点的（f x，f y，f t）. 所以现在我们的问题变成解决了9个方程式，其中两个未知变量是过度确定的.解的个数大于未知数的个数，这是个超定方程，使用最小二乘的方法来求解最优值.\n$$\n\\begin{bmatrix} u \\\\ v \\end{bmatrix} = \\begin{bmatrix} \\sum_{i}{f_{x_i}}^2 & \\sum_{i}{f_{x_i} f_{y_i} } \\\\ \\sum_{i}{f_{x_i} f_{y_i}} & \\sum_{i}{f_{y_i}}^2 \\end{bmatrix}^{-1} \\begin{bmatrix} - \\sum_{i}{f_{x_i} f_{t_i}} \\\\ - \\sum_{i}{f_{y_i} f_{t_i}} \\end{bmatrix}\n$$\n所以从用户的角度来看，想法很简单，给出一些跟踪点，从而那些点的光流向量,但是到现在为止，我们只处理了小动议,所以当有大的运动时它会失败.使用的解决办法是利用图像金字塔,在金字塔顶端的小尺寸图片当中，大幅度的运动就变成了小幅度的运动, 因此，在那里应用Lucas-Kanade,可以得到尺度空间上的光流.\nLucas-Kanade Optical Flow in OpenCV\nimport numpy as np\nimport cv2\nimport matplotlib.pyplot as plt\n\ncap = cv2.VideoCapture('test.mp4')\n# params for ShiTomasi corner detection\nfeature_params = dict( maxCorners = 100,\n                       qualityLevel = 0.3,\n                       minDistance = 7,\n                       blockSize = 7 )\n\n# Parameters for lucas kanade optical flow\nlk_params = dict( winSize  = (15,15),\n                  maxLevel = 2,\n                  criteria = (cv2.TERM_CRITERIA_EPS | cv2.TERM_CRITERIA_COUNT, 10, 0.03))\n\n# Create some random colors\ncolor = np.random.randint(0,255,(100,3))\n\n# Take first frame and find corners in it\nret, old_frame = cap.read()\nold_gray = cv2.cvtColor(old_frame, cv2.COLOR_BGR2GRAY)\np0 = cv2.goodFeaturesToTrack(old_gray, mask = None, **feature_params)\n\n# Create a mask image for drawing purposes\nmask = np.zeros_like(old_frame)\n\nwhile(1):\n    ret,frame = cap.read()\n    frame_gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n\n    # calculate optical flow\n    p1, st, err = cv2.calcOpticalFlowPyrLK(old_gray, frame_gray, p0, None, **lk_params)\n\n    # Select good points\n    good_new = p1[st==1]\n    good_old = p0[st==1]\n\n    # draw the tracks\n    for i,(new,old) in enumerate(zip(good_new,good_old)):\n        a,b = new.ravel()\n        c,d = old.ravel()\n        mask = cv2.line(mask, (a,b),(c,d), color[i].tolist(), 2)\n        frame = cv2.circle(frame,(a,b),5,color[i].tolist(),-1)\n    img = cv2.add(frame,mask)\n\n    cv2.imshow('frame',img)\n    k = cv2.waitKey(30) & 0xff\n    if k == 27:\n        break\n\n    # Now update the previous frame and previous points\n    old_gray = frame_gray.copy()\n    p0 = good_new.reshape(-1,1,2)\n\ncv2.destroyAllWindows()\ncap.release()\n\nDense Optical Flow in OpenCV\nLucas-Kanade方法计算稀疏特征集的光流（在我们的例子中，使用Shi-Tomasi算法检测到的角）。 OpenCV提供了另一种算法来查找密集的光流。 它计算帧中所有点的光流。 它基于Gunner Farneback的算法，该算法在Gunner Farneback于2003年的“Two-Frame Motion Estimation Based on Polynomial Expansion”中进行了解释.\nimport numpy as np\nimport cv2\nimport matplotlib.pyplot as plt\n\ncap = cv2.VideoCapture('test.mp4')\nret, frame1 = cap.read()\nprvs = cv2.cvtColor(frame1,cv2.COLOR_BGR2GRAY)\nhsv = np.zeros_like(frame1)\nhsv[...,1] = 255\n\nwhile(1):\n    ret, frame2 = cap.read()\n    next = cv2.cvtColor(frame2,cv2.COLOR_BGR2GRAY)\n\n    flow = cv2.calcOpticalFlowFarneback(prvs,next, None, 0.5, 3, 15, 3, 5, 1.2, 0)\n\n    mag, ang = cv2.cartToPolar(flow[...,0], flow[...,1])\n    hsv[...,0] = ang*180/np.pi/2\n    hsv[...,2] = cv2.normalize(mag,None,0,255,cv2.NORM_MINMAX)\n    bgr = cv2.cvtColor(hsv,cv2.COLOR_HSV2BGR)\n\n    cv2.imshow('frame2',bgr)\n    k = cv2.waitKey(30) & 0xff\n    if k == 27:\n        break\n    elif k == ord('s'):\n        cv2.imwrite('opticalfb.png',frame2)\n        cv2.imwrite('opticalhsv.png',bgr)\n    prvs = next\n\ncap.release()\ncv2.destroyAllWindows()\n\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}