{"title": "Python-Django - ormsf ", "index": "django,python", "content": "准备工作\n新建一个Django项目\n# 新建一个django项目\n$ django-admin startproject mysite\n# 新建一个app\n$ django-admin startapp blog\n项目的结构\n├── blog\n│   ├── admin.py\n│   ├── apps.py\n│   ├── __init__.py\n│   ├── migrations\n│   │   └── __init__.py\n│   ├── models.py\n│   ├── tests.py\n│   └── views.py\n├── manage.py\n└── mysite\n    ├── __init__.py\n    ├── settings.py\n    ├── urls.py\n    └── wsgi.py\n# mysite/settings.py\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'blog', \n    'markdown2'\n]\n$ python3 manage.py runserver\n\n$ python manage.py collectstatic\n一般在urls.py中配置url，在models.py中配置model，在views.py中配置View。\nurls.py\nFunction views\n1. Add an import:  from my_app import views\n2. Add a URL to urlpatterns:  url(r'^$', views.home, name='home')\nClass-based views\n1. Add an import:  from other_app.views import Home\n2. Add a URL to urlpatterns:  url(r'^$', Home.as_view(), name='home')\nIncluding another URLconf\n1. Import the include() function: from django.conf.urls import url, include\n2. Add a URL to urlpatterns:  url(r'^blog/', include('blog.urls'))\n\n# blog/urls.py\n\nfrom django.conf.urls import url\nfrom blog import views\n\nurlpatterns = [\n    url(r'^blog/$', views.IndexView.as_view(), name='index'),\n    url(r'^blog/article/(?P<article_id>\\d+)$', views.ArticleDetailView.as_view(), name='detail'),\n    url(r'^blog/category/(?P<cate_id>\\d+)$', views.CategoryView.as_view(), name='category'),\n    url(r'^blog/tag/(?P<tag_id>\\d+)$', views.TagView.as_view(), name='tag'),\n]\n使用(?P<>d+)的形式捕获值给<>中得参数，比如(?P<article_id>d+)，当访问/blog/article/3时，将会将3捕获给article_id,这个值会传到views.ArticleDetailView。\n# mysite/urls.py\n\nfrom django.conf.urls import url, include\nfrom django.contrib import admin\nfrom blog import views\n\nurlpatterns = [\n    url(r'^admin/', admin.site.urls),\n    url(r'', include('blog.urls', namespace='blog', app_name='blog'))\n]\n其中namespace参数为我们指定了命名空间，这说明这个urls.py中的url是blog app下的，这样即使不同的app下有相同url也不会冲突了。\n假设用户要访问某篇文章，它会自动解析 blog:detail 这个视图函数对应的 url，并且把 article.pk（文章的主键）传递给detail视图函数，details就是我们在blog/urls.py中指定的name。\n<a href=\"{% url 'blog:detail' article.pk %}\">{{ article.title }}</a>\n如果要访问某个目录\n<a href=\"{% url 'blog:category' category.pk %}\">{{ category.name }}</a>\nmodels.py\ndjango.db.models是orm框架的基础，在blog/models.py中新建Article, Category, Tag三个model。\nclass Article(models.Model):\n    STATUS_CHOICES = (\n        ('d', 'Draft'),\n        ('p', 'Published'),\n    )\n    \n    # 仍然使用默认的 objects 作为 manager 的名字\n    objects = ArticleManager()\n\n    title = models.CharField('标题', max_length=70)\n    body = models.TextField('正文')\n    created_time = models.DateTimeField('创建时间', auto_now_add=True)\n    last_modified_time = models.DateTimeField('修改时间', auto_now=True)\n    status = models.CharField('文章状态', max_length=1, choices=STATUS_CHOICES)\n    # blank和null要同时设置为null，详情参考官方文档\n    abstract = models.CharField('摘要', max_length=54, blank=True, null=True, \n                                help_text=\"可选，如若为空将摘取正文的前54个字符\")\n    views = models.PositiveIntegerField('浏览量', default=0)\n    likes = models.PositiveIntegerField('点赞数', default=0)\n    topped = models.BooleanField('置顶', default=False)\n    \n    category = models.ForeignKey('Category', verbose_name='分类', null=True, on_delete=models.SET_NULL)\n    tags = models.ManyToManyField('Tag', verbose_name='标签集合', blank=True)\n\n    def __str__(self):\n        return self.title\n\n    class Meta:\n        ordering = ['-last_modified_time']\n\n    # 新增 get_absolute_url 方法\n    def get_absolute_url(self):\n        # 这里 reverse 解析 blog:detail 视图函数对应的 url\n        return reverse('blog:detail', kwargs={'article_id': self.pk})\nDjango给我们提供了很多有用的字段，比如上面提到的CharFiled, TestField, DateTimeFiled等等，详情请参考官方文档。\nDjango中的一对多是在一中进行设置，这里对应于文章的分类，ForeignKey即数据库中的外键。on_delete=models.SET_NULL表示删除某个分类（category）后该分类下所有的Article的外键设为null（空），所以我们同时设置了null=True。多对多就不同，两边都要进行配置。详情请参考官方文档。\nclass Category(models.Model):\n    name = models.CharField('类名', max_length=20)\n    created_time = models.DateTimeField('创建时间', auto_now_add=True)\n    last_modified_time = models.DateTimeField('修改时间', auto_now=True)\n\n    def __str__(self):\n        return self.name\nclass Tag(models.Model):\n    name = models.CharField('标签名', max_length=20)\n    created_time = models.DateTimeField('创建时间', auto_now_add=True)\n    last_modified_time = models.DateTimeField('修改时间', auto_now=True)\n\n    def __str__(self):\n        return self.name\n评论功能的实现\nclass BlogComment(models.Model):\n    user_name = models.CharField('评论者名字', max_length=100)\n    user_email = models.EmailField('评论者邮箱', max_length=255)\n    body = models.TextField('评论内容')\n    created_time = models.DateTimeField('评论发表时间', auto_now_add=True)\n    article = models.ForeignKey('Article', verbose_name='评论所属文章', on_delete=models.CASCADE)\n\n    def __str__(self):\n        return self.body[:20]\nclass ArticleManage(models.Manager):\n    \"\"\"\n    继承自默认的 Manager ，为其添加一个自定义的 archive 方法\n    \"\"\"\n    def archive(self):\n        date_list = Article.objects.datetimes('created_time', 'month', order='DESC')\n        # 获取到降序排列的精确到月份且已去重的文章发表时间列表\n        # 并把列表转为一个字典，字典的键为年份，值为该年份下对应的月份列表\n        date_dict = defaultdict(list)\n        for d in date_list:\n            date_dict[d.year].append(d.month)\n        # 模板不支持defaultdict，因此我们把它转换成一个二级列表，由于字典转换后无序，因此重新降序排序\n        return sorted(date_dict.items(), reverse=True)\n我们首先要在project_name/settings.py中配置好相应的配置文件\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.mysql', \n        'NAME': 'DB_NAME',\n        'USER': 'DB_USER',\n        'PASSWORD': 'DB_PASSWORD',\n        'HOST': 'localhost',   # Or an IP Address that your DB is hosted on\n        'PORT': '3306',\n    }\n}\n定义完毕后，我们执行下面的命令就在数据库中可以生成相应的数据表：\n$ python manage.py makemigrations\n\n$ python manage.py migrate\nadmins.py\n参考Mozila的教程以及结合官方文档。\nviews.py\n下面要使用markdown2，所以在INSTALLED_APP里面要添加markdown2，不过这个mardown解析非常的不好，并且弄完还要去下载相应的markdown的css文件，有个专门的网站。\nfrom blog.models import Article, Tag, Category\nfrom django.views.generic import ListView, DetailView\nimport markdown2\n\nclass IndexView(ListView):\n    # template_name属性用于指定使用哪个模板进行渲染\n    template_name = \"blog/index.html\"\n\n    # context_object_name属性用于给上下文变量取名（在模板中使用该名字）\n    context_object_name = \"article_list\"\n\n    def get_queryset(self):\n        article_list = Article.objects.filter(status='p')\n        for article in article_list:\n            article.body = markdown2.markdown(article.body, )\n        return article_list\n\n    def get_context_data(self, **kwargs):\n        kwargs['category_list'] = Category.objects.all().order_by('name')\n        # 调用 archive 方法，把获取的时间列表插入到 context 上下文中以便在模板中渲染\n        kwargs['date_archive'] = Article.objects.archive()\n        kwargs['tag_list'] = Tag.objects.all().order_by('name')\n        return super(IndexView, self).get_context_data(**kwargs)\n上面因为我们要进行markdown处理，所以重新自定义了get_queryset，如果不要进行相应的处理，直接制定model就行了，get_context_data可以添加一些额外的字段，比如以后我们要在首页的侧边栏显示目录和标签，所以这里要添加一个category_list和tag_list。\nclass ArticleDetailView(DetailView):\n    model = Article\n    template_name = \"blog/detail.html\"\n    context_object_name = \"article\"\n    # pk_url_kwarg会自动和model中相应的主键对应，aritlce_id就是下面配置的URLCONF\n    pk_url_kwarg = 'article_id'\n\n    # 为了让文章以markdown形式展现，我们重写get_object()方法\n    def get_object(self):\n        obj = super(ArticleDetailView, self).get_object()\n        obj.body = markdown2.markdown(obj.body)\n        return obj\n        \n    # 新增 form 到 context\n    def get_context_data(self, **kwargs):\n        kwargs['comment_list'] = self.object.blogcomment_set.all()\n        kwargs['form'] = BlogCommentForm()\n        return super(ArticleDetailView, self).get_context_data(**kwargs)\nclass CategoryView(ListView):\n    template_name = \"blog/index.html\"\n    context_object_name = \"article_list\"\n    \n    def get_queryset(self):\n        # url里的cate_id传递给CategoryView，传递的参数在kwargs属性中获取\n        article_list = Article.objects.filter(category=self.kwargs['cate_id'],status='p')\n        for article in article_list:\n            article.body = markdown2.markdown(article.body, )\n        return article_list\n\n    def get_context_data(self, **kwargs):\n        # 增加一个category_list,用于在页面显示所有分类，按照名字排序\n        kwargs['category_list'] = Category.objects.all().order_by('name')\n        return super(CategoryView, self).get_context_data(**kwargs)\nclass TagView(ListView):\n    template_name = \"blog/index.html\"\n    context_object_name = \"article_list\"\n\n    def get_queryset(self):\n        \"\"\"\n        根据指定的标签获取该标签下的全部文章\n        \"\"\"\n        article_list = Article.objects.filter(tags=self.kwargs['tag_id'], status='p')\n        for article in article_list:\n            article.body = markdown2.markdown(article.body, extras=['fenced-code-blocks'], )\n        return article_list\n\n    def get_context_data(self, **kwargs):\n        kwargs['tag_list'] = Tag.objects.all().order_by('name')\n        return super(TagView, self).get_context_data(**kwargs)\nfrom django.views.generic.edit import FormView\n\nclass CommentPostView(FormView):\n    form_class = BlogCommentForm\n    template_name = 'blog/detail.html' \n\n    def form_valid(self, form):\n        target_article = get_object_or_404(Article, pk=self.kwargs['article_id'])\n        # 调用ModelForm的save方法保存评论，设置commit=False则先不保存到数据库，\n        # 而是返回生成的comment实例，直到真正调用save方法时才保存到数据库。\n        comment = form.save(commit=False)\n        # 把评论和文章关联\n        comment.article = target_article\n        comment.save()\n        # 评论生成成功，重定向到被评论的文章页面，get_absolute_url 请看下面的讲解。\n        self.success_url = target_article.get_absolute_url()\n        return HttpResponseRedirect(self.success_url)\n\n    def form_invalid(self, form):\n        target_article = get_object_or_404(Article, pk=self.kwargs['article_id'])\n\n        # 不保存评论，回到原来提交评论的文章详情页面\n        return render(self.request, 'blog/detail.html', {\n            'form': form,\n            'article': target_article,\n            'comment_list': target_article.blogcomment_set.all(),\n        })\ntemplate\n{% for %}循环标签，{% if %}判断标签. {{ variable }}是一些非常常用的标签\n在模板文件中我们可以这样使用，views.py中已经指定了context_object_name = \"article_list\"，并且已经在get_queryset()中进行了markdown处理\n{% for article in article_list %}\n    {{article.title}}\n通常都会设置一个通用的父模板：\n{% extends \"base_generic.html\" %}\n\n{% block content %}\n...\n{% endblock %}\n好像要这么这么设置：\nTEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'DIRS': [os.path.join(BASE_DIR, 'blog/templates')]\n        ,\n        'APP_DIRS': True,\n...\n]\n静态文件\n由于源代码丢失，具体情况记得不太清晰，静态文件路径要设置好，如果js文件加载异常，可能是加载顺序的问题。\nbase_generic.html大概就是下面这样的格式：\n<!DOCTYPE html>\n{% load staticfiles %}\n<html lang=\"zh-CN\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Myblog</title>\n    <link rel=\"stylesheet\" href=\"{% static 'lib/css/bootstrap.min.css' %}\">\n    <link rel=\"stylesheet\" href=\"{% static 'blog/css/style.css' %}\">\n    <link rel=\"stylesheet\" href=\"{% static 'blog/css/pygments/github.css' %}\">\n</head>\n...\n下面这样设置貌似有点问题：\n# mysite/settings.py\nSTATIC_URL = '/static/'\nSTATICFILES = os.path.join(BASE_DIR, 'blog/static')\n具体参考官方文档\n部署\n使用uwsgi+nginx\n/etc/nginx/sites-available/mysite.conf，blog是app名字，static文件放在了下面，建议直接放在mysite下面，template也是一样：\nserver {\n    listen 80;\n\n    location /static/ {\n        alias /home/omrsf/mysite/blog/static/;\n    }\n\n    location / {\n        uwsgi_pass 127.0.0.1:8001;\n        include     /etc/nginx/uwsgi_params;\n    }\n}\nuwsgi -i uwsgi.ini来启动uwsgi进程，结合nohup &：\n[uwsgi]\nsocket = 127.0.0.1:8001\nchdir=/home/ormsf/mysite/\nwsgi-file = mysite/wsgi.py\n\nprocesses = 2\nthreads = 4\n\nchmod-socket = 664\n改进\n目前文章是直接在admin.py中注册model，然后去admin后台发布的，可以做成api接口，做一个在线的编辑器。增加基本的用户认证功能。\n零碎知识点\nnull和blank的区别\n\nnull 是针对数据库而言，如果 null=True, 表示数据库的该字段可以为空。\nblank 是针对表单的，如果 blank=True，表示你的表单填写该字段的时候可以不填，比如 admin 界面下增加 model 一条记录的时候。直观的看到就是该字段不是粗体。\n\nrender与render_response\n优先采用render。\nget_absolute_url\nmodel有一个get_absolute_url，它可以与reverse结合起来。\n参考资料\nGitHub项目地址\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}