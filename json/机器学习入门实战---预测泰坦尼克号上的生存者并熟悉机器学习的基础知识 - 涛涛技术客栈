{"title": "机器学习入门实战---预测泰坦尼克号上的生存者并熟悉机器学习的基础知识 - 涛涛技术客栈 ", "index": "python,laravel,缓存,github", "content": "背景知识：\n泰坦尼克号1912年4月从英国南安普顿出发，途径法国，爱尔兰在美国大西洋碰触冰山沉没，一部分人幸免于难，一部分人没有生存，这个案例中就是要通过机器学习的算法来预测一下test.csv中418人的生存状况。案例详细内容可以访问网站：https://www.kaggle.com/c/titanic。通过这个案例你可以大致掌握一个机器学习的基本步骤，本文最后附上案例的源码。\n一、提出问题\n首先我们从kaggle上下载了泰坦尼克号案例的train.csv和test.csv两个数据，这里我为大家已经下好，大家可以在百度网盘里下载，地址：链接：https://pan.baidu.com/s/1RV-U... 密码：zlkj。\n二、理解数据\n首先导入数据，可以看到训练数据集train.csv中有891行，12列数据，而测试数据集中有418行，11列数据；缺少的这一列数据正是我们要预测的生存状况数据。\nimport numpy as np\nimport pandas as pd\n#导入训练集\ntrain = pd.read_csv('train.csv')\n#导入测试集\ntest = pd.read_csv('test.csv')\n#查看测试数据集合训练数据集的形状\n# print(\"训练数据集：\",train.shape)\n# print(\"测试数据集：\",test.shape)\nfull = train.append(test,ignore_index=True)\n# print(\"合并后的数据集：\",full.shape)\n# print(full.head(10))\n通过实验结果我们可以知道，每一名乘客都对应着一个12维数据，其含义是：\n   1.Age：乘客年龄      \n   2.Cabin：乘客船舱座位号\n   3.Embarked：乘客登船的港口，有三个可选值：S：南安普顿，C：法国瑟堡 Q：爱尔兰昆士敦\n   4.Fare：船票费用\n   5.Name：乘客姓名\n   6.parch：乘客的父母与子女数量\n   7.PassengerId：乘客ID\n   8.Pclass：乘客所在的船舱等级，1;一等，2;二等；3：三等\n   9.sex：乘客性别\n   10.SibSp：乘客的兄弟姐妹以及配偶数量\n   11.Survived：乘客是否存活标志;1:活着的  0：死亡\n   12.Ticket：票的编号\n总数据有1309行，Age、Cabin、Embarked、Fare这四列数据中有缺失的情况，接下来的第三步就是要清洗数据，填补缺失值。\n三、清洗数据\n首先处理一下缺失的数据，如果缺失的数据是数字类型的，可以用平均数代替，如果是字符串类型的，可以用出现最多的数（众数）来替代。\n# 填充年龄缺失值\nfull.Age = full.Age.fillna(full.Age.mean())\n# 填充船票价格缺失值\nfull.Fare = full.Fare.fillna(full.Fare.mean())\n# #填充登船的港口，因为最多的为s，故将所有的缺失值填充为S\nfull.Embarked = full.Embarked.fillna('S')\n# 由于船票号这一栏缺失值过多，故将其填充为U\nfull.Cabin = full.Cabin.fillna('U')\n在做好这一步之后，数据还需要对一些列的字符串数据类型进行编码，比如Sex性别的分类数据，需要进行one-hot编码，方便机器学习识别。这里需要对性别、港口和姓名、船舱等级这些分类数据，进行重新编码。应用map函数可以对一列数据做同一个操作：\nsexDict = {'male':1,'female':0}\nsex = full.Sex.map(sexDict)\nprint(sex.head())\n登船的港口有三个，分别是英国南安普顿、法国瑟堡、爱尔兰昆士敦，分别用首字母S、C、Q表示。\nembarked = pd.DataFrame()\nembarked = pd.get_dummies(full.Embarked,prefix=\"Embarked\")\nprint(embarked.head())\n#对船舱等级采取同样的方法\npclass = pd.DataFrame()\npclass = pd.get_dummies(full.Pclass,prefix=\"Pclass\")\nprint(pclass.head())\n \n接下来我们看一下名字这一列的数据字符串格式：名，头衔，姓，我们需要从名字里面获取头衔来判定是否对生存情况的影响。通过定义一个函数：第一步获取name1剔除名字中逗号前面的名，第二步剔除名字中冒号后面的姓，第三步用strip函数剔除字符串头尾指定的字符（默认为空格）然后返回中间的头衔。第四步应用函数，用一个表格型数据Df存放提取后的头衔，第五步讲姓名中的头衔字符串与定义头衔类别的映射关系，再把头衔进行one-hot编码，\n定义一个函数获取每一个姓名列中的头衔\ndef title1(name):\n    name1 = name.split(',')[1]\n    name2 = name1.split('.')[0]\n    #使用strip函数提出姓名列的头尾，获得头衔\n    name3 = name2.strip()\n    return name3\ntitleDf = pd.DataFrame()\ntitleDf['Title'] = full.Name.map(title1)\ntitleDict = {\n    'Capt':'officer',\n    'Col':'officer',\n    'Major':'officer',\n    'Dr':'officer',\n    'Rev':'officer',\n    'Jonkheer':'Royalty',\n    'Don':'Royalty',\n    'Sir':'Royalty',\n    'the Countess':'Royalty',\n    'Dona':'Royalty',\n    'Lady':'Royalty',\n    'Mlle':'Miss',\n    'Miss':'Miss',\n    'Mr':'Mr',\n    'Mme':'Mrs',\n    'Ms':'Mrs',\n    'Mrs':'Mrs',\n    'Master':'Master'\n}\ntitleDf['Title'] = titleDf['Title'].map(titleDict)\ntitleDf = pd.get_dummies(titleDf['Title'])\nprint(titleDf.head())\n\n接着从座位号提取坐席类别，用seat存放客舱号的信息坐席类别就是座位号的首字母，比如C85，类别映射为首字母C，用U代表不知道的数据。使用lambda匿名函数提取Cabin中的首字母：\nseat = pd.DataFrame()\nseat['seat'] = full['Cabin']\nseat.seat = seat.seat.map(lambda  a:a[0])\n#使用one-hot编码\nseat = pd.get_dummies(seat.seat,prefix=\"Cabin\")\n#print(seat.head())\n\n对船上每一个乘客的家庭成员数量进行一个统计。分别将原始数据中的SibSp列和Parch中的数据相加，再加上被统计者自身。\n#对船上每一个乘客的家庭成员数量进行一个统计\nfamily = pd.DataFrame()\nfamily['family'] = full.SibSp + full.Parch + 1\n#print(family.head())\n最后就是将原始数据复制一份，删除我们刚刚对其中重新编码的列（Cabin、Name、Sex、Pclass、Embarked、Parch、SibSp；还有票的编号Ticket这一列没有关系的数据。最后合并的列包括了刚刚处理产生的新列名比如：da、family、seat、titleDf、pclass、embarked、sex。我们发现新的数据da有1309行，27列。\n最后就是将原始数据复制一份，\n删除我们刚刚对其中重新编码的列（Cabin、Name、Sex、Pclass、Embarked、Parch、SibSp； 还有票的编号Ticket这一列没有关系的数据.最后合并的列包括了刚刚处理产生的新列名比如：da、family、seat、titleDf、pclass、embarked、sex.我们发现新的数据da有1309行，27列\nda = train.append(test,ignore_index=True)\n#采取同样的方式填充缺失值\nda.Age = da.Age.fillna(da.Age.mean())\nda.Fare = da.Fare.fillna(da.Fare.mean())\nda.Embarked = da.Embarked.fillna('S')\nda.Cabin = da.Cabin.fillna('U')\n#提出不需要的列\nda = da.drop(['Name','Pclass','Cabin','Parch','Embarked','SibSp','Ticket','Sex'],axis=1)\n#合并修改后的列\nda = pd.concat([titleDf,seat,family,pclass,embarked,da,sex],axis=1)\n#print(da.shape)\n#print(da.head())\n四、模型建立与评估\n第一步：用数据框corr()得到相关系数矩阵，\n第二步：讲相关系数矩阵的生存情况的列提取出来，分别按照降序排列和升序排列\n#使用数据框corr获取相关系数矩阵，将相关系数提取出来，按照升序和降序排列\ncorrDf = da.corr()\n#print(corrDf['Survived'].sort_values(ascending=False))\n#print(corrDf['Survived'].sort_values(ascending=True))\n我们发现相关系数大于0的列中：头衔、客舱等级、船票价格、船舱号都与生存状况呈现正线性关系在相关系数小于0的列中：头衔、性别、客舱等级、客舱号与生存情况呈现负线性相关。这些特征其实与我们在数据清洗过程中处理的列非常相关，这里我们直接采用上一步最后形成的新数据da\n第三步：我们在原始训练数据中有891行，选取特征和标签，然后对这个数据进行拆分训练集和测试集，\n#将原始数据集拆分为训练集合评估集\nsourceRow = 891\nsource_X  = da.loc[0:sourceRow-1,:]\nsource_X = source_X.drop(['Survived'],axis  =1)\nsource_y  =da.loc[0:sourceRow-1,'Survived']\n\n#拆分训练集和测试集\ntrain_X,test_X,train_y,test_y = train_test_split(source_X,source_y,train_size=0.8)\n\n#输出数据集大小\n# print('原始数据集特征：',source_X.shape)\n# print('训练集特征：',train_X.shape)\n# print('测试集特征：',test_X.shape)\n# print('原始数据集标签：',source_y.shape)\n# print('训练数据集标签：',train_y.shape)\n# print('测试数据集标签：',test_y.shape)\n\n第四步是导入算法，训练模型：\n导入训练数据的特征train_X712条，包括性别，头衔等，导入标签train_y712条生存状况，得到正确率0.87：\n#使用逻辑回归模型\nmodel = LogisticRegression()\n#使用数据，训练模型\nmodel.fit(train_X,train_y)\n# print(model.fit(train_X,train_y))\n# print(model.score(test_X,test_y))\n\n第五步：方案实施\n用机器学习模型，对预测数据集中的生存情况进行预测，这里用乘客的ID，数据框Df保存预测情况的值。\n#方案实施，对预测数据集中的数据进行预测\npredict_X = da.loc[sourceRow:,:]\npredict_X = da.drop(['Survived'],axis=1)\npred_Y = model.predict(predict_X)\npred_Y = pred_Y.astype(int)  \n#乘客ID\npassenger_id = da.loc[sourceRow,'PassengerId']\npredDf = pd.DataFrame({'PassengerId':passenger_id,'Survived':pred_Y})\nprint(predDf.shape)\nprint(predDf)\n  \n最后附上源码：链接：https://pan.baidu.com/s/1cb60... 密码：y12u。有兴趣的可以在阅读本文点赞，欢迎评论哦！\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "2"}