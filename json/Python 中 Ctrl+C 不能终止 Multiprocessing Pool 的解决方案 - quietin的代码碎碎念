{"title": "Python 中 Ctrl+C 不能终止 Multiprocessing Pool 的解决方案 - quietin的代码碎碎念 ", "index": "python2.x,多进程,python", "content": "本文理论上对multiprocessing.dummy的Pool同样有效。\npython2.x中multiprocessing提供的基于函数进程池，join后陷入内核态，按下ctrl+c不能停止所有的进程并退出。即必须ctrl+z后找到残留的子进程，把它们干掉。先看一段ctrl+c无效的代码：\n#!/usr/bin/env python\nimport multiprocessing\nimport os\nimport time\n\n\ndef do_work(x):\n    print 'Work Started: %s' % os.getpid()\n    time.sleep(10)\n    return x * x\n\n\ndef main():\n    pool = multiprocessing.Pool(4)\n    try:\n        result = pool.map_async(do_work, range(8))\n        pool.close()\n        pool.join()\n        print result\n    except KeyboardInterrupt:\n        print 'parent received control-c'\n        pool.terminate()\n        pool.join()\n \n\nif __name__ == \"__main__\":\n    main()\n这段代码运行后，按^c一个进程也杀不掉，最后会残留包括主进程在内共5个进程(1+4)，kill掉主进程能让其全部退出。很明显，使用进程池时KeyboardInterrupt不能被进程捕捉。解决方法有两种。\n方案一\n下面这段是python源码里multiprocessing下的pool.py中的一段，ApplyResult就是Pool用来保存函数运行结果的类\nclass ApplyResult(object):\n\n    def __init__(self, cache, callback):\n        self._cond = threading.Condition(threading.Lock())\n        self._job = job_counter.next()\n        self._cache = cache\n        self._ready = False\n        self._callback = callback\n        cache[self._job] = self\n而下面这段代码也是^c无效的代码\nif __name__ == '__main__':\n    import threading\n\n    cond = threading.Condition(threading.Lock())\n    cond.acquire()\n    cond.wait()\n    print \"done\"\n很明显，threading.Condition(threading.Lock())对象无法接收KeyboardInterrupt，但稍微修改一下，给cond.wait()一个timeout参数即可，这个timeout可以在map_async后用get传递，把\nresult = pool.map_async(do_work, range(4))\n改为\nresult = pool.map_async(do_work, range(4)).get(1)\n就能成功接收^c了，get里面填1填99999还是0xffff都行\n方案二\n另一种方法当然就是自己写进程池了，需要使用队列，贴一段代码感受下\n#!/usr/bin/env python\nimport multiprocessing, os, signal, time, Queue\n\ndef do_work():\n    print 'Work Started: %d' % os.getpid()\n    time.sleep(2)\n    return 'Success'\n\ndef manual_function(job_queue, result_queue):\n    signal.signal(signal.SIGINT, signal.SIG_IGN)\n    while not job_queue.empty():\n        try:\n            job = job_queue.get(block=False)\n            result_queue.put(do_work())\n        except Queue.Empty:\n            pass\n        #except KeyboardInterrupt: pass\n\ndef main():\n    job_queue = multiprocessing.Queue()\n    result_queue = multiprocessing.Queue()\n\n    for i in range(6):\n        job_queue.put(None)\n\n    workers = []\n    for i in range(3):\n        tmp = multiprocessing.Process(target=manual_function,\n                                      args=(job_queue, result_queue))\n        tmp.start()\n        workers.append(tmp)\n\n    try:\n        for worker in workers:\n            worker.join()\n    except KeyboardInterrupt:\n        print 'parent received ctrl-c'\n        for worker in workers:\n            worker.terminate()\n            worker.join()\n\n    while not result_queue.empty():\n        print result_queue.get(block=False)\n\nif __name__ == \"__main__\":\n    main()\n方案三\n使用一个全局变量eflag作标识，让SIG_INT信号绑定一个处理函数，在其中对eflag的值更改，线程的函数中以eflag的值判定作为while的条件，把语句写在循环里，老实说这个方案虽然可以用，但是简直太差劲。线程肯定是可行的，进程应该还需要单独共享变量，非常不推荐的方式\n常见的错误方案\n这个必须要提一下，我发现segmentfault上都有人被误导了\n理论上，在Pool初始化时传递一个initializer函数，让子进程忽略SIGINT信号，也就是^c，然后Pool进行terminate处理。代码\n#!/usr/bin/env python\nimport multiprocessing\nimport os\nimport signal\nimport time\n\n\ndef init_worker():\n    signal.signal(signal.SIGINT, signal.SIG_IGN)\n\n\ndef run_worker(x):\n    print \"child: %s\" % os.getpid()\n    time.sleep(20)\n    return x * x\n\n\ndef main():\n    pool = multiprocessing.Pool(4, init_worker)\n    try:\n        results = []\n        print \"Starting jobs\"\n        for x in range(8):\n            results.append(pool.apply_async(run_worker, args=(x,)))\n\n        time.sleep(5)\n        pool.close()\n        pool.join()\n        print [x.get() for x in results]\n    except KeyboardInterrupt:\n        print \"Caught KeyboardInterrupt, terminating workers\"\n        pool.terminate()\n        pool.join()\n\n\nif __name__ == \"__main__\":\n    main()\n然而这段代码只有在运行在time.sleep(5)处的时候才能用ctrl+c中断，即前5s你按^c有效，一旦pool.join()后则完全无效！\n建议\n先确认是否真的需要用到多进程，如果是IO多的程序建议用多线程或协程，计算特别多则用多进程。如果非要用多进程，可以利用Python3的concurrent.futures包(python2.x也能装)，编写更加简单易用的多线程/多进程代码，其使用和Java的concurrent框架有些相似.经过亲自验证，ProcessPoolExecutor是没有^c的问题的，要用多进程建议使用它\n参考\n\nhttp://bryceboe.com/2010/08/26/python-multiprocessing-and-keyboardinterrupt/#georges\nhttp://stackoverflow.com/questions/1408356/keyboard-interrupts-with-pythons-multiprocessing-pool#comment12678760_6191991\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "9"}