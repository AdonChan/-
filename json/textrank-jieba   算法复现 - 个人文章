{"title": "textrank-jieba   算法复现 - 个人文章 ", "index": "python", "content": "\n根据jieba textrank算法的思路，手动复现textrank算法。思路：1.分词，确定窗口大小。\n 2.根据窗口大小，组合共现词和频率，频率代表共现权重。\n      trick:正反双向共现词。\n 3.根据textrank 每个词的权重的迭代公式，采用冒泡排序的方法，将一个词的所有共现词的权重代入公式。\n 4.迭代10次，使每个词的权重收敛。\n 5.根据权重排序，输出top words。\n\nimport collections\nimport sys\nimport jieba\nimport jieba.posseg as psg\nfrom operator import itemgetter\n\n\nclass UndirectWeightedGraph:\n    d=0.85\n    def __init__(self):\n        self.edges=collections.defaultdict(list)\n    def add_edge(self,start,end,weight):\n        self.edges[start].append((start,end,weight))\n        self.edges[end].append((end,start,weight))\n    def rank(self):\n        ws=collections.defaultdict(float)\n        outSum=collections.defaultdict(float)\n\n        wsdef=1.0/(len(self.edges) or 1.0)\n        for n,elem in self.edges.items():\n            outSum[n]=sum([e[2] for e in elem])\n            ws[n]=wsdef\n\n        for epoch in range(10):\n            for n,elems in self.edges.items():\n                s=0\n                for elem in elems:\n                   s+=elem[2]/outSum[elem[1]]*ws[elem[1]]\n                ws[n]=s\n\n        min_rank,max_rank=sys.float_info[0],sys.float_info[3]\n        for n,w in ws.items():\n            if w<min_rank:\n                min_rank=w\n            if w>max_rank:\n                max_rank=w\n\n        for n,w in ws.items():\n            ws[n]=((n-min_rank)/10.0)/((max_rank-min_rank)/10.0)\n        return ws\n\nclass TextRank(object):\n    def __init__(self):\n        self.stopwords=[]\n        self.pos_filter=[]\n        self.span=5\n    def pairfilter(self,wp):\n        return wp.flag in self.pos_filter and len(wp.word)>=2 and wp.word.lower not in self.stopwords\n    def textrank(self,sentence,topk=20):\n        uwg=UndirectWeightedGraph()\n        words=psg.lcut(sentence)\n        wm=collections.defaultdict(int)\n        for word_index,wp in enumerate(words):\n            if self.pairfilter(wp):\n                for index_assit in range(word_index+1,word_index+5):\n                    if index_assit>=len(words):\n                        break\n                    if not self.pairfilter(words[index_assit]):\n                        continue\n                    wm[(wp,words[index_assit])]+=1\n                    # uwg.add_edge(wp.word,words[index_assit].word,1)\n        for words_tuple,w in wm.items():\n            uwg.add_edge(words_tuple[0],words_tuple[1],w)\n        g=uwg.rank()\n        g=sorted(g.items(),key=itemgetter(1),reverse=True)\n        return g[:topk]\n\n\n\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}