{"title": "简单理解Python装饰器 - paopao学编程 ", "index": "python", "content": "来源：http://www.lightxue.com/under...\n       Python有大量强大又贴心的特性，如果要列个最受欢迎排行榜，那么装饰器绝对会在其中。       刚接触装饰器，会觉得代码不多却难以理解。其实装饰器的语法本身挺简单的，复杂是因为同时混杂了其它的概念。下面我们一起抛去无关概念，简单地理解下Python的装饰器。\n装饰器的原理\n       在解释器下跑个装饰器的例子，直观地感受一下\n# make_bold就是装饰器，实现方式这里略去\n\n>>> @make_bold\n... def get_content():\n...     return 'hello world'\n...\n>>> get_content()\n'<b>hello world</b>'\n       被make_bold装饰的get_content，调用后返回结果会自动被b标签包住。怎么做到的呢，简单4步就能明白了。\n1.  函数是对象\n       我们定义个get_content函数。这时get_content也是个对象，它能做所有对象的操作。\n它有id，有type，有值。\n>>> id(get_content)\n140090200473112\n>>> type(get_content)\n<class 'function'>\n>>> get_content\n<function get_content at 0x7f694aa2be18>\n跟其他对象一样可以被赋值给其它变量。\n>>> func_name = get_content\n>>> func_name()\n'hello world'\n它可以当参数传递，也可以当返回值\n>>> def foo(bar):\n...     print(bar())\n...     return bar\n...\n>>> func = foo(get_content)\nhello world\n>>> func()\n'hello world'\n2. 自定义函数对象\n       我们可以用class来构造函数对象。有成员函数__call__的就是函数对象了，函数对象被调用时正是调用的__call__。\nclass FuncObj(object):\n    def __init__(self, name):\n        print('Initialize')\n        self.name= name\n\n    def __call__(self):\n        print('Hi', self.name)\n我们来调用看看。可以看到，函数对象的使用分两步：构造和调用(同学们注意了，这是考点)。\n>>> fo = FuncObj('python')\n    Initialize\n>>> fo()\n    \"Hi python\"\n3. @是个语法糖\n装饰器的@没有做什么特别的事，不用它也可以实现一样的功能，只不过需要更多的代码。\n@make_bold\ndef get_content():\n    return 'hello world'\n上面的代码等价于下面的\ndef get_content():\n    return 'hello world'\nget_content = make_bold(get_content)\nmake_bold是个函数，要求入参是函数对象，返回值是函数对象。@的语法糖其实是省去了上面最后一行代码，使可读性更好。用了装饰器后，每次调用get_content，真正调用的是make_bold返回的函数对象。\n4. 用类实现装饰器\n入参是函数对象，返回是函数对象，如果第2步里的类的构造函数改成入参是个函数对象，不就正好符合要求吗？我们来试试实现make_bold。\nclass make_bold(object):\n    def __init__(self, func):\n        print('Initialize')\n        self.func = func\n\n    def __call__(self):\n        print('Call')\n        return '<b>{}</b>'.format(self.func())\n大功告成，看看能不能用。\n>>> @make_bold\n... def get_content():\n...     return 'hello world'\n...\nInitialize\n>>> get_content()\nCall\n'<b>hello world</b>'\n成功实现装饰器！是不是很简单？这里分析一下之前强调的构造和调用两个过程。我们去掉@语法糖好理解一些。\n# 构造，使用装饰器时构造函数对象，调用了__init__\n>>> get_content = make_bold(get_content)\nInitialize\n\n# 调用，实际上直接调用的是make_bold构造出来的函数对象\n>>> get_content()\nCall\n'<b>hello world</b>'\n到这里就彻底清楚了，完结撒花，可以关掉网页了~~~(如果只是想知道装饰器原理的话)\n\n函数版装饰器\n阅读源码时，经常见到用嵌套函数实现的装饰器，怎么理解？同样仅需4步。\n1. def的函数对象初始化\n用class实现的函数对象很容易看到什么时候构造的，那def定义的函数对象什么时候构造的呢？\n# 这里的全局变量删去了无关的内容\n>>> globals()\n{}\n>>> def func():\n...     pass\n...\n>>> globals()\n{'func': <function func at 0x10f5baf28>}\n不像一些编译型语言，程序在启动时函数已经构造那好了。上面的例子可以看到，执行到def会才构造出一个函数对象，并赋值给变量make_bold。\n这段代码和下面的代码效果是很像的。\nclass NoName(object):\n    def __call__(self):\n        pass\nfunc = NoName()\n2. 嵌套函数\nPython的函数可以嵌套定义。\ndef outer():\n    print('Before def:', locals())\n    def inner():\n        pass\n    print('After def:', locals())\n    return inner\n    \n#inner是在outer内定义的，所以算outer的局部变量。\n#执行到def inner时函数对象才创建，因此每次调用outer都会创建一个新的inner。\n#下面可以看出，每次返回的inner是不同的。\n\n>>> outer()\nBefore def: {}\nAfter def: {'inner': <function outer.<locals>.inner at 0x7f0b18fa0048>}\n<function outer.<locals>.inner at 0x7f0b18fa0048>\n>>> outer()\nBefore def: {}\nAfter def: {'inner': <function outer.<locals>.inner at 0x7f0b18fa00d0>}\n<function outer.<locals>.inner at 0x7f0b18fa00d0>\n3. 闭包\n嵌套函数有什么特别之处？因为有闭包。\ndef outer():\n    msg = 'hello world'\n    def inner():\n        print(msg)\n    return inner\n下面的试验表明，inner可以访问到outer的局部变量msg。\n>>> func = outer()\n>>> func()\nhello world\n闭包有2个特点inner能访问outer及其祖先函数的命名空间内的变量(局部变量，函数参数)。调用outer已经返回了，但是它的命名空间被返回的inner对象引用，所以还不会被回收。这部分想深入可以去了解Python的LEGB规则。\n4. 用函数实现装饰器\n装饰器要求入参是函数对象，返回值是函数对象，嵌套函数完全能胜任。\ndef make_bold(func):\n    print('Initialize')\n    def wrapper():\n        print('Call')\n        return '<b>{}</b>'.format(func())\n    return wrapper\n用法跟类实现的装饰器一样。可以去掉@语法糖分析下构造和调用的时机。\n>>> @make_bold\n... def get_content():\n...     return 'hello world'\n...\nInitialize\n>>> get_content()\nCall\n'<b>hello world</b>'\n因为返回的wrapper还在引用着，所以存在于make_bold命名空间的func不会消失。make_bold可以装饰多个函数，wrapper不会调用混淆，因为每次调用make_bold，都会有创建新的命名空间和新的wrapper。到此函数实现装饰器也理清楚了，完结撒花，可以关掉网页了~~~(后面是使用装饰的常见问题)\n常见问题\n1. 怎么实现带参数的装饰器？\n带参数的装饰器，有时会异常的好用。我们看个例子。\n    >>> @make_header(2)\n    ... def get_content():\n    ...     return 'hello world'\n    ...\n    >>> get_content()\n    '<h2>hello world</h2>'\n    #怎么做到的呢？其实这跟装饰器语法没什么关系。去掉@语法糖会变得很容易理解。\n    @make_header(2)\n    def get_content():\n        return 'hello world'\n        \n    # 等价于\n    def get_content():\n        return 'hello world'\n    unnamed_decorator = make_header(2)\n    get_content = unnamed_decorator(get_content)\n上面代码中的unnamed_decorator才是真正的装饰器，make_header是个普通的函数，它的返回值是装饰器。\n来看一下实现的代码。\ndef make_header(level):\n    print('Create decorator')\n\n    # 这部分跟通常的装饰器一样，只是wrapper通过闭包访问了变量level\n    def decorator(func):\n        print('Initialize')\n        def wrapper():\n            print('Call')\n            return '<h{0}>{1}</h{0}>'.format(level, func())\n        return wrapper\n\n    # make_header返回装饰器\n    return decorator\n看了实现代码，装饰器的构造和调用的时序已经很清楚了。\n>>> @make_header(2)\n... def get_content():\n...     return 'hello world'\n...\nCreate decorator\nInitialize\n>>> get_content()\nCall\n'<h2>hello world</h2>'\n2. 如何装饰有参数的函数？\n为了有条理地理解装饰器，之前例子里的被装饰函数有意设计成无参的。我们来看个例子。\n@make_bold\ndef get_login_tip(name):\n    return 'Welcome back, {}'.format(name)\n最直接的想法是把get_login_tip的参数透传下去。\nclass make_bold(object):\n    def __init__(self, func):\n        self.func = func\n\n    def __call__(self, name):\n        return '<b>{}</b>'.format(self.func(name))\n       如果被装饰的函数参数是明确固定的，这么写是没有问题的。但是make_bold明显不是这种场景。它既需要装饰没有参数的get_content，又需要装饰有参数的get_login_tip。这时候就需要可变参数了。\nclass make_bold(object):\n    def __init__(self, func):\n        self.func = func\n    def __call__(self, *args, **kwargs):\n        return '<b>{}</b>'.format(self.func(*args, **kwargs))\n       当装饰器不关心被装饰函数的参数，或是被装饰函数的参数多种多样的时候，可变参数非常合适。可变参数不属于装饰器的语法内容，这里就不深入探讨了。\n3. 一个函数能否被多个装饰器装饰？\n下面这么写合法吗？\n@make_italic\n@make_bold\ndef get_content():\n    return 'hello world'\n合法。上面的的代码和下面等价，留意一下装饰的顺序。\ndef get_content():\n    return 'hello world'\nget_content = make_bold(get_content) # 先装饰离函数定义近的\nget_content = make_italic(get_content)\n4. functools.wraps有什么用？\n       Python的装饰器倍感贴心的地方是对调用方透明。调用方完全不知道也不需要知道调用的函数被装饰了。这样我们就能在调用方的代码完全不改动的前提下，给函数patch功能。       为了对调用方透明，装饰器返回的对象要伪装成被装饰的函数。伪装得越像，对调用方来说差异越小。有时光伪装函数名和参数是不够的，因为Python的函数对象有一些元信息调用方可能读取了。为了连这些元信息也伪装上，functools.wraps出场了。它能用于把被调用函数的__module__，__name__，__qualname__，__doc__，__annotations__赋值给装饰器返回的函数对象。\nimport functools\ndef make_bold(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        return '<b>{}</b>'.format(func(*args, **kwargs))\n    return wrapper\n对比一下效果。\n>>> @make_bold\n... def get_content():\n...     '''Return page content'''\n...     return 'hello world'\n>>>\n# 不用functools.wraps的结果\n>>> get_content.__name__\n'wrapper'\n>>> get_content.__doc__\n>>>\n# 用functools.wraps的结果\n>>> get_content.__name__\n'get_content'\n>>> get_content.__doc__\n'Return page content'\n       实现装饰器时往往不知道调用方会怎么用，所以养成好习惯加上functools.wraps吧。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "6"}