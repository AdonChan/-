{"title": "【数据结构_浙江大学MOOC】第三四五讲 树 - 个人文章 ", "index": "数据结构,python", "content": "本篇为关于树的编程题，给出编译器 C++(g++)的解答。主要记录题意理解和代码学习过程。\n\n1 树的同构\n题目\n给定两棵树T1和T2。如果T1可以通过若干次左右孩子互换就变成T2，则我们称两棵树是“同构”的。例如图1给出的两棵树就是同构的，因为我们把其中一棵树的结点A、B、G的左右孩子互换后，就得到另外一棵树。而图2就不是同构的。\n\n现给定两棵树，请你判断它们是否是同构的。\n输入格式：输入给出2棵二叉树树的信息。对于每棵树，首先在一行中给出一个非负整数N (≤10)，即该树的结点数（此时假设结点从0到N−1编号）；随后N行，第i行对应编号第i个结点，给出该结点中存储的1个英文大写字母、其左孩子结点的编号、右孩子结点的编号。如果孩子结点为空，则在相应位置上给出“-”。给出的数据间用一个空格分隔。注意：题目保证每个结点中存储的字母是不同的。\n输出格式：如果两棵树是同构的，输出“Yes”，否则输出“No”。\n输入样例1（对应图1）：\n8\nA 1 2\nB 3 4\nC 5 -\nD - -\nE 6 -\nG 7 -\nF - -\nH - -\n8\nG - 4\nB 7 6\nF - -\nA 5 1\nH - -\nC 0 -\nD - -\nE 2 -\n输出样例1:\nYes\n输入样例2（对应图2）：\n8\nB 5 7\nF - -\nA 0 3\nC 6 -\nH - -\nD - -\nG 4 -\nE 1 -\n8\nD 6 -\nB 5 -\nE - -\nH - -\nC 0 2\nG - 3\nF - -\nA 1 4\n输出样例2:\nNo\n解读题目\n首先理解同构的意思，题目中的同构是指左右孩子相同即可。一种简单的判断两棵树是否同构的方法是看结点的儿子，如果都一样，则是同构。很明显，图1中的两棵树是同构的，而图2中的两棵树C下面的儿子就不同，因此它们不同构。\n本题要求我们输入两棵树的信息，判断它们是否同构。这棵二叉树的信息表示如输入样例所示，第一个数是整数，告诉我们这棵树有几个结点，对每个结点来说有三个信息：结点本身，左儿子，右儿子。左右儿子通过编号来表示，若为空则用-来表示。但要注意的是这里没有规定一定要从根节点来开始编号，即能以任意的顺序进行编号。所以要解这道题我们还需要进行判别根结点在哪里。\n我们需要的事情有三个：二叉树表示，建二叉树，同构判别。\n实现代码\n#include <iostream>\n#include <vector>\n \nusing namespace std;\n \n#define Max_Node 11\n#define END -1\n \ntypedef struct node\n{\n    char value;\n    int left;\n    int right;\n}Node;\n\n//获取树的输入，并将输入的字符合理转化成整型数字\nvoid CreateTree(vector<Node>& Tree,int N)\n{\n    \n    char value,left,right;\n    for (int i=0; i<N; ++i)\n    {\n        cin>>value>>left>>right;\n        Tree[i].value=value;\n        \n        if (left=='-')\n        {\n            Tree[i].left=END;\n        }else\n        {\n            Tree[i].left=left-'0';\n        }\n        \n        if (right=='-')\n        {\n            Tree[i].right=END;\n        }else\n        {\n            Tree[i].right=right-'0';\n        }\n    }\n}\n\n//寻找树的树根：树根没有其它的结点指向它\nint FindTreeRoot(vector<Node>& Tree,int N)\n{\n    int Flag[Max_Node];\n    for (int i=0; i<N; ++i)\n    {\n        Flag[i]=0;\n    }\n    \n    for (int i=0; i<N; ++i)\n    {\n        if (Tree[i].left!=END)\n        {\n            Flag[Tree[i].left]=1;\n        }\n        if (Tree[i].right!=END)\n        {\n            Flag[Tree[i].right]=1;\n        }\n    }\n    \n    int k;\n    for (k=0; k<N; ++k)\n    {\n        if (Flag[k]==0)\n        {\n            break;\n        }\n    }\n    return k;\n}\n\n//递归判断两树是否同构 \nbool IsOmorphic(int Root1,int Root2,vector<Node>& Tree1,vector<Node>& Tree2)\n{\n    if (Tree1[Root1].value==Tree2[Root2].value)\n    {\n        //两结点相等，并都是叶子结点\n        if (Tree1[Root1].left==END && Tree1[Root1].right==END && Tree2[Root2].left==END && Tree2[Root2].right==END)\n        {\n            return true;\n        }\n        \n        //以下四种情况：两个结点都是有一个孩子为空，另一个子树不空且这两个孩子相等的情形\n        if (Tree1[Tree1[Root1].left].value==Tree2[Tree2[Root2].left].value && Tree1[Root1].right==END && Tree2[Root2].right==END)\n        {\n            return IsOmorphic(Tree1[Root1].left, Tree2[Root2].left, Tree1, Tree2);\n        }\n        if (Tree1[Tree1[Root1].left].value==Tree2[Tree2[Root2].right].value && Tree1[Root1].right==END && Tree2[Root2].left==END)\n        {\n            return IsOmorphic(Tree1[Root1].left, Tree2[Root2].right, Tree1, Tree2);\n        }\n        if (Tree1[Tree1[Root1].right].value==Tree2[Tree2[Root2].left].value && Tree1[Root1].left==END && Tree2[Root2].right==END)\n        {\n            return IsOmorphic(Tree1[Root1].right, Tree2[Root2].left, Tree1, Tree2);\n        }\n        if (Tree1[Tree1[Root1].right].value==Tree2[Tree2[Root2].right].value && Tree1[Root1].left==END && Tree2[Root2].left==END)\n        {\n            return IsOmorphic(Tree1[Root1].right, Tree2[Root2].right, Tree1, Tree2);\n        }\n        \n        //以下两种：两个结点的孩子都相等的情形\n        if (Tree1[Tree1[Root1].left].value==Tree2[Tree2[Root2].left].value && Tree1[Tree1[Root1].right].value==Tree2[Tree2[Root2].right].value)\n        {\n            return (IsOmorphic(Tree1[Root1].left, Tree2[Root2].left, Tree1, Tree2))&&(IsOmorphic(Tree1[Root1].right, Tree2[Root2].right, Tree1, Tree2));\n        }\n        if (Tree1[Tree1[Root1].left].value==Tree2[Tree2[Root2].right].value && Tree1[Tree1[Root1].right].value==Tree2[Tree2[Root2].left].value)\n        {\n            return (IsOmorphic(Tree1[Root1].left, Tree2[Root2].right, Tree1, Tree2))&&(IsOmorphic(Tree1[Root1].right, Tree2[Root2].left, Tree1, Tree2));\n        }\n    }\n    //不符合以上7种情况表明这两棵树不同构\n    return false;\n}\n \nint main(int argc, const char * argv[])\n{\n    //输入两颗二叉树的信息\n    int N1=0;\n    cin>>N1;\n    vector<Node> Tree1(Max_Node);\n    CreateTree(Tree1,N1);\n    int N2=0;\n    cin>>N2;\n    vector<Node> Tree2(Max_Node);\n    CreateTree(Tree2,N2);\n    \n    \n    if (N1!=N2)\n    {\n        cout<<\"No\";\n    }else\n    {\n        if (N1==0)\n        {\n            cout<<\"Yes\";\n        }else\n        {\n           \n    \n            //建二叉树\n            int root1=FindTreeRoot(Tree1,N1);\n            int root2=FindTreeRoot(Tree2,N2);\n    \n            //判断是否同构\n            if (IsOmorphic(root1, root2, Tree1, Tree2))\n            {\n                cout<<\"Yes\";\n            }else\n            {\n                cout<<\"No\";\n            }\n        }\n    \n    }\n    return 0;\n}\n\n\n提交结果\n\n2 List Leaves\n题目\nGiven a tree, you are supposed to list all the leaves in the order of top down, and left to right.\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤10) which is the total number of nodes in the tree -- and hence the nodes are numbered from 0 to N−1. Then N lines follow, each corresponds to a node, and gives the indices of the left and right children of the node. If the child does not exist, a \"-\" will be put at the position. Any pair of children are separated by a space.\nOutput Specification:For each test case, print in one line all the leaves' indices in the order of top down, and left to right. There must be exactly one space between any adjacent numbers, and no extra space at the end of the line.\nSample Input:\n8\n1 -\n- -\n0 -\n2 7\n- -\n- -\n5 -\n4 6\nSample Output:\n4 1 5\n实现代码\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nint flag=0;//用于判断结果输出格式的\nstruct NodeInf{//树的节点信息，左右儿子下标\n    int LeftIndex;\n    int RightIndex;\n};\nstruct BinTreeNode{//树节点\n    int Element;//编号\n    struct BinTreeNode* Left;\n    struct BinTreeNode* Right;\n};\nint FindTreeHead(int book[],int n)//查找树根\n{\n    for(int i=0;i<n;i++)\n        if(book[i]==0)\n          return i;\n}\nvoid CreBinTreeAndPriLeaves(int treehead,struct NodeInf nodeinf[])//层序创建树，同时输出叶子\n{\n    struct BinTreeNode* BinTree;//树\n    struct BinTreeNode* Temp;\n    struct BinTreeNode* Queue[15];\n    int head=0,tail=0;\n    BinTree=(struct BinTreeNode*)malloc(sizeof(struct BinTreeNode));\n    BinTree->Element=treehead;\n    Queue[tail++]=BinTree;\n    while(head<tail){\n       if(nodeinf[Queue[head]->Element].LeftIndex!=-1){\n          Temp=(struct BinTreeNode*)malloc(sizeof(struct BinTreeNode));\n          Temp->Element=nodeinf[Queue[head]->Element].LeftIndex;\n          Queue[head]->Left=Temp;\n          Queue[tail++]=Temp;\n \n       }\n       else{\n          Queue[head]->Left=NULL;\n       }\n       if(nodeinf[Queue[head]->Element].RightIndex!=-1){\n          Temp=(struct BinTreeNode*)malloc(sizeof(struct BinTreeNode));\n          Temp->Element=nodeinf[Queue[head]->Element].RightIndex;\n          Queue[head]->Right=Temp;\n          Queue[tail++]=Temp;\n       }\n       else{\n          Queue[head]->Right=NULL;\n       }\n       if(Queue[head]->Left==NULL&&Queue[head]->Right==NULL){//判断是否为叶子\n            if(flag)\n              printf(\"%c\",' ');\n            printf(\"%d\",Queue[head]->Element);\n            flag=1;\n       }\n       head++;\n    }\n    putchar('\\n');\n    return;\n}\nint main()\n{\n    int n;\n    char ch;\n    struct NodeInf nodeinf[10];//存储节点信息\n    int treehead;//树根\n    int book[10];//标记是别人儿子的节点，则未标记的就为树根\n    memset(book,0,sizeof(book));\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){//题目的节点信息是按照节点编号来的，即0到n-1，题目没说出来......\n        getchar();\n        scanf(\"%c\",&ch);\n        if(ch-'0'>=0&&ch-'0'<=9){\n           nodeinf[i].LeftIndex=ch-'0';\n           book[ch-'0']=1;\n        }\n        else\n            nodeinf[i].LeftIndex=-1;\n        getchar();\n        scanf(\"%c\",&ch);\n        if(ch-'0'>=0&&ch-'0'<=9){\n            nodeinf[i].RightIndex=ch-'0';\n            book[ch-'0']=1;\n        }\n        else\n            nodeinf[i].RightIndex=-1;\n    }\n    treehead=FindTreeHead(book,n);//找树根\n    CreBinTreeAndPriLeaves(treehead,nodeinf);\n    return 0;\n}\n\n\n提交结果\n\n3 是否同一棵二叉搜索树\n题目\n给定一个插入序列就可以唯一确定一棵二叉搜索树。然而，一棵给定的二叉搜索树却可以由多种不同的插入序列得到。例如分别按照序列{2, 1, 3}和{2, 3, 1}插入初始为空的二叉搜索树，都得到一样的结果。于是对于输入的各种插入序列，你需要判断它们是否能生成一样的二叉搜索树。\n输入格式:输入包含若干组测试数据。每组数据的第1行给出两个正整数N (≤10)和L，分别是每个序列插入元素的个数和需要检查的序列个数。第2行给出N个以空格分隔的正整数，作为初始插入序列。最后L行，每行给出N个插入的元素，属于L个需要检查的序列。\n简单起见，我们保证每个插入序列都是1到N的一个排列。当读到N为0时，标志输入结束，这组数据不要处理。\n输出格式:对每一组需要检查的序列，如果其生成的二叉搜索树跟对应的初始序列生成的一样，输出“Yes”，否则输出“No”。\n输入样例:\n4 2\n3 1 4 2\n3 4 1 2\n3 2 4 1\n2 1\n2 1\n1 2\n0\n输出样例:\nYes\nNo\nNo\n解读题目\n本题要求我们对于输入的各种插入序列，判断它们是否能生成一样的二叉搜索树。在输入样例中包含三部分内容。第一部分是第一行的两个整数：4表示插入序列所包含的个数，即二叉树的结点个数，2表示后面有两个序列需要取比较和前面是否一样；第二部分是输入的序列；第三部分就是后面输入的若干组序列，它们要和第一组序列做比较。\n这道题实际上是两个序列是否对应相同搜索树的判别。\n实现代码\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef struct node Node;\n\nstruct node{\n    int left;\n    int right;\n};\n\n//初始化二叉树函数 \nvoid Init_Tree(vector<Node> &Tree,int N)\n{\n    for ( int i = 1 ; i <= N ; i++){\n        Tree[i].left = -1;\n        Tree[i].right = -1;\n    }\n}\n\n//建树函数 \nvoid Build_Tree(vector<Node> &Tree,int N)\n{\n    int value;\n    int flag = 0;\n    int root = 0;\n    int pre = 0;\n    while(N--){\n        cin>>value;\n        if ( flag == 0){\n            root = value;\n            pre = root;\n            flag = 1;\n        }else{\n            while(1){\n                //当前输入值比访问的上一个结点pre（pre最初为根结点）大，且pre有右孩子  \n                if (value > pre && Tree[pre].right != -1){\n                    pre = Tree[pre].right;\n                }\n                //当前输入值比访问的上一个结点pre（pre最初为根结点）大，且pre无右孩子  \n                if (value > pre && Tree[pre].right == -1){\n                    Tree[pre].right = value;\n                    pre = root;//下一次输入数字也从根结点开始比较  \n                    break;\n                }\n                //当前输入值比访问的上一个结点pre（pre最初为根结点）小，且pre有左孩子 \n                if (value<pre && Tree[pre].left != -1) \n                {  \n                    pre=Tree[pre].left;  \n                }  \n                //当前输入值比访问的上一个结点pre（pre最初为根结点）小，且pre无左孩子\n                if (value<pre && Tree[pre].left == -1)  \n                {  \n                    Tree[pre].left=value;  \n                    pre=root;//下一次输入数字也从根结点开始比较  \n                    break;  \n                }  \n            }\n        }\n    } \n}\n\n//比较两棵二叉搜索树是否相同的函数 \nbool Compare_Tree(vector<Node> &Tree1,vector<Node> &Tree2 ,int N)\n{\n    bool flag = true;\n    for ( int i = 1 ; i <= N ; i++){\n        if (!(Tree1[i].left == Tree2[i].left && Tree1[i].right == Tree2[i].right)){\n            flag = false;\n            break;\n        } \n    }\n    return flag;\n } \n\nint main()\n{\n    int N,L;\n    int flag = 0;\n    while(1){\n        cin>>N;\n        if ( N == 0){\n            break;\n        }\n        cin>>L;\n        vector<vector<Node>> Tree(L,vector<Node>(11));\n        vector<Node> tree(11); \n        Init_Tree(tree,N);\n        for ( int i = 0 ; i < L ; i++){\n            Init_Tree(Tree[i],N);\n        }\n        Build_Tree(tree,N);\n        for ( int i = 0 ; i < L ; i++){\n            Build_Tree(Tree[i],N);\n            if (Compare_Tree(tree,Tree[i],N)){\n                if ( flag == 0){\n                    flag = 1;\n                    cout<<\"Yes\";\n                }else{\n                    cout<<\"\\n\"<<\"Yes\";\n                }\n            }else{\n                if ( flag == 0){\n                    flag = 1;\n                    cout<<\"No\";\n                }else{\n                    cout<<\"\\n\"<<\"No\"; \n                }\n            }\n        }\n    }\n\n    return 0;\n}\n\n提交结果\n\n4 Root of AVL Tree\n题目\nAn AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules.\n\nNow given a sequence of insertions, you are supposed to tell the root of the resulting AVL tree.\nInput Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (≤20) which is the total number of keys to be inserted. Then N distinct integer keys are given in the next line. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, print the root of the resulting AVL tree in one line.\nSample Input 1:\n5\n88 70 61 96 120\n\nSample Output 1:\n70\n\nSample Input 2:\n7\n88 70 61 96 120 90 65\n\nSample Output 2:\n88\n\n实现代码\n#include<iostream>\nusing namespace std;\n \ntypedef int ElemType;\n \ntypedef struct AVLTreeNode *AVLTree;\nstruct AVLTreeNode {\n    ElemType data;\n    AVLTree left;\n    AVLTree right;\n    int height;\n};\n \nint GetHeight(AVLTreeNode *tree)\n{\n    if (tree == NULL)\n        return -1;                     //空树返回-1\n    else\n        return tree->height;\n}\n \nint Max(int a,int b)\n{\n    if (a > b)\n        return a;\n    else\n        return b;\n}\nAVLTree SingleLeftRotation(AVLTree A)\n{   /* 注意：A 必须有一个左子结点 B */\n    /* 将 A 与 B 做如图 4.35 所示的左单旋，更新 A 与 B 的高度，返回新的根结点 B */\n    AVLTree B = A->left;\n    A->left = B->right;\n    B->right = A;\n    A->height = Max(GetHeight(A->left), GetHeight(A->right)) + 1;\n    B->height = Max(GetHeight(B->left), A->height) + 1;\n    return B;\n}\n \nAVLTree SingleRightRotation(AVLTree A)\n{   /* 注意：A 必须有一个左子结点 B */\n    /* 将 A 与 B 做如图 4.35 所示的右单旋，更新 A 与 B 的高度，返回新的根结点 B */\n    AVLTree B = A->right;\n    A->right = B->left;\n    B->left = A;\n    A->height = Max(GetHeight(A->right), GetHeight(A->left)) + 1;\n    B->height = Max(GetHeight(B->right), A->height) + 1;\n    return B;\n}\n \nAVLTree DoubleLeftRightRotation(AVLTree A) \n{    /* 注意：A 必须有一个左子结点 B，且 B 必须有一个右子结点 C */   \n    /* 将 A、B 与 C 做如图 4.38 所示的两次单旋，返回新的根结点 C */          \n    A->left = SingleRightRotation(A->left); /*将 B 与 C 做右单旋，C 被返回*/\n    return SingleLeftRotation(A); /*将 A 与 C 做左单旋，C 被返回*/\n}\n \nAVLTree DoubleRightLeftRotation(AVLTree A)\n{    /* 注意：A 必须有一个左子结点 B，且 B 必须有一个右子结点 C */\n    /* 将 A、B 与 C 做如图 4.38 所示的两次单旋，返回新的根结点 C */\n    A->right = SingleLeftRotation(A->right); /*将 B 与 C 做右单旋，C 被返回*/\n    return SingleRightRotation(A); /*将 A 与 C 做左单旋，C 被返回*/\n}\n \nAVLTree AVL_Insertion(ElemType X, AVLTree T) \n{ \n    /* 将 X 插入 AVL 树 T 中，并且返回调整后的 AVL 树 */  \n    if (!T) \n    { \n        /* 若插入空树，则新建包含一个结点的树 */   \n        T = (AVLTree)malloc(sizeof(struct AVLTreeNode));   \n        T->data = X;   \n        T->height = 0;   \n        T->left = T->right = NULL; \n    } \n    /* if (插入空树) 结束 */\n    else if (X < T->data) \n    { \n        /* 插入 T 的左子树 */   \n        T->left = AVL_Insertion(X, T->left);         \n        if (GetHeight(T->left) - GetHeight(T->right) == 2)    \n            /* 需要左旋 */             \n            if (X < T->left->data)                 \n                T = SingleLeftRotation(T);      /* 左单旋 */             \n            else                 \n                T = DoubleLeftRightRotation(T); /* 左-右双旋 */ \n    }\n    /* else if (插入左子树) 结束 */       \n    else if (X > T->data) \n    { /* 插入 T 的右子树 */   \n        T->right = AVL_Insertion(X, T->right);         \n        if (GetHeight(T->left) - GetHeight(T->right) == -2)    /* 需要右旋 */             \n            if (X > T->right->data)                 \n                T = SingleRightRotation(T);     /* 右单旋 */             \n            else                 \n                T = DoubleRightLeftRotation(T); /* 右-左双旋 */ \n    } \n    /* else if (插入右子树) 结束 */\n    /* else X == T->Data，无须插入 */\n    T->height = Max(GetHeight(T->left), GetHeight(T->right)) + 1;  /*更新树高*/    \n    return T;\n}\n \nint main()\n{\n    int n;\n    cin >> n;\n    AVLTree root = NULL;\n \n    int x;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> x;\n        root = AVL_Insertion(x, root);\n    }\n \n    cout << root->data;\n    return 0;\n}\n\n\n提交结果\n\n5 堆中的路径\n题目\n将一系列给定数字插入一个初始为空的小顶堆H[]。随后对任意给定的下标i，打印从H[i]到根结点的路径。\n输入格式:每组测试第1行包含2个正整数N和M(≤1000)，分别是插入元素的个数、以及需要打印的路径条数。下一行给出区间[-10000, 10000]内的N个要被插入一个初始为空的小顶堆的整数。最后一行给出M个下标。\n输出格式:对输入中给出的每个下标i，在一行中输出从H[i]到根结点的路径上的数据。数字间以1个空格分隔，行末不得有多余空格。\n输入样例:\n5 3\n46 23 26 24 10\n5 4 3\n\n输出样例:\n24 23 10\n46 23 10\n26 10\n\n\n解读题目\n本题实际上是一个最小堆查询问题，在输入样例中给定5个数据构成一个最小堆，查询3次。第二行的5个数据就构成了一个最小堆，第三行的5 4 3分别代表最小堆中的下标。\n实现代码\n#include <iostream>\nusing namespace std;\n\nclass MinHeap{\n    private :\n        int* data;\n        int capacity;\n        int size;\n    public:\n        MinHeap(int N){\n            this->capacity = N;\n            this->size = 0;\n            this->data = new int[10000];\n            this->data[0] = -10000;\n        }\n\n        int GetSize(){\n            return this->size;\n        } \n\n        bool IsFull(){\n            return this->size == this->capacity;\n        }\n\n        bool IsEmpty(){\n            return this->size == 0;\n        }\n\n        void Insert(int data){\n            if ( this->IsFull()){\n                return ;\n            }\n            int i = ++this->size;\n            for ( ; this->data[i/2] > data ; i /= 2){\n                this->data[i] = this->data[i/2];\n            }\n            this->data[i] = data;\n        }\n\n        void Find_Path(int index){\n            if (index > this->size){\n                return;\n            }\n            bool flag = false;\n            for ( int i = index ; i >= 1 ; i /= 2){\n                if (!flag){\n                    cout<<this->data[i];\n                    flag = true;\n                }else{\n                    cout<<\" \"<<this->data[i];\n                }\n            }\n        }\n}; \n\nint main()\n{\n    int N,L;\n    cin>>N>>L;\n    MinHeap minheap(N);\n    for ( int i  = 1 ; i <= N ; i++){\n        int data;\n        cin>>data;\n        minheap.Insert(data);\n    }\n\n    for ( int i = 0 ; i < L ; i++){\n        int index;\n        cin>>index;\n        minheap.Find_Path(index);\n        cout<<\"\\n\"; \n    } \n    return 0;\n}\n\n提交结果\n\n\n参考链接：03-树1 树的同构 (25分)PTA List Leaves04-树4 是否同一棵二叉搜索树 (25分)Root of AVL Tree05-树7 堆中的路径 (25分)\n不足之处，欢迎指正。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "1"}