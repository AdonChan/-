{"title": "Python学习笔记 - 刘大牛要好好努力 ", "index": "python", "content": "基础\n局部变量与全局变量\n函数中使用的变量是局部的\n如果在外面的变量在函数中使用，需要加global关键字\nAPPLY = 100 # 全局变量\na = None\ndef fun():\n    global a    # 使用之前在全局里定义的 a\n    a = 20      # 现在的 a 是全局变量了\n    return a+100\n\nprint(APPLE)    # 100\nprint('a past:', a)  # None\nfun()\nprint('a now:', a)   # 20\n深拷贝与浅拷贝\nid()可以显示内存地址\n=\n列表可以通过引用其元素，改变对象自身(in-place change)。这种对象类型，称为可变数据对象(mutable object)，词典也是这样的数据类型。\n数字和字符串，不能改变对象本身，只能改变引用的指向，称为不可变数据对象(immutable object)。元组(tuple)，尽管可以调用引用元素，但不可以赋值，因此不能改变对象自身，所以也算是immutable object。\n浅拷贝\n当使用浅拷贝时，python只是拷贝了最外围的对象本身，内部的元素都只是拷贝了一个引用而已。看代码：\n>>> import copy\n>>> a=[1,2,3]\n>>> c=copy.copy(a)  #拷贝了a的外围对象本身,\n>>> id(c)\n4383658568\n>>> print(id(a)==id(c))  #id 改变 为false\nFalse\n>>> c[1]=22222   #此时，我去改变c的第二个值时，a不会被改变。\n>>> print(a,c)\n[1, 2, 3] [1, 22222, 3] #a值不变,c的第二个值变了，这就是copy和‘==’的不同\n\n深拷贝\ndeepcopy对外围和内部元素都进行了拷贝对象本身，而不是对象的引用。\n#copy.copy()\n\n>>> a=[1,2,[3,4]]  #第三个值为列表[3,4],即内部元素\n>>> d=copy.copy(a) #浅拷贝a中的[3，4]内部元素的引用，非内部元素对象的本身\n>>> id(a)==id(d)\nFalse\n>>> id(a[2])==id(d[2])\nTrue\n>>> a[2][0]=3333  #改变a中内部原属列表中的第一个值\n>>> d             #这时d中的列表元素也会被改变\n[1, 2, [3333, 4]]\n\n\n#copy.deepcopy()\n\n>>> e=copy.deepcopy(a) #e为深拷贝了a\n>>> a[2][0]=333 #改变a中内部元素列表第一个的值\n>>> e\n[1, 2, [3333, 4]] #因为时深拷贝，这时e中内部元素[]列表的值不会因为a中的值改变而改变\n例子\n创建二维数组\nmyList = [([0] * 3) for i in range(4)]\n#以上会出现浅拷贝，\n>>> lists = [[] for i in range(3)]\n>>> lists[0].append(3)\n>>> lists[1].append(5)\n>>> lists[2].append(7)\n#避免浅拷贝\nif\nvar = var1 if condition else var2\n如果 condition 的值为 True, 那么将 var1 的值赋给 var;如果为 False 则将 var2 的值赋给 var。\nif condition1:\n    true1_expressions\nelif condition2:\n    true2_expressions\nelif condtion3:\n    true3_expressions\nelif ...\n    ...\nelse:\n    else_expressions\n如果有多个判断条件，那可以通过 elif 语句添加多个判断条件，一旦某个条件为 True，那么将执行对应的 expression。\nfor\nrange使用\n在 Python 内置了工厂函数，range 函数将会返回一个序列，总共有三种使用方法\nrange(start, stop)\n其中 start 将会是序列的起始值，stop为结束值，但是不包括该值，类似 数学中的表达 [start, stop),左边为闭区间，右边为开区间。\nfor i in range(1, 10):\n    print(i)\n上述表达将会返回 1-9 所有整数，但不包含 10\nrange(stop)\n如果省略了 start 那么将从 0 开始，相当于 range(0, stop)\nrange(start, stop, step)\nstep 代表的为步长，即相隔的两个值得差值。从 start 开始，依次增加 step 的值，直至等于或者大于 stop\nfor i in range(0,13, 5):\n    print(i)\n将会输出 0, 5, 10。\n内置集合\nPython 共内置了 list、 tuple 、dict 和 set 四种基本集合，每个集合对象都能够迭代。\n迭代器和生成器\nwhile\n在 Python 中集合类型有 list、 tuple 、dict 和 set 等，如果该集合对象作为 while 判断语句， 如果集合中的元素数量为 0，那么将会返回 False, 否则返回 True。\na = range(10)\nwhile a:\n    print(a[-1])\n    a = a[:len(a)-1]\n上述程序将会返回 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 程序首先判断列表是否空，如果不为空，则 打印出最后一个内容，然后使用切片操作去掉最后一个元素，并更新列表；如此重复，直至列表为空。\n读取操作和文件操作\ninput\nvariable=input() 表示运行后，可以在屏幕中输入一个数字，该数字会赋值给自变量。\nprint\npython 中 print 字符串 要加''或者\"\"\n\\n 换行命令\n\\t 达到 tab 对齐\nopen\n使用 open 能够打开一个文件, open 的第一个参数为文件名和路径 ‘my file.txt’, 第二个参数为将要以什么方式打开它, 比如 w 为可写方式. 如果计算机没有找到 ‘my file.txt’ 这个文件, w 方式能够创建一个新的文件, 并命名为 my file.txt\nmy_file=open('my file.txt','w')   #用法: open('文件名','形式'), 其中形式有'w':write;'r':read.\nmy_file.write(text)               #该语句会写入先前定义好的 text\nmy_file.close()                   #关闭文件\nappend\nopen('my file.txt','a') 打开类型为 a ，a 即表示 append。\nfile.read()\n使用 file.read() 能够读取到文本的所有内容.\nfile= open('my file.txt','r') \ncontent=file.read()  \nprint(content)\n\n\"\"\"\"\nThis is my first test.\nThis is the second line.\nThis the third line.\nThis is appended file.    \n\"\"\"\"\nfile.readline()\n如果想在文本中一行行的读取文本, 可以使用 file.readline(), file.readline() 读取的内容和你使用的次数有关, 使用第二次的时候, 读取到的是文本的第二行, 并可以以此类推:\nfile= open('my file.txt','r') \ncontent=file.readline()  # 读取第一行\nprint(content)\n\n\"\"\"\"\nThis is my first test.\n\"\"\"\"\n\nsecond_read_time=file.readline()  # 读取第二行\nprint(second_read_time)\n\n\"\"\"\nThis is the second line.\n\"\"\"\nfile.readlines()\n如果想要读取所有行, 并可以使用像 for 一样的迭代器迭代这些行结果, 我们可以使用file.readlines(), 将每一行的结果存储在 list 中, 方便以后迭代。\nfile= open('my file.txt','r') \ncontent=file.readlines() # python_list 形式\nprint(content)\n\n\"\"\"\"\n['This is my first test.\\n', 'This is the second line.\\n', 'This the third line.\\n', 'This is appended file.']\n\"\"\"\"\n\n# 之后如果使用 for 来迭代输出:\nfor item in content:\n    print(item)\n    \n\"\"\"\nThis is my first test.\n\nThis is the second line.\n\nThis the third line.\n\nThis is appended file.\n\"\"\"\n基础数据结构\ntuple\n(tuple)\nlist\n[list]\n详细文档\ndict\n{dict}\n详细文档\nset\n函数\n默认参数\n函数声明只需要在需要默认参数的地方用 = 号给定即可, 但是要注意所有的默认参数都不能出现在非默认参数的前面。\n自调用\n如果想要在执行脚本的时候执行一些代码，比如单元测试，可以在脚本最后加上单元测试 代码，但是该脚本作为一个模块对外提供功能的时候单元测试代码也会执行，这些往往我们不想要的，我们可以把这些代码放入脚本最后：\nif __name__ == '__main__':\n    #code_here\n如果执行该脚本的时候，该 if 判断语句将会是 True,那么内部的代码将会执行。 如果外部调用该脚本，if 判断语句则为 False,内部代码将不会执行。\n可变参数\n顾名思义，函数的可变参数是传入的参数可以变化的，1个，2个到任意个。当然可以将这些 参数封装成一个 list 或者 tuple 传入，但不够 pythonic。使用可变参数可以很好解决该问题，注意可变参数在函数定义不能出现在特定参数和默认参数前面，因为可变参数会吞噬掉这些参数。\ndef report(name, *grades):\n    total_grade = 0\n    for grade in grades:\n        total_grade += grade\n    print(name, 'total grade is ', total_grade)\n定义了一个函数，传入一个参数为 name, 后面的参数 *grades 使用了 * 修饰，表明该参数是一个可变参数，这是一个可迭代的对象。该函数输入姓名和各科的成绩，输出姓名和总共成绩。所以可以这样调用函数 report('Mike', 8, 9)，输出的结果为 Mike total grade is 17, 也可以这样调用 report('Mike', 8, 9, 10)，输出的结果为 Mike total grade is 27\n关键字参数\n关键字参数可以传入0个或者任意个含参数名的参数，这些参数名在函数定义中并没有出现，这些参数在函数内部自动封装成一个字典(dict).\ndef portrait(name, **kw):\n    print('name is', name)\n    for k,v in kw.items():\n        print(k, v)\n定义了一个函数，传入一个参数 name, 和关键字参数 kw，使用了 ** 修饰。表明该参数是关键字参数，通常来讲关键字参数是放在函数参数列表的最后。如果调用参数portrait('Mike', age=24, country='China', education='bachelor') 输出:\nname is Mike\nage 24\ncountry China\neducation bachelor\n通过可变参数和关键字参数，任何函数都可以用 universal_func(*args, **kw) 表达。\n类\n类变量\n在类中，方法外的变量，所有实例对象公用\n实例变量\n在类方法中，一般在__init__中声明定义，对象之间独立\n内置类属性\n保护与私有\n单下划线是Protect\n双下划线是Private\n方法的默认值\n设置属性的默认值, 直接在def里输入即可，如下:\ndef __init__(self,name,price,height=10,width=14,weight=16):\n自定义模块\n自建一个模块\n这里和视频有点差别，我自己写了另外一个模块，是计算五年复利本息的模块,代码如下：模块写好后保存在默认文件夹：balance.py\nd=float(input('Please enter what is your initial balance: \\n'))\np=float(input('Please input what is the interest rate (as a number): \\n'))\nd=float(d+d*(p/100))\nyear=1\nwhile year<=5:\n    d=float(d+d*p/100)\n    print('Your new balance after year:',year,'is',d)\n    year=year+1\nprint('your final year is',d)\n调用自己的模块\n新开一个脚本，import balance\nimport balance\n\n\"\"\"\"\nPlease enter what is your initial balance:\n50000  # 手动输入我的本金\nPlease input what is the interest rate (as a number):\n2.3  #手动输入我的银行利息\nYour new balance after year: 1 is 52326.45\nYour new balance after year: 2 is 53529.95834999999\nYour new balance after year: 3 is 54761.14739204999\nYour new balance after year: 4 is 56020.653782067144\nYour new balance after year: 5 is 57309.12881905469\nyour final year is 57309.12881905469\n\"\"\"\"\n模块存储路径说明\n在Mac系统中，下载的python模块会被存储到外部路径site-packages，同样，我们自己建的模块也可以放到这个路径，最后不会影响到自建模块的调用。\n错误处理\ntry\n输出错误：try:, except ... as ...: 看如下代码\ntry:\n    file=open('eeee.txt','r')  #会报错的代码\nexcept Exception as e:  # 将报错存储在 e 中\n    print(e)\n\"\"\"\n[Errno 2] No such file or directory: 'eeee.txt'\n\"\"\"\n处理错误：会使用到循环语句。首先报错：没有这样的文件No such file or directory. 然后决定是否输入y, 输入y以后，系统就会新建一个文件（要用写入的类型），再次运行后，文件中就会写入ssss\ntry:\n    file=open('eeee.txt','r+')\nexcept Exception as e:\n    print(e)\n    response = input('do you want to create a new file:')\n    if response=='y':\n        file=open('eeee.txt','w')\n    else:\n        pass\nelse:\n    file.write('ssss')\n    file.close()\n\"\"\"\n[Errno 2] No such file or directory: 'eeee.txt'\ndo you want to create a new file:y\n\nssss  #eeee.txt中会写入'ssss'\n多进程和多线程\n正则表达式\nGUI\nReference\n\n笔记大纲参考莫烦PYTHON\n\n浅拷贝和深拷贝参考python 引用和对象理解和Python-copy()与deepcopy()区别\n\nlist和dict参考菜鸟教程\n\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "2"}