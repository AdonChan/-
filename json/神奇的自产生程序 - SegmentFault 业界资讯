{"title": "神奇的自产生程序 - SegmentFault 业界资讯 ", "index": "c,scala,lua,python,quine", "content": "最近读到冯·诺依曼的《Theory of Self-Reproducing Automata》的中译本，被自复制自动机理论深深吸引了！\n\n\n  问题（自产生程序）：编写一个程序，不读取任何输入，只把自己的源代码输出。\n\n\n\n\n这个问题是个非常本质的问题，跟使用什么编程语言无关（不要想到使用反射之类的东西）。\n\n试想，如果要输出自己的源代码，那么，显然，程序中应该有“print ...”语句。但 print 什么出来呢？如果硬要写的话就会变成：\n\nprint \"print \\\\\"print ......\\\\\"\"\n\n\n最后是一个无限循环。\n\n一般地，我们知道，如果程序 A 能产生程序 B ，那么 A 必须包含 B 的全部信息，而且应该比 B 的信息还多，因为还要包含额外的打印语句。也就是说，一般情况下，信息是减少的。而这个自产生程序，自己要包含自己的全部信息，从某种程度上已经具有生命的意味了。\n\n下面列出一些自产生程序及其思路。\n\n首先需要注意的是，使用编程语言本身的反射功能或者读取文件等做法都被视为 cheating ，比如这样的 bash 脚本：\n\n#!/bin/sh\ncat $0\n\n\n或者像这样的 javascript ：\n\nfunction a() { console.log(a.toString(), \"a()\"); } a()\n\n\n因为这些程序没有体现出自产生程序的递归和自指特性，或者结果严重依赖于编程语言的具体实现。\n\n不cheating的思路主要有以下几种：\n\n输出源代码在该语言中的转义\n\nPython ：\n\ns = \"'s = ' + repr(s) + '\\\\nprint(' + s + ')'\"\nprint('s = ' + repr(s) + '\\nprint(' + s + ')')\n\n\nLua 5.1 ：\n\ns = \"string.format('s = %q\\\\nprint(%s)', s, s)\"\nprint(string.format('s = %q\\nprint(%s)', s, s))\n\n\n另一个 Lua 版：\n\ns = \"s = %q\\\nprint(string.format(s, s))\"\nprint(string.format(s, s))\n\n\nScala ：\n\ndef e(s: String) = (\"\\\"\" + s.replace(\"\\\\\", \"\\\\\\\\\").replace(\"\\\"\", \"\\\\\\\"\") + \"\\\"\")\nval s = \"\\\"\\\"\\\"def e(s: String) = (\\\"\\\\\\\"\\\" + s.replace(\\\"\\\\\\\\\\\", \\\"\\\\\\\\\\\\\\\\\\\").replace(\\\"\\\\\\\"\\\", \\\"\\\\\\\\\\\\\\\"\\\") + \\\"\\\\\\\"\\\")\\\"\\\"\\\" + \\\"\\\\nval s = \\\" + e(s) + \\\"\\\\nprintln(\\\" + s + \\\")\\\"\"\nprintln(\"\"\"def e(s: String) = (\"\\\"\" + s.replace(\"\\\\\", \"\\\\\\\\\").replace(\"\\\"\", \"\\\\\\\"\") + \"\\\"\")\"\"\" + \"\\nval s = \" + e(s) + \"\\nprintln(\" + s + \")\")\n\n\n用某种方法 encode 源代码，使之不包含引号，然后还原出源代码\n\nBash ：\n\n#!/bin/sh\ns='\\x22#!/bin/sh\\ns=\\x27$s\\x27\\necho $(echo -e $s)\\x22'\necho \"#!/bin/sh\ns='$s'\necho $(echo -e $s)\"\n\n\nLua 5.2 使用 load()：\n\ns = \"a,q,b=string.char(39),string.char(34),string.char(92) return a..'s = '..q..a..'..s..'..a..q..b..'nprint('..a..'..load(s)()..'..a..')'..a\"\nprint('s = \"'..s..'\"\\nprint('..load(s)()..')')\n\n\nScala ：\n\n~~~~ {.hl}\nval s = \"%22val+s+%3D+%5C%22%22+%2B+s+%2B+%22%5C%22%5Cnprintln%28%22+%2B+java.net.URLDecoder.decode%28s%2C+%22UTF-8%22%29+%2B+%22%29%22\"\nprintln(\"val s = \\\"\" + s + \"\\\"\\nprintln(\" + java.net.URLDecoder.decode(s, \"UTF-8\") + \")\")\n~~~~\n\n使用 eval ：在 eval 的字符串中引用自己\n-------------------------------------\n\nLua load() 的另一种用法：\n\n```lua\ns = \"print(string.format('s = %q load(s)()', s))\" load(s)()\n\n\njs 的 eval()：\n\ns = \"q = String.fromCharCode(34); console.log('s = ' + q + s + q + '; eval(s)')\"; eval(s)\n\n\n使用语言中的更强的转义机制\n\n类似上面的第二种，但不用引号。\n\nLua 的 long string ：\n\nx = [[\"x = [\"..\"[\"..x..\"]\"..\"]\\nprint(\"..x..\")\"]]\nprint(\"x = [\"..\"[\"..x..\"]\"..\"]\\nprint(\"..x..\")\")\n\n\nScala 的三引号：\n\nval s = \"\"\"\"val s = \\\"\\\"\\\"\" + s + \"\\\"\\\"\\\"\\nprintln(\" + s + \")\"\"\"\"\nprintln(\"val s = \\\"\\\"\\\"\" + s + \"\\\"\\\"\\\"\\nprintln(\" + s + \")\")\n\n\n使用 C 的宏\n\n先执行传入的参数，再把参数变成字符串。\n\ngcc ：\n\n#define p(a) int main(){a;puts(\"p(\"#a\")\");return 0;}\np(puts(\"#define p(a) int main(){a;puts(\\\"p(\\\"#a\\\")\\\");return 0;}\"))\n\n\n至于它们是怎么实现的，就留给读者自己琢磨了。自产生程序也称为 Quine ，可以参考 Quine Page 。\n\n\n\nvia henix.info\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "1"}