{"title": "写一个简单的webserver - 个人文章 ", "index": "python", "content": "基于 Python3 写的极简版 webserver。用于学习 HTTP协议，及 WEB服务器 工作原理。笔者对 WEB服务器 的工作原理理解的比较粗浅，仅是基于个人的理解来写的，存在很多不足和漏洞，目的在于给大家提供一个写 webserver 的思路。项目GitHub地址：https://github.com/hanrenguang/simple-webserver。\nWEB服务器原理\n学过计网的同学应该都知道 HTTP协议 是在 TCP协议 之上实现的。浏览器与服务器之间的通信首先是建立 TCP 连接，再进行请求和响应报文的传输。服务器是属于被动的一方，当浏览器发起请求的时候，服务器才能和浏览器通信，在此之前，服务器都处于一个等待监听的状态。\nsocket连接\n实现服务器的第一步是建立一个 socket 连接，socket 套接字是对 TCP/UDP协议 的一个封装，Python 就自带有 socket 模块，所以使用起来很方便。\nimport socket\n\nsk = socket.socket(\n    socket.AF_INET, \n    socket.SOCK_STREAM\n)\n\n# 监听本地 8888 端口\nhost = '127.0.0.1'\nport = 8888\n\nsk.bind((host, port))\nsk.listen(5)\n\nwhile True:\n    try:\n        clientSk, addr = sk.accept()\n        print(\"address is: %s\" % str(addr))\n\n        req = clientSk.recv(1024)\n\n        clientSk.sendall('...')\n        clientSk.close()\n\n    except Exception as err:\n        print(err)\n        clientSk.close()\n这是一个极简的 socket-server，需要注意的是，我们仅实现了 TCP协议 的部分。\n解析HTTP请求\n拿到浏览器的请求很简单，clientSk.recv() 即可获取请求报文，而些数据我们无法直接拿来用，因为它是基于 HTTP协议 封装的数据，在我们进行下一步操作前，需要对请求报文“解封”。而在此之前，我们需要了解请求报文的格式。最快捷的方式呢，是打开浏览器（以 chrome 为例），随便打开百度啥的，F12 打开开发者工具，在 Network 一栏就可以观察到。大概长下面这样：\nGET / HTTP/1.1\nHost: xxx\nConnection: xxx\nCache-Control: xxx\nUpgrade-Insecure-Requests: xxx\nUser-Agent: xxx\nAccept: xxx\nAccept-Encoding: xxx\nAccept-Language: xxx\nCookie: xxx\n我们把关注点放在第一行，GET 方法，请求的资源路径为 /，使用的协议是 HTTP1.1，之后就是一回车换行符 \\r\\n。所以我们对报文的解析如下（存在许多不足之处）：\n# 第一步先对数据进行解码 decode()，\n# 再以行为单位进行分割\nrequestList = clientSk.recv(1024).decode().split(\"\\r\\n\")\n\n# 调用写好的函数对其进行解析\nparseReq(requestList)\n\n# 解析请求报文\ndef parseReq(reqList):\n    # 保存解析结果\n    parseRet = {}\n\n    # 请求的方法，如 GET\n    method = reqList[0].split(' ')[0]\n    # 请求的资源路径，如 '/'\n    sourcePath = reqList[0].split(' ')[1]\n\n    parseRet['method'] = method\n    parseRet['sourcePath'] = sourcePath\n\n    i = len(reqList) - 1\n\n    # 以 key: value 的形式保存解析结果\n    while i:\n        if len(reqList[i].split(':')) == 1:\n            i = i - 1\n            continue\n\n        idx = reqList[i].find(':')\n        key, value = reqList[i][0:idx], reqList[i][idx+1:]\n        parseRet[key] = value.strip()\n        i = i - 1\n    \n    return parseRet\n构造响应报文\n拿到了请求报文并将其解析后，我们可以开始构造响应报文的内容了，以请求静态资源为例，假设请求报文第一行为 GET /index.html HTTP/1.1。那么我首先要做的就是先获取路径为 /index.html 的文件内容：\n# 获取资源内容\ntry:\n    f = open(path, 'r')\n    while True:\n        chunk = f.read(1024)\n        if not chunk:\n            f.close()\n            break;\n        content += chunk\nexcept:\n    pass\n那接下来就是构造响应报文了，同理可以观察 HTTP 响应报文的格式，在此就不举例了，直接上代码：\ntry:\n    f = open(path, 'r')\n    while True:\n        chunk = f.read(1024)\n        if not chunk:\n            f.close()\n            break;\n        content += chunk\nexcept:\n    pass\n\n# 省略了大部分头部信息\nheaders = 'HTTP/1.1 200 OK\\r\\n'\ncontentType = 'Content-Type: text/html; charset=utf-8\\r\\n'\ncontentLen = 'Content-Length: ' + str(len(content)) + '\\r\\n'\n\n# 组合成响应报文 res\nres = headers + contentType + contentLen + '\\r\\n' + content\n\n# 编码后发送给浏览器，\n# 至此，本次通信结束\nclientSk.sendall(res.encode(encoding='UTF-8'))\nclientSk.close()\n示例\n到项目GitHub：https://github.com/hanrenguang/simple-webserver，下载本项目到本地，双击 server.py，并访问 http://localhost:8888/index.html，你应该会看到十分亲切的 Hello world!。\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "3"}