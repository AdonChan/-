{"title": "Python生成器next方法和send方法区别 - bingo ", "index": "python", "content": "生成器简介\npython中，含有yield关键字的对象就是一个生成器，每次调用next方法时会执行到yield后面的语句，然后返回yield后面代码块的执行结果。其实也可以调用send方法下面给个例子方便理解。\nnext方法\ndef foo():\n    bar_a = yield 1         # bar_a是语句块(yield 1)的返回值，默认为None\n    bar_b = yield bar_a\n    yield \"最后一个值，再迭代就要报StopIteration了\"\n\nf = foo()                   # 创建生成器，此时没有执行foo()里的任何语句\nprint(next(f))              # 从foo()里进入，一直执行到(yield 1)处，此时变量bar_a还没有创建\nprint(next(f))              # 先将语句块(yield 1)的返回值赋值个bar_a，此时bar_a的值是None。\n                            # 然后执行到语句块(yield bar_a)，bar_b也还没有被创建\nprint(next(f)\n\n\n输出:\n>>>1\n>>>None\n>>>最后一个值，再迭代就要报StopIteration了\n\n可以看出，f = foo()创建生成器时，每次执行到yield时，会跳出去并将yield关键字后面的内容返回给调用者。下一次有别的调用者再次调用生成器时，会先恢复生成器上次的机器状态，再接着执行指导遇到yield或者元素迭代完毕。而且我们可以看到bar_a和bar_b是语句yield 1和yield bar_a的返回值，注意：不是生成器的返回值。这里有个比较绕的地方，我们用bar_a = yield 1做分析：\n\n1是生成器的返回值。因为生成器返回yield后面的代码块\n\nbar_a是语句yield 1的返回值，这就好比我们写\na = print('my lover')\nprint('a的值是:', a)\n会输出：\n>>>my lover\n>>>a的值是: None\n\n\n\nsend方法\ndef foo():\n    bar_a = yield 1\n    bar_b = yield bar_a\n    yield \"最后一个值，再迭代就要报StopIteration了\"\n\nf = foo()\nprint(f.send(None))\nprint(f.send(\"my lover\"))\nprint(next(f))\n输出：\n>>>1\n>>>my lover\n>>>最后一个值，再迭代就要报StopIteration了\n这里f.send(None)是初始化生成器，和next(f)的效果一模一样。但是不推荐这么写，因为不规范。注意输出的第二行是字符串my lover，而不是None。这是因为send函数带有一个参数，这个参数会覆盖yield 1语句的返回值，也就是bar_a的值现在不是None了。\nFAQ\n官网提到，当我们创建一个生成器时，第一次调用只能用next()或者send(None)。因为此时send传入其他参数也没有yield语句去接收。这句话我看不懂，说的好像传入None就有yield来接收似的。各位如果明白的欢迎指点。原文和传送门如下：\n官网传送门\nResumes the execution and “sends” a value into the generator function. The value argument becomes the result of the current yield expression. The send() method returns the next value yielded by the generator, or raises StopIteration if the generator exits without yielding another value. When send() is called to start the generator, it must be called with None as the argument, because there is no yield expression that could receive the value.\nGoogle翻译版本：恢复执行并将值“发送”到生成器函数中。所述 值参数成为当前产量表达的结果。该 send()方法返回由生成器产生的下一个值，或者StopIteration如果生成器退出而不产生另一个值则引发。当send()调用启动生成器时，必须将其None作为参数调用，因为没有可以接收该值的yield表达式。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}