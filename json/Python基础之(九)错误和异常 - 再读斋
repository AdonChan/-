{"title": "Python基础之(九)错误和异常 - 再读斋 ", "index": "python", "content": "错误\n>>> for i in range(10)\n File \"<stdin>\", line 1\n   for i in range(10)\n                    ^\nSyntaxError: invalid syntax\n上面那句话因为缺少冒号:，导致解释器无法解释，于是报错。这个报错行为是由Python的语法分析器完成的，并且检测到了错误所在文件和行号（File \"<stdin>\", line 1），还以向上箭头^标识错误位置（后面缺少:），最后显示错误类型。\n另一种常见错误是逻辑错误。逻辑错误可能是由于不完整或者不合法的输入导致，也可能是无法生成、计算等，或者是其它逻辑问题。\n当Python检测到一个错误时，解释器就无法继续执行下去，于是抛出提示信息，即为异常。\n异常\n下表中列出常见的异常\n\n\n异常\n描述\n\n\n\nNameError\n尝试访问一个没有申明的变量\n\n\nZeroDivisionError\n除数为0\n\n\nSyntaxError\n语法错误\n\n\nIndexError\n索引超出序列范围\n\n\nKeyError\n请求一个不存在的字典关键字\n\n\nIOError\n输入输出错误（比如你要读的文件不存在）\n\n\nAttributeError\n尝试访问未知的对象属性\n\n\n\nNameError\n>>> bar\nTraceback (most recent call last):\n File \"<stdin>\", line 1, in <module>\nNameError: name 'bar' is not defined\nPython中变量虽然不需在使用变量之前先声明类型，但也需要对变量进行赋值，然后才能使用。不被赋值的变量，不能再Python中存在，因为变量相当于一个标签，要把它贴到对象上才有意义。\nZeroDivisionError\n>>> 1/0\nTraceback (most recent call last):\n File \"<stdin>\", line 1, in <module>\nZeroDivisionError: integer division or modulo by zero\nSyntaxError\n    >>> for i in range(10)\n      File \"<stdin>\", line 1\n        for i in range(10)\n                         ^\n    SyntaxError: invalid syntax\n这种错误发生在Python代码编译的时候，当编译到这一句时，解释器不能讲代码转化为Python字节码，就报错。\nIndexError和KeyError\n    >>> a = [1,2,3]\n    >>> a[4]\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    IndexError: list index out of range\n    \n    >>> d = {\"python\":\"itdiffer.com\"}\n    >>> d[\"java\"]\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    KeyError: 'java'\nIOError\n    >>> f = open(\"foo\")\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    IOError: [Errno 2] No such file or directory: 'foo'\nAttributeError\n    >>> class A(object): pass        #Python 3: class A: pass\n    ... \n    >>> a = A()\n    >>> a.foo\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    AttributeError: 'A' object has no attribute 'foo'\n处理异常\n#!/usr/bin/env python\n# coding=utf-8\n\nwhile 1:\n   print \"this is a division program.\"\n   c = raw_input(\"input 'c' continue, otherwise logout:\")\n   if c == 'c':\n       a = raw_input(\"first number:\")\n       b = raw_input(\"second number:\")\n       try:\n           print float(a)/float(b)\n           print \"*************************\"\n       except ZeroDivisionError:\n           print \"The second number can't be zero!\"\n           print \"*************************\"\n   else:\n       break\ntry...except\n对于上述程序，只看try和except部分，如果没有异常发生，except子句在try语句执行之后被忽略；如果try子句中有异常可，该部分的其它语句被忽略，直接跳到except部分，执行其后面指定的异常类型及其子句。\nexcept后面也可以没有任何异常类型，即无异常参数。如果这样，不论try部分发生什么异常，都会执行except。\n在except子句中，可以根据异常或者别的需要，进行更多的操作。比如：\n#!/usr/bin/env python\n# coding=utf-8\n\nclass Calculator(object):\n   is_raise = True\n   def calc(self, express):\n       try:\n           return eval(express) #运行表达式\n       except ZeroDivisionError:\n           if self.is_raise:\n               print \"zero can not be division.\"        #Python 3:  \"zero can not be division.\"\n           else:\n               raise #抛出异常信息\n处理多个异常\nPython 2:\n\n    #!/usr/bin/env python\n    # coding=utf-8\n\n    while 1:\n        print \"this is a division program.\"\n        c = raw_input(\"input 'c' continue, otherwise logout:\")\n        if c == 'c':\n            a = raw_input(\"first number:\")\n            b = raw_input(\"second number:\")\n            try:\n                print float(a)/float(b)\n                print \"*************************\"\n            except ZeroDivisionError:\n                print \"The second number can't be zero!\"\n                print \"*************************\"\n            except ValueError:\n                print \"please input number.\"\n                print \"************************\"\n        else:\n            break\n            \n or\n \nexcept (ZeroDivisionError, ValueError): #括号内也可以包含多个异常\n   print \"please input rightly.\"\n   print \"********************\"\n打印异常，但程序不中断\n    while 1:\n        print \"this is a division program.\"\n        c = raw_input(\"input 'c' continue, otherwise logout:\")\n        if c == 'c':\n            a = raw_input(\"first number:\")\n            b = raw_input(\"second number:\")\n            try:\n                print float(a)/float(b)\n                print \"*************************\"\n            except (ZeroDivisionError, ValueError), e: #类似java\n                print e\n                print \"********************\"\n        else:\n            break\n\nPython 3:\n\n    while 1:\n        print(\"this is a division program.\")\n        c = input(\"input 'c' continue, otherwise logout:\")\n        if c == 'c':\n            a = input(\"first number:\")\n            b = input(\"second number:\")\n            try:\n                print(float(a)/float(b))\n                print(\"*************************\")\n            except (ZeroDivisionError, ValueError) as e:\n                print(e)\n                print(\"********************\")\n        else:\n            break\nelse语句\n    >>> try:\n    ...     print \"I am try\"        #Python 3: print(\"I am try\")，\n    ... except:                \n    ...     print \"I am except\"\n    ... else:                     #处理except就不会运行else\n    ...     print \"I am else\"\n    ... \n    I am try\n    I am else\nelse语句应用，只有输入正确的内容，循环才会终止\n    #!/usr/bin/env python\n    # coding=utf-8\n    while 1:\n        try:\n            x = raw_input(\"the first number:\")\n            y = raw_input(\"the second number:\")\n\n            r = float(x)/float(y)\n            print r\n        except Exception, e:  #python3为 Exception as e:\n            print e\n            print \"try again.\"\n        else:\n            break\nfinally语句\n如果有了finally，不管前面执行的是try，还是except，最终都要执行它。类似java\n    >>> x = 10\n\n    >>> try:\n    ...     x = 1/0\n    ... except Exception, e:        #Python 3:  except Exception as e:\n    ...     print e        #Python 3: print(e)\n    ... finally:\n    ...     print \"del x\"        #Python 3:  print(e)\n    ...     del x\n    ... \n    integer division or modulo by zero\n    del x\nassert\nassert是一句等价于布尔真的判定，发生异常就意味着表达式为假。当程序运行到某个节点的时候，就断定某个变量的值必然是什么，或者对象必然拥有某个属性等，简单说就是断定什么东西必然是什么，如果不是，就抛出异常。\n#!/usr/bin/env python\n# coding=utf-8\n            \nif __name__ == \"__main__\":\n    a = 8\n    assert a < 0\n    print a\n    \nTraceback (most recent call last):\n  File \"/Users/liuguoquan/Documents/workspace/PythonDemo/main.py\", line 6, in <module>\n    assert a < 0\nAssertionError\n这就是断言assert的引用。什么是使用断言的最佳时机？有文章做了总结：\n如果没有特别的目的，断言应该用于如下情况：\n\n防御性的编程\n运行时对程序逻辑的检测\n合约性检查（比如前置条件，后置条件）\n程序中的常量\n检查文档\n\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "6"}