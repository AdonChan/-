{"title": "Python变量命名与作用域的坑 - Drinkey's warehouse ", "index": "python", "content": "使用python有些年头了，自认为对Python的基本知识很了解了，今天发生的一件事让我对Python有了更多的认识，写成文章做个记录。\n同事让我帮忙看以下一段代码，具体内容和函数名字可以不用太过在意，命名上做了一些特殊处理，但是不影响代码逻辑和要表达的意思。\nfor循环中当node_type为fb时，将FBX对象返回并作为全局变量dut(node_name的内容是字符串dut)，接下来print dut，报错。\ndef setup_module(module):\n    with step('Set_setup'):\n        function_1_run(topo_info)\n        function_2_run(topo_info)\n        function_3_run(topo_info, set_resource, 'device_config')\n        for node in topo_info.nodes:\n            if node.type == 'fb':\n                globals()[node.name] = FBX(node.manage_ip,'admin','111111')\n                print node.name\n                print globals()[node.name]\n                print dut\n            else:\n                globals()[node.name] = Device()\n            globals()[node.name].node_info = node\n\n        if not get_config_file(topo_info, set_resource, 'device_config'):\n            test = dut\n            print test\n            with cli_ctx(dut) as dut:\n                dut.cli.cmd_list = \\\n                            [\n                                'configure',\n                                'interface fastEthernet 2',\n                                'ip address 192.168.1.5/24'\n                            ]\n                dut.cli.exec_cmd()\n                log.info('cli_ctx 1 end')\n        export_firebox_topo(topo_info, set_resource, 'device_config')\n错误信息如下：\n==================================== ERRORS ====================================\n___________________ ERROR at setup of some_module_1 ___________________\n\nmodule = <module 'some_name_python' from '/path/to/file/some_name_python.py'>\n\n    def setup_module(module):\n        with step('Set_setup'):\n            function_1_run(topo_info)\n            function_2_run(topo_info)\n            function_3_run(topo_info, set_resource, 'device_config')\n            for node in topo_info.nodes:\n                if node.type == 'fb':\n                    globals()[node.name] = FBX(node.manage_ip,'admin','111111')\n                    print node.name\n                    print globals()[node.name]\n>                   print dut\nE                   UnboundLocalError: local variable 'dut' referenced before assignment\n\nsome_name_python.py:54: UnboundLocalError\n========================== 1 error in 155.62 seconds ===========================\n同事提到，如果将with cli_ctx as dut这个block删除掉，代码执行正常。\n听到这里，我的第一反应是变量作用域的问题，但是也无法道出其中原委，于是建议同事，将context manager那一段代码改成with cli_ctx as d，重新尝试一下是否有问题，同时我在网上继续搜索相关的原因，之后由结果和理论结合分析问题的原因。\n幸运的是，代码修改以后，执行正常，我也找到了一些文章来解释这个问题，我的第一感觉也没有错，的确是变量作用域的问题，代码在执行过程中，print dut实际上是在访问Local variable，而不是我们期望的global variable dut。\n参考Python的官方文档和搜索到的资料，总结出具体原因如下。\n\n当搜索一个变量的时候，先从局部作用域开始搜索，如果在局部作用域没有找到那个变量，就会在全局变量中找这个变量，如果找不到抛出异常Unbound-LocalError。\n如果内部函数有引用外部函数的同名变量或者全局变量，并且对这个变量有修改，那么python会认为它是一个局部变量。因为对变量的定义在代码块以外，当前代码块中没有变量的定义和赋值，所以报错。\n在我们的代码中，全局变量dut虽然创建了，但是由于在函数代码块中，下文中有context manager cli_ctx对变量dut进行了赋值操作，导致在函数block中，dut成为了局部变量，而非全局变量。\n对变量赋值的操作=是很明显的语句，其他不是那么明显的赋值操作有：for循环中的赋值，except语句中的赋值，with...as...{var}中的var。\n\n大坑啊，基础不够牢靠还是。\nReference\nPython 2.7.13 Documentation - Language Reference - 4. Execution ModelStackoverflow - Short Description of the Scoping Rules?\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}