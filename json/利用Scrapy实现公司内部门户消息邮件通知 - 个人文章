{"title": "利用Scrapy实现公司内部门户消息邮件通知 - 个人文章 ", "index": "python,scrapy", "content": "一、项目背景\n　　我本人所在公司是一个国有企业，自建有较大的内部网络门户群，几乎所有部门发布各类通知、工作要求等消息都在门户网站进行。由于对应的上级部门比较多，各类通知通告、领导讲话等内容类目繁多，要看一遍真需要花费点时间。更重要的是有些会议通知等时效性比较强的消息一旦遗漏错过重要会议就比较麻烦。为了改变这种状况，就想建立一个内部网络消息跟踪、通知系统。\n二、基本功能\n　　主要功能：系统功能比较简单，主要就是爬取内部网络固定的一些通知页面，发现新的通知就向指定的人发送通知邮件。　　涉及到的功能点：　　1.常规页面请求　　2.post请求　　3.数据存储　　4.识别新消息　　5.邮件通知　　6.定时启动，循环运行\n三、详细说明\n（一）文件结构\n\n　　上图显示了完成状态的文件结构，与新建的scrapy项目相比增加的文件有两部分：　　一是spiders目录下的6个爬虫文件，对应了6个栏目，以后根据需要还会再增加；　　二是涉及定时启动、循环运行功能的几个文件，分别是commands文件夹、noticeStart.py、setup.py、autorun.bat\n（二）各部分代码\n1. items.py\nimport scrapy\n\nclass JlshNoticeItem(scrapy.Item):\n    # define the fields for your item here like:\n    # name = scrapy.Field()\n    noticeType = scrapy.Field()     #通知类别\n    noticeTitle = scrapy.Field()    #通知标题\n    noticeDate = scrapy.Field()     #通知日期\n    noticeUrl = scrapy.Field()      #通知URL\n    noticeContent = scrapy.Field()  #通知内容\n2. spider\n　　篇幅关系，这里只拿一个爬虫做例子，其它的爬虫只是名称和start_url不同，下面代码尽量做到逐句注释。\n代码\nfrom scrapy import Request\nfrom scrapy import FormRequest\nfrom scrapy.spiders import Spider\nfrom jlsh_notice.items import JlshNoticeItem\nfrom jlsh_notice.settings import DOWNLOAD_DELAY\nfrom scrapy.crawler import CrawlerProcess\nfrom datetime import date\nimport requests\nimport lxml\nimport random\nimport re\n#=======================================================\nclass jlsh_notice_spider_gongsitongzhi(Spider):\n    #爬虫名称\n    name = 'jlsh_gongsitongzhi'\n    \n    start_urls = [\n        'http://www.jlsh.petrochina/sites/jlsh/news/inform/Pages/default.aspx', #公司通知\n    ]\n#=======================================================\n    #处理函数\n    def parse(self, response):\n        noticeList = response.xpath('//ul[@class=\"w_newslistpage_list\"]//li')\n#=======================================================\n        #创建item实例\n        item = JlshNoticeItem()\n        for i, notice in enumerate(noticeList):\n            item['noticeType'] = '公司通知'\n\n            item['noticeTitle'] = notice.xpath('.//a/@title').extract()[0]\n\n            item['noticeUrl'] = notice.xpath('.//a/@href').extract()[0]\n#=======================================================\n            dateItem = notice.xpath('.//span[2]/text()').extract()[0]\n            pattern = re.compile(r'\\d+')\n            datetime = pattern.findall(dateItem)\n            yy = int(datetime[0])+2000\n            mm = int(datetime[1])\n            dd = int(datetime[2])\n            item['noticeDate'] = date(yy,mm,dd)\n#=======================================================\n            content_html = requests.get(item['noticeUrl']).text\n            content_lxml = lxml.etree.HTML(content_html)\n            content_table = content_lxml.xpath( \\\n                '//div[@id=\"contentText\"]/div[2]/div | \\\n                //div[@id=\"contentText\"]/div[2]/p')\n            \n            \n            item['noticeContent'] = []\n            for j, p in enumerate(content_table):\n                p = p.xpath('string(.)')\n                #print('p:::::',p)\n                p = p.replace('\\xa0',' ')\n                p = p.replace('\\u3000', ' ')\n                item['noticeContent'].append(p)\n\n            yield item\n#=======================================================\n        pages = response.xpath('//div[@class=\"w_newslistpage_pager\"]//span')\n        nextPage = 0\n        for i, page_tag in enumerate(pages):\n            page = page_tag.xpath('./a/text()').extract()[0]\n            page_url = page_tag.xpath('./a/@href').extract()\n            if page == '下一页>>':\n                pattern = re.compile(r'\\d+')\n                page_url = page_url[0]\n                nextPage = int(pattern.search(page_url).group(0))\n                break\n#=======================================================\n        if nextPage > 0 :\n            postUrl = self.start_urls[0]\n            formdata = {\n                'MSOWebPartPage_PostbackSource':'',\n                'MSOTlPn_SelectedWpId':'',\n                'MSOTlPn_View':'0',\n                'MSOTlPn_ShowSettings':'False',\n                'MSOGallery_SelectedLibrary':'',\n                'MSOGallery_FilterString':'',\n                'MSOTlPn_Button':'none',\n                '__EVENTTARGET':'',\n                '__EVENTARGUMENT':'',\n                '__REQUESTDIGEST':'',\n                'MSOSPWebPartManager_DisplayModeName':'Browse',\n                'MSOSPWebPartManager_ExitingDesignMode':'false',\n                'MSOWebPartPage_Shared':'',\n                'MSOLayout_LayoutChanges':'',\n                'MSOLayout_InDesignMode':'',\n                '_wpSelected':'',\n                '_wzSelected':'',\n                'MSOSPWebPartManager_OldDisplayModeName':'Browse',\n                'MSOSPWebPartManager_StartWebPartEditingName':'false',\n                'MSOSPWebPartManager_EndWebPartEditing':'false',\n                '_maintainWorkspaceScrollPosition':'0',\n                '__LASTFOCUS':'',\n                '__VIEWSTATE':'',\n                '__VIEWSTATEGENERATOR':'15781244',\n                'query':'',\n                'database':'GFHGXS-GFJLSH',\n                'sUsername':'',\n                'sAdmin':'',\n                'sRoles':'',\n                'activepage':str(nextPage),\n                '__spDummyText1':'',\n                '__spDummyText2':'',\n                '_wpcmWpid':'',\n                'wpcmVal':'',\n            }\n\n            yield FormRequest(postUrl,formdata=formdata, callback=self.parse)\n\n说明，以下说明要配合上面源码来看，不单独标注了\nstart_urls #要爬取的页面地址，由于各个爬虫要爬取的页面规则略有差异，所以做了6个爬虫，而不是在一个爬虫中写入6个URL。通过查看scrapy源码，我们能够看到，start_urls中的地址会传给一个内件函数start_request（这个函数可以根据自己需要进行重写），start_request向这个start_urls发送请求以后，所得到的response会直接转到下面parse函数处理。\nxpath ，下图是页面源码：通过xpath获取到response中class类是'w_newslistpage_list'的ul标签下的所有li标签，这里所得到的就是通知的列表，接下来我们在这个列表中做循环。\n\n先看下li标签内的结构：notice.xpath('.//a/@title').extract()[0] #获取li标签内a标签中的title属性内容，这里就是通知标题notice.xpath('.//a/@href').extract()[0] #获取li标签内a标签中的href属性内容，这里就是通知链接notice.xpath('.//span[2]/text()').extract()[0] #获取li标签内第二个span标签中的内容，这里是通知发布的日期接下来几行就是利用正则表达式讲日期中的年、月、日三组数字提取出来，在转换为日期类型存入item中。\n\n再下一段，是获得通知内容，这里其实有两种方案，一个是用scrapy的request发送给内部爬虫引擎，得到另外一个response后再进行处理，另一种就是我现在这样直接去请求页面。由于内容页面比较简单，只要获得html代码即可，所以就不麻烦scrapy处理了。request.get得到请求页面的html代码利用lxml库的etree方法格式化html为xml结构利用xpath获取到div[@id=\"contentText\"]内所有p标签、div标签节点。（可以得到99%以上的页面内容）所得到的所有节点将是一个list类型数据，所有我们做一个for in循环p.xpath('string(.)') 是获取到p标签或div标签中的所有文本，而无视其他html标签。用replace替换到页面中的半角、全角空格（xa0、u3000）每得到一行清洗过的数据，就将其存入item['noticeContent']中最后将item输出\n在scrapy中，yield item后，item会提交给scrapy引擎，再又引擎发送给pipeline处理。pipeline一会再说。\n接下来的代码就是处理翻页。这里的页面翻页是利用js提交请求完成的，提交请求后，会response一个新的页面列表首先利用xpath找到页面导航栏的节点，在获取到的所有节点中做for in循环，直到找到带有“下一页”的节点，这里有下一页的页码，还是利用正则表达式来得到它，并将其转为int类型。\n\nyield FormRequest(postUrl,formdata=formdata, callback=self.parse)\n利用scrpay自带的FormRequest发送post请求，这里的formdata是跟踪post请求时得到的，要根据自己的网站调整，callback指示讲得到的response反馈给parse函数处理（也就是新的一页列表）\n到此为止，就是spider文件的所有，这个文件唯一对外的输出就是item，它会有scrapy引擎转给pipeline处理\n3. pipeline\n代码\n\nfrom scrapy import signals\nfrom scrapy.contrib.exporter import CsvItemExporter\nfrom jlsh_notice import settings\nimport pymysql\nimport time\n\nimport smtplib\nfrom email.mime.text import MIMEText\nfrom email.utils import formataddr\n\n\nclass JlshNoticePipeline(object):\n    def process_item(self, item, spider):\n        return item\n\n\n# 用于数据库存储\nclass MySQLPipeline(object):\n    def process_item(self, item, spider):\n#=======================================================\n        self.connect = pymysql.connect(\n            host=settings.MYSQL_HOST,\n            port=3306,\n            db=settings.MYSQL_DBNAME,\n            user=settings.MYSQL_USER,\n            passwd=settings.MYSQL_PASSWD,\n            charset='utf8',\n            use_unicode=True)\n\n        # 通过cursor执行增删查改\n        self.cursor = self.connect.cursor()\n#=======================================================\n        # 查重处理\n        self.cursor.execute(\n            \"\"\"select * from jlsh_weblist where \n                noticeType = %s and \n                noticeTitle = %s and\n                noticeDate = %s \"\"\",\n            (item['noticeType'], item['noticeTitle'], item['noticeDate']))\n        # 是否有重复数据\n        repetition = self.cursor.fetchone()\n#=======================================================\n        # 重复\n        if repetition:\n            print('===== Pipelines.MySQLPipeline ===== 数据重复，跳过，继续执行..... =====')\n        else:\n            # 插入数据\n            content_html = ''\n            for p in item['noticeContent']:\n                content_html = content_html + '<p>' + p + '</p>'\n\n            self.cursor.execute(\n                \"\"\"insert into jlsh_weblist(noticeType, noticeTitle, noticeDate, noticeUrl, noticeContent, record_time)\n                value (%s, %s, %s, %s, %s, %s)\"\"\",\n                (item['noticeType'], item['noticeTitle'], item['noticeDate'], item['noticeUrl'], content_html, time.localtime(time.time())))\n\n            try:\n                # 提交sql语句\n                self.connect.commit()\n                print('===== Insert Success ! =====', \\\n                    item['noticeType'], item['noticeTitle'], item['noticeDate'], item['noticeUrl'])\n            except Exception as error:\n                # 出现错误时打印错误日志\n                print('===== Insert error: %s ====='%error)\n#=======================================================\n            #定向发送邮件\n            if settings.SEND_MAIL:\n                sender='***@***.com'    # 发件人邮箱账号\n                password = '********'              # 发件人邮箱密码\n                receiver='*****@*****.com'      # 收件人邮箱账号，我这边发送给自己\n                title = item['noticeTitle']\n                content = \"\"\"\n                    <p>%s</p>\n                    <p><a href=\"%s\">%s</a></p>\n                    <p>%s</p>\n                    %s\n                    \"\"\" % (item['noticeType'], item['noticeUrl'], item['noticeTitle'], item['noticeDate'], content_html)\n\n                ret=self.sendMail(sender, password, receiver, title, content)\n                if ret:\n                    print(\"邮件发送成功\")\n                else:\n                    print(\"邮件发送失败\")\n                pass\n            \n        self.connect.close()\n        return item\n#=======================================================\n    def sendMail(self, sender, password, receiver, title, content):\n        ret=True\n        try:\n            msg=MIMEText(content,'html','utf-8')\n            msg['From']=formataddr(['', sender])            # 括号里的对应发件人邮箱昵称、发件人邮箱账号\n            msg['To']=formataddr([\"\",receiver])             # 括号里的对应收件人邮箱昵称、收件人邮箱账号\n            msg['Subject']=\"邮件的主题 \" + title    # 邮件的主题，也可以说是标题\n    \n            server=smtplib.SMTP(\"smtp.*****.***\", 25)  # 发件人邮箱中的SMTP服务器，端口是25\n            server.login(sender, password)  # 括号中对应的是发件人邮箱账号、邮箱密码\n            server.sendmail(sender,[receiver,],msg.as_string())  # 括号中对应的是发件人邮箱账号、收件人邮箱账号、发送邮件\n            server.quit()  # 关闭连接\n        except Exception:  # 如果 try 中的语句没有执行，则会执行下面的 ret=False\n            ret=False\n        return ret\n#=======================================================   \n说明\n这里的pipeline是我自己建立的，写好后在setting中改一下设置就可以了。因为scrapy的去重机制只针对爬虫一次运行过程有效，多次循环爬取就不行了，所以为了实现不爬取重复数据，使用mysql就是比较靠谱的选择了。\npymysql是python链接mysql的包，没有的话pip安装即可。首先建立一个pymysql.connect实例，将连接mysql的几个参数写进去，我这里是先写到setting里面再导入，也可以直接写，值得注意的是port参数（默认是3306）不要加引号，因为它必须是int类型的。\n接下来建立一个cursor实例，用于对数据表进行增删查改。cursor.execute() 方法是定义要执行的sql命令，这里注意就是execute只是定义，不是执行。cursor.fetchone() 方法是执行sql并返回成功与否的结果。这里进行了数据查询，如果能够查到，说明这条记录已经建立，如果没有，就可以新增数据了。\n由mysql数据库不接受list类型的数据，所以接下来要对item['noticeContent']做一下处理（他是list类型的，还记得么^_^）。在item['noticeContent']中做for in循环，把他的每一项内容用<p>标签包起来，组成一个长字符串。\n接下来还是写sql命令：insert into .....写完以后用connect.commit()提交执行\n最后就是发送邮件了，自建一个sendMail函数，发送邮件用到了两个python包：smtplib 和 email，具体没啥说的，照着写就行了，我是一次成功。。\n到此为止，就可以运行爬虫了，可以看到数据库中已经有了爬取的内容。。。\n\n4. settings.py\n注册pipeline\nITEM_PIPELINES = {\n    'jlsh_notice.pipelines.MySQLPipeline': 300,\n}\nlog输出的定义，四个任选其一\nLOG_LEVEL = 'INFO'\nLOG_LEVEL = 'DEBUG'\nLOG_LEVEL = 'WARNING'\nLOG_LEVEL = 'CRITICAL'\n关于爬虫终止条件的定义，默认不设置\n#在指定时间过后，就终止爬虫程序.\nCLOSESPIDER_TIMEOUT = 60\n\n#抓取了指定数目的Item之后，就终止爬虫程序.\nCLOSESPIDER_ITEMCOUNT = 10\n\n#在收到了指定数目的响应之后，就终止爬虫程序.\nCLOSESPIDER_PAGECOUNT = 100\n\n#在发生了指定数目的错误之后，就终止爬虫程序.\nCLOSESPIDER_ERRORCOUNT = 100\n5. 实现自动执行\n(1) 同时执行多个爬虫。\n首先，在项目目录下建立新的目录（与spider目录同级），名为“commands”，内建两个文件：\n__init__.py    (空文件，但是要有）\ncrawlall.py\nfrom scrapy.commands import ScrapyCommand\nfrom scrapy.utils.project import get_project_settings\n \n \nclass Command(ScrapyCommand):\n \n    requires_project = True\n \n    def syntax(self):\n        return '[options]'\n \n    def short_desc(self):\n        return 'Runs all of the spiders'\n \n    def run(self, args, opts):\n        spider_list = self.crawler_process.spiders.list()\n        for name in spider_list:\n            self.crawler_process.crawl(name, **opts.__dict__)\n        self.crawler_process.start()\n然后在项目目录下建立一个setup.py文件\nfrom setuptools import setup, find_packages\n\nsetup(name='scrapy-mymodule',\n    entry_points={\n        'scrapy.commands': [\n            'crawlall=jlsh_notice.commands:crawlall',\n            ],\n        },\n    )\n这个时候，在scrapy项目目录下执行scrapy crawlall即可运行所有的爬虫\n(2) 每隔一段时间运行爬虫。\n在项目目录下新建一个noticeStart.py文件（名称任意）,利用python中的os和time包实现每隔一段时间运行一个命令。\nimport time\nimport os\n\nwhile True:\n    os.system(\"scrapy crawlall\")\n    remindTime = 5\n    remindCount = 0\n    sleepTime = 60\n    while remindCount * remindTime < sleepTime:\n        time.sleep(remindTime*60)\n        remindCount = remindCount + 1\n        print('已等待%s分钟，距离下一次搜集数据还有%s分钟......'%(remindCount*remindTime,(sleepTime/remindTime-(remindCount))*remindTime))   \n    \n(3) 实现开机运行。\n首先：由于cmd命令打开目录在c盘，我的scrapy项目在e盘，所以要做一个bat文件跳转目录并运行py文件\nautorun.bat\ne:\ncd e:\\PythonProjects\\ScrapyProjects\\jlsh_notice\\jlsh_notice\\\npython noticeStart.py\n其次：打开计划任务程序，创建基本任务，运行程序选择刚刚的bat文件，值得说明的是，计划任务触发器不要设置启动后立即执行，不然可能会失败，要延迟1分钟运行。\n\n到此为止，所有的代码完成，以后还要根据实际情况增加更多的通知类别，也可以根据不同领导的关注点不同，分别发送邮件提醒。欢迎有兴趣的朋友留言交流。。。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}