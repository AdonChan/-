{"title": "Python 延迟初始化（lazy property） - nummy的专栏 ", "index": "python", "content": "Python 对象的延迟初始化是指，当它第一次被创建时才进行初始化，或者保存第一次创建的结果，然后每次调用的时候直接返回该结果。\n延迟初始化主要用于提高性能，避免浪费计算，并减少程序的内存需求。\nproperty\n在切入正题之前，我们了解下property的用法，property可以将属性的访问转变成方法的调用。\nclass Circle(object): \n  def __init__(self, radius): \n    self.radius = radius \n  \n  @property\n  def area(self): \n    return 3.14 * self.radius ** 2\n  \nc = Circle(4) \nprint c.radius \nprint c.area \n可以看到，area虽然是定义成一个方法的形式，但是加上@property后，可以直接执行c.area，当成属性访问。\n现在问题来了，每次调用c.area，都会计算一次，太浪费cpu了，怎样才能只计算一次呢?这就是lazy property。\nlazy property\n实现延迟初始化有两种方式，一种是使用python描述符，另一种是使用@property修饰符。\n方式1：\nclass lazy(object): \n  def __init__(self, func): \n    self.func = func \n  \n  def __get__(self, instance, cls): \n    val = self.func(instance) \n    setattr(instance, self.func.__name__, val) \n    return val \n  \nclass Circle(object): \n  def __init__(self, radius): \n    self.radius = radius \n  \n  @lazy\n  def area(self): \n    print 'evalute'\n    return 3.14 * self.radius ** 2\n  \nc = Circle(4) \nprint c.radius \nprint c.area \nprint c.area \nprint c.area \n结果'evalute'只输出了一次。在lazy类中，我们定义了__get__()方法，所以它是一个描述符。当我们第一次执行c.area时，python解释器会先从c.__dict__中进行查找，没有找到，就从Circle.__dict__中进行查找，这时因为area被定义为描述符，所以调用__get__方法。\n在__get__()方法中，调用实例的area()方法计算出结果，并动态给实例添加一个同名属性area，然后将计算出的值赋予给它，相当于设置c.__dict__['area']=val。\n当我们再次调用c.area时，直接从c.__dict__中进行查找，这时就会直接返回之前计算好的值了。\n不太懂python描述符的话，可以参考Descriptor HowTo Guide。\n方式2\ndef lazy_property(func):\n    attr_name = \"_lazy_\" + func.__name__\n\n    @property\n    def _lazy_property(self):\n        if not hasattr(self, attr_name):\n            setattr(self, attr_name, func(self))\n        return getattr(self, attr_name)\n\n    return _lazy_property\n\nclass Circle(object): \n  def __init__(self, radius): \n    self.radius = radius \n  \n  @lazy_property\n  def area(self): \n    print 'evalute'\n    return 3.14 * self.radius ** 2\n这里与方法1异曲同工，在area()前添加@lazy_property相当于运行以下代码：\nlazy_property(area)\nlazy_property()方法返回_lazy_property，_lazy_property又会调用_lazy_property()方法，剩下的操作与方法1类似。\n我们可以检查下是否真的延迟初始化了：\nc = Circle(4) \nprint \"before first visit\"\nprint c.__dict__  \nc.area\nprint \"after first visit\"\nprint c.__dict__\n输出结果为：\nbefore first visit\n{'radius': 4}\nevalute\nafter first visit\n{'_lazy_area': 50.24, 'radius': 4}\n从中可以看书，只有当我们第一次访问c.area时，才调用area方法，说明确实延迟初始化了。\n参考文献\n\nDescriptor HowTo Guide\nlazy evaluation\npython中的property及实现lazy property(原博客已找不到)\n\n\n                ", "mainLikeNum": ["4 "], "mainBookmarkNum": "13"}