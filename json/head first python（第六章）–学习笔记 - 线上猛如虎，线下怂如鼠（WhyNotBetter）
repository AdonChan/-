{"title": "head first python（第六章）–学习笔记 - 线上猛如虎，线下怂如鼠（WhyNotBetter） ", "index": "python", "content": "\n\n样例数据\n\nSarah Sweeney,2002-6-17,2:58,2.58,2:39,2-25,2-55,2:54,2.18,2:55,2:55,2:22,2-21,2.22\n\n\n需要将数据整理，实现人名+出生日期+成绩的输出\n\n以往的做法是：\n\ndef sanitize(time_string):\n    if '-' in time_string:\n        splitter = '-'\n    elif ':' in time_string:\n        splitter = ':'\n    else:\n        return(time_string)\n    (mins, secs) = time_string.split(splitter)\n    return(mins + '.' + secs)\n\ndef get_coach_data(filename):\n    try:\n        with open(filename) as f:\n            data = f.readline()\n        return(data.strip().split(','))\n    except IOError as ioerr:\n        print('File error: ' + str(ioerr))\n        return(None)\n\nsarah = get_coach_data('sarah2.txt')\n\n(sarah_name, sarah_dob) = sarah.pop(0), sarah.pop(0)\n\nprint(sarah_name + \"'s fastest times are: \" +\n        str(sorted(set([sanitize(t) for t in sarah]))[0:3]))\n\n\n这次加入了字典的做法\n\n字典将数据值与键关联：\n\nkey   -->   value\nName        \"sarah sweeney\"\nDOB         \"2002-6-17\"\nTimes       \"[2:58,2.58,2:39,2-25,2-55,2:54,2.18,2:55,2:55,2:22,2-21,2.22]\"\n\n\n创建字典的方式可以是\n\ncleese = {} #大括号！！\n\n\n也可以是\n\npalin = dict()\n\n\n关联key和value的话是\n\ncleese['Name'] = 'John Cleese'  # 一个key 对应一个字符串\n\n\n或者\n\ncleese['Name'] = ['John Cleese','John Cleese1','John Cleese2','John Cleese3','John Cleese4'] #一个key对应一个list\n\n\n或者\n\ncleese = {'Name':'abc','Address':'asdasdasda'}  #注意是用冒号\n\n\n另外数据值与key关联后，需要访问数据值里面的某个数据项的话，可以是\n\ncleese['Name'][-1] \n\n\n类似多维数组使用。\n\n代码改为\n\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n\ndef sanitize(time_string):\n        if '-' in time_string:\n                splitter = '-'\n        elif ':' in time_string:\n                splitter = ':'\n        else:\n                return(time_string)\n        (mins,secs) = time_string.split(splitter)\n        return (mins + '.' + secs)\n\ndef get_coach_data(filename):\n        try:\n                with open(filename) as f:\n                        data = f.readline()\n                return(data.strip().split(','))\n        except IOError as ioerr:\n                print('File error:' + str(ioerr))\n                return(None)\n\nsarah = get_coach_data('sarah2.txt')\n\nsarah_data={}\nsarah_data['Name'] = sarah.pop(0)   #根据数据结构，第一个数据是名字，第二个是生日，第二个之后是成绩，所以分别将相关数据赋值到字典里面。\nsarah_data['DOB'] = sarah.pop(0)\nsarah_data['Times'] = sarah\n\nprint(sarah_data['Name'] + \"'s fastest times are: \" + str(sorted(set([sanitize(t) for t in sarah_data['Times']]))[0:3]))\n\n\n\n  字典的方法优势在于合理使用数据结构。是否知道何时使用列表而何时使用字典，这正式从好的程序员中区分出优秀程序员的一个标准。\n  字典其实也叫“映射”，“散列”，“关联数组”\n\n\n为了更加方便的处理多个人的成绩的数据，所以将字典数据转移到函数里面去，直接通过函数生成出字典，并返回需要的数据\n\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n\ndef sanitize(time_string):\n        if '-' in time_string:\n                splitter = '-'\n        elif ':' in time_string:\n                splitter = ':'\n        else:\n                return(time_string)\n        (mins,secs) = time_string.split(splitter)\n        return (mins + '.' + secs)\n\ndef get_coach_data(filename):\n        try:\n                with open(filename) as f:\n                        data = f.readline()\n                templ = data.strip().split(',')\n                return({'Name':templ.pop(0),    #这里就是字典\n                        'DOB':templ.pop(0),\n                        'Times':str(sorted(set([sanitize(t) for t in templ]))[0:3])})\n        except IOError as ioerr:\n                print('File error:' + str(ioerr))\n                return(None)\n\nsarah = get_coach_data('sarah2.txt')\njames = get_coach_data('james2.txt')\n\nprint(sarah['Name'] + \"'s fastest times are: \" + sarah['Times'])\n\n\n这就是将代码和数据打包在一起。特定函数应用特定数据。\n\n更加正规的做法是建立类。\n\n类是面向对象oop编程模型的东西，类的概念在这里不详细描述。\n\n类可以\n\n1.降低复杂性\n2.方便维护和扩展\n\n\npython的类需要有一个self参数，这个参数是用来标识是属于哪个对象实例的\n\n例如：\n\nclass Athlete:\n    def __init__(self,value=0):\n        self.thing = value      #定义这个类的属性thing\n    def how_big(self)           #定义一个方法how_big\n        return(len(self.thing))\n\n\nbtw：init 是类的python固定实现方法，所以是必须的。\n\n你写的代码                   -->     python执行的代码\nd = Athlete(\"Holy Grail\")           Athlete.__init__(d,\"Holy Grail\")\n                                    |         |      |  \n                                    类       方法    目标标识符 \n                                    |         |     |\nd.how_big()                         Athlete.how_big(d)\n\n\n代码改为：\n\ndef sanitize(time_string):\n    if '-' in time_string:\n        splitter = '-'\n    elif ':' in time_string:\n        splitter = ':'\n    else:\n        return(time_string)\n    (mins, secs) = time_string.split(splitter)\n    return(mins + '.' + secs)\n\nclass Athlete:\n    def __init__(self, a_name, a_dob=None, a_times=[]):\n        self.name = a_name      #通过类的属性来定义name，dob和times\n        self.dob = a_dob\n        self.times = a_times\n\n    def top3(self):\n        return(sorted(set([sanitize(t) for t in self.times]))[0:3])\n\ndef get_coach_data(filename):\n    try:\n        with open(filename) as f:\n            data = f.readline()\n        templ = data.strip().split(',')\n        return(Athlete(templ.pop(0), templ.pop(0), templ))\n    except IOError as ioerr:\n        print('File error: ' + str(ioerr))\n        return(None)\n\njames = get_coach_data('james2.txt')\njulie = get_coach_data('julie2.txt')\nmikey = get_coach_data('mikey2.txt')\nsarah = get_coach_data('sarah2.txt')\n\nprint(james.name + \"'s fastest times are: \" + str(james.top3()))\nprint(julie.name + \"'s fastest times are: \" + str(julie.top3()))\nprint(mikey.name + \"'s fastest times are: \" + str(mikey.top3()))\nprint(sarah.name + \"'s fastest times are: \" + str(sarah.top3()))\n\n\n\n  科普：\n  \n  1.通过在各个对象的属性中保留原始数据，可以支持类扩展来满足将来的其他需求。如果处理数据并作为对象初始化代码的一部分，说明你已对程序员将如何使用这个类做出了假设，而日后这些假设肯定会对你造成障碍。\n\n\n在类里面增加一个灵活的增加成绩数据的函数\n\n可以是增加单个成绩，或是增加多个成绩\n单个成绩用add_time，传入的是字符串\n多个成绩是add_times，传入的是list\n\n以下是单个成绩的样例：\n\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\nclass Athlete:\n        def __init__(self,a_name,a_dob=None,a_times=[]):\n                self.name = a_name\n                self.dob = a_dob\n                self.times = a_times\n\n        def add_time(self,time_value):      #这里就是了。\n                self.times.append(time_value)\n        def top3(self):\n                return (sorted(set([sanitize(t) for t in self.times]))[0:15])\n        def add_times(self,list_of_times):\n                self.times.extend(list_of_times)\n\ndef sanitize(time_string):\n        if '-' in time_string:\n                splitter = '-'\n        elif ':' in time_string:\n                splitter = ':'\n        else:\n                return(time_string)\n        (mins,secs) = time_string.split(splitter)\n        return (mins + '.' + secs)\n\ndef get_coach_data(filename):\n        try:\n                with open(filename) as f:\n                        data = f.readline()\n                templ = data.strip().split(',')\n                return (Athlete(templ.pop(0),templ.pop(0),templ))\n        except IOError as ioerr:\n                print('File error:' + str(ioerr))\n                return(None)\n\nsarah = get_coach_data('sarah2.txt')\n\nsarah.add_time('2.88')      #这里调用\nprint(sarah.name + \"'s fastest times are: \" + str(sarah.top3()))    #输出结果会改变\n\n\n观察到这个类有点像list，所以有重复制造车轮的嫌疑，并且功能单一，所以决定集成list类\n\ndef sanitize(time_string):\n    if '-' in time_string:\n        splitter = '-'\n    elif ':' in time_string:\n        splitter = ':'\n    else:\n        return(time_string)\n    (mins, secs) = time_string.split(splitter)\n    return(mins + '.' + secs)\n\nclass AthleteList(list):    #继续list类，所以这里要写list的名字\n\n    def __init__(self, a_name, a_dob=None, a_times=[]):\n        list.__init__([])   #这里需要初始化list类\n        self.name = a_name\n        self.dob = a_dob\n        self.extend(a_times)    #因为集成list类了，所以这里可以直接使用list的extend方法\n\n    def top3(self):\n        return(sorted(set([sanitize(t) for t in self]))[0:3])\n\ndef get_coach_data(filename):\n    try:\n        with open(filename) as f:\n            data = f.readline()\n        templ = data.strip().split(',')\n        return(AthleteList(templ.pop(0), templ.pop(0), templ))\n    except IOError as ioerr:\n        print('File error: ' + str(ioerr))\n        return(None)\n\njames = get_coach_data('james2.txt')\njulie = get_coach_data('julie2.txt')\nmikey = get_coach_data('mikey2.txt')\nsarah = get_coach_data('sarah2.txt')\n\nprint(james.name + \"'s fastest times are: \" + str(james.top3()))\nprint(julie.name + \"'s fastest times are: \" + str(julie.top3()))\nprint(mikey.name + \"'s fastest times are: \" + str(mikey.top3()))\nprint(sarah.name + \"'s fastest times are: \" + str(sarah.top3()))\n\n\n\n原文引用：http://www.godblessyuan.com/2015/05/03/head_first_python_chapter_6_lea...\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}