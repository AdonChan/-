{"title": "Python 从零开始爬虫(八)——动态爬取解决方案 之 selenium  - Python 从零开始爬虫 ", "index": "selenium,网页爬虫,python", "content": "selenium——自动化测试工具，专门为Web应用程序编写的一个验收测试工具，测试其兼容性，功能什么的。然而让虫师们垂涎的并不是以上的种种，而是其通过驱动浏览器获得的解析JavaScript的能力。所以说这货在动态爬取方面简直是挂逼级别的存在，相较于手动分析更简单易用，节省分析打码时间。\n虽然selenium因其“超能力”被不少人吹上天了，但是认清利弊，根据需求来选择爬虫工具，还是挺重要的，所以这里简单说下以供参考：\n\nselenium无脑解决动态难题\nselenium更耐网页变动\nselenium极大提升开发效率，但极大降低爬取效率（规模一大就明显了）。\nselenium更占用资源（cpu，内存，网络）\n\n理由：打开一个/多个浏览器，浏览器里还有n个窗口.....下面不多说，进入正题\n前置\n本体直接pip安装pip install selenium\n驱动按需选择：\n\n\nchrome （内核版本要对应，详看其中的notes.txt）\n\nfirefox （相信各位的英文实力）\n\nIE （很少用吧）\n\n下载好后把解压得到的驱动放到设置了环境变量的路径下就行了，如果你的python设置了环境变量，应该丢到python目录下就行了。\n简单尝试\n照例贴上文档，2.53旧版中文,想学更多就给我啃选好浏览器就创建实例，之后的操作都在这个实例之上，并介绍一些有用的option，本文以Chrome为例。\nfrom selenium import webdriver\n\n#其他浏览器把Chrome换名就行\n#option = webdriver.ChromeOptions()\n#option.set_headless() 设置无头浏览器，就是隐藏界面后台运行\n\ndriver = webdriver.Chrome() #创建driver实例\n#driver = webdriver.Chrome(chrome_options=option)  创建实例并载入option\n\nurl = '**********'\ndriver.get(url)\n#driver.maximize_window() 最大化窗口\n#driver.set_window_size(width,height) 设置窗口大小\n\nprint(driver.page_source) #打印网页源码\ndriver.quit() # 关闭浏览器\n对付低级的动态网页(ajax较少)就是这么简单，基本不用考虑动态问题，徒手撸动态的人表示羡慕。然而更多时候并不像这样简单，直接套用的话很容易导致源码所见非所得，而且很多爬虫并没有简单到拿个源码就走的程度，它还要交互，模拟点击滚动等等。所以还请往下看，不要看到这就投入实战啦\n定位\nselenium提供多种方法对元素进行定位，返回WebElement对象，而上面提到的driver就相当于最大的WebElement对象\n#以下都是单次定位，返回第一个定位到的。如果想多次定位，给element加个s就行，返回的是符合元素的列表\nelement = driver.find_element_by_id() # 通过标签的id定位，接收id属性值\n\ndriver.find_element_by_name() # 通过标签的name定位，接收name属性值\n\ndriver.find_element_by_xpath() # 通过xpath定位，接收xpath表达式\n\ndriver.find_element_by_link_text() # 通过标签的完全文本定位，接收完整的文本\n\ndriver.find_element_by_partial_link_text() # 通过标签的部分文本定位，接收部分文本\n\ndriver.find_element_by_tag_name() # 通过标签名定位，接收标签名\n\ndriver.find_element_by_class_name() # 通过标签的class定位，接收class属性值\n\ndriver.find_element_by_css_selector() # 通过css选择器定位，接收其语法\n#返回的WebElement对象可以继续往下定位\n\nxpath和css就不展开讲了，能实现精确定位，一定要学其中一个，不知道的小伙伴们上网自学吧，不难\n\n除了上面这些公有的方法，还有2个私有的方法来帮助页面对象的定位。 这两个方法就是 find_element 和 find_elements，需要导入By类辅助，接收一个By类属性及其对应语法/值\nfrom selenium.webdriver.common.by import By\ndriver.find_element(By.XPATH,'//a[text()=\"dark\"]')\ndriver.find_elements(By.XPATH,'//a[text()=\"dark\"]')\n'''By类有以下属性\nID = \"id\"\nXPATH = \"xpath\"\nLINK_TEXT = \"link text\"\nPARTIAL_LINK_TEXT = \"partial link text\"\nNAME = \"name\"\nTAG_NAME = \"tag_name\"\nCLASS_NAME = \"class name\"\nCSS_SELECTOR = \"css selector\"\n'''\nframe切换\n很多人在用selenium会遇到所见非所得，或者定位页面元素的时候会定位不到的问题，这种情况很有可能是frame在搞鬼，必须切换到相应frame中再进行定位。如果遇到以上问题，第一时间F12看下你所要的信息是否在frame标签里面。frame标签有frameset、frame、iframe三种，frameset跟其他普通标签没有区别，不会影响到正常的定位，而frame与iframe对selenium定位而言是一样的。\nselenium提供了4种方法定位iframe并切换进去：\n#对于<iframe name=\"frame1\" id=\"dark\">.....</iframe>\ndriver.switch_to_frame(0)  # 用frame的index来定位，第一个是0，以此类推\ndriver.switch_to_frame(\"frame1\")  # 用id来定位\ndriver.switch_to_frame(\"dark\")  # 用name来定位\ndriver.switch_to_frame(driver.find_element_by_tag_name(\"iframe\"))  # 用WebElement对象来定位\n通常通过id和name就能实现，无此属性时可以通过WebElement对象，即用find_element系列方法所取得的对象来定位。如果你确定每个目标frame都是固定第几个，那也可以用index定位\n切到frame中之后，就不能继续操作主文档的元素了，这时如果想操作主文档内容，则需切回主文档。\ndriver.switch_to_default_content()\n\n嵌套frame的切换 如果frame里包着frame而你要的frame是后者，那么需要一层一层切换进去，切换方法四选一\ndriver.switch_to_frame(\"frame1\")\ndriver.switch_to_frame(\"frame2\")\n如果想回去上一个父frame，用driver.switch_to.parent_frame()\nwindow 切换\n有时候点开一个链接就会弹出一个新窗口，如果要对其操作就要切换过去，方法和frame的切换差不多，但只接收window_handle（相当于窗口的名字）来进行切换。driver.switch_to_window(\"windowName\")\n切换前最好保存之前的handle和所有的handles以便于来回切换。\ncurrent_window = driver.current_window_handle  # 获取当前窗口handle name\nall_windows = driver.window_handles  # 获取所有窗口handle name\n\n# 如果window不是当前window，则切换到该window，即切换到新窗口\nfor window in all_windows:\n    if window != current_window:\n        driver.switch_to_window(window)\n        #....\ndriver.switch_to_window(current_window)  # 返回之前的窗口\ndriver.close()  # 窗口的关闭用close()\n\n页面交互\n常用的页面交互有点击，输入文本等。交互的原则是先定位，后交互，比如你F12找到了某个文本框或某个可点击项的标签，那就先定位到那，再用以下的交互方法\nfrom selenium.webdriver.common.keys import Keys\n# 首先定位到某个文本框或某个可点击项（如超链接，按钮）,\nelement = driver.find_element_by_xpath('//a[text()=\"dark\"]')\n\nelement.send_keys(\"some text\")  # 往文本框输入文本\n#element.send_keys(\"some text\", Keys.ARROW_DOWN)  可以使用 Keys 类来模拟输入方向键\nelement.clear()  # 清空文本框\n\n#element.click() 如果此元素可点击，可用click()方法\n要注意的一点是，不是定位到就必定能交互，有时候目标会被网页弹出来的东西覆盖，导致无法交互，所以要确保页面干净无覆盖\n上下拉滚动\nselenium可以执行js，下拉滚动可以通过此实现，因此就算不懂js也可以记一些有用的js代码\n#driver.execute_script('js_str')\ndriver.execute_script('window.scrollTo(0,10000)')  # 移动到指定坐标\ndriver.execute_script('window.scrollBy(0,10000)')  # 相对当前坐标移动\ndriver.execute_script('window.scrollTo(0, document.body.scrollHeight)')  # 相对当前坐标移动\n等待\n现在不少web都都有使用ajax技术，即异步加载，有时候你要的东西都还没加载到你就去定位了，就会抛出异常。为了避免此等血淋淋的惨状，必须要待其加载一段时间后再进行后面的操作。这里付一张不等待就获取page_source的后果\n最粗暴的方法就是使用time.sleep()，这很笨，因为你还要设置合适的时间，而不同网站加载的速度有异，容易造成时间的浪费。所以最好还是使用selenium提供的两种等待方法\n显式Wiats\n显式Wiats允许你设置一个加载时间的上限和一个条件，每隔0.5s就判断一下所设条件，条件成立就继续执行下面的代码，如果过了时间上限还是没有成立，默认抛出NoSuchElementException 异常。这种相对智能的等待方法能最大化地节省时间，应该优先选择使用\nselenium提供了多种expected_conditions（EC）来设置条件，但是要注意有定位时EC的方法接收的是定位信息的元组(locator_tuple)而不是两个参数，正确用法如 EC.presence_of_element_located((By.ID,\"dark\"))这个条件检测是否有id='dark'的元素\nselenium提供的EC有以下方法，意思如其名，这里注释一些易搞错的，选择使用\ntitle_is(str)title_contains(str)presence_of_element_located(locator_tuple)visibility_of_element_located(locator_tuple)  # 判断某个元素是否可见visibility_of(WebElement) # 同上，传参不同presence_of_all_elements_located(locator_tuple)text_to_be_present_in_element(str) # 判断某个元素中的text是否包含了指定字符串text_to_be_present_in_element_value(str) # 判断某个元素中的value属性是否包含了预期的字符串frame_to_be_available_and_switch_to_itinvisibility_of_element_located(locator_tuple)element_to_be_clickable(locator_tuple)staleness_of(WebElement) # 等待某个元素从的移除element_to_be_selected(WebElement)element_located_to_be_selected(locator_tuple)element_selection_state_to_be(WebElement)element_located_selection_state_to_be(locator_tuple)alert_is_present() # 判断页面上是否存在alert\n\n使用上通常搭配try语句\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait # 导入显式等待\nfrom selenium.webdriver.support import expected_conditions as EC # 导入EC\nfrom selenium.common.exceptions import NoSuchElementException\n\n# WebDriverWait(driver,time).until(EC) 显式waits\n\ntry:\n    element = WebDriverWait(driver,10).until(EC.presence_of_element_located((By.ID,\"myDynamicElement\")))\n    \nexcept NoSuchElementException:\n    #.....\nfinally:\n     driver.quit()\n隐式等待\n隐式等待是在尝试定位某个元素的时候，如果没能成功，就等待固定长度的时间，默认0秒。一旦设置了隐式等待时间，它的作用范围就是Webdriver对象实例的整个生命周期。driver.implicitly_wait(10)\n最后补充\n这是用selenium几分钟弄出来的网易云音乐单曲评论爬虫，而且还模拟了评论翻页，还截了图。没提取信息，提取的时候可以用BeautifulSoup或正则提取，\nfrom selenium import webdriver\nimport time\nfrom selenium.common.exceptions import NoSuchElementException, TimeoutException\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\n\ndriver = webdriver.Chrome()\ndriver.maximize_window()\ndriver.get(\"http://music.163.com/#/song?id=31877470\")\ndriver.switch_to_frame(\"contentFrame\")\ntime.sleep(5)\ndriver.execute_script('window.scrollTo(0, document.body.scrollHeight)')\ndriver.save_screenshot('E:/python3/gg.png')  # 截图\nb = driver.find_element_by_xpath(\"//a[starts-with(@class,'zbtn znxt')]\")\nb.click()\ntry:\n    WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.XPATH,\"//a[@data-type='reply']\")))\n    print(driver.page_source)\nexcept NoSuchElementException:\n    print('OMG')\nfinally:\n        driver.quit()\n短短二十行就能做到这种程度（而且不少还是import的），足以见得selenium强大。如果要手动分析，你还要分析js加密算法，写上n倍的代码。两者相比起来selenium真的很吸引人，简直是懒人救星。大家权衡利弊按需选择吧\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "1"}