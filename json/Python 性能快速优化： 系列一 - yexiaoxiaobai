{"title": "Python 性能快速优化： 系列一 - yexiaoxiaobai ", "index": "optimization,performance,python", "content": "\n  注： 本文的原文地址 quick-python-performance-optimization-part-i\n\n\nPython可能最容易扼杀你的想法，但不是最好的代码实现。尽管强烈反对过早优化，但在 Python 代码中一点点的优化都可能带来巨大的性能提升。\n\n解释仅仅是目的，最正确的方式是天天使用 Python 编程，并且与性能影响相关。\n\n\n\n%timeit (per line) 和 %prun (cProfile) 在 ipython 的交互式 Shell 中\n\n当你的代码在工作时，分析你的代码，并且尝试找出性能瓶颈在哪里。这不与过早的优化是万恶之源这个事实相反。这意味着一级优化，而不是进入冗长的优化序列。\n\n更多的分析你的 Python 代码，你需要阅读这个 python-performance-analysis\n\n另外一个有趣的包， line_profiler 是一行一行的分析代码\n分析 line_profiler\n\n\n降低方法调用次数，如果你有一个列表需要操作，传递整个列表，而不是遍历整个列表并且传递每个元素给函数并返回。\n使用 xrange 代替 range。（在 Python2.x 中这样做，因为 Python 3.x 中是默认的）\n\nxrange 是 range 的 C 实现，着眼于有效的内存使用。\n\n\n对于大数据，使用 numpy，它比标准的数据结构好很多。\n\"\".join(string) 比 + or += 好\nwhile 1 比 while True 快\nlist comphrension > for loop > while\n\n列表推导比循环遍历列表快，但 while loop 是最慢的，需要使用一个外部计数器。\n\n\n使用 cProfile，cStringIO 和 cPickle \n\n一直使用 C 版本的模块\n\n\n使用局部变量\n\n局部变量比全局变量，内建类型以及属性快。\n\n\n列表和迭代器版本存在 - 迭代器是内存效率和可伸缩性的。使用 itertools\n\n\n创建生成器以及尽可能使用 yeild，它们比正常的列表方式更快。\n\nhttp://www.diveinto.org/python3/iterators.html\n\nhttp://stackoverflow.com/questions/231767/the-python-yield-keyword-explained\n\n让我继续下一个层次的第二部分快速优化技巧\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "22"}