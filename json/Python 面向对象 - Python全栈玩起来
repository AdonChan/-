{"title": "Python 面向对象 - Python全栈玩起来 ", "index": "python", "content": "1.构造函数\n构造函数：__init__(参数列表)  ：在使用类创建对象时自动调用。注意：如果自己不写构造函数，系统默认也会加上一个空的构造函数。对象属性的优先级高于类属性，当对象调用属性时，如果有对象属性时，先获取对象属性的值；如果没有对象属性，会去找同样名字的类属性；如果没有同样名字的类属性，返回一个错误。\nclass Person():\n    # 直接写在class中的属性叫类属性(可以通过类名直接调用)\n    # name = \"\"\n    # age = 0\n\n    # 默认的构造函数(在init方法中的属性叫对象属性)\n    # __init__函数没有返回值，不能写return\n    # def __init__(self):\n    #     pass\n\n    # 自己重新写构造函数时，只能更改参数列表及函数体，不能写return这条语句\n    # def __init__(self):\n    #     print(\"我显示的是init函数\")\n\n    def __init__(self, name, age, weight=30.0):\n        print(\"小兔子乖乖\")\n        # 对象属性(定义在构造函数中的属性为对象属性)\n        self.name = name\n        self.age = age\n        self.weight = weight\n    # 建议：一个类中最好只有一个init函数，如果写了多个，程序不会报错，\n    # 但是只会执行最后一个写的init函数\n\n    def eat(self):\n        print(\"person--eat\")\n    def sleep(self, hours):\n        print(\"我睡了%d小时\" % hours)\n    \n    # 建议使用关键字 实例化对象\n    per1 = Person(name=\"Lily\", age=30, weight=50.0)\n2.self和__class__\n\nself:当前类的实例对象，但是在类中用self表示。哪个对象调用带有self参数的方法时，self就指向哪一个对象。__class__: 代表当前类的类名。self:不是关键字，换成其他的词语也可以，只要类中的成员方法至少有一个形参即可，第一个形参就代表当前类的实例对象\n\n3.析构函数\n析构函数：__del__()  : 释放对象时调用，销毁对象时调用。\n\nclass Person():\n    # 构造函数\n    def __init__(self, name):\n        self.name = name\n\n    def __del__(self):\n        print('析构函数' + self.name)\n\n\nper1 = Person('tom')\nper2 = Person('lucy')\nper3 = Person('lily')\n# del per3.name 删除对象属性\n# del per3 # 手动删除优先级高 先删除lily 然后执行类里的析构函数，系统的自动回收\n\n\ndef fun1():\n    per4 = Person('Json') # 局部变量\n    print(per4.name)\n\nfun1() # Json 析构函数Json 用完函数后 per4 被析构函数回收\n\n4.__str__函数\n\n在使用print打印对象时会自动调用，这个方法是给用户使用的，是描述对象的方法。\nclass Person():\n    def __init__(self, name, age, sex):\n        self.name = name\n        self.sex = sex\n        self.age = age\n\n    # 可以在类中重新写__str__方法\n    # 要求必须有返回值，返回值类型str类型\n    def __str__(self):\n        sexStr = \"\"\n        if self.sex == 1:\n            sexStr = \"女\"\n        elif self.sex == 0:\n            sexStr = \"男\"\n        return \"姓名为%s, 年龄为%d，性别为%s\" %(self.name, self.age, sexStr)\n\n5.访问限制\n私有属性子类不能继承，子类的对象不能使用实例对象不能直接访问私有属性__age,因为python解释器把__age私有属性变成了_Person__age， 我们就可以通过_Person__age访问私有属性__age。强烈建议：不要这么干\n\nclass Person():\n    def __init__(self, name, age, weight, height):\n        # 公有属性：能够在当前类、当前类的实例对象、子类中均能使用\n        self.name = name\n        # 私有属性: 只能在当前类中使用\n        # 格式：__属性名(只在属性名前面加两个下划线)\n        self.__age = age\n        # 格式：__变量名__：在python中属于特殊变量，可以直接访问，类似公有属性\n        self.__weight__ = weight\n        # 格式: _变量名:在python中能够正常访问，类似公有属性，但是，当我们\n        # 看到这种属性时，把它当成是私有属性使用。\n        # _变量名(虽然我现在能直接访问并使用，但请把我当成私有属性，不要用\n        # 对象直接访问)\n        self._height = height\n    # set方法：赋值\n    def setAge(self, age):\n        if age < 0:\n            self.__age = 20\n        else:\n            self.__age = age\n\n    # get方法: 取值\n    def getAge(self):\n        return self.__age + 20\n\n    def setName(self, name):\n        self.name = name\n    def getName(self):\n        return self.name\n\n6.继承\nclass Animal():\n    def __init__(self, name, color, age):\n        self.name = name\n        self.age = age\n        # 私有属性\n        self.__color = color\n    def run(self):\n        print(self.__color)\n        print(\"run\")\n    def eat(self):\n        print(\"eat\")\nclass Cat(Animal):\n    def __init__(self, name, age, color, miao):\n        # 调用父类的__init__方法\n        # 父类名称.__init__(self, 根据父类形参赋值实参)\n        Animal.__init__(self, name, color, age)\n        # 使用super关键字调用init方法(同上)\n        # super(Cat, self).__init__(name, color, age)\n        # 子类可以有自己独有的属性\n        self.miao = miao\n\n7.多重继承和多继承\n单继承：一个子类只有一个父类多重继承：子类有父类，父类又有父类 ：  父类->子类->子子类。。。。。多继承： Son -> Father,Mother注意：如果父类们中的方法名相同，默认调用小括号中排在前面的父类中的方法(就近原则)\n8.类方法及静态方法\n\n类方法  @classmethod类方法一般来说使用类名调用。类方法类和对象均能调用，但是不管是类还是对象调用，cls都代表类；比如当前例子中，cls就代表Person，cls不是关键字，使用其他形参名称也可以，总之，类方法的第一个形参就代表类。静态方法  @staticmethod静态方法一般来说不是给对象是用的，一般使用类名调用静态方法就是一个普通函数，不会默认需要传参数类和对象均能调用，但一般使用类名调用\n\nclass Person():\n    # 对象方法，使用实例对象调用\n    def eat(self):\n        print(\"eat\")\n\n    # 类方法  @classmethod\n    @classmethod\n    def play(cls, a, b):\n        print(\"类方法\", a+b)\n        print(cls)\n    # 静态方法  @staticmethod\n    @staticmethod\n    def run(num1, num2):\n        print(num1 + num2)\n\n9.动态添加属性及方法及__slots__属性\nfrom types import MethodType\n\nclass Person():\n    def run(self):\n        print(\"run\")\n    pass\n\n# 动态添加属性\nper1 = Person()\nper1.name = \"Lily\"\nprint(per1.name)\n# 动态添加方法\n\ndef say(self):\n    print(\"say\")\n# MethodType(函数名称, 当前实例对象的名称)\n# 把当前的实例对象传递给函数的第一个形参\nper1.saying = MethodType(say, per1)\nper1.saying()\n\n思考：如果我们要限制动态添加属性或方法的个数及名称怎么办？比如我们只能动态添加name及age属性，run方法。为了达到要求，python允许在定义类时，定义一个特殊的属性__slots__属性变量，__slots__属性可以限制动态添加的属性及方法的名称。__slots__ :使用元组的方式赋值注：__slots__定义的属性只对当前类有效，对它继承的子类无效；如果子类中也定义了__slots__属性，这样定义的属性的个数为子类本身的内容加上父类中定义的内容。\nclass Student():\n    __slots__ = (\"name\", \"age\", \"run\")\n    pass\nstu1 = Student()\nstu1.name = \"Tom\"\n# stu1.weight = 56.7  # 错误，不允许添加\n\ndef run(self, a, b):\n    print(\"run\", a+b)\nstu1.run = MethodType(run, stu1)\nstu1.run(2,3)\n\n10.@property\n@property  装饰器@property: 可以使对象通过点方法访问私有属性。\nclass Person():\n    def __init__(self, name, age):\n        # 公有属性\n        self.name = name\n        # 私有属性\n        self.__age = age\n    @property\n    def age(self):\n        return self.__age\n    \n    @age.setter\n    def age(self, age):\n        if age < 0:\n            age = 1\n        self.__age = age\nper1 = Person(name=\"二胖\", age=1)\n# 如果属性为公有属性，对象可以直接调用进行更改或使用\n# 这样，不安全，数据可以直接被重新赋值，而且没有任何限制条件。\n# 相当于调用set方法，现在调用的是加了@age.setter装饰器的方法\nper1.age = 99\n# 相当于调用get方法，现在调用的是加了@property装饰器的方法\nprint(per1.age)\n\n11.运算符重载\nclass Person():\n    def __init__(self, num):\n        self.num = num\n    # 打印对象时调用\n    def __str__(self):\n        return \"目前num为：\" + str(self.num)\n    # 运算符重载\n    def __add__(self, other):\n        return Person(self.num + other.num)\n    def __mul__(self, other):\n        return Person(self.num * other.num)\np1 = Person(100)\nprint(p1)\np2 = Person(266)\nprint(p2)\nprint(p1 + p2)  # p1.__add__(p2)   __add__(self, other)\nPerson(111)\nPerson(111)\nprint(p1 * p2)\n\n__init__: 构造函数\n__del__:析构函数\n__str__:打印对象\n__add__:加运算\n__mul__:乘运算\n__sub__:减运算\n__mod__:余运算\n__div__:除运算\n__pow__:幂运算\n\n12.抽象类\n在开发中，我们遇到的所有事物都是对象，对象是通过类创建的。但是不是所有的类都是用来描述对象的。如果一个类中没有足够的条件信息来描述一个具体的事物/对象，而需要其他具体的类来辅助他，那么，这样的类我们称之为抽象类。抽象类中可以有抽象方法，一般包含抽象方法的类都是抽象类。抽象方法可以不包含任何方法实现的代码，只有一个方法名字，但是，在子类中要求必须实现该抽象方法，否则，子类也为抽象类。\n类是从一堆对象中抽取相同的属性及方法得出的，抽象类就是从一堆类中抽取相同的属性及方法得出的。\n抽象类不能实例化对象。\n\n1、定义抽象类在定义抽象类之前，我们需要导入模块abc中的ABCMeta类(抽象基类的元类)（Metaclass for defining Abstract BaseClass）。在定义抽象类时，我们需要在代码中加入 metaclass=ABCMeta,指定该类的元类为ABCMeta元类：创建一个类的类。抽象类不能实例化对象。抽象类一般都用作父类。2、定义抽象方法在定义抽象方法之前，我们需要导入模块abc中的abstractmethod类。在定义抽象方法时，我们需要在方法前面加上@abstractmethod修饰词。因为抽象方法一般不需要在抽象类中实现，我们只需要在抽象方法的函数体中写一条pass语句即可。\n3、实现类实现类为抽象类的子类。如果实现类不实现父类(抽象类)中的抽象方法，那么该类也是抽象类；如果实现类实现了父类(抽象类)中的抽象方法，那么该类就是普通类，可以实例化对象。\n\nfrom abc import ABCMeta, abstractmethod\n# 定义抽象类\n\nclass Animal(metaclass=ABCMeta):\n    # 定义属性\n    def __init__(self, color):\n        self.color = color\n    # 对象方法\n    def eat(self):\n        print(\"Animal--eat\")\n    # 定义抽象方法\n    @abstractmethod\n    def play(self):\n        pass\n# 创建实现类（以一个抽象类为父类）\nclass Cat(Animal):\n    def __init__(self, color, name):\n        Animal.__init__(self, color)\n        self.name = name\n    # 子类实现父类的抽象方法\n    def play(self):\n        print(\"cat--play\")\n\ncat1 = Cat(color=\"black\", name=\"旺财\")\nprint(cat1.color)\n\n\n13.接口\n真正的接口中不能定义变量，接口中只能有抽象方法。1.什么是接口  interface，接口都是当作父类使用。子类实现接口中的抽象方法。在python中没有interface这个关键字，我们目前所写的接口只是通过抽象类仿写，所以，目前，接口可以认为就是一个类，一个只包含抽象方法并且不能实例化对象的类。其子类如果想要实例化对象，必须实现接口中所有的抽象方法。\n2.为什么要使用接口？接口本身就是一系列方法的声明，一些特殊方法的集合，一个接口中只有方法的声明，但是没有方法的实现，这些特殊的方法要在不同的类之间进行不同的实现。接口本身是用于封装代码的。\n例子：鸟类和昆虫类都有飞行的行为，功能相同，但实现内容不同，二者如果抽象出一个类不太方便，但可以抽象一个接口，用于飞行行为的封装。\n3.注意：一般在接口中只有方法的声明，没有方法的实现。在接口中不能出现变量。\n\nfrom abc import abstractmethod\n# 定义接口\nclass Interface: # 仿写接口\n    # 定义抽象方法\n    @abstractmethod\n    def fly(self):\n        pass\n    # ...\n# 定义接口的实现类\nclass Bird(Interface):\n    def __init__(self, leg):\n        self.leg = leg\n    def egg(self):\n        print(\"鸟生蛋\")\n    def fly(self):\n        print(\"小鸟飞的高\")\nclass Insect(Interface):\n    def __init__(self, leg):\n        self.leg = leg\n    def spawn(self):\n        print(\"昆虫产卵\")\n    def fly(self):\n        print(\"昆虫飞的低\")\nb1 = Bird(2)\nb1.fly()\n\ni1 = Insect(6)\ni1.fly()\n\n\n14.多态\n面向对象的三大特征： 封装，继承，多态多态：一种事物的多种形态，子类可以认为是父类的不同形态的实现python是弱类型语言,声明变量时，不要求数据类型，根据赋值的类型去确定该变量的类型。c，Java强类型语言，声明变量时，已经确定该变量的数据类型，如果赋值的类型与声明的类型不一致，程序会报错。在强类型语言中：子类对象可以强转为父类类型的对象，但父类类型的对象不能强转为子类类型的对象。在强类型语言中：子类对象可以强转为父类类型的对象，父类类型的对象也能强转为子类类型的对象。\n\nclass Animal():\n    def __init__(self, name):\n        self.name = name\n    def eat(self):\n        print(self.name + \"eat\")\nclass Cat(Animal):\n    def __init__(self, name):\n        Animal.__init__(self, name)\n    def run(self):\n        print(self.name + \"run\")\nclass Dog(Animal):\n    def __init__(self, name):\n        Animal.__init__(self, name)\n\nclass Person():\n    # def feedAnimalCat(self, cat):\n    #     print(\"人喂了\" + cat.name)\n    # def feedAnimalDog(self, dog):\n    #     print(\"人喂了\" + dog.name)\n    def feedAnimal(self, animal):\n        print(\"人喂了\" + animal.name)\n\nper = Person()\ncat1 = Cat('喵')\n# per.feedAnimalCat(cat1)\ndog1 = Dog(\"汪\")\n# per.feedAnimalDog(dog1)\n\nper.feedAnimal(cat1)\nper.feedAnimal(dog1)\n\nclass Animal(object):\n    def run(self):\n        print('animal is running')\n\n\nclass Dog(object):\n    def run(self):\n        print('dog is running')\n\n\nclass Cat(object):\n    def run(self):\n        print('cat is running')\n\n\ndef run_twice(animal):\n    animal.run()\n    animal.run()\n\nrun_twice(Animal())\nrun_twice(Cat())\nrun_twice(Dog())\n\nclass Tortoise(Animal):\n    def run(self):\n        print('Tortoise is running slowly...')\n\nrun_twice(Tortoise())\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}