{"title": "Python&Java互通rsa加密解密 - 个人文章 ", "index": "python", "content": "记录一次项目使用RSA加解密\n项目使用Java和Python在开发，RSA加密解密互通代码：\nPython代码\n# -*- coding: utf-8 -*-\n\"\"\"\nRSA加解密\n\"\"\"\nimport base64\nfrom M2Crypto import BIO, RSA\n\nwith open(\"public_key.pem\", 'r') as f:\n    pubkey = f.read()\nwith open(\"private_key.pem\", 'r') as f:\n    prikey = f.read()\n\n# 加密\ntext = \"ABCDEF\".encode('utf-8')  # 明文\npub_bio = BIO.MemoryBuffer(pubkey.encode('utf-8'))  # 公钥字符串\npub_rsa = RSA.load_pub_key_bio(pub_bio)  # 加载公钥\nsecret = pub_rsa.public_encrypt(text, RSA.pkcs1_padding)  # 公钥加密\nsign = base64.b64encode(secret)  # 密文base64编码\nprint(sign)\n\n# 解密\nb64_sign = \"uhBqhevT0E5+WT++HX+pGzSy7YGskBQODuvoV+hf0k8cSyXG/GuAT4LKYaCiT9qiEGlbWxCIH51Qt1s0y2X56TbNja93AbzXiFWzsC2H6vwo3ZFcoj+YqUBsax+Gad0I6NME9lalpKsPtWqi4W/b3VbG5Mx+WBJ+L17GR7ZvWMo=\" # base64密文\ncipher = base64.b64decode(b64_sign)  # base64解码\npri_bio = BIO.MemoryBuffer(prikey.encode('utf-8'))  # 加载私钥\npri_rsa = RSA.load_key_bio(pri_bio)\nplain = pri_rsa.private_decrypt(cipher, RSA.pkcs1_padding)  # 解密\nprint(plain.decode('utf-8'))\nJava代码\nimport java.security.Key;\nimport java.security.KeyFactory;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.X509EncodedKeySpec;\nimport java.util.Base64;\n\nimport javax.crypto.Cipher;\n\npublic class rsa_demo {\n    \n    public String encryptoMode =\"RSA/ECB/PKCS1Padding\";\n    //public String encryptoMode =\"RSA/ECB/NoPadding\";\n\n    private String priKey=\"私钥字符串\";\n    \n    private String pubKey=\"公钥字符串\";\n    \n    public String sign_str = \"123456\" ;\n     /***\n      * 秘钥的来源方式 openssl 生成\n      */\n     \n     /**\n      * 获得公钥\n      * @return\n     * @throws NoSuchAlgorithmException \n     * @throws InvalidKeySpecException \n      */\n     private PublicKey getPublicKey(String pubKeyString) throws NoSuchAlgorithmException, InvalidKeySpecException {\n         byte[] pubKeyByte = Base64.getDecoder().decode(pubKey);\n         X509EncodedKeySpec spec = new X509EncodedKeySpec(pubKeyByte);\n         KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");    \n         PublicKey pubkey = keyFactory.generatePublic(spec); \n         return pubkey;\n     }\n     /**\n      * 获得私钥\n      * @return\n      */\n     private PrivateKey getPrivateKey(String priKeyString) throws NoSuchAlgorithmException, InvalidKeySpecException {\n         byte[] priKeyByte = Base64.getDecoder().decode(priKey);\n         PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(priKeyByte);\n         KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");    \n         PrivateKey priKey = keyFactory.generatePrivate(spec);    \n         return priKey;\n     }\n     \n     /**\n      * 公钥加密 （私钥加密）\n      */\n     public String encrypto(String text,Key key) {\n         try{\n                Cipher cipher = Cipher.getInstance(encryptoMode);\n                cipher.init(Cipher.ENCRYPT_MODE, key);\n                byte tempBytes[] = cipher.doFinal(text.getBytes());\n                String secretText=Base64.getEncoder().encodeToString(tempBytes);\n                return secretText;\n            }catch(Exception e){\n                throw new RuntimeException(\"加密字符串[\" + text + \"]时遇到异常\", e);\n            }\n     }\n     /**\n      * 私钥解密（公钥解密）\n      * @param secretText\n      */\n     public String decrypto(String secretText,Key key) {\n         try{\n                //生成公钥\n                Cipher cipher = Cipher.getInstance(encryptoMode);\n                cipher.init(Cipher.DECRYPT_MODE, key);\n                // 密文解码\n                byte[] secretText_decode = Base64.getDecoder().decode(secretText.getBytes());\n                byte tempBytes[] = cipher.doFinal(secretText_decode);\n                String text=new String( tempBytes);\n                return text;\n            }catch(Exception e){\n                throw new RuntimeException(\"解密字符串[\" + secretText + \"]时遇到异常\", e);\n            }\n     }\n    /**\n     * 由于每次公钥 加密出来的结果都不一样，所有python java 每次加密出来的结果都不一样，也就没有可比性。我们只考虑能解密就行 \n     * @param args\n     */\n    public static void main(String[] args) throws Exception {\n        \n        rsa_demo rsa = new rsa_demo();\n        System.err.println(\"明文:\"+rsa.sign_str);\n        PublicKey pubkey = rsa.getPublicKey(rsa.pubKey);\n        PrivateKey prikey = rsa.getPrivateKey(rsa.priKey);\n        String secretText = rsa.encrypto(rsa.sign_str,pubkey);//公钥加密，私钥解密\n    \n        secretText=\"Lm9PN4oM1dl17d2XFYRIs+hDV6RkGPVYBjgYAglaj020v5RnYzClHUN6lOVBzpeYKyH1MY5JzyOfxuYZHKCupVqhcvY4+zx+jowBH2nbVp1+/OrzuiPkNivfvmEad6ImAZp5/3Y/dVafABm5xZE78j7Ytlv0ak4seXMGTisU39o=\";\n        System.out.println(\"密文:\"+secretText);\n        String text =  rsa.decrypto(secretText,prikey);\n        \n        System.out.println(\"明文:\"+text);\n        \n    }\n    \n    \n}\n\nnote\n1 公钥私钥:使用openssl生成pkcs#1格式的公钥私钥pem文件。python直接使用该密钥；Java需要转换为pkcs#8格式公钥私钥，密钥字符串不需要BEGIN/END。\n2 python可以将公钥私钥的字符串直接保存使用，避免每次读pem文件。\n3 M2Crypto库安装会有环境问题，centOS直接pip安装成功，Ubuntu安装失败。\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}