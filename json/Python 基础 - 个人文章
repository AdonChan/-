{"title": "Python 基础 - 个人文章 ", "index": "python", "content": "Python　基础\n基础\n函数\n定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。\ndef my_abs(x):\n    if x >= 0:\n        return x\n    else:\n        return -x\n// my_abs(-9)  调用        \n空函数\n如果想定义一个什么事也不做的空函数，可以用pass语句：\ndef nop():\n    pass\n// pass 作为占位符    \n在其他语句里\nif age >= 18:\n    pass\n参数检查\n调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出TypeError\ndef my_abs(x):\n    if not isinstance(x, (int, float)):\n        raise TypeError('bad operand type')\n    // 数据类型检查可以用内置函数isinstance()实现：\n    if x >= 0:\n        return x\n    else:\n        return -x\n返回多个值\nimport math\n\ndef move(x, y, step, angle=0):\n    nx = x + step * math.cos(angle)\n    ny = y - step * math.sin(angle)\n    return nx, ny\n    \n默认参数\n定义默认参数要牢记一点：默认参数必须指向不变对象！\ndef enroll(name, gender, age=6, city='shanghai'):\n  print('gender:',gender)\n  print('age:',age)\n  print('city:',city)\n\nenroll('shan','F')\nenroll('shan','M',5,'beijing')\nenroll('shan','F',age=6)\n\ndef add_end(L=None):\n    if L is None:\n        L = []\n    L.append('END')\n    return L\n    \nadd_end()    \n可变参数\ndef calc(numbers):\n    sum = 0\n    for n in numbers:\n        sum = sum + n * n\n    return sum\n    \ncalc([1, 2, 3]) //  调用的时候，需要先组装出一个list或tuple\ncalc(1, 2, 3)\nnums = [1, 2, 3]\ncalc(*nums)   // 定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号\n关键字参数\n关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict\ndef person(name, age, **kw):\n    print('name:', name, 'age:', age, 'other:', kw)\n    \nperson('Bob', 35, city='Beijing')\nperson('Adam', 45, gender='M', job='Engineer')\nextra = {'city': 'Beijing', 'job': 'Engineer'}\nperson('Jack', 24, **extra)   // **extra表示把extra这个dict的所有key-value用关键字参数传入到函数的**kw参数  \n命名关键字参数\n如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数和关键字参数*kw不同，命名关键字参数需要一个特殊分隔符，*后面的参数被视为命名关键字参数。\ndef person(name, age, *, city, job):\n    print(name, age, city, job)\n\nperson('Jack', 24, city='Beijing', job='Engineer')\n# person('Jack', 24, 'Beijing', 'Engineer')   命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错\n如果没有可变参数，就必须加一个作为特殊分隔符。如果缺少，Python解释器将无法识别位置参数和命名关键字参数：\ndef person(name, age, city, job):\n    # 缺少 *，city和job被视为位置参数\n    pass\n参数组合\n在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。\n\ndef f1(a, b, c=0, *args, **kw):\n    print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)\ndef f2(a, b, c=0, *, d, **kw):\n    print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw)\n在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。\n>>> f1(1, 2)\na = 1 b = 2 c = 0 args = () kw = {}\n>>> f1(1, 2, c=3)\na = 1 b = 2 c = 3 args = () kw = {}\n>>> f1(1, 2, 3, 'a', 'b')\na = 1 b = 2 c = 3 args = ('a', 'b') kw = {}\n>>> f1(1, 2, 3, 'a', 'b', x=99)\na = 1 b = 2 c = 3 args = ('a', 'b') kw = {'x': 99}\n>>> f2(1, 2, d=99, ext=None)\na = 1 b = 2 c = 0 d = 99 kw = {'ext': None}\n最神奇的是通过一个tuple和dict，你也可以调用上述函数：\n>>> args = (1, 2, 3, 4)\n>>> kw = {'d': 99, 'x': '#'}\n>>> f1(*args, **kw)\na = 1 b = 2 c = 3 args = (4,) kw = {'d': 99, 'x': '#'}\n>>> args = (1, 2, 3)\n>>> kw = {'d': 88, 'x': '#'}\n>>> f2(*args, **kw)\na = 1 b = 2 c = 3 d = 88 kw = {'x': '#'}\n递归函数\n在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。\n举个例子，计算阶乘n! = 1 x 2 x 3 x ... x n\ndef fact(n):\n    if n==1:\n        return 1\n    return n * fact(n - 1)\n使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。\n可以试试fact(1000)：\n尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。\ndef fact(n):\n    return fact_iter(n, 1)\n\ndef fact_iter(num, product):\n    if num == 1:\n        return product\n    return fact_iter(num - 1, num * product)\n    \n切片\n取前N个元素\n　L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']\n for i in range(n):\n     r.append(L[i])\n  L[0:3] // 完成切片 \n L[-2:]  //　倒数第２个开始\nL[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。倒数第一个元素的索引是-1\nL = list(range(100))\n# >>> L [0, 1, 2, 3, ..., 99]\n\n>>> L[:10] 前10个数\n>>> L[-10:] 后10个数：\n>>> L[10:20] 前11-20个数\n>>> L[:10:2]  前10个数，每两个取一个\n>>> L[::5] 所有数，每5个取一个：\n>>> L[:] 所有的\n字符串'xxx'也可以看成是一种list，每个元素就是一个字符。\n>>> 'ABCDEFG'[:3]\n'ABC'\n>>> 'ABCDEFG'[::2]\n'ACEG'\n\ndef trim(s):\n  if (s[:1] == ' '):\n    return trim(s[1:])\n  if (s[-1:] == ' '):\n    return trim(s[:-1])\n  return s\n\n迭代\n如果给定一个list或tuple，通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）\nd = {'a': 1, 'b': 2, 'c': 3}\nfor key in d:\n  print(key)\ndict的存储不是按照list的方式顺序排列，所以，迭代出的结果顺序很可能不一样\nfor ch in 'abcde'\n  print(ch)\n如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断：\n>>> from collections import Iterable\n>>> isinstance('abc', Iterable) # str是否可迭代\nTrue\n>>> isinstance([1,2,3], Iterable) # list是否可迭代\nTrue\n>>> isinstance(123, Iterable) # 整数是否可迭代\nFalse\n# Python内置的enumerate函数可以把一个list变成索引-元素对\nfor i, value in enumerate(['A', 'B', 'C']):\n  print(i, value)\n# 在for循环中，引用了两个变量\n for x, y in [(1, 1), (2, 4), (3, 9)]:\n   print(x, y)\n列表生成式\nList Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式\n>>> list(range(1, 11))\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n>>> L = []\n>>> for x in range(1, 11):\n    L.append(x * x)\n>>>[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n\n>>> [x * x for x in range(1, 11)]\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n# for循环后面加条件判断\n>>>[x * x for x in range(1, 11) if x % 2 == 0]\n[4, 16, 36, 64, 100]\n# 两层循环\n[m + n for m in 'ABC' for n in 'XYZ']\n['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']\n\nimport os # 导入os模块，模块的概念后面讲到\n>>> [d for d in os.listdir('.')] # os.listdir可以列出文件和目录\n\nfor循环其实可以同时使用两个甚至多个变量\nd = {'x': 'A', 'y': 'B', 'z': 'C' }\n for k, v in d.items():\n   print(k, '=', v)\n[k + '=' + v for k, v in d.items()]\nL = ['Hello', 'World', 'IBM', 'Apple']\n[s.lower() for s in L] #大写变小写\n\n生成器\n如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。\n>>> L = [x * x for x in range(10)]\n>>> L\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n>>> g = (x * x for x in range(10))\n>>> g\n<generator object <genexpr> at 0x1022ef63\nnext(g)\n\nfor n in g:\n  print(n)\n\n创建L和g的区别仅在于最外层的[]和()，L是一个list，而g是一个generator。\n可以通过next()函数获得generator的下一个返回值：\n著名的斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到,函数\ndef fib(max):\n    n, a, b = 0, 0, 1\n    while n < max:\n        print(b)\n        a, b = b, a + b\n        n = n + 1\n    return 'done'\n    \n把fib函数变成generator，只需要把print(b)改为yield b就可以了：\ndef fib(max):\n    n, a, b = 0, 0, 1\n    while n < max:\n        yield b\n        a, b = b, a + b\n        n = n + 1\n    return 'done'\n\n>>> f = fib(6)\n>>> f\n<generator object fib at 0x104feaaa0>\n最难理解的就是generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。用for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中：\n>>> g = fib(6)\n while True:\n     try:\n       x = next(g)\n        print('g:', x)\n    except StopIteration as e:\n       print('Generator return value:', e.value)       break\n迭代器\n凡是可作用于for循环的对象都是Iterable类型；\n凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；\n集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。\nfor x in [1, 2, 3, 4, 5]:\n    pass\n实际上完全等价于：\n\n# 首先获得Iterator对象:\nit = iter([1, 2, 3, 4, 5])\n# 循环:\nwhile True:\n    try:\n        # 获得下一个值:\n        x = next(it)\n    except StopIteration:\n        # 遇到StopIteration就退出循环\n        break\n使用isinstance()判断一个对象是否是Iterable对象：\n>>> from collections import Iterable\n>>> isinstance([], Iterable)\nTrue\n>>> isinstance({}, Iterable)\nTrue\n>>> isinstance('abc', Iterable)\nTrue\n>>> isinstance((x for x in range(10)), Iterable)\nTrue\n>>> isinstance(100, Iterable)\nFalse\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}