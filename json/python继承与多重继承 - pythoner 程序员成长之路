{"title": "python继承与多重继承 - pythoner 程序员成长之路 ", "index": "python", "content": "记住以下几点:\n\n\n直接子类化内置类型(如dict,list或str)容易出错,因为内置类型的方法通常会忽略用户覆盖的方法,不要子类化内置类型,用户自定义的类应该继承collections模块.\n    def __setitem__(self, key, value):\n        super().__setitem__(key, [value] * 2) # 错误案例\n\n\nclass AnswerDict(dict):\n    def __getitem__(self, item): # 错误案例\n        return 42\n\n\nimport collections\n\n\nclass DoppelDict2(collections.UserDict): # 正确案例\n    def __setitem__(self, key, value):\n        super().__setitem__(key, [value] * 2)\n\n\nclass AnswerDict2(collections.UserDict): # 正确案例\n    def __getitem__(self, item):\n        return 42\n\n\n多重继承有关的另一个问题就是:如果同级别的超类定义了同名属性.Python如何确定使用哪个?\nclass DoppelDict(dict):\n    def __setitem__(self, key, value):\n        super().__setitem__(key, [value] * 2)\n\n\nclass AnswerDict(dict):\n    def __getitem__(self, item):\n        return 42\n\n\nimport collections\n\n\nclass DoppelDict2(collections.UserDict):\n    def __setitem__(self, key, value):\n        super().__setitem__(key, [value] * 2)\n\n\nclass AnswerDict2(collections.UserDict):\n    def __getitem__(self, item):\n        return 42\n\n\nclass A:\n    def ping(self):\n        print('Ping:', self)\n\n\nclass B(A):\n    def pong(self):\n        print('pong:', self)\n\n\nclass C(A):\n    def pong(self):\n        print('PONG:', self)\n\n\nclass D(B, C):\n    def ping(self):\n        super().ping()\n        print('post-ping:', self)\n\n    def pingpong(self):\n        self.ping()\n        super().ping()\n        self.pong()\n        super().pong()\n        C.pong(self)\nif __name__ == '__main__':\n\n    d = D()\n    print(d.pong()) # 输出来源于B\n    print(C.pong(d)) #输出来源于C 超类的方法都可以直接调用,此时要把实例作为显示参数传入.\npython能区别调用的是哪个方法,通过方法解析顺序>>> D.mro() [<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]  若想把方法调用委托给超类,推荐的方式是使用内置的super()函数.\n\n\n以下是对于d.pingpong()方法的解读\n>>> self.ping()\n\nPing: <__main__.D object at 0x000002213877F2B0> post-ping: <__main__.D object at 0x000002213877F2B0> 第一个调用的是self.ping(),运行的是是D类的ping,方法.\n第二个调用的的是super().ping(),跳过D类的ping方法,找到A类的ping方法.Ping: <__main__.D object at 0x000002213877F2B0>\n\n第三个调用的是self.pong()方法,根据__mro__,找到B类实现的pong方法. pong: <__main__.D object at 0x000002213877F2B0>\n\n第四个调用时super().pong(),也是根据__mro__,找到B类实现的pong方法. pong: <__main__.D object at 0x000002213877F2B0>\n\n\n第五个调用的是C.pong(self),忽略了__mro__,找到的是C类实现的pong方法. PONG: <__main__.D object at 0x000002213877F2B0>\n\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}