{"title": "流畅的python读书笔记-第七章-函数装饰器和闭包 - 个人文章 ", "index": "python", "content": "函数装饰器和闭包\n严格来说，装饰器只是语法糖。如前所示，装饰器可以像常规的可调用对象那样调用，其参数是另一个函数。有时，这样做更方便，尤其是做元编程（在运行时改变程序的行为）时。\nPython何时执行装饰器\n它们在被装饰的函数定义之后立即运行。这通常是在导入时（即 Python 加载模块时）\nregistry = []\n\ndef register(func):\n    print('running register(%s)' % func)\n    registry.append(func)\n    return func\n\n@register\ndef f1():\n    print('running f1()')\n\n@register\ndef f2():\n    print('running f2()')\n\ndef f3():\n    print('running f3()')\n\ndef main():\n    print('running main()')\n    print('registry ->', registry)\n    f1()\n    f2()\n    f3()\n\nif __name__=='__main__':\n    main()\n把 registration.py 当作脚本运行得到的输出如下：\n$ python3 registration.py\nrunning register(<function f1 at 0x100631bf8>)\nrunning register(<function f2 at 0x100631c80>)\nrunning main()\nregistry -> [<function f1 at 0x100631bf8>, <function f2 at 0x100631c80>]\nrunning f1()\nrunning f2()\nrunning f3()\n如果导入 registration.py 模块（不作为脚本运行），输出如下：\n>>> import registration\nrunning register(<function f1 at 0x10063b1e0>)\nrunning register(<function f2 at 0x10063b268>)\n此时查看 registry 的值，得到的输出如下：\n>>> registration.registry\n[<function f1 at 0x10063b1e0>, <function f2 at 0x10063b268>]\n装饰器在真实代码中的常用方式\n装饰器函数与被装饰的函数在同一个模块中定义。实际情况是，装饰器通常在一个模块中定义，然后应用到其他模块中的函数上。\n使用装饰器改进“策略”模式\npromos = []\n\n\ndef promotion(promo_func):\n    promos.append(promo_func)\n    return\n\n\n@promotion\ndef fidelity(order):\n    \"\"\"为积分为1000或以上的顾客提供5%折扣\"\"\"\n    return order.total() * .05 if order.customer.fidelity >= 1000 else 0\n\n\n@promotion\ndef bulk_item(order):\n    \"\"\"单个商品为20个或以上时提供10%折扣\"\"\"\n    discount = 0\n    for item in order.cart:\n        if item.quantity >= 20:\n            discount += item.total() * .1\n    return discount\n\n\n@promotion\ndef large_order(order):\n    \"\"\"订单中的不同商品达到10个或以上时提供7%折扣\"\"\"\n    distinct_items = {item.product for item in order.cart}\n    if len(distinct_items) >= 10:\n        return order.total() * .07\n    return 0\n\n\ndef best_promo(order):\n    \"\"\"选择可用的最佳折扣\"\"\"\n    return max(promo(order) for promo in promos)\n\n\npromotion 把 promo_func 添加到 promos 列表中，然后原封不动地将其返回。\n被 @promotion 装饰的函数都会添加到 promos 列表中。\n\n与 6.1 节给出的方案相比，这个方案有几个优点。\n\n促销策略函数无需使用特殊的名称（即不用以 _promo 结尾）。\n@promotion 装饰器突出了被装饰的函数的作用，还便于临时禁用\n某个促销策略：只需把装饰器注释掉。\n促销折扣策略可以在其他模块中定义，在系统中的任何地方都行，只要使用 @promotion 装饰即可。\n\n变量作用域规则\n神奇的例子\n>>> b = 6\n>>> def f2(a):\n... print(a)\n... print(b)\n... b = 9\n...\n>>> f2(3)\n3\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"<stdin>\", line 3, in f2\nUnboundLocalError: local variable 'b' referenced before assignment\nb = 9###### 它判断 b 是局部变量，因为在函数中给它赋值了\n\n可事实是，Python 编译函数的定义体时，它判断 b 是局部变量，因为在函数中给它赋值了。\n生成的字节码证实了这种判断，Python 会尝试从本地环境获取 b。\n后面调用 f2(3) 时， f2 的定义体会获取并打印局部变量 a 的值，但是尝试获取局部变量 b 的值时，发现 b 没有绑定值。\n\n为什么会这样\n\n这不是缺陷，而是设计选择：Python 不要求声明变量，但是假定在函数定义体中赋值的变量是局部变量。\n这比 JavaScript 的行为好多了，JavaScript 也不要求声明变量，但是如果忘记把变量声明为局部变量使用 var），可能会在不知情的情况下获取全局变量。\n\n利用global就可以啦\n>>> b = 6\n>>> def f3(a):\n... global b\n... print(a)\n... print(b)\n... b = 9\n...\n>>> f3(3)\n3\n6\n闭包\n人们有时会把闭包和匿名函数弄混。这是有历史原因的：在函数内部定义函数不常见，直到开始使用匿名函数才会这样做，\n注意:\n\n函数是不是匿名的没有关系，关键是它能访问定义体之外定义的非全局变量。\n只有涉及嵌套函数时才有闭包问题。因此，很多人是同时知道这两个概念的。\n\n案例\n假如有个名为 avg 的函数，它的作用是计算不断增加的系列值的均值；\n初学者可能会这样\nclass Averager():\n    def __init__(self):\n        self.series = []\n\n    def __call__(self, new_value):\n        self.series.append(new_value)\n        total = sum(self.series)\n        return total / len(self.series)\n>>> avg = Averager()\n>>> avg(10)\n10.0\n>>> avg(11)\n10.5\n>>> avg(12)\n11.0\n函数式实现，使用高阶函数 make_averager。\ndef make_averager():\n    series = []\n\n    def averager(new_value):\n        series.append(new_value)\n        total = sum(series)\n        return total / len(series)\n\n    return averager\n重要概念\n在 averager 函数中，series 是自由变量（free variable）。这是一个技术术语，指未在本地作用域中绑定的变量.\n\n审查 make_averager（见示例 7-9）创建的函数\n>>> avg.__code__.co_varnames\n('new_value', 'total')\n>>> avg.__code__.co_freevars\n('series',)\n\nseries 的绑定在返回的 avg 函数的 closure 属性中。\navg.__closure__ 中的各个元素对应于avg.__code__.co_freevars 中的一个名称。\n这些元素是 cell 对象，有个 cell_contents 属性，保存着真正的值。\n\n>>> avg.__code__.co_freevars\n('series',)\n>>> avg.__closure__\n(<cell at 0x107a44f78: list object at 0x107a91a48>,)\n>>> avg.__closure__[0].cell_contents\n[10, 11, 12]\n小总结\n\n综上，闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，\n这样调用函数时，虽然定义作用域不可用了，但是仍能使用那些绑定。\n注意，只有嵌套在其他函数中的函数才可能需要处理不在全局作用域中的外部变量。\n\nnonlocal声明\n计算移动平均值的高阶函数，不保存所有历史值，但有缺陷\ndef make_averager():\n    count = 0\n    total = 0\n\n    def averager(new_value):\n        count += 1\n        total += new_value\n        return total / count\n\n    return averager\n问题是，当 count 是数字或任何不可变类型时\ncount += 1 语句的作用其实与 count = count + 1 一样。因此，我们在 averager 的定义体中为 count 赋值了，这会把 count 变成局部变量。\n注意\n示例 7-9 没遇到这个问题，因为我们没有给 series 赋值，我们只是调用 series.append，并把它传给 sum 和 len。也就是说，我们利用了列表是可变的对象这一事实。但是对数字、字符串、元组等不可变类型来说，只能读取，不能更新。如果尝试重新绑定，例如 count = count + 1，其实会隐式创建局部变量 count。这样，count 就不是自由变量了，因此不会保存在闭包中。\n\n解决这个问题\n为了解决这个问题，Python 3 引入了 nonlocal 声明。它的作用是把变量标记为自由变量，即使在函数中为变量赋予新值了，也会变成自由变量。如果为 nonlocal 声明的变量赋予新值，闭包中保存的绑定会更新。\ndef make_averager():\n    count = 0\n    total = 0\n\n    def averager(new_value):\n        nonlocal count,total\n        count += 1\n        total += new_value\n        return total / count\n\n    return averager\n\n对付没有 nonlocal 的 Python 2\n基本上，这种处理方式是把内部函数需要修改的变量（如 count 和 total）存储为可变对象（如字典或简单的实例）的元素或属性，并且把那个对象绑定给一个自由变量。\n实现一个简单的装饰器\nimport time\n\n\ndef clock(func):\n    def clocked(*args):\n        t0 = time.perf_counter()\n        result = func(*args)\n        elapsed = time.perf_counter() - t0\n        name = func.__name__\n        args_str = ''.join(repr(arg) for arg in args)\n\n        print('[%0.8fs] %s(%s) -> %r' % (elapsed, name, args_str, result))\n        return result\n\n    return clocked\n\n\n@clock\ndef snooze(seconds):\n    time.sleep(seconds)\n\n\n@clock\ndef factorial(n):\n    return 1 if n < 2 else n * factorial(n - 1)\n\n\nif __name__ == \"__main__\":\n    print(\"*\" * 40)\n    snooze(0.123)\n    print(\"*\" * 40)\n    factorial(6)\n\n    ## 这里的函数对象变成了从clocked\n    print(factorial.__name__)\n\n这是装饰器的典型行为：把被装饰的函数替换成新函数，二者接受相同的参数，而且（通\n常）返回被装饰的函数本该返回的值，同时还会做些额外操作。\n\n上面实现的 clock 装饰器有几个缺点：不支持关键字参数，而且遮盖了被装饰函数的 name 和 doc 属性。\n使用 functools.wraps 装饰器把相关的属性从 func 复制到 clocked 中。此外，这个新版还能正确处理关键字参数。\n\nimport time\nimport functools\n\n\ndef clock(func):\n    @functools.wraps(func)  ###这里 保留__name__ 和 __doc__ 属性\n    def clocked(*args, **kwargs):\n        t0 = time.time()\n        result = func(*args, **kwargs)\n        elapsed = time.time() - t0\n        name = func.__name__\n        arg_lst = []\n        if args:\n            arg_lst.append(', '.join(repr(arg) for arg in args))\n        if kwargs:\n            pairs = ['%s=%r' % (k, w) for k, w in sorted(kwargs.items())]\n        arg_lst.append(', '.join(pairs))\n        arg_str = ', '.join(arg_lst)\n        print('[%0.8fs] %s(%s) -> %r ' % (elapsed, name, arg_str, result))\n        return result\n\n    return clocked\n\n标准库中的装饰器\nfunctools.lru_cache 是非常实用的装饰器，它实现了备忘（memoization）功能。就是更加利用缓存干活\nimport time\nimport functools\n\n\ndef clock(func):\n    @functools.wraps(func)\n    def clocked(*args, **kwargs):\n        t0 = time.time()\n        result = func(*args, **kwargs)\n        elapsed = time.time() - t0\n        name = func.__name__\n        arg_lst = []\n        if args:\n            arg_lst.append(', '.join(repr(arg) for arg in args))\n        if kwargs:\n            pairs = ['%s=%r' % (k, w) for k, w in sorted(kwargs.items())]\n        arg_lst.append(', '.join(pairs))\n        arg_str = ', '.join(arg_lst)\n        print('[%0.8fs] %s(%s) -> %r ' % (elapsed, name, arg_str, result))\n        return result\n\n    return clocked\n\n\n\n\n\n@clock\ndef fibonacci(n):\n    if n < 2:\n        return n\n    return fibonacci(n - 2) + fibonacci(n - 1)\n\n\nif __name__ == '__main__':\n    print(fibonacci(6))\n\n浪费时间的地方很明显：fibonacci(1) 调用了 8 次，fibonacci(2) 调用了 5 次……但是，如果增加两行代码，使用 lru_cache，性能会显著改善，\nimport time\nimport functools\n\n\ndef clock(func):\n    @functools.wraps(func)\n    def clocked(*args, **kwargs):\n        t0 = time.time()\n        result = func(*args, **kwargs)\n        elapsed = time.time() - t0\n        name = func.__name__\n        arg_lst = []\n        if args:\n            arg_lst.append(', '.join(repr(arg) for arg in args))\n        if kwargs:\n            pairs = ['%s=%r' % (k, w) for k, w in sorted(kwargs.items())]\n        arg_lst.append(', '.join(pairs))\n        arg_str = ', '.join(arg_lst)\n        print('[%0.8fs] %s(%s) -> %r ' % (elapsed, name, arg_str, result))\n        return result\n\n    return clocked\n\n\n@functools.lru_cache()  # \n@clock  #\ndef fibonacci(n):\n    if n < 2:\n        return n\n    return fibonacci(n - 2) + fibonacci(n - 1)\n\n\nif __name__ == '__main__':\n    print(fibonacci(6))\n\n❶ 注意，必须像常规函数那样调用 lru_cache。这一行中有一对括号：@functools.lru_cache()。这么做的原因是，lru_cache 可以接受配置参数，稍后说明。\nlru_cache 可以使用两个可选的参数来配置。\nfunctools.lru_cache(maxsize=128, typed=False)\n\nmaxsize 参数指定存储多少个调用的结果。\n缓存满了之后，旧的结果会被扔掉，腾出空间。\n为了得到最佳性能，maxsize 应该设为 2 的幂。typed 参数如果设为 True，把不同\n参数类型得到的结果分开保存，即把通常认为相等的浮点数和整数参数（如 1 和 1.0）区\n\n分开。\nfunctools.singledispatch 装饰器  让Python强行支持重载方法\n因为 Python 不支持重载方法或函数，所以我们不能使用不同的签名定义 htmlize 的变体，也无法使用不同的方式处理不同的数据类型。\n使用 @singledispatch 装饰的普通函数会变成泛函数（generic function）：根据第一个参数的类型，以不同方式执行相同操作的一组函数。\n让Python强行支持重载方法,不再使用一串 if/elif/elif，调用专门的函数\nsingledispatch 创建一个自定义的 htmlize.register 装饰器，把多\n个函数绑在一起组成一个泛函数\nfrom functools import singledispatch\nfrom collections import abc\nimport numbers\nimport html\n\n\n@singledispatch\ndef htmlize(obj):\n    content = html.escape(repr(obj))\n    return '<pre>{}</pre>'.format(content)\n\n\n@htmlize.register(str)\ndef _(text):\n    content = html.escape(text).replace('\\n', '<br>\\n')\n    return '<p>{0}</p>'.format(content)\n\n\n@htmlize.register(numbers.Integral)\ndef _(n):\n    return '<pre>{0} (0x{0:x})</pre>'.format(n)\n\n\n@htmlize.register(tuple)\n@htmlize.register(abc.MutableSequence)\ndef _(seq):\n    inner = '</li>\\n<li>'.join(htmlize(item) for item in seq)\n    return '<ul>\\n<li>' + inner + '</li>\\n</ul>'\n\nprint(htmlize({1, 2, 3}))\n\nprint(htmlize(abs))\n\nprint(htmlize('Heimlich & Co.\\n- a game'))\nprint(htmlize(42))\n\n##这个强啊!!!\nprint(htmlize(['alpha', 66, {3, 2, 1}]))\n\n❷ 各个专门函数使用 @«base_function».register(«type») 装饰。❸ 专门函数的名称无关紧要；_ 是个不错的选择，简单明了。为每个需要特殊处理的类型注册一个函数。numbers.Integral 是 int 的虚拟超类。❺ 可以叠放多个 register 装饰器，让同一个函数支持不同类型。\n\n只要可能，注册的专门函数应该处理抽象基类（如 numbers.Integral 和abc.MutableSequence），不要处理具体实现（如 int 和 list）。这样，代码支持的兼容类型更广泛。\n例如，Python 扩展可以子类化 numbers.Integral，使用固定的位数实现 int 类型。\n\n注意:\n\n@singledispatch 不是为了把 Java 的那种方法重载带入 Python。在一个类中 为同一个方法定义多个重载变体，\n@singledispath 的优点是支持模块化扩展：各个模块可以为它支持的各个类型注册一个专门函数。\n\n叠放装饰器\n@d1\n@d2\ndef f():\n    print('f')\n等同于\ndef f():\n    print('f')\nf = d1(d2(f))\n一个参数化的注册装饰器\n为了便于启用或禁用 register 执行的函数注册功能，我们为它提供一个可选的 active参数，设为 False 时，不注册被装饰的函数。\nregistry = set()\n\n\ndef register(active=True):\n    def decorate(func):\n        print('running register(active=%s)->decorate(%s)'\n              % (active, func))\n        if active:\n            registry.add(func)\n        else:\n            registry.discard(func)\n            return func\n\n    return decorate\n\n\n@register(active=False)\ndef f1():\n    print('running f1()')\n\n@register()\ndef f2():\n    print('running f2()')\n\ndef f3():\n    print('running f3()')\n\nif __name__ ==\"__main__\":\n    print(registry)\n参数化装饰器通常会把被装饰的函数替换掉，而且结构上需要多一层嵌套。\n参数化clock装饰器\nimport time\n\nDEFAULT_FMT = '花费时间:[{elapsed:0.5f}s] 程序名:{name}  参数:({args}) -> 结果:{result}'\n\n\ndef clock(fmt=DEFAULT_FMT):\n    def decorate(func):\n        def clocked(*_args):\n            t0 = time.time()\n            _result = func(*_args)\n\n            ### locals() 局部变量\n            elapsed = time.time() - t0\n            name = func.__name__\n            args = ', '.join(repr(arg) for arg in _args)\n            result = repr(_result)\n                # 这里不知道他为什么这么能用\n            print(fmt.format(**locals()))\n\n            return _result\n\n        return clocked\n\n    return decorate\n\n\nif __name__ == '__main__':\n\n    # ## 第一种情况\n    # @clock()\n    # def snooze(seconds):\n    #     time.sleep(seconds)\n\n\n    ## 第二种情况\n    # @clock('程序名:{name}: 花费时间:{elapsed}s')\n    # def snooze(seconds):\n    #     time.sleep(seconds)\n\n    ## 第三种情况\n    @clock('程序名:{name}  参数:({args})  花费时间:dt={elapsed:0.3f}s')\n    def snooze(seconds):\n        time.sleep(seconds)\n\n\n\n    snooze(0.123)\n\n\n\nclock 是参数化装饰器工厂函数❷ decorate 是真正的装饰器。❸ clocked 包装被装饰的函数。❹ _result 是被装饰的函数返回的真正结果\n这里的locals()是啥不知道\ndef runnoob(arg:'int'):\n    z = 1\n    print(arg + 1)\n\n    # 返回字典类型的局部变量。\n    print('==='*30)\n    print(locals())\n\n    # 返回字典类型的全部变量。\n    print('=' * 50)\n    print(globals())\n\n\n\nnum = 8\nrunnoob(num)\n\n小总结\n\n严格来说，装饰器只是语法糖。\n它们在被装饰的函数定义之后立即运行。这通常是在导入时（即 Python 加载模块时）\n装饰器改进了策略模式\n\n闭包\n\n闭包是一种函数，它会保留定义函数时存在的自由变量的绑定\nPython 3 引入了 nonlocal 声明。它的作用是把变\n\n量标记为自由变量\nfunctools.wraps 装饰器把相关的属性从 func 复制到 clocked 中。此外，这个新版还能正确处理关键字参数\nfunctools.lru_cache 是非常实用的装饰器，它实现了备忘（memoization）功能。就是更加利用缓存干活\nfunctools.singledispatch 装饰器  让Python强行支持重载方法\nlocals() globals()\n\n*locals\n** locals()\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "2"}