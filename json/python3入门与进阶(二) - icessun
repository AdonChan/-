{"title": "python3入门与进阶(二) - icessun ", "index": "python", "content": "变量\npython3中变量的定义是不固定类型的（动态），区分大小写\n\n\n值类型\n引用类型\n\n\n\n不可变的（值类型）\n可变的（引用类型）\n\n\nint (整型)\nlist (列表)\n\n\nstr (字符串)\nset (集合)\n\n\ntuple (元组)\ndict (字典)\n\n\n\n通过内置函数id(),可以知道变量在内存的位置\nb = \"icessun\"\nb = b + \"hello\"\nprint(b)\n>>> \"icessunhello\"  # 不是说字符串是不可变的嘛？怎么改变了\n如果字符串可以改变，那么可以使用索引值给字符串赋值\"python\"[0] = 'h' -----> 报错，会发现报错，是不行的。\n上面程序的结果是因为，+连接符，把两个字符串连接起来了，链接起来的值重新赋值给了b元素，使用id(b)函数，会发现其实上面两个b变量在内存的位置是不一样的，所以第一个b变量的值没有改变，被覆盖了。\n乘方的表示法  ：2**5  ----> 2的5次方=32\n\n身份运算符\nis  /  not is\na = (1,2,3)\nb = (1,3,2)\nprint(a is b)    # 元组是不可变的\nprint(a == b)  # 元组是有序的，值是不相等的\n>>> False    False\n\n# 集合\na = {1,2,3}\nb = {1,3,2}\nprint(a==b)  # 集合是无序的，所以值是相等的\nprint(a is b)\n>>> True False\n\n# 字符串，数字   两个取值相等，则is 返回True，但是数字有特殊\na = 'icessun'\nb = 'icessun'\nprint(a is b)\n>>> True\n\na = 1   \nb = 1\nc = 1.0\nprint(a==b)\nprint(a==c\nprint(a is b)\nprint(a is c)\n>>> True  True True False\n从上面可以看出，元组是不可变的，改变里面元素的位置就变成了两个新的元组。is不是比较两个变量的值是否相等，而是比较变量在内存的地址是否相等，算术运算符==是比较值是否相等的\n\n\n对象的三个特性\n一切都是对象\n\n\n\nid（）函数：变量在内存的地址\nis ：身份运算符\n\n\ntype（）函数：类型判断函数\nisinstance（变量，（int，str，float....））\n\n\nvalue值的比较\n== ：算术比较符\n\n\n\n成员运算符\n判断一个变量是否在一个变量里面 in / not in\n\nb= 'a'\nb in {'c':1}\n>>> False\n\nb=1\nb in {'c':1}\n>>> False\n\nb='c'\nb in {'c':1}\n>>> True\n优先级：not > and > or\n代码编写\n\n缩进来区分代码块，没有大括号{ }\n\n\npass：占位语句\n常量一般大写\n单行注释：#；推荐在这行语句的开头写，与上一条语句有空格\n多行注释： '''注释内容''' \n\n代码后面不需要分号，有也可以\n实例化一个对象，不需要new关键词\n\nif else  / elseif\na = input()\na = int(a)\nprint('a is ' + str(a))\n\nif a==1:\n    print('apple')\nelif a==2:\n    print('orange')\nelif a==3:\n    print('banana')\nelse:\n    print('shoppingp')\n\n# 使用 if  else\nif a==1:\n    print('apple')\nelse:\n    if a==2:\n        print('orange')\n    else:\n        if a==3:\n            print('banana')\n        else:\n            print('shopping')\ninput()接收用户的输入，elif功能类似于switch功能；int(a)：因为终端输入的是字符串，所以应该强制转为数字进行比较print('a is ' + str(a))：字符串的拼接只能两者都是字符串，否者会报错\nfor  变量  in 循环体 \n主要用来遍历循环：序列List，集合Set，字典Dict\na = [['apple','orange','banana','grape'],(1,2,3)]\nfor x in a:\n    for y in x:\n        if y=='orange':\n            break   #  continue\n        print(y)  # 默认是换行（print（y，end='/n'））输出的，要想不换行：print(y,end=' ')；故可以在end里面添加其他的符号来连接字符\nelse:\n    print('fruit is gone')\n\n>>> apple 1 2 3 fruit is gone\nbreak跳出里面的for循环，但是外面的for循环没有跳出，还是会执行；和else配对的是外面的for循环，所以依然会执行；要是在外层的for循环里面加入break，那么就不会执行else语句；for循环后面有else语句，当循环执行完毕，也会依然接着执行else语句，所以会输出fruit is gone；一般不推荐在for循环后面使用else语句\n循环中使用range()函数\nfor x in range(0,10):\n    print(x,end='|')\n>>> 0|1|2|3|4|5|6|7|8|9|\n\nfor x in range(10,0,-2):\n    print(x,end='|')\n>>> 10|8|6|4|2|\n\n# 打印列表a中所有的基奇数项\na=[1,2,3,4,5,6,7,8]\n\n# 循环+range（）函数的方法\nfor x in range(0,len(a),2):\n    print(a[x]) \n\n# 列表的切片的方法\nprint(a[0:len(a):2])\n\n>>> [1,3,7]\nrange()函数的作用类似于其他语言中的for(i = 初始值；i < 长度；i ++)；里面可以传入两个或者三个参数，两个参数的时候表示的是：初始值，长度；传入三个参数的时候表示的是：初始值，长度，步长\n序列解包\ndef ice(a,b):\n    a1=a*3\n    b1=b*2+10\n    return a1,b1\n\nice_a1,ice_b1 = ice(3,6)\nprint(ice_a1,ice_b1)\n>>> 9 22\n\na=1\nb=2                ====>    a,b,c=1,2,3  或者  (1,2,3)  当abc都相等的时候：a=b=c=1 或者 a,b,c=1,1,1\nc=3\n序列解包：就是当一个函数有多个返回值的时候，不需要使用一个变量接收到所有的返回值，然后又重新遍历返回值，取到对应的返回值；只需要使用和返回值个数对等的变量依次接收就行；当然只是针对返回值是值类型的函数。个数相等，顺序对应\n当在函数参数里面使用的时候，可以在实参里面修改默认值；在调用函数传入参数的时候，明确告诉实参，形参给传的是那个实参的值sum(y=3，x=2)\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}