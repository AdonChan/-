{"title": "Python入门学习(六) - 个人文章 ", "index": "python", "content": "在熟悉了Python中常用的一些内置函数, 那接下来我们定义一个自己的函数吧\ndef add(x, y):\n    return x + y\n函数\n函数语法\ndef functonname(parameters):\n    ...\n    return result\n定义空函数\ndef nop():\n    pass\n实际上 pass 是用来作为占位符的. 比如现在还没想好怎么写函数的代码, 就可以先放一个pass, 让其他代码可以运行起来.\n函数也是Object\ndef pow(x, y):\n    result = 1\n    for i in range(0, y):\n        result = result * x\n    return result\n\nprint(pow) #<function pow at 0x104147e18>\n函数也是内存中的一块区域, 函数名指向这块区域.\nfn = pow\nprint(fn) #<function pow at 0x104147e18>\nprint(fn(2, 10)) #1024\n参数\n\n必选参数\n默认参数\n可变参数\n关键字参数\n命名关键字参数\n\n必选参数\ndef pow(x, y):\n    result = 1\n    for i in range(0, y):\n        result = result * x\n    return result\n\nt = pow(2, 3)\nprint(t) # 8\n上面函数中, 需要两个参数分别是 x, y. 这两个参数都是必选参数, 缺一不可.pow函数中 x 为底数, y 为指数, 现在我想让指数默认为 2\n默认参数\ndef pow(x, y = 2):\n    result = 1\n    for i in range(0, y):\n        result = result * x\n    return result\n\nt = pow(2)\nprint(t) # 4\n设, 我要求多个数的和. 具体有多个参数, 我也不知道\n可变参数\ndef sum_1(numbers):\n    s = 0\n    for x in numbers:\n        s += x\n    return s\n\ndef sum_2(*numbers):\n    s = 0\n    for x in numbers:\n        s += x\n    return s\n\narr = [1, 2, 4]\nprint(sum_1(arr))\nprint(sum_2(1, 2, 4))\nprint(sum_2(*arr))\n关键字参数\n可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict\ndef person(name, age, **kw) :  # ** => dict\n    print(\"kw tyep is\", type(kw))\n    if \"city\" in kw : \n        print(\"city :\", kw[\"city\"])\n    if \"job\" in kw:\n        print(\"job :\", kw.get(\"job\"))\n    print(\"name:\", name, \", age:\", age, \", other:\", kw)\n\n\nperson(\"Jion\", 18, city = \"Beijing\")\nperson(name = \"Tom\", city = \"Beijing\", age = 17)\nextra = {'city': 'Beijing', 'job': 'Engineer'}\nperson(\"Jion\", 18, **extra)\n命名关键字参数\n如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数\ndef person(name, age, *, city, job):\n    print(name, age, city, job)\n命名关键字参数需要一个特殊分隔符 * ，* 后面的参数被视为命名关键字参数。\n>>> person('Jack', 24, city='Beijing', job='Engineer')\nJack 24 Beijing Engineer\n如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符 * 了.\ndef person(name, age, *, city = \"Beijing\", job):\n    # 要限制关键字参数的名字, 就要用到 \"命名关键字参数\"\n    # * 后的参数, 被视为\"命名关键字参数\"\n    print(name, age, city, job)\nperson(\"Jack\", 24, job = \"Engineer\")\nx = {\"city\":\"Shanghai\", \"job\":\"Engineer\"}\nperson(\"Jack\", 23, **x)\nperson(\"Jack\", 23, city = \"Beijing\", job = \"Engineer\")\n\ndef person(name, age, *args, city, job):\n    print(name, age, args, city, job)\nx = {\"A\":1, \"B\":2, \"C\":3}\n# 当实参为 *x 时, 会将实参中的key以tuple(元组)的形式, 传递到方法内\n# person(\"Jack\", 23, *x, city = \"Beijing\", job = \"Engineer\") # Jack 23 ('A', 'B', 'C') Beijing Engineer\n\n# 当实参为 x 时, 会将实参的整体内容做为tuple(元组)的一个元素, 传递到方法内\nperson(\"Jack\", 23, x, city = \"Beijing\", job = \"Engineer\") # Jack 23 ({'A': 1, 'B': 2, 'C': 3},) Beijing Engineer\n\n返回值\n返回常用类型\ndef abs(x):\n    if(x >= 0):\n        return x\n    else:\n        retrun -x\n\nprint(abs(-1)) #1\n\nreturn 类似出栈操作, return之后的语句则不被执行\n返回多个值\ndef show(x, y, z):\n    return x  * y * z, x + y + z\n\nx = show(2, 3, 4)\nprint(x[0], x[1]) #24 9\nprint(x) #(24, 9)\n当函数返回多个值时, 实际上是把多个需要返回的值, 封装成一个tuple\n\n返回函数\n刚刚说过, 函数也是一个Object, 所以也可以作为返回值进行返回\n递归\ndef trim(s):\n    if (s == ''):\n        return ''\n    if (ord(s[:1]) == 32):\n        return trim(s[1:])\n    elif (ord(s[-1:]) == 32):\n        return trim(s[:-1])\n    else:\n        return s\n这是一个去除字符串前后空格的函数, 首先检测字符串的第一位是不是空格, 如果是去掉第一位, 再次检查新字符串的第一位 直至不是后, 检查字符串的最后一位, 如果是, 则去掉最后一位, 再次检测新字符串的最后一位.直到最后一位,不再是空格.\n闭包\ndef make_adder(addend):\n    def adder(augend):\n        return augend + addend\n    return adder\n\np = make_adder(23)\nq = make_adder(44)\n\nprint(p(100)) #123\nprint(q(100)) #144\n闭包: 可以形象的把它理解为一个封闭的包裹，这个包裹就是一个函数，当然还有函数内部对应的逻辑，包裹里面的东西就是自由变量，自由变量可以在随着包裹到处游荡。当然还得有个前提，这个包裹是被创建出来的。在通过Python的语言介绍一下，一个闭包就是你调用了一个函数A，这个函数A返回了一个函数B给你。这个返回的函数B就叫做闭包。你在调用函数A的时候传递的参数就是自由变量。\ndef func(name):\n    def inner_func(age):\n        print 'name:', name, 'age:', age\n    return inner_func\n\nbb = func('the5fire')\nbb(26)  # >>> name: the5fire age: 26\n这里面调用func的时候就产生了一个闭包——inner_func,并且该闭包持有自由变量——name，因此这也意味着，当函数func的生命周期结束之后，name这个变量依然存在，因为它被闭包引用了，所以不会被回收。\ndef hellocounter (name):\n    count = 0\n    def counter():\n        # 如果不加 nonlocal 会报错\n        # UnboundLocalError: local variable 'count' referenced before assignment\n        nonlocal count\n        count += 1\n        print ('Hello {0}, {1} access!'.format(name, count))\n    return counter\n\nhello = hellocounter('ysisl')\nhello()\nhello()\nhello()\n在闭包函数内, 可以直接访问父函数作用域下的变量, 但不可以修改.python3里面,引入了一个关键字:nonlocal,这个关键字是干什么的? 就是告诉python程序, 我的这个count变量是再外部定义的, 你去外面找吧. 然后python就去外层函数找, 然后就找到了count = 0 这个定义和赋值, 程序就能正常执行了.\n装饰器\n装饰器: 是对闭包的一种实际运用的场景.\ndef makebold(fn):\n    def wrapped():\n        return \"<b>\" + fn() + \"</b>\"\n    return wrapped\n\ndef makeitalic(fn):\n    def wrapped():\n        return \"<i>\" + fn() + \"</i>\"\n    return wrapped\n\n@makebold\n@makeitalic\ndef hello():\n    return \"hello world\"\n\nprint hello() # <b><i>hello world</i></b>\n相当于 makebold(makeitalic(hello()))\nimport time\n\ndef timecost(func):\n    def wrapper(*args, **kw):\n        def fn(*args, **kw):\n            start = int(time.time())\n            print(\"Call {0}() Before [{1}]\".format(func.__name__, time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime(int(time.time())))))\n            func(*args, **kw)\n            print(\"Call {0}() After [{1}]\".format(func.__name__, time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime(int(time.time())))))\n            end = int(time.time())\n            print(\"Run Cost Time {0}s\".format(end - start))\n\n        return fn(*args, **kw)\n    return wrapper\n\n@timecost\ndef now_datetime(format):\n    now = int(time.time())\n    print(time.strftime(format, time.localtime(now)))\n\nnow_datetime(\"%H:%M:%S\")\n\n# Call now_datetime() Before [2018-01-15 00:24:17]\n# 00:24:17\n# Call now_datetime() After [2018-01-15 00:24:17]\n# Run Cost Time 0s\n# 在方法前后加入自己想要的内容, 哈哈, 这就是传说中的AOP吗?\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}