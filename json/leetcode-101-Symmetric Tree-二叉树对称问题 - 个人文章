{"title": "leetcode-101-Symmetric Tree-二叉树对称问题 - 个人文章 ", "index": "python", "content": "\ntopic:\n101. Symmetric Tree \nDescription:\nGiven a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).\n\nFor example\nthis binary tree [1,2,2,3,4,4,3] is symmetric:\n\n1    / \\   2   2  / \\ / \\ 3  4 4  3\nBut the following [1,2,2,null,3,null,3] is not:\n1    / \\   2   2    \\   \\    3    3 Note:\nBonus points if you could solve it both recursively and iteratively.\n\n解题思路：1.所谓的对称，是左右相反位置的节点的值判断是否相同。\n    2.所有的节点对称，是可以从源头追根溯源的。\n    3.只要出现不同，即可返回即可，否则继续进行处理。\n代码如下：\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\nfrom collections import deque\nclass Solution:\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return True\n        nodes_stack=[root.left,root.right]\n        while nodes_stack:\n            val_left,val_right=nodes_stack.pop(0),nodes_stack.pop(0)\n            if not val_left and not val_right:\n                continue\n            elif not val_left or not val_right:\n                return False\n            elif val_left.val!=val_right.val:\n                return False\n            else:\n                nodes_stack.extend([val_left.left,val_right.right,val_left.right,val_right.left])\n        return  True\n\n\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "0"}