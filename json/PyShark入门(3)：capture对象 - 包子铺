{"title": "PyShark入门(3)：capture对象 - 包子铺 ", "index": "pyshark,wireshark,python", "content": "原文链接：http://zodiacg.net/2016/07/in...\n本系列文章译自thePacketGeek的系列文章。原创翻译，转载请注明出处。\n我们已经了解了如何使用 FileCapture 和 LiveCapture 模块来捕获数据包，下面我们来看一下如何使用返回的 capture 对象。\ndir(cap)\nOut[3]:\n['apply_on_packets',\n 'close',\n 'current_packet',\n 'display_filter',\n 'encryption',\n 'input_filename',\n 'next',\n 'next_packet']\n（简洁起见以上列表经过了精简）\n这些是我认为比较有用的方法和属性，其它大多数是用于调试或者捕获过程内部使用。 display_filter ， encryption 和 input_filename 属性是之前传递给 FileCapture 或者 LiveCapture 的值。\n此处真正强大的是apply_on_packets()和next()方法。next()方法使得 capture 对象可以通过for循环进行遍历。apply_on_packets() 方法是另一种遍历数据包的方式，它接受一个函数作为参数并将之作用于所有的数据包。\n>>> cap = pyshark.FileCapture('test.pcap', keep_packets=False)\n>>> def print_highest_layer(pkt)\n...: print pkt.highest_layer\n>>> cap.apply_on_packets(print_highest_layer)\nHTTP\nHTTP\nHTTP\nHTTP\nHTTP\n... (truncated)\n这个方法也可以用于打印之外的功能，例如将数据包添加入一个列表进行其它处理。下面的脚本会将所有的数据包加入到一个列表中并打印总数：\nimport pyshark\n\ndef get_capture_count():\n    p = pyshark.FileCapture('test.cap.pcap', keep_packets=False)\n\n    count = []\n    def counter(*args):\n        count.append(args[0])\n\n    p.apply_on_packets(counter, timeout=100000)\n\n    return len(count)\n\nprint get_capture_count()\n\n上一篇：PyShark入门(2)：FileCapture和LiveCapture模块  下一篇：PyShark入门(4)：capture对象\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}