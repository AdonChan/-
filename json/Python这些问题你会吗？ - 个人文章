{"title": "Python这些问题你会吗？ - 个人文章 ", "index": "面试,技巧,python", "content": "Python这些问题你会吗？\nfinal作用域的代码一定会被执行吗？\n正常的情况下，finally作用域的代码一定会被执行的，不管是否发生异常。哪怕是调用了sys.exit函数，finally也是会被执行的，那怎么样才能让finally代码不执行了。\nimport time\nchoice = True\ntry:\n    if choice:\n        while True:\n            pass\n    else:\n        print \"Please pull the plug on your computer sometime soon...\"\n        time.sleep(60 * 60 * 24 * 365)\nfinally:\n    print \"Finally ...\"\n上面的代码主要是通过让流程停滞在try作用域里，从而实现了需求。上面的代码不排除有点投机取巧的意思，但是我们实习了题目的需求不是吗。\n可以对含有任意的元素的list进行排序吗？\n正常情况下：\n>>> a = [1, '2', '3', '1']\n>>> a.sort()\n>>> a\n[1, '1', '2', '3']\n那是不是以为着，任何list都可以调用sort函数进行排序了？\n>>> x = [1, 1j]\n>>> x.sort()\nTraceback (most recent call last):\n  File \"<pyshell#13>\", line 1, in ?\n    x.sort()\nTypeError: cannot compare complex numbers using <, <=, >, >=\npython里1j是一个特殊符号代表-1的平方根，出现这个问题的原因是sort函数调用的对象的__lt__函数来比较两个对象的，而复杂的数字类型是不可比较的，也就说没有实现__lt__函数，所以比较不了。因此，对于list里包含的对象如果都是可以比较的，也就是说实现了__lt__函数，那么对list调用sort函数是没问题的。\nPython可是使用++x或者x++之类的操作吗？\n\n++x操作是可以的，但是这个操作产生的结果和C语言里该操作产生的结果是不一样的，Python里++x操作里的加好只是一个一元操作符，所以，++x等价于+(+x)，所以++x == x。\nx++操作是不合法的，虽然有些情况下，x++看着是合法的，比如：x++-y，但其实这个表达式等价于x+(+(-y)) = x-y，所以正常情况下，x++是不合法的。\n\nPython里如何实现类似于C++里的cout<<x<<y操作？\n实现的方法如下：\nimport sys\n\nclass ostream:\n    def __init__(self, file):\n        self.file = file\n        \n    def __lshift__(self, obj):\n        self.file.write(str(obj));\n        return self\n\ncout = ostream(sys.stdout)\ncerr = ostream(sys.stderr)\nnl = '\\n'\n\ncout << x << \" \" << y << nl\n这地方并不是展示了一个新的python语法，这只是对python的str对象进行了封装。\nPython里如何实现C++里的printf函数？\n在python2中，print是一个表达式，python3里是个函数。所以在python2里，我们可以这么做：\ndef printf(format, *args): print format % args,\n上面的代码虽然只有一行，但是，有些地方还是需要注意的。第一个地方，就是最后使用了都好结尾，这样的话会更像c++的printf函数，如果想换行，则需要传入换行符。第二个地方是这个代码会在最后多打印一个空格，如果不想要这个空格，可以使用sys.stdout.write函数。第三的方面，这行代码除了更像C++风格的printf，还有其他好处吗？当然是有的，参数是比较灵活的。\nPython里逗号等号(,=)是什么意思？\n你可以能见过下面的代码：\n>>> x ,= range(1)\n>>> x\n0\n实际上，没有逗号等号(,=)这种操作符，上面的代码等价于 (x,) =  range(1)。这只是一个赋值语句，在左边有一个元组，意味着将元组的每个元素赋给右边的相应元素; 在这种情况下，x被赋值为0\n下面的代码是否意味着python里有阶乘的操作符？\n比如下面的代码：\nassert 0!=1\nassert 3!=6\nassert 4!=24\nassert 5!=120\n其实上面的代码并不是阶乘的结果，只是有意的构造代码的结果，实际上，上面的代码等价于：\nassert 0 != 1\nassert 3 != 6\nassert 4 != 24\nassert 5 != 120\n这样一看，其实assert判断是不等于的关系，所以都是True。\n如何快速的给Python的对象增加属性\n通常我们的做法是，在对象定义的时候，定义相关的属性，那如何自由的添加对象属性了。\nclass Struct:\n    \"A structure that can have any fields defined.\"\n    def __init__(self, **entries): self.__dict__.update(entries)\n\n>>> options = Struct(answer=42, linelen=80, font='courier')\n>>> options.answer\n42\n>>> options.answer = 'plastics'\n>>> vars(options)\n{'answer': 'plastics', 'font': 'courier', 'linelen': 80}\n如何定义一个包含默认值的dict\n在python2.7之前，必须定义一个类来处理这样的需求，现在，可以使用collections.defaultdict和collections.Counte来实现。\nfrom collections import Counter\n\nwords = 'this is a test this is only a test'.split()\n\n>>> Counter(words)\nCounter({'this': 2, 'test': 2, 'a': 2, 'is': 2, 'only': 1})\n如何计算函数的执行时间\ndef timer(fn, *args):\n    \"Time the application of fn to args. Return (result, seconds).\"\n    import time\n    start = time.clock()\n    return fn(*args), time.clock() - start\n\n>>> timer(max, range(1e6))\n(999999, 0.4921875)\n当然，python还有很多现成的轮子，可以更好的计算程序每个步骤的详细信息。\n如何实现单例模式\n网上有很多方法，但是我知道的最简单的方式如下：\ndef singleton(object):\n    \"Raise an exception if an object of this class has been instantiated before.\"\n    cls = object.__class__\n    if hasattr(cls, '__instantiated'):\n        raise ValueError(\"%s is a Singleton class but is already instantiated\" % cls)\n    cls.__instantiated = True\n\nclass YourClass:\n    \"A singleton class to do something ...\"\n    def __init__(self, args):\n        singleton(self)\n        ...\n转载自我的博客:捕蛇者说\n\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "0"}