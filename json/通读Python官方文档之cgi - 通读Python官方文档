{"title": "通读Python官方文档之cgi - 通读Python官方文档 ", "index": "python,html", "content": "cgi 通用网关接口\n\n前驱知识\n网关协议学习：CGI、FastCGI、WSGI\n简单点说：\n\nweb服务器接受请求，启动CGI；CGI接受请求，处理，返回给服务器；服务器返回给用户\ncgi效率不高，每次都要fork一个新进程出来\n\nWCGI，Python架设的一个桥，连接了服务器和web框架，相当将cgi的连接功能独立了出来，并把处理功能留给了web框架\n\n\n简介\nCGI脚本由HTTP服务器启动，通常用来处理用户通过<FROM>提交的数据。\n通常，CGI脚本位于服务器的专门的cgi-bin目录下。HTTP服务器在脚本的shell环境中放置了请求相关的信息，比如客户端的hostname，请求的url，请求的字符串以及其他东西。服务器执行脚本，并把输出返回给客户端。\n脚本的输入也和客户端相连，有时表单数据是通过这种方式读取的。其他时候，表单数据是通过URL的query字符串传递的。这个模块用于处理不同的情况，提供一个简单的接口。同时提供了一些功能，帮助调试脚本。最近添加的功能是通过表单上传文件。\nCGI脚本的输出由两部分组成，由一个空行分割。第一部分包含一些头部，告诉客户接下来返回的是什么数据。大概是这样：\nprint(\"Content-Type: text/html\")    # 接下来返回的是html\nprint()                             # 空白行，头部结束\n第二部分，一般来说是HTML。客户端软件可以展示这些页面，图片什么的。\n使用cgi模块\n当你写一个新的脚本时，添加下面这两行：\nimport cgitb\ncigtb.enable()\n这将会激活一个异常处理器，如果发生了错误，它就会把错误返回给浏览器。如果你不想让用户看到，也可以指定输出目录。\nimport cgitb\ncgitb.enable(display=0, logdir='/path/to/logdir')\n\n补充：\n\nPOST请求提交数据有两种方式application/x-www-form-urlencoded和multipart/form-data。前者形如MyVariableOne=ValueOne&MyVariableTwo=ValueTwo，使用%HH的形式编码非ascii码，不接受重复键值。后者接受重复键值、二进制文件等。参考资料\n\n可以通过FieldStorage类获取提交的表单数据，如果含有非asciii码，使用encoding参数，由于它会消耗标准数据，所以应该只被实例化1次。\nFieldStorage实例与python的字典相似。可以使用in检测内容，keys, len接口也都可以使用。FieldStorage的每个值也是一个FieldStorage或者MiniFieldStorage实例。\n由于表单可能存在重复的项目名，你可以使用getlist()方法。getlist(key_name)方法会返回所有key为key_name的值。\n如果上传的表单中存在文件，你可以调用值的read()函数或者readline()函数。\n如果是通过application/x-www-form-urlencoded发送的数据，则没有list, file, filename接口。\n高级接口\n前面介绍了，如果使用FieldStorage类从数据读取CGI。这一节，讲述以西而更可读和符合直觉的高级接口。但，前面讲的技术还是有用的，比如高效处理文件上传。\n该接口包含两个方法。使用这戏方法你可以以更一般的方式处理数据，不用担心是否有几个值公用一个名字。\nform = cgi.FieldStorage()\n\nitem = form.getvalue(\"item\")\nif isinstance(item, list):\n    # handle the list\n    pass\nelse:\n    # handle the single value\n    pass\n\n进行类型检查是必须的，因为会有好事的用户，输入重复的键名。\n你可以使用高级接口提供的getfirst()和getlist()方法。\n函数\n大部分函数，如cgi.parse，cgi.parse_qs，cgi.parse_qsl，已经被移植到urllib.parse。 cgi.escape被移植到html.escape。\n安全问题\n原则：如果你启动了一个外部程序函数，永远不要把用户的输入直接传入shell。即使要传入也要确保只含有字母和数字、横杠、下划线和点。\n在Unix系统上安装CGI脚本\n阅读你的HTTP服务器的文档，找到你的CGI脚本的安装位置，一般是在服务器目录的cgi-bin目录下。\n确保你的脚本可被其他程序读和执行；在Unix文件模式下处于0o755：使用chmod 0755 filename。确保第一行有shebang:\n#! /usr/local/bin/python\n同时，你的脚本需要执行的文件都有对应的权限。因为你的服务器被用户nobody执行，它只能读/写/执行那些被所有人读/写/执行的文件。当前目录和系统环境变量也可能可你目前所处的不一样。\n如果你需要从别的目录引用模块，使用sys.path.insert(0, \"/path/to/your/module\")这样你的模块会被首先搜索。\n测试你的CGI脚本\n不行的是，当你从命令行尝试CGI脚本是，它很有可能不会运行，而一个能运行的CGI脚本往往在服务器中不能运行。但你仍然应该从命令行中运行脚本，检查一下他是否有语法错误。如果你的脚本没有语法错误，但是它不工作，你只能读下一节。\n调试CGI脚本\n首先，检查一下琐碎的安装错误，读一下上面关于安装的部分，能节约时间。如果你想知道你是否正确理解了安装过程，把这个模块文件cgi.py安装到你的cgi脚本目录下，启动这个脚本，他就会将它的环境和内容以HTML的格式输出。给他一个合适的模式，发送给他一个请求。如果它被安装在cgi-bin目录下，在你的浏览器内输入如下url：\n\nhttp://yourhostname/cgi-bin/c...\\\n如果返回404错误，则说明服务器没有找到这个脚本，或许你应该把它装在别的目录下。如果给了别的错误，说明你有安装问题。你应该首先解决这些安装问题，再做别的调试。如果它给出了非常整洁的环境变量和表单内容输出，说明cgi.py被正确的安装了。如果，你的脚本按上述过程安装，你现在可以对他进行调试了。\n下一步是在你的脚本中调用cgi模块的test()方法，把它的主要代码替换成cgi.test。\n它应该输出和仅安装cgi.py时一致。\n当一个普通的python脚本抛出了一个未处理的异常时，Python解释器会把traceback打印出来，退出。当你的CGI脚本抛出异常时，Python解释器也会这么做。这些traceback一般会在你的HTTP服务器的日志文件里，或者被丢弃了。\n幸运的是，如果你的脚本执行了某些代码，你可以通过启用cgitb模块，把traceback的内容发送到浏览器中。把下面两行代码加到你脚本的顶部。\nimport cgitb\ncgitb.enable()\n如果你怀疑cgitb模块有问题，你可以使用一个更鲁棒的方法，只调用内置模块：\nimport sys\nsys.stderr = sys.stdout\nprint(\"Content-Type: text/plain\")\nprint()\n\n上述代码依赖python解释器输出traceback，输出的内容的格式被指定为纯文本，去除了HTML过程。如果你的脚本正常工作，你的客户端会显示纯HTML。如果抛出了异常，前两行打印出之后，traceback会被打印出来，如果没有HTML解释器进行处理，所以traceback会可读。\n常见问题及解决\n\n大多数HTTP服务器将CGI脚本的输出放入缓冲区直至脚本完成，这意味着在脚本还在执行时，不可能在客户端展示进度\n按上述核对安装过程\n监控日志文件\n先检查语法错误\n如果没有语法错误，在脚本顶部添加import cgitb; cgitb.enable()\n\n当启动外部程序时，确保他们能够被找到，通常这意味着绝对路径名，在CGI脚本中，PATH总是被设置为一个没啥用的值\n当脚本读写外部文件是，确保执行CGI的userid能够读写这些文件：一般来说是运行服务器的的userid，或者是服务器的suexec的userid\n不要给一个CGI set-uid权限，这在大多数操作系统上不可行，而且不安全。\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}