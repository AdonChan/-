{"title": "Python中的下划线（译文） - chevalier ", "index": "python3.x,python2.7,python", "content": "原文地址\n这篇文章讨论Python中下划线_的使用。跟Python中很多用法类似，下划线_的不同用法绝大部分（不全是）都是一种惯例约定。\n\n单个下划线（_）\n\n主要有三种情况：\n\n1. 解释器中\n\n_符号是指交互解释器中最后一次执行语句的返回结果。这种用法最初出现在CPython解释器中，其他解释器后来也都跟进了。\n\n>>> _\nTraceback (most recent call last):\n  File \"\", line 1, in \nNameError: name '_' is not defined\n>>> 42\n>>> _\n42\n>>> 'alright!' if _ else ':('\n'alright!'\n>>> _\n'alright!'\n\n\n2. 作为名称使用\n\n这个跟上面有点类似。_用作被丢弃的名称。按照惯例，这样做可以让阅读你代码的人知道，这是个不会被使用的特定名称。举个例子，你可能无所谓一个循环计数的值：\n\nn = 42\nfor _ in range(n):\n    do_something()\n\n3. i18n\n\n_还可以被用作函数名。这种情况，单下划线经常被用作国际化和本地化字符串翻译查询的函数名。这种惯例好像起源于C语言。举个例子，在 Django documentation for translation 中你可能会看到：\n\nfrom django.utils.translation import ugettext as _\nfrom django.http import HttpResponse\n\ndef my_view(request):\n    output = _(\"Welcome to my site.\")\n    return HttpResponse(output)\n\n第二种和第三种用法会引起冲突，所以在任意代码块中，如果使用了_作i18n翻译查询函数，就应该避免再用作被丢弃的变量名。\n\n单下划线前缀的名称（例如_shahriar）\n\n以单下划线做前缀的名称指定了这个名称是“私有的”。在 有些 导入import * 的场景中，下一个使用你代码的人（或者你本人）会明白这个名称仅内部使用。Python documentation里面写道：\n\n\n  a name prefixed with an underscore (e.g. _spam) should be treated as a non-public part of the API (whether it is a function, a method or a data member). It should be considered an implementation detail and subject to change without notice.\n\n\n之所以说在在 有些 import * 的场景，是因为导入时解释器确实对单下划线开头的名称做了处理。如果你这么写from <module/package> import *，任何以单下划线开头的名称都不会被导入，除非模块/包的__all__列表明确包含了这些名称。更多相关信息见““Importing * in Python”。\n\n双下划线前缀的名称（例如__shahriar）\n\n以双下划线做前缀的名称（特别是方法名）并不是一种惯例；它对解释器有特定含义。Python会改写这些名称，以免与子类中定义的名称产生冲突。Python documentation中提到，任何__spam这种形式（至少以两个下划线做开头，绝大部分都还有一个下划线做结尾）的标识符，都会文本上被替换为_classname__spam，其中classname是当前类名，并带上一个下划线做前缀。\n看下面这个例子：\n\n>>> class A(object):\n...     def _internal_use(self):\n...         pass\n...     def __method_name(self):\n...         pass\n... \n>>> dir(A())\n['_A__method_name', ..., '_internal_use']\n\n正如所料，_internal_use没有变化，但__method_name被改写成了_ClassName__method_name。现在创建一个A的子类B（这可不是个好名字），就不会轻易的覆盖掉A中的__method_name了：\n\n>>> class B(A):\n...     def __method_name(self):\n...         pass\n... \n>>> dir(B())\n['_A__method_name', '_B__method_name', ..., '_internal_use']\n\n这种特定的行为差不多等价于Java中的final方法和C++中的正常方法（非虚方法）。\n\n前后都带有双下划线的名称（例如__init__）\n\n这些是Python的特殊方法名，这仅仅是一种惯例，一种确保Python系统中的名称不会跟用户自定义的名称发生冲突的方式。通常你可以覆写这些方法，在Python调用它们时，产生你想得到的行为。例如，当写一个类的时候经常会覆写__init__方法。\n你也可以写出自己的“特殊方法”名（但是别这么做）：\n\n>>> class C(object):\n...     def __mine__(self):\n...         pass\n...\n>>> dir(C)\n... [..., '__mine__', ...]\n\n还是不要这样写方法名，只让Python定义的特殊方法名使用这种惯例吧。\n\n\nhackernews和reddit上的相关讨论\n\n                ", "mainLikeNum": ["17 "], "mainBookmarkNum": "49"}