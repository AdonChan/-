{"title": "Django中同一页面中的多表单处理 - 曾经的自己 ", "index": "form,python,django,python-django", "content": "原文地址:\nhttp://52sox.com/how-to-handl...\n关于在同1个页面多个表单提交的问题,实际上是项目中遇到的1个小问题。关于这个问题,主要有2个需要解决的问题:\n\n多个表单的渲染问题\n多个表单提交时外键的处理问题\n\n下面我们分别进行说明。  当时在建模的时候使用了类似如下的方式:\nfrom django.db import models\n\nclass Store(models.Model):\n    name = models.CharField('名称', max_length=20)\n    first = models.FloatField('首重')\n    additional = models.FloatField('次重')\n    img = models.ImageField('图片', upload_to='store/1')\n\nclass Depot(models.Model):\n    s_name = models.ForeignKey(Store, verbose_name='仓库')\n    src = models.CharField('始发地', max_length=20)\n    dest = models.CharField('目的地', max_length=20)\n    days = models.PositiveSmallIntegerField('需要的天数')\n\nclass Address(models.Model):\n    s_name = models.ForeignKey(Store, verbose_name='仓库')\n    country = models.CharField('国家', max_length=20)\n    state = models.CharField('省份', max_length=10)\n    city = models.CharField('城市', max_length=10)\n    description = models.TextField('描述', blank=True)\n在这里,1个仓库的数据主要由3个表组成,分别为它的一些基础信息,可以配送的范围、天数及其他一些附加信息组成。然后其页面如下所示:\n\n多表单渲染\n而公司的需求就是我们要在商户端上让客户在创建仓库时填写上述的内容,由于我比较懒,而公司给出的时间也不是很充裕,于是直接使用ModelForm来实现,而不需要一一的创建表单了。换句话说,我们要将多个模型表在同1个页面中渲染出来,对于这样的问题,主要有4种解决的方案:\n\n在1个form组件中使用多个模型表单类\n使用django提供的modelform_factory来解决\n使用第3方插件django-betterforms或django-multipleformwizard这样的插件\n使用元类,然后继承BaseForm进行表单的重写。\n\n这里我们使用第1种解决方案来实现多个表单渲染的问题。这里我们在forms模块下新建3个模型表单类:\nfrom django.forms import ModelForm\nfrom models import Store, Address, Depot\n\nclass StoreForm(ModelForm):\n    class Meta:\n        model = Store\n        fields = '__all__'\n\nclass AddressForm(ModelForm):\n    class Meta:\n        model = Address\n        exclude = ['s_name']\n\nclass DepotForm(ModelForm):\n    class Meta:\n        model = Depot\n        exclude = ['s_name']\n然后在视图中引入这3个表单:\nfrom django.shortcuts import render_to_response, HttpResponseRedirect\nfrom django.template import RequestContext\nfrom forms import StoreForm, AddressForm, DepotForm\n\ndef store_add(req):\n    if req.method == 'POST':\n       ...\n    else:\n        sf = StoreForm()\n        af = AddressForm()\n        df = DepotForm()\n    return render_to_response('store_add.html', {\n        'sf': sf, 'af': af, 'df': df,\n    }, context_instance=RequestContext(req))\n默认情况下,我们先将对应的表单渲染出来先。在这里我们往模板中输出了多个变量,然后在模板中手动进行如下的处理:\n<form action=\"\" method='post' enctype='multipart/form-data'>\n        {% csrf_token %}\n        {{ sf.as_p }}\n          {{ df.as_p }}\n          {{ af.as_p }}\n          <input type=\"submit\" value = \"添加\" />\n</form>\n在这里,我们在1个表单中输出多个表单,其页面如下所示:\n\n可以看到其效果与后台的页面相差不是很大,只是没有对应的样式而已。\n多表单提交外键处理\n接着我们需要处理多个表单提交时的处理问题。\ndef store_add(req):\n    if req.method == 'POST':\n        sf = StoreForm(req.POST, req.FILES)\n        af = AddressForm(req.POST)\n        df = DepotForm(req.POST)\n        if sf.is_valid() and af.is_valid() and df.is_valid():\n            sf.save()\n            df.save()\n            af.save()\n            return HttpResponseRedirect('store')\n    ...\n在这里我们直接对这3个表单进行保存,结果出现了这样1个错误。\nNOT NULL constraint failed: app_depot.s_name_id\n\n由于我们使用了1个外键进行了约束,而使用上述的方式会导致数据表中的s_name_id的字段数值为NULL,从而导致了错误。而上述的方式时直接就提交给数据库了,导致后面的外键无法被满足。为了解决这个问题,我们采用延迟提交给数据库的方式:\ndef store_add(req):\n    if req.method == 'POST':\n        ...\n        if sf.is_valid() and af.is_valid() and df.is_valid():\n            form = sf.save(commit=False)\n            sf.save()\n            dform = df.save(commit=False)\n            dform.s_name = form\n            dform.save()\n            aform = af.save(commit=False)\n            aform.s_name = form\n            aform.save()\n            return HttpResponseRedirect('store')\n    else:\n        ...\n在这里,我们先让第1张表先不提交,将其保存为1个变量form中。而第2个张表也先不提交,我们将其实例的s_name修改为之前的第1张表返回的结果,然后再进行保存。这样我们就实现了多张表的依赖导致的问题了。最后我们使用重定向的方式将成功添加后的页面跳转到该商户的仓库列表中。  其跳转后的页面如下所示:\n\n这样我们就解决了在1个页面提交多个表单的问题。  实际关于Django在1个页面提交多个表单的问题,实际上问题不是很多,只要解决了渲染和提交时处理的问题,实际这个问题就迎刃而解了。重要的是如何拆分问题和解决问题的思路。  \n参考文章:\nhttp://stackoverflow.com/ques...\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "6"}