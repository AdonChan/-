{"title": "Python线程池源码分析 - 莫谈国是 ", "index": "multi-thread,python", "content": "对Python线程池的研究是之前对Apshceduler分析的附加工作。\n在之前对Apshceduler源码分析的文章中，写到调度器将任务放入线程池的函数\n    def _do_submit_job(self, job, run_times):\n        def callback(f):\n            exc, tb = (f.exception_info() if hasattr(f, 'exception_info') else\n                       (f.exception(), getattr(f.exception(), '__traceback__', None)))\n            if exc:\n                self._run_job_error(job.id, exc, tb)\n            else:\n                self._run_job_success(job.id, f.result())\n\n        f = self._pool.submit(_run_job, job, job._jobstore_alias, run_times, self._logger.name)\n        f.add_done_callback(callback)\n这里分析的线程池类是concurrent.futures.ThreadPoolExecutor，也就是上述代码中self._pool所使用的类。先上self._pool.submit函数的代码，再做详细分析\n    def submit(self, fn, *args, **kwargs):\n        with self._shutdown_lock:\n            if self._shutdown:\n                raise RuntimeError('cannot schedule new futures after shutdown')\n\n            f = _base.Future()\n            w = _WorkItem(f, fn, args, kwargs)\n\n            self._work_queue.put(w)\n            self._adjust_thread_count()\n            return f\nf和w是两个非常重要的变量，f作为submit返回的对象，submit函数的调用者可以对其添加回调，待fn执行完成后，会在当前线程执行，具体是如何实现的，这里先不说，下面再详细分析；w则是封装了线程需要执行的方法和参数，通过self._work_queue.put(w)方法放入一个队列当中。\nself._adjust_thread_count()方法则是检查当前线程池的线程数量，如果小于设定的最大值，就开辟一个线程，代码就不上了，直接看这些个线程都是干嘛的\ndef _worker(executor_reference, work_queue):\n    try:\n        while True:\n            work_item = work_queue.get(block=True)\n            if work_item is not None:\n                work_item.run()\n                # Delete references to object. See issue16284\n                del work_item\n                continue\n            executor = executor_reference()\n            # Exit if:\n            #   - The interpreter is shutting down OR\n            #   - The executor that owns the worker has been collected OR\n            #   - The executor that owns the worker has been shutdown.\n            if _shutdown or executor is None or executor._shutdown:\n                # Notice other workers\n                work_queue.put(None)\n                return\n            del executor\n    except BaseException:\n        _base.LOGGER.critical('Exception in worker', exc_info=True)\n这些线程就是一个死循环，不断的从任务队列中获取到_WorkItem，然后通过其封装方法，执行我们需要的任务。如果取到的任务为None，就往队列中再放入一个None，以通知其它线程结束，然后结束当前循环。\n    def run(self):\n        if not self.future.set_running_or_notify_cancel():\n            return\n\n        try:\n            result = self.fn(*self.args, **self.kwargs)\n        except BaseException as e:\n            self.future.set_exception(e)\n        else:\n            self.future.set_result(result)\n如果没有异常，执行结束后，会执行之前我们说的回调。在self.future.set_result(result)方法中会执行任务回调，当然了，是在当前线程中。如果需要写入数据库之类的操作，不建议在回调中直接写入。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}