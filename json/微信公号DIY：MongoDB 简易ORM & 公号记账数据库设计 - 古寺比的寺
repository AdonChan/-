{"title": "微信公号DIY：MongoDB 简易ORM & 公号记账数据库设计 - 古寺比的寺 ", "index": "python,mongodb,nosql,orm,微信公众平台", "content": "前两篇 微信公号DIY 系列:\n\n微信公号DIY：一小时搭建微信聊天机器人\n微信公号DIY：训练聊天机器人&公号变身图片上传工具\n\n介绍了如何使用搭建&训练聊天机器人以及让公号支持图片上传到七牛，把公号变成一个七牛图片上传客户端。这一篇将继续开发公号，让公号变成一个更加实用的工具账本（理财从记账开始）。\n代码： 项目代码已上传至github，地址为：gusibi/momo\n账本功能\n账本是一个功能比较简单应用，公号内只需要支持：\n\n记账（记账，修改金额，取消记账）\n账单统计（提供数据和图片形式的统计功能）\n\n当然后台管理功能就比较多了，这个以后再介绍。\n对于数据存储，我选择的是MongoDB（选MongoDB的原因是，之前没用过，想试一下），我们先看下MongoDB和关系型数据库的不同。\nMongoDB\n什么是MongoDB ?\nMongoDB 是由C++语言编写的，是一个开放源代码的面向文档的数据库,易于开发和缩放。\nmongo和传统关系数据库的最本质的区别在那里呢？MongoDB 是文档模型。\n关系模型和文档模型的区别在哪里？\n\n关系模型需要你把一个数据对象，拆分成零部件，然后存到各个相应的表里，需要的是最后把它拼起来。举例子来说，假设我们要做一个CRM应用，那么要管理客户的基本信息，包括客户名字、地址、电话等。由于每个客户可能有多个电话，那么按照第三范式，我们会把电话号码用单独的一个表来存储，并在显示客户信息的时候通过关联把需要的信息取回来。\n而MongoDB的文档模式，与这个模式大不相同。由于我们的存储单位是一个文档，可以支持数组和嵌套文档，所以很多时候你直接用一个这样的文档就可以涵盖这个客户相关的所有个人信息。关系型数据库的关联功能不一定就是它的优势，而是它能够工作的必要条件。 而在MongoDB里面，利用富文档的性质，很多时候，关联是个伪需求，可以通过合理建模来避免做关联。\n\nMongoDB 概念解析\n在mongodb中基本的概念是文档、集合、数据库，下表是MongoDB和关系型数据库概念对比：\n\n\nSQL术语/概念\nMongoDB术语/概念\n解释/说明\n\n\n\ndatabase\ndatabase\n数据库\n\n\ntable\ncollection\n数据库表/集合\n\n\nrow\ndocument\n数据记录行/文档\n\n\ncolumn\nfield\n数据字段/域\n\n\nindex\nindex\n索引\n\n\ntable\njoins\n表连接,MongoDB不支持\n\n\nprimary key\nprimary key\n主键,MongoDB自动将_id字段设置为主键\n\n\n\n通过下图实例，我们也可以更直观的的了解Mongo中的一些概念：\n\n接下来，我从使用的角度来介绍下如何使用 python 如何使用MongoDB，在这个过程中，我会实现一个简单的MongoDB的ORM，同时也会解释一下涉及到的概念。\n简易 Python MongoDB ORM\npython 使用 mongodb\n首先，需要确认已经安装了 PyMongo，如果没有安装，使用以下命令安装：\npip install pymongo\n# 或者\neasy_install pymongo\n详细安装步骤参考: PyMongo Installing / Upgrading\n连接 MongoClient：\n>>> from pymongo import MongoClient\n>>> client = MongoClient()\n上述命令会使用Mongo的默认host和端口号，和以下命令作用相同：\nclient = MongoClient('localhost', 27017) # mongo 默认端口号\n为27017\n# 也可以这样写\nclient = MongoClient('mongodb://localhost:27017/')\n选择一个数据库\n获取 MongoClient 后我们接下来要做的是选择要执行的数据库，命令如下：\n>>> db = client.test_database # test_database 是选择的数据库名称\n# 也可以使用下述方式\n>>> db = client['test-database']\n数据库（Database） 一个mongodb中可以建立多个数据库。\nMongoDB的默认数据库为\"db\"，该数据库存储在data目录中。MongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中。\"show dbs\" 命令可以显示所有数据的列表。\n执行 \"db\" 命令可以显示当前数据库对象或集合。运行\"use\"命令，可以连接到一个指定的数据库。\n获取集合\n选择数据库后，接下来就是选择一个集合（Collection），获取一个集合和选择一个数据库的方式基本一致：\n>>> collection = db.test_collection  # test_collection 是集合名称\n# 也可以使用字典的形式\n>>> collection = db['test-collection']\n集合（collection）集合就是 MongoDB 文档组，类似于 RDBMS （关系数据库管理系统：Relational Database Management System)中的表。\n集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。\n当第一个文档插入时，集合就会被创建。集合名不能是空字符串\"\"。集合名不能含有\\0字符（空字符)，这个字符表示集合名的结尾。集合名不能以\"system.\"开头，这是为系统集合保留的前缀。用户创建的集合名字不能含有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除非你要访问这种系统创建的集合，否则千万不要在名字里出现$。　\n了解这几个操作后我们把这几个封装一下：\nfrom six import with_metaclass\nfrom pymongo import MongoClient\nfrom momo.settings import Config\n\npyclient = MongoClient(Config.MONGO_MASTER_URL)\n\nclass ModelMetaclass(type):\n    \"\"\"\n    Metaclass of the Model.\n    \"\"\"\n    __collection__ = None\n\n    def __init__(cls, name, bases, attrs):\n        super(ModelMetaclass, cls).__init__(name, bases, attrs)\n        cls.db = pyclient['momo_bill']  # 数据库名称，也可以作为参数传递 通常情况下一个应用只是用一个数据库就能实现需求\n        if cls.__collection__:\n            cls.collection = cls.db[cls.__collection__]\n\n\nclass Model(with_metaclass(ModelMetaclass, object)):\n\n    __collection__ = 'model_base'\n现在我们可以这样定义一个集合（Collection）：\nclass Account(Model):\n\n    '''\n    暂时在这里声明文档结构，用不用做校验，只是方便自己查阅\n    以后也不会变成类似 SQLAlchemy 那种强校验的形式\n    :param _id: '用户ID',\n    :param nickname: '用户昵称 用户显示',\n    :param username: '用户名 用于登录',\n    :param avatar: '头像',\n    :param password: '密码',\n    :param created_time: '创建时间',\n    '''\n    __collection__ = 'account'  # 集合名\n使用方式：\naccount = Account()\n现在就已经指定了数据库和集合，可以自由做 CURD 操作了（虽然还不支持）。\n创建文档（insert document）\n使用PyMongo 创建文档非常方便：\n>>> import datetime\n>>> account = {\"nickname\": \"Mike\",\n...         \"username\": \"mike\",\n...         \"avatar\": \"http://media.gusibi.mobi/Hy8XHexmzppNKuekLuGxWy8LjdGrQAzZA3mH_e9xltoiYgTFWdvlpZwGWxZESrbK\",\n...         \"password\": \"password\",\n...         \"created_time\": datetime.datetime.utcnow()}\n\n>>> accounts = db.account\n>>> account_id = accounts.insert_one(account).inserted_id\n>>> account_id\nObjectId('...')\n创建一个文档时，你可以指定 _id，如果不指定，系统会自动添加上_id 字段，这个字段必须是唯一不可重复的字段。\n也可是使用 collection_names 命令显示所有的集合：\n>>> db.collection_names(include_system_collections=False)\n[u'account']\n文档（Document） 文档是一组键值(key-value)对(即BSON)。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。\n现在我们给这个简易ORM添加创建文档的功能：\nclass Model(with_metaclass(ModelMetaclass, object)):\n\n    __collection__ = 'model_base'\n\n    @classmethod\n    def insert(cls, **kwargs):\n        # insert one document\n        doc = cls.collection.insert_one(kwargs)\n        return doc\n        \n    @classmethod\n    def bulk_inserts(cls, *params):\n        '''\n        :param params: document list\n        :return: \n        '''\n        results = cls.collection.insert_many(params)\n        return results        \n创建一个文档方法为：\naccount = Account.insert(\"nickname\": \"Mike\",\n        \"username\": \"mike\",\n        \"avatar\": \"http://media.gusibi.mobi/Hy8XHexmzppNKuekLuGxWy8LjdGrQAzZA3mH_e9xltoiYgTFWdvlpZwGWxZESrbK\",\n        \"password\": \"password\",\n        \"created_time\": datetime.datetime.utcnow())\n查询文档\n使用 find_one 获取单个文档：\naccounts.find_one()\n如果没有任何筛选条件，find_one 命令会取集合中的第一个文档如果有筛选条件，会取符合条件的第一个文档\naccounts.find_one({\"nickname\": \"mike\"})\n使用 ObjectId 查询单个文档：\naccounts.find_one({\"_id\": account_id})\n将这个添加到ORM中：\nclass Model(with_metaclass(ModelMetaclass, object)):\n\n    __collection__ = 'model_base'\n\n    @classmethod\n    def get(cls, _id=None, **kwargs):\n        if _id: # 如果有_id\n            doc = cls.collection.find_one({'_id': _id})\n        else: # 如果没有id\n            doc = cls.collection.find_one(kwargs)\n        return doc\n如果你想获取多个文档可以使用find命令。\n使用find命令获取多个文档\naccounts.find()\n# 当然支持筛选条件\naccounts.find({\"nickname\": \"mike\"})\n将这个功能添加到ORM：\nclass Model(with_metaclass(ModelMetaclass, object)):\n\n    __collection__ = 'model_base'\n    \n    @classmethod\n    def find(cls, filter=None, projection=None, skip=0, limit=20, **kwargs):\n        docs = cls.collection.find(filter=filter,\n                                   projection=projection,\n                                   skip=skip, \n                                   limit=limit,\n                                   **kwargs)\n        return docs\n现在我们可以这样做查询操作：\naccount = Account.get(_id='account_id')\naccounts = Account.find({'name': \"mike\"})\n修改（update）\n更新操作文档地址：http://api.mongodb.com/python/current/api/pymongo/collection.html#pymongo.collection.Collection.update_one：\nupdate_one(filter, update, upsert=False, bypass_document_validation=False, collation=None)\n更新一个符合筛选条件的文档 upsert 如果为True 则会在没有匹配到文档的时候创建一个\nupdate_many(filter, update, upsert=False, bypass_document_validation=False, collation=None)\n更新全部符合筛选条件的文档 upsert 如果为True 则会在没有匹配到文档的时候创建一个\n添加到ORM中：\nclass Model(with_metaclass(ModelMetaclass, object)):\n\n    __collection__ = 'model_base'\n    \n    @classmethod\n    def update_one(cls, filter, **kwargs):\n        result = cls.collection.update_one(filter, **kwargs)\n        return result\n\n    @classmethod\n    def update_many(cls, filter, **kwargs):\n        results = cls.collection.update_many(filter, **kwargs)\n        return results\n可以看到，我这里并没有做多余的操作，只是直接调用了PyMongo的方法。\n删除\n删除操作和update类似但是比较简单：\ndelete_one(filter, collation=None):\n删除一个匹配到的文档\ndelete_many(filter, collation=None):\n删除全部匹配到的文档\n添加到ORM中：\nclass Model(with_metaclass(ModelMetaclass, object)):\n\n    __collection__ = 'model_base'\n\n    @classmethod\n    def delete_one(cls, **filter):\n        cls.collection.delete_one(filter)\n\n    @classmethod\n    def delete_many(cls, **filter):\n        cls.collection.delete_many(filter)\n\n到这里，简易的ORM就实现了（这只能算是个功能简单的框，可以再自由添加其它更多的功能）。\n接下来是账本文档结构的设计\n账本数据结构设计\n账本需要包含的数据有：\n\n账户所有人\n账单记录\n账单分类\n\n那么我们至少需要三个集合：\n{\n    'account': {  # 用户集合\n        '_id': '用户ID',\n        'nickname': '用户昵称',\n        'username': '用户名 用于登录',\n        'avatar': '头像',\n        'password': '密码',\n        'created_time': '创建时间',\n    },\n    'bill': { # 账单集合\n        '_id': '账单ID',\n        'uid': '用户ID',\n        'money': '金额 精确到分',\n        'tag': '标签',\n        'remark': '备注',\n        'created_time': '创建时间',\n    },\n    'tag': {  # 账单标签\n        '_id': '标签ID',\n        'name': '标签名',\n        'icon': '标签图标',\n        'uid': '创建者ID（默认是管理员）',\n        'created_time': '创建时间',\n    }\n}\n这里账单和用户使用 uid 作为引用的关联，account 和 bill 是一对多关系。\n当然你也可以再加一个账本的集合，用户和账本对应，这时，账单可以作为账本中的一个list数据结构（单个文档有16M的限制，如果存储超过这个大小不能使用这种形式，数据量大的时候，查询操作会比较缓慢）。\n作为公号中的账本，我们暂时不加账本功能，因为这会让我们的操作变得复杂。\n因为公号里的每次操作都是独立请求，并没有上下文。所以我们要记录记账这个操作走到了哪一步，接下来改干嘛。\n记账逻辑如图：\n\n所以我们这里要有数据来记录当前的操作步骤以及接下来改有的操作步骤：\n{\n    'account_workflow': {  # 用户当前工作流\n        '_id': 'id', \n        'next': '下一步的操作',\n        'uid': '用户ID',\n        'workflow': '使用的工作流',\n        'created_time': '开始时间'\n    }\n}\n这个集合记录了我们当前所在的工作流，下一步该走向哪一步。\n这个集合需要设置文档的过期时间，比如输入 “记账” 激活记账工作流后，如果10分钟没有操作完成，那么需要重新开始。以免输入记账后不完成不能继续其它的操作。\n下面的这个集合记录了哪些关键字可以激活工作流，对应的工作流是什么以及开始哪个动作。\n{\n    'keyword': {  # 特殊关键字\n        '_id': '关键字ID',\n        'word': '关键字',\n        'data': {\n            'workflow': '工作流',\n            'action': '工作流动作',\n            'value': '返回值',\n            'type': '返回值类型 url|pic|text',\n        },\n        'created_time': '创建时间'\n    },\n}\n到这里账本的数据库设计就结束了。\n总结\n这一篇主要介绍了MongoDB，PyMongo 的使用以及如何编写一个简易的MongoDB ORM。然后又介绍了基于 MongoDB 的公号账本应用的数据库设计。\n预告\n下一篇我们将介绍，如何实现记账功能。\n以下是操作截图。\n\n欢迎关注公号四月（April_Louisa）试用。\n参考链接\n\nMongoDB数据库设计中6条重要的经验法则\nMongoDB 进阶模式设计\nMongoDB 概念解析\nPyMongo 3.4.0 Documentation\n\n\n最后，感谢女朋友支持。\n\n\n>欢迎关注(April_Louisa)\n>请我喝芬达\n\n\n\n\n\n\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "9"}