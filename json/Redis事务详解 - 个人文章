{"title": "Redis事务详解 - 个人文章 ", "index": "python,事务,redis", "content": "Redis的基本事务（basic transaction）需要用到MULTI命令和EXEC命令，这种事务可以让一个客户端在不被其他客户端打断的情况下执行多个命令。被NULTI命令和EXEC命令包围的所有命令会一个接一个地执行，直到所有命令都执行完毕为止。当一个事务执行完毕之后，Redis才会处理其他客户端的命令。\n当Redis从一个客户端那里接收到MULTI命令时，Redis会将这个客户端之后发送的所有命令都放入到一个队列里面，直到这个客户端发送EXEC命令为止，然后Redis就会在不被打断的情况下，一个接一个地执行存储在队列里面的命令。从语义上来说，Redis事务在Python客户端上面是由流水线（pipeline）实现的：对连接对象调用pipeline()方法将创建一个事务，在一切正常的情况下，客户端会自动地使用MULTI和EXEC包裹起用户输入的多个命令。为了减少Redis与客户端之间的通信往返次数，提升执行多个命令时的性能，Python的Redis客户端会存储起事务包含的多个命令，然后在事务执行时一次性地将所有命令都发送给Redis。\n在Python中使用事务来处理命令的并行执行问题：\ndef trans():\n    pipeline = conn.pipeline() # 创建事务型流水线对象\n    pipeline.incr('trans:') # 把针对'trans:'计数器的自增操作放入队列\n    time.sleep(.1) # 等待100ms\n    \n    pipeline.incr('trans:', -1) # 把针对'trans:'计数器的自减操作放入队列\n    print pipeline.execute()[0] # 执行被事务包裹的命令，并打印自增操作的执行结果\n    \nif 1:\n    for i in xrange(3):\n        # 启动3个线程来执行被事务包裹的自增、休眠和自减3个操作\n        threading.Thread(target=trans).start()\n    time.sleep(.5) # 等待500ms,让操作有足够的时间完成  \n          \n# 打印结果：    \n1\n1\n1  \n\nRedis要在接收到EXEC命令之后，才会执行哪些位于MULTI和EXEC之间的入队命令。 \n上述这种简单的事务在EXEC命令被调用之前不会执行任何实际操作，所以用户将没办法根据读取到的数据来做决定。这种方式无法以一致的形式读取数据将导致某一类型的问题变得难以解决，除此之外，因为在多个事务同时处理同一个对象时通常需要用到二阶提交（two-phase commit）, 所以如果事务不能以一致的形式读取数据，那么二阶提交将无法实现，从而导致一些原本可以成功执行的事务执行失败。\n\n延迟执行事务有助于提升性能因为Redis在执行事务的过程中，会延迟执行已入队的命令直到客户端发送EXEC命令为止。包括python客户端在内的很多Redis客户端都会等到事务包含的所有命令都出现了之后，才一次性地将MULTI命令、要在事务中执行的一系列命令，以及EXEC命令全部发送给Redis，然后等待直到接收到所有命令的回复为止。这种“一次性发送多个命令，然后等待所有回复出现”的做法通常被称为流水线（pipeline）,它可以通过减少客户端与Redis服务器之间的网络通信次数来提升Redis在执行多个命令时的性能。\n在用户使用WATCH命令对键进行监视之后，直到用户执行EXEC命令的这段时间，如果有其他客户端抢先对任何被监视的键进行了替换、更新或删除等操作，那么当用户尝试执行EXEC命令的时候，事务将失败并返回一个错误（之后选择重试事务或者放弃事务）。\nUNWATCH命令可以在WATCH命令执行之后、MULTI命令执行之前对连接进行重置（reset）;同样地，DISCARD命令也可以在MULTI命令执行之后、EXEC命令执行之前对连接进行重置。这也就是说，用户在使用WATCH监视一个或多个键，接着使用MULTI开始一个新的事务，并将多个命令入队到事务队列之后，仍然可以通过发送DISCARD命令来取消WATCH命令并清空所有已入队命令。\n将商品放到市场上销售：\ndef list_item(conn, itemid, sellerid, price):\n    inventory = \"inventory:%s\"%sellerid # 商家包裹\n    item = \"%s.%s\"%(itemid, sellerid)\n    end = time.time() + 5\n    pipe = conn.pipeline()\n    \n    while time.time() < end:\n        try:\n            pipe.watch(inventory) # 监视商家包裹发生的变化\n            if not pipe.sismember(inventory, itemid): # 检查商家是否仍然持有将要被销售的商品\n                pipe.unwatch()\n                return None\n                \n            pipe.multi()\n            pipe.zadd(\"market:\",  item, price) # 将出售的商品添加到买卖市场\n            pipe.srem(inventory, itemid)\n            pipe.execute() # 执行execute没有引发WatchError异常，说明事务执行成功，并且对包裹键的监视也已经结束\n            return True\n         except redis.exceptions.WatchError: # 商家的包裹已经发生变化，重试\n            pass\n    return False\n\n\n购买商品：\ndef purchase_item(conn, buyerid, itemid, sellerid, lprice):\n    buyer = \"users:%s\"%buyerid\n    seller = \"users:%s\"%sellerid\n    item = \"%s.%s\"%(itemid, sellerid)\n    inventory = \"inventory:%s\"%buyerid\n    end = time.time() + 10 \n    pipe = conn.pipeline()\n    \n    while time.time() < end:\n        try:\n            pipe.watch(\"market:\", buyer) # 对商品买卖市场以及买家的个人信息进行监视\n            # 检查购买的商品价格是否发生变化，以及卖家是否有足够的钱购买\n            price = pipe.zscore(\"market:\", item)\n            funds = int(pipe.hget(buyer, \"funds\"))\n            if price != lprice or price > funds:\n                pipe.unwatch()\n                return None\n                \n            pipe.multi()\n            pipe.hincrby(seller, \"funds\", int(price))\n            pipe.hincrby(buyer, \"funds\", int(-price))\n            pipe.sadd(inventory, itemid)\n            pipe.zrem(\"market:\", item)\n            pipe.execute()\n            return True\n        except redis.exceptions.WatchError:\n            pass\n            \n    return False     \n    \n\n加锁有可能造成长时间的等待，所以Redis为了尽可能地减少客户端的等待时间，并不会在执行WATCH命令时对数据进行加锁。相反，Redis只会在数据已经被其他客户端抢先修改了的情况下，通知执行WATCH命令的客户端，这种做法称为乐观锁（optimistic locking）,而关系型数据库实际执行的加锁操作则被称为悲观锁（pessimistic locking)。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}