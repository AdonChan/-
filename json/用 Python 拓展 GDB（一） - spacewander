{"title": "用 Python 拓展 GDB（一） - spacewander ", "index": "python,gdb", "content": "之前写的《GDB 自动化操作的技术》一文介绍了可在gdb内部使用的DSL（领域特定语言）来自动化gdb的操作。借助该DSL，我们分别实现了一个名为mv的自定义命令，和“对账”用的调试脚本。在末尾，我提到了也可以用python来实现拓展脚本。从本篇开始，我会介绍如何使用python来给gdb编写脚本。由于篇幅所限，该教程会分成四篇，争取在本周内更完。\n作为开始的热身，让我们用python重新实现前文（《GDB 自动化操作的技术》）的mv命令。\n实现自定义命令\n引用前文的mv命令实现如下：\n# ~/.gdbinit\ndefine mv\n    if $argc == 2\n        delete $arg0\n        # 注意新创建的断点编号和被删除断点的编号不同\n        break $arg1\n    else\n        print \"输入参数数目不对，help mv以获得用法\"\n    end\nend\n\n# (gdb) help mv 会输出以下帮助文档\ndocument mv\nMove breakpoint.\nUsage: mv old_breakpoint_num new_breakpoint\nExample:\n    (gdb) mv 1 binary_search -- move breakpoint 1 to `b binary_search`\n\nend\n对应的python实现如下：\n# move.py\n# 1. 导入gdb模块来访问gdb提供的python接口\nimport gdb\n\n\n# 2. 用户自定义命令需要继承自gdb.Command类\nclass Move(gdb.Command):\n\n    # 3. docstring里面的文本是不是很眼熟？gdb会提取该类的__doc__属性作为对应命令的文档\n    \"\"\"Move breakpoint\n    Usage: mv old_breakpoint_num new_breakpoint\n    Example:\n        (gdb) mv 1 binary_search -- move breakpoint 1 to `b binary_search`\n    \"\"\"\n\n    def __init__(self):\n        # 4. 在构造函数中注册该命令的名字\n        super(self.__class__, self).__init__(\"mv\", gdb.COMMAND_USER)\n\n    # 5. 在invoke方法中实现该自定义命令具体的功能\n    # args表示该命令后面所衔接的参数，这里通过string_to_argv转换成数组\n    def invoke(self, args, from_tty):\n        argv = gdb.string_to_argv(args)\n        if len(argv) != 2:\n            raise gdb.GdbError('输入参数数目不对，help mv以获得用法')\n        # 6. 使用gdb.execute来执行具体的命令\n        gdb.execute('delete ' + argv[0])\n        gdb.execute('break ' + argv[1])\n\n# 7. 向gdb会话注册该自定义命令\nMove()\npython脚本完成了，该怎么运行呢？在gdb里使用python脚本，需要用source命令：\n(gdb) so ~/move.py\n(gdb) mv 1 binary_search.cpp:18\n\n在“gdb自动化一的技术”一文中，我们最后把自定义命令的实现放到~/.gdbinit里面。这样gdb每次启动时就会运行它，而无需手动source。直接把python代码放进~/.gdbinit当然是不行的。需要变通一下，在~/.gdbinit加入source ~/move.py。这样gdb每次启动时都会替我们source一下。\n有两点需要注意的是：\n\ngdb会用python 3来解释你的python脚本，除非你用的gdb还处于版本感人的上古时代。\n跟一般情况不同，gdb环境中的sys.path是不包括当前目录的。这意味着，如果你的脚本依赖于当前目录下的其他模块，你需要手工修改sys.path。比如(gdb) python import sys; sys.path.append('')\n\ngdb的python接口\ngdb通过gdb模块提供了不少python接口。其中最为常用的是gdb.execute和gdb.parse_and_eval。\n如前所示，gdb.execute可用于执行一个gdb命令。默认情况下，结果会输出到gdb界面上。如果想把输出结果转存到字符串中，设置to_string为True：gdb.execute(cmd, to_string=True)。\ngdb.parse_and_eval接受一个字符串作为表达式，并以gdb.Value的形式返回表达式求值的结果。举例说，gdb当前上下文中有一个变量i，i等于3。那么gdb.parse_and_eval('i + 1')的结果是一个gdb.Value的实例，其value属性的值为4。这跟(gdb) i + 1是等价的。\n何为gdb.Value？在gdb会话里，我们可以访问C/C++类型的值。当我们通过python接口跟这些值打交道时，gdb会把它们包装成一个gdb.Value对象。\n举个例子，struct Point有x跟y两个成员。现在假设当前上下文中有一个Point类型的变量point和指向该变量的Point指针p，就意味着：\npoint = gdb.parse_and_eval('point')\npoint['x'] # 等价于point.x\npoint['y'] # 等价于point.y\npoint.referenced_value() # 等价于&point\n\np = gdb.parse_and_eval('p')\npoint2 = p.dereference() # 等价于*p\npoint2['x'] # 等价于(*p).x，也即p->x\n有时候我们需要转换gdb.Value的类型。如果能在gdb上下文内完成转换，那倒是不难：gdb.parse_and_eval('(TypeX)$a')。\n但如果只能在python代码这一边完成转换，倒是有些复杂，需要使用gdb.Type类型：typeX_point = point.cast(gdb.lookup_type('TypeX'))。gdb.Value有一个cast方法用于类型转换，接收一个gdb.Type对象。我们还需要使用lookup_type来构建一个gdb.Type对象。看上去是挺啰嗦。值得注意的是，'TypeX *'和'TypeX &'并非独立的类型。如果你要获得类型X的指针/引用，需要这么写gdb.lookup_type('X').pointer()/gdb.lookup_type('X').reference()。\n另外一个常用的接口是gdb.events.stop.connect。你可以使用该接口注册gdb停止时的回调函数。当gdb触发断点或收到信号时，就会调用事先注册的回调函数。对应的，撤销回调函数的接口是gdb.events.stop.disconnect。\nbps = gdb.breakpoints()\nif bps is None:\n    raise gdb.GdbError('No breakpoints')\nlast_breakpoint_num = bps[-1].number\n\ndef commands(event):\n    if not isinstance(event, gdb.BreakpointEvent):\n        return\n    if last_breakpoint_num in (bp.number for bp in event.breakpoints):\n        gdb.execute('info locals')\n        gdb.execute('info args')\n\ngdb.events.stop.connect(commands)\n借助这些接口，我们可以这样重新实现前文用到的“对账”脚本：\n# malloc_free.py\nfrom collections import defaultdict, namedtuple\nimport atexit\nimport time\nimport gdb\n\n\nEntry = namedtuple('Entry', ['addr', 'bt', 'timestamp', 'size'])\nMEMORY_POOL = {}\nMEMORY_LOST = defaultdict(list)\n\ndef comm(event):\n    if isinstance(event, gdb.SignalEvent): return\n    # handle BreakpointEvent\n    for bp in event.breakpoints:\n        if bp.number == 1:\n            addr = str(gdb.parse_and_eval('p'))\n            bt = gdb.execute('bt', to_string=True)\n            timestamp = time.strftime('%H:%M:%S', time.localtime())\n            size = int(gdb.parse_and_eval('size'))\n            if addr in MEMORY_POOL:\n                MEMORY_LOST[addr].append(MEMORY_POOL[addr])\n            MEMORY_POOL[addr] = Entry(addr, bt, timestamp, size)\n        elif bp.number == 2:\n            addr = gdb.parse_and_eval('p')\n            if addr in MEMORY_POOL:\n                del MEMORY_POOL[addr]\n    gdb.execute('c')\n\n\ndef dump_memory_lost(memory_lost, filename):\n    with open(filename, 'w') as f:\n        for entries in MEMORY_LOST.values():\n            for e in entries:\n                f.write(\"Timestamp: %s\\tAddr: %s\\tSize: %d\" % (\n                        e.timestamp, e.addr, e.size))\n                f.write('\\n%s\\n' % e.bt)\n\n\natexit.register(dump_memory_lost, MEMORY_LOST, '/tmp/log')\n# Write to result file once signal catched\ngdb.events.stop.connect(comm)\n\ngdb.execute('set pagination off')\ngdb.execute('b my_malloc') # breakpoint 1\ngdb.execute('b my_free') # breakpoint 2\ngdb.execute('c')\n用法：sudo gdb -q -p $(pidof $your_project) -x malloc_free.py。\n小结\n对比于前文的DSL实现，“对账”脚本的python实现里直接完成了对数据的处理，免去了额外写一个脚本来处理输出结果。能够灵活方便地处理数据——这是诸如python一类的通用语言对于领域特定语言的优势。当然，领域特定语言在其擅长的领域里，具有通用语言无法比拟的亲和力——直接输入gdb命令，显然比每次都gdb.execute('xxx')要顺畅得多。无论是自定义的mv命令，还是“对账”脚本，python实现都要比DSL实现更长。当然，python比照DSL来说，有其自身的长处。本教程剩余部分会提及这一点。\n如果说本篇主要讲了如何用python实现DSL实现过的内容，那么接下来几篇将关注于如何用python实现DSL实现不了的内容。敬请期待。\n完整的python API参见官方文档：https://sourceware.org/gdb/current/onlinedocs/gdb/Python-API.html\n另外本人写过一个gdb接口的辅助模块，包装了常用的gdb接口： https://github.com/spacewander/debugger-utils 。感兴趣的话可以参考下里面的实现。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "13"}