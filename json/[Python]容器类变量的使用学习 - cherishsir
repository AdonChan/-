{"title": "[Python]容器类变量的使用学习 - cherishsir ", "index": "python", "content": "0:Python的强大之处在于数据操作的方便和大类的第三方module,本文主要是学习收集数据操作相关的内容\n1:Tuple相关内容\n#通过代码对基本内容进行学习\nempty=() #这是一个空的tuple\n\nonestr=(\"hello world\")    #注意这不是一个tuple变量，而是一个str类型的变量 \n\nonetuple=(\"hello world\",) #注意与上面的例子对比，这里在括号内加了一个逗号，变量类型为tuple\n\nmultituples=(1,\"hellow\",3.14) #tuple变量包含多个元素，元素的类型可以不一样\n\nmultituples=1,\"hellow\",3.14  #这个例子也是tuple类型，与上例效果一样，只是一种偷懒的写法\n\n\n#tuple中，选择子tuple的方法与list一样，这里就不多说了，如下\nname[:3]  #前三个元素 \nname[-3:] #最后三个元素 \nname[3:6] #位置3,4,5 这三个元素 ，注意不包含位置6的元素 \n\n#由于tuple内部的数据是可嵌套的，所以内部的数据是什么类型，也很重要\n\n#看一个tuple不怎么用的功能，把world分解成每一个alphabet\nIn [1]: tuple(\"hello\")\nOut[1]: ('h', 'e', 'l', 'l', 'o')\n\nIn [2]: tuple(\"hello world\")\nOut[2]: ('h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd')\n\n2:List相关内容\nvarlist=[] #空的list\n\n#list中，选择子list的方法,如下\nname[:3]  #前三个元素 \nname[-3:] #最后三个元素 \nname[3:6] #位置3,4,5 这三个元素 ，注意不包含位置6的元素\n\n#list的insert方法\nvarlist.insert(4,\"apple\") #在位置4插入\"apple\"值，原来在位置4的值，往后退一位，变成位置5上的值\n\n#list中删除一个元素的方法 \ndel varlist[3]     #这样会把位置3的元素值给删掉\ndel valist[0:2]    #删除位置 0,1的两个元素 \ndel valist[3:5]    #删除位置 3,4的两个元素 \n\n#改变某一个位置的元素 \nvarlist[3]=\"hello\"\n\n\n#下面是List中常用的一些方法 \nif x in List :  #判断 item是不是在list中存在\nif x not in List: #同上，这里的item可以是子List\n#如下看例子\nIn [36]: a\nOut[36]: [1, 2, 3, 6, 7, 8, 9, [1, 2, 4]]\n\nIn [37]: [1,2,4] in a\nOut[37]: True\n\n#List容器的扩展\n# 直接做+产生新的扩展list,不会影响a,b的值\nIn [39]: a=[i  for i in range(1,5)]\n\nIn [40]: a\nOut[40]: [1, 2, 3, 4]\n\nIn [41]: b=[6,7,8]\n\nIn [42]: a+b\nOut[42]: [1, 2, 3, 4, 6, 7, 8]\n\nIn [43]: a\nOut[43]: [1, 2, 3, 4]\n\nIn [44]: b\nOut[44]: [6, 7, 8]\n\n#使用list容器的 extend函数，如下，a的内容被 扩展了\n\nIn [45]: a\nOut[45]: [1, 2, 3, 4]\n\nIn [46]: b\nOut[46]: [6, 7, 8]\n\nIn [47]: a.extend(b)\n\nIn [48]: a\nOut[48]: [1, 2, 3, 4, 6, 7, 8]\n\n#删掉list中的某个item,如下，可以看到remove是从左往右查找，找到第一需要删除的item就删除掉 \nIn [56]: a\nOut[56]: [1, 2, 3, 4, 5, 6, 7]\nIn [57]: a.append(7)\n\nIn [58]: a\nOut[58]: [1, 2, 3, 4, 5, 6, 7, 7]\n\nIn [59]: a.remove(7)\nIn [60]: a\nOut[60]: [1, 2, 3, 4, 5, 6, 7]\n\n#使用append()追加函数和pop()函数，实现stack的效果\nIn [66]: a\nOut[66]: [1, 2, 3, 4, 5, 6, 7]\n\nIn [67]: a.append(8)\n\nIn [68]: a\nOut[68]: [1, 2, 3, 4, 5, 6, 7, 8]\n\nIn [69]: cell=a.pop()\n\nIn [70]: cell\nOut[70]: 8\n\nIn [71]: a\nOut[71]: [1, 2, 3, 4, 5, 6, 7]\n\n#pop(int)还可以指定弹出某一位置的值，如下\nIn [72]: a\nOut[72]: [1, 2, 3, 4, 5, 6, 7]\n\nIn [73]: a.pop(0)\nOut[73]: 1\n\nIn [74]: a\nOut[74]: [2, 3, 4, 5, 6, 7]\n\n#list的reverse()和sort()方法也是经常会使用到的\n\n\n# 关于list的shadow copy和 deep copy\n# 下面是shadow copy的例子，b的值改变了会影响a的值\n# 所以shadow copy中，b变量只是a变量的别名，操作的是同一块内存空间\nIn [76]: a\nOut[76]: [2, 3, 4, 5, 6, 7]\n\nIn [77]: b=a\n\nIn [78]: b[0]=100\n\nIn [79]: a\nOut[79]: [100, 3, 4, 5, 6, 7]\n\nIn [80]: b\nOut[80]: [100, 3, 4, 5, 6, 7]\n\n#使用deep copy的方法 ，赋值时使用b=a[:] 这处形式即可，a,b的操作互不影响对方\nIn [81]: a\nOut[81]: [100, 3, 4, 5, 6, 7]\n\nIn [82]: b=a[:]\n\nIn [83]: b[0]=200\n\nIn [84]: a\nOut[84]: [100, 3, 4, 5, 6, 7]\n\nIn [85]: b\nOut[85]: [200, 3, 4, 5, 6, 7]\n\n3:Dict相关内容\n#dict是相当重要的一类容器\n#注意dict的key不能是数字\nIn [1]: vardict=dict(name=\"Tome\",age=22,height=1.75)\n\nIn [2]: vardict\nOut[2]: {'age': 22, 'height': 1.75, 'name': 'Tome'}\n\nIn [3]: vardict=dict(name=\"Tome\",age=22,height=1.75,3=5)\n  File \"<ipython-input-3-8ead9275fd02>\", line 1\n    vardict=dict(name=\"Tome\",age=22,height=1.75,3=5)\nSyntaxError: keyword can't be an expression\n\n\nIn [4]: vardict=dict(name=\"Tome\",age=22,height=1.75,test=(3,4))\n\nIn [5]: vardict\nOut[5]: {'age': 22, 'height': 1.75, 'name': 'Tome', 'test': (3, 4)}\n\n#如上test这个key就对应着多个值，所以 1个 key 对应多个值，这种情况，在python中就不是问题，\n#因为在Python中，容器是可嵌套的\n\n\n#在vardict字典变量中插入一对key,value\nIn [9]: vardict[\"gendar\"]=\"male\"\n\nIn [10]: vardict\nOut[10]: {'age': 22, 'gendar': 'male', 'height': 1.75, 'name': 'Tome', 'test': (3, 4)}\n\n#删除dict变量中的key,value,只需要知道key值就足够了\nIn [10]: vardict\nOut[10]: {'age': 22, 'gendar': 'male', 'height': 1.75, 'name': 'Tome', 'test': (3, 4)}\n\nIn [11]: del vardict[\"age\"]\n   \nIn [12]: vardict\nOut[12]: {'gendar': 'male', 'height': 1.75, 'name': 'Tome', 'test': (3, 4)}\n\n\n#dict变量中弹出一个key,value的方法 pop(key)\nIn [15]: vardict\nOut[15]: {'gendar': 'male', 'height': 1.75, 'name': 'Tome', 'test': (3, 4)}\n\nIn [16]: vardict.pop(\"gendar\")\nOut[16]: 'male'\n\nIn [18]: vardict\nOut[18]: {'height': 1.75, 'name': 'Tome', 'test': (3, 4)}\n\n\n# 判断key,value 在dict变量中是否存在的方法 \n# 从下面的例子可知 keys(),values()函数返回的是一个可迭代的对象list对象\nIn [23]: vardict\nOut[23]: {'height': 1.75, 'name': 'Tome', 'test': (3, 4)\n\nIn [24]: \"height\" in vardict.keys()\nOut[24]: True\n\nIn [25]: 1.75 in vardict.values()\nOut[25]: True\n\n# 使用clear()方法，清空dict对象\nIn [27]: vardict\nOut[27]: {'height': 1.75, 'name': 'Tome', 'test': (3, 4)}\n\nIn [28]: vardict.clear()\n\nIn [29]: vardict\nOut[29]: {}\n\n\n\n#直接把dcit对象赋值给另一个对象，使用的是shadow copy方式，相当于c++里面的引用，看如下例子\nIn [32]: vardict\nOut[32]: {'age': 22, 'height': 1.75, 'name': 'Tome'}\n\nIn [33]: shadowdict=vardict\n\nIn [34]: shadowdict\nOut[34]: {'age': 22, 'height': 1.75, 'name': 'Tome'}\n\nIn [35]: shadowdict[\"age\"]=25\n\nIn [36]: shadowdict\nOut[36]: {'age': 25, 'height': 1.75, 'name': 'Tome'}\n\nIn [37]: vardict\nOut[37]: {'age': 25, 'height': 1.75, 'name': 'Tome'}\n\n\n#当我们使用了copy操作，对一个对象进行复制后，两个对象是相互不影响的，如下例子\nIn [50]: vardict\nOut[50]: {'age': 25, 'height': 1.75, 'name': 'Tome'}\n\nIn [51]: adict=vardict.copy()\n\nIn [52]: adict\nOut[52]: {'age': 25, 'height': 1.75, 'name': 'Tome'}\n\nIn [53]: adict[\"age\"]=888\n\nIn [54]: vardict\nOut[54]: {'age': 25, 'height': 1.75, 'name': 'Tome'}\n\nIn [55]: adict\nOut[55]: {'age': 888, 'height': 1.75, 'name': 'Tome'\n\n#如下又一个例子，可见dict对象的copy方法复制对象还是非常彻底的\nIn [60]: vardict\nOut[60]: {'age': 25, 'height': 1.75, 'name': 'Tome', 'subdict': {'a': 4, 'b': 5}}\n\nIn [61]: adict=vardict.copy()\n\nIn [62]: adict\nOut[62]: {'age': 25, 'height': 1.75, 'name': 'Tome', 'subdict': {'a': 4, 'b': 5}}\n\nIn [63]: adict[\"subdict\"]=\"hello world\"\n\nIn [65]: adict\nOut[65]: {'age': 25, 'height': 1.75, 'name': 'Tome', 'subdict': 'hello world'}\n\nIn [66]: vardict\nOut[66]: {'age': 25, 'height': 1.75, 'name': 'Tome', 'subdict': {'a': 4, 'b': 5}}\n\n#再看下面的例子可以知道dict的变量的copy()只是对 对象进行一层copy,第二层没有进行copy,\nIn [67]: vardict\nOut[67]: {'age': 25, 'height': 1.75, 'name': 'Tome', 'subdict': {'a': 4, 'b': 5}}\n\nIn [68]: adict=vardict.copy()\n\nIn [69]: adict[\"subdict\"][\"a\"]=55\n\nIn [70]: adict\nOut[70]: {'age': 25, 'height': 1.75, 'name': 'Tome', 'subdict': {'a': 55, 'b': 5}}\n\nIn [71]: vardict\nOut[71]: {'age': 25, 'height': 1.75, 'name': 'Tome', 'subdict': {'a': 55, 'b': 5}}\n\nIn [72]: vardict[\"age\"]=88\n\nIn [73]: adict\nOut[73]: {'age': 25, 'height': 1.75, 'name': 'Tome', 'subdict': {'a': 55, 'b': 5}}\n\nIn [74]: vardict\nOut[74]: {'age': 88, 'height': 1.75, 'name': 'Tome', 'subdict': {'a': 55, 'b': 5}}\n\n\n#dict变量中可以进行迭代的一些量\nd.keys() ,d.values(),d.items()\nfor key,value in d.items():\n\n#返回 key对应的value\nd.get(key)     #如果没有这个key,则返回None\nd.get(key,x)   #如果没有这个key,则返回x\n\n# 下面是get方法的用法\nIn [6]: vardict.get(\"a\")\nOut[6]: 4\n\nIn [7]: vardict.get(\"0\")\n\nIn [8]: a=vardict.get(\"0\")\n\nIn [9]: a\n\nIn [10]: print a\nNone\n\nIn [11]: vardict\nOut[11]: {'a': 4, 'b': 5, 'c': 6, 'd': 'hello'}\n\nIn [12]: if a==None:\n   ....:     print \"yes\"\n   ....:     \nyes\n\n# 由于vardict里面没有\"0\"这个key,所以会返加\"baby\"\n\nIn [13]: vardict.get(\"0\",\"baby\")\nOut[13]: 'baby'\n\nIn [14]: vardict\nOut[14]: {'a': 4, 'b': 5, 'c': 6, 'd': 'hello'}\n\n#下面是setdefault(key)的用法\nIn [26]: vardict=dict(a=1,b=2)\n\nIn [27]: a=vardict.setdefault(\"aa\")  #由于\"aa\"之前不存在，所以返回None\nIn [28]: vardict\nOut[28]: {'a': 1, 'aa': None, 'b': 2}  # 并且这个\"aa\" key也加入到vardict里面了\n\n#下面setdefault(key,value)的用法\nIn [33]: vardict\nOut[33]: {'a': 1, 'aa': None, 'b': 2}\n\nIn [34]: a=vardict.setdefault(\"bb\",\"baby\") #由于\"bb\" key之前不存在，所以 返回\"baby\",并且将这个一对key,value加入到vardict中\n\nIn [35]: print a\nbaby\n\nIn [36]: vardict\nOut[36]: {'a': 1, 'aa': None, 'b': 2, 'bb': 'baby'}\n\n\n#下例，由于\"bb\"key之前存在，所以返回\"bb\"的value,\nIn [37]: a=vardict.setdefault(\"bb\",\"gaga\")\n\nIn [38]: print a\nbaby\n\nIn [39]: vardict\nOut[39]: {'a': 1, 'aa': None, 'b': 2, 'bb': 'baby'}\n\n\n\n#下面的例子与上面的d.get,d.setdefault也是一样的工作原理\nd.pop(k)  #如果存在k 键 ，则返回对应value,否则返回None\nd.pop(k,x) #如果存在k 键，则返回对应的value,否则返回x\n\n#下面是pop的用法\nIn [39]: vardict\nOut[39]: {'a': 1, 'aa': None, 'b': 2, 'bb': 'baby'}\nIn [40]: vardict.pop(\"xx\",3)  #没有\"xx\" key，所以返回3\nOut[40]: 3\n\nIn [41]: vardict.pop(\"a\",3)   #存在\"a\" key, 所以返回对应的value\nOut[41]: 1\n\nIn [42]: vardict              #并且可以看到，这个key,value已经被弹出\nOut[42]: {'aa': None, 'b': 2, 'bb': 'baby'}\n3：Set相关内容\n#由于Set用的相对较少，所以也不多说\n#Set容器的重要特点就是唯一性\n#看下面例子就可以了\n\nIn [43]: a=set()\n\nIn [44]: type(a)\nOut[44]: set\n\nIn [45]: a=set(3,4,5,\"hellO\") #这样是不对的哦\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n<ipython-input-45-69dc95d9d8eb> in <module>()\n----> 1 a=set(3,4,5,\"hellO\")\n\nTypeError: set expected at most 1 arguments, got 4\n\nIn [46]: a=set((3,4,5,\"hellO\"))  #这样才对，两个括号\n\n#set元素的唯 一性\nIn [46]: a=set((3,4,5,\"hellO\"))\n\nIn [47]: a.add(3)  #因为上面已经存在3了，加了也没用\n\nIn [48]: a\nOut[48]: {3, 4, 5, 'hellO'}\n\nIn [49]: a.add(6)\n\nIn [50]: a\nOut[50]: {3, 4, 5, 6, 'hellO'}\n\n#set的remove\nIn [57]: a\nOut[57]: {3, 4, 5, 6, 9, 'hellO'}\n\nIn [58]: 9 in a\nOut[58]: True\n\nIn [59]: 10 in a\nOut[59]: False\n\nIn [60]: a.remove(3)\n\nIn [61]: a\nOut[61]: {4, 5, 6, 9, 'hellO'}\n\nIn [62]: a.remove(0) # 由于0不在set a中,所以报错了 \n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\n<ipython-input-62-bea8936f69a1> in <module>()\n----> 1 a.remove(0)\n\nKeyError: 0\n\n#set的常用函数\nx in set\nx not in set\nlen(set)\nset.clear()\nset.copy() #只会复制第一层\ns.add(x)  #只会加一次\ns.remove(x) #把x去掉 ，x不存在会报错，所以remove 之前，做一下 if x in a:\ns.dicard(x) #把x去掉， x不存在也不会报错\n\ns.issubset(t) #当s是t的子集时，返回true   s <= t\ns.issuperset(t) #当s是t的超集时，返回true s >= t\n\ns.union(t)         #不影响s,t，做 “或”运算，返回一个新的集合\ns.intersection(t)  #不影响s,t，做 “与”运算，返回一个新的集合\ns.difference(t)    #不影响s,t，做 “-”运算， 返回一个新的集合 \n\n4：常用 实用built-in函数\n#all(q)函数，q中所有元素都是true时，返回true,q是可iterable\nIn [75]: a\nOut[75]: {5, 6, 9, 'hellO'}\n\nIn [76]: all(a)\nOut[76]: True\n\nIn [77]: a.add(None)\n\nIn [78]: a\nOut[78]: {None, 5, 6, 9, 'hellO'}\n\nIn [79]: all(a)\nOut[79]: False\n\nIn [80]: any(a)  #any(q)函数，只要q中有一个item是true,则返回ture\nOut[80]: True\n\n#常用小函数，不解释\n x in q , x not in q ,  len(q) ,max(q)\n\nIn [84]: max((\"tom\",\"jerry\",\"zuangta\")) #比较首字母的ascii值\nOut[84]: 'zuangta'\n\nIn [85]: min((\"tom\",\"jerry\",\"zuangta\")) #比较首字母的ascii值\nOut[85]: 'jerry'\n\nIn [86]: max(3,4,5)\nOut[86]: 5\n\nIn [87]: min(3,4,5)\nOut[87]: 3\n\nIn [92]: sum([i for i in range(1,101)]) #一行代码，求1到100的和\nOut[92]: 5050\n\nIn [93]: sum((1,2,3))\nOut[93]: 6\n\nIn [94]: len([i for i in range(1,101)])\nOut[94]: 100\n\nchr(int),unichr(int),ord(character)\ndir(x) #返回module的method and attributes\nhasattr(x,a) #这个很重要，后面需要特别研究\nid(x) #相当于变量x的内存地址，如果id(x),id(y)相同，那么x与y互为别名\n\nisinstance(x, C) #如果变量x是 类C的一个实例，返回true,如下例子\nIn [129]: a=3\nIn [130]: isinstance(a,int)\nOut[130]: True\nIn [131]: isinstance(a,float)\nOut[131]: False\ntype(x) #查看x的类型，多用于debug\n\n#eval(s) 就下面这点用？？\nIn [138]: a\nOut[138]: 3\nIn [139]: s=\"a+2\"\nIn [142]: a=eval(s)\nIn [143]: a\nOut[143]: 5\n\n#文件操作，这个太重要了\nopen(f, m)\n\nrange(i) #产生 0到i-1的list\n\nIn [146]: divmod(6,4) #这个函数好用\nOut[146]: (1, 2)\n\n#几个基本的数操作函数 \nhex(i)  #注意下面的结果，返回的是str类型\nIn [147]: hex(16)\nOut[147]: '0x10'\nIn [148]: hex(15)\nOut[148]: '0xf'\n\n\noct(int) #返回的是8进行的表达式，返回类型为str\nIn [154]: oct(7)\nOut[154]: '07'\n\nIn [155]: oct(8)\nOut[155]: '010'\n\nIn [156]: oct(16)\nOut[156]: '020'\n\n#float函数，注意传入参数可以是str，也可以是数字\nIn [160]: float(\"3\")\nOut[160]: 3.0\n\nIn [161]: float(3)\nOut[161]: 3.0\n\nIn [162]: float(\"3.4\")\nOut[162]: 3.4\n\nIn [163]: float(\"3e10\") #这样也是可以的\nOut[163]: 30000000000.0\n\n#int()函数的使用\nIn [164]: int(\"33\")\nOut[164]: 33\n\nIn [165]: int(44.4)\nOut[165]: 44\n\nIn [166]: int(\"44.4\") #这样就报错了，怎么办\nValueError: invalid literal for int() with base 10: '44.4'\n\nIn [167]: int(float(\"44.4\")) #先转化为float再int，就可以了\nOut[167]: 44\n\n\n#long()函数的使用\nIn [168]: long(333)\nOut[168]: 333L\n\nIn [169]: long(\"333\")\nOut[169]: 333L\n\nIn [170]: long(\"333.3\") #又报错了，同上面的解决方法一样\nValueError: invalid literal for long() with base 10: '333.3'\n\nIn [171]: long(float(\"333.3\")) #内部嵌套一个float转换即可\nOut[171]: 333L\n\n#pow(x,y)的使用\nIn [185]: pow(2,3)\nOut[185]: 8\n\nIn [186]: pow(2,-3)\nOut[186]: 0.125\n\n#round(x,n) 4舍5入，精确到几位小数\nIn [187]: round(3.1415926,2)\nOut[187]: 3.14\n\nIn [188]: round(3.1415926,3)\nOut[188]: 3.142\n\nIn [189]: round(3.1415926)\nOut[189]: 3.0\n5：通过id函数，思考shadow copy and deep copy\n#demo 1\nIn [99]: a=[1,3,4]\n\nIn [100]: b=a #shadow copy,b是a的别名，下面可以看到，都是指向同一块内存地址 \n\nIn [101]: id(b)\nOut[101]: 139824773228304\n\nIn [102]: id(a)\nOut[102]: 139824773228304\n\n#demo 2\nIn [103]: a\nOut[103]: [1, 3, 4]\n\nIn [104]: b=a[:] #id都不同了\n\nIn [105]: id(a)\nOut[105]: 139824773228304\n\nIn [106]: id(b)\nOut[106]: 139824773228232\n\n#但是 下面的现象，你可以知道什么 ，呵呵\n#下面的情况，还是python为了节约内存的一种做法\n#python的解释器太过智能了\nIn [107]: id(b[0])\nOut[107]: 30560600\n\nIn [108]: id(a[0])\nOut[108]: 30560600\n\nIn [109]: b[0]=33 #当b[0]的内容发生变化时，就会分配一块新的内存给b[0]\n\nIn [110]: id(a[0])\nOut[110]: 30560600\n\nIn [111]: id(b[0])\nOut[111]: 30559832\n\n#demo 3 这个更难了，所以书中说的shadow copy实际就是说只复制了一层\nIn [115]: a\nOut[115]: [1, 2, [3, 4]]\n\nIn [116]: b=a[:]\n\nIn [117]: id(b)\nOut[117]: 139824773228160\n\nIn [118]: id(a)\nOut[118]: 139824773229240\n\nIn [119]: id(b[2])\nOut[119]: 139824789304600\n\nIn [120]: id(a[2])\nOut[120]: 139824789304600\n\nIn [121]: b[2].append(88)\n\nIn [122]: a\nOut[122]: [1, 2, [3, 4, 88]]\n\nIn [123]: b\nOut[123]: [1, 2, [3, 4, 88]]\n\nIn [124]: id(a[2])\nOut[124]: 139824789304600\n\nIn [125]: id(b[2])\nOut[125]: 139824789304600\n\nIn [126]: a[0]=33\n\nIn [127]: a\nOut[127]: [33, 2, [3, 4, 88]]\n\nIn [128]: b\nOut[128]: [1, 2, [3, 4, 88]]\n\n\n#deep copy后面再整理\n\n\n\n6：几个常用的数据取整函数 round,ceil,floor\n#round函数4舍5入\nIn [3]: round(1.4999)\nOut[3]: 1.0\n\nIn [4]: round(1.5000)\nOut[4]: 2.0\n\nIn [5]: round(1.5)\nOut[5]: 2.0\n\nIn [6]: round(1.2)\nOut[6]: 1.0\n\n#ceil函数，向上取整\nIn [9]: import math\n\nIn [10]: math.ceil(1.2)\nOut[10]: 2.0\n\nIn [11]: math.ceil(1.8)\nOut[11]: 2.0\n\n#foor函数，向下取整\nIn [12]: math.floor(1.2)\nOut[12]: 1.0\n\nIn [13]: math.floor(1.8)\nOut[13]: 1.0\n\n\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "2"}