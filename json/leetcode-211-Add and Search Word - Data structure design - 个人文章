{"title": "leetcode-211-Add and Search Word - Data structure design - 个人文章 ", "index": "python", "content": "原题：\n211. Add and Search Word - Data structure design\n\nDesign a data structure that supports the following two operations:\n\nvoid addWord(word)\nbool search(word)\n\nsearch(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.\n\nExample:\n\naddWord(\"bad\")\naddWord(\"dad\")\naddWord(\"mad\")\nsearch(\"pad\") -> false\nsearch(\"bad\") -> true\nsearch(\".ad\") -> true\nsearch(\"b..\") -> true\n\nNote:\nYou may assume that all words are consist of lowercase letters a-z.\n总结：栈 stack 的利用，先进后出的作用，可以保持 链表一类的数据的连贯操作，可以用来替代广度搜索。\n每一层次可以用进栈出栈进行替代。\nstack=[（node,str）],形式的数据结构，有记忆状态的作用。\n应用： 字符串的遍历，广度搜索。\n    \n\nimport collections\n\nclass WordNode:\n    def __init__(self):\n        self.children = {}\n        self.isEnd = False\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = WordNode()\n\n    def addWord(self, word):\n        cur_node=self.root\n        for char_iter in word:\n            if char_iter in cur_node.children:\n                cur_node=cur_node.children[char_iter]\n            else:\n                new_node=WordNode()\n                cur_node.children[char_iter]=new_node\n                cur_node=new_node\n            # cur_node=cur_node.children[char_iter]\n        cur_node.isEnd=True\n\n    def search(self, word):\n        stack=[(self.root,word)]\n        while stack:\n            node,w=stack.pop()\n            if not w:\n                if node.isEnd:\n                    return True\n            # print([w])\n            elif w[0] == '.':\n                for node_iter in node.children.values():\n                    stack.append((node_iter,w[1:]))\n            elif w[0] in node.children:\n                nodes_cur=node.children[w[0]]\n                stack.append((nodes_cur,w[1:]))\n            else:\n                pass\n        return False\n\n\n\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = WordNode()\n\n    def addWord(self, word):\n        node = self.root\n        for w in word:\n            if w in node.children:\n                node = node.children[w]\n            else:\n                node.children[w] = WordNode()\n                node = node.children[w]\n        node.isEnd = True\n\n    def search(self, word):\n        stack = [(self.root, word)]\n        while stack:\n            node, w = stack.pop()\n            if not w:\n                if node.isEnd:\n                    return True\n            elif w[0] == '.':\n                for n in node.children.values():\n                    stack.append((n, w[1:]))\n            else:\n                if w[0] in node.children:\n                    n = node.children[w[0]]\n                    stack.append((n, w[1:]))\n        return False\n\n\nif __name__=='__main__':\n    wd=WordDictionary()\n    # wd.addWord(\"bad\")\n    # wd.addWord(\"dad\")\n    # wd.addWord(\"mad\")\n    # out=wd.search(\"pad\")\n    # print(out)\n    # out =wd.search(\"bad\")\n    # print(out)\n    # out =wd.search(\".ad\")\n    # print(out)\n    # out =wd.search(\"b..\")\n    # print(out)\n\n    words=[\"WordDictionary\", \"addWord\", \"addWord\", \"search\", \"search\", \"search\", \"search\", \"search\", \"search\"]\n    detect_words=[ [\"a\"], [\"a\"], [\".\"], [\"a\"], [\"aa\"], [\"a\"], [\".a\"], [\"a.\"]]\n    for word in words:\n        wd.addWord(word)\n    for detect_word in detect_words:\n        out=wd.search(detect_word[0])\n        print(out)\n\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}