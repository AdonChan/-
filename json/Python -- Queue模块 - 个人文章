{"title": "Python -- Queue模块 - 个人文章 ", "index": "python", "content": "学习契机\n最近的一个项目中在使用grpc时遇到一个问题，由于client端可多达200，每个端口每10s向grpc server发送一次请求，server端接受client的请求后根据request信息更新数据库，再将数据库和配置文件的某些数据封装后返回给client。原代码的性能是0.26s/request，远远达不到所需性能，其中数据库更新操作耗时达到80%，其中一个优化点就是将数据库更新操作放在独立的线程中。在次之前没有使用过线程编码，学以致用后本着加深理解的想法，将这个过程记录下来，这里先记下用于线程间通信的队列Queue的相关知识。\n概念\nPython2中队列库名称为Queue，Python3中已改名为queue，项目使用Python2.7.5版本，自然是使用Queue。Queue模块中提供了同步的、线程安全的队列类，包括FIFO（先入先出)队列Queue，LIFO（后入先出）队列LifoQueue，和优先级队列PriorityQueue。这些队列都实现了锁原语，可在多线程通信中直接使用。\nQueue模块定义了以下类及异常，在队列类中，maxsize限制可入队列数据的数量，值小于等于0时代表不限制:\n\n\nQueue.Queue(maxsize=0)  FIFO队列\n\nQueue.LifoQueue(maxsize=0) LIFO队列\n\nQueue.PriorityQueue(maxsize=0)  优先级队列\n\nQueue.Empty TODO\n\nQueue.Full\n\nQueue（Queue、LifoQueue、PriorityQueue）对象提供以下方法：\n\n\nQueue.qsize()  返回队列大小，但是不保证qsize() > 0时，get()不会阻塞；也不保证qsize() < maxsize时，put()不会阻塞。\n\nQueue.empty()  返回True时，不保证put()时不会阻塞；返回False时不保证get()不会阻塞。\n\nQueue.full()  返回True时，不保证get()时不会阻塞；返回False时不保证put()不会阻塞。\n\nQueue.put(item[, block[, timeout]])  block默认值为False，指定为True时代表可以阻塞，若同时指定timeout，在超时时返回Full exception。\n\nQueue.put_nowait(item)  等同put(item, False)\n\nQueue.get([block[, timeout]])\n\nQueue.get_nowait()  等同get(item, False)\n\n\nQueue.task_done()  消费者线程调用。调用get()后，可调用task_done()告诉队列该任务已经处理完毕。  如果当前一个join()正在阻塞，它将在队列中的所有任务都处理完时恢复执行（即每一个由put()调用入队的任务都有一个对应的task_done()调用）。\n\nQueue.join()  阻塞调用线程，直到队列中的所有任务被处理掉。  只要有数据被加入队列，未完成的任务数就会增加。当消费者线程调用task_done()（意味着有消费者取得任务并完成任务），未完成的任务数就会减少。当未完成的任务数降到0，join()解除阻塞。\n\n应用\nUpdateThread是单一消费者进程，获取FIFO队列中的数据处理，GrpcThread是multi生产者线程，需要对往队列中丢数据这个操作加锁保证数据先后顺序。\nimport threading\nimport Queue\nimport time\n\nq = Queue.Queue()\nq_lock = threading.Lock()\n\n\nclass UpdateThread(threading.Thread):\n\n    def __init__(self):\n        super(self.__class__, self).__init__()\n        self.setName(self.__class__.__name__)\n        self._setName = self.setName\n\n    @staticmethod\n    def update_stat():\n        global q\n        while not q.empty():\n            stat = q.get()\n            print 'Update stat (%s) in db' % stat\n\n    def run(self):\n        while True:\n            self.update_stat()\n            time.sleep(0.1)\n\n\nclass GrpcThread(threading.Thread):\n\n    def compose_stat(self, stat):\n        global q\n        q_lock.acquire()\n        q.put('%d: %s' % (stat, self.name))\n        q_lock.release()\n        return\n\n    def run(self):\n        for i in range(10):\n            self.compose_stat(i)\n            time.sleep(0.1)\n\n\ndef launch_update_thread():\n    UpdateThread().start()\n\n\nif __name__ == '__main__':\n    launch_update_thread()\n    thread1 = GrpcThread()\n    thread2 = GrpcThread()\n\n    thread1.start()\n    thread2.start()\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}