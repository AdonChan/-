{"title": "利用python进行识别相似图片(二) - 肥兔子de碎碎语 ", "index": "图像检索,图片识别,opencv,pillow,python", "content": "前言\n和网上各种首先你要有一个女朋友的系列一样，想进行人脸判断，首先要有脸，只要能靠确定人脸的位置，那么进行两张人脸是否相似的操作便迎刃而解了。\n所以本篇文章着重讲述如何利用openCV定位人脸。\n上一篇文章的地址：\n利用python进行识别相似图片（一）\n安装openCV\nopencv官网\n在进行下一步操作时，我们需要安装openCV，本来安装openCV的步骤跟平常安装其他模块一样，而然由于python的历史原因(用过都懂……)，弄得一点都不友好。\n先说一下，python2.7的用户，可以直接在openCV的官网上直接下载，然后在openCV的build\\python的目录下，根据自己的情况，选择x86,x64下的cv2.pyd放到你python的安装目录的\\Lib\\site-packages\\下。\n至于python3.4的用户，即有点特别。你可以在StackOverFlow找到这样和这样的答案，但我们不要这么麻烦。\n进入这个网站,下载openCV相关whl文件，例如opencv_python-3.1.0-cp35-none-win_amd64.whl\n然后再对应目录下使用pip install opencv_python-3.1.0-cp35-none-win_amd64.whl命令即可\n安装完成后，可以在python的命令行下测试。\nimport cv2\n如果没有报错的话，恭喜你安装成功。\n不过无论是哪个版本的用户，在python上使用openCV都需要先安装numpy这个模块。\nnumpy\n人脸识别的原理\nopencv的人脸识别是基于了haar特征,关于什么叫haar特征，足以开另外一篇文章说明了，碍于篇幅，这里不做介绍。opencv提供已经训练好的数据写成了xml文件，放在了opencv\\sources\\data\\haarcascades的目录下。\n如果只是安装了opencv_python-3.1.0-cp35-none-win_amd64.whl的，可以在我的github上，下载cvdata里面的内容，地址会在文章底部给出。\n除了人脸识别的数据外，还有人眼，上半身，下半身……等人体特征的数据，观察xml文件的命名，不难见名知义。\n接下来会介绍如何利用这个已经训练好的数据，如果仍对haar模型感兴趣，可以参考以下地址。\nzouxy09的专栏\n如何使用训练好的数据\n先讲关于openCV基本的一些操作。全部具体代码，请查看我的github。\n读入一张图片\ncv2.imread(path)\n如果你用type()把其返回值的类型是numpy.ndarray。\n而同样，numpy.asarray(Image)返回的亦是numpy.ndarray对象，为什么强调这两点？\n\ncv2.imread(path)不能读取中文路径，若路径中含有中文字符，其会返回None\n在后面的操作中，包括是切割图片(人脸部分)，再进行局部哈希，比较相似度，等等都是用Image对象进行操作，如果再用Image.open()读入图片未免显得麻烦。\n\n所以干脆统一用Image.open()打开图片，再用numpy.asarray(Image)转化即可。\n需要注意有一个不同的地方是虽然其返回的也是三维数组，但在第三维，即某个坐标下的RGB值,两个矩阵的顺序是反的，但只要另外编写一个小函数将其反转即可。\n载入xml数据\nface_cascade = cv2.CascadeClassifier(xml_path)\n将图片灰度化\n if img.ndim == 3:\n    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n else:\n    gray = img \n\n# 如果img维度为3，说明不是灰度图，先转化为灰度图gray，如果不为3，也就是2，原图就是灰度图\nimg是之前读入的三维数组，虽然灰度图可以用Image对象的convert('L')完成，但由于不确定opencv的处理方法是否和该方法一样，所以还是用opencv自己的方法进行处理比较好。\n获取人脸坐标\n\nfaces = face_cascade.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=3, \nminSize=(10,10),flags=cv2.CASCADE_SCALE_IMAGE)\n\n\nscale_factor：被检测对象的尺度变化。尺度越大，越容易漏掉检测的对象，但检测速度加快；尺度越小，检测越细致准确，但检测速度变慢。\nmin_neighbors：数值越大，检测到对象的条件越苛刻；反之检测到对象的条件越宽松；\nminSize:检测对象的大小\n\n该方法返回的是一个列表，每个列表元素是长度为四的元组，分别脸部的左上角的x,y值，脸部区域的宽度和高度。\n下一步操作\n通过上述的方法，我们就已经获取到人脸的位置，下一步你可以通过ImageDraw`对象进行绘图，框出人脸的位置。\n同样，你也可以使用Image的crop方法把人脸部分提取出来，然后进行局部哈希，通过上一篇文章提及的算法，比较两者的相似度。\n两种操作分别在我的github中实现了，请参考我的github中face1.py,和face2.py两个python文件。\n写一只具有识别能力的图片爬虫\n在上一篇文章中，我说了会应用这些算法做成以只具有识别能力的图片爬虫，然现在我也确实是在做但考虑到作为核心的图片识别和人脸识别的部分我已经写成文章分享出来，其余部分就是想写其他爬虫一样而已，所以我决定看看这两篇文章的反响后再决定是否继续该系列，把图片爬虫的制作过程和大家分享一下。\n总结\n鉴于个人实力有限，本文未能详细说明人脸识别的原理，但总结了如何利用已经训练好的数据进行人脸识别，希望能帮到有需要的朋友。\n如有不足之处，欢迎提出。\n本文涉及内容的详细代码在下面的github地址。\n我的github仓库\n欢迎star，也欢迎给意见\n本文参考文章\nwphh的博客\n\n                ", "mainLikeNum": ["6 "], "mainBookmarkNum": "40"}