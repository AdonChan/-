{"title": "leetcode-124-Binary Tree Maximum Path Sum - 个人文章 ", "index": "python", "content": "\n题目描述：\nGiven a binary tree, find the maximum path sum.\n\nFor this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child\nconnections. The path must contain at least one node and does not needto go through the root.\n举例：\nGiven the below binary tree,\n\n   1\n  / \\\n 2   3\nReturn 6.\n\n题目分析： 找从任意节点出发的任意路径的最大长度。  每个node都有可能是其他路径上的node，这种情况要max(left，right)。如此循环。  每个node都有可能作为中心node，此时要max(左侧之前的路径最长长度，左侧之前的路径最长长度，此node为中心时候的长度)\n将这个分析单元递归封装，即可实现目标。\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def dfs(self,node):\n        ls = rs = None\n        lmv = rmv = 0\n        if node.left:\n            lmv,ls=self.dfs(node.left)\n            lmv=max(lmv,0)\n        if node.right:\n            rmv,rs=self.dfs(node.right)\n            rmv=max(rmv,0)\n        # print(lmv,rmv,ls,rs)\n        mv=node.val+max(lmv,rmv)\n        sv=node.val+lmv+rmv\n        # mv=node.val\n        trans_list=[elem for elem in [sv,ls,rs] if elem]\n        if not trans_list:\n            trans_list=[0]\n        return mv,max(trans_list)\n\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return\n        mv,smv=self.dfs(root)\n        return max(mv,smv)\n\nif __name__=='__main__':\n    tn=TreeNode(2)\n    tn1=TreeNode(-1)\n    tn2=TreeNode(-2)\n    tn.left=tn1\n    tn.right=tn2\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}