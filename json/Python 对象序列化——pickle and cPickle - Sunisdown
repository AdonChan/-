{"title": "Python 对象序列化——pickle and cPickle - Sunisdown ", "index": "cpickle,pickle,python", "content": "Python 对象序列化——pickle and cPickle\n\n\n从这篇文章粗略翻译的pickle and cPickle\n\npickle模块可以实现任意的Python对象转换为一系列字节(即序列化对象)的算法。这些字节流可以 被传输或存储,接着也可以重构为一个和原先对象具有相同特征的新对象。\n\ncPickle模块实现了同样的算法,但它是用c而不是python。因此,它比python实现的快上好几倍, 但是不允许使用者去继承Pickle。如果继承对于你的使用不是很重要,那么你大可以使用cPickle。\n\n\n  Woring: pickle的文档明确的表明它不提供安全保证。所以慎用pickle来作为内部进程通信或者数\n  据存储,也不要相信那些你不能验证安全性的数据。\n\n\n\nImporting\n\n\n通常优先试用 cPickle，只有当 cPickle 无法正常 import 的时候，采用 pickle 来替代。\n\ntry:\n   import cPickle as pickle\nexcept:\n   import pickle\n\n\nEncoding and Decoding Data in Strings\n\n\n第一个示例是将数据结构编码为字符串，然后输出到控制台。例子中数据结构完全由基本类型组成。pickle 可以编码任意类的实例，就像下面栗子中演示的那样：用 pickle.dumps() 来创建对象的字符串表示。\n\ntry:\n    import cPickle as pickle\nexcept:\n    import pickle\nimport pprint\n\ndata = [ { 'a':'A', 'b':2, 'c':3.0 } ]\nprint 'DATA:',\npprint.pprint(data)\n\ndata_string = pickle.dumps(data)\nprint 'PICKLE:', data_string\n\n\npickle 默认试用 ASSCII 字符串来进行编码解码。也支持效率更高的二进制格式，但是下面的例子为了方便阅读,还是使用了 ASSCII 码。\n\n$ python pickle_string.py\n\nDATA:[{'a': 'A', 'b': 2, 'c': 3.0}]\nPICKLE: (lp1\n(dp2\nS'a'\nS'A'\nsS'c'\nF3\nsS'b'\nI2\nsa.\n\n\n数据被序列化之后，你就可以将他写入文件、socket、pipe、etc.然后你可以读取文件并unpickle 这些数据来构造一个新的对象。\n\ntry:\n    import cPickle as pickle\nexcept:\n    import pickle\nimport pprint\n\ndata1 = [ { 'a':'A', 'b':2, 'c':3.0 } ]\nprint 'BEFORE:',\npprint.pprint(data1)\n\ndata1_string = pickle.dumps(data1)\n\ndata2 = pickle.loads(data1_string)\nprint 'AFTER:',\npprint.pprint(data2)\n\nprint 'SAME?:', (data1 is data2)\nprint 'EQUAL?:', (data1 == data2)\n\n\n\n如同例子中演示的那样，新的对象与之前的对象相等，但是并不是同一个对象。\n\n$ python pickle_unpickle.py\n\nBEFORE:[{'a': 'A', 'b': 2, 'c': 3.0}]\nAFTER:[{'a': 'A', 'b': 2, 'c': 3.0}]\nSAME?: False\nEQUAL?: True\n\n\nWorking with Streams\n\n\n除了 dumps() 跟 loads(), pickle 还有其他比较方便的方法来操作类文件流。可以同时写入多个对象到一个 stream 中，然后对象数量与大小的时候从 stream 读取他们。\n\ntry:\n    import cPickle as pickle\nexcept:\n    import pickle\nimport pprint\nfrom StringIO import StringIO\n\nclass SimpleObject(object):\n\n    def __init__(self, name):\n        self.name = name\n        l = list(name)\n        l.reverse()\n        self.name_backwards = ''.join(l)\n        return\n\ndata = []\ndata.append(SimpleObject('pickle'))\ndata.append(SimpleObject('cPickle'))\ndata.append(SimpleObject('last'))\n\n# Simulate a file with StringIO\nout_s = StringIO()\n\n# Write to the stream\nfor o in data:\n    print 'WRITING: %s (%s)' % (o.name, o.name_backwards)\n    pickle.dump(o, out_s)\n    out_s.flush()\n\n# Set up a read-able stream\nin_s = StringIO(out_s.getvalue())\n\n# Read the data\nwhile True:\n    try:\n        o = pickle.load(in_s)\n    except EOFError:\n        break\n    else:\n        print 'READ: %s (%s)' % (o.name, o.name_backwards)\n\n\n上面例子中使用了 StringIO 缓冲区来模拟streams，这样我们在建立可读流的时候可以玩一些技巧。一些接单的数据库格式也可以使用 pickles 来存储数据，当然，如果试用 shelve 来存储会更加简单。\n\n$ python pickle_stream.py\n\nWRITING: pickle (elkcip)\nWRITING: cPickle (elkciPc)\nWRITING: last (tsal)\nREAD: pickle (elkcip)\nREAD: cPickle (elkciPc)\nREAD: last (tsal)\n\n\n除了存储数据，pickles 用来做内部通信的机会也很多。举个例子：用 os.fork() 和 os.pipe() 可以建立一个工作进程，然后这个进程会从管道中读取数据并把结果传递给另外一个管道。因为这些代码是用来管理worker pool 跟 发送任务跟接受任务的，没有什么特殊的内容，所以这些核心代码可以被拿来重复利用。如果你在试用 pipe 或者 sockets，那么在 dumping完对象之后，不要忘记刷新它们并通过其间的连接将数据推送到另外一个进程。如果你不想自己写 worker pool manager 的话，可以看一下multiprocessing。\n\nProblems Reconstructing Objects\n\n\n需要注意的是，在序列化实例的时候，我们只是对于数据来进行序列化，而无法对类的定义进行序列化。\n下面的栗子：\n\ntry:\n    import cPickle as pickle\nexcept:\n    import pickle\nimport sys\n\nclass SimpleObject(object):\n\n    def __init__(self, name):\n        self.name = name\n        l = list(name)\n        l.reverse()\n        self.name_backwards = ''.join(l)\n        return\n\nif __name__ == '__main__':\n    data = []\n    data.append(SimpleObject('pickle'))\n    data.append(SimpleObject('cPickle'))\n    data.append(SimpleObject('last'))\n\n    try:\n        filename = sys.argv[1]\n    except IndexError:\n        raise RuntimeError('Please specify a filename as an argument to %s' % sys.argv[0])\n\n    out_s = open(filename, 'wb')\n    try:\n        # Write to the stream\n        for o in data:\n            print 'WRITING: %s (%s)' % (o.name, o.name_backwards)\n            pickle.dump(o, out_s)\n    finally:\n        out_s.close()\n\n\n运行的时候，这个脚本会以命令行中给出的参数创建一个文件。\n\n$ python pickle_dump_to_file_1.py test.dat\n\nWRITING: pickle (elkcip)\nWRITING: cPickle (elkciPc)\nWRITING: last (tsal)\n\n\n下面是一个会报错的栗子：\n\ntry:\n    import cPickle as pickle\nexcept:\n    import pickle\nimport pprint\nfrom StringIO import StringIO\nimport sys\n\n\ntry:\n    filename = sys.argv[1]\nexcept IndexError:\n    raise RuntimeError('Please specify a filename as an argument to %s' % sys.argv[0])\n\nin_s = open(filename, 'rb')\ntry:\n    # Read the data\n    while True:\n        try:\n            o = pickle.load(in_s)\n        except EOFError:\n            break\n        else:\n            print 'READ: %s (%s)' % (o.name, o.name_backwards)\nfinally:\n    in_s.close()\n\n\n这个报错是因为没有SimpleObject类。\n\n$ python pickle_load_from_file_1.py test.dat\n\nTraceback (most recent call last):\n  File \"pickle_load_from_file_1.py\", line 52, in <module>\n    o = pickle.load(in_s)\nAttributeError: 'module' object has no attribute 'SimpleObject'\n\n\n我们通过从原来的脚本中import SimpleObject来修正上面的错误。\n在上面文件中的增加下面一行:\n\nfrom pickle_dump_to_file_1 import SimpleObject\n\n\n$ python pickle_load_from_file_2.py test.dat\n\nREAD: pickle (elkcip)\nREAD: cPickle (elkciPc)\nREAD: last (tsal)\n\n\n像sockets, file handles, database connections ...这些数据类型是无法被序列化的，我们在处理类似数据类型的时候不得不特殊处理。而利用pickle protocol 则可以控制序列化的细节。\n\nclass Data(object):\n    def __init__(self, x, y):\n        self._x = x\n        self._y = y\n\n    def __getstate__(self):\n        d = self.__dict__.copy()\n        del d[\"_y\"]\n        return d\n    def __setstate__(self, state):\n        self.__dict__.update(state)\nd = Data(10, 20)\ns = cPickle.dumps(d, 2)\nd2 = cPickle.loads(s)\n##d2.__dict__\n##{'_x': 10}\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}