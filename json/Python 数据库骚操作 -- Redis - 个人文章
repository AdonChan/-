{"title": "Python 数据库骚操作 -- Redis - 个人文章 ", "index": "redis,python", "content": "目录\n\n前言\nRedis GUI 工具\nRedis 遇上 Docker\nRedis string\nRedis hash\nRedis list\nRedis set\nRedis zset\n后记\n\n前言\n前面一篇文章介绍了 MongoDB 的库，我把 MySQL 放在了最后面，这篇文章继续介绍 Redis 的操作。Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。接下来会简单介绍一下，Python 与 Redis 的化学反应。\nRedis GUI 工具\n首先介绍一款 Redis 的 GUI 工具 Medis，初学 Redis 用这个来查看数据真的很爽。可以即时看到数据的增删改查，不用操作命令行来查看。\n\n## Redis 遇上 Docker关注我的人都知道，我的简介上面写着我的公众号会涉及 Docker 相关的知识，但最近的文章也没怎么涉及，所以后面的文章中，能跟 Docker 扯上关系的，我都会粗略地说一下。这里主要贴一贴配置代码，docker-compose 代码如下。\nversion: '3'\nservices:\n  redis_container:\n    image: redis\n    command: redis-server --requirepass yourpassword # 配置 Redis 密码\n    ports:\n      - \"6378:6379\" # 映射端口\n    volumes:\n      - /your/path/data:/data \n启动命令\ndocker-compose up -d\nRedis string\ninstall\npip install redis\n连接\n# 普通连接\nr = redis.StrictRedis(host='localhost', port=6379, db=0)\nr = redis.StrictRedis(host='localhost', port=6379, password=\"your password\", db=0)\n\n# 连接池\n\"\"\"\nredis-py 使用 connection pool 来管理对一个 redis server 的所有连接，避免每次建立、释放连接的开销。默认，每个Redis实例都会维护一个自己的连接池，这样就可以实现多个 Redis 实例共享一个连接池\n\"\"\"\n# host 是 redis 服务 ip，默认端口是6379\npool = redis.ConnectionPool(host='localhost', port=6379,decode_responses=True)  \nr = redis.Redis(connection_pool=pool)\n增加\nset(name, value, ex=None, px=None, nx=False, xx=False)\n\n在Redis中设置值，默认，不存在则创建，存在则修改\n参数：\nex，过期时间（秒）\npx，过期时间（毫秒）\nnx，如果设置为True，则只有name不存在时，当前set操作才执行\nxx，如果设置为True，则只有name存在时，当前set操作才执行\n# 设置过期时间为 1 秒\nr.set('foo', 'zone', ex=1)\n# 效果同上\nr.setex('foo', 'zone', 1)\n# 效果同上\nr.psetex('foo', 1000, 'zone')\n\nprint(r.get('foo'))\n\n# 休眠两秒后，再打印输出\ntime.sleep(2)\nprint(r.get('foo'))\n查找\nget(key)\n普通查找\nprint(r.get('foo'))\nmget(keys, *args)\n批量查找\n# 批量获取\nprint(r.mget(\"k1\", \"k2\"))  # 一次取出多个键对应的值\nprint(r.mget(\"k1\"))\n获取子序列\ngetrange(key, start, end)\n获取子序列（根据字节获取，非字符）\n参数：\nname，Redis 的 name\nstart，起始位置（字节）\nend，结束位置（字节）\n# 一个汉字3个字节 1个字母一个字节\nr.set(\"name\", \"zonezone\")\nprint(r.getrange('name', 0, 3))\n# 获取所有字节\nprint(r.getrange('name', 0, -1))\n\n\n修改\n原始值 zonezone ，修改后变为 zone is a boy\nsetrange(name, offset, value)\n修改字符串内容，从指定字符串索引开始向后替换（新值太长时，则向后添加）\n参数：\noffset，字符串的索引，字节（一个汉字三个字节）\nvalue，要设置的值\nr.set(\"name\", \"zonezone\")\nr.setrange(\"name\", 4, \" is a boy\")\nprint(r.get(\"name\")) \n\n返回相应 key 的字符串长度\nr.set(\"name\", \"zonezone\")\nprint(r.strlen(\"name\"))\n自增 name 对应的值(int)\nincr(self, name, amount=1)\n自增 name对应的值，当name不存在时，则创建name＝amount，否则，则自增。\n参数：\nname,Redis的name\namount,自增数（必须是整数）\nr.set(\"age\", 123)\nprint(r.get(\"age\"))\nr.incr(\"age\", amount=1)\nprint(r.get(\"age\"))\n\n自增 name 对应的值(float)\nincrbyfloat(self, name, amount=1.0)\n自增 name对应的值，当name不存在时，则创建name＝amount，否则，则自增。\n参数：\nname,Redis的name\namount,自增数（浮点型）\nr.set(\"age\", 123.0)\nprint(r.get(\"age\"))\nr.incrbyfloat(\"age\", amount=0.2)\nprint(r.get(\"age\"))\n\n\n自减 name 对应的值\nr.set(\"age\", 123)\nr.decr(\"age\", amount=1) # 递减1\nprint(r.mget(\"foo1\", \"foo4\"))\n追加内容\nappend(key, value)\n在redis name对应的值后面追加内容\n参数：\nkey, redis的name\nvalue, 要追加的字符串\nr.set(\"name\", \"关注 \")\nprint(r.get(\"name\"))\nr.append(\"name\",\"公众号【zone7】\")\nprint(r.get(\"name\"))\n\nRedis hash\nhash\nhset(name, key, value)\nname对应的hash中设置一个键值对（不存在，则创建；否则，修改）\n参数：\nname，redis的name\nkey，name对应的hash中的key\nvalue，name对应的hash中的value\n注：\nhsetnx(name, key, value),当name对应的hash中不存在当前key时则创建（相当于添加）\nr.hset(\"hash1\", \"k1\", \"v1\")\nr.hset(\"hash1\", \"k2\", \"v2\")\n# 取hash中所有的key\nprint(r.hkeys(\"hash1\")) \n# 单个取hash的key对应的值\nprint(r.hget(\"hash1\", \"k1\"))    \n# 多个取hash的key对应的值\nprint(r.hmget(\"hash1\", \"k1\", \"k2\")) \nr.hsetnx(\"hash1\", \"k2\", \"v3\")\nprint(r.hget(\"hash1\", \"k2\"))\n\n批量增加与批量获取\n# 批量增加\nr.hmset(\"hash2\", {\"k1\": \"v1\", \"k2\": \"v2\"})\n# 批量获取\nprint(r.hmget(\"hash2\", \"k1\", \"k2\"))\n\n去除所有 hash 键值对\nprint(r.hgetall(\"hash1\"))\n获取 hash长度\nhlen(name)\n获取name对应的hash中键值对的个数\nprint(r.hlen(\"hash1\"))\n获取所有的keys（类似字典的取所有keys）\nhkeys(name)\n获取name对应的hash中所有的key的值\nprint(r.hkeys(\"hash1\"))\n获取所有的value（类似字典的取所有value）\nhvals(name)\n获取name对应的hash中所有的value的值\nprint(r.hvals(\"hash1\"))\n判断成员是否存在（类似字典的in）\nhexists(name, key)\n检查name对应的hash是否存在当前传入的key\nprint(r.hexists(\"hash1\", \"k1\")) \n删除键值对\nhdel(name,*keys)\n将name对应的hash中指定key的键值对删除\nr.hset(\"hash1\", \"name\", \"zone\")\nprint(r.hget(\"hash1\", \"name\"))\nr.hdel(\"hash1\", \"name\")\nprint(r.hget(\"hash1\", \"name\"))\n\n自增自减(int)\nhincrby(name, key, amount=1)\n自增name对应的hash中的指定key的值，不存在则创建key=amount\n参数：\nname，redis中的name\nkey， hash对应的key\namount，自增数（整数）\nr.hset(\"hash1\", \"age\", 123)\nr.hincrby(\"hash1\", \"age\", amount=-1)\nprint(r.hget(\"hash1\", \"age\"))\nr.hincrby(\"hash1\", \"age\", amount=1)  # 不存在的话，value默认就是1\nprint(r.hget(\"hash1\", \"age\"))\n\n自增自减(float)\nhincrbyfloat(name, key, amount=1.0)\n自增name对应的hash中的指定key的值，不存在则创建key=amount\n参数：\nname，redis中的name\nkey， hash对应的key\namount，自增数（浮点数）\n自增name对应的hash中的指定key的值，不存在则创建key=amount\nr.hset(\"hash1\", \"age\", 123.0)\nr.hincrbyfloat(\"hash1\", \"age\", amount=-0.3)\nprint(r.hget(\"hash1\", \"age\"))\nr.hincrbyfloat(\"hash1\", \"age\", amount=0.5)  # 不存在的话，value默认就是1\nprint(r.hget(\"hash1\", \"age\"))\nRedis list\n增加(不存在会自动创建)\nlpush(name,values)\n在name对应的list中添加元素，每个新的元素都添加到列表的最左边\nrpush(name,values)\n在name对应的list中添加元素，每个新的元素都添加到列表的最右边\nr.lpush(\"left_list\", 11, 22, 33)\nprint(r.lrange('left_list', 0, -1))\n\nr.rpush(\"right_list\", 11, 22, 33)\nprint(r.lrange(\"right_list\", 0, 3))\n\nprint(r.llen(\"right_list\"))  # 列表长度\n\n添加(不存在不会自动创建)\nlpushx(name,value)\n在name对应的list中添加元素，只有name已经存在时，值添加到列表的最左边。不存在时，不会自动创建。\nr.lpushx(\"left_list\", 2222)\nprint(r.lrange('left_list', 0, -1))\n\nr.rpushx(\"right_list\", 1111)\nprint(r.lrange('right_list', 0, -1))\n\n新增\n新增（固定索引号位置插入元素）\nlinsert(name, where, refvalue, value))\n在name对应的列表的某一个值前或后插入一个新值\n参数：\nname，redis的name\nwhere，BEFORE或AFTER\nrefvalue，标杆值，即：在它前后插入数据\nvalue，要插入的数据\n# 往列表中左边第一个出现的元素\"11\"前插入元素\"00\"\nr.linsert(\"left_list\", \"before\", \"11\", \"00\") \nprint(r.lrange(\"left_list\", 0, -1))\n\n修改\n修改（指定索引号进行修改）\nr.lset(name, index, value)\n对name对应的list中的某一个索引位置重新赋值\n参数：\nname，redis的name\nindex，list的索引位置\nvalue，要设置的值\nr.lset(\"left_list\", 0, \"关注公众号【zone7】\")    # 把索引号是0的元素修改成 关注公众号【zone7】\nprint(r.lrange(\"left_list\", 0, -1))\n\n删除\n删除（指定值进行删除）\nr.lrem(name, value, num)\n在name对应的list中删除指定的值\n参数：\nname，redis的name\nvalue，要删除的值\nnum， num=0，删除列表中所有的指定值；\nnum=2,从前到后，删除2个； num=1,从前到后，删除左边第1个\nnum=-2,从后向前，删除2个\n# 将列表中左边第一次出现的\"33\"删除\nr.lrem(\"left_list\", \"33\", 1)   \nprint(r.lrange(\"left_list\", 0, -1))\n\n删除并返回\nlpop(name)\n在 name 对应的列表的左边获取第一个元素并在列表中移除，返回值则是第一个元素\nrpop(name)\n在 name 对应的列表的右边获取第一个元素并在列表中移除，返回值则是第一个元素\nprint(r.lpop(\"left_list\"))\nprint(r.lrange(\"list2\", 0, -1))\nRedis set\n增加\nsadd(name,values)\n添加元素\nr.sadd(\"set1\", 1, 2, 3, 4)\n# 获取集合长度\nprint(r.scard(\"set1\"))  \n# 获取集合中所有元素\nprint(r.smembers(\"set1\")) \n\n删除\n# 普通删除\nsrem(name, values)\n在name对应的集合中删除某些值\n # 从集合中删除指定值 1\nprint(r.srem(\"set1\", 1))  \nprint(r.smembers(\"set1\"))\n\n# 随机删除并返回被删除值\nspop(name)\n从集合移除一个成员，并将其返回,说明一下，集合是无序的，所有是随机删除的\nprint(r.spop(\"set2\"))   # 这个删除的值是随机删除的，集合是无序的\nprint(r.smembers(\"set2\"))\n查找\n# 普通获取\nsmembers(name)\n获取name对应的集合的所有成员\nprint(r.smembers(\"set1\"))   # 获取集合中所有的成员\n# 以元组形式获取集合\nsscan(name, cursor=0, match=None, count=None)\nprint(r.sscan(\"set1\"))\n# 以迭代器的方式获取集合\nsscan_iter(name, match=None, count=None)\n同字符串的操作，用于增量迭代分批获取元素，避免内存消耗太大\nfor i in r.sscan_iter(\"set1\"):\n    print(i)\n交集\nsinter(keys, *args)\n获取多个 name 对应集合的交集\nr.sadd(\"set2\", 1, 2, 3, 4)\nr.sadd(\"set3\", 3, 4, 5, 6)\nprint(r.sinter(\"set2\", \"set3\"))\n\nsinterstore(dest, keys, *args)\n获取多个 name 对应集合的并集，再将并集加入到 dest(目标集合) 中\nr.sadd(\"set2\", 1, 2, 3, 4)\nr.sadd(\"set3\", 3, 4, 5, 6)\nprint(r.sinterstore(\"set4\", \"set2\", \"set3\"))\nprint(r.smembers(\"set4\"))\n\n移动\nsmove(src, dst, value)\n将某个成员从一个集合中移动到另外一个集合\nr.smove(\"set2\", \"set3\", 3)\nprint(r.smembers(\"set2\"))\nprint(r.smembers(\"set3\"))\n\n判断集合中是否有某元素\nsismember(name, value)\n检查value是否是name对应的集合的成员，结果为True和False\nprint(r.sismember(\"set2\", 3))\nprint(r.sismember(\"set3\", 1))\n并集\nsunion(keys, *args)\n获取多个name对应的集合的并集\nr.sadd(\"set2\", 1, 2, 3, 4)\nr.sadd(\"set3\", 3, 4, 5, 6)\nprint(r.sunion(\"set2\", \"set3\"))\n\n并集--并集存在一个新的集合\nsunionstore(dest,keys, *args)\n获取多个name对应的集合的并集，并将结果保存到dest对应的集合中\nr.sadd(\"set2\", 1, 2, 3, 4)\nr.sadd(\"set3\", 3, 4, 5, 6)\nprint(r.sunionstore(\"set4\", \"set2\", \"set3\")) # 取2个集合的并集\nprint(r.smembers(\"set4\"))\n\nRedis zset\nset 就是无序，不允许重复的列表\n增加\nzadd(name, *args, **kwargs)\n在name对应的有序集合中添加元素\nr.zadd(\"zset1\", n1=123, n2=234)\nprint(r.zrange(\"zset1\", 0, -1))   # 获取有序集合中所有元素\n# 效果同上\nr.zadd(\"zset1\", 'n1', 123, 'n2', 234)\n\n删除\nzrem(name, values)\n删除name对应的有序集合中值是values的成员\n# 删除 n2\nr.zrem(\"zset2\", \"n2\")\nprint(r.zrange(\"zset2\", 0, -1))\n\nzremrangebyrank(name, min, max)\n根据索引删除\n# 根据索引删除\nr.zremrangebyrank(\"zset2\", 0, 1)\nprint(r.zrange(\"zset2\", 0, -1))\n\n查\nzscore(name, value)\n获取name对应有序集合中 value 对应的分数\n# 查找 n5 的值\nprint(r.zscore(\"zset2\", \"n5\"))\n\n获取 set 的长度\nprint(r.zcard(\"zset1\")) \n获取有序集合的所有元素\nr.zrange( name, start, end, desc=False, withscores=False, score_cast_func=float)\n按照索引范围获取name对应的有序集合的元素\n参数：\nname，redis的name\nstart，有序集合索引起始位置（非分数）\nend，有序集合索引结束位置（非分数）\ndesc，排序规则，默认按照分数从小到大排序\nwithscores，是否获取元素的分数，默认只获取元素的值\nscore_cast_func，对分数进行数据转换的函数\n从大到小排序(同zrange，集合是从大到小排序的)\nzrevrange(name, start, end, withscores=False, score_cast_func=float)\n# 只获取元素，不显示分数\nprint(r.zrevrange(\"zset1\", 0, -1))    \n# 获取有序集合中所有元素和分数,分数倒序\nprint(r.zrevrange(\"zset1\", 0, -1, withscores=True))\n\n统计范围内元素个数\nzcount(name, min, max)\n获取name对应的有序集合中分数 在 [min,max] 之间的个数\nfor i in range(1, 30):\n    key = 'n' + str(i)\n    r.zadd(\"zset2\", key, i)\nprint(r.zrange(\"zset2\", 0, -1, withscores=True))\nprint(r.zcount(\"zset2\", 1, 9))\n\n自增\nzincrby(name, value, amount)\n自增name对应的有序集合的 name 对应的分数\n# 每次将n1的分数自增5\nr.zincrby(\"zset2\", \"n2\", amount=5)\nprint(r.zrange(\"zset2\", 0, -1, withscores=True))\n\n获取值的索引号\nzrank(name, value)\n获取某个值在 name对应的有序集合中的索引（从 0 开始）\n# 获取 n2 的索引号\nprint(r.zrank(\"zset2\", \"n2\"))\n后记\n在微信公众号后台回复「Redis」获取源码。Redis 的骚操作就介绍到这里，后面会继续写 MySQL 的骚操作。尽请期待。\n本文首发于公众号「zone7」，关注获取最新推文！\n\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "2"}