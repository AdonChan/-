{"title": "tornado源码解析之IOLoop - 如风的部落格 ", "index": "web,epoll,tornado,python", "content": "0. 简介\ntornado是一个用Python语言写成的Web服务器兼Web应用框架，由FriendFeed公司在自己的网站FriendFeed中使用，被Facebook收购以后框架以开源软件形式开放给大众。\ntornado最大的特点就是其支持异步IO，所以它有着优异的性能。下表是和一些其他Web框架与服务器的对比:(处理器为 AMD Opteron, 主频2.4GHz, 4核) (来源wikipedia)\n\n\n服务\n部署\n请求/每秒\n\n\n\nTornado\nnginx, 4进程\n8213\n\n\nTornado\n1个单线程进程\n3353\n\n\nDjango\nApache/mod_wsgi\n2223\n\n\nweb.py\nApache/mod_wsgi\n2066\n\n\nCherryPy\n独立\n785\n\n\n\n先来看看hello world的例子。^_^\nimport tornado.httpserver\nimport tornado.ioloop\nimport tornado.options\nimport tornado.web\n\nfrom tornado.options import define, options\n\ndefine(\"port\", default=8888, help=\"run on the given port\", type=int)\n\n\nclass MainHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.write(\"Hello, world\")\n\n\ndef main():\n    tornado.options.parse_command_line()\n    application = tornado.web.Application([\n        (r\"/\", MainHandler),\n    ])\n    http_server = tornado.httpserver.HTTPServer(application)\n    http_server.listen(options.port)\n    tornado.ioloop.IOLoop.current().start()\n\n\nif __name__ == \"__main__\":\n    main()\n\n运行：\n$ python3 helloworld.py\n我们就得到一个web server监听在8888端口。用curl命令get一下，就返回了\"Hello, world\"。\ntornado的代码结构可以在其官网了解，本文着重分析IOLoop的实现。\n1. IOLoop\n1.1 http交互的大致过程\n介绍IOLoop之前我们先看看http server和http client交互的一个大致过程。\n\nserver端监听在某个端口，client端发送请求过来，server处理后返回，然后继续等待下一个请求，周而复始。如果用socket那一坨来描述的话就是：\n1. server.py\n================================================================\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.bind(address)\ns.listen(backlog)\nWhile True:\n    connection = s.accept()\n    do_something()\n    connection.send()\n    connection.close()\n    \n2. client.py\n=================================================================\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.connect()\ns.send()\ns.recv()\ns.close()\n1.2 聊聊阻塞与非阻塞\n所谓阻塞，就是进程正在等待某些资源（如IO），而处于等待运行的状态（不占用CPU资源）。比如connect((\"google.com\", 80))返回之前进程都是阻塞的，在它下面的语句得不到执行，除非connect返回。\n很显然阻塞式的IO模型有个缺点就是并发量不大，试想如果server进程在do_something()处阻塞，而这时另外有个客户端试图连进来，则可能得不到响应。\n提高并发量有几种实现方式：多线程（一个连接fork一个线程去处理）；多进程（一个连接fork一个子进程去处理）(apache)；事件驱动(nginx, epoll)等。tornado就是基于epoll(Linux)事件驱动模型实现的。\n当然它们有各自的优缺点，此文不详述，有兴趣的读者可以自行google之。^_^\n关于IO模型，epoll, 同步，异步，阻塞，非阻塞的概念，可以参考这两篇文章：https://segmentfault.com/a/11...\nhttp://blog.csdn.net/historya...\n1.3 IOLoop实现\n1.3.1 IOLoop配置\n前文说到tornado是基于epoll事件驱动模型，也不完全正确，tornado实际上是根据平台选择底层驱动。请看IOLoop类的configurable_default方法：\n    @classmethod\n    def configurable_default(cls):\n        if hasattr(select, \"epoll\"):\n            from tornado.platform.epoll import EPollIOLoop\n            return EPollIOLoop\n        if hasattr(select, \"kqueue\"):\n            # Python 2.6+ on BSD or Mac\n            from tornado.platform.kqueue import KQueueIOLoop\n            return KQueueIOLoop\n        from tornado.platform.select import SelectIOLoop\n        return SelectIOLoop\n这里的IOLoop实际上是个通用接口，根据不同平台选择：linux->epoll，BSD->kqueue，如果epoll和kqueue都不支持则选择select(性能要差些)。\nclass IOLoop(Configurable):IOLoop继承了Configurable类，Configurable类的__new__方法调用了configured_class方法：\n    def __new__(cls, *args, **kwargs):\n        base = cls.configurable_base()\n        init_kwargs = {}\n        if cls is base:\n            impl = cls.configured_class()\n            if base.__impl_kwargs:\n                init_kwargs.update(base.__impl_kwargs)\n        else:\n            impl = cls\n        init_kwargs.update(kwargs)\n        instance = super(Configurable, cls).__new__(impl)\n        # initialize vs __init__ chosen for compatibility with AsyncHTTPClient\n        # singleton magic.  If we get rid of that we can switch to __init__\n        # here too.\n        instance.initialize(*args, **init_kwargs)\n        return instance\nconfigured_class方法又调用了configurable_default方法：\n    @classmethod\n    def configured_class(cls):\n        # type: () -> type\n        \"\"\"Returns the currently configured class.\"\"\"\n        base = cls.configurable_base()\n        if cls.__impl_class is None:\n            base.__impl_class = cls.configurable_default()\n        return base.__impl_class\n所以当初始化一个IOLoop实例的时候就给IOLoop做了配置，根据不同平台选择合适的驱动。\n1.3.2 IOLoop实例化\n下面我们来看IOLoop的实例化函数：\n    # Global lock for creating global IOLoop instance\n    _instance_lock = threading.Lock()\n    @staticmethod\n    def instance():\n        if not hasattr(IOLoop, \"_instance\"):\n            with IOLoop._instance_lock:\n                if not hasattr(IOLoop, \"_instance\"):\n                    # New instance after double check\n                    IOLoop._instance = IOLoop()\n        return IOLoop._instance\n很显然，这里是实现了一个全局的单例模式。确保多个线程也只有一个IOLoop实例。(思考一下：为什要double check？if not hasattr(IOLoop, \"_instance\") ^_^)\n1.3.3 实现epoll的接口(假设是在Linux平台)\n我们知道epoll支持3种操作：\nEPOLL_CTL_ADD    添加一个新的epoll事件\nEPOLL_CTL_DEL    删除一个epoll事件\nEPOLL_CTL_MOD    改变一个事件的监听方式\n分别对应tornado.IOLoop里面的三个函数：add_handler, remove_handler, update_handler\n下面看看这三个函数：\n    def add_handler(self, fd, handler, events):\n        fd, obj = self.split_fd(fd)\n        self._handlers[fd] = (obj, stack_context.wrap(handler))\n        self._impl.register(fd, events | self.ERROR)\n\n    def update_handler(self, fd, events):\n        fd, obj = self.split_fd(fd)\n        self._impl.modify(fd, events | self.ERROR)\n\n    def remove_handler(self, fd):\n        fd, obj = self.split_fd(fd)\n        self._handlers.pop(fd, None)\n        self._events.pop(fd, None)\n        try:\n            self._impl.unregister(fd)\n        except Exception:\n            gen_log.debug(\"Error deleting fd from IOLoop\", exc_info=True)\n这里的self._impl就是select.epoll()，使用方法可以参考epoll接口。\n1.3.4 事件驱动模型的大致思路\nIOLoop的start()方法用于启动事件循环（Event Loop）。\n(部分源码)\nwhile self._events:\n    fd, events = self._events.popitem()\n    try:\n        fd_obj, handler_func = self._handlers[fd]\n        handler_func(fd_obj, events)\n    except (OSError, IOError) as e:\n        if errno_from_exception(e) == errno.EPIPE:\n            # Happens when the client closes the connection\n            pass\n        else:\n            self.handle_callback_exception(self._handlers.get(fd))\n    except Exception:\n        self.handle_callback_exception(self._handlers.get(fd))\n大致的思路是：有连接进来（client端请求），就丢给epoll，顺便注册一个事件和一个回调函数，我们主线程还是继续监听请求；然后在事件循环中，如果发生了某种事件（如socket可读，或可写），则调用之前注册的回调函数去处理。这和Node.js的思路是一致的。\n1.3.5 关于cpu bound任务\ntornado很适合处理IO bound的任务，如果遇到cpu bound的任务，则还是会阻塞整个进程。这个时候就必须将耗时的任务丢到另一个worker，或者队列中去处理（如celery）。\n1.3.6 其他\nIOLoop类还有其他一些方法，多为辅助函数，读者可以自行参考，此处不详述。\n行文比较草率，如有错误和不足之处，敬请指正。\n下次继续分析tornado其他模块。^_^\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "10"}