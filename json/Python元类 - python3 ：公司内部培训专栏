{"title": "Python元类 - python3 ：公司内部培训专栏 ", "index": "python", "content": "Python元类\n上一篇文章：Python==与is对比下一篇文章：Python是动态语言：动态编辑属性、动态编辑方法本篇内容只供了解，实际上99%的python程序员都用不到元类哟，不过你要想成为那1%，请随意享用，别客气😆\n元类作用：拦截类的创建、修改类、返回修改之后的类\n\n万物皆对象，类创建了实例对象，那既然万物皆对象，类也是对象，那什么创建了类呢，啦啦啦，当然就是本篇的主人翁：元类。\n1、类也是对象\n既然类也是一个对象，那就应该具有对象共有的特性：可以将其赋给变量\n可以拷贝\n可以增加属性\n可以作为函数参数进行传递\n\n实例：\nclass A:\n    def hello_fun(self):\n        print(\"Hello World\")\n\ndef test(a):\n    print(\"类作为函数参数传递：\",a)\n\n#类也是对象，所以可以打印\nprint(A)\n\n#因为类也是对象，所以可以作为函数参数进行传递\ntest(A)\n\n#hasattr用来判断指定类中是有有对应属性\nprint(hasattr(A,\"mark\"))#哼，我就是一个属性，来打我呀\n\n#添加属性并且赋值\nA.mark=\"帅\"#mark是属性名称，帅是值\nprint(hasattr(A,\"mark\"))\nprint(\"mark属性值：\",A.mark)\n\n#因为类是一个对象，所以可以拷贝\nB=A#拷贝\nprint(B)\n运行结果：\n<class '__main__.A'>\n类作为函数参数传递： <class '__main__.A'>\nFalse\nTrue\nmark属性值： 帅\n<class '__main__.A'>\n2、动态（函数内部）创建类\n既然类也是对象，当然可以动态创建，比如在函数内部创建。\n实例：\ndef test():\n    class A:\n        def hello_fun(self):\n            print(\"Hello World\")\n    print(\"函数内部创建的类：\",A)\n\n\ntest()\n运行结果：\n函数内部创建的类： <class '__main__.test.<locals>.A'>\n3、type动态创建类\ntype函数除了可以检查类型外，另一个高大上的用途就是动态创建类。语法：type(类名,由父类名称组成的元组（可以为空）,包含属性的字典（名称和值）)\n\n实例：\n#定义一个没有方法，没有属性的类：A\nA=type(\"A\",(),{})\n\n#打印A\nprint(A)\n#打印A的实例\nprint(A())\n\nprint(\"*\"*30)\n\n#定义一个带两个属性的类：B\nB=type(\"B\",(),{\"name\":\"mark\",\"age\":18})\nprint(B.name)\nprint(B.age)\n\nprint(\"*\"*30)\n\n#定义一个带普通方法的类：C\ndef test_for_c(self):\n    print(self.name)\nC=type(\"C\",(),{\"name\":\"mark\",\"age\":18,\"test_for_c\":test_for_c})\nc=C()\nc.test_for_c()\n\nprint(\"*\"*30)\n\n#添加静态方法\n@staticmethod\ndef static_method_test():\n    print(\"static method test\")\nD=type(\"D\",(),{\"name\":\"mark\",\"age\":18,\"static_method_test\":static_method_test})\nD.static_method_test()\n\n\nprint(\"*\"*30)\n#添加类方法\n@classmethod\ndef class_method_test(cls):\n    print(cls.name)\nE=type(\"E\",(),{\"name\":\"mark\",\"age\":18,\"class_method_test\":class_method_test})\ne=E()\ne.class_method_test()\nE.class_method_test()\n\n\n\n\n结果：\n<class '__main__.A'>\n<__main__.A object at 0x10b7ac0f0>\n******************************\nmark\n18\n******************************\nmark\n******************************\nstatic method test\n******************************\nmark\nmark\n4、__metaclass__\n实例：\nclass A(object,metaclass=xxxx):\n    pass\n滴答滴答，想象一下，解析指针现在运行到这个类的上面，此处类还没加载到内存中，然后开始解析A，首先去A的定义中找，有没有指定__metaclass__属性，如果指定了，就利用这个指定的属性来创建类，没有指定就会用type开生成类。具体步骤如下：\n\n类中有这个__metaclass__属性吗，如果有，利用这个属性来创建类。\n如果类中不存在，判断父类是否存在，如果存在，就利用这个属性创建类。\n父类也没有，就去模块层次寻找这个属性，存在的话就利用这个属性创建类，\n如果还没有找到，就使用type来创建类。\n\n5、自定义元类（通过定义方法）\n现在自定义一个元类，保证所有的属性名都大写\n实例：\ndef upper_attr(class_name,class_parent,class_attr):\n    #遍历属性字典，把不是__开头的属性名称都编程大写\n    newAttr={}\n    for name,value in class_attr.items():\n        if not name.startswith(\"__\"):\n            newAttr[name.upper()]=value\n    #调用type来创建类\n    return type(class_name,class_parent,newAttr)\nclass A(object,metaclass=upper_attr):\n    mark=\"帅哥\"\n\nprint(hasattr(A,\"mark\"))\nprint(hasattr(A,\"MARK\"))\n\nprint(A.MARK)\n\n\n\n结果：\nFalse\nTrue\n帅哥\n6、自定义元类（通过继承type）\n现在自定义一个元类，保证所有的属性名都大写\n实例：\nclass UpperAttrMetaClass(type):\n    #__new__是在__init__之前被调用的特殊方法，用来创建对象并返回，\n    #而__init__只是将传递的参数赋给对象\n    def __new__(cls,class_name,class_parent,class_attr):\n        # 遍历属性字典，把不是__开头的属性名称都编程大写\n        newAttr = {}\n        for name, value in class_attr.items():\n            if not name.startswith(\"__\"):\n                newAttr[name.upper()] = value\n        # 方法1：调用type来创建类\n        #return type(class_name, class_parent, newAttr)\n\n        #方法2：复用type.__new__方法\n        #return type.__new__(cls,class_name,class_parent,newAttr)\n\n        #方法3：使用super方法\n        return super(UpperAttrMetaClass,cls).__new__(cls,class_name,class_parent,newAttr)\n\n\n\nclass A(object,metaclass=UpperAttrMetaClass):\n    mark=\"帅哥\"\n\nprint(hasattr(A,\"mark\"))\nprint(hasattr(A,\"MARK\"))\n\nprint(A.MARK)\n\n\n\n结果：\nFalse\nTrue\n帅哥\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "0"}