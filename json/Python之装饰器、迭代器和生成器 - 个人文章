{"title": "Python之装饰器、迭代器和生成器 - 个人文章 ", "index": "python", "content": "在学习python的时候，三大“名器”对没有其他语言编程经验的人来说，应该算是一个小难点，本次博客就博主自己对装饰器、迭代器和生成器理解进行解释。\n装饰器\n什么是装饰器？“装饰”从字面意思来谁就是对特定的建筑物内按照一定的思路和风格进行美化的一种行为，所谓“器”就是工具，对于python来说装饰器就是能够在不修改原始的代码情况下给其添加新的功能，比如一款软件上线之后，我们需要在不修改源代码和不修改被调用的方式的情况下还能为期添加新的功能，在python种就可以用装饰器来实现，同样在写代码的时候也要考虑到后面的可扩展性，下面我们来看一步一步的看一下python的装饰器。\n无参装饰器\n先来看简单的几行代码，代码的运行结果是先睡2秒，再打印\"hello boy!\"：\nimport time\ndef foo():\n     \"\"\"打印\"\"\"\n     time.sleep(2)\n     print(\"Hello boy!\")\nfoo()\n我们现在我们需要为其添加一个程序计时功能，但是不能修改原始的代码：\nimport time\ndef timmer(func):\n     def wrapper():\n          \"\"\"计时功能\"\"\"\n          time_start=time.time()\n          func()\n          time_end=time.time()\n          print(\"Run time is %f \"%(time_end-time_start))\n     return wrapper\ndef foo():\n     \"\"\"打印\"\"\"\n     time.sleep(2)\n     print(\"Hello boy!\")\nfoo = timmer(foo)\nfoo()\n运行结果Hello boy!Run time is 2.000446看！我们没有修改原来的代码就实现了这个功能，因为函数也是对象，所以能够将函数foo当做参数传递给了函数timmer。在python中，有个更简洁的方式来取代foo=timmer(foo)，使用@timmer这种方式，这个在python中被称为语法糖。\nimport time\ndef timmer(func):\n      def wrapper():\n          \"\"\"计时功能\"\"\"\n          time_start=time.time()\n          func()\n          time_end=time.time()\n          print(\"Run time is %f \"%(time_end-time_start))\n     return wrapper\n@timmer  #等于 foo=timmer(foo)\ndef foo():\n     \"\"\"打印\"\"\"\n     time.sleep(2)\n     print(\"Hello boy!\")\nfoo()\n下面我们来一步一步的分析函数的执行过程：1.导入time模块\nimport time\n2.定义函数timmer，定义函数并不会执行函数内的代码\ndef timmer(func):\n3.调用装饰器，相当于foo=timer(foo)，就是把函数foo作为参数穿给了函数timmer\n@timmer\n4.运行函数timmer，接受了参数 func=foo\ndef timmer(func):\n5.在函数timmer内，定义了函数wrapper，wrapper函数内部代码也不执行，然后将函数wrapper作为返回值返回\nreturn wrapper\n6.将返回值赋值给了foo，在第3步中，foo=timmer(foo)，还记吧\n@timmer #等于 foo=timmer(foo)\n7.运行函数foo()，但是这里的函数已经不是原来的那个函数了，可以打印foo，对的，因为之前我们将wrapper作为返回值传给了foo，所以在这里执行foo就是在执行wrapper了，为了再确定这一点你也可打印wrapper，它们的内存地址相同，所以都是指向同一个地址空间：\n<function timmer.<locals>.wrapper at 0x00000180E0A8A950> #打印foo的结果\n<function timmer.<locals>.wrapper at 0x000001F10AD8A950> #打印wrapper的结果\nfoo()\n8.运行函数wrapper，记录开始时间，执行函数func，在第4步的时候，func被foo赋值，运行func就是在运行原函数foo，睡2秒，打印字符串；\n time_start=time.time()\n time.sleep(2)\n print(\"Hello boy!\")\n9.记录结束时间，打印运行时间，程序结束。Hello boy!Run time is 2.000161\n有参装饰器\n在前面的例子中，原函数没有参数，下面的来看一个当原函数有参数，该怎么修改装饰器函数呢？\n# -*- coding: UTF-8 -*-\nimport time\ndef timmer(func):\n    def wrapper(*args,**kwargs):\n          \"\"\"计时功能\"\"\"\n          start_time=time.time()\n          res=func(*args,**kwargs)\n          end_time=time.time()\n          print(\"Run time is %f\"%(end_time-start_time))\n          return res\n     return wrapper\n@timmer\ndef my_max(x,y):\n     \"\"\"返回两个值的最大值\"\"\"\n     res=x if x > y else y\n     time.sleep(2)\n     return res\nres=my_max(1,2)\nprint(res)\n运行结果Run time is 2.0001752当原函数有需要传入参数的时候，在这个例子my_max有两个位置形成需要传入参数，只需要在wrapper上添加两个形参，本例子中使用了可变参数(args,*kwargs）也是可以的，这是@timmer就等于my_max(1,2)=timmer(my_max)(1,2)下面我们来看一个带有参数的装饰器：\ndef auth(filetype):\n     def auth2(func):\n          def wrapper(*args,**kwargs):\n               if filetype == \"file\":\n                username=input(\"Please input your username:\")\n                   passwd=input(\"Please input your password：\")\n                if passwd == '123456' and username == 'Frank':\n                     print(\"Login successful\")\n                     func()\n                else:\n                     print(\"login error!\")\n               if filetype == 'SQL':\n                print(\"No SQL\")\n          return wrapper\n     return auth2\n\n@auth('file)\ndef index():\n     print(\"Welcome to China\")\n\nindex()\n如果装饰器本身有参数，就需要多一层内嵌函数，下面我们一步一步分析执行流程：1.定义函数auth\ndef auth(filetype):\n2.调用解释器，首先要运行函数auth(filetype='file')\n@auth(filetype='file')\n3.运行函数auth，定义了一个函数auth2，并作为返回值返回，那么这个@auth(filetype='file')就等同于@auth2，等同于index=auth2(index)\ndef auth(filetype):\n def auth2(func):\n  def wrapper(*args,**kwargs):\n  return wrapper\n return auth2\n4.auth2(index)执行，func=index，定义函数wrapper，并返回之，这时候index其实就是等于wrapper了\ndef wrapper(*args,**kwargs):\nreturn wrapper\n5.当运行index，即运行wrapper，运行函数内部代码，filetype==\"file\"，提示用户输出用户名和密码，判断输入是否正确，如果正确，则执行函数func()，等于执行原来的index，打印\nif filetype == \"file\":\n    username=input(\"Please input your username:\")\n    passwd=input(\"Please input your password：\")\n    if passwd == '123456' and username == 'Frank':\n     print(\"Login successful\")\n     func()\n6.运行结果测试Please input your username:FrankPlease input your password：123456Login successfulWelcome to China装饰器也是可以被叠加的：\nimport time\n\n\ndef timmer(func):\n    def wrapper():\n        \"\"\"计时功能\"\"\"\n        time_start = time.time()\n        func()\n        time_end = time.time()\n        print(\"Run time is %f \" % (time_end - time_start))\n        # print(\"---\",wrapper)\n    return wrapper\n\n\ndef auth(filetype):\n    def auth2(func):\n        def wrapper(*args, **kwargs):\n            if filetype == \"file\":\n                username = input(\"Please input your username:\")\n                passwd = input(\"Please input your password：\")\n                if passwd == '123456' and username == 'Frank':\n                    print(\"Login successful\")\n                    func()\n                else:\n                    print(\"login error!\")\n            if filetype == 'SQL':\n                print(\"No SQL\")\n        return wrapper\n    return auth2\n\n\n@timmer\n# 先先返回一个auth2 ==》@auth2 ==》 index=auth2() ==》 index=wrapper\n@auth(filetype='file')\ndef index():\n    print(\"Welcome to China\")\n\n\nindex()\n\n测试结果Please input your username:FrankPlease input your password：123456Login successfulWelcome to ChinaRun time is 7.966267注释优化\nimport time\n\n\ndef timmer(func):\n    def wrapper():\n        \"\"\"计算程序运行时间\"\"\"\n        start_time = time.time()\n        func()\n        end_time = time.time()\n        print(\"Run time is %s:\" % (end_time - start_time))\n    return wrapper\n\n\n@timmer\ndef my_index():\n    \"\"\"打印欢迎\"\"\"\n    time.sleep(1)\n    print(\"Welcome to China!\")\n\n\nmy_index()\n运行结果Welcome to China!Run time is 1.0005640983581543:计算程序运行时间当我们使用了装饰器的时候，虽然没有修改代码本身，但是在运行的时候，比如上面这个例子，运行my_index其实在运行wrapper了，如果我们打印my_index的注释信息，会打印wrapper()的注释信息，那么该怎么优化？\n可以在模块functools中导入wraps，具体见以下：\nimport time\nfrom functools import wraps\n\n\ndef timmer(func):\n    @wraps(func)\n    def wrapper():\n        \"\"\"计算程序运行时间\"\"\"\n        start_time = time.time()\n        func()\n        end_time = time.time()\n        print(\"Run time is %s:\" % (end_time - start_time))\n    return wrapper\n\n\n@timmer\ndef my_index():\n    \"\"\"打印欢迎\"\"\"\n    time.sleep(1)\n    print(\"Welcome to China!\")\n\n\nmy_index()\nprint(my_index.__doc__)\n运行结果Welcome to China!Run time is 1.0003223419189453:打印欢迎这样，在表面看来，原函数没有发生任何变化。\n迭代器\n从字面意思，迭代就是重复反馈过程的活动，其目的通常是为了比较所需目标或结果，在python中可以用迭代器来实现，先来描述一下迭代器的优缺点，如果看不懂可以先略过，等看完本博客再回头看，相信你会理解其中的意思：优点：迭代器在取值的时候是不依赖于索引的，这样就可以遍历那些没有索引的对象，比如字典和文件迭代器与列表相比，迭代器是惰性计算，更节省内存缺点：无法获取迭代器的长度，没有列表灵活只能往后取值，不能倒着取值什么是迭代器那么在python什么才算是迭代器呢？只要对象有__iter__()，那么它就是可迭代的，迭代器可以使用函数next()来取值下面我们来看一个简单的迭代器：\nmy_list=[1,2,3]\nli=iter(my_list)  #li=my_list.__iter__()\nprint(li)\nprint(next(li))\nprint(next(li))\nprint(next(li))\n运行结果<list_iterator object at 0x000002591652C470>2可以看到，使用内置函数iter可以将列表转换成一个列表迭代器，使用next()获取值，一次值取一个值，当值取完了，再使用一次next()的时候，会报异常StopIteration，可以通过异常处理的方式来避免，try-except-else就是一个最常用的异常处理结构：\nmy_list=[1,2,3]\nli=iter(my_list)\nwhile True:\n try:\n  print(next(li))\n except StopIteration:\n  print(\"Over\")\n  break\n else:\n  print(\"get!\")\n运行结果get!get!get!Over查看可迭代对象和迭代器对象使用Iterable模块可以判断对象是否是可迭代的：\nfrom collections import Iterable\ns=\"hello\" #定义字符串\nl=[1,2,3,4] #定义列表\nt=(1,2,3) #定义元组\nd={'a':1} #定义字典\nset1={1,2,3,4} #定义集合\nf=open(\"a.txt\") #定义文本\n #查看是否都是可迭代的\nprint(isinstance(s,Iterable))\nprint(isinstance(l,Iterable))\nprint(isinstance(t,Iterable))\nprint(isinstance(d,Iterable))\nprint(isinstance(set1,Iterable))\nprint(isinstance(f,Iterable))\n运行结果TrueTrueTrueTrueTrueTrue通过判断，可以确定我们所知道的常用的数据类型都是可以被迭代的。使用Iterator模块可以判断对象是否是迭代器：\nfrom collections import Iterable,Iterator\ns=\"hello\"\nl=[1,2,3,4]\nt=(1,2,3)\nd={'a':1}\nset1={1,2,3,4}\nf=open(\"a.txt\")\n# 查看是否都是可迭代的\nprint(isinstance(s,Iterator))\nprint(isinstance(l,Iterator))\nprint(isinstance(t,Iterator))\nprint(isinstance(d,Iterator))\nprint(isinstance(set1,Iterator))\nprint(isinstance(f,Iterator))\n运行结果FalseFalseFalseFalseFalseTrue可知只有文件是迭代器，所以可以直接使用next()，而不需要转换成迭代器。\n生成器\n生产器就是一个是带有yield的函数下面来看一个简单的生成器\ndef my_yield():\n    print('first')\n    yield 1\n\n\ng = my_yield()\nprint(g)\n运行结果<generator object my_yield at 0x0000024366D7E258>生成器也是一个迭代器\nfrom collections import Iterator\n\n\ndef my_yield():\n    print('first')\n    yield 1\n\n\ng = my_yield()\nprint(isinstance(g, Iterator))\n运行结果True那就可以用next()来取值了print(next(g))运行结果first1生成器的执行过程我们来看以下下面这个例子，了解生产的执行流程\ndef my_yield():\n print('first')\n yield 1\n print('second')\n yield 2\n print('Third')\n yield 3\ng=my_yield()\nnext(g)\nnext(g)\nnext(g)\n运行结果firstsecondThird1.定义生成器my_yield，并将其赋值给了g\ndef my_yield():\ng=my_yield()\n2.开始第一次执行next()，开始执行生产器函数 ，打印第一语句，遇到yileld的时候暂停，并返回一个1，如果你想打印返回值的话，这里会显示1\nprint('first')\nyield 1\n3.再执行2次，打印字符串（每执行一次都会暂停一下）\nprint('second')\nyield 2\nprint('Third')\nyield 3\n**4.如果再加一次next()就会报出StopIteration异常了生成器在每次暂停的时候，函数的状态将被保存下来，来看下面的例子：**\ndef foo():\n i=0\n while True:\n  yield i\n  i+=1\ng=foo()\nfor num in g:\n if num < 10:\n  print(num)\n else:\n  break\n运行结果for循环中隐含next()，每next一次，暂停一次，if语句判断一次，然后执行下一次next，可以看到我们的while循环并没有无限循环下去，而是状态被保存下来了。协程函数我们来看下面这个生成器和执行结果\ndef eater(name):\n print('%s start to eat food'%name)\n while True:\n  food=yield\n  print('%s get %s ,to start eat'%(name,food))\n print('done')\ne=eater('Frank')\nnext(e)#或者e.send(None)\ne.send('egg') #给yield送一个值，并继续执行代码\ne.send('tomato')\n运行结果Frank start to eat foodFrank get egg ,to start eatFrank get tomato ,to start eatsend可直接以向yield传值，含有yield表达式的函数我们也称为协程函数，这运行程序的时候，不可以直接send，必须先使用next()初始化生成器(e.send(None)亦可以初始化)。如果存在多个这样的函数，那么我们每次执行的时候都要去next()一下，为了防止忘记这一步操作，可以使用装饰器初始化：\ndef init(func):\n def wrapper(*args):\n  res = func(*args)\n  next(res)  # 在这里执行next\n  return res\n return wrapper\n@init\ndef eater(name):\n print('%s start to eat food'%name)\n while True:\n  food=yield\n  print('%s get %s ,to start eat'%(name,food))\n print('done')\ne=eater('Frank')\ne.send('egg') \ne.send('tomato')\n所以在程序中有更多的生成器需要初始化的时候，直接调用这个装饰器就可以了。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "2"}