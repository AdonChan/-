{"title": "Python之路--python基础3 - 个人文章 ", "index": "python", "content": "python基础31、函数基本语法及特性2、函数参数3、局部变量和全局变量4、返回值嵌套函数5、递归函数6、匿名函数7、高阶函数8、内置函数9、函数式编程\n在编程语言中的函数并非数学意义上的函数(总是返回根据参数计算得到的结果)，编程语言中的函数也称为过程，在使用这个函数的时候有可能不会返回一个结果或者说返回的结果不是数学意义上的函数执行的结果。\n一、函数基本语法及特性\n1、抽象和结构\n抽象是程序能够被别人理解的关键所在(无论对编写程序还是阅读程序来说，这都至关重要)。程序应非常抽象，如下载网页、计算使用频率、打印每个单词的使用频率。下面将上述简单描述转换为一个Python程序：\npage = download_page()\nfreqs = compute_frequencies(page)\nfor word, freq in freqs:\n    print(word, freq)\n看到这些代码，任何人都知道这个程序是做什么的。至于具体该如何做那么我们就得在函数中得出定义。\n在比如打印斐波那契数(一种数列，其中每个数都是前两个数的和)\nfibs = [0,1]\nfor i in range(8):\n    fibs.append(fibs[-2] + fibs[-1])\nprint(fibs)\n上述代码会打印出斐波那契数的前十个，当然你也可以指定要打印数的个数：\nnum = int(input(\"How many Fibonacci numbers do you want?\"))\nfib = [0,1]\nfor i in range(num-2):\n    fibs.append(fibs[-2] + fibs[-1])\nprint(fibs)\n当我们在其他地方想使用这些数的时候，你可能会想到我再把这个循环再写一次，对于这段代码是可以的，但是对于更加复杂的代码你还愿意去重写吗？真正的程序员会去抽象程序，把一些想要实现的功能抽象为函数，直接调用这个函数来实现指定的功能，让程序更加简洁、易懂并且降低代码的重复率。真正的程序员会像下面这样做：\nnum = int(input(\"How many Fibonacci numbers do you want?\"))\nprint(fibs(num))\n2、函数的定义\ndef 函数名():\n    函数体\n例如：\ndef hello():\n    print(\"Hello world!\")\n3、给函数编写文档\n要给函数编写文档，以确保其他人能够理解，可添加注释。放在函数开头的字符串成为文档字符串(docstring)，将作为函数的一部分存储起来。例如：\ndef square(x):\n    'Calculates the square of the number x.'\n    return x * x\n可以像下面这样访问文档字符串：\n>>> square.__doc__\n'Calculates the square of the number x.'\n特殊的内置函数help很有用。在交互式解释器中，可使用它获取有关函数的信息，其中包含函数的文档字符串。\n>>> help(square)\nHelp on function square in module __main__:\nsquare(x)\nCalculates the square of the number x.\n\n二、函数的参数\n为了让一个函数更通用，在定义函数的时候可以让函数接收数据，函数接收的数据就是函数的参数。\n1、参数的基本应用\n（1）定义带参数的函数\n\n示例如下：\ndef add(a,b):\n    c = a + b\n    print(c)\n（2）调用带参数的函数\n\n以上面的add函数为例，我们调用该函数，代码如下：\ndef add(a,b):\n    c = a + b\n    print(c)\n   \nadd(11,22)   #调用带参数的函数时，需要在小括号中传递数据\n（3）调用函数时参数的顺序\n\n>>> def test(a,b):\n...     print(a,b)\n... \n>>> test(1,2)\n1 2\n>>> test(b=1,a=2)\n2 1\n>>> \n>>> test(b=1,2)\n  File \"<stdin>\", line 1\nSyntaxError: positional argument follows keyword argument\n>>> \n>>>\n通过以上代码我们可以看出，函数的参数在调用的过程中是一一对应的，如果不指定那个实参是那个对应的形参时，会默认按实参的顺序将实参赋值给形参。\n（4）总结\n\n\n定义时小括号中的参数，用来接收参数用的，称为“形参”\n调用时小括号中的参数，用来传递给函数的，称为“实参”\n\n2、参数的高级应用\n（1）缺省参数\n\n调用函数时，缺省参数的值如果没有传入，则被认为是默认值。缺省参数就是给参数设定默认值，如果在传参过程中，缺省参数传入值的话则依照传入的值，如果没有传入值则按照默认的值。如下代码：\ndef sum(a,b=11):\n    result = a + b \n    print(\"%d+%d=%d\"%(a,b,result))\n\nsum(11,22)    #调用函数时会将11和22分别赋值给a和b\nsum(10,)      #调用函数时，由于只给了一个实参，则10赋值给a，b则用默认的参数值11\n\n程序运行结果如下：\n\n注意：带有默认值的参数一定要位于参数列表的最后面。\n>>> def printinfo(name, age=35, sex):\n...     print name\n...\n  File \"<stdin>\", line 1\nSyntaxError: non-default argument follows default argument\n（2）不定长参数\n\n有时可能需要一个函数能处理比当初声明时更多的参数，这些参数叫做不定长参数，声明时不会命名。\n基本语法如下：\ndef functionname([formal_args,] *args, **kwargs):\n    \"函数_文档字符串\"\n    function_suite\n    return [expression]\n\n加*号的变量args会存放所有未命名的变量参数，args为元组\n加**号的变量kwargs会存放命名参数，即形如key=value的参数，kwargs为字典\n可变参数示例：\n>>> def fun(a, b, *args, **kwargs):\n...     \"\"\"可变参数演示示例\"\"\"\n...     print \"a =\", a\n...     print \"b =\", b\n...     print \"args =\", args\n...     print \"kwargs: \"\n...     for key, value in kwargs.items():\n...         print key, \"=\", value\n...\n>>> fun(1, 2, 3, 4, 5, m=6, n=7, p=8)  # 注意传递的参数对应\na = 1\nb = 2\nargs = (3, 4, 5)\nkwargs: \np = 8\nm = 6\nn = 7\n>>>\n>>>\n>>> c = (3, 4, 5)\n>>> d = {\"m\":6, \"n\":7, \"p\":8}\n>>> fun(1, 2, *c, **d)    # 注意元组与字典的传参方式\na = 1\nb = 2\nargs = (3, 4, 5)\nkwargs: \np = 8\nm = 6\nn = 7\n>>>\n>>>\n>>> fun(1, 2, c, d) # 注意不加星号与上面的区别\na = 1\nb = 2\nargs = ((3, 4, 5), {'p': 8, 'm': 6, 'n': 7})\nkwargs:\n>>>\n>>>\n（3）引用传参\n\n\n可变类型与不可变类型的变量分别作为函数参数时，会有什么不同？\nPython有没有类似C语言中的指针传参？\n\n>>> def selfAdd(a):\n...     \"\"\"自增\"\"\"\n...     a += a\n...\n>>> a_int = 1\n>>> a_int\n1\n>>> selfAdd(a_int)\n>>> a_int\n1\n>>> a_list = [1, 2]\n>>> a_list\n[1, 2]\n>>> selfAdd(a_list)\n>>> a_list\n[1, 2, 1, 2]\nPython中函数参数是引用传递(注意不是值传递)。对于不可变类型，因变量不能修改，所以运算不会影响到变量自身；而对于可变类型来说，函数体中的运算可能会更改传入的参数变量。\n如下代码示例：\n>>> def selfAdd(a):\n...     \"\"\"自增\"\"\"\n...     a = a + a   # 我们更改了函数体的这句话\n...\n>>> a_int = 1\n>>> a_int\n1\n>>> selfAdd(a_int)\n>>> a_int\n1\n>>> a_list = [1, 2]\n>>> a_list\n[1, 2]\n>>> selfAdd(a_list)\n>>> a_list\n[1, 2]      # 想一想为什么没有变呢？\nPython中变量之间的赋值利用到引用，只要是有\"=\"就是引用，引用就是变量中存储的是地址，而地址指向的内存空间是存真实数据地方。a = a + a会创建一个新的内存空间，然后让变量a指向这段空间；而a += a是将a所指向的那段空间的值变为a + a。如下demo：\n>>> a = [1,2]\n>>> id(a)\n31329224\n>>> a = a + a\n>>> a\n[1, 2, 1, 2]\n>>> id(a)\n31991944\n>>> b = 2\n>>> id(b)\n1587990368\n>>> b = b + b\n>>> b\n4\n>>> id(b)\n1587990432\n>>> c = [1,2]\n>>> id(c)\n31992072\n>>> c += c\n>>> c\n[1, 2, 1, 2]\n>>> id(c)\n31992072\n>>>\n\n三、局部变量和全局变量\n1、局部变量\n\n局部变量，就是定义在函数内部的变量，其作用单位只是在函数体内；\n不同的函数，可以定义相同名字的局部变量，其不会产生影响；\n局部变量的作用：为了临时保存数据需要在函数中定义变量来进行存储。\n\n示例：\ndef test1():\n    a = 100     #此时的a为局部变量，作用范围只在test1函数内\ndef test2():\n    print(\"a=%d\"%a)\n    \ntest1()\ntest2()\n此时由于a是局部变量，其做作用范围只在test1函数中，相当于test2函数中没有定义变量a，所以上述程序在运行时会报如下错误：\n\n2、全局变量\n（1）什么是全局变量\n\n如果一个变量既能在函数体中使用，也能在其他函数中使用，这样的变量称为全局变量。\n示例：\n#定义全局变量\na = 100\n\ndef test1():\n    print(\"a=%d\"%a)\n\ndef test2():\n    print(\"a=%d\"%a)\n\n#调用函数\ntest1()\ntest2()         \n由于变量a是全局变量，所以在test1和test2两个函数中都可以使用变量a，运行结果如下：\n\n（2）全局变量与局部变量同名的问题\n\n当全局变量与局部变量同名时，在定义该局部变量的函数体内以局部变量为主，如下示例：\n#定义全局变量\na = 100 \n\ndef test1():\n    a = 300 \n    print(\"---test1--修改前--a=%d\"%a)\n    a = 200 \n    print(\"---test1--修改后--a=%d\"%a)\n\ndef test2():\n    print(\"---test2---a=%d\"%a)\n\ntest1()\ntest2()\n\n此时，对于test1函数，函数体内定义了和全部变量同名的局部变量a，此时会以函数中的变量a为根据；对于test2函数，函数体内没有定义和全局变量同名的局部变量，所以如果test2函数使用变量a，则以全部变量a为根据。运行结果如下：\n\n（3）修改全局变量\n\n既然是全局变量，就可以在所有的函数中是，那么是否可以修改呢？看如下代码：\n#定义全局变量\na = 100 \n\ndef test1():\n    global a\n    print(\"---test1--修改前--a=%d\"%a)\n    a = 200 \n    print(\"---test1--修改后--a=%d\"%a)\n\ndef test2():\n    print(\"---test2---a=%d\"%a)\n\ntest1()\ntest2()\n代码运行结果如下：\n\n在函数体内利用global这个关键字来声明变量为全局变量，此时在函数体内对该变量的操作就是相当于对全局变量的操作。\n（4）可变类型的全局变量\n\n看下面两个代码示例的区别：\n#定义全局变量\na = 100 \n\ndef test1():\n    print(\"---test1--修改前--a=%d\"%a)\n    a = 200 \n    print(\"---test1--修改后--a=%d\"%a)\n\ndef test2():\n    print(\"---test2---a=%d\"%a)\n\ntest1()\ntest2()\n\n上述代码运行结果为：\n\n#定义全局变量\na = [11,22,33]\n\ndef test1():\n    print(\"---test1--修改前--\",a)\n    a.append(44)\n    print(\"---test1--修改前--\",a)\n\ndef test2():\n    print(\"---test2--修改前--\",a)\n\ntest1()\ntest2()\n\n上述代码运行结果为：\n\n对于上述两种情况，列表(list)、字典(dict)这种可变的类型的全局变量不用再函数体内声明全局变量，在函数体中对该变量的操作就是在对全局变量进行操作；而像数值类型(int,flaot,bool,long)、字符串(str)、元组(tuple)这种不可变类型的操作，要想在函数体内对这种全局变量进行操作，必须在函数体内声明其为全局变量。\n（5）总结\n\n\n在函数外边定义的变量叫全局变量\n全局变量能够在所有的函数中进行访问\n如果在函数中修改全局变量，那么就需要使用global进行声明\n如果全局变量的名字和局部变量的名字相同，那么使用的是局部变量的，小技巧强龙不压地头蛇\n\n在函数中不使用global声明全局变量时不能修改全局变量的本质是不能修改全局变量的指向，即不能将全局变量指向新的数据\n对于不可变类型的全局变量来说，因其指向的数据不能修改，所以不能使用global时无法修改全局变量\n对于可变类型的全局变量来说，因其指向的数据可以修改，所以不使用global时也可修改全局变量\n\n\n四、函数的返回值\n“返回值”，就是程序中函数完成一件事情后，最后给调用者返回的结果。\n1、带有返回值的函数\n想要在函数中把结果返回给调用者，需要在函数中使用return如下示例：\ndef add2num(a, b):\n    c = a+b\n    return c\n或者\ndef add2num(a, b):\n    return a + b\n2、保存函数的返回值\n在程序中，如果一个函数返回了一个数据，那么想要用这个数据，就需要用一个变量来保存函数返回的数据。示例如下：\n#定义函数\ndef add2num(a, b):\n    return a+b\n\n#调用函数，顺便保存函数的返回值\nresult = add2num(100,98)\n\n#因为result已经保存了add2num的返回值，所以接下来就可以使用了\nprint result\n3、Python返回多值看如下代码：\ndef test(a,b):\n    sum2 = a + b \n    mulit = a * b \n    return [sum2,mulit]\n\nresult = test(2,3)\nprint(result)\n\n运行结果为：\n[5,6]\ndef test(a,b):\n    sum2 = a + b \n    mulit = a * b \n    return sum2,mulit\n\nresult = test(2,3)\nprint(result)\n\n运行结果为：\n(5,6)\n由上述示例我们可以得出，当有多个返回值时，利用列表将结果返回，那么函数就会返回一个列表；当将几个返回值用逗号隔开返回时，默认返回的是元组。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}