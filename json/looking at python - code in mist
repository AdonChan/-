{"title": "looking at python - code in mist ", "index": "python", "content": "Python 初探\nPython是。。？\n\npython是一种解释型脚本语言。\npython语言是一句一句执行的，可以再命令提示符中直接编写程序并随时获得结果\npython支持面向对象\n\n我已经会c了，除此之外我还会java了，为嘛我还要学习python？\n\npython语言结构和语法十分简单，十分容易学习。（这两天基本就可以开始写python了，那个机器人项目就是用python写的。）\npython代码易于阅读，并且，易于维护（这一条是看来的，这可能只是一种感觉问题。也可能是因为，python代码的层次性非常弱，代码结构非常简单，再加上很容易阅读，因此容易维护）\n标准库十分广泛。（那个机器人项目=。=居然只提供了python和c++库）\n可移植性好。\n可扩展性好。这一条也是看来的。python可以添加低层次的模块到python解释器，这些模块使得程序员可以添加或者定制自己的工具。（别的语言也可以啊）\n\npython的语法鉴赏\n变量\n对变量的第一次赋值就是声明和定义。\nnum = 1;\nnums = 1, 2, 3;\narray = 'a', \"b\", 'sa', 3;\nnum = array[1];    // num = \"b\"\nnum = array[3];    // num = 3\n通过上面的例子可以看出来，变量的类型在运行时是可以发生改变的。另外，python中没有字符类型。事实上也不需要有。\n列表\n这相当于数组的概念，但是python的列表中允许出现不同类型的元素。例如：\nlist1 = ['a', 'b', \"c\", 123 ]\npython列表的索引从0开始，并且可以一次访问其中的多个元素。例如：\nsublist = list[0:4]\nsublist = list[0:]\n上述语句访问的是0, 1, 2, 3四个元素。\n还可以直接删除列表中的一个元素：\ndel list[2];\n对列表的操作还有：\nlist.append(o) # 列表尾追加元素o\nlist.count(o)  # 列表的元素个数\nlist.extend(o) # 将新列表的值全部追加到原列表中\nlist.index(o)  # 返回列表中第一次出现这个值得位置\nlist.insert(index, o) # 插入o到位置index\nlist.pop(o=list[-1])  # 移除列表的一个元素，并返回该元素的值\nlist.remove(o) # 移除列表中第一个这样的值\nlist.reverse() # 将列表中的值倒置\nlist.sort([compFunc]) # 链表排序，compFunc用于指定比较函数，可选\npython中还有元组（不允许修改的列表）、字典等数据结构。。不码这儿了，语法什么的大差不离\npython面向对象编程\n与其他众多支持面向对象编程的编程语言一样，python使用class关键字来定义一个类。\n创建类：\nclass Foo:\n\n    id = 1\n    \n    def __init__(self, name):\n        self.name = name\n        id = id + 1\n        \n    def displayself(self):\n        print self.name, Foo.id\n        \npython中self是指向这个对象自己的引用。他必须作为每个方法的第一个参数。每个类的属性分为两部分，一部分是在所有方法声明之前声明的变量，他们作为所有对象共享的一个静态变量，所有对象都持有相同的这个属性，并且都可以改变他的值。在方法中声明的属性是这个类的私有属性，每个对象拥有不同的私有属性。\n创建对象的实例\nfoo1 = Foo(\"foo1\")\nfoo2 = Foo(\"foo2\")\n访问属性\nfoo1.displayself()\nfoo2.displayself()\npython内置类属性\n__dict__: 一个字典，由类的属性数据构成__doc__: 类的文档字符串，是类的第一个逻辑行的由三个引号括起来的字符串__name__: 类名__module__: 类定义所在的模块__bases__: 类的所有父类构成元素（包含了一个由所有父类组成的元组）\npython的对象销毁机制\npython拥有和java类似的垃圾回收机制。python使用引用计数器来最总内存总的对象。当对象的引用计数变为0的时候，对象占用的内存将被回收。但是回收发生在内存将要被写满的时候。\n同事python还有一个循环引用垃圾收集器，即两个对象分别持有对方的引用，但是没有别的变量指向他们，因此他们也应该被垃圾回收所以，他们也应该被垃圾回收。因此python的垃圾回收机制由一个引用计数器和一个循环垃圾收集器组成。\npython的对象中包含了内置的析构函数__del__,当对象的引用计数变为0时，析构函数将被执行。\n类的继承\npython支持多重继承：\nclass Foo (Parent1, Parent2, Parent3...):\n父类的构造函数必须在子类中亲自调用：\nclass Foo(Foo2):\n    def __init__(self):\n        super().__init__(self);\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}