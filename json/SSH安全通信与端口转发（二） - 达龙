{"title": "SSH安全通信与端口转发（二） - 达龙 ", "index": "python,docker,linux,centos,mysql", "content": "博文参考\nhttp://www.178linux.com/48542\nhttps://segmentfault.com/a/1190000010279082\n利用openssl建立私有CA，完成证书颁发和管理\nopenssl配置文件中关于CA的配置段介绍\nopenssl的配置文件为/etc/pki/tls/openssl.cnf，其中定义了openssl完成CA工作时的相关属性定义\n建立私有CA\n在确定配置为CA的服务器上生成一个自签证书，为CA提供所需的目录及文件即可\n\n        步骤：\n\n        <1>生成CA自己的私钥，而在openssl的配置文件中定义了私钥存放的位置为/etc/pki/CA/private/cakey.pem\n        <2>为CA提供工作所需要的目录及文件：\n`\n            mkdir /etc/pki/CA/{certs,crl,newcerts}  注意：如果目录不存在才创建\n\n            touch /etc/pki/CA/{serial,index.txt}\n\n            echo 01 >>/etc/pki/CA/serial\n\n            创建两个CA工作需要用到的文件，serial为存放证书编号的文件，并且要给该文件提供一个初始的编号，标号必须是2位数字。\n\nindex.txt文件用于存放签署过的证书的索引\n\n            (umask 077;openssl genrsa -out /etc/pki/CA/private/cakey.pem 2048 )\n             <3>生成CA自己的自签证书，而在openssl的配置文件中，也定义了自签证书的存放位置为/etc/pki/CA/cacert.pem\n\n            发起签署CA证书的请求\n\n            openssl req -new -x509 -key /etc/pki/CA/private/cakey.pem  -out /etc/pki/CA/cacert.pem -days 3650  \n\n                表示发起CA证书签署请求，\n\n                    -new表示这是一个新申请的签署请求\n\n                    -x509 表示这是自签证书，该选项只有在CA为自己生成自签证书时使用\n\n                    -key指明私钥的存放路径\n\n                    -out 标明所生成的请求的文件存放路径，如果是自签证书，将直接生成签署过的证书，如果不是自签证书，则将生成的签署请求文件发送给CA服务器，由CA服务器根据请求文件生成证书文件\n\n                    -days 指明申请的证书的有效期限为多少天\n\n            命令执行后会要求填入一些信息：\n\n                国家代码：CN\n\n                省份：beijing\n\n                城市：beijing\n\n                公司名：nwc\n\n                部门：ops\n\n                持有者名称：ca.nwc.com(注意:此处最好与此CA服务器的主机名保持一致)\n\n                管理员的邮件地址：nwc@nwc.com\n另一个主机建立CA申请请求,CA进行签署颁发证书\n    某服务器需要用到证书进行安全通行时，需要向CA服务器请求签署证书：\n\n        步骤：\n\n        <1>在需要使用证书的服务器上建一个目录，生成私钥(真实环境中建议将该目录建在需要用到证书的服务的相关目录下，便于管理)\n\n        <2>生成签署请求\n\n            openssl req -new -key /testdir/testssl/mykey.private -out /testdir/testssl/mykey.csr -days 365\n\n            表示生成证书签署请求，使用的私钥文件路径为/testdir/testssl/mykey.private，生成的签署请求的文件为/testdir/testssl/mykey.csr，申请的证书有效期为365天\n\n            执行命令后会要求填入一些信息：\n\n                国家、身份、城市、单位、部门、持有者、管理员邮箱等\n\n            注意：持有者要写成主机名， 否则可能造成后期用户访问时，提示证书与访问的主机名不一致，此处应为www.nwc.com\n            <3>将生成的请求文件拷贝到CA服务器上\n\n            <4>在CA服务器上进行签署，生成证书，在openssl的配置文件中，定义了签署完成的证书的存放位置为/etc/pki/CA/certs/目录下\n\n            openssl ca -in /tmp/mykey.csr -out /etc/pki/CA/certs/mykey.crt -days 365\n\n            表示签署证书，-in指明请求签署文件的路径，-out指明生成的证书的路径，-days表示签署多少天\n\n            命令执行后，会让确认两次，确认好了之后，即完成了签署的动作，生成了签署过后的证书\n\n        <5>将签署的证书发给请求方        \n证书的吊销\n      <1>在客户端获取要吊销的证书的serial\n            openssl x509 -in /PATH/FROM/CERT_FILE -noout -serial -subject\n        <2>在CA上，根据客户提交的serial与subject信息，对比检验是否与index.txt文件中的信息一致\n            吊销证书：\n                openssl ca -revoke /etc/pki/CA/newcerts/SERIAL.pem\n\n        <3>生成吊销证书的编号(第一次吊销一个证书时才需要执行)\n                echo 01 > /etc/pki/CA/crlnumber\n        <4>更新证书吊销列表\n            openssl ca -gencrl -out /etc/pki/CA/crl/ca.crl\n            查看crl文件：\n            openssl crl -in /etc/pki/CA/crl/ca.crl -noout -text\n利用gpg实现加解密\ngpg实现对称加密\n    <1>对称加密file文件\n            gpg -c file\n            ls file.gpg\n        <2>在另一台主机上解密file\n            gpg -o file -d file.gpg\ngpg实现公钥加密\n 在hostB主机上用公钥加密，在hostA主机上解密\n        <1>在hostA主机上生成公钥/私钥对\n            gpg –gen-key\n        <2>在hostA主机上查看公钥\n            gpg –list-keys\n        <3>在hostA主机上导出公钥到nwckey.pub\n\n            gpg -a –export -o nwckey.pub\n        <4>从hostA主机上复制公钥文件到需加密的B主机上\n            scp nwckey.pub HOST_B:/PATH/TO/SOMEWHERE\n\n        <5>在需加密数据的hostB主机上生成公钥/私钥对\n            gpg –list-keys\n            gpg –gen-key\n        <6>在hostB主机上导入公钥\n            gpg –import nwckey.pub\n            gpg –list-keys\n        <7>用从hostA主机导入的公钥，加密hostB主机的文件file,生成file.gpg\n            gpg -e -r nwc file\n            file file.gpg\n\n        <8>复制加密文件到hostA主机\n            scp file.gpg HOST_A:/PATH/TO/SOMEWHERE\n        <9>在hostA主机解密文件\n            gpg -d file.gpg\n            gpg -o file -d file.gpg\n        <10>删除公钥和私钥\n            gpg –delete-keys nwc\n            gpg –delete-secret-keys nwc\nssh服务\nSSH协议的基本概念\n    SSH：Secure Shell\n\n        监听在TCP协议的22号端口\n\n        SSH协议版本：\n\n            sshv1：基于CRC-32做MAC，因此不安全，建议勿用\n\n            sshv2：基于双方主机协商选择最安全的MAC实现机制，建议使用。\n\n                    sshv2基于DH实现秘钥交换，基于RSA或DSA实现身份认证\n\n                    客户端通过检查服务器端的主机秘钥来判定是否与其进一步通信\n\n        服务端程序为：openssh-server，配置文件为/etc/ssh/sshd_config\n\n        客户端程序为：openssh-client,配置文件为/etc/ssh/ssh_config`\nSSH服务器端的相关配置\n       配置文件：/etc/ssh/sshd_config\n\n        服务脚本：/etc/rc.d/init.d/sshd\n\n        服务脚本配置文件：/etc/sysconfig/sshd\n\n        获取关于服务配置文件的帮助：man sshd_config\n\n        /etc/ssh/sshd_config配置文件中相关指令说明：(#开始的相关选项表示使用的是默认值)\n\n                Port 22  指明ssh服务监听的端口\n\n                ListenAddress IP_ADDR  表示监听的地址，可出现多次\n\n                        0.0.0.0表示当前主机的所有地址\n\n                Protocol 2  表示支持的ssh协议版本，建议是2\n\n                SyslogFacility AUTHPRIV  表示日志记录的设施，要想知道该设置的具体日志放在哪里，则查看rsyslog的配置文件/etc/rsyslog.conf文件中的相关定义，此处相当于日志存在/var/log/secure日志中\n\n                LogLevel INFO  表示定义记录的日志级别\n\n                PermitRootLogin yes|no  是否允许管理员以ssh登录\n\n                MaxAuthTries 6  表示认证时的重试次数，为此数字的一半，超过次数后会被锁定一定时间\n\n                MaxSessions 10 表示支持的最大的ssh会话的个数\n\n                AcceptEnv  接受的环境变量参数\n\n                AllowUsers  接受那些用户使用ssh，做用户白名单，只要不在此名单内的用户，都不允许登录\n\n                        如：AllowUsers nwc1 nwc2 nwc3 root\n\n                AllowGroups  接受那些用户组使用ssh，组的白名单\n\n                DenyUsers  不允许那些用户使用ssh，用户黑名单\n\n                DenyGroups  不允许那些用户组使用ssh，组黑名单\n\n                        白名单和黑名单不要同时使用\n\n                X11Forwarding yes|no  是否转发图形窗口\n\n                #KeyRegenerationInterval 1h  密钥的使用时间\n\n                #ServerKeyBits 1024 密钥长度\n\n                #LoginGraceTime 2m 登陆宽限期\n\n                #PermitRootLogin yes root是否可以登录\n\n                #StrictModes yes 严格模式，家目录 属主 属组\n\n                PasswordAuthentication yes 是否使用用户名和密码的方式\n\n                Kerberos集中认证管理\n\n        使用SSH服务的最佳配置方案：\n\n            1）仅适用sshv2版本\n\n            2）限定仅允许哪些用户访问ssh服务\n\n                Allowusers root vivek jerry\n\n                白名单\n\n                DenyUser saroj anjali foo\n\n                黑名单\n\n            3）配置空闲会话超时长\n\n                ClientAliveCountMax  0 \n\n                ClientAliveInterval  300\n\n            4）使用iptables设置ssh服务安全访问策略\n\n            5）改变默认的端口和监听的IP\n\n                port 300\n\n                ListenAddress 192.168.1.5\n\n                ListenAddress 202.54.1.5\n\n                勿使用默认22端口\n\n            6）使用强密码\n\n                生成随机密码的函数示例：\n\n                genpasswd（）{\n\n                    local 1=$1\n\n                    [ \"$1\" == \"\" ]&& 1=20\n\n                    tr -dc A-Za-z0-9_</dev/urandom | head -c ${1} | xargs\n\n                }\n\n            7）使用公钥认证\n\n            8）禁止空密码登录\n\n            9）使用前利用漏扫工具先评估下破解的可能性\n\n                google：ssh best practice\n\n            10）限制ssh访问频度\n\n            11）记录好日志，经常做日志分析。\n用户登录信息的获取\n        /var/log/wtmp  用户成功登录的日志信息，也可直接用last命令显示\n\n        /var/log/btmp  用户失败登录的日志信息，也可用lastb命令显示\n\n        lastlog 每个用户最近一次成功登录的信息\n基于SSH的客户端相关工具\n     客户端的命令：ssh\n\n        ssh [OPTIONS] USERNAME@HOST [COMMAND]\n\n        常见选项：(如果不提供USERNAME，则会以当前系统上的用户，作为登录远程主机的用户，如果远程主机上的用户不存在，则无法连接)\n\n            -p PORT  指定登录的端口(如果远程主机的ssh服务修改了默认监听的端口，则需要用-p指定端口)，在生产环境中建议将SSH监听的端口改掉\n\n            COMMAND  表示不登录对方主机，在远程主机执行命令，然后结果返回本机后退出\n\n            -b:指定连接的源IP\n            -v:调试模式\n            -C：压缩方式\n            -X: 支持x11转发\n            -Y：支持信任x11转发\n                ForwardX11Trusted yes\n            -t: 强制伪tty分配\n                ssh -t remoteserver1 ssh remoteserver2\n配置基于秘钥方式进行SSH登录\n SSH的认证机制：\n\n            基于口令\n\n            基于秘钥：\n\n                客户端在本地生成一对秘钥，客户端将公钥复制到服务器端，要登录的用户的家目录下的隐藏目录.ssh目录下一个名为authorized_keys或authorized_keys2文件中，这样即可实现无需密码登录ssh服务端\n\n        配置过程：\n\n            <1>生成秘钥对\n\n                ssh-keygen -t rsa -P ''\n\n                生成的秘钥默认保存至当前用户家目录下的.ssh目录的id_rsa文件中，公钥在id_rsa.pub文件中\n\n                -P 表示不指定使用秘钥文件时的密码，否则以后每次使用秘钥登录时，都要输入秘钥文件的密码\n\n            <2>复制秘钥至远程主机\n\n                ssh-copy-id -i /PATH/TO/公钥文件 USERNAME@HOST\n\n                表示将本机的公钥文件复制到哪个远程主机的哪个用户\n基于ssh的复制文件命令：scp\n     scp SRC1 SRC2 … DEST\n\n        常用选项有：\n\n            -r 当源是目录时，实现递归复制\n\n            -p 复制时，保留源文件的复制和修改时间戳以及权限\n\n            -q 复制时静默模式\n\n            -C: 压缩数据流\n\n            -P PORT  指定服务器端的端口(如果远程主机的ssh服务修改了默认监听的端口，则需要用-P指定端口)\n\n        分两种情况：\n\n            <1>源文件在本机，目标为远程：\n\n                scp /PATH/TO/FILE1… USERNAME@HOST:/PATH/TO/SOMEWHERE\n\n                注意：源文件为目录时，要使用-r 选项，实现递归复制;多个源时，目标要是目录\n\n            <2>源文件在远程，目标为本机：\n\n                scp USERNAME@HOST:/PATH/TO/FILE… /PATH/TO/SOMEWHERE\n\n                注意：源文件为目录时，要使用-r 选项，实现递归复制，多个源时，目标要是目录\n基于ssh的ftp协议的命令：sftp\n    查看openssh是不是支持sftp，查看openssh的配置文件/etc/ssh/sshd_config里面，是否有\n\n            Subsystem sftp /usr/libexec/openssh/sftp-server\n\n        这一行的定义，如果有，则证明支持sftp\n\n        用法：sftp USERNAME@HOST  指明以哪个用户登录哪个主机的ftp服务器，登录后可利用help获取ftp命令的使用格式\nrsync命令(比scp更快，只复制不同的文件，对于相同的文件不复制)\n 基于ssh和rsh服务实现高效率的远程系统之间复制文件\n\n        使用安全的shell连接做为传输方式\n\n            rsync –av /etc server1:/tmp 复制目录和目录下文件(源路径后面没有/)\n\n            rsync –av /etc/ server1:/tmp 只复制目录下文件(原路径后面有/)\n\n        常见选项：\n\n            -n 模拟复制过程\n\n            -v 显示详细过程\n\n            -r 递归复制目录树\n\n            -p 保留权限\n\n            -t 保留时间戳\n\n            -g 保留组信息\n\n            -o 保留所有者信息\n\n            -l 把符号链接文件做为符号文件进行复制（默认）\n\n            -L 将软链接文件指向文件复制\n\n            -a 存档模式，相当于 –rlptgoD，但不保留ACL（ -A）和SELinux属性（-X）\nSSH的端口转发\n <1>什么是SSH端口转发？\n            SSH 会自动加密和解密所有 SSH 客户端与服务端之间的网络数据。但是， SSH 还能够将其他 TCP 端口的网络数据通过 SSH 链接来转发，并且自动提供了相应的加密及解密服务。这一过程也被叫做“隧道”（ tunneling），这是因为 SSH 为其他 TCP 链接提供了一个安全的通道来进行传输而得名。例如， Telnet， SMTP， LDAP 这些 TCP 应用均能够从中得益，避免了用户名，密码以及隐私信息的明文传输。而与此同时， 如果工作环境中的防火墙限制了一些网络端口的使用，但是允许SSH 的连接，也能够通过将 TCP 端口转发来使用 SSH 进行通讯\n\n        <2>SSH 端口转发能够提供两大功能：\n            加密 SSH Client 端至 SSH Server 端之间的通讯数据\n            突破防火墙的限制完成一些之前无法建立的 TCP 连接\n\n        <3>本地转发\n            ssh -L localport:host:hostport sshserver\n            ssh –L 9527:telnetsrv:23 -N sshsrv\n            telnet 127.0.0.1 9527\n                当访问本机的9527的端口时，被加密后转发到sshsrv的ssh服务，再解密被转发到telnetsrv:23\n                data–>localhost:9527–>localhost:XXXXX–>sshsrv:22–>sshsrv:YYYYY–>telnetsrv:23\n            选项：\n                -f 后台启用\n                -N 不开远程shell\n                -g 启用网关功能\n\n        <4>远程转发:\n            -R sshserverport:host:hostport sshserver\n            ssh –R 9527:telnetsrv:23 –N sshsrv\n                让sshsrv侦听9527端口的访问，如有访问，就加密后通过ssh服务转发请求到本机ssh客户端， 再由本机解密后转发到telnetsrv:23\n                Data–>sshsrv:9527–>sshsrv:22–>localhost:XXXXX–>localhost:YYYYY–>telnetsrv:23\n\n        <5>动态端口转发：\n            当用firefox访问internet时，本机的1080端口做为代理服务器， firefox的访问请求被转发到sshserver上，由sshserver替之访问internet\n            在本机firefox设置代理socket proxy:127.0.0.1:1080\n            #ssh -D 1080 root@sshserver\ndropbear提供ssh服务\nssh协议的另一个实现： dropbear\n编译安装dropbear准备：\n    <1>安装开发包组:yum groupinstall \"Development Tools\" -y\n    <2>下载源码包，假设为dropbear-2013.58.tar.bz2\n\n安装：\n    <3> 解压：tar xf dropbear-2013.58.tar.bz2\n    <4> 查看安装的帮助手册：less INSTALL\n    <5> 切换到解压后的目录，并执行./configure\n    <6> make，指定要安装那些工具：make PROGRAMS=\"dropbear dbclient dropbearkey dropbearconvert scp\"\n    <7> make install，指定安装的工具：make PROGRAMS=\"dropbear dbclient dropbearkey dropbearconvert scp\" install\n\n启动ssh服务：\n    <8> ls /usr/local/sbin/ /usr/local/bin/\n    <9> /usr/local/sbin/dropbear -h\n    <10> mkdir /etc/dropbear\n    <11> dropbearkey -t rsa -f /etc/dropbear/dropbear_rsa_host_key -s 2048\n    <12> dropbearkey -t dss -f /etc/dropbear/dropbear_dsa_host_key\n    <13> dropbear -p :2222 -F –E #前台运行(因为本机有SSH，为了避免端口冲突，手动指定其运行在2222端口)\n            dropbear -p :2222 #后台运行\n客户端访问：\n    <14> ssh -p 2222 root@127.0.0.1\n    <15> dbclient -p 2222 root@127.0.0.1\naide监控文件安全性\naide是什么\n    AIDE(Advanced Intrusion Detection Environment高级入侵检测环境)是一个入侵检测工具，主要用途是检查文件的完整性，审计计算机上的那些文件被更改过了。\n    AIDE能够构造一个指定文件的数据库，它使用aide.conf作为其配置文件。 AIDE数据库能够保存文件的各种属性，包括：权限(permission)、索引节点序号(inode number)、所属用户(user)、所属用户组(group)、文件大小、最后修改时间(mtime)、创建时间(ctime)、最后访问时间(atime)、增加的大小以及连接数。 AIDE还能够使用下列算法： sha1、 md5、 rmd160、 tiger，以密文形式建立每个文件的校验码或散列号.\n    这个数据库不应该保存那些经常变动的文件信息，例如：日志文件、邮件、 /proc文件系统、用户起始目录以及临时目录\n\nAIDE安装及其配置文件\n    安装：yum install aide\n\n    其配置文件为/etc/aide.conf (指定对哪些文件进行哪些种类的检测)\n\n    配置文件相关的定义：\n[root@localhost ~]# cat /etc/aide.conf\n@@define DBDIR /var/lib/aide    //定义aide的数据库文件\n@@define LOGDIR /var/log/aide   //定义aide的日志文件\ndatabase=file:@@{DBDIR}/aide.db.gz   //定义aide比对时使用的数据库文件\ndatabase_out=file:@@{DBDIR}/aide.db.new.gz    //定义aide创建数据库时的数据文件\n//创建好比对数据库后，数据库的名称默认就是new，如果要比对，需要将new去掉，然后利用去掉new后的数据进行验证\n#p:      permissions  //定义文件权限的检测\n#i:      inode:     //定义文件inode号的检测\n#n:      number of links  //定义文件链接数的检测\n#u:      user   //定义文件所属主的检测\n#g:      group  //定义文件所属组的检测\n#s:      size   //定义文件大小的检测\n#b:      block count   //定义文件占用块数量的检测\n#m:      mtime   //定义文件内容修改时间的检测\n#a:      atime   //定义文件访问时间的检测\n#c:      ctime   //定义文件修改时间的检测\n#S:      check for growing size  \n#acl:           Access Control Lists   //定义文件acl权限的检测\n#selinux        SELinux security context   //定义selinux的检测\n#xattrs:        Extended file attributes   //定义文件xattrs属性的检测\n#md5:    md5 checksum  //定义MD5校验检测\n#sha1:   sha1 checksum  //定义SHA1校验检测\n#sha256:        sha256 checksum   //定义SHA256校验检测\n#sha512:        sha512 checksum\n#R:             p+i+n+u+g+s+m+c+acl+selinux+xattrs+md5   //定义一个检测项目的组，组名为R，检测的内容为后面各个单独属性的集合\n#L:             p+i+n+u+g+acl+selinux+xattrs             //支持自定义的检测项目组\n#E:             Empty group\n#>:             Growing logfile p+u+g+i+n+S+acl+selinux+xattrs\nALLXTRAHASHES = sha1+rmd160+sha256+sha512+tiger\nNORMAL = R+rmd160+sha256\n/opt    NORMAL   //定义检测的文件路径，及对其采用哪种方式的检测，后面NORMAL为定义的一个检测项目的集合\n/usr    NORMAL\n/root   NORMAL\n!/usr/src   //路径前面带！表示不检测\n!/usr/tmp\n使用流程\n    初始化默认的AIDE的库：\n        /usr/local/bin/aide –init\n    生成检查数据库（建议初始数据库存放到安全的地方）\n        cd /var/lib/aide\n        mv aide.db.new.gz aide.db.gz\n    检测：\n        /usr/local/bin/aide –check\n    更新数据库\n        aide –update \n   \n[root@centos7 ~]# echo aa > /testdir/file1[root@centos7 ~]# echo cc > /testdir/file2\n\n\nsudo相关内容\nsudo的基础概念\n    <1> sudo能够授权指定用户在指定主机上运行某些命令。 如果未授权用户尝试使用 sudo，会提示联系管理员\n    <2>sudo可以提供日志，记录每个用户使用sudo操作\n    <3>sudo为系统管理员提供配置文件，允许系统管理员集中地管理用户的使用权限和使用的主机\n    <4>sudo使用时间戳文件来完成类似“检票”的系统，默认存活期为5分钟的“入场券”\n    <5>通过visudo命令编辑配置文件，具有语法检查功能，用visudo -c 可检查配置文件语法\n\nsudo命令本身：\n    sudo [-u user] COMMAND\n        -V 显示版本信息等配置信息\n        -u user 默认为root\n        -l,ll 列出用户在主机上可用的和被禁止的命令\n        -v 再延长密码有效期限5分钟,更新时间戳\n        -k 清除时间戳，下次需要重新输密码（当用户使用sudo时，会要求输入用户密码，用户密码默认5分钟内有效，如果使用sudo -k则可以让密码立即失效，下次使用sudo又要使用密码）            \n\n        -K 与-k类似，还要删除时间戳文件\n        -b 在后台执行指令\n        -p 改变询问密码的提示符号\n            如 -p ”password on %h for user %p\n\n        sudo –i –u nwc切换身份\n\nsudo的配置文件（/etc/sudoers）\n    配置文件： /etc/sudoers, /etc/sudoers.d/\n    时间戳文件： /var/db/sudo\n    日志文件： /var/log/secure\n\n\n配置文件支持使用通配符glob：\n        ？ :前面的字符或词可出现一次或无\n        * ：前面的字符或词出现零次或多次\n        [nwc]:匹配其中一个字符\n        [^nwc]:除了这三个字符的其它字符\n        \\x : 转义\n        [[alpha]] :字母 示例： /bin/ls [[alpha]]*\n\n配置文件规则有两类；\n        别名定义:不是必须的\n        授权规则:必须的\n\n一个sudo条目：\n\n            who  which_host=（runas）  command\n\n            在命令前可以使用标签NOPASSWD:就可以让用户在使用该命令时不用输入密码\n\n        格式说明：\n            user: 运行命令者的身份\n            host: 通过哪些主机\n            (runas)：以哪个用户的身份\n            command: 运行哪些命令\n\n别名机制：类似组的概念，组里面多个角色\n            who：User_alias\n\n            which_host：Host_alias\n\n            runas：Runas_alias\n\n            command：Cmnd_alias\n\n            别名必须全部而且只能全部使用大写英文字母的组合\n\n        用户别名：User_alias 别名 =\n\n            后面可以是：\n\n                用户名\n\n                用户UID，用#引用\n\n                组名，用%引用\n\n                组的GID，用%#引用\n\n                还可以包含其他已经定义的用户别名\n\n        主机别名：Host_Alias 别名 =\n\n            后面可以是：\n\n                    主机名\n\n                    IP\n\n                    网络地址\n\n                    其他已经定义的主机别名\n\n        以哪个身份运行：Run_Alias 别名 =\n\n            后面可以是：\n\n                    用户名\n\n                    %组名\n\n                    其他已经定义的runas别名\n\n        命令别名：Cnmd_Alias 别名 =\n\n            后面可以是：\n\n                    命令路径（一般为绝对路径）\n\n                    目录（此目录内的所有命令）\n\n                    其他已定义的命令别名\n\nsudo示例：\n例如：以nwc用户以root身份运行useradd，usermod命令\n           先visudo\n\n           nwc ALL=（root） /usr/sbin/useradd，/usr/sbin/usermod\n\n           当nwc用的时候格式为：sudo /usr/sbin/useradd newbee\n\n例如：nwc ALL=（root）NOPASSWD:/usr/sbin/useradd，/usr/sbin/usermod\n           表示nwc在使用useradd和usermod时都不需要输入密码\n\n例如：nwc ALL=（root） NOPASSWD:/usr/sbin/useradd，PASSWD:/usr/sbin/usermod\n           表示nwc在使用useradd时不要密码，usermod要密码\n\n例如：\n         定义一个用户组别名\n\n             User_Alias USERADMIN = nwc，%newbee，%nwc\n\n             组内包含nwc用户，newbee组和nwc组内的所有用户\n\n         定义一个命令组别名\n\n             Cmnd_Alias ADMINCOMMAND = /usr/sbin/useradd，/usr/sbin/userdel，/usr/bin/passwd [A-Za-z]*，！/usr/bin/passwd root\n\n             表示定义useradd、userdel命令，passwd命令后必须跟字符，且不能对root进行passwd命令。\n\n         添加条目：\n\n             USERADMIN  ALL=(root)  NOPASSWD:ADMINCOMMAND\n\n             表示USERADMIN别名内的所有用户，在所有主机上，以root身份，不需要密码，执行ADMINCOMMAND内的所有命令\n\n例如：\n        nwc ALL=(ALL) ALL\n        %wheel ALL=(ALL) ALL\n\n        表示nwc用户可以在任意主机上，以任意身份运行任意命令，wheel组类的用户可以在任意主机上，以任意身份运行任意命令                 例如：\n        nwc ALL=(root) /sbin/pidof,/sbin/ifconfig\n        %wheel ALL=(ALL) NOPASSWD: ALL\n\n        表示nwc用户可以在任意主机上以root身份运行/sbin/pidof,/sbin/ifconfig命令\n\n        wheel组类的用户可以在任意主机上，以任意身份无需密码运行任意命令\n\n\n例如：\n        User_Alias NETADMIN=user1,user2\n        Cmnd_Alias NETCMD = /usr/sbin/ip\n        NETADMIN ALL=（ root） NETCMD\n\n        表示定义一个用户别名NETADMIN，该别名内包含用户user1，user2\n\n        定义一个命令别名NETCMD，包含命令/usr/sbin/ip\n\n        NETADMIN内的用户能够在任意主机上，以root身份，运行NETCMD定义的命令，也就是user1和user2能在任意主机上以root身份运行ip命令\n\n例如：\n        User_Alias SYSADER=nwc,user1,%admins\n        User_Alias DISKADER=tom\n        Host_Alias SERS=www.nwc.com,10.1.32.0/24\n        Runas_Alias OP=root\n        Cmnd_Alias SYDCMD=/bin/chown,/bin/chmod\n        Cmnd_Alias DSKCMD=/sbin/parted,/sbin/fdisk\n        SYSADER SERS=(OP) SYDCMD,DSKCMD\n\n        表示定义一个用户别名SYSADER，包含用户nwc，user1，和admins组内的所有用户\n\n        定义一个用户别名DISKADER，包含用户tom\n\n        定义主机别名SERS包含主机名为www.nwc.com的这台主机和10.1.32.0/24这个网络内的所有主机 \n\n        定义一个运行身份的别名OP，包含身份是root\n\n        定义一个命令别名SYDCMD，包含命令/bin/chown,/bin/chmod\n\n        定义一个命令别名DSKCMD，包含命令/sbin/parted,/sbin/fdisk\n\n        定义SYSADER用户别名的用户，在SERS定义的主机上，以root身份，运行SYDAMD和DSKCMD定义的命令，也就是nwc、user1和admins组内的所有用户，能够在www.nwc.com这台主机和10.1.32.0/24这个网络内的所有主机上，以root身份运行/bin/chown,/bin/chmod，/sbin/parted,/sbin/fdisk命令\n\n        \n\n例如：\n        User_Alias ADMINUSER = adminuser1,adminuser2\n        Cmnd_Alias ADMINCMD = /usr/sbin/useradd,/usr/sbin/usermod, /usr/bin/passwd [a-zA-Z]*,!/usr/bin/passwd root\n        ADMINUSER ALL=(root) NOPASSWD:ADMINCMD，PASSWD:/usr/sbin/userdel\n\n        表示定义一个ADMINUSER的用户别名，包括adminuser1和adminuser2\n\n        定义一个ADMINCMD命令别名，包括useradd、usermod命令，passwd命令后面跟字母开头的字符串，但不能执行passwd root，也就是不能对root改密\n\n        定义允许adminuser1和adminuser2用户能够在所有主机上，不用输入密码执行useradd、usermod、和passwd定义的相关命令，但是需要密码执行userdel命令\n\n例如\n        Defaults:nwc runas_default=tom\n        nwc ALL=(tom,jerry) ALL\n\n        表示授权nwc用户在所有主机上以tom或Jerry身份，运行所有命令\n\n        上面的Defaults 表示当nwc用sodu执行命令时，如果不用-u指明以谁的身份，则默认以tom的身份执行命令\n\n例如\n        nwc 10.1.32.68,10.1.32.22 = (root)  /usr/sbin/,!/usr/sbin/useradd\n\n        表示授权nwc用户在10.1.32.68和10.1.32.22主机上以root身份执行/user/sbin/下的所有命令，但是不包括useradd命令\n\n例如\n        nwc ALL=(ALL) /bin/cat /var/log/message*\n\n        表示授权nwc用户在所有主机上，以任意身份，运行cat /var/log/message*命令\n\n        注意，此种方式是非常危险的，因为用户可以利用命令 cat /var/log/message  /etc/shadow ….因为*代表任意字符，故后面可以跟上任何文件\n\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}