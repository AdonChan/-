{"title": "大展身手的字典树 - Just For Fun ", "index": "算法,python", "content": "原文地址\n在简单字典树(Trie)的实现一文中，我们以单词输入自动提示为引子，简单介绍了字典树的实现。那么，字典树到底可以用于哪些场合呢？\n\n前缀匹配：给定字典库，输入一段字符，返回以该字符串为前缀的所有单词。\n字频统计：给出一段文本，统计其中指定单词出现的频数。\n\n前缀匹配\n本文讲述前缀匹配的字典树实现方案。仍然假设我们有以下单词：apps apple cook cookie cold，当我们想获得以co为前缀的单词时，只需要在字典树中依次找到c、o节点，然后搜索o节点的所有子树，取出其中的单词即可。\n在简单字典树(Trie)的实现一文中，我们已经实现了字典树的基本操作，这里只需要再加上一个前缀匹配方法即可。具体流程如下，将前缀字符串标记为当前前缀，将根节点标记为当前节点，执行操作1：\n\n当前前缀为空，对当前节点执行操作2。否则，取出当前单词的首字符，标记为X，遍历当前节点的子节点，如果X存在于子节点N中，将N标记为当前节点，将剩余字符串标记为当前单词，重复操作1；如果X不存在于子节点中，返回None。\n以当前节点为根节点，进行深度优先搜索，取得当前节点所有子树下的所有单词。\n\n实现的伪代码如下：\ndef pre_match_op(current_word, current_node):\n    if current_word not empty:\n        X = current_word[0]\n        if X in current_node.child_node:\n            current_word = current_word[1:]\n            current_node = child_node\n            return pre_match_op(current_word, current_node)\n        else:\n            return None\n    else:\n        return pre_match_bfs(\"\", current_node)\n        \ndef pre_match_dfs(keep_char, current_node):\n    match_word = []\n    for child in current_node.child_node:\n        current_pre = pre_str + keep_char\n        if child.isword = True:\n            word = current_pre + child.char\n            match_word.append(word)\n        else:\n            pass\n\n        pre_match_dfs(current_pre, child)\n\n    return match_word\n\n具体程序以及测试例子放在gist上，可以在这里找到。测试了一下，两千多个单词，寻找共同前缀的单词，速度还是蛮快的。\n字频统计\n有时候我们需要统计一篇文章中一些单词出现的次数，这个时候用字典树可以很方便的解决这个问题。\n在字典树的简单实现中，我们设计的节点数据结构如下：\n\n图1. 用list实现字典树\n\n只要对这里节点的数据结构稍作修改，就可以用于统计字频了。把原来数据结构中的标记位改为频数位，即保存该单词出现的次数。然后，再把原有字典树实现中的插入操作和查找操作稍微改动，就可以实现字频统计功能了。\n\n\n插入操作：将单词标记为当前单词，将根节点标记为当前节点，执行操作1：\n\n当前单词为空，当前节点单词出现频数加1，终止操作；否则取出当前单词的首字符记为X，遍历当前节点的子节点：如果X存在于子节点N，将剩余字符标记为当前单词，将N标记为当前节点，重复操作1，如果X不存在于当前节点的子节点中，那么进入操作2。\n取出当前单词的首字符记为X，新建一个节点M存储X，M的父节点为当前节点。剩余字符串记为当前单词，如果当前单词为空，M节点单词出现频数加1，终止操作；否则，将M标记为当前节点，重复操作2。\n\n\n\n查询操作：将单词标记为当前单词，将根节点标记为当前节点，执行操作1：\n当前单词为空，返回当前节点字频数，即为该单词出现的次数。否则，取出当前单词的首字符，标记为X，遍历当前节点的子节点，如果X存在于子节点N中，将N标记为当前节点，将剩余字符串标记为当前单词，重复操作1；如果X不存在于子节点中，返回0。\n\n\n实现伪代码如下，插入操作如下：\ndef insert(word):\n    current_word = word\n    current_node = root\n    insert_operation_1(current_word, current_node)\n\ndef insert_operation_1(current_word, current_node):\n    if current_word not empty:\n        X = current_word[0]\n\n        if X in current_node.child:\n            current_word = current_word[1:]\n            current_node = child_node\n            insert_operation_1(current_word, current_node)\n        else:\n            insert_operation_2(current_word, current_node)\n\n    else:\n        current_node.count++\n\ndef insert_operation_2(current_word, current_node):\n    X = current_word[0]\n    M.value = x\n    M.father = current_node\n    current_node.child = M\n\n    current_word = current_word[1:]\n    if current_word not empty:\n        current_node = M\n        insert_operation_2(current_word, current_node)\n\n    else:\n        current_node.count++\n\n查询操作：\ndef count(word):\n    current_word = word\n    current_node = root\n    return find_opration(current_word, current_node)\n\ndef count_opration(current_word, current_node):\n    if current_word not empty:\n        X = current_word[0]\n        if X in current_node.child_node:\n            current_word = current_word[1:]\n            current_node = child_node\n            return find_opration(current_word, current_node)\n        else:\n            return 0\n    else:\n        return current_node.count\n\n具体程序以及测试例子放在gist上，可以在这里找到。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "2"}