{"title": "Python的__slots__ - late ", "index": "python", "content": "__slots__ 用处\n__slots__的作用是阻止在实例化类时为实例分配dict，默认情况下每个类都会有一个dict,通过__dict__访问，这个dict维护了这个实例的所有属性。\n代码：\n# coding:utf-8\n \n \nclass Base(object):\n    val = 1\n \n    def __init__(self):\n        pass\n \n \nclass BaseSlots(object):\n    val = 1\n    __slots__ = ('y',)\n \n    def __init__(self):\n        pass\n \n \nclass BaseSlots2(object):\n    val = 1\n    y = 2\n    __slots__ = ('y',)\n \n    def __init__(self):\n        pass\n \n \nb1 = Base()\nprint 'b1.__dict__ is ', b1.__dict__  # b1.__dict__ is  {}\nb1.x = 1\nprint 'bi.x = 1, b1.__dict__ is ', b1.__dict__  # bi.x = 1, b1.__dict__ is  {'x': 1}\n \nb2 = BaseSlots()\nprint 'b2.__dict__ is ', b2.__dict__  # AttributeError: 'BaseSlots' object has no attribute '__dict__'\nb2.x = 1  # AttributeError: 'BaseSlots2' object has no attribute 'x'\nb2.y = 3\nprint 'b2.__dict__ is ', b2.__dict__  # AttributeError: 'BaseSlots' object has no attribute '__dict__'\n \nb3 = BaseSlots2()\nprint 'b3.__dict__ is ', b3.__dict__  # AttributeError: 'BaseSlots2' object has no attribute '__dict__'\nb3.x = 1  # AttributeError: 'BaseSlots2' object has no attribute 'x'\nb3.y = 3  # 'BaseSlots2' object attribute 'y' is read-only\nprint 'b3.__dict__ is ', b3.__dict__  # AttributeError: 'BaseSlots2' object has no attribute '__dict__'\n输出\n# Base()输出\nb1.__dict__ is  {}\nbi.x = 1, b1.__dict__ is  {'x': 1}\n\n# BaseSlots()输出\nb2.__dict__ is\nTraceback (most recent call last):\n  File \"test04.py\", line 34, in <module>\n    print 'b2.__dict__ is ', b2.__dict__\nAttributeError: 'BaseSlots' object has no attribute '__dict__'\n\nTraceback (most recent call last):\n  File \"test04.py\", line 35, in <module>\n    b2.x = 1\nAttributeError: 'BaseSlots' object has no attribute 'x'\n\n\nb2.__dict__ is\nTraceback (most recent call last):\n  File \"C:/Users/fred1/PycharmProjects/test/test04.py\", line 37, in <module>\n    print 'b2.__dict__ is ', b2.__dict__\nAttributeError: 'BaseSlots' object has no attribute '__dict__'\n\n# BaseSlots2输出\n  File \"test04.py\", line 40, in <module>\n    print 'b3.__dict__ is ', b3.__dict__\nAttributeError: 'BaseSlots2' object has no attribute '__dict__'\n\nTraceback (most recent call last):\n  File \"test04.py\", line 41, in <module>\n    b3.x = 1\nAttributeError: 'BaseSlots2' object has no attribute 'x'\n\nTraceback (most recent call last):\n  File \"test04.py\", line 42, in <module>\n    b3.y = 3\nAttributeError: 'BaseSlots2' object attribute 'y' is read-only\n\nTraceback (most recent call last):\n  File \"test04.py\", line 43, in <module>\n    print 'b3.__dict__ is ', b3.__dict__\nAttributeError: 'BaseSlots2' object has no attribute '__dict__'\n可见：实例的 __dict__ 只保持实例的变量，对于类的属性是不保存的，类的属性包括变量和函数。由于每次实例化一个类都要分配一个新的dict，因此存在空间的浪费，因此有了__slots__，当定义了__slots__后，__slots__中定义的变量变成了类的描述符，相当于java，c++中的成员变量声明，类的实例只能拥有这些个变量，而不在有__dict__，因此也就不能在增加新的变量。\nPython 是一门动态语言，可以在运行过程中，修改对象的属性和添加修改方法。任何类的实例对象包含一个字典__dict__ (类型为dictproxy)， Python通过这个字典将任意属性绑定到对象上。有时候我们只想使用固定的对象，而不想任意绑定对象，这时候我们可以定义一个属性名称集合，只有在这个集合里的名称才可以绑定。__slots__就是完成这个功能的。\n使用__slots__的主要原因是当你只需要用预定义一系列属性的简单对象，并且不需要携带__dict__方法时来节省空间。_PS：仅在你有大量实例的时候使用。_\n# coding:utf-8\n \nimport sys\nimport pympler.asizeof as sf\n# Pympler is a development tool to measure, monitor and analyze the memory behavior of Python objects in a running Python application.\n \n \nclass Slots(object):\n    pass\n \n \nclass WithSlots(object):\n    __slots__ = ('a', 'b', 'c')\n \n    pass\n \n \nn = Slots()\nn.a, n.b, n.c = 1, 2, 3\nw = WithSlots()\nw.a, w.b, w.c = 1, 2, 3\n \nprint sys.getsizeof(n)  # 32\n\nprint sys.getsizeof(w)  # 36\n \nprint sf.asizeof(n)  # 296\n \nprint sf.asizeof(w)  # 136\n\n# test in Python 2.7.10 \n__slots__允许子类重复继承\n# coding:utf-8\n \nimport sys\nimport pympler.asizeof as sf\n \n \nclass A(object):\n    __slots__ = 'a'\n    pass\n \n \nclass AB(A):\n    __slots__ = 'b'\n    pass\n \n \nab = AB()\nab.a = ab.b = 23\n \n \nclass ABC(A):\n    __slots__ = 'a', 'b'  # 允许重复继承\n    pass\n \n \nabc = ABC()\nabc.a = abc.b = 23\n \nprint sf.asizeof(ab)  # 88\nprint sf.asizeof(abc)  # 96\n# test in Python 2.7.10 \n若子类没有__slots__，父类的__slots__对子类无效。\n>>> class A(object): __slots__ = 'a'\n...\n>>> a = A()\n>>> a.b = 2\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nAttributeError: 'A' object has no attribute 'b'\n>>> class B(A): pass\n...\n>>> b = B()\n>>> b.b = 2\n>>> b.b\n2\n>>>\nNotes on using slots\n\n\nWithout a __dict__ variable, instances cannot be assigned new variables not listed in the __slots__ definition. Attempts to assign to an unlisted variable name raises AttributeError. If dynamic assignment of new variables is desired, then add __dict__ to the sequence of strings in the __slots__ declaration. Changed in version 2.3: Previously, adding __dict__ to the __slots__ declaration would not enable the assignment of new attributes not specifically listed in the sequence of instance variable names.\nWithout a__weakref__ variable for each instance, classes defining __slots__ do not support weak references to its instances. If weak reference support is needed, then add __weakref__ to the sequence of strings in the __slots__ declaration. Changed in version 2.3: Previously, adding __weakref__ to the __slots__ declaration would not enable support for weak references.\n__slots__ are implemented at the class level by creating descriptors (3.4.2) for each variable name. As a result, class attributes cannot be used to set default values for instance variables defined by __slots__; otherwise, the class attribute would overwrite the descriptor assignment.\nIf a class defines a slot also defined in a base class, the instance variable defined by the base class slot is inaccessible (except by retrieving its descriptor directly from the base class). This renders the meaning of the program undefined. In the future, a check may be added to prevent this.\nThe action of a __slots__ declaration is limited to the class where it is defined. As a result, subclasses will have a __dict__ unless they also define __slots__.\n__slots__ do not work for classes derived from ``variable-length'' built-in types such as long, str and tuple.\nAny non-string iterable may be assigned to __slots__. Mappings may also be used; however, in the future, special meaning may be assigned to the values corresponding to each key.\n\n扩展阅读\nSaving 9 GB of RAM with Python’s slots\nWe’ve mentioned before how Oyster.com’s Python-based web servers cache huge amounts of static content in huge Python dicts (hash tables). Well, we recently saved over 2 GB in each of four 6 GB server processes with a single line of code — using __slots__ on our Image class.\nHere’s a screenshot of RAM usage before and after deploying this change on one of our servers:\nWe allocate about a million instances of a class like the following:\nclass Image(object):\n    def __init__(self, id, caption, url):\n        self.id = id\n        self.caption = caption\n        self.url = url\n        self._setup()\n \n    # ... other methods ...\nBy default Python uses a dict to store an object’s instance attributes. Which is usually fine, and it allows fully dynamic things like setting arbitrary new attributes at runtime.\nHowever, for small classes that have a few fixed attributes known at “compile time”, the dict is a waste of RAM, and this makes a real difference when you’re creating a million of them. You can tell Python not to use a dict, and only allocate space for a fixed set of attributes, by settings __slots__ on the class to a fixed list of attribute names:\nclass Image(object):\n    __slots__ = ['id', 'caption', 'url']\n \n    def __init__(self, id, caption, url):\n        self.id = id\n        self.caption = caption\n        self.url = url\n        self._setup()\n \n    # ... other methods ...\nNote that you can also use collections.namedtuple, which allows attribute access, but only takes the space of a tuple, so it’s similar to using __slots__ on a class. However, to me it always feels weird to inherit from a namedtuple class. Also, if you want a custom initializer you have to override __new__ rather than __init__.\nWarning: Don’t prematurely optimize and use this everywhere! It’s not great for code maintenance, and it really only saves you when you have thousands of instances.\n参考\n\n《python __slots__》\nhttp://stackoverflow.com/questions/1816483/python-how-does-inheritance-of-slots-in-subclasses-actually-work\n《Saving 9 GB of RAM with Python’s __slots__》\n《使用__slots__》\n\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "6"}