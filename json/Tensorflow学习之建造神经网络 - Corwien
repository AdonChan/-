{"title": "Tensorflow学习之建造神经网络 - Corwien ", "index": "python,tensorflow", "content": "经过前期的学习，这一节来学习稍微综合一点的，建造一个完整的神经网络，包括添加神经层,计算误差,训练步骤,判断是否在学习。\n添加层\n构造添加一个神经层的函数。\ndef add_layer(inputs, in_size, out_size, activation_function=None):\n    Weights = tf.Variable(tf.random_normal([in_size, out_size]))\n    biases = tf.Variable(tf.zeros([1, out_size]) + 0.1)\n    Wx_plus_b = tf.matmul(inputs, Weights) + biases\n    if activation_function is None:\n        outputs = Wx_plus_b\n    else:\n        outputs = activation_function(Wx_plus_b)\n    return outputs\n导入数据\n构建所需的数据。 这里的x_data和y_data并不是严格的一元二次函数的关系，因为我们多加了一个noise,这样看起来会更像真实情况。\nx_data = np.linspace(-1,1,300, dtype=np.float32)[:, np.newaxis]\nnoise = np.random.normal(0, 0.05, x_data.shape).astype(np.float32)\ny_data = np.square(x_data) - 0.5 + noise\n利用占位符定义我们所需的神经网络的输入。 tf.placeholder()就是代表占位符，这里的None代表无论输入有多少都可以，因为输入只有一个特征，所以这里是1。\nxs = tf.placeholder(tf.float32, [None, 1])\nys = tf.placeholder(tf.float32, [None, 1])\n接下来，我们就可以开始定义神经层了。 通常神经层都包括输入层、隐藏层和输出层。这里的输入层只有一个属性， 所以我们就只有一个输入；隐藏层我们可以自己假设，这里我们假设隐藏层有10个神经元； 输出层和输入层的结构是一样的，所以我们的输出层也是只有一层。 所以，我们构建的是——输入层1个、隐藏层10个、输出层1个的神经网络。\n搭建网络\n下面，我们开始定义隐藏层,利用之前的add_layer()函数，这里使用 Tensorflow 自带的激励函数tf.nn.relu。\nl1 = add_layer(xs, 1, 10, activation_function=tf.nn.relu)\n接着，定义输出层。此时的输入就是隐藏层的输出——l1，输入有10层（隐藏层的输出层），输出有1层。\nprediction = add_layer(l1, 10, 1, activation_function=None)\n计算预测值prediction和真实值的误差，对二者差的平方求和再取平均。\nloss = tf.reduce_mean(tf.reduce_sum(tf.square(ys - prediction),\n                     reduction_indices=[1]))\n接下来，是很关键的一步，如何让机器学习提升它的准确率。tf.train.GradientDescentOptimizer()中的值通常都小于1，这里取的是0.1，代表以0.1的效率来最小化误差loss。\ntrain_step = tf.train.GradientDescentOptimizer(0.1).minimize(loss)\n使用变量时，都要对它进行初始化，这是必不可少的。\n# init = tf.initialize_all_variables() # tf 马上就要废弃这种写法\ninit = tf.global_variables_initializer()  # 替换成这样就好\n定义Session，并用 Session 来执行 init 初始化步骤。 （注意：在tensorflow中，只有session.run()才会执行我们定义的运算。）\nsess = tf.Session()\nsess.run(init)\n训练\n下面，让机器开始学习。\n比如这里，我们让机器学习1000次。机器学习的内容是train_step, 用 Session 来 run 每一次 training 的数据，逐步提升神经网络的预测准确性。 (注意：当运算要用到placeholder时，就需要feed_dict这个字典来指定输入。)\nfor i in range(1000):\n    # training\n    sess.run(train_step, feed_dict={xs: x_data, ys: y_data})\n每50步我们输出一下机器学习的误差。\n\n    if i % 50 == 0:\n        # to see the step improvement\n        print(sess.run(loss, feed_dict={xs: x_data, ys: y_data}))\n完整代码：\nimport tensorflow as tf\nimport numpy as np\n\n# 构造添加神经层函数\ndef add_layer(inputs, in_size, out_size, activation_function=None):\n    Weights = tf.Variable(tf.random_normal([in_size, out_size]))\n    biases = tf.Variable(tf.zeros([1, out_size]) + 0.1)\n    Wx_plus_b = tf.matmul(inputs, Weights) + biases\n    if activation_function is None:\n        outputs = Wx_plus_b\n    else:\n        outputs = activation_function(Wx_plus_b)\n    return outputs\n\nx_data = np.linspace(-1, 1, 300, dtype=np.float32)[:, np.newaxis]\nnoise = np.random.normal(0, 0.05, x_data.shape).astype(np.float32)\ny_data = np.square(x_data) - 0.5 + noise\n\n\n# 定义占位符\nxs = tf.placeholder(tf.float32, [None, 1])\nys = tf.placeholder(tf.float32, [None, 1])\n\n\n# 假设一个输入层，十个隐藏层，一个输出层\nl1 = add_layer(xs, 1, 10, activation_function=tf.nn.relu)\n\n# 定义输出层\nprediction = add_layer(l1, 10, 1, activation_function=None)\n\n# 计算预测值prediction和真实值的误差，对二者差的平方求和再取平均\nloss = tf.reduce_mean(tf.reduce_sum(tf.square(ys - prediction), reduction_indices=[1]))\n\n# 梯度下降\ntrain_step = tf.train.GradientDescentOptimizer(0.1).minimize(loss)\n\n# 初始化变量\ninit = tf.global_variables_initializer()\n\n# Session\nsess = tf.Session()\nsess.run(init)\n\n# 机器开始学习\nfor i in range(1000):\n    # training\n    sess.run(train_step, feed_dict={xs:x_data, ys:y_data})\n    if i % 50 == 0:\n        # to see the step improvement \n        print(sess.run(loss, feed_dict={xs:x_data, ys:y_data}))\n    \n\n结果打印：\n0.19636884\n0.012856119\n0.008055502\n0.0063308137\n0.005578088\n0.0050883116\n0.004656622\n0.0043336144\n0.0040885494\n0.0038989265\n0.0037537257\n0.0036524797\n0.0035737625\n0.003509487\n0.003454599\n0.0034066995\n0.0033646119\n0.0033249983\n0.0032859768\n0.0032486534\n通过上边的结果打印可以看出，误差在逐渐减小，这说明机器学习是有积极的效果的。\n\n注：本文转载自莫烦说TensorFlow\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "3"}