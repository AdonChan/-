{"title": "动态规划法（八）最大子数组问题（maximum subarray problem） - 个人文章 ", "index": "python,分治,动态规划", "content": "问题简介\n  本文将介绍计算机算法中的经典问题——最大子数组问题（maximum subarray problem）。所谓的最大子数组问题，指的是：给定一个数组A，寻找A的和最大的非空连续子数组。比如，数组 A = [-2, -3, 4, -1, -2, 1, 5, -3]， 最大子数组应为[4, -1, -2, 1, 5],其和为7。  首先，如果A中的元素全部为正（或非负数），则最大子数组就是它本身；如果A中的元素全部为负，则最大子数组就是第一个元素组成的数组。以上两种情形是平凡的，那么，如果A中的元素既有正数，又有负数，则该如何求解呢？本文将介绍该问题的四种算法，并给出后面三种算法的Python语言实现，解决该问题的算法如下：\n\n暴力求解\n分治法\nKadane算法\n动态规划法\n\n  下面就这四种算法做详细介绍。\n暴力求解\n  假设数组的长度为n，暴力求解方法的思路是很简单的，就是将子数组的开始坐标和结束坐标都遍历一下，这样共有$C_{n}^{2}$中组合方式，再考虑这所有组合方式中和最大的情形即可。  该算法的运行时间为$O(n^{2})$,效率是很低的。那么，还有其它高效的算法吗？\n分治法\n  分治法的基本思想是将问题划分为一些子问题，子问题的形式与原问题一样，只是规模更小，递归地求解出子问题，如果子问题的规模足够小，则停止递归，直接求解，最后将子问题的解组合成原问题的解。  对于最大子数组，我们要寻求子数组A[low...high]的最大子数组。令mid为该子数组的中央位置，我们考虑求解两个子数组A[low...mid]和A[mid+1...high]。A[low...high]的任何连续子数组A[i...j]所处的位置必然是以下三种情况之一：\n\n完全位于子数组A[low...mid]中,因此$low\\leq i\\leq j \\leq mid.$\n完全位于子数组A[mid+1...high]中,因此$mid< i\\leq j \\leq high.$\n跨越了中点，因此$low \\leq i \\leq mid < j \\leq high.$\n\n因此，最大子数组必定为上述3种情况中的最大者。对于情形1和情形2，可以递归地求解，剩下的就是寻找跨越中点的最大子数组。  任何跨越中点的子数组都是由两个子数组A[i...mid]和A[mid+1...j]组成，其中$low \\leq i \\leq mid$且$mid<j\\leq high$.因此，我们只需要找出形如A[i...mid]和A[mid+1...j]的最大子数组，然后将其合并即可，这可以在线性时间内完成。过程FIND-MAX-CROSSING-SUBARRAY接收数组A和下标low、mid和high作为输入，返回一个下标元组划定跨越中点的最大子数组的边界，并返回最大子数组中值的和。其伪代码如下：\nFIND-MAX-CROSSING-SUBARRAY(A, low, mid, high):\nleft-sum = -inf\nsum = 0\nfor i = mid downto low\n    sum = sum + A[i]\n    if sum > left-sum\n        left-sum = sum\n        max-left = i\n        \nright-sum = -inf\nsum = 0\nfor j = mid+1 to high\n    sum = sum + A[j]\n    if sum > right-sum\n        right-sum = sum\n        max-right = i\n        \nreturn (max-left, max-right, left-sum+right+sum)\n  有了FIND-MAX-CROSSING-SUBARRAY我们可以找到跨越中点的最大子数组，于是，我们也可以设计求解最大子数组问题的分治算法了，其伪代码如下：\nFIND-MAXMIMUM-SUBARRAY(A, low, high):\nif high = low\n    return (low, high, A[low])\nelse \n    mid = floor((low+high)/2)\n    (left-low, left-high, left-sum) = FIND-MAXMIMUM-SUBARRAY(A, low, mid)\n    (right-low, right-high, right-sum) = FIND-MAXMIMUM-SUBARRAY(A, mid+1, high)\n    (cross-low, cross-high, cross-sum) = FIND-MAXMIMUM-SUBARRAY(A, low, mid, high)\n    \n    if left-sum >= right-sum >= cross-sum\n        return (left-low, left-high, left-sum)\n    else right-sum >= left-sum >= cross-sum\n        return (right-low, right-high, right-sum)\n    else\n        return (cross-low, cross-high, cross-sum)\n  显然这样的分治算法对于初学者来说，有点难度，但是熟能生巧, 多学多练也就不难了。该分治算法的运行时间为$O(n*logn).$\nKadane算法\n  Kadane算法的伪代码如下：\nInitialize:\n    max_so_far = 0\n    max_ending_here = 0\n\nLoop for each element of the array\n  (a) max_ending_here = max_ending_here + a[i]\n  (b) if(max_ending_here < 0)\n            max_ending_here = 0\n  (c) if(max_so_far < max_ending_here)\n            max_so_far = max_ending_here\nreturn max_so_far\n  Kadane算法的简单想法就是寻找所有连续的正的子数组（max_ending_here就是用来干这事的），同时，记录所有这些连续的正的子数组中的和最大的连续数组。每一次我们得到一个正数，就将它与max_so_far比较，如果它的值比max_so_far大，则更新max_so_far的值。\n动态规划法\n   用MS[i]表示最大子数组的结束下标为i的情形，则对于i-1，有：$$MS[i] = max\\{MS[i-1], A[i]\\}.$$这样就有了一个子结构，对于初始情形，$MS[1]=A[1].$遍历i, 就能得到MS这个数组，其最大者即可最大子数组的和。\n总结\n   可以看到以上四种算法，每种都有各自的优缺点。对于暴力求解方法，想法最简单，但是算法效率不高。Kanade算法简单高效，但是不易想到。分治算法运行效率高，但其分支过程的设计较为麻烦。动态规划法想法巧妙，运行效率也高，但是没有普遍的适用性。\nPython程序\n   下面将给出分治算法，Kanade算法和动态规划法来求解最大子数组问题的Python程序， 代码如下：\n# -*- coding: utf-8 -*-\n__author__ = 'Jclian'\n\nimport math\n\n# find max crossing subarray in linear time\ndef find_max_crossing_subarray(A, low, mid, high):\n    max_left, max_right = -1, -1\n\n    # left part of the subarray\n    left_sum = float(\"-Inf\")\n    sum = 0\n    for i in range(mid, low - 1, -1):\n        sum += A[i]\n        if (sum > left_sum):\n            left_sum = sum\n            max_left = i\n\n    # right part of the subarray\n    right_sum = float(\"-Inf\")\n    sum = 0\n    for j in range(mid + 1, high + 1):\n        sum += A[j]\n        if (sum > right_sum):\n            right_sum = sum\n            max_right = j\n\n    return max_left, max_right, left_sum + right_sum\n\n# using divide and conquer to solve maximum subarray problem\n# time complexity: n*logn\ndef find_maximum_subarray(A, low, high):\n    if (high == low):\n        return low, high, A[low]\n    else:\n        mid = math.floor((low + high) / 2)\n        left_low, left_high, left_sum = find_maximum_subarray(A, low, mid)\n        right_low, right_high, right_sum = find_maximum_subarray(A, mid + 1, high)\n        cross_low, cross_high, cross_sum = find_max_crossing_subarray(A, low, mid, high)\n        if (left_sum >= right_sum and left_sum >= cross_sum):\n            return left_low, left_high, left_sum\n        elif (right_sum >= left_sum and right_sum >= cross_sum):\n            return right_low, right_high, right_sum\n        else:\n            return cross_low, cross_high, cross_sum\n\n# Python program to find maximum contiguous subarray\n# Kadane’s Algorithm\ndef maxSubArraySum(a, size):\n    max_so_far = float(\"-inf\")\n    max_ending_here = 0\n\n    for i in range(size):\n        max_ending_here = max_ending_here + a[i]\n        if (max_so_far < max_ending_here):\n            max_so_far = max_ending_here\n\n        if max_ending_here < 0:\n            max_ending_here = 0\n\n    return max_so_far\n\n# using dynamic programming to slove maximum subarray problem\ndef DP_maximum_subarray(arr):\n    t = len(arr)\n    MS = [0]*t\n    MS[0] = arr[0]\n\n    for i in range(1, t):\n        MS[i] = max(MS[i-1]+arr[i], arr[i])\n\n    return MS\n\ndef main():\n    # example of array A\n    A = [13,-3,-25,20,-3,-16,-23,18,20,-7,12,-5,-22,15,-4,7]\n    # A = [-2, 2, -3, 4, -1, 2, 1, -5, 3]\n    # A = [0,-2, 3, 5, -1, 2]\n    # A = [-9, -2, -3, -5, -3]\n    # A = [1, 2, 3, 4, 5]\n    # A = [-2, -3, 4, -1, -2, 1, 5, -3]\n\n    print('using divide and conquer...')\n    print(\"Maximum contiguous sum is\",find_maximum_subarray(A, 0, len(A) - 1), '\\n')\n\n    print('using Kanade Algorithm...')\n    print(\"Maximum contiguous sum is\", maxSubArraySum(A, len(A)), '\\n')\n\n    print('using dynamic programming...')\n    MS = DP_maximum_subarray(A)\n    print(\"Maximum contiguous sum is\", max(MS), '\\n')\n\nmain()\n输出结果如下：\nusing divide and conquer...\nMaximum contiguous sum is (7, 10, 43) \n\nusing Kanade Algorithm...\nMaximum contiguous sum is 43 \n\nusing dynamic programming...\nMaximum contiguous sum is 43 \n参考文献\n\n算法导论（第三版） 机械工业出版社\nhttps://www.geeksforgeeks.org...\nhttps://algorithms.tutorialho...\n\n注意：本人现已开通两个微信公众号： 用Python做数学（微信号为：python_math）以及轻松学会Python爬虫（微信号为：easy_web_scrape）， 欢迎大家关注哦~~\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}