{"title": "使用python调用ffmpeg的录制项目总结 - 林潇的开发日常 ", "index": "python,ffmpeg,innosetup,pyqt,录制屏幕", "content": "录制项目终于做完，不用总是提醒自己抓紧时间这样来想问题了。在完成之后带着一些满足感，回头看看哪些地方是需要改进的，哪些地方又是有更好的替代方案，自己又有哪些不足。\n下面按照软件的各部分分别做作总结：\n0. 软件应用场景：\n  客户希望用视频+音频的方式录制下会议的内容。除了录制会议室情况之外，会议中还有可能需要录制电脑屏幕内容，比如在做PPT讲解等，所以需要一个在两种录制方式之间快捷切换的软件。除此之外，需要一个防止复制运行的机制和完整的安装包。\n1. 核心：subprocess子进程运行控制。\n  由应用来看，关键是录制屏幕和录制摄像头，以及用快捷键控制在这两者之间切换。    我的实现是通过python3调用ffmpeg，ffmpeg实现录制，python来完成切换。  从开发角度来说，并不算难，抛去录制这个功能，这个软件实际上应该这样描述：python完全控制ffmpeg.exe进程的应用。  进一步地说，ffmpeg能做到的，软件大部分都可以做到，不同的是可以添加快捷键控制等，可以用python对除了ffmpeg功能之外做一些必要的补充。比如，客户在需求实现之前测试发现win10系统下自买的摄像头运行时间长了之后会随机的中断录制，卖家也无办法解决，因为是win10系统兼容性问题。所以客户提出在录制异常中断的情况下，能够自动重新开始录制。这个需求的满足就依赖python对ffmpeg的补充。  另外，完全控制ffmpeg进程关键在于如何自然退出。ffmpeg在cmd运行按下q键是退出，利用这一点往子进程输入流写入'q'实现了自然退出，保证了数据的正常写入和保存，并且不会引发异常情况。如果不得益于这一点，用os.kill(process_id)等方式都很难去控制进程的正常退出。    下面是代码结构简化版思维导图：\n2. 界面和pyqt5：\n  界面相当的简单，主界面是一个按钮+录制时间显示。  \n  功能性的右键菜单：  \n  设置界面：\n  软件为了客户方便定制化使用，提供了必要的参数设置。实现时用到了configparser。快捷键部分还有待完善。\n  \n  程序主要的录制状态变化通过托盘图标的来展示。三种录制状态的托盘图标如下：  为了尽可能少的让主界面出现在录制内容中，当失去焦点时，窗口就会隐藏，这大概也就是客户能够容忍的原因:)。  界面实现用的是pyqt5，因为以前自己做过c#的winform和java的swing开发，界面的处理逻辑又大同小异，所以参照着qt的文档这块能够比较顺手的处理。  pyqt源自qt，而qt的文档非常全面，参照着文档在写pyqt代码时注意一点与c++语法的区别就好了。  如果能够更深入的用pyqt开发，有想过写一篇《qt大局观》的总结，就是整理一下图形界面开发的模型以及与qt相比的相同点不同点，一来是自己觉得如果有这样一篇大局观的介绍文章能够帮助自己节省大量的时间；二来能够帮助从其他语言切换到qt或者新学习qt的开发人员在查询qt文档之前有更清晰的思路，那就更好了。  如果要写这篇文章大致从以下几个方面入手：\n共同性，比如都是基于事件驱动通常有哪些常用或特别的控件？每个或某类控件都有哪些通用的事件？窗体加载机制有何不同？在qt开发时又是怎么样的？ 具体一点，比如quitOnLastWindowClosed()的效果是怎样的？会带来什么问题？qt的信号槽机制相比winform事件机制有何不同？等等。\n3. 简易的防复制运行机制\n  这个机制的目的是限制不是通过安装包安装的，运行都要受到限制。限制条件是超过三个月快捷键失效。实现分两步：\n1.安装时在注册表特定位置，假如是A，写入目录相关信息。2.在程序运行时，检测当前目录是否存在于注册表A下。\n  具体实现时，A位置下保存两类信息，一类是正常安装的目录，比如以'INSTALL+时间'为键名称，值为安装目录，时间用以区分多次安装；另一类是在非安装目录第一次运行的时间，实际就一个而且不可改变，这样保证了所有非安装目录都有同一个时间限制基础。  更完善的实现应该对所有的键值加密处理。\n4. 软件打包，包括cx_Freeze编译和inno setup打包安装文件。\n  这是第一个有自己署名的软件，也是第一次从无到有完整的做出一个有安装包的软件。  软件打包分成了两步：\n\n\n用cx_Freeze将python代码编译为exe文件。编译python代码为exe一般常见的工具有py2exe、pyinstaller、cx_Freeze等，因为这次开发用的python3.6，而只有cx_Freeze对3.6支持最好，所以自然也就用了cx_Freeze。原本网上的教程看到cx_Freeze也是可以定制打包复杂安装文件的，但是在自己的实验过程中始终在access数据库相关的模块报错。使用bdist_msi生成的简单安装包不够用，而且中文支持不好。然后仔细看过一篇文档，发现cx_Freeze推荐的inno setup。\n\n用inno setup定制软件安装包。按照inno setup默认的生成安装包向导实验一遍后，发现这东西太强了太好用了，前面花在cx_Freeze上折腾的时间简直是浪费。inno setup使用类似配置文件的结构来定制安装包所需要的功能。最常用的应该是[Tasks]即任务节点，在该节点下面定义安装包需要执行的任务。任务属性有名称、描述、触发条件、可选属性等，其他节点可通过任务的名称来关联任务。比如给用户添加是否开机启动的选择项，首先定义任务:\n[Tasks]\nName: \"startupicon\"; Description: \"开机启动\"; GroupDescription: \"{cm:AdditionalIcons}\"; Flags: unchecked \n然后，当这个任务startupicon被选中需要执行时，在用户电脑的启动目录添加快捷方式：\n[Icons]\nName: \"{userstartup}\\{#MyAppName}\"; Filename: \"{app}\\{#MyAppExeName}\"; Tasks: startupicon\n这里[Icons]节点和[Tasks]关联起来的属性就是[Icons]的Tasks: startupicon。其他的Files等节点也可以用同样的方式关联任务。一个完整的inno配置文件在保证逻辑性的同时还非常简洁，这一点非常强大。本项目的打包文件参见目录中的setup.iss文件。不过它的强大还不止于这一点，另一个原因是inno自带一个叫Pascal的脚本语言，这可就让可定制性直接上升一个台阶。Pascal不仅内置常用的函数，还可以自己写Pascal代码。看过示例脚本过后，也就不难想象现在的下载网站下载下来的安装包有各种各样的广告是怎么实现的了。\n\n\n5. 不能再忘的git和代码开源\n  版本管理软件对开发人员来说就像一个保险柜一样，重要性不言而喻。以前自己总是零零碎碎的接触到git，始终没有用git真正的来管理一个项目，这次利用这个软件正好好好的学习git，不能再忘了。  以下自己按照使用逻辑再手敲一遍常用git（version:2.16.2.windows)管理命令及注释：\n    git init 梦开始的地方\n    git status 查看项目状态，使用率最高\n    git add <file>/. 将文件修改让git管理\n    git reset HEAD <file> 撤销git管理\n    git checkout -- <file> 撤销修改(未add之前)\n    \n    git rm [-r] <file> 删除git已管理的文件，文件被删除\n    git rm [-r] --cached <file> 撤销git已管理的文件，文件仍存在\n    撤销删除跟撤销修改一样.\n    \n    git commit -m '注释' 提交修改并备注修改缘由\n    git log 提交记录\n    git reflog 命令历史记录\n    git reset --hard HEAD^^/HEAD~2/commit_id 回退到上上个版本或者回到指定commit_id版本\n    \n    git pull origin master  与远程仓库origin下的master分支同步 \n    git push origin master 将本地的修改推送到远程仓库origin下的master分支\n    \n    git remote -v 查看远程仓库信息\n    git branch 查看全部分支\n    git branch <branch_name> 创建分支\n    git checkout <branch_name> 切换到分支\n    git checkout -b <branch_name> 创建分支并切换到该分支\n    git branch -d/-D <branch_name> 删除分支\n    \n    git merge [--no-ff保留分支信息] <branch_name> 合并分支\n    \n    git stash [list] [apply恢复] [drop删除] [pop恢复并删除] 将修改临时保存\n暂时熟练的就这些，以后再更新。另，软件代码发布在record-camera-and-screen。创建了两个分支gutin和dev。gutin是给客户的版本，dev是自己想在这个软件上进一步的完善。\n6. 交付效果：\n  软件运行效果：在分辨率为1024x768、帧率30/s、h264编码、i5 cpu threads=4的情况下录制，cpu占有率保持在30%~40%之间（这是ffmpeg的功劳）。  开发分两次提出，客户第一次的需求主要是录制，第二次是调整和增加附加功能。两次合作及时完成了客户的需求，都得到了用户满意的反馈。\n7. 项目收获：\n\n加深了对python的了解，更熟练的编写python代码。\n\n在开发过程中，练习使用git管理自己的代码。并且利用版本回退帮助自己查找bug引发的原因，相信以后git会成为我开发工作中必不可少的帮手。这次不同的是，是在自己一手写出来的代码基础上进行管理，所以得心应手很多。以往总是试着去github上clone别人的项目别人的代码，作为一个新手，自己首先就面对的是不熟悉的项目和代码，如果说在这个基础上再学习git的操作和概念，其实是很难的。所以以前总是没能好好的掌握git。\n\n开发这个软件第一目的是再学习如何解决在开发过程中遇到的问题。这次开发遇到最大的难题是write(q),为什么这么说？确定是不是采用python+ffmpeg.exe的形式来实现的关键点在于对ffmpeg.exe进程的完全控制。首先，查看了subprocess的文档，确定了完全控制一个子进程不成问题；然后在cmd下实验了摄像头录制和屏幕录制，就是ffmpeg在单独运行的情况下，实现录制功能。这两点实验过后都没有问题，然后自以为两者的结合会顺其自然的顺利。结果就卡在了停止录制时，怎么处理ffmpeg进程的退出方式。第一次实验是Popen.terminate()和kill(),实际发现ffmpeg根本无动于衷。[原因待确认]然后用Popen.send_signal(CTRL_C_EVENT)确实是可以控制ffmpeg进程退出了，结果看录制的视频，最后一部分录制内容丢失了，很显然是ffmpeg不正常退出导致的。由此也明白了，光退出还不行，还得自然的退出。虽然知道凡强制的方式必定不是自然的，期间抱着试试的态度也用到了os.kill()，结果果然不如人愿。然后回头复盘，想着CTRL_C_EVENT是模拟按键进行退出，那么模拟q键退出是不是可行呢？CTRL_C_EVENT是python提供的，那么怎么模拟自定义按键呢？接着就尝试了stdin.write('q')方式，结果令人振奋，不仅录制内容完整，而且没有强制退出时偶尔引起的程序异常。事实证明这样的处理方式是最自然的。还记得当时解决这个难题是多么的开心和满足，这种满足感也正是自己的开发乐趣所在。不过解决旧问题的同时，常常也许会引发新的问题。与输入流交互的write('q')方式也就必须让Popen(universal_newlines=True)，而这后面也凸显了ffmpeg对中文支持不太友好的问题，不过都得到了解决。\n\n\n最后经过这个软件的开发，让自己从整体上对软件有了一个新的认识。任何一个软件简洁到可以用一句话说清楚。知道最终的目的是什么，从一个模型框架开始，我们所做的工作无非就是在这个模型之上添砖加瓦。软件的不同之处在于，包含的砖瓦种类数目，每种砖每个瓦的开发难度，以及它们用什么样的方式合在一起。最终构建成一座高楼大厦。收获了完成一件作品时的喜悦，同时，也看到了自己能力的局限性。想构建更强更大的软件不光是要提升自己的能力，找到一个好的团队，并一起合作创造才是最佳途径。\n\n\n8. 未来改进计划：\n完善快捷键录制状态切换音效和添加动画【学习pyqt的绘制】视频输出优化：添加水印和标签等界面美化：用圆形框取代方形按钮添加支付接口\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}