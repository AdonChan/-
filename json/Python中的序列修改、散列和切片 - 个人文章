{"title": "Python中的序列修改、散列和切片 - 个人文章 ", "index": "python", "content": "导语：本文章记录了本人在学习Python基础之面向对象篇的重点知识及个人心得，打算入门Python的朋友们可以来一起学习并交流。\n本文重点：\n1、了解协议的概念以及利用__getitem__和__len__实现序列协议的方法；2、掌握切片背后的__getitem__；3、掌握动态访问属性背后的__getattr__和__setattr__;4、掌握实现可散列对象背后精简的__hash__和__eq__。\n注：本文介绍的vector类将二维vector类推广到多维，跟不上本文的朋友可以移步至《编写符合Python风格的对象》先了解二维向量类的编写。\n一、基本的序列协议\n首先，需要就n维向量和二维向量的显示、模的计算等差异重新调整。n维向量的设计包括初始化，迭代，输出，向量实例转为字节序列，求模，求布尔值，比较等内容，代码如下：\nimport math\nimport reprlib\nfrom array import array\n\nclass Vector:\n    typecode='d'\n    def __init__(self,components):\n        self._components=array(self.typecode,components)\n\n    def __str__(self):\n        return str(tuple(self))\n\n    def __iter__(self):\n        return iter(self._components)\n\n    def __repr__(self):\n        classname=type(self).__name__\n        components=reprlib.repr(self._components)\n        components=components[components.find('['):-1]\n        return \"{}({})\".format(classname,components)\n\n    def __eq__(self, other):\n        return tuple(self)==tuple(other)\n\n    def __abs__(self):\n        return math.sqrt(sum(x*x for x in self))\n\n    def __bytes__(self):\n        return (bytes(self.typecode,encoding='utf-8')+\n                bytes(array(self.typecode,self._components)))\n\n    def __bool__(self):\n        return bool(abs(self)\n\n    @classmethod\n    def frombytes(cls,seqs):\n        typecode=chr(seqs[0])\n        memv=memoryview(seqs[1:]).cast(typecode)\n        return cls(memv)\n在Python中创建功能完善的序列类型无需使用继承，只需要实现符合序列协议的__len__和__getitem__，具体代码实现如下：\nclass Vector:\n    #省略中间代码\n    def __len__(self):\n        return len(self._components)\n    \n    def __getitem__(self, item):\n        return self._components[item]\n在面向对象编程中，协议是非正式的接口，没有强制力。因此如果知道类的具体使用场景，实现协议中的一部分也可以。例如，为了支持迭代只实现__getitem__方法即可。\n二、切片原理\n1、了解切片的行为\n在对序列切片(slice)的操作中，解释器允许切片省略start,stop,stride中的部分值甚至是全部省略。通过dir(slice)查阅发现，是切片背后的indices在做这个工作。indices方法会整顿存储数据属性的元组，把start,stop,stride都变成非负数，而且都落在指定长度序列的边界内。例如slice(-3,None,None).indices(5)整顿完毕之后是（2,5,1）这样合理的切片。\n2、关键的__getitem__方法\n__getitem__是支持迭代取值的特殊方法。我们将上文的__getitem__改造成可以处理切片的方法，改造需要考虑到处理参数是否为合理切片，合理切片的操作结果是产生新的向量实例。\n    def __getitem__(self, index):\n        cls=type(self)\n        if isinstance(index,slice):\n            return cls(self._components[index])#判断参数为切片时返回新的向量实例\n        elif isinstance(index,numbers.Integral):\n            return self._components[index]#判断参数为数值时返回对应的数值\n        else:\n            msg=\"{cls.__name__} indices must be integers\"\n            raise TypeError(msg.format(cls=cls))#判断参数不合理时抛出TypeError\n三、动态存取属性\n1、访问向量分量:__getattr__\nn维向量没有像二维向量一样把访问分量的方式直接在__init__中写入，由于传入的维数不确定无法采取穷举分量的原始方法，为此我们需要借助__getattr__实现。假设n维向量最多能处理6维向量，访问向量分量的代码实现如下：\n    shortcut_names='xyztpq'\n    def __getattr__(self, name):\n        cls=type(self)\n        if len(name)==1:\n            index=cls.shortcut_names.find(str(name))#若传入的参数在备选分量中可进行后续处理\n            if 0<=index<len(self._components):#判断分量的位置索引是否超出实例的边界\n                return self._components[index]\n        else:\n            msg = \"{.__name__} doesn't have attribute {!r}\"\n            raise AttributeError(msg.format(cls,name))#不支持非法的分量访问，抛出Error。\nTips：代码严谨之处在于传入的参数即使在备选分量之中，也有可能会超出实例的边界，因此涉及到索引和边界需要认真注意这一点。\n2、保持行为一致:__setattr__\n尽管我们实现了__getattr__，但事实上目前的n维向量存在行为不一致的问题，先看一段代码：\nv=Vector(range(5))\nprint(v.y)#输出1.0\nv.y=6\nprint(v.y)#输出6\nprint(v)#输出(0.0, 1.0, 2.0, 3.0, 4.0)\n上面的例子显示我们可以访问6维向量的y分量，但是问题在于我们为y分量赋值的改动没有影响到向量实例v。这种行为是不一致的，并且还没有抛出错误令人匪夷所思。本文中我们希望向量分量是只读不可变的，也就是说我们要对修改向量分量这种不当的行为抛出Error。因此需要额外构造__setattr__，代码实现如下：\n    def __setattr__(self, key, value):\n        cls=type(self)\n        if len(key)==1:\n            if key in self.shortcut_names:\n                error=\"can't set value to attribute {attr_name!r}\"\n            elif key.islower():\n                error=\"can't set attributes 'a' to 'z' in {cls_name!r}\"\n            else:\n                error=\"\"\n            if error:#写嵌套语句的时候要始终把握住逻辑思路。\n                msg = error.format(cls_name=cls.__name__, attr_name=key)\n                raise AttributeError(msg)\n        super().__setattr__(key,value)#在超类上调用__setattr__方法来提供标准行为。\n小结：如果定义了__getattr__方法，那么也要定义__setattr__方法，这样才能避免行为不一致。\n四、可散列的对象\n可散列对象应满足的三个条件在此不再赘述，对于n维向量类而言需要做两件事将其散列化：\n1、利用异或运算符构造__hash__\n构造思路是将hash()应用到向量中的每个元素，并用异或运算符进行聚合计算。由于处理的向量维数提高，采用归约函数functools.reduce处理。\nimport operator\nfrom functools import reduce\n    def __hash__(self):\n        hashes=map(hash,self._components)\n        return reduce(operator.xor,hashes)\n2、通过zip优化n维向量的比较方法__eq__\n上文初始给出的比较方法是粗糙的，下面针对两个维数均不确定的向量进行比较，代码如下：\n def __eq__(self, other):\n     if len(self)!=len(other):#数组数量的比较很关键\n         return False\n     for x,y in zip(self,other):\n         if x!=y:\n             return False\n     return True\n数组数量的比较时很关键的，因为zip在比较数量不等的序列时会随着一个输入的耗尽而停止迭代，并且不抛出Error。回到正题，上述的逻辑关系可以进一步精简。通过all函数可以把for循环替代：\n    def __eq__(self, other):\n         return len(self)==len(other) and all(x==y for x,y in zip(self,other))\n本人更喜欢后者这种简洁且准确的代码书写方式。\n五、格式化显示\n理解n维向量的超球面坐标（r,θ1，θ2，θ3，...，θn-1）计算公式需要额外的数学基础，此处的格式化输出在本质上与《编写符合Python风格的对象》中的格式化输出并无明显区别，此处不作详述，感兴趣的朋友可以查看如下的代码：\n    def angle(self, n): #使用公式计算角坐标\n        r = math.sqrt(sum(x * x for x in self[n:]))\n        a = math.atan2(r, self[n-1])\n        if (n == len(self) - 1) and (self[-1] < 0):\n            return math.pi * 2 - a\n        else:\n            return a\n\n    def angles(self): \n        return (self.angle(n) for n in range(1, len(self)))#计算所有角坐标并存入生成器表达式中\n\n    def __format__(self, fmt_spec=''):\n        if fmt_spec.endswith('h'): # 超球面坐标标识符\n             fmt_spec = fmt_spec[:-1]\n            coords = itertools.chain([abs(self)],self.angles()) #利用itertools.chain无缝迭代模和角坐标\n            outer_fmt = '<{}>' \n        else:\n            coords = self\n            outer_fmt = '({})' \n        components = (format(c, fmt_spec) for c in coords) #格式化极坐标的各元素并存入生成器中\n        return outer_fmt.format(', '.join(components)) \n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}