{"title": "head first python（第五章）–学习笔记 - 线上猛如虎，线下怂如鼠（WhyNotBetter） ", "index": "python", "content": "\n\n1.排序有两种方式\n\n原地排序（in-place sorting），按指定的顺序排列数据，然后用排序后的数据替换原来的数据。原来的顺序会丢失。\n\nsort()\n\n\n复制排序（copied sorting）,按你指定的顺序排序，然后返回原数据的一个有序副本。原数据的顺序依然保留。\n\nsorted()\n\n\n\n  方法串联（method chaining）\n  \n  第一个方法应用到数据中，然后再将处理好的数据应用到第二个方法中。从左向右读。\n  \n  例子：\n  \n  data.strip().split(',')\n  \n  函数串联（function chaining）\n  \n  每个函数会取得数据，对他完成某个操作，然后把转换后的数据继续向下传递到下一个函数。 从右向左读。\n  \n  例子：\n  \n  print(sorted(james))\n\n\n2.数据不一致导致排序中出现问题，需要整理数据\n\n创建一个函数，传入时间参数，然后将不一致的（-，：）数据清除掉，然后将其分割为分和秒，然后整合在一起，形成统一时间格式  MM:SS 。\n\ndef sanitize(time_string):\n    if '-' in time_string:\n        splitter = '-'\n    elif ':' in time_string:\n        splitter = ':'\n    else:\n        return(time_string)\n    (mins, secs) = time_string.split(splitter)\n    return(mins + '.' + secs)\n\n\n然后修改代码\n\ndef sanitize(time_string):\n    if '-' in time_string:\n        splitter = '-'\n    elif ':' in time_string:\n        splitter = ':'\n    else:\n        return(time_string)\n    (mins, secs) = time_string.split(splitter)\n    return(mins + '.' + secs)\n\nwith open('james.txt') as jaf:\n    data = jaf.readline()\njames = data.strip().split(',')\n\nwith open('julie.txt') as juf:\n    data = juf.readline()\njulie = data.strip().split(',')\n\nwith open('mikey.txt') as mif:\n    data = mif.readline()\nmikey = data.strip().split(',')\n\nwith open('sarah.txt') as saf:\n    data = saf.readline()\nsarah = data.strip().split(',')\n\nclean_james = []\nclean_julie = []\nclean_mikey = []\nclean_sarah = []\n\n---------臃肿的部分------------\nfor each_t in james:\n    clean_james.append(sanitize(each_t))\n\nfor each_t in julie:\n    clean_julie.append(sanitize(each_t))\n\nfor each_t in mikey:\n    clean_mikey.append(sanitize(each_t))\n\nfor each_t in sarah:\n    clean_sarah.append(sanitize(each_t))\n\nprint(sorted(clean_james))\nprint(sorted(clean_julie))\nprint(sorted(clean_mikey))\nprint(sorted(clean_sarah))\n---------臃肿的部分------------\n\n\n3.不过代码看来十分臃肿，学会使用推导列表\n\nclean_mikey = []\n\nfor each_t in mikey:\n    clean_mikey.append(sanitize(each_t))\n\n\n变成\n\nclean_mikey = [sanitize(each_t) for each_t in mikey]\n\n新列表         转换方法            for循环       列表\n\n\nappend动作隐含在里面了。\n\n推导列表有点奇怪，不过写多几次就熟悉了。\n\n[m * 60 for m in mins]\n\n[s.upper() for s in lower]\n\n[float(s) for s in clean]\n\n\n使用推导列表后，程序简化了\n\nprint(sorted([sanitize(t) for t in james]))\nprint(sorted([sanitize(t) for t in julie]))\nprint(sorted([sanitize(t) for t in mikey]))\nprint(sorted([sanitize(t) for t in sarah]))\n\n\n4.只需要前三项数据\n\n可以使用列表分片\n如：\n\njames[0:3]\n\n\n5.删除重复项\n\n有2种方法：\n1.用集合的方法，集合的特性是数据是无序的，而且不允许重复。\n\njames = {10.6,11,10.6}\n\ndistances = set（james）  #set()就是集合的方法\n\n\n这样distances出来的数据就是无序且不重复的。\n\n2.用遍历的方法\n\nunique_james = []\nfor each_t in james:\n    if each_t not in unique_james:  #判断是否在数组中，不在就放进新的数组\n        unique_james.append(each_t)\n\n\n\n\n  BTW：\n  python中有两种类型的列表，一种是可以改变的列表（用中括号包围），一种是不可改变的列表（用小括号包围）-叫元组tuple，还有一种不是列表，是集合，用大括号包围。\n\n\n\n原文引用：http://www.godblessyuan.com/2015/04/27/head_first_python_chapter_5_lea...\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "2"}