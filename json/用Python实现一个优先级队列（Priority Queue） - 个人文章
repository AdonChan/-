{"title": "用Python实现一个优先级队列（Priority Queue） - 个人文章 ", "index": "python,数据结构", "content": "堆（Heap）\n在实现一个优先队列之前，先简单介绍 heap（堆）的概念。堆，是对于每一个父节点上的值都小于或等于子节点的值的二叉树。此外，一个堆必须是一个完整的二叉树，除了最底层其他每一级必须是被完整填充的。因此，堆的最重要的一个特点就是：首项heap[0]总是最小的一项。 \n而堆化（heapify）则是将一个二叉树转化为一个堆数据结构的过程。在Python中，我们可以用自带heapq模块中的heapify(x)函数来实现将一个列表 x 转化为一个堆。时间复杂度为线性O(N). 代码如下:\n>>> import heapq\n>>> x = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]\n>>> heap = list(x)\n>>> heapq.heapify(heap)\n>>> heap\n[-4, 2, 1, 23, 7, 2, 18, 23, 42, 37, 8]\n\n\nheap 是被\"堆化\"后的列表，heap[0] = -4为最小项。注意：此时heap 的数据类型仍是一个list。\n另外，可以用heappop(), heappush()，heapreplace()等方法来对一个堆列表进行操作。例如，heappop()会从堆列表中拿出并返回最小项，并且使堆保持不变（即heap[0]仍为最小项）。\n>>> heapq.heappop(heap)    -4    >>> heapq.heappop(heap)    1    >>> heapq.heappop(heap)    2    >>> heap    [2, 7, 8, 23, 42, 37, 18, 23]\n优先级队列（Priority Queue）\n优先级队列的特点：\n\n给定一个优先级（Priority）\n每次pop操作都会返回一个拥有最高优先级的项\n\n代码如下：\nimport heapq\n\nclass PriorityQueue(object):\n    def __init__(self):\n        self._queue = []        #创建一个空列表用于存放队列\n        self._index = 0        #指针用于记录push的次序\n    \n    def push(self, item, priority):\n        \"\"\"队列由（priority, index, item)形式的元祖构成\"\"\"\n        heapq.heappush(self._queue, (-priority, self._index, item)) \n        self._index += 1\n        \n    def pop(self):\n        return heapq.heappop(self._queue)[-1]    #返回拥有最高优先级的项\n\nclass Item(object):\n    def __init__(self, name):\n        self.name = name\n\n    def __repr__(self):\n        return 'Item: {!r}'.format(self.name)\n\nif __name__ == '__main__':\n    q = PriorityQueue()\n    q.push(Item('foo'), 5)\n    q.push(Item('bar'), 1)\n    q.push(Item('spam'), 3)\n    q.push(Item('grok'), 1)\n    for i in range(4):\n        print(q._queue)\n        print(q.pop())\n\n\n对队列进行4次pop()操作，打印结果如下：\n[(-5, 0, Item: 'foo'), (-1, 1, Item: 'bar'), (-3, 2, Item: 'spam'), (-1, 3, Item: 'grok')]\nItem: 'foo'\n[(-3, 2, Item: 'spam'), (-1, 1, Item: 'bar'), (-1, 3, Item: 'grok')]\nItem: 'spam'\n[(-1, 1, Item: 'bar'), (-1, 3, Item: 'grok')]\nItem: 'bar'\n[(-1, 3, Item: 'grok')]\nItem: 'grok'\n\n可以观察出pop()是如何返回一个拥有最高优先级的项。对于拥有相同优先级的项（bar和grok），会按照被插入队列的顺序来返回。代码的核心是利用heapq模块，之前已经说过，heapq.heappop()会返回最小值项，因此需要把 priority 的值变为负，才能让队列将每一项按从最高到最低优先级的顺序级来排序。\n参考文献：\n\nPython 3.6 Documentation\nPython Cookbook (3rd), O'Reilly.\n\n声明\n原创文章，仅用于个人学习及参考，禁止转载。一切解释权归原作者所有。文中如有错误或不足之处请及时指出。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}