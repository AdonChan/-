{"title": "Python之functools.wraps - Sunisdown ", "index": "decorator,python", "content": "在看 Bottle 代码中看见 functools.wraps 这种用法。\n\ndef make_default_app_wrapper(name):\n    \"\"\" Return a callable that relays calls to the current default app. \"\"\"\n    a = getattr(Bottle, name)\n    @functools.wraps(getattr(Bottle, name))\n    def wrapper(*a, **ka):\n        return getattr(app(), name)(*a, **ka)\n    return wrapper\n\n\n之前没有看过，于是查文档了解了一下他的用处\n先下定义：functools.wraps 是 装饰器的装饰器\n\n要明白 functiools.wraps 首先要明白 Python 的 Decorator\n\nDecorator\n\n在以前的 Blog 中曾经简单写过 Decorator。这次需要讲的更细一些。\n\nDecorator 通过返回包装对象实现间接调用,以此插入额外逻辑。是从老大那边偷来的哪里摘抄来的，应该算是言简意赅了。\n\n@dec2\n@dec1\ndef func(arg1, arg2, ...):\n    pass\n\n\n可以还原成\n\ndef func(arg1, arg2, ...):\n    pass\nfunc = dec2(dec1(func))\n\n\n```python\n@decomaker(argA, argB, ...)\ndef func(arg1, arg2, ...):\n    pass\n\n可以还原成\n```python\nfunc = decomaker(argA, argB, ...)(func)\n\n\nIn [1]: def outer(func):\n   ...:     def inner():\n   ...:         print \"before func\"\n   ...:         ret = func()\n   ...:         return ret + 1\n   ...:     return inner #返回 inner 函数对象\n   ...:\n\nIn [2]: @outer  # 解释器执⾏行 foo = outer(foo)\n   ...: def foo():\n   ...:     return 1\n   ...:\n\nIn [3]: foo\nOut[3]: <function __main__.inner>\n\nIn [4]: foo()\n        before func\nOut[4]: 2\n\n\n这个过程中执行了下面几步\n\n\n函数 foo 作为 装饰器 outer 的参数被传入\n函数 inner 对 func 进行调用，然后装饰器 outer 返回 inner\n原来的函数名 foo 关联到 inner，如上面的foo <function __main__.inner> 所示，调用 foo 时间上是在调用 inner\n\n装饰器不仅可以用函数返回包装对象，也可以是个类，不过这种方法太尼玛啰嗦，这里就不介绍了，想了解的自己去翻吧。下面我们写一个有点用处的 Decorator。\n假想我们有个coordinate类，而且这个类提供了 x, y坐标，而我们要对两个coordinate 对象进行计算。代码如下：\n\nclass Coordinate(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    def __repr__(self):\n        return \"Coord: \" + str(self.__dict__)\n\ndef add(a, b):\n    return Coordinate(a.x + b.x, a.y + b.y)\n\ndef sub(a, b):\n    return Coordinate(a.x - b.x, a.y - b.y)\n\nIn [8]: one = Coordinate(100, 200)\n\nIn [9]: two = Coordinate(300, 200)\n\nIn [10]: three = Coordinate(-100, -100)\n\nIn [11]: sub(one, three)\nOut[11]: Coord: {'y': 300, 'x': 200}\n\nIn [12]: add(one, three)\nOut[12]: Coord: {'y': 100, 'x': 0}\n\nIn [13]: sub(one, two)\nOut[13]: Coord: {'y': 0, 'x': -200}\n\n\n上面例子中的sub(one, two)与three都有负数，当我们把坐标限制在第一象限时，这两个就不符合我们的要求，用 Decorator 来做一个检测再好不过了\n\nIn [14]: def wrapper(func):\n   ....:     def checker(a, b):\n   ....:         if a.x < 0 or a.y < 0:\n   ....:             a = Coordinate(a.x if a.x > 0 else 0, a.y if a.y > 0 else 0)\n   ....:         if b.x < 0 or b.y < 0:\n   ....:             b = Coordinate(b.x if b.x > 0 else 0, b.y if b.y > 0 else 0)\n   ....:         ret = func(a, b)\n   ....:         if ret.x < 0 or ret.y <0:\n   ....:             ret = Coordinate(ret.x if ret.x > 0 else 0, ret.y if ret.y > 0 else 0)\n   ....:         return ret\n   ....:     return checker\n   ....:\nIn [16]: @wrapper\n   ....: def add(a, b):\n   ....:     return Coordinate(a.x + b.x, a.y + b.y)\n   ....:\n\nIn [17]: @wrapper\n   ....: def sub(a, b):\n   ....:     return Coordinate(a.x - b.x, a.y + b.y)\n   ....:\n\nIn [18]: add(one, three)\nOut[18]: Coord: {'y': 200, 'x': 100}\n\nIn [19]: one\nOut[19]: Coord: {'y': 200, 'x': 100}\n\nIn [20]: sub(one, two)\nOut[20]: Coord: {'y': 400, 'x': 0}\n\n\n这样，只计算的函数add与sub前面加一个 Decorator 就可以完成坐标的校验。比在函数内实现要优雅一些。\n\nDecorator 还可以为类增加额外的成员，\n\nIn [21]: def hello(cls):\n   ....:     cls.hello = staticmethod(lambda: \"HELLO\")\n   ....:     return cls\n   ....:\n\nIn [22]: @hello\n   ....: class World(object):pass\n   ....:\n\nIn [23]: World.hello\nOut[23]: <function __main__.<lambda>>\n\nIn [24]: World.hello()\nOut[24]: 'HELLO'\n\n\nfunctools.wraps\n\n我们在使用 Decorator 的过程中，难免会损失一些原本的功能信息。直接拿 stackoverflow 里面的栗子\n\ndef logged(func):\n    def with_logging(*args, **kwargs):\n        print func.__name__ + \" was called\"\n        return func(*args, **kwargs)\n    return with_logging\n\n@logged\ndef f(x):\n   \"\"\"does some math\"\"\"\n   return x + x * x\n\ndef f(x):\n    \"\"\"does some math\"\"\"\n    return x + x * x\nf = logged(f)\n\nIn [24]: f.__name__\nOut[24]: with_logging\n\n\n而functools.wraps 则可以将原函数对象的指定属性复制给包装函数对象, 默认有 __module__、__name__、__doc__,或者通过参数选择。代码如下：\n\nfrom functools import wraps\ndef logged(func):\n    @wraps(func)\n    def with_logging(*args, **kwargs):\n        print func.__name__ + \" was called\"\n        return func(*args, **kwargs)\n    return with_logging\n\n@logged\ndef f(x):\n   \"\"\"does some math\"\"\"\n   return x + x * x\n\nprint f.__name__  # prints 'f'\nprint f.__doc__   # prints 'does some math'\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "6"}