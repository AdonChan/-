{"title": "Python基础之(七)函数 - 再读斋 ", "index": "python", "content": "函数\n建立函数\n在Python中，规定了一种定义函数的格式，下面的举例就是一个函数，以这个函数为例来说明定义函数的格式和调用函数的方法。\ndef add_function(a, b): #冒号必须\n   c = a + b  #缩进必须\n   return c\n\nif __name__ == \"__main__\":\n   result = add_function(2, 3)\n   print result               #python3: print(result)\n定义函数的格式为：\ndef 函数名(参数1，参数2，...，参数n)：\n\n   函数体（语句块）\n几点说明：\n\n函数名的命名规则要符合Python中的命名要求。一般用小写字母和单下划线、数字等组合，有人习惯用aaBb的样式，但我不推荐\ndef是定义函数的关键词，这个简写来自英文单词define\n函数名后面是圆括号，括号里面，可以有参数列表，也可以没有参数\n千万不要忘记了括号后面的冒号\n函数体（语句块），相对于def缩进，按照python习惯，缩进四个空格\n\n函数命名\nPython对命名的一般要求:\n\n文件名:全小写,可使用下划线\n函数名:小写，可以用下划线风格单词以增加可读性。如：myfunction，my_example_function。注意：混合大小写仅被允许用于这种风格已经占据优势的时候，以便保持向后兼容。有的人，喜欢用这样的命名风格：myFunction，除了第一个单词首字母外，后面的单词首字母大写。这也是可以的，因为在某些语言中就习惯如此。但我不提倡，这是我非常鲜明的观点。\n函数的参数：命名方式同变量（本质上就是变量）。如果一个参数名称和Python保留的关键字冲突，通常使用一个后缀下划线会好于使用缩写或奇怪的拼写。\n变量:变量名全部小写，由下划线连接各个单词。如color = WHITE，this_is_a_variable = 1。\n\n调用函数\n定义函数\n>>> def add(x,y):       #为了能够更明了显示参数赋值特点，重写此函数\n...     print \"x=\",x         #分别打印参数赋值结果\n...     print \"y=\",y\n...     return x+y\n... \n普通调用\n>>> add(10, 3)           #x=10,y=3\nx= 10\ny= 3\n13\n还可以直接把赋值语句写到里面，就明确了参数和对象的关系。当然，这时候顺序就不重要了\n>>> add(x=10, y=3)       \nx= 10\ny= 3\n13\n\n>>> add(y=10, x=3)\nx= 3\ny= 10\n13\n多态调用\n>>> def times(x, y=2):       #y的默认值为2\n    ...     print \"x=\",x                 #Python 3: print(\"x={}\".format(x))，以下类似，从略。\n    ...     print \"y=\",y\n    ...     return x*y\n    ... \n    >>> times(3)                #x=3,y=2\n    x= 3\n    y= 2\n    6\n\n    >>> times(x=3)              #同上\n    x= 3\n    y= 2\n    6\n    \n>>> times(3, 4)              #x=3,y=4,y的值不再是2\nx= 3\ny= 4\n12\n\n>>> times(\"qiwsir\")         #再次体现了多态特点\nx= qiwsir\ny= 2\n'qiwsirqiwsir'\n注意事项\n下面的若干条，是常见编写代码的注意事项：\n\n别忘了冒号。一定要记住复合语句首行末尾输入“：”（if,while,for等的第一行）\n从第一行开始。要确定顶层（无嵌套）程序代码从第一行开始。\n空白行在交互模式提示符下很重要。模块文件中符合语句内的空白行常被忽视。但是，当你在交互模式提示符下输入代码时，空白行则是会结束语句。\n缩进要一致。避免在块缩进中混合制表符和空格。\n使用简洁的for循环，而不是while or range.相比，for循环更易写，运行起来也更快\n要注意赋值语句中的可变对象。\n不要期待在原处修改的函数会返回结果,比如list.append()，这在可修改的对象中特别注意\n调用函数是，函数名后面一定要跟随着括号，有时候括号里面就是空空的，有时候里面放参数。\n不要在导入和重载中使用扩展名或路径。\n\n返回值\n所谓返回值，就是函数向调用函数的地方返回的数据。\n编写一个斐波那契数列函数:\n#!/usr/bin/env python\n# coding=utf-8\n\ndef fibs(n):\n   result = [0,1]\n   for i in range(n-2):\n       result.append(result[-2] + result[-1])\n   return result\n\nif __name__ == \"__main__\":\n   lst = fibs(10)\n   print lst\n返回多个值元组\n    >>> def my_fun():\n    ...     return 1, 2, 3\n    ... \n    >>> a = my_fun()\n    >>> a\n    (1, 2, 3)\n对这个函数，我们还可以用这样的方式来接收函数的返回值。\n >>> x, y, z = my_fun()\n    >>> x\n    1\n    >>> y\n    2\n    >>> z\n    3\n函数文档\n#!/usr/bin/env python\n# coding=utf-8\n\ndef fibs(n):\n   \"\"\"\n   This is a Fibonacci sequence. #函数文档\n   \"\"\"\n   result = [0,1]\n   for i in range(n-2):\n       result.append(result[-2] + result[-1])\n   return result\n\nif __name__ == \"__main__\":\n   lst = fibs(10)\n   print lst\n    >>> def my_fun():\n    ...     \"\"\"\n    ...     This is my function.\n    ...     \"\"\"\n    ...     print \"I am a craft.\"\n    ... \n    >>> my_fun.__doc__  #调用打印函数文档\n    '\\n    This is my function.\\n    '\n参数收集\n函数参数的个数也有不确定的时候，怎么解决这个问题呢？Python用这样的方式解决参数个数的不确定性。\n元组形式\ndef func(x, *arg): \n    print x         #Python 3请自动修改为print()的格式，下同，从略。\n    result = x\n    print arg       #输出通过*arg方式得到的值\n    for i in arg:\n        result +=i\n    return result\n\nprint func(1, 2, 3, 4, 5, 6, 7, 8, 9)    #赋给函数的参数个数不仅仅是2个\n字典形式\n   >>> def foo(**kargs):\n    ...     print kargs        #Python 3:  print(kargs)\n    ...\n    >>> foo(a=1,b=2,c=3)    #注意观察这次赋值的方式和打印的结果\n    {'a': 1, 'c': 3, 'b': 2}\n一种优雅的方式\n>>> def add(x, y):\n...     return x + y\n... \n>>> add(2, 3)\n5\n\n>>> bars = (2, 3)\n>>> add(*bars)\n5\n    \n>>> bars = (2, 3, 4) #元组中元素的个数，要跟函数所要求的变量个数一致,不然如下报错\n>>> add(*bars)\nTraceback (most recent call last):\n File \"<stdin>\", line 1, in <module>\nTypeError: add() takes exactly 2 arguments (3 given)\n\n综合\ndef foo(p1, p2, p3, ...)\n>>> def foo(p1, p2, p3):\n...     print \"p1==>\",p1        #Python 3用户修改为print()格式，下同\n...     print \"p2==>\",p2\n...     print \"p3==>\",p3\n... \n>>> foo(\"python\", 1, [\"qiwsir\",\"github\",\"io\"])   \np1==> python\np2==> 1\np3==> ['qiwsir', 'github', 'io']\ndef foo(p1=value1, p2=value2, ...)\n\n>>> foo(p3=3, p1=10, p2=222)\n    p1==> 10\n    p2==> 222\n    p3==> 3\n\n>>> def foo(p1, p2=22, p3=33):    #设置了两个参数p2, p3的默认值\n...     print \"p1==>\",p1\n...     print \"p2==>\",p2\n...     print \"p3==>\",p3\n... \n>>> foo(11)     #p1=11，其它的参数为默认赋值\np1==> 11\np2==> 22\np3==> 33\n>>> foo(11, 222)     #按照顺序，p2=222, p3依旧维持原默认值\np1==> 11\np2==> 222\np3==> 33\n>>> foo(11, 222, 333)  #按顺序赋值\np1==> 11\np2==> 222\np3==> 333\n\n>>> foo(11, p2=122)\np1==> 11\np2==> 122\np3==> 33\n\n>>> foo(p2=122)     #p1没有默认值，必须要赋值的，否则报错\nTraceback (most recent call last):\n File \"<stdin>\", line 1, in <module>\nTypeError: foo() takes at least 1 argument (1 given)\ndef foo(*args)\n这种方式适合于不确定参数个数的时候，在参数args前面加一个*\n>>> def foo(*args): \n...     print args\n... \n>>> foo(\"qiwsir.github.io\")\n('qiwsir.github.io',)\n>>> foo(\"qiwsir.github.io\",\"python\")\n('qiwsir.github.io', 'python')\ndef foo(**args)\n这种方式跟上面的区别在于，必须接收类似arg=val形式的。\n>>> def foo(**args):    \n...     print args\n... \n\n>>> foo(1,2,3)   \nTraceback (most recent call last):\n File \"<stdin>\", line 1, in <module>\nTypeError: foo() takes exactly 0 arguments (3 given)\n\n>>> foo(a=1,b=2,c=3)\n{'a': 1, 'c': 3, 'b': 2}\n特殊函数\nlambda\n# !/usr/bin/env python\n#coding=utf-8\n\ndef add(x,y = 3):\n    return x + y\n\nret = add(5)\nprint ret\n\nlam = lambda x : x + 3\nret = lam(5)\nprint ret\n\nlam = lambda x,y : x + y\nret = lam(5,5)\nprint ret\n\n8\n8\n10\nlambda函数的使用方法：\n\nlambda后面直接跟变量；\n变量后面是冒号；\n冒号后面是表达式，表达式计算结果就是本函数的返回值；\n\nlambda函数不能包含太多的命令，包含的表达式不能超过一个，不要试图向lambda函数中塞入太多的东西，如果需要更复杂的东西，应该定义一个普通的函数。\nmap\n# !/usr/bin/env python\n#coding=utf-8\n\ndef add(x,y = 3):\n    return x + y\n\nnumbers = range(9)\nprint numbers\n\nret = map(add, numbers) #只引用函数名即可\nprint ret\n\nret = map(lambda x : x + 4, numbers) #\nprint ret\n\nret = [x + 4 for x in numbers] #列表解析的方式实现\nprint ret\nmap()是Python的一个内置函数，它的基本样式是：map(fun,seq)\nfunc是一个函数，seq是一个序列对象。在执行的时候，序列对象中的每个对象，按照从左到右的顺序依次被取出来，塞入到func函数里面，并将func的返回值依次存到一个列表中。\nreduce\nreduce()是横着逐个元素进行运算\n# !/usr/bin/env python\n#coding=utf-8\n\ndef add(x,y): #连续相加\n    return x + y\n\ndef mul(x,y): #连续相乘\n    return x * y\n\nnumbers = range(9)\nprint numbers\n\nret = reduce(add, numbers) \nprint ret\n\nret = reduce(mul, numbers) \nprint ret\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8]\n36\n0\nfilter\n# !/usr/bin/env python\n#coding=utf-8\n\nnumbers = range(-5,5)\nprint numbers\n\nret = filter(lambda x : x > 0, numbers) #过滤掉x < 0的数\nprint ret\n\nret = [x for x in numbers if x > 0]\nprint ret\n\nret = filter(lambda c : c != 'i', \"liuguoquan\") #过滤掉字符i\nprint ret\n练习\n求解一元二次方程\n# !/usr/bin/env python\n#coding=utf-8\n\n\"\"\"\n 求解一元二次方程\n \n\"\"\"\n\nfrom __future__ import division\nimport math\n\ndef quadratic_equation(a,b,c):\n    delta = b * b - 4 * a * c\n    if delta < 0:\n        return False\n    elif delta == 0:\n        return -(b / (2 * a))\n    else:\n        sqrt_delat = math.sqrt(delta)\n        x1 = (-b + sqrt_delat) / (2 * a)\n        x2 = (-b - sqrt_delat) / (2 * a)\n        return x1,x2\n\nif __name__ == \"__main__\":\n    print \"a quadratic equation: x^2 + 2x + 1 = 0\"\n    coefficients = (1,2,1)\n    roots = quadratic_equation(*coefficients)\n    if roots:\n        print \"the result is: \",roots\n    else:\n        print \"this equation has no solution\"\n        \na quadratic equation: x^2 + 2x + 1 = 0\nthe result is:  -1.0\n统计考试成绩\n# !/usr/bin/env python\n#coding=utf-8\n\n\"\"\"\n 统计考试成绩\n \n\"\"\"\n\nfrom __future__ import division\nimport math\n\ndef average_score(scores):\n    \"\"\"\n        统计平均分\n    \"\"\"\n    score_values = scores.values()\n    sum_scores = sum(score_values)\n    average = sum_scores / len(score_values)\n    return average\n\ndef sorted_score(scores):\n    \"\"\"\n        对成绩从高到低排序呢\n    \"\"\"\n    score_list = [(scores[k],k) for k in scores]  #将键-值互换位置 score_list是列表,里面的元素是一个元组\n    sort_lst = sorted(score_list,reverse = True)\n    return [(i[1],i[0]) for i in sort_lst] #将键-值互换位置\n\ndef max_score(scores):\n    \"\"\"\n        成绩最高的姓名和分数\n    \"\"\"\n    lst = sorted_score(scores)\n    max_score = lst[0][1]\n    return [(i[0],i[1]) for i in lst if i[1] == max_score]\n\ndef min_scroe(scores):\n    \"\"\"\n        成绩最低的姓名和分数\n    \"\"\"\n    lst = sorted_score(scores)\n    min_score = lst[len(lst) - 1][1]\n    return [(i[0],i[1]) for i in lst if i[1] == min_score]\n\nif __name__ == \"__main__\":\n    scores = {\"google\":98,\"facebook\":99,\"baidu\":52,\"alibab\":80,\"yahoo\":49,\"android\":76,\"apple\":99,\"amazon\":99}\n    \n    ret = average_score(scores) #平均分\n    print \"average is: \",ret\n\n    ret = sorted_score(scores) #成绩表\n    print \"list of scores is: \",ret\n    \n    ret = max_score(scores) #学霸们\n    print \"学霸是: \",ret\n    \n    ret = min_scroe(scores) #学渣\n    print \"学渣是: \",ret\n\naverage is:  81.5\nlist of scores is:  [('facebook', 99), ('apple', 99), ('amazon', 99), ('google', 98), ('alibab', 80), ('android', 76), ('baidu', 52), ('yahoo', 49)]\n学霸是:  [('facebook', 99), ('apple', 99), ('amazon', 99)]\n学渣是:  [('yahoo', 49)]\n找质数\n质数又称素数，指在大于1的自然数中，除了1和此整数自身外，无法被其他自然整数整除的数（也可定义为只有1和本身两个因数的数）\n# !/usr/bin/env python\n#coding=utf-8\n\n\"\"\"\n寻找质数\n\"\"\"\nimport math\n\ndef is_prime(n):\n    \"\"\"\n    判断一个数是否是质数\n    \"\"\"\n    if n <=1:\n        return False\n    for i in range(2,int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            return False\n        return True\n\nif __name__ == \"__main__\":\n    \n    primes = [i for i in range(2,100) if is_prime(i)]\n    print primes\n\n[5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99]     \n编写函数的注意事项\n\n尽量不要使用全局变量\n如果参数是可变数据类型，则在函数内不要修改它\n每个函数的功能和目的要单一，不要一个函数试图做很多事情\n函数的代码行数尽量少\n函数的独立性越强越好，不要跟其他的外部东西产生关联\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "4"}