{"title": "Python之路--python基础2 - 个人文章 ", "index": "python", "content": "day2内容1、列表、元组操作2、字符串操作3、字典操作4、集合操作5、文件操作6、字符编码与转码7、内置函数\n在Python中，最基本的数据结构是序列(sequence)。序列中的每个元素被分配一个序号--即元素的位置，也称为索引。第一个索引是0，第二个是1，以此类推。Python包含6中内键的序列：列表、元组、字符串、Unicode字符串、buffer对象和xrange对象。序列都可以进行的操作包括索引、切片、加、乘、检查成员此外，Python已经内置确定序列的长度以及确定最大和最小元素的方法。\n一、列表(list)\n列表是Python中最常用的数据类型之一，通过列表可以对数据实现最方便的存储，修改等操作。\n\n1、列表的基本操作\n列表的定义\nnames = [\"dabric\",\"devil\",\"Tom\"]\n列表中元素的访问\n通过下标访问列表中的元素，下标从0开始计数\n>>> names\n['dabric', 'devil', 'Tom']\n>>> names[0]\n'dabric'\n>>> names[1]\n'devil'\n>>> names[-1]   #还可以从后往前取\n'Tom'\n>>> names[-2]\n'devil'\n改变列表：元素赋值\n为指定下标的元素赋值\n>>> names\n['dabric', 'devil', 'Tom']\n>>> names[1] = 'Alice'\n>>> names\n['dabric', 'Alice', 'Tom']\n分片(split)\nPython通过对序列进行分片，来取序列中的多个元素，分片遵循顾前不顾后的原则\n>>> names\n['dabric', 'Alice', 'Tom', 'Beth', 'Cecil']\n>>> names[0:3]             #当从列表的首个元素开始切片时，可以省略不写0；相当于names[:3]\n['dabric', 'Alice', 'Tom'] \n\n>>> names\n['dabric', 'Alice', 'Tom', 'Beth', 'Cecil']\n>>> names[1:]              #要取从指定下标处开始所有列表中的元素，省略不写后面的下标；\n['Alice', 'Tom', 'Beth', 'Cecil']\n\n#从列表后往前切片  \n>>> names\n['dabric', 'Alice', 'Tom', 'Beth', 'Cecil']\n>>> names[-3:-1]\n['Tom', 'Beth']\n\n>>> names\n['dabric', 'Alice', 'Tom', 'Beth', 'Cecil']\n>>> names[:-1]\n['dabric', 'Alice', 'Tom', 'Beth']\n>>> names[-4:]\n['Alice', 'Tom', 'Beth', 'Cecil']\n\n\n2、列表的方法\nappend\nappend方法用于在列表末尾追加新的对象：\n>>> names\n['dabric', 'Alice', 'Tom']\n>>> names.append('Beth')\n>>> names\n['dabric', 'Alice', 'Tom', 'Beth']\ncount\ncount方法统计某个元素在列表中出现的次数：\n>>> names\n['dabric', 'Alice', 'Tom', 'Beth', 'Cecil', 'Cecil']\n>>> names.count('Cecil')\n2\nextend\nextend方法可以在列表的末尾一次性追加另一个序列中的多个值。换句话说，可以用新列表扩展原有的列表：\n>>> names\n['dabric', 'Alice', 'Tom', 'Beth', 'Cecil', 'Cecil']\n>>> name\n['Dee-Dee', 'Earl']\n>>> names.extend(name)\n>>> names\n['dabric', 'Alice', 'Tom', 'Beth', 'Cecil', 'Cecil', 'Dee-Dee', 'Earl']\nindex\nindex方法用于从列表中找出某个值第一个匹配的索引位置：\n>>> names\n['dabric', 'Alice', 'Tom', 'Beth', 'Cecil', 'Cecil', 'Dee-Dee', 'Earl']\n>>> names.index('dabric')\n0\n>>> names.index('Tom')\n2\n>>> names.index('Jerry')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: 'Jerry' is not in list\ninsert\ninsert方法用于将对象插入到列表中的指定位置：\n>>> names\n['dabric', 'Alice', 'Tom', 'Beth', 'Cecil', 'Cecil', 'Dee-Dee', 'Earl']\n>>> names.insert(3,'贝斯')\n>>> names\n['dabric', 'Alice', 'Tom', '贝斯', 'Beth', 'Cecil', 'Cecil', 'Dee-Dee', 'Earl']\npop\npop方法会移除列表中的一个元素(默认为最后一个)，并且返回该元素的值：\n>>> names\n['dabric', 'Alice', 'Tom', '贝斯', 'Beth', 'Cecil', 'Cecil', 'Dee-Dee', 'Earl']\n>>> names.pop()\n'Earl'\n>>> names\n['dabric', 'Alice', 'Tom', '贝斯', 'Beth', 'Cecil', 'Cecil', 'Dee-Dee']\n>>> names.pop(3)         #移除指定下标的元素，并将该元素的值返回\n'贝斯'\n>>> names\n['dabric', 'Alice', 'Tom', 'Beth', 'Cecil', 'Cecil', 'Dee-Dee']\nremove\nremove方法用于移除列表中某个值的第一个匹配项(remove方法修改了列表却没有返回值，这与pop方法相反)：\n>>> names\n['dabric', 'Alice', 'Tom', 'Beth', 'Cecil', 'Cecil', 'Dee-Dee', 'Tom']\n>>> names.remove('Tom')\n>>> names\n['dabric', 'Alice', 'Beth', 'Cecil', 'Cecil', 'Dee-Dee', 'Tom']\nreverse\nreverse方法将列表中的元素反向存放：\n>>> names\n['dabric', 'Alice', 'Beth', 'Cecil', 'Cecil', 'Dee-Dee', 'Tom']\n>>> names.reverse()\n>>> names\n['Tom', 'Dee-Dee', 'Cecil', 'Cecil', 'Beth', 'Alice', 'dabric']\nsort\nsort方法用于在原位置对列表尽心排序。在“原位置排序”意味着改变原来的列表，sort方法修改原来的列表，其返回结果为空：\n>>> names\n['Tom', 'Dee-Dee', 'Cecil', 'Cecil', 'Beth', 'Alice', 'dabric']\n>>> name = names.sort()\n>>> names\n['Alice', 'Beth', 'Cecil', 'Cecil', 'Dee-Dee', 'Tom', 'dabric']\n>>> name\n>>> print(name)\nNone\ncopy\n列表的赋值有三种方式：\n>>> names\n['Alice', 'Beth', 'Cecil', 'Cecil', 'Dee-Dee', 'Tom']\n>>> name = names.copy()    #方法一(浅拷贝)\n>>> names\n['Alice', 'Beth', 'Cecil', 'Cecil', 'Dee-Dee', 'Tom']\n>>> name\n['Alice', 'Beth', 'Cecil', 'Cecil', 'Dee-Dee', 'Tom']\n\n>>> names.pop()    #移除names中的最后一个元素\n'Tom'\n>>> name\n['Alice', 'Beth', 'Cecil', 'Cecil', 'Dee-Dee', 'Tom']\n>>> names\n['Alice', 'Beth', 'Cecil', 'Cecil', 'Dee-Dee']\n\n>>> name.clear()    #清空列表中的数据\n>>> name\n[]\n>>> name = names[:]     #方法二，names[:]得到的是包含names所有元素的分片，这是一种很有效率的复制整个列表的方法。只是简单的把names赋值给name是没有用的，因为这样做就让names和name都指向同一个列表了。\n>>> name\n['Alice', 'Beth', 'Cecil', 'Cecil', 'Dee-Dee', 'Tom']\n\n>>> names\n['Alice', 'Beth', 'Cecil', 'Cecil', 'Dee-Dee']\n>>> name.clear()\n>>> name\n[]\n>>> import copy     #方法三，导入copy模块\n>>> name = copy.copy(names)      #其功能和列表的copy方法一样，都是浅拷贝\n>>> name\n['Alice', 'Beth', 'Cecil', 'Cecil', 'Dee-Dee']\n深拷贝与浅拷贝\n#浅拷贝，只能拷贝第一层的列表，对于第二层乃至更深的一层不能实现拷贝的功能。列表的拷贝是将列表中每个索引指向的值拷贝一份，对于列表中的列表，其索引指向的是另外一个地址，而浅拷贝只是将该索引指向的地址复制一份，所以当前一个列表中值发生改变，相应复制的列表中的值也发生同样的变化。\n>>> names\n['Alice', 'Beth', 'Cecil', 'Cecil', 'Dee-Dee']\n>>> names.append([1,2,3])\n>>> names\n['Alice', 'Beth', 'Cecil', 'Cecil', 'Dee-Dee', [1, 2, 3]]\n>>> name\n[]\n>>> name = copy.copy(names)\n>>> name\n['Alice', 'Beth', 'Cecil', 'Cecil', 'Dee-Dee', [1, 2, 3]]\n>>> names\n['Alice', 'Beth', 'Cecil', 'Cecil', 'Dee-Dee', [1, 2, 3]]\n>>> names[-1][0] = 10\n>>> name\n['Alice', 'Beth', 'Cecil', 'Cecil', 'Dee-Dee', [10, 2, 3]]\n>>> names\n['Alice', 'Beth', 'Cecil', 'Cecil', 'Dee-Dee', [10, 2, 3]]\n\n#深拷贝\n>>> names\n['Alice', 'Beth', 'Cecil', 'Cecil', 'Dee-Dee', [1, 2, 3]]\n>>> name\n[]\n>>> name = copy.deepcopy(names)\n>>> name\n['Alice', 'Beth', 'Cecil', 'Cecil', 'Dee-Dee', [1, 2, 3]]\n>>> names[-1][0] = 10\n>>> names\n['Alice', 'Beth', 'Cecil', 'Cecil', 'Dee-Dee', [10, 2, 3]]\n>>> name\n['Alice', 'Beth', 'Cecil', 'Cecil', 'Dee-Dee', [1, 2, 3]]\n\n二、元组(tuple)\n元组与列表一样，也是一种序列。唯一不同的是元组不能修改。\n1、元组的定义\n用逗号分隔一些值，就自动创建了元组\n>>> 1,2,3\n(1, 2, 3)\n>>> (1,2,3)\n(1, 2, 3)\n包含一个值的元组的实现\n>>> 42,\n(42,)\n>>> (42)\n42\n>>> (42,)\n(42,)\n\n2、元组的操作\n元组也可以实现切片，它只有两个方法，一个是count，另一个是index。\n\n程序练习 \n程序：购物车程序\n需求:(1) 启动程序后，让用户输入工资，然后打印商品列表(2) 允许用户根据商品编号购买商品(3) 用户选择商品后，检测余额是否够，够就直接扣款，不够就提醒 (4) 可随时退出，退出时，打印已购买商品和余额\n\n三、字符串操作\n1、基本的字符串操作\n所有标准的序列操作（索引、分片、乘法、判断成员资格、求长度、取最小值和最大值）对字符串同样适用。但是字符串是不可改变的，例如：\n>>> website = \"http://www.python.org\"\n>>> website[-3:] = 'com'\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: 'str' object does not support item assignment\n2、字符串格式化\n字符串格式化使用字符串格式化操作符即百分号%来实现。在%号左侧放置一个字符串(格式化字符串)，而右侧则放置希望被格式化的值。可以使用一个值，如一个字符串或者数字，也可以使用多个值的元组或者字典。格式化操作符的右操作数可以是任意类型，如果右操作数是元组的话，则其中的每一个元素都会被单独格式化，每个值都需要一个对应的转换说明符。\n>>> '%s plus %s equals %s' % (1,1,2)\n'1 plus 1 equals 2'\n基本的转换说明符\n\n\n%字符：标记转换说明符的开始\n\n转换标志(可选)：-表示左对齐；+表示在转换值之前要加上正负号；\"\"(空白字符)表示整十数之前保留空格；0表示转换值若位数不够则用0填充。\n\n最小字段宽度(可选)：转换后的字符串至少应该具有该值指定的宽度。如果是*，则宽度会从值元组中读出。\n\n点(.)后跟精度值(可选)：如果转换的是实数，精度值就表示出现小数点后的位数。如果转换的是字符串，那么该数字就表示最大字段宽度。如果是*，那么精度将会从元组中读出。\n\n转换类型：参见下表。\n\n\n3、字符串方\n基本方法\ncenter\n方法center通过在两边添加填充字符(默认为空格)让字符串居中。\n>>> name = \"My name is Dabric\"\n>>> name.center(39)\n'           My name is Dabric           '\n>>> name.center(39,'*')\n'***********My name is Dabric***********'\n\n\n>>> name.ljust(40,'*')   #将字符串靠左显示，如果字符串不够给定长度，用给定字符进行填充\n'My name is Dabric***********************'\n>>> name.rjust(40,'*')   #将字符串靠右显示，如果字符串不够给定长度，用给定字符进行填充\n'***********************My name is Dabric'\n\n>>> name.zfill(40)       #将字符串靠右显示，如果字符串不够给定长度，用0进行填充\n'00000000000000000000000My name is Dabric'\nfind\n方法find在字符串中查找子串。如果找到，就返回子串的第一个字符的索引，否则返回-1.\n>>> name.find('e')\n6\n>>> name.find('u')\n-1\n还可以指定搜索的起点和终点(可选)\n>>> subject = '$$$ Get rich now!!! $$$'\n>>> subject.find('$$$')\n0\n>>> subject.find('$$$', 1) # 只指定了起点\n20\n>>> subject.find('!!!')\n16\n>>> subject.find('!!!', 0, 16) # 同时指定了起点和终点(搜索范围包含起点，但不包含终点)\n-1\njoin\njoin是一个非常重要的字符串方法，其作用于split相反，用于合并序列的元素。\n>>> seq = [1, 2, 3, 4, 5]\n>>> sep = '+'\n>>> sep.join(seq) # 尝试合并一个数字列表\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in ?\nTypeError: sequence item 0: expected string, int found\n>>> seq = ['1', '2', '3', '4', '5']\n>>> sep.join(seq) # 合并一个字符串列表\n'1+2+3+4+5'\n>>> dirs = '', 'usr', 'bin', 'env'\n>>> '/'.join(dirs)\n'/usr/bin/env'\n>>> print('C:' + '\\\\'.join(dirs))\nC:\\usr\\bin\\env\nrepalce\n方法replace将指定子串都替换为另一个字符串，并返回替换后的结果。\n>>> \"dabric tian, chinese name is tianchenguang\".replace(\"tian\",\"TIAN\",1)\n     'dabric TIAN, chinese name is tianchenguang'\nspilt\nsplit是一个非常重要的字符串方法，其作用与join相反，用于将字符串拆分为序列。\n>>> '1+2+3+4+5'.split('+')\n['1', '2', '3', '4', '5']\n>>> '/usr/bin/env'.split('/')\n['', 'usr', 'bin', 'env']\n>>> 'Using the default'.split()\n['Using', 'the', 'default']\n注意，如果没有指定分隔符，将默认在单个或多个连续的空白字符（空格、制表符、换行符\n等）处进行拆分。\nstrip\n方法strip将字符串开头和末尾的空白（但不包括中间的空白）删除，并返回删除后的结果。\n>>> ' internal whitespace is kept '.strip()\n'internal whitespace is kept'\n判断字符串是否满足特定的条件\n很多字符串方法都以is打头，如isspace、isdigit和isupper，它们判断字符串是否具有特定的性质（如包含的字符全为空白、数字或大写）。如果字符串具备特定的性质，这些方法就返回True，否则返回False。\nisalnum、isalpha、isdecimal、isdigit、isidentifier、islower、isnumeric、\nisprintable、isspace、istitle、isupper\n其他方法\n>>> name = 'My name is Dabric'\n>>> name\n'My name is Dabric'\n>>> name.capitalize()       #首字母大写\n'My name is dabric'\n\n>>> name.casefold()         #大写全部变成小写\n'my name is dabric'\n\n>>> name.count('a')         #统计指定字符或字符串出现的次数\n2\n>>> name.count('is')\n1\n\n>>> name.encode()           #将字符串编码成bytes格式\nb'My name is Dabric'\n\n>>> name.endswith('dabric')   #判断字符串是否以指定的字符串结尾\nFalse\n>>> name.endswith('Dabric')\nTrue\n\n>>> \"dabric\\ttian\".expandtabs(10)   #将\\t转换成多长的空格\n'dabric    tian'\n>>> \"dabric\\ttian\".expandtabs()\n'dabric  tian'\n\nformat :\n\n    >>> msg = \"my name is {}, and age is {}\"\n    >>> msg.format(\"dabric\",22)\n    'my name is dabric, and age is 22'\n    >>> msg = \"my name is {1}, and age is {0}\"\n    >>> msg.format(\"dabric\",22)\n    'my name is 22, and age is alex'\n    >>> msg = \"my name is {name}, and age is {age}\"\n    >>> msg.format(age=22,name=\"dabric\")\n    'my name is dabric, and age is 22'\nformat_map\n    >>> msg.format_map({'name':'dabric','age':22})\n    'my name is dabric, and age is 22'\n\n\nmsg.index('a')  返回a所在字符串的索引\n\nmaketrans\n    >>> intab = \"aeiou\"  #This is the string having actual characters. \n    >>> outtab = \"12345\" #This is the string having corresponding mapping character\n    >>> trantab = str.maketrans(intab, outtab)\n    >>> \n    >>> str = \"this is string example....wow!!!\"\n    >>> str.translate(trantab)\n    'th3s 3s str3ng 2x1mpl2....w4w!!!'\n\n msg.partition('is')   输出 ('my name ', 'is', ' {name}, and age is {age}') \n\n msg.swapcase 大小写互换\n\n>>> b=\"ddefdsdff_哈哈\" \n>>> b.isidentifier() #检测一段字符串可否被当作标志符，即是否符合变量命名规则\nTrue\n\n四、字典操作\n字典的数据结构成为映射，字典是Python中唯一内建的映射类型。字典中的值并没有特殊的顺序，但是都存储在一个热定的键(Key)下。键可以是数字、字符串甚至是元组。\n1、字典的创建\n字典由多个键及与之对应的值构成的Key-Value对组成。每个键和它的值之间用冒号(:)隔开，项之间用逗号(,)隔开，而整个字典是由一对大括号括起来。空字典(不包括任何项)由两个大括号组成({})。例如：\nphonebook = {'Alice':'2341','Beth':'9102','Cecil':'3258'}\ndict函数\n\n可以使用dict函数，通过其他映射(比如其他字典)或者(键，值)对的序列建立字典。\n>>> items  = [('name','Gumby'),('age',42)]\n>>> d = dict(items)\n>>> d\n{'name': 'Gumby', 'age': 42}\ndict函数也可以通过关键字参数来创建字典，如下所示：\n>>> d = dict(name='Gumby',age=42)\n>>> d\n{'name': 'Gumby', 'age': 42}\n2、字典的操作\n增加\n>>> info\n{'student1': 'Alice', 'student2': 'Beth', 'student': 'Cecil'}\n>>> info[\"student4\"] = 'Dabric'\n>>> info\n{'student1': 'Alice', 'student2': 'Beth', 'student': 'Cecil', 'student4': 'Dabri\nc'}\n修改\n>>> info\n{'student1': 'Alice', 'student2': 'Beth', 'student': 'Cecil', 'student4': 'Dabri\nc'}\n>>> info['student1'] = 'ALICE'\n>>> info\n{'student1': 'ALICE', 'student2': 'Beth', 'student': 'Cecil', 'student4': 'Dabri\nc'}\n删除\n标准删除方法\n>>> info\n{'student1': 'ALICE', 'student2': 'Beth', 'student': 'Cecil', 'student4': 'Dabri\nc'}\n>>> info.pop('student')                #删除指定键下的值，并将该值返回\n'Cecil'\n>>> info\n{'student1': 'ALICE', 'student2': 'Beth', 'student4': 'Dabric'}\n通用删除方法\n>>> info\n{'student1': 'ALICE', 'student2': 'Beth', 'student4': 'Dabric'}\n>>> del info['student1']\n>>> info\n{'student2': 'Beth', 'student4': 'Dabric'}\n随机删除方法\n>>> info\n{'student2': 'Beth', 'student4': 'Dabric', 'student1': 'Alice', 'student3': 'Cec\nil'}\n>>> info.popitem()     #随机删除字典中的项，并将对应的键值以元组的形式返回\n('student3', 'Cecil')\n查找\n>>> info\n{'student2': 'Beth', 'student4': 'Dabric', 'student1': 'Alice', 'student3': 'Cec\nil'}\n>>> 'student2' in  info    #成员资格检查，标准用户\nTrue\n\n>>> info.get('student1')   #获取指定键下的值，如果该指定的键值不存在，返回None\n'Alice'\n>>> info.get('student5')\n>>>\n\n>>> info['student1']    #同上，但是当指定的键不存在时报错\n'Alice'\n>>> info['student5']\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nKeyError: 'student5'\n多级字典嵌套及操作\nav_catalog = {\n    \"欧美\":{\n        \"www.youporn.com\": [\"很多免费的,世界最大的\",\"质量一般\"],\n        \"www.pornhub.com\": [\"很多免费的,也很大\",\"质量比yourporn高点\"],\n        \"letmedothistoyou.com\": [\"多是自拍,高质量图片很多\",\"资源不多,更新慢\"],\n        \"x-art.com\":[\"质量很高,真的很高\",\"全部收费,屌比请绕过\"]\n    },\n    \"日韩\":{\n        \"tokyo-hot\":[\"质量怎样不清楚,个人已经不喜欢日韩范了\",\"听说是收费的\"]\n    },\n    \"大陆\":{\n        \"1024\":[\"全部免费,真好,好人一生平安\",\"服务器在国外,慢\"]\n    }\n}\n\nav_catalog[\"大陆\"][\"1024\"][1] += \",可以用爬虫爬下来\"\nprint(av_catalog[\"大陆\"][\"1024\"])\n#ouput \n['全部免费,真好,好人一生平安', '服务器在国外,慢,可以用爬虫爬下来']\n其他操作\n#values\n>>> info\n{'student2': 'Beth', 'student4': 'Dabric', 'student1': 'Alice', 'student3': 'Cec\nil'}\n>>> info.values()\ndict_values(['Beth', 'Dabric', 'Alice', 'Cecil'])\n\n\n#keys\n>>> info.keys()\ndict_keys(['student2', 'student4', 'student1', 'student3'])\n\n#setdefault  setdefault方法在某种程度上类似于get方法，能够获得与给定键相关量的值，除此之外，setdefault还能在字典中不含有给定键的情况下设定相应的键值。\n>>> info.setdefault('student5','Devil')\n'Devil'\n>>> info\n{'student2': 'Beth', 'student4': 'Dabric', 'student1': 'Alice', 'student3': 'Cec\nil', 'student5': 'Devil'}\n>>> info.setdefault('student2','Devil')\n'Beth'\n\n#update   update方法可以利用一个字典项更新另外一个字典\n>>> info\n{'student2': 'Beth', 'student4': 'Dabric', 'student1': 'Alice', 'student3': 'Cec\nil', 'student5': 'Devil'}\n>>> b = {1:2,3:4,'student0':'ALICE'}\n>>> info.update(b)\n>>> info\n{'student2': 'Beth', 'student4': 'Dabric', 'student1': 'Alice', 'student3': 'Cec\nil', 'student5': 'Devil', 1: 2, 3: 4, 'student0': 'ALICE'}\n\n#items  items方法将字典所有的项返回\n>>> info.items()\ndict_items([('student2', 'Beth'), ('student4', 'Dabric'), ('student1', 'Alice'),\n ('student3', 'Cecil'), ('student5', 'Devil'), (1, 2), (3, 4), ('student0', 'ALI\nCE')])\n\n#通过一个列表生成默认dict,有个没办法解释的坑，少用吧这个\n>>> dict.fromkeys([1,2,3],'testd')\n{1: 'testd', 2: 'testd', 3: 'testd'}\n字典的遍历\n#方法1\nfor key in info:\n    print(key,info[key])\n\n#方法2\nfor k,v in info.items(): #会先把dict转成list,数据大时莫用\n    print(k,v)\n程序练习\n程序: 三级菜单要求:\n\n打印省、市、县三级菜单\n可返回上一级\n可随时退出程序\n\nmenu = {\n    '北京':{\n        '海淀':{\n            '五道口':{\n                'soho':{},\n                '网易':{},\n                'google':{}\n            },\n            '中关村':{\n                '爱奇艺':{},\n                '汽车之家':{},\n                'youku':{},\n            },\n            '上地':{\n                '百度':{},\n            },\n        },\n        '昌平':{\n            '沙河':{\n                '老男孩':{},\n                '北航':{},\n            },\n            '天通苑':{},\n            '回龙观':{},\n        },\n        '朝阳':{},\n        '东城':{},\n    },\n    '上海':{\n        '闵行':{\n            \"人民广场\":{\n                '炸鸡店':{}\n            }\n        },\n        '闸北':{\n            '火车战':{\n                '携程':{}\n            }\n        },\n        '浦东':{},\n    },\n    '山东':{},\n}\n\nflag = True\n\nwhile flag:\n    for i1 in menu:\n        print(i1)\n\n    choice1 = input(\"Please choose the province1>>:\")\n    if choice1 in menu:\n        while flag:\n            for i2 in menu[choice1]:\n                print(\"\\t\",i2)\n            choice2 = input(\"Please choose the province2>>:\")\n            if choice2 in menu[choice1]:\n                while flag:\n                    for i3 in menu[choice1][choice2]:\n                        print(\"\\t\\t\",i3)\n                    choice3 = input(\"Please choose the province3>>:\")\n                    if choice3 in menu[choice1][choice2]:\n                        while flag:\n                            for i4 in menu[choice1][choice2][choice3]:\n                                print(\"\\t\\t\\t\",i4)\n                            choice4 = input(\"最后一层，按b返回上层，按q退出>>:\")\n                            if choice4 == 'b':\n                                break\n                            elif choice4 == 'q':\n                                flag = False\n                    if choice3 == 'b':\n                        break\n                    elif choice3 == 'q':\n                        flag = False\n            if choice2 == 'b':\n                break\n            elif choice2 == 'q':\n                flag = False\n    if choice1 == 'b':\n        break\n    elif choice1 == 'q':\n        flag = False\n\n五、集合操作\n集合是一个无序的，不重复的数据组合，它的主要作用如下：\n去重，把一个列表变成集合，就自动去重了\nlist_1 = [1,3,5,7,9,5]\nlist_1 = set(list_1)\n\nprint(list_1,type(list_1))\n{1, 3, 5, 7, 9} <class 'set'>\n关系测试，测试两组数据之间的交集、并集、差集等关系\n1、基本操作\n  \nt.add('x')            # 添加一项  \n  \ns.update([10,37,42])  # 在s中添加多项  \n  \n使用remove()可以删除一项：  \nt.remove('H')  \n   \nlen(s)  \nset 的长度  \n  \nx in s  \n测试 x 是否是 s 的成员  \n  \nx not in s  \n测试 x 是否不是 s 的成员  \n  \ns.copy()  \n返回 set “s”的一个浅复制\n2、关系测试(方法形式和符号形式)\n交集\n>>>list_1 = [1,3,5,7,9,5]\n>>>list_1 = set(list_1)\n>>>list_2 = set([6,2,4,7,8,9])\n>>>print(list_1,list_2)\n{1, 3, 5, 7, 9} {2, 4, 6, 7, 8, 9}\n>>>list_3 = list_1.intersection(list_2)   #或者list_3 = list_1 & list_2\n>>>print(list_3)\n{9, 7}\n并集\n>>>list_3 = list_1.union(list_2)  #或者list_3 = list_1 | list_2\n>>>print(list_3)\n{1, 2, 3, 4, 5, 6, 7, 8, 9}\n差集\n>>>list_3 = list_1.difference(list_2)  #或者list_3 = list_1 - list_2\n>>>print(list_3)\n{1, 3, 5}\n对称差集\n>>>list_3 = list_1.symmetric_difference(list_2)    #或者list_3 = list_1 ^ list_2\n>>>print(list_3)\n{1, 2, 3, 4, 5, 6, 8}\n子集\n>>>a = list_1.issubset(list_2)  #判断一个集合是否为另外一个集合的子集(list_1是否为list_2的子集)，如果是返回值为真，否则为假\n>>>print(a)\nFalse\n父集\n>>>a = list_1.issuperset(list_2)   #判断一个集合是否为另外一个集合的父集(list_1是否包含list_2)，如果是返回值为真，否则为假\n>>>print(a)\nFalse\n\n六、文件操作\n对文件操作流程\n\n1、打开文件，得到文件句柄并赋值给一个变量\n2、通过句柄对文件进行操作\n3、关闭文件\n\n1、打开文件\n要打开文件，可使用函数open，它位于自动导入的模块io中。函数open将文件名作为唯一必不可少的参数，并返回一个文件对象。如果当前目录中有一个名为somefile.txt的文本文件（可能是使用文本编辑器创建的），则可像下面这样打开它：\n>>> f = open('somefile.txt')\n文件模式：\n\nr，只读模式(默认)w，只写模式 (不可读；文件不存在则创建；文件存在则既有内容被删除，并从文件开头处开始写入)x，独占写入模式(在文件已经存在时引发FileExistsError)a，追加模式(可读；文件不存在则创建；存在则在文件末尾追加写入内容)\n\"+\"表示可以同时读写某个文件r+，可读写文件(可读；可写；可追加。以读和追加模式打开文件)w+，写读(没有文件先创建一个文件，有文件的话覆盖原文件)a+，追加读写\n默认模式为'rt'，这意味着将把文件视为经过编码的Unicode文本，因此将自动执行解码和编码，且默认使用UTF-8编码。默认情况下，行以'n'结尾。读取时讲自动替换其他行尾字符('r'或'rn')；写入时讲'n'替换为系统的默认行尾字符(os.linesep)；通过设置newline参数可指定只将'r'或'rn'视为合法的行尾字符，这样，读取时不会对行尾字符进行转换，但写入时将把'n'替换为系统默认的行尾字符。\n\"U\"表示在读取时，可以将rnrn自动转换成n(与r或r+模式同时使用)rUr+U\n\"b\"表示处理二进制文件(如：FTP发送上传ISO镜像文件，linux可忽略，windows处理二进制文件时需标注)rbwbab\n2、文件的基本方法\n读取和写入\n文件写入\n每当调用f.write(string)时，提供的字符串都将写入到文件中既有内容的后面\n>>> f = open('somefile.txt', 'w')\n>>> f.write('Hello, ')\n7\n>>> f.write('World!')\n6\n>>> f.close()\n文件读取\n>>> f = open('somefile.txt', 'r')\n>>> f.read(4)\n'Hell'\n>>> f.read()\n'o, World!'\n#首先，指定了要读取多少（4）个字符。接下来，读取了文件中余下的全部内容（不指定要读取多少个字符）。\n读取和写入行\n读取行\nreadline\n默认返回一行的内容，也可以指定返回几个字符\nreadlines\n读取文件中的所有行，并以列表的方式返回\n写入行\nwritelines\n与readlines相反：接受一个字符串列表(实际上，可以是任何序列或可迭代对象)，并将这些字符串都写入到文件(或流)中。\n注意：写入时不会添加换行符，因此必须自行添加。另外，没有方法writeline，一次可以使用write\nwith语句\n为了避免打开文件后忘记关闭，可以通过上下文管理器，即：\nwith open(\"somefile.txt\") as somefile\n    do_something(somefile)\n3、其他方法\nflush\n将内存中的数据同步到磁盘上\n进度条的实现\nimport sys,time\n\nfor i in range(50):\n    sys.stdout.write('#')\n    sys.stdout.flush()\n    time.sleep(0.1)\ntell和seektell方法返回文件指针的位置，seek方法用来移动文件指针的位置，一般两个方法结合使用。\nencoding打印文件的编码\nfileno返回文件句柄的编号。操作系统会有一个专门的接口负责调度所有的文件，该编号为系统中已经打开文件的编号。\nname打印文件名\ntruncate该方法如果不接任何参数，则将文件中的内容清空；如果接一个参数10，从文件指针位置开始截断取出十个字符并保存文件指针前的内容。\n4、迭代文件内容\n一种常见的文件操作是迭代其内容，并在迭代过程中反复采取某种措施。\n每次一个字符(或字节)\n使用read遍历字符\nwith open('yesterday',encoding='utf-8') as f:\n     char = f.read(1)\n     while char:\n         sys.stdout.write(char)\n         char = f.read(1)\n\nwith open('yesterday', encoding='utf-8') as f:\n    while True:\n        char = f.read(1)\n        if not char: break\n        sys.stdout.write(char)\n这个程序之所以可行，是因为到达文件末尾时，方法read将返回一个空字符串，但在此之前，返回的字符串都只包含一个字符(对应于布尔值True)。\n每次一行\nwith open (filename) as f:\n    while True:\n        line = f.readline()\n        if not line: break\n        print(line)\n读取文件所有内容\n如果文件不太大，可以读取整个文件，利用下面两种方法进行读取\nwith open(filename) as f:\n    for char in f.read():\n        sys.stdout.write(char)\n\nwith open(filename) as f:\n    for line in f.readlines:\n        print(line)\n两者的区别是read不提供任何参数，将整个文件读取到一个字符串中；readlines将文件读取到一个字符串列表中，其中每个字符串都是一行。\n使用fileinput实现延迟行迭代\n延迟行迭代的方法：延迟是因为它只读取实际需要的文本部分\nimport fileinput\nfor line in fileinput.input(filename)\n    print(line)\n\n# 模块fileinput会负责打开文件，只需要给其提供一个文件名即可。\n文件迭代器(最常见的方法)\n文件实际上可迭代的(sys.stdin也是可迭代的)，所以可以用下面的方法进行读取文件的内容：\nwith open(filename) as f:\n    for line in f:\n        print(line)\n\n六、字符编码与转码\n1、在python2默认编码是ASCII, python3里默认是unicode\n2、unicode 分为 utf-32(占4个字节),utf-16(占两个字节)，utf-8(占1-4个字节)， so utf-16就是现在最常用的unicode版本， 不过在文件里存的还是utf-8，因为utf8省空间\n3、在py3中encode,在转码的同时还会把string 变成bytes类型，decode在解码的同时还会把bytes变回string\n转码过程如下图：\n\nin python2\n#-*-coding:utf-8-*-\n\nimport sys\nprint(sys.getdefaultencoding())\n\n\nmsg = \"我爱北京天安门\"\nmsg_gb2312 = msg.decode(\"utf-8\").encode(\"gb2312\")\ngb2312_to_gbk = msg_gb2312.decode(\"gbk\").encode(\"gbk\")\n\nprint(msg)\nprint(msg_gb2312)\nprint(gb2312_to_gbk)\nin python3\n#-*-coding:gb2312 -*-   #这个也可以去掉\n\nimport sys\nprint(sys.getdefaultencoding())\n\n\nmsg = \"我爱北京天安门\"\n#msg_gb2312 = msg.decode(\"utf-8\").encode(\"gb2312\")\nmsg_gb2312 = msg.encode(\"gb2312\") #默认就是unicode,不用再decode,喜大普奔\ngb2312_to_unicode = msg_gb2312.decode(\"gb2312\")\ngb2312_to_utf8 = msg_gb2312.decode(\"gb2312\").encode(\"utf-8\")\n\nprint(msg)\nprint(msg_gb2312)\nprint(gb2312_to_unicode)\nprint(gb2312_to_utf8)\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}