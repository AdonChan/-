{"title": "Python 正则表达式 re 模块简明笔记 - Keep Going ", "index": "python,正则表达式", "content": "简介\n正则表达式（regular expression）是可以匹配文本片段的模式。最简单的正则表达式就是普通字符串，可以匹配其自身。比如，正则表达式 'hello' 可以匹配字符串 'hello'。\n要注意的是，正则表达式并不是一个程序，而是用于处理字符串的一种模式，如果你想用它来处理字符串，就必须使用支持正则表达式的工具，比如 Linux 中的 awk, sed, grep，或者编程语言 Perl, Python, Java 等等。\n正则表达式有多种不同的风格，下表列出了适用于 Python 或 Perl 等编程语言的部分元字符以及说明：\n\nre 模块\n在 Python 中，我们可以使用内置的 re 模块来使用正则表达式。\n有一点需要特别注意的是，正则表达式使用 ` 对特殊字符进行转义，比如，为了匹配字符串 'python.org'，我们需要使用正则表达式 'python.org'，而 Python 的字符串本身也用 ` 转义，所以上面的正则表达式在 Python 中应该写成 'python\\.org'，这会很容易陷入 `` 的困扰中，因此，我们建议使用 Python 的原始字符串，只需加一个 r 前缀，上面的正则表达式可以写成：\nr'python\\.org'\nre 模块提供了不少有用的函数，用以匹配字符串，比如：\n\ncompile 函数\nmatch 函数\nsearch 函数\nfindall 函数\nfinditer 函数\nsplit 函数\nsub 函数\nsubn 函数\n\nre 模块的一般使用步骤如下：\n\n使用 compile 函数将正则表达式的字符串形式编译为一个 Pattern 对象\n通过 Pattern 对象提供的一系列方法对文本进行匹配查找，获得匹配结果（一个 Match 对象）\n最后使用 Match 对象提供的属性和方法获得信息，根据需要进行其他的操作\n\ncompile 函数\ncompile 函数用于编译正则表达式，生成一个 Pattern 对象，它的一般使用形式如下：\nre.compile(pattern[, flag])\n其中，pattern 是一个字符串形式的正则表达式，flag 是一个可选参数，表示匹配模式，比如忽略大小写，多行模式等。\n下面，让我们看看例子。\nimport re\n\n# 将正则表达式编译成 Pattern 对象 \npattern = re.compile(r'\\d+')\n在上面，我们已将一个正则表达式编译成 Pattern 对象，接下来，我们就可以利用 pattern 的一系列方法对文本进行匹配查找了。Pattern 对象的一些常用方法主要有：\n\nmatch 方法\nsearch 方法\nfindall 方法\nfinditer 方法\nsplit 方法\nsub 方法\nsubn 方法\n\nmatch 方法\nmatch 方法用于查找字符串的头部（也可以指定起始位置），它是一次匹配，只要找到了一个匹配的结果就返回，而不是查找所有匹配的结果。它的一般使用形式如下：\nmatch(string[, pos[, endpos]])\n其中，string 是待匹配的字符串，pos 和 endpos 是可选参数，指定字符串的起始和终点位置，默认值分别是 0 和 len (字符串长度)。因此，当你不指定 pos 和 endpos 时，match 方法默认匹配字符串的头部。\n当匹配成功时，返回一个 Match 对象，如果没有匹配上，则返回 None。\n看看例子。\n>>> import re\n>>> pattern = re.compile(r'\\d+')                    # 用于匹配至少一个数字\n>>> m = pattern.match('one12twothree34four')        # 查找头部，没有匹配\n>>> print m\nNone\n>>> m = pattern.match('one12twothree34four', 2, 10) # 从'e'的位置开始匹配，没有匹配\n>>> print m\nNone\n>>> m = pattern.match('one12twothree34four', 3, 10) # 从'1'的位置开始匹配，正好匹配\n>>> print m                                         # 返回一个 Match 对象\n<_sre.SRE_Match object at 0x10a42aac0>\n>>> m.group(0)   # 可省略 0\n'12'\n>>> m.start(0)   # 可省略 0\n3\n>>> m.end(0)     # 可省略 0\n5\n>>> m.span(0)    # 可省略 0\n(3, 5)\n在上面，当匹配成功时返回一个 Match 对象，其中：\n\ngroup([group1, …]) 方法用于获得一个或多个分组匹配的字符串，当要获得整个匹配的子串时，可直接使用 group() 或 group(0)；\nstart([group]) 方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引），参数默认值为 0；\nend([group]) 方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1），参数默认值为 0；\nspan([group]) 方法返回 (start(group), end(group))。\n\n再看看一个例子：\n>>> import re\n>>> pattern = re.compile(r'([a-z]+) ([a-z]+)', re.I)   # re.I 表示忽略大小写\n>>> m = pattern.match('Hello World Wide Web')\n>>> print m                               # 匹配成功，返回一个 Match 对象\n<_sre.SRE_Match object at 0x10bea83e8>\n>>> m.group(0)                            # 返回匹配成功的整个子串\n'Hello World'\n>>> m.span(0)                             # 返回匹配成功的整个子串的索引\n(0, 11)\n>>> m.group(1)                            # 返回第一个分组匹配成功的子串\n'Hello'\n>>> m.span(1)                             # 返回第一个分组匹配成功的子串的索引\n(0, 5)\n>>> m.group(2)                            # 返回第二个分组匹配成功的子串\n'World'\n>>> m.span(2)                             # 返回第二个分组匹配成功的子串\n(6, 11)\n>>> m.groups()                            # 等价于 (m.group(1), m.group(2), ...)\n('Hello', 'World')\n>>> m.group(3)                            # 不存在第三个分组\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nIndexError: no such group\nsearch 方法\nsearch 方法用于查找字符串的任何位置，它也是一次匹配，只要找到了一个匹配的结果就返回，而不是查找所有匹配的结果，它的一般使用形式如下：\nsearch(string[, pos[, endpos]])\n其中，string 是待匹配的字符串，pos 和 endpos 是可选参数，指定字符串的起始和终点位置，默认值分别是 0 和 len (字符串长度)。\n当匹配成功时，返回一个 Match 对象，如果没有匹配上，则返回 None。\n让我们看看例子：\n>>> import re\n>>> pattern = re.compile('\\d+')\n>>> m = pattern.search('one12twothree34four')  # 这里如果使用 match 方法则不匹配\n>>> m\n<_sre.SRE_Match object at 0x10cc03ac0>\n>>> m.group()\n'12'\n>>> m = pattern.search('one12twothree34four', 10, 30)  # 指定字符串区间\n>>> m\n<_sre.SRE_Match object at 0x10cc03b28>\n>>> m.group()\n'34'\n>>> m.span()\n(13, 15)\n再来看一个例子：\n# -*- coding: utf-8 -*-\n\nimport re\n \n# 将正则表达式编译成 Pattern 对象\npattern = re.compile(r'\\d+') \n \n# 使用 search() 查找匹配的子串，不存在匹配的子串时将返回 None \n# 这里使用 match() 无法成功匹配 \nm = pattern.search('hello 123456 789') \n \nif m: \n    # 使用 Match 获得分组信息 \n    print 'matching string:',m.group()\n    print 'position:',m.span()\n执行结果：\nmatching string: 123456\nposition: (6, 12)\nfindall 方法\n上面的 match 和 search 方法都是一次匹配，只要找到了一个匹配的结果就返回。然而，在大多数时候，我们需要搜索整个字符串，获得所有匹配的结果。\nfindall 方法的使用形式如下：\nfindall(string[, pos[, endpos]])\n其中，string 是待匹配的字符串，pos 和 endpos 是可选参数，指定字符串的起始和终点位置，默认值分别是 0 和 len (字符串长度)。\nfindall 以列表形式返回全部能匹配的子串，如果没有匹配，则返回一个空列表。\n看看例子：\nimport re\n \npattern = re.compile(r'\\d+')   # 查找数字\nresult1 = pattern.findall('hello 123456 789')\nresult2 = pattern.findall('one1two2three3four4', 0, 10)\n \nprint result1\nprint result2\n执行结果：\n['123456', '789']\n['1', '2']\nfinditer 方法\nfinditer 方法的行为跟 findall 的行为类似，也是搜索整个字符串，获得所有匹配的结果。但它返回一个顺序访问每一个匹配结果（Match 对象）的迭代器。\n看看例子：\n# -*- coding: utf-8 -*-\n\nimport re\n \npattern = re.compile(r'\\d+')\n\nresult_iter1 = pattern.finditer('hello 123456 789')\nresult_iter2 = pattern.finditer('one1two2three3four4', 0, 10)\n\nprint type(result_iter1)\nprint type(result_iter2)\n\nprint 'result1...'\nfor m1 in result_iter1:   # m1 是 Match 对象\n    print 'matching string: {}, position: {}'.format(m1.group(), m1.span())\n\nprint 'result2...'\nfor m2 in result_iter2:\n    print 'matching string: {}, position: {}'.format(m2.group(), m2.span())\n执行结果：\n<type 'callable-iterator'>\n<type 'callable-iterator'>\nresult1...\nmatching string: 123456, position: (6, 12)\nmatching string: 789, position: (13, 16)\nresult2...\nmatching string: 1, position: (3, 4)\nmatching string: 2, position: (7, 8)\nsplit 方法\nsplit 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下：\nsplit(string[, maxsplit])\n其中，maxsplit 用于指定最大分割次数，不指定将全部分割。 \n看看例子：\nimport re\n \np = re.compile(r'[\\s\\,\\;]+')\nprint p.split('a,b;; c   d')\n执行结果：\n['a', 'b', 'c', 'd']\nsub 方法\nsub 方法用于替换。它的使用形式如下：\nsub(repl, string[, count])\n其中，repl 可以是字符串也可以是一个函数：\n\n如果 repl 是字符串，则会使用 repl 去替换字符串每一个匹配的子串，并返回替换后的字符串，另外，repl 还可以使用 id 的形式来引用分组，但不能使用编号 0；\n如果 repl 是函数，这个方法应当只接受一个参数（Match 对象），并返回一个字符串用于替换（返回的字符串中不能再引用分组）。\n\ncount 用于指定最多替换次数，不指定时全部替换。 \n看看例子：\nimport re\n \np = re.compile(r'(\\w+) (\\w+)')\ns = 'hello 123, hello 456'\n\ndef func(m):\n    return 'hi' + ' ' + m.group(2)\n\nprint p.sub(r'hello world', s)  # 使用 'hello world' 替换 'hello 123' 和 'hello 456'\nprint p.sub(r'\\2 \\1', s)        # 引用分组\nprint p.sub(func, s)\nprint p.sub(func, s, 1)         # 最多替换一次\n执行结果：\nhello world, hello world\n123 hello, 456 hello\nhi 123, hi 456\nhi 123, hello 456\nsubn 方法\nsubn 方法跟 sub 方法的行为类似，也用于替换。它的使用形式如下：\nsubn(repl, string[, count])\n它返回一个元组：\n(sub(repl, string[, count]), 替换次数)\n元组有两个元素，第一个元素是使用 sub 方法的结果，第二个元素返回原字符串被替换的次数。\n看看例子：\nimport re\n \np = re.compile(r'(\\w+) (\\w+)')\ns = 'hello 123, hello 456'\n\ndef func(m):\n    return 'hi' + ' ' + m.group(2)\n\nprint p.subn(r'hello world', s)\nprint p.subn(r'\\2 \\1', s)\nprint p.subn(func, s)\nprint p.subn(func, s, 1)\n执行结果：\n('hello world, hello world', 2)\n('123 hello, 456 hello', 2)\n('hi 123, hi 456', 2)\n('hi 123, hello 456', 1)\n其他函数\n事实上，使用 compile 函数生成的 Pattern 对象的一系列方法跟 re 模块的多数函数是对应的，但在使用上有细微差别。\nmatch 函数\nmatch 函数的使用形式如下：\nre.match(pattern, string[, flags]):\n其中，pattern 是正则表达式的字符串形式，比如 d+, [a-z]+。\n而 Pattern 对象的 match 方法使用形式是：\nmatch(string[, pos[, endpos]])\n可以看到，match 函数不能指定字符串的区间，它只能搜索头部，看看例子：\nimport re\n\nm1 = re.match(r'\\d+', 'One12twothree34four')\nif m1:\n    print 'matching string:',m1.group()\nelse:\n    print 'm1 is:',m1\n    \nm2 = re.match(r'\\d+', '12twothree34four')\nif m2:\n    print 'matching string:', m2.group()\nelse:\n    print 'm2 is:',m2\n执行结果：\nm1 is: None\nmatching string: 12\nsearch 函数\nsearch 函数的使用形式如下：\nre.search(pattern, string[, flags])\nsearch 函数不能指定字符串的搜索区间，用法跟 Pattern 对象的 search 方法类似。\nfindall 函数\nfindall 函数的使用形式如下：\nre.findall(pattern, string[, flags])\nfindall 函数不能指定字符串的搜索区间，用法跟 Pattern 对象的 findall 方法类似。\n看看例子：\nimport re\n\nprint re.findall(r'\\d+', 'hello 12345 789')\n\n# 输出\n['12345', '789']\nfinditer 函数\nfinditer 函数的使用方法跟 Pattern 的 finditer 方法类似，形式如下：\nre.finditer(pattern, string[, flags])\nsplit 函数\nsplit 函数的使用形式如下：\nre.split(pattern, string[, maxsplit])\nsub 函数\nsub 函数的使用形式如下：\nre.sub(pattern, repl, string[, count])\nsubn 函数\nsubn 函数的使用形式如下：\nre.subn(pattern, repl, string[, count])\n到底用哪种方式\n从上文可以看到，使用 re 模块有两种方式：\n\n使用 re.compile 函数生成一个 Pattern 对象，然后使用 Pattern 对象的一系列方法对文本进行匹配查找；\n直接使用 re.match, re.search 和 re.findall 等函数直接对文本匹配查找；\n\n下面，我们用一个例子展示这两种方法。\n先看第 1 种用法：\nimport re\n\n# 将正则表达式先编译成 Pattern 对象\npattern = re.compile(r'\\d+')\n\nprint pattern.match('123, 123')\nprint pattern.search('234, 234')\nprint pattern.findall('345, 345')\n再看第 2 种用法：\nimport re\n\nprint re.match(r'\\d+', '123, 123')\nprint re.search(r'\\d+', '234, 234')\nprint re.findall(r'\\d+', '345, 345')\n如果一个正则表达式需要用到多次（比如上面的 d+），在多种场合经常需要被用到，出于效率的考虑，我们应该预先编译该正则表达式，生成一个 Pattern 对象，再使用该对象的一系列方法对需要匹配的文件进行匹配；而如果直接使用 re.match, re.search 等函数，每次传入一个正则表达式，它都会被编译一次，效率就会大打折扣。\n因此，我们推荐使用第 1 种用法。\n匹配中文\n在某些情况下，我们想匹配文本中的汉字，有一点需要注意的是，中文的 unicode 编码范围 主要在 [u4e00-u9fa5]，这里说主要是因为这个范围并不完整，比如没有包括全角（中文）标点，不过，在大部分情况下，应该是够用的。\n假设现在想把字符串 title = u'你好，hello，世界' 中的中文提取出来，可以这么做：\n# -*- coding: utf-8 -*-\n\nimport re\n\ntitle = u'你好，hello，世界'\npattern = re.compile(ur'[\\u4e00-\\u9fa5]+')\nresult = pattern.findall(title)\n\nprint result\n注意到，我们在正则表达式前面加上了两个前缀 ur，其中 r 表示使用原始字符串，u 表示是 unicode 字符串。\n执行结果:\n[u'\\u4f60\\u597d', u'\\u4e16\\u754c']\n贪婪匹配\n在 Python 中，正则匹配默认是贪婪匹配（在少数语言中可能是非贪婪），也就是匹配尽可能多的字符。\n比如，我们想找出字符串中的所有 div 块：\nimport re\n\ncontent = 'aa<div>test1</div>bb<div>test2</div>cc'\npattern = re.compile(r'<div>.*</div>')\nresult = pattern.findall(content)\n\nprint result\n执行结果：\n['<div>test1</div>bb<div>test2</div>']\n由于正则匹配是贪婪匹配，也就是尽可能多的匹配，因此，在成功匹配到第一个 </div> 时，它还会向右尝试匹配，查看是否还有更长的可以成功匹配的子串。\n如果我们想非贪婪匹配，可以加一个 ?，如下：\nimport re\n\ncontent = 'aa<div>test1</div>bb<div>test2</div>cc'\npattern = re.compile(r'<div>.*?</div>')    # 加上 ?\nresult = pattern.findall(content)\n\nprint result\n结果：\n['<div>test1</div>', '<div>test2</div>']\n小结\n\n\nre 模块的一般使用步骤如下：\n\n使用 compile 函数将正则表达式的字符串形式编译为一个 Pattern 对象；\n通过 Pattern 对象提供的一系列方法对文本进行匹配查找，获得匹配结果（一个 Match 对象）；\n最后使用 Match 对象提供的属性和方法获得信息，根据需要进行其他的操作；\n\n\nPython 的正则匹配默认是贪婪匹配。\n\n本文由 funhacks 发表于个人博客，采用 Creative Commons BY-NC-ND 4.0（自由转载-保持署名-非商用-禁止演绎）协议发布。非商业转载请注明作者及出处。商业转载请联系作者本人。本文标题为: Python 正则表达式 re 模块简明笔记本文链接为: https://funhacks.net/2016/12/...\n参考资料\n\n正则表达式 - 维基百科\nPython正则表达式指南\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "10"}