{"title": "python开发-实现RabbitMQ的消息队列 - wyzane ", "index": "消息队列,rabbitmq,python", "content": "最近在研究redis做消息队列时，顺便看了一下RabbitMQ做消息队列的实现。以下是总结的RabbitMQ中三种exchange模式的实现，分别是fanout, direct和topic。\nbase.py：\nimport pika\n        \n        \n# 获取认证对象，参数是用户名、密码。远程连接时需要认证\ncredentials = pika.PlainCredentials(\"admin\", \"admin\")\n\n# BlockingConnection(): 实例化连接对象\n# ConnectionParameters(): 实例化链接参数对象\nconnection = pika.BlockingConnection(pika.ConnectionParameters(\n    \"192.168.0.102\", 5672, \"/\", credentials))\n\n# 创建新的channel(通道)\nchannel = connection.channel()\nfanout模式：向绑定到指定exchange的queue中发送消息，消费者从queue中取出数据，类似于广播模式、发布订阅模式。绑定方式: 在接收端channel.queue_bind(exchange=\"logs\", queue=queue_name)代码：publisher.py:\nfrom base import channel, connection\n        \n# 声明exchange, 不声明queue\nchannel.exchange_declare(exchange=\"logs\", exchange_type=\"fanout\")  # 广播\nmessage = \"hello fanout\"\nchannel.basic_publish(\n    exchange=\"logs\",\n    routing_key=\"\",\n    body=message\n)\nconnection.close()\nconsumer.py：\nfrom base import channel, connection\n        \n# 声明exchange\nchannel.exchange_declare(exchange=\"logs\", exchange_type=\"fanout\")\n\n# 不指定queue名字, rabbitmq会随机分配一个名字, 消息处理完成后queue会自动删除\nresult = channel.queue_declare(exclusive=True)  \n\n# 获取queue名字\nqueue_name = result.method.queue\n\n# 绑定exchange和queue\nchannel.queue_bind(exchange=\"logs\", queue=queue_name)\n\n\ndef callback(ch, method, properties, body):\n    print(\"body:%s\" % body)\n\n\nchannel.basic_consume(\n    callback,\n    queue=queue_name\n)\n\n\nchannel.start_consuming()\ndirect模式：发送端绑定一个routing_key1, queue中绑定若干个routing_key2, 若key1与key2相等，或者key1在key2中，则消息就会发送到这个queue中，再由相应的消费者去queue中取数据。publisher.py：\nfrom base import channel, connection\n            \n            \nchannel.exchange_declare(exchange=\"direct_test\", exchange_type=\"direct\")\n\nmessage = \"hello\"\n\nchannel.basic_publish(\n    exchange=\"direct_test\",\n    routing_key=\"info\",  # 绑定key\n    body=message\n)\nconnection.close()\nconsumer01.py：\nfrom base import channel, connection\n            \n            \nchannel.exchange_declare(exchange=\"direct_test\", exchange_type=\"direct\")\nresult = channel.queue_declare(exclusive=True)\nqueue_name = result.method.queue\n\n\nchannel.queue_bind(\n    exchange=\"direct_test\",\n    queue=queue_name,\n    # 绑定的key,与publisher中的相同\n    routing_key=\"info\"  \n)\n\n\ndef callback(ch, method, properties, body):\n    print(\"body:%s\" % body)\n\n\nchannel.basic_consume(\n    callback,\n    queue=queue_name\n)\n\n\nchannel.start_consuming()\nconsumer02.py：\nfrom base import channel, connection\n\n\nchannel.exchange_declare(exchange=\"direct_test\", exchange_type=\"direct\")\nresult = channel.queue_declare(exclusive=True)\nqueue_name = result.method.queue\n\n\nchannel.queue_bind(\n    exchange=\"direct_test\",\n    queue=queue_name,\n    # 绑定的key\n    routing_key=\"error\"   \n)\n\n\ndef callback(ch, method, properties, bosy):\n    print(\"body:%s\" % body)\n\n\nchannel.basic_consume(\n    callback,\n    queue=queue_name\n)\n\n\nchannel.start_consuming()\nconsumer03.py：\nfrom base import channel, connection\n            \n            \nchannel.exchange_declare(exchange=\"direct_test\", exchange_type=\"direct\")\nresult = channel.queue_declare(exclusive=True)\nqueue_name = result.method.queue\n\n\nkey_list = [\"info\", \"warning\"]\nfor key in key_list:\n    channel.queue_bind(\n        exchange=\"direct_test\",\n        queue=queue_name,\n        # 一个queue同时绑定多个key，有一个key满足条件时就可以收到数据\n        routing_key=key  \n    )\n\n\ndef callback(ch, method, properties, body):\n    print(\"body:%s\" % body)\n\n\nchannel.basic_consume(\n    callback,\n    queue=queue_name\n)\n\n\nchannel.start_consuming()\n执行:\npython producer.py\npython consumer01.py\npython consumer02.py\npython consumer03.py\n结果:\nconsumer01.py: body:b'hello'\nconsumer02.py没收到结果\nconsumer03.py: body:b'hello'\ntopic模式不是太好理解，我的理解如下:对于发送端绑定的routing_key1，queue绑定若干个routing_key2；若routing_key1满足任意一个routing_key2，则该消息就会通过exchange发送到这个queue中，然后由接收端从queue中取出其实就是direct模式的扩展。\n绑定方式: 发送端绑定:\n    channel.basic_publish(\n        exchange=\"topic_logs\",\n        routing_key=routing_key,\n        body=message\n    )\n接收端绑定:\n    channel.queue_bind(\n        exchange=\"topic_logs\",\n        queue=queue_name,\n        routing_key=binding_key\n    )\npublisher.py：\nimport sys\nfrom base import channel, connection\n\n\n# 声明exchange\nchannel.exchange_declare(exchange=\"topic_test\", exchange_type=\"topic\")\n\n# 待发送消息\nmessage = \" \".join(sys.argv[1:]) or \"hello topic\"\n\n# 发布消息\nchannel.basic_publish(\n    exchange=\"topic_test\",\n    routing_key=\"mysql.error\",   # 绑定的routing_key\n    body=message\n)\nconnection.close()\nconsumer01.py:\nfrom base import channel, connection\n            \n            \nchannel.exchange_declare(exchange=\"topic_test\", exchange_type=\"topic\")\nresult = channel.queue_declare(exclusive=True)\nqueue_name = result.method.queue\n\n\nchannel.queue_bind(\n    exchange=\"topic_test\",\n    queue=queue_name,\n    routing_key=\"*.error\"    # 绑定的routing_key\n)\n\n\ndef callback(ch, method, properties, body):\n    print(\"body:%s\" % body)\n\n\nchannel.basic_consume(\n    callback,\n    queue=queue_name,\n    no_ack=True\n)\n\n\nchannel.start_consuming()\nconsumer02.py:\nfrom base import channel, connection\n            \n            \nchannel.exchange_declare(exchange=\"topic_test\", exchange_type=\"topic\")\nresult = channel.queue_declare(exclusive=True)\nqueue_name = result.method.queue\n\n\nchannel.queue_bind(\n    exchange=\"topic_test\",\n    queue=queue_name,\n    routing_key=\"mysql.*\"    # 绑定的routing_key\n)\n\n\ndef callback(ch, method, properties, body):\n    print(\"body:%s\" % body)\n\n\nchannel.basic_consume(\n    callback,\n    queue=queue_name,\n    no_ack=True\n)\n\n\nchannel.start_consuming()\n执行:\npython publisher02.py \"this is a topic test\"\npython consumer01.py\npython consumer02.py\n结果:\nconsumer01.py的结果: body:b'this is a topic test'\nconsumer02.py的结果: body:b'this is a topic test'\n说明通过绑定相应的routing_key，两个消费者都收到了消息\n将publisher.py的routing_key改成\"mysql.info\"再此执行:\npython publisher02.py \"this is a topic test\"\npython consumer01.py\npython consumer02.py\n结果:\nconsumer01.py没收到结果\nconsumer02.py的结果: body:b'this is a topic test'\n通过这个例子我们就能明白topic的运行方式了。\n参考自： https://blog.csdn.net/fgf00/a...\n今天就说到这里，如有问题，欢迎交流指正！\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}