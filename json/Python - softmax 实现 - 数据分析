{"title": "Python - softmax 实现 - 数据分析 ", "index": "python,python2.7,python3.5", "content": "Softmax\nsoftmax函数将任意n维的实值向量转换为取值范围在(0,1)之间的n维实值向量，并且总和为1。例如：向量softmax([1.0, 2.0, 3.0]) ------> [0.09003057, 0.24472847, 0.66524096]\n性质：\n\n因为softmax是单调递增函数，因此不改变原始数据的大小顺序。\n将原始输入映射到(0,1)区间，并且总和为1，常用于表征概率。\nsoftmax(x) = softmax(x+c), 这个性质用于保证数值的稳定性。\n\nsoftmax的实现及数值稳定性\n一个最简单的计算给定向量的softmax的实现如下：\nimport numpy as np\ndef softmax(x):\n\"\"\"Compute the softmax of vector x.\"\"\"\n    exp_x = np.exp(x)\n    softmax_x = exp_x / np.sum(exp_x)\n    return softmax_x \n让我们来测试一下上面的代码：\nsoftmax([1, 2, 3])\narray([0.09003057, 0.24472847, 0.66524096])\n但是，当我们尝试输入一个比较大的数值向量时，就会出错：\nsoftmax([1000, 2000, 3000])\narray([nan, nan, nan])\n这是由numpy中的浮点型数值范围限制所导致的。当输入一个较大的数值时，sofmax函数将会超出限制，导致出错。为了解决这一问题，这时我们就能用到sofmax的第三个性质，即：softmax(x) = softmax(x+c)，一般在实际运用中，通常设定c = - max(x)。接下来，我们重新定义softmax函数：\nimport numpy as np\ndef softmax(x):\n\"\"\"Compute the softmax in a numerically stable way.\"\"\"\n    x = x - np.max(x)\n    exp_x = np.exp(x)\n    softmax_x = exp_x / np.sum(exp_x)\n    return softmax_x\n然后再次测试一下：\nsoftmax([1000, 2000, 3000])\narray([ 0.,  0.,  1.])\nDone!\n以上都是基于向量上的softmax实现，下面提供了基于向量以及矩阵的softmax实现，代码如下：\nimport numpy as np\ndef softmax(x):\n    \"\"\"\n    Compute the softmax function for each row of the input x.\n\n    Arguments:\n    x -- A N dimensional vector or M x N dimensional numpy matrix.\n\n    Return:\n    x -- You are allowed to modify x in-place\n    \"\"\"\n    orig_shape = x.shape\n\n    if len(x.shape) > 1:\n        # Matrix\n        exp_minmax = lambda x: np.exp(x - np.max(x))\n        denom = lambda x: 1.0 / np.sum(x)\n        x = np.apply_along_axis(exp_minmax,1,x)\n        denominator = np.apply_along_axis(denom,1,x) \n        \n        if len(denominator.shape) == 1:\n            denominator = denominator.reshape((denominator.shape[0],1))\n        \n        x = x * denominator\n    else:\n        # Vector\n        x_max = np.max(x)\n        x = x - x_max\n        numerator = np.exp(x)\n        denominator =  1.0 / np.sum(numerator)\n        x = numerator.dot(denominator)\n    \n    assert x.shape == orig_shape\n    return x\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "1"}