{"title": "python-动态规划的递归、非递归实现 - python成长日记 ", "index": "python,算法,动态规划", "content": "概要\n本文只是简单的介绍动态规划递归、非递归算法实现\n案例一\n题目一:求数组非相邻最大和\n[题目描述]在一个数组arr中，找出一组不相邻的数字，使得最后的和最大。[示例输入] arr=1 2 4 1 7 8 3[示例输出]15\nfrom functools import wraps\ndef memoDeco(func):\n    '''\n    memoDeco主要是缓存已遍历的节点，减少递归内存开销\n    '''\n    cashe={}\n    @wraps(func)\n    def wrapper(*args):\n        if args not in cashe:\n            cashe[args]=func(*args)\n        return cashe[args]\n    \n    return wrapper\n\n@memoDeco\ndef recMaxArray(array,index):\n    if index==0:\n        return array[0]\n    elif index==1:\n        return max(array[0],array[1])\n    else:\n        return max(recMaxArray(array,index-2)+array[index],recMaxArray(array,index-1))\n    \nif __name__==\"__main__\":\n    array=(1,2,4,1,7,8,3)\n    print(recMaxArray(array,len(array)-1))\n非递归实现\ndef dpMaxArray(array):\n    '''\n    代码讲解详见引用一：正月点灯笼讲解\n    '''\n    lens=len(array)\n    maxArray=[0]*(lens)\n    maxArray[0]=array[0]\n    maxArray[1]=max(array[0],array[1])\n    for i in range(2,lens):\n        maxArray[i]=max(maxArray[i-2]+array[i],maxArray[i-1])\n    return maxArray[-1]\n\n    \nif __name__==\"__main__\":\n    array=(1,2,4,1,7,8,3)\n    print(dpMaxArray(array))\n案例二\n[题目描述]给定一个正整数s, 判断一个数组arr中，是否有一组数字加起来等于s。[示例输入]arr=3 34 4 12 5 3s=9[实例输出]true\n递归实现\nfrom functools import wraps\n\n#和第一题一样，套用装饰器可以做一个缓存节点作用\ndef memoDeco(func):\n    '''\n    memoDeco主要是缓存已遍历的节点，减少递归内存开销\n    '''\n    cashe = {}\n    \n    @wraps(func)\n    def wrapper(*args):\n        if args not in cashe:\n            cashe[args] = func(*args)\n        return cashe[args]\n    \n    return wrapper\n\n\n@memoDeco\ndef recSubSet(arr, index, tar_num):\n    if index == 0:\n        return arr[0] == tar_num\n    elif tar_num == 0:\n        return True\n    elif arr[index] > tar_num:\n        return recSubSet(arr, index - 1, tar_num)\n    else:\n        return recSubSet(arr, index - 1, tar_num) or recSubSet(arr, index - 1, tar_num - index)\n\n\nif __name__ == \"__main__\":\n    arr = (3, 34, 4, 12, 5, 3)\n    tar_num = 13\n    index = len(arr) - 1\n    print(recSubSet(arr, index, tar_num))\n\n非递归实现\n'''\n多维数组构建用python第三方库numpy比较方便\n代码讲解详见引用一：正月点灯笼讲解\n'''\nimport numpy as np\n\n\ndef dpSubSet(arr, tar_num):\n    subSet = np.zeros((len(arr), tar_num + 1), dtype=bool)\n    subSet[:, 0] = True\n    subSet[0, :] = False\n    subSet[0, arr[0]] = True\n    for i in range(1, len(arr)):\n        for j in range(1, tar_num + 1):\n            if arr[i] > j:\n                subSet[i, j] = subSet[i - 1, j]\n            else:\n                subSet[i, j] = subSet[i - 1, j] or subSet[i - 1, j - arr[i]]\n    return subSet[-1, -1]\n\n\nif __name__ == \"__main__\":\n    arr = (3, 34, 4, 12, 5, 3)\n    tar_num = 13\n    print(dpSubSet(arr, tar_num))\n\n引用\n1，正月点灯笼-动态规划\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}