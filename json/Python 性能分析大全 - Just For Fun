{"title": "Python 性能分析大全 - Just For Fun ", "index": "性能分析,python", "content": "虽然运行速度慢是 Python 与生俱来的特点，大多数时候我们用 Python 就意味着放弃对性能的追求。但是，就算是用纯 Python 完成同一个任务，老手写出来的代码可能会比菜鸟写的代码块几倍，甚至是几十倍（这里不考虑算法的因素，只考虑语言方面的因素）。很多时候，我们将自己的代码运行缓慢地原因归结于python本来就很慢，从而心安理得地放弃深入探究。\n但是，事实真的是这样吗？面对python代码，你有分析下面这些问题吗：\n\n程序运行的速度如何？\n程序运行时间的瓶颈在哪里？\n能否稍加改进以提高运行速度呢？\n\n为了更好了解python程序，我们需要一套工具，能够记录代码运行时间，生成一个性能分析报告，方便彻底了解代码，从而进行针对性的优化（本篇侧重于代码性能分析，不关注如何优化）。\n谁快谁慢\n假设有一个字符串，想将里面的空格替换为字符‘-’，用python实现起来很简单，下面是四种方案：\ndef slowest_replace():\n    replace_list = []\n    for i, char in enumerate(orignal_str):\n        c = char if char != \" \" else \"-\"\n        replace_list.append(c)\n    return \"\".join(replace_list)\n\ndef slow_replace():\n    replace_str = \"\"\n    for i, char in enumerate(orignal_str):\n        c = char if char != \" \" else \"-\"\n        replace_str += c\n    return replace_str\n\ndef fast_replace():\n    return \"-\".join(orignal_str.split())\n\ndef fastest_replace():\n    return orignal_str.replace(\" \", \"-\")\n\n这四种方案的效率如何呢，哪种方案比较慢呢？这是一个问题！\n时间断点\n最直接的想法是在开始 replace 函数之前记录时间，程序结束后再记录时间，计算时间差即为程序运行时间。python提供了模块 time，其中 time.clock() 在Unix/Linux下返回的是CPU时间(浮点数表示的秒数)，Win下返回的是以秒为单位的真实时间(Wall-clock time)。\n由于替换函数耗时可能非常短，所以这里考虑分别执行 100000次，然后查看不同函数的效率。我们的性能分析辅助函数如下：\ndef _time_analyze_(func):\n    from time import clock\n    start = clock()\n    for i in range(exec_times):\n        func()\n    finish = clock()\n    print \"{:<20}{:10.6} s\".format(func.__name__ + \":\", finish - start)\n\n这样就可以了解上面程序的运行时间情况：\n\n第一种方案耗时是第四种的 45 倍多，大跌眼镜了吧！同样是 python代码，完成一样的功能，耗时可以差这么多。\n为了避免每次在程序开始、结束时插入时间断点，然后计算耗时，可以考虑实现一个上下文管理器，具体代码如下：\nclass Timer(object):\n    def __init__(self, verbose=False):\n        self.verbose = verbose\n\n    def __enter__(self):\n        self.start = clock()\n        return self\n\n    def __exit__(self, *args):\n        self.end = clock()\n        self.secs = self.end - self.start\n        self.msecs = self.secs * 1000  # millisecs\n        if self.verbose:\n            print 'elapsed time: %f ms' % self.msecs\n\n使用时只需要将要测量时间的代码段放进 with 语句即可，具体的使用例子放在 gist 上。\ntimeit\n上面手工插断点的方法十分原始，用起来不是那么方便，即使用了上下文管理器实现起来还是略显笨重。还好 Python 提供了timeit模块，用来测试代码块的运行时间。它既提供了命令行接口，又能用于代码文件之中。\n命令行接口\n命令行接口可以像下面这样使用：\n$ python -m timeit -n 1000000 '\"I like to reading.\".replace(\" \", \"-\")'\n1000000 loops, best of 3: 0.253 usec per loop\n$ python -m timeit -s 'orignal_str = \"I like to reading.\"' '\"-\".join(orignal_str.split())'\n1000000 loops, best of 3: 0.53 usec per loop\n\n具体参数使用可以用命令 python -m timeit -h 查看帮助。使用较多的是下面的选项：\n\n-s S, --setup=S: 用来初始化statement中的变量，只运行一次；\n-n N, --number=N: 执行statement的次数，默认会选择一个合适的数字；\n-r N, --repeat=N: 重复测试的次数，默认为3；\n\nPython 接口\n可以用下面的程序测试四种 replace函数的运行情况（完整的测试程序可以在 gist 上找到）：\ndef _timeit_analyze_(func):\n    from timeit import Timer\n    t1 = Timer(\"%s()\" % func.__name__, \"from __main__ import %s\" % func.__name__)\n    print \"{:<20}{:10.6} s\".format(func.__name__ + \":\", t1.timeit(exec_times))\n\n运行结果如下：\n\nPython的timeit提供了 timeit.Timer() 类，类构造方法如下：\nTimer(stmt='pass', setup='pass', timer=<timer function>)\n\n其中：\n\nstmt: 要计时的语句或者函数；\nsetup: 为stmt语句构建环境的导入语句；\ntimer: 基于平台的时间函数(timer function)；\n\nTimer()类有三个方法：\n\ntimeit(number=1000000): 返回stmt执行number次的秒数(float)；\nrepeat(repeat=3, number=1000000): repeat为重复整个测试的次数，number为执行stmt的次数，返回以秒记录的每个测试循环的耗时列表；\nprint_exc(file=None): 打印stmt的跟踪信息。\n\n此外，timeit 还提供了另外三个函数方便使用，参数和 Timer 差不多。\ntimeit.timeit(stmt='pass', setup='pass', timer=<default timer>, number=1000000)\ntimeit.repeat(stmt='pass', setup='pass', timer=<default timer>, repeat=3, number=1000000)\ntimeit.default_timer()\n\nprofile\n以上方法适用于比较简单的场合，更复杂的情况下，可以用标准库里面的profile或者cProfile，它可以统计程序里每一个函数的运行时间，并且提供了可视化的报表。大多情况下，建议使用cProfile，它是profile的C实现，适用于运行时间长的程序。不过有的系统可能不支持cProfile，此时只好用profile。\n可以用下面程序测试 timeit_profile() 函数运行时间分配情况。\nimport cProfile\nfrom time_profile import *\n\ncProfile.run(\"timeit_profile()\")\n\n这样的输出可能会很长，很多时候我们感兴趣的可能只有耗时最多的几个函数，这个时候先将cProfile 的输出保存到诊断文件中，然后用 pstats 定制更加有好的输出（完整代码在 gist 上）。\ncProfile.run(\"timeit_profile()\", \"timeit\")\np = pstats.Stats('timeit')\np.sort_stats('time')\np.print_stats(6)\n\n输出结果如下：\n\n如果觉得 pstas 使用不方便，还可以使用一些图形化工具，比如 gprof2dot 来可视化分析 cProfile 的诊断结果。\nvprof\nvprof 也是一个不错的可视化工具，可以用来分析 Python 程序运行时间情况。如下图：\n\nline_profiler\n上面的测试最多统计到函数的执行时间，很多时候我们想知道函数里面每一行代码的执行效率，这时候就可以用到 line_profiler 了。\nline_profiler 的使用特别简单，在需要监控的函数前面加上 @profile 装饰器。然后用它提供的 kernprof -l -v [source_code.py] 行进行诊断。下面是一个简单的测试程序 line_profile.py：\nfrom time_profile import slow_replace, slowest_replace\n\nfor i in xrange(10000):\n    slow_replace()\n    slowest_replace()\n\n运行后结果如下：\n\n输出每列的含义如下：\n\nLine #: 行号\nHits: 当前行执行的次数.\nTime: 当前行执行耗费的时间，单位为 \"Timer unit:\"\nPer Hit: 平均执行一次耗费的时间.\n% Time: 当前行执行时间占总时间的比例.\nLine Contents: 当前行的代码\n\nline_profiler 执行时间的估计不是特别精确，不过可以用来分析当前函数中哪些行是瓶颈。\n博客地址\n更多阅读\nA guide to analyzing Python performance  timeit – Time the execution of small bits of Python code  Profiling Python using cProfile: a concrete case  profile, cProfile, and pstats – Performance analysis of Python programs.  How can you profile a Python script?  检测Python程序执行效率及内存和CPU使用的7种方法  代码优化概要  Python性能优化的20条建议\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "20"}