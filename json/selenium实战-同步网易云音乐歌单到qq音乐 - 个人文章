{"title": "selenium实战-同步网易云音乐歌单到qq音乐 - 个人文章 ", "index": "python,网页爬虫", "content": "本文主要介绍selenium在爬虫脚本的实际应用。适合刚接触python，没使用过selenium的童鞋。(如果你是老司机路过的话，帮忙点个star吧)\n项目地址\nhttps://github.com/Denon/sync...\nselenium介绍\nselenium官网. 直接引用官网的话\nSelenium automates browsers. That's it! What you do with that power is entirely up to you. Primarily, it is for automating web applications for testing purposes, but is certainly not limited to just that. Boring web-based administration tasks can (and should!) also be automated as well.\n简单翻译下\nselenium是一个自动化的浏览器, 主要使用来做web应用的自动化测试。\n个人认为用selenium主要的好处是: 可以解析js渲染的页面。对于这次的爬虫来说， 由于网易云音乐以及qq音乐网页中大部分元素都是使用js渲染生成的， 因此选择使用selenium来完成这次的脚本。\n环境准备\n\npython 2.7\nselenium\nphantomjs / Chromium\n\nselenium 运行需要额外的浏览器支持. 其中phantomjs可以在这里下载, Chromium可以在这里下载。 前期debug阶段建议使用 Chromium 。\n详细的包依赖请查看github项目\n\n流程\n\n初始化selenium\n从网易云音乐歌单网页中获取歌曲列表\n登录qq音乐\n搜索音乐\n添加到qq音乐的歌单中\n\n初始化selenium\nfrom selenium import webdriver\n# 这里是使用PhantomJs, 如果使用chromium则使用webdriver.Chrome(),\n# 并替换对应的驱动路径即可\nphantomjs_driver = phantomjs_driver_path\n\nopts = Options()\nopts.add_argument(\"user-agent={}\".format(headers[\"User-Agent\"]))\nbrowser = webdriver.PhantomJS(phantomjs_driver)\n从网易云音乐中获取音乐\n对于一般爬虫来说, 如果能用手机端网页爬取那就无脑选网页端爬取。可以发现网易云音乐的手机版歌单地址是: http://music.163.com/m/playli... 。 这个地址么一看就知道, 后面那串id就是歌单id。chrome浏览器打开调试工具, 可以看到所有的歌曲都在<span class=\"detail\">...</span>里面。 那么直接用requests + beautifulsoup 爬取元素就好。 这里就不深入讨论了。 具体的代码请参考项目\n登录qq音乐\n一般来说，爬虫做登录有两种选择。一种是抓包，分析登录请求体，直接模拟登录，这种稳定性较好，只要解析出请求体后，登录一般都能成功。一种是模拟正常登录操作，在输入框中输入账号密码，然后点击登录按钮来登录，这种稳定性较差，有可能会有各种意外的情况，比如验证码之类的。这里当然要使用第二种来做(不然就跑题了)。\n首先打开qq音乐网站, 发现qq登录的按钮在\n这里介绍selenium第一个函数find_element_by_xpath，这个函数就是根据element的xpath来获取元素的。\nbrowser.find_element_by_xpath(\"/html/body/div[1]/div/div[2]/span/a[2]\").click()\n点击完后, 页面应该会弹出一个登录框, 不过默认应该是扫码登录, 这个时候就要点击下“帐号密码登录”来切换。可以发现, 这个切换按钮的id是switcher_plogin. 那么使用selenium的 find_element_by_id 函数:\nbrowser.find_element_by_id(\"switcher_plogin\").click()\n按理来说这段代码应该能运行成功，但是如无意外的话，我们只能获得一个报错\nselenium.common.exceptions.NoSuchElementException: Message: no such element: Unable to locate element: {\"method\":\"id\",\"selector\":\"switcher_plogin\"}\n这是什么情况？？？\n细心点观察可以发现，这个弹出来的登录框是在一个iframe里面。这个时候需要使用到另外一个函数switch_to.frame，\n# 切换iframe\nbrowser.switch_to.frame(\"frame_tips\")\nbrowser.find_element_by_id(\"switcher_plogin\").click()\n# 输入账号密码, 用到send_keys函数\nuser_input = browser.find_element_by_id(\"u\")\nuser_input.send_keys(\"qq_account\")\npwd_input = self.browser.find_element_by_id(\"p\")\npwd_input.send_keys(\"qq_password\")\n# 最后要切换回来\nbrowser.switch_to.default_content()\n可以发现ok了，然后账号密码等输入框直接用上面介绍过的函数直接获取就行。\n搜索歌曲\n在浏览器中打开qq音乐实际搜索一下，发现搜索的url是 https://y.qq.com/portal/search.html#page=1&searchid=1&remoteplace=txt.yqq.top&t=song&w=%E6%B5%AE%E5%A4%B8，可以看到搜索的关键词在 w 这个参数里面，并且中文字是被url encode过的。那么这里使用python内置的urllib2包即可\nfrom urllib2 import quote\nurl_sw = quote(search_word.encode('utf8'))\n由于python2坑爹的编码问题, 一般把字符存储成unicode, 在需要使用的时候再转换对应编码比较合适。\n添加到歌单\n人工添加歌单的操作实际分为三步:\n\n鼠标移动到歌曲上\n点击 + 号\n点击对应的歌单\n\n观察html元素可以发现，搜索出来的歌曲都在<div class=\"songlist__songname\">...</div>里面。这里使用find_elements_by_class_name这个函数\nall_song = browser.find_elements_by_class_name(\"songlist__list\")\n点击完以后，可以看到歌单的html元素都在<li class=\"operate_menu__item\">里面。\nall_playlist = browser.find_elements_by_class_name(\"operate_menu__item\")\n而其中每个歌单是以data-dirid这个属性来区分的，这里介绍另外一个元素选择函数find_element_by_css_selector\nbrowser.find_element_by_css_selector(\"a[data-dirid='{}']\").click()\n那么就这样结束了么? 当然不是！ 实际运行中发现，这里面大部分元素都是js渲染生成的，直接使用selenium函数去获取这些元素，很大可能会报错\nselenium.common.exceptions.ElementNotVisibleException: Message: element not visible\n碰到这种情况，最好的解决办法是，用selenium直接执行js脚本来调用元素，selenium执行js脚本的函数为execute_script\nbrowser.execute_script(\"document.getElementsByClassName('songlist__list')[0].firstElementChild.getElementsByClassName('list_menu__add')[0].click()\"\n而js代码是可以直接在浏览器上debug的，一般现在浏览器上执行成功在复制回来。\n其他一些辅助方法\n在实际操作中，虽然使用的方法是正确的，但会出现很多意外的情况导致本次操作是失败的，这时候就需要来一次重试来解决问题(如果一次重试解决不了问题，那就来两次)。这里使用一个装饰器来写\ndef retry(retry_times=0, exc_class=Exception, notice_message=None, print_exc=False):\n    '''retry_times: 重试次数\n    exc_class: 捕捉的异常\n    notice_message: 提示信息\n    print_exc: 是否打印错误信息\n    '''\n    def wrapper(f):\n        @functools.wraps(f)\n        def inner_wrapper(*args, **kwargs):\n            current = 0\n            while True:\n                try:\n                    return f(*args, **kwargs)\n                except exc_class as e:\n                    if print_exc:\n                        traceback.print_exc()\n                    if current >= retry_times:\n                        raise RetryException()\n                    if notice_message:\n                        print notice_message\n                    current += 1\n        return inner_wrapper\n    return wrapper\n总结\n\n介绍了selenium获取元素的各种用法，更多的请参考文档\n解决使用selenium可能会碰到的一些坑。\n最后在安利一次github项目, https://github.com/Denon/sync...。欢迎点赞以及提issue。现在已经支持网易云音乐与qq音乐歌单的互相同步。\n\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "3"}