{"title": "看例子，学 Python（三） - 止于至善 ", "index": "python", "content": "看例子，学 Python（三）\n看例子，学 Python（一）看例子，学 Python（二）\n包\n创建一个目录 myutil，把 mymath.py 挪到里面，再添加一个空文件 __init__.py：\nmyutil/\n    __init__.py\n    mymath.py\nmyutil 便是一个包（package）。\nimport\n最直接的用法：\n>>> import myutil.mymath\n>>> myutil.mymath.fac(4)\n24\n缺点是调用 fac 时太长，包和模块作为前缀都要写全。但是写成 import myutil.mymath.fac 也是不对的。通过 import 的语法（syntax）：\nimport <包>.<包>.<包|模块>\n可以看出：\n\n最后一项（item）可以是包也可以是模块，前面的必须是包；\n最后一项不可以是类、函数或变量的定义。\n\n根据语法来看，可以 import 一个包：\n>>> import myutil\n>>> help(myutil)\n...\n但是这样并没有什么实际用处，因为无法就此调用具体的函数（类、变量）：\n>>> myutil.mymath.fac(4)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nAttributeError: module 'myutil' has no attribute 'mymath'\nfrom...import\n如果要避免调用时带着一串前缀，可以用 from...import：\n>>> from myutil.mymath import fac\n>>> fac(4)  # 不再需要前缀\n24\n一次 import 多个时以逗号分割：\n>>> from myutil.mymath import fib, fac\n一次 import 所有：\n>>> from myutil.mymath import *\nfrom...import... 避免了前缀，但是也污染了名字，使用时需权衡。\n高阶函数\n高阶函数（higher-order）就是操作或返回其它函数的函数。下面是几个经典的高阶函数，其它稍微函数式一点的语言里一般也有。\nreduce（规约）\n用 reduce 重写阶乘：\nimport operator, functools\ndef fac(n):\n    return functools.reduce(operator.mul, range(1, n+1))\n用 reduce 求和:\ndef sum(n):\n    return functools.reduce(operator.add, range(1, n+1))\nPython 的 reduce 就相当于 C++ 的 accumulate（C++17 已经新增 reduce）。\nstd::vector<int> v{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\nint sum = std::accumulate(v.begin(), v.end(), 0);  // 求和\nint product = std::accumulate(v.begin(), v.end(), 1, std::multiplies<int>());  // 求积\nmap（映射）\n>>> list(map(bool, [None, 0, \"\", u\"\", list(), tuple(), dict(), set(), frozenset()]))\n[False, False, False, False, False, False, False, False, False]\nNone、0、空字符串、以及没有元素的容器对象都可视为 False，反之为 True。\nfilter（过滤）\n>>> list(filter(bool, [None, 0, \"\", 1]))\n[1]\n数据模型\n== vs. is\n== 判断值是否相等，is 判断两个变量是否为同一个对象。这就好像 Java 里的 == 和 equals 一样。下面是一些例子：\n>>> a, b = 1, 1\n>>> a == b\nTrue\n>>> a is b\nTrue\na == b 比较好理解，a is b 是因为 Python 对整数做了优化，a 和 b 都指向同一个预先分配的对象（其值为 1）。可以理解为 is 比较的是对象的内存地址。内建函数 id() 返回对象的唯一标识，可以理解为内存地址。\n>>> id(a), id(b)\n(35169392, 35169392)\n甚至可以拿到一个对象的引用计数（reference count）：\n>>> import sys\n>>> sys.getrefcount(a)\n99\n>>> sys.getrefcount(b)\n99\n引用计数为 99 有点意外，其实是因为很多装载的内建模块都用到了整数 1。不妨看看其它整数如何：\n>>> sys.getrefcount(0)\n169\n>>> sys.getrefcount(255)\n4\n对 Python 来说，变量只是名字，它的类型和值取决于它所绑定的对象。我们可以把 a b 绑定到其它对象：\n>>> a, b = \"hello\", \"hello\"\n>>> a is b\nTrue\n同样，a is b 是因为 Python 对字符串做了优化。\n值得一提的是，这种优化（也即引用计数）可能只针对 CPython，对于 Python 的其它实现可能就不是这样了。你的程序不该依赖于这些特定于解释器的实现。\n整数和字符串有一个共同点，即它们都是不可变的（immutable），现在来看看可变对象，比如列表：\n>>> c, d = [a, b], [a, b]\n>>> c == d\nTrue\n>>> c is d\nFalse\n可见虽然 c 和 d 具有相等的值，但对象是不同的两个。\n这些就是 Python 的数据模型（Data Model），虽然不是全部。\n对象\nPython 的每一个对象（object）都有以下三个部分：\n\n身份（identity）\n类型（type）\n值（value）\n\n身份：\n\n不可改变（unchangeable）（一旦对象创建了就不会改变）\n对应于内存地址\n通过操作符 is 进行比较: a is b\n函数 id() 返回对象唯一的整形标识（内存地址)\n\n类型：\n\n不可改变（unchangeable）\n函数 type() 返回对象类型\n\n值：\n\n可变的（mutable）：字典，列表\n不可变的（immutable）：数字，字符串，元组\n\n最后，对象不会被显式地销毁（explicitly destroyed）。对 CPython 来说，对象由引用计数管理，计数为 0 时对象会自动销毁。\n练习\n最后留一道练习。\n给定：\n>>> c = []\n>>> d = []\n>>> c is d\nFalse\n请问：\n>>> e = f = []\n>>> e is f\n???\n看例子，学 Python（一）看例子，学 Python（二）\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "9"}