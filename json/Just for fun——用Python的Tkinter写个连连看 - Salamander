{"title": "Just for fun——用Python的Tkinter写个连连看 - Salamander ", "index": "python,python3.x", "content": "UI\n\n代码\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# @Date    : 2017-10-02 15:19:24\n# @Author  : Salamander    (*********@qq.com)\n# @Link    : http://51lucy.com\n\nimport os, random\nimport tkinter as tk\nimport tkinter.messagebox\nfrom PIL import Image, ImageTk\n\nclass MainWindow():\n    __gameTitle = \"连连看游戏\"\n    __windowWidth = 700\n    __windowHeigth = 500\n    __icons = []\n    __gameSize = 10 # 游戏尺寸\n    __iconKind = __gameSize * __gameSize / 4 # 小图片种类数量\n    __iconWidth = 40\n    __iconHeight = 40\n    __map = [] # 游戏地图\n    __delta = 25\n    __isFirst = True\n    __isGameStart = False\n    __formerPoint = None\n    EMPTY = -1\n    NONE_LINK = 0\n    STRAIGHT_LINK = 1\n    ONE_CORNER_LINK = 2\n    TWO_CORNER_LINK = 3\n\n    def __init__(self):\n        self.root = tk.Tk()\n        self.root.title(self.__gameTitle)\n        self.centerWindow(self.__windowWidth, self.__windowHeigth)\n        self.root.minsize(460, 460)\n\n        self.__addComponets()\n        self.extractSmallIconList()\n\n        self.root.mainloop()\n\n    def __addComponets(self):\n        self.menubar = tk.Menu(self.root, bg=\"lightgrey\", fg=\"black\")\n\n        self.file_menu = tk.Menu(self.menubar, tearoff=0, bg=\"lightgrey\", fg=\"black\")\n        self.file_menu.add_command(label=\"新游戏\", command=self.file_new, accelerator=\"Ctrl+N\")\n\n        self.menubar.add_cascade(label=\"游戏\", menu=self.file_menu)\n        self.root.configure(menu=self.menubar)\n\n        self.canvas = tk.Canvas(self.root, bg = 'white', width = 450, height = 450)\n        self.canvas.pack(side=tk.TOP, pady = 5)\n        self.canvas.bind('<Button-1>', self.clickCanvas)\n        \n\n    def centerWindow(self, width, height):\n        screenwidth = self.root.winfo_screenwidth()  \n        screenheight = self.root.winfo_screenheight()  \n        size = '%dx%d+%d+%d' % (width, height, (screenwidth - width)/2, (screenheight - height)/2)\n        self.root.geometry(size)\n\n\n    def file_new(self, event=None):\n        self.iniMap()\n        self.drawMap()\n        self.__isGameStart = True\n\n    def clickCanvas(self, event):\n        if self.__isGameStart:\n            point = self.getInnerPoint(Point(event.x, event.y))\n            # 有效点击坐标\n            if point.isUserful() and not self.isEmptyInMap(point):\n                if self.__isFirst:\n                    self.drawSelectedArea(point)\n                    self.__isFirst= False\n                    self.__formerPoint = point\n                else:\n                    if self.__formerPoint.isEqual(point):\n                        self.__isFirst = True\n                        self.canvas.delete(\"rectRedOne\")\n                    else:\n                        linkType = self.getLinkType(self.__formerPoint, point)\n                        if linkType['type'] != self.NONE_LINK:\n                            # TODO Animation\n                            self.ClearLinkedBlocks(self.__formerPoint, point)\n                            self.canvas.delete(\"rectRedOne\")\n                            self.__isFirst = True\n                            if self.isGameEnd():\n                                tk.messagebox.showinfo(\"You Win!\", \"Tip\")\n                                self.__isGameStart = False\n                        else:\n                            self.__formerPoint = point\n                            self.canvas.delete(\"rectRedOne\")\n                            self.drawSelectedArea(point)\n\n\n    # 判断游戏是否结束\n    def isGameEnd(self):\n        for y in range(0, self.__gameSize):\n            for x in range(0, self.__gameSize):\n                if self.__map[y][x] != self.EMPTY:\n                    return False\n        return True\n\n                            \n\n    '''\n    提取小头像数组\n    '''\n    def extractSmallIconList(self):\n        imageSouce = Image.open(r'images\\NARUTO.png')\n        for index in range(0, int(self.__iconKind)):\n            region = imageSouce.crop((self.__iconWidth * index, 0, \n                    self.__iconWidth * index + self.__iconWidth - 1, self.__iconHeight - 1))\n            self.__icons.append(ImageTk.PhotoImage(region))\n\n    '''\n    初始化地图 存值为0-24\n    '''\n    def iniMap(self):\n        self.__map = [] # 重置地图\n        tmpRecords = []\n        records = []\n        for i in range(0, int(self.__iconKind)):\n            for j in range(0, 4):\n                tmpRecords.append(i)\n\n        total = self.__gameSize * self.__gameSize\n        for x in range(0, total):\n            index = random.randint(0, total - x - 1)\n            records.append(tmpRecords[index])\n            del tmpRecords[index]\n\n        # 一维数组转为二维，y为高维度\n        for y in range(0, self.__gameSize):\n            for x in range(0, self.__gameSize):\n                if x == 0:\n                    self.__map.append([])\n                self.__map[y].append(records[x + y * self.__gameSize])\n\n    '''\n    根据地图绘制图像\n    '''\n    def drawMap(self):\n        self.canvas.delete(\"all\")\n        for y in range(0, self.__gameSize):\n            for x in range(0, self.__gameSize):\n                point = self.getOuterLeftTopPoint(Point(x, y))\n                im = self.canvas.create_image((point.x, point.y), \n                    image=self.__icons[self.__map[y][x]], anchor='nw', tags = 'im%d%d' % (x, y))\n\n    '''\n    获取内部坐标对应矩形左上角顶点坐标\n    '''\n    def getOuterLeftTopPoint(self, point):\n        return Point(self.getX(point.x), self.getY(point.y))\n\n    '''\n    获取内部坐标对应矩形中心坐标\n    '''\n    def getOuterCenterPoint(self, point):\n        return Point(self.getX(point.x) + int(self.__iconWidth / 2), \n                self.getY(point.y) + int(self.__iconHeight / 2))\n        \n    def getX(self, x):\n        return x * self.__iconWidth + self.__delta\n\n    def getY(self, y):\n        return y * self.__iconHeight + self.__delta\n\n    '''\n    获取内部坐标\n    '''\n    def getInnerPoint(self, point):\n        x = -1\n        y = -1\n\n        for i in range(0, self.__gameSize):\n            x1 = self.getX(i)\n            x2 = self.getX(i + 1)\n            if point.x >= x1 and point.x < x2:\n                x = i\n\n        for j in range(0, self.__gameSize):\n            j1 = self.getY(j)\n            j2 = self.getY(j + 1)\n            if point.y >= j1 and point.y < j2:\n                y = j\n\n        return Point(x, y)\n\n    '''\n    选择的区域变红，point为内部坐标\n    '''\n    def drawSelectedArea(self, point):\n        pointLT = self.getOuterLeftTopPoint(point)\n        pointRB = self.getOuterLeftTopPoint(Point(point.x + 1, point.y + 1))\n        self.canvas.create_rectangle(pointLT.x, pointLT.y, \n                pointRB.x - 1, pointRB.y - 1, outline = 'red', tags = \"rectRedOne\")\n\n\n    '''\n    消除连通的两个块\n    '''\n    def ClearLinkedBlocks(self, p1, p2):\n        self.__map[p1.y][p1.x] = self.EMPTY\n        self.__map[p2.y][p2.x] = self.EMPTY\n        self.canvas.delete('im%d%d' % (p1.x, p1.y))\n        self.canvas.delete('im%d%d' % (p2.x, p2.y))\n\n    '''\n    地图上该点是否为空\n    '''\n    def isEmptyInMap(self, point):\n        if self.__map[point.y][point.x] == self.EMPTY:\n            return True\n        else:\n            return False\n\n    '''\n    获取两个点连通类型\n    '''\n    def getLinkType(self, p1, p2):\n        # 首先判断两个方块中图片是否相同\n        if self.__map[p1.y][p1.x] != self.__map[p2.y][p2.x]:\n            return { 'type': self.NONE_LINK }\n\n        if self.isStraightLink(p1, p2):\n            return {\n                'type': self.STRAIGHT_LINK\n            }\n        res = self.isOneCornerLink(p1, p2)\n        if res:\n            return {\n                'type': self.ONE_CORNER_LINK,\n                'p1': res\n            }\n        res = self.isTwoCornerLink(p1, p2)\n        if res:\n            return {\n                'type': self.TWO_CORNER_LINK,\n                'p1': res['p1'],\n                'p2': res['p2']\n            }\n        return {\n            'type': self.NONE_LINK\n        }\n\n\n    '''\n    直连\n    '''\n    def isStraightLink(self, p1, p2):\n        start = -1\n        end = -1\n        # 水平\n        if p1.y == p2.y:\n            # 大小判断\n            if p2.x < p1.x:\n                start = p2.x\n                end = p1.x\n            else:\n                start = p1.x\n                end = p2.x\n            for x in range(start + 1, end):\n                if self.__map[p1.y][x] != self.EMPTY:\n                    return False\n            return True\n        elif p1.x == p2.x:\n            if p1.y > p2.y:\n                start = p2.y\n                end = p1.y\n            else:\n                start = p1.y\n                end = p2.y\n            for y in range(start + 1, end):\n                if self.__map[y][p1.x] != self.EMPTY:\n                    return False\n            return True\n        return False\n\n    def isOneCornerLink(self, p1, p2):\n        pointCorner = Point(p1.x, p2.y)\n        if self.isStraightLink(p1, pointCorner) and self.isStraightLink(pointCorner, p2) and self.isEmptyInMap(pointCorner):\n            return pointCorner\n\n        pointCorner = Point(p2.x, p1.y)\n        if self.isStraightLink(p1, pointCorner) and self.isStraightLink(pointCorner, p2) and self.isEmptyInMap(pointCorner):\n            return pointCorner\n\n    def isTwoCornerLink(self, p1, p2):\n        for y in range(-1, self.__gameSize + 1):\n            pointCorner1 = Point(p1.x, y)\n            pointCorner2 = Point(p2.x, y)\n            if y == p1.y or y == p2.y:\n                continue\n            if y == -1 or y == self.__gameSize:\n                if self.isStraightLink(p1, pointCorner1) and self.isStraightLink(pointCorner2, p2):\n                    return {'p1': pointCorner1, 'p2': pointCorner2}\n            else:\n                if self.isStraightLink(p1, pointCorner1) and self.isStraightLink(pointCorner1, pointCorner2) and self.isStraightLink(pointCorner2, p2) and self.isEmptyInMap(pointCorner1) and self.isEmptyInMap(pointCorner2):\n                    return {'p1': pointCorner1, 'p2': pointCorner2}\n\n        # 横向判断\n        for x in range(-1, self.__gameSize + 1):\n            pointCorner1 = Point(x, p1.y)\n            pointCorner2 = Point(x, p2.y)\n            if x == p1.x or x == p2.x:\n                continue\n            if x == -1 or x == self.__gameSize:\n                if self.isStraightLink(p1, pointCorner1) and self.isStraightLink(pointCorner2, p2):\n                    return {'p1': pointCorner1, 'p2': pointCorner2}\n            else:\n                if self.isStraightLink(p1, pointCorner1) and self.isStraightLink(pointCorner1, pointCorner2) and self.isStraightLink(pointCorner2, p2) and self.isEmptyInMap(pointCorner1) and self.isEmptyInMap(pointCorner2):\n                    return {'p1': pointCorner1, 'p2': pointCorner2}\n\n\nclass Point():\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def isUserful(self):\n        if self.x >= 0 and self.y >= 0:\n            return True\n        else:\n            return False\n                    \n    '''\n    判断两个点是否相同\n    '''\n    def isEqual(self, point):\n        if self.x == point.x and self.y == point.y:\n            return True\n        else:\n            return False\n\n    '''\n    克隆一份对象\n    '''\n    def clone(self):\n        return Point(self.x, self.y)\n\n\n    '''\n    改为另一个对象\n    '''\n    def changeTo(self, point):\n        self.x = point.x\n        self.y = point.y\n\nMainWindow()\n\n使用\n完整源码在GitHub上，主要就是三种连通情况的判断。很早之前用C#也是写过一个，但是写的不好，这次用python写，看看自己有木有提升。\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "9"}