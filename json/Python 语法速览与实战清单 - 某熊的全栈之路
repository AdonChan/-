{"title": "Python 语法速览与实战清单 - 某熊的全栈之路 ", "index": "python", "content": "\n本文是对于 现代 Python 开发：语法基础与工程实践的总结，更多 Python 相关资料参考 Python 学习与实践资料索引；本文参考了 Python Crash Course - Cheat Sheets，pysheeet 等。本文仅包含笔者在日常工作中经常使用的，并且认为较为关键的知识点与语法，如果想要进一步学习 Python 相关内容或者对于机器学习与数据挖掘方向感兴趣，可以参考程序猿的数据科学与机器学习实战手册。\n基础语法\nPython 是一门高阶、动态类型的多范式编程语言；定义 Python 文件的时候我们往往会先声明文件编码方式:\n# 指定脚本调用方式\n#!/usr/bin/env python\n# 配置 utf-8 编码\n# -*- coding: utf-8 -*-\n\n# 配置其他编码\n# -*- coding: <encoding-name> -*-\n\n# Vim 中还可以使用如下方式\n# vim:fileencoding=<encoding-name>\n人生苦短，请用 Python，大量功能强大的语法糖的同时让很多时候 Python 代码看上去有点像伪代码。譬如我们用 Python 实现的简易的快排相较于 Java 会显得很短小精悍:\ndef quicksort(arr):\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[len(arr) / 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    return quicksort(left) + middle + quicksort(right)\n    \nprint quicksort([3,6,8,10,1,2,1])\n# Prints \"[1, 1, 2, 3, 6, 8, 10]\"\n控制台交互\n可以根据 __name__ 关键字来判断是否是直接使用 python 命令执行某个脚本，还是外部引用；Google 开源的 fire 也是不错的快速将某个类封装为命令行工具的框架：\nimport fire\n\nclass Calculator(object):\n  \"\"\"A simple calculator class.\"\"\"\n\n  def double(self, number):\n    return 2 * number\n\nif __name__ == '__main__':\n  fire.Fire(Calculator)\n\n# python calculator.py double 10  # 20\n# python calculator.py double --number=15  # 30\nPython 2 中 print 是表达式，而 Python 3 中 print 是函数；如果希望在 Python 2 中将 print 以函数方式使用，则需要自定义引入:\nfrom __future__ import print_function\n我们也可以使用 pprint 来美化控制台输出内容：\nimport pprint\n\nstuff = ['spam', 'eggs', 'lumberjack', 'knights', 'ni']\npprint.pprint(stuff)\n\n# 自定义参数\npp = pprint.PrettyPrinter(depth=6)\ntup = ('spam', ('eggs', ('lumberjack', ('knights', ('ni', ('dead',('parrot', ('fresh fruit',))))))))\npp.pprint(tup)\n模块\nPython 中的模块（Module）即是 Python 源码文件，其可以导出类、函数与全局变量；当我们从某个模块导入变量时，函数名往往就是命名空间（Namespace）。而 Python 中的包（Package）则是模块的文件夹，往往由 __init__.py 指明某个文件夹为包:\n# 文件目录\nsomeDir/\n    main.py\n    siblingModule.py\n\n# siblingModule.py\n\ndef siblingModuleFun():\n    print('Hello from siblingModuleFun')\n    \ndef siblingModuleFunTwo():\n    print('Hello from siblingModuleFunTwo')\n\nimport siblingModule\nimport siblingModule as sibMod\n\nsibMod.siblingModuleFun()\n\nfrom siblingModule import siblingModuleFun\nsiblingModuleFun()\n\ntry:\n    # Import 'someModuleA' that is only available in Windows\n    import someModuleA\nexcept ImportError:\n    try:\n        # Import 'someModuleB' that is only available in Linux\n        import someModuleB\n    except ImportError:\nPackage 可以为某个目录下所有的文件设置统一入口:\nsomeDir/\n    main.py\n    subModules/\n        __init__.py\n        subA.py\n        subSubModules/\n            __init__.py\n            subSubA.py\n\n# subA.py\n\ndef subAFun():\n    print('Hello from subAFun')\n    \ndef subAFunTwo():\n    print('Hello from subAFunTwo')\n\n# subSubA.py\n\ndef subSubAFun():\n    print('Hello from subSubAFun')\n    \ndef subSubAFunTwo():\n    print('Hello from subSubAFunTwo')\n\n# __init__.py from subDir\n\n# Adds 'subAFun()' and 'subAFunTwo()' to the 'subDir' namespace \nfrom .subA import *\n\n# The following two import statement do the same thing, they add 'subSubAFun()' and 'subSubAFunTwo()' to the 'subDir' namespace. The first one assumes '__init__.py' is empty in 'subSubDir', and the second one, assumes '__init__.py' in 'subSubDir' contains 'from .subSubA import *'.\n\n# Assumes '__init__.py' is empty in 'subSubDir'\n# Adds 'subSubAFun()' and 'subSubAFunTwo()' to the 'subDir' namespace\nfrom .subSubDir.subSubA import *\n\n# Assumes '__init__.py' in 'subSubDir' has 'from .subSubA import *'\n# Adds 'subSubAFun()' and 'subSubAFunTwo()' to the 'subDir' namespace\nfrom .subSubDir import *\n# __init__.py from subSubDir\n\n# Adds 'subSubAFun()' and 'subSubAFunTwo()' to the 'subSubDir' namespace\nfrom .subSubA import *\n\n# main.py\n\nimport subDir\n\nsubDir.subAFun() # Hello from subAFun\nsubDir.subAFunTwo() # Hello from subAFunTwo\nsubDir.subSubAFun() # Hello from subSubAFun\nsubDir.subSubAFunTwo() # Hello from subSubAFunTwo\n表达式与控制流\n条件选择\nPython 中使用 if、elif、else 来进行基础的条件选择操作：\nif x < 0:\n     x = 0\n     print('Negative changed to zero')\n elif x == 0:\n     print('Zero')\n else:\n     print('More')\nPython 同样支持 ternary conditional operator:\na if condition else b\n也可以使用 Tuple 来实现类似的效果：\n# test 需要返回 True 或者 False\n(falseValue, trueValue)[test]\n\n# 更安全的做法是进行强制判断\n(falseValue, trueValue)[test == True]\n\n# 或者使用 bool 类型转换函数\n(falseValue, trueValue)[bool(<expression>)]\n循环遍历\nfor-in 可以用来遍历数组与字典：\nwords = ['cat', 'window', 'defenestrate']\n\nfor w in words:\n    print(w, len(w))\n\n# 使用数组访问操作符，能够迅速地生成数组的副本\nfor w in words[:]:\n    if len(w) > 6:\n        words.insert(0, w)\n\n# words -> ['defenestrate', 'cat', 'window', 'defenestrate']\n如果我们希望使用数字序列进行遍历，可以使用 Python 内置的 range 函数：\na = ['Mary', 'had', 'a', 'little', 'lamb']\n\nfor i in range(len(a)):\n    print(i, a[i])\n基本数据类型\n可以使用内建函数进行强制类型转换（Casting）:\nint(str)\nfloat(str)\nstr(int)\nstr(float)\nNumber: 数值类型\nx = 3\nprint type(x) # Prints \"<type 'int'>\"\nprint x       # Prints \"3\"\nprint x + 1   # Addition; prints \"4\"\nprint x - 1   # Subtraction; prints \"2\"\nprint x * 2   # Multiplication; prints \"6\"\nprint x ** 2  # Exponentiation; prints \"9\"\nx += 1\nprint x  # Prints \"4\"\nx *= 2\nprint x  # Prints \"8\"\ny = 2.5\nprint type(y) # Prints \"<type 'float'>\"\nprint y, y + 1, y * 2, y ** 2 # Prints \"2.5 3.5 5.0 6.25\"\n布尔类型\nPython 提供了常见的逻辑操作符，不过需要注意的是 Python 中并没有使用 &&、|| 等，而是直接使用了英文单词。\nt = True\nf = False\nprint type(t) # Prints \"<type 'bool'>\"\nprint t and f # Logical AND; prints \"False\"\nprint t or f  # Logical OR; prints \"True\"\nprint not t   # Logical NOT; prints \"False\"\nprint t != f  # Logical XOR; prints \"True\" \nString: 字符串\nPython 2 中支持 Ascii 码的 str() 类型，独立的 unicode() 类型，没有 byte 类型；而 Python 3 中默认的字符串为 utf-8 类型，并且包含了 byte 与 bytearray 两个字节类型：\ntype(\"Guido\") # string type is str in python2\n# <type 'str'>\n\n# 使用 __future__ 中提供的模块来降级使用 Unicode\nfrom __future__ import unicode_literals\ntype(\"Guido\") # string type become unicode\n# <type 'unicode'>\nPython 字符串支持分片、模板字符串等常见操作:\nvar1 = 'Hello World!'\nvar2 = \"Python Programming\"\n\nprint \"var1[0]: \", var1[0]\nprint \"var2[1:5]: \", var2[1:5]\n# var1[0]:  H\n# var2[1:5]:  ytho\n\nprint \"My name is %s and weight is %d kg!\" % ('Zara', 21)\n# My name is Zara and weight is 21 kg!\nstr[0:4]\nlen(str)\n\nstring.replace(\"-\", \" \")\n\",\".join(list)\n\"hi {0}\".format('j')\nstr.find(\",\")\nstr.index(\",\")   # same, but raises IndexError\nstr.count(\",\")\nstr.split(\",\")\n\nstr.lower()\nstr.upper()\nstr.title()\n\nstr.lstrip()\nstr.rstrip()\nstr.strip()\n\nstr.islower()\n# 移除所有的特殊字符\nre.sub('[^A-Za-z0-9]+', '', mystring) \n如果需要判断是否包含某个子字符串，或者搜索某个字符串的下标:\n# in 操作符可以判断字符串\nif \"blah\" not in somestring: \n    continue\n\n# find 可以搜索下标\ns = \"This be a string\"\nif s.find(\"is\") == -1:\n    print \"No 'is' here!\"\nelse:\n    print \"Found 'is' in the string.\"\nRegex: 正则表达式\nimport re\n\n# 判断是否匹配\nre.match(r'^[aeiou]', str)\n\n# 以第二个参数指定的字符替换原字符串中内容\nre.sub(r'^[aeiou]', '?', str)\nre.sub(r'(xyz)', r'\\1', str)\n\n# 编译生成独立的正则表达式对象\nexpr = re.compile(r'^...$')\nexpr.match(...)\nexpr.sub(...)\n下面列举了常见的表达式使用场景:\n# 检测是否为 HTML 标签\nre.search('<[^/>][^>]*>', '<a href=\"#label\">')\n\n# 常见的用户名密码\nre.match('^[a-zA-Z0-9-_]{3,16}$', 'Foo') is not None\nre.match('^\\w|[-_]{3,16}$', 'Foo') is not None\n\n# Email\nre.match('^([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]{2,6})$', 'hello.world@example.com')\n\n# Url\nexp = re.compile(r'''^(https?:\\/\\/)? # match http or https\n                ([\\da-z\\.-]+)            # match domain\n                \\.([a-z\\.]{2,6})         # match domain\n                ([\\/\\w \\.-]*)\\/?$        # match api or file\n                ''', re.X)\nexp.match('www.google.com')\n\n# IP 地址\nexp = re.compile(r'''^(?:(?:25[0-5]\n                     |2[0-4][0-9]\n                     |[1]?[0-9][0-9]?)\\.){3}\n                     (?:25[0-5]\n                     |2[0-4][0-9]\n                     |[1]?[0-9][0-9]?)$''', re.X)\nexp.match('192.168.1.1')\n集合类型\nList: 列表\nOperation: 创建增删\nlist 是基础的序列类型：\nl = []\nl = list()\n\n# 使用字符串的 split 方法，可以将字符串转化为列表\nstr.split(\".\")\n\n# 如果需要将数组拼装为字符串，则可以使用 join \nlist1 = ['1', '2', '3']\nstr1 = ''.join(list1)\n\n# 如果是数值数组，则需要先进行转换\nlist1 = [1, 2, 3]\nstr1 = ''.join(str(e) for e in list1)\n可以使用 append 与 extend 向数组中插入元素或者进行数组连接\nx = [1, 2, 3]\n\nx.append([4, 5]) # [1, 2, 3, [4, 5]]\n\nx.extend([4, 5]) # [1, 2, 3, 4, 5]，注意 extend 返回值为 None\n可以使用 pop、slices、del、remove 等移除列表中元素：\nmyList = [10,20,30,40,50]\n\n# 弹出第二个元素\nmyList.pop(1) # 20\n# myList: myList.pop(1)\n\n# 如果不加任何参数，则默认弹出最后一个元素\nmyList.pop()\n\n# 使用 slices 来删除某个元素\na = [  1, 2, 3, 4, 5, 6 ]\nindex = 3 # Only Positive index\na = a[:index] + a[index+1 :]\n\n# 根据下标删除元素\nmyList = [10,20,30,40,50]\nrmovIndxNo = 3\ndel myList[rmovIndxNo] # myList: [10, 20, 30, 50]\n\n# 使用 remove 方法，直接根据元素删除\nletters = [\"a\", \"b\", \"c\", \"d\", \"e\"]\nnumbers.remove(numbers[1])\nprint(*letters) # used a * to make it unpack you don't have to\nIteration: 索引遍历\n你可以使用基本的 for 循环来遍历数组中的元素，就像下面介个样纸:\nanimals = ['cat', 'dog', 'monkey']\nfor animal in animals:\n    print animal\n# Prints \"cat\", \"dog\", \"monkey\", each on its own line.\n如果你在循环的同时也希望能够获取到当前元素下标，可以使用 enumerate 函数:\nanimals = ['cat', 'dog', 'monkey']\nfor idx, animal in enumerate(animals):\n    print '#%d: %s' % (idx + 1, animal)\n# Prints \"#1: cat\", \"#2: dog\", \"#3: monkey\", each on its own line\nPython 也支持切片（Slices）:\nnums = range(5)    # range is a built-in function that creates a list of integers\nprint nums         # Prints \"[0, 1, 2, 3, 4]\"\nprint nums[2:4]    # Get a slice from index 2 to 4 (exclusive); prints \"[2, 3]\"\nprint nums[2:]     # Get a slice from index 2 to the end; prints \"[2, 3, 4]\"\nprint nums[:2]     # Get a slice from the start to index 2 (exclusive); prints \"[0, 1]\"\nprint nums[:]      # Get a slice of the whole list; prints [\"0, 1, 2, 3, 4]\"\nprint nums[:-1]    # Slice indices can be negative; prints [\"0, 1, 2, 3]\"\nnums[2:4] = [8, 9] # Assign a new sublist to a slice\nprint nums         # Prints \"[0, 1, 8, 9, 4]\"\nComprehensions: 变换\nPython 中同样可以使用 map、reduce、filter，map 用于变换数组:\n# 使用 map 对数组中的每个元素计算平方\nitems = [1, 2, 3, 4, 5]\nsquared = list(map(lambda x: x**2, items))\n\n# map 支持函数以数组方式连接使用\ndef multiply(x):\n    return (x*x)\ndef add(x):\n    return (x+x)\n\nfuncs = [multiply, add]\nfor i in range(5):\n    value = list(map(lambda x: x(i), funcs))\n    print(value)\nreduce 用于进行归纳计算:\n# reduce 将数组中的值进行归纳\n\nfrom functools import reduce\nproduct = reduce((lambda x, y: x * y), [1, 2, 3, 4])\n\n# Output: 24\nfilter 则可以对数组进行过滤:\nnumber_list = range(-5, 5)\nless_than_zero = list(filter(lambda x: x < 0, number_list))\nprint(less_than_zero)\n\n# Output: [-5, -4, -3, -2, -1]\n字典类型\n创建增删\nd = {'cat': 'cute', 'dog': 'furry'}  # 创建新的字典\nprint d['cat']       # 字典不支持点（Dot）运算符取值\n如果需要合并两个或者多个字典类型：\n# python 3.5\nz = {**x, **y}\n\n# python 2.7\ndef merge_dicts(*dict_args):\n    \"\"\"\n    Given any number of dicts, shallow copy and merge into a new dict,\n    precedence goes to key value pairs in latter dicts.\n    \"\"\"\n    result = {}\n    for dictionary in dict_args:\n        result.update(dictionary)\n    return result\n索引遍历\n可以根据键来直接进行元素访问:\n# Python 中对于访问不存在的键会抛出 KeyError 异常，需要先行判断或者使用 get\nprint 'cat' in d     # Check if a dictionary has a given key; prints \"True\"\n\n# 如果直接使用 [] 来取值，需要先确定键的存在，否则会抛出异常\nprint d['monkey']  # KeyError: 'monkey' not a key of d\n\n# 使用 get 函数则可以设置默认值\nprint d.get('monkey', 'N/A')  # Get an element with a default; prints \"N/A\"\nprint d.get('fish', 'N/A')    # Get an element with a default; prints \"wet\"\n\n\nd.keys() # 使用 keys 方法可以获取所有的键\n可以使用 for-in 来遍历数组:\n# 遍历键\nfor key in d:\n\n# 比前一种方式慢\nfor k in dict.keys(): ...\n\n# 直接遍历值\nfor value in dict.itervalues(): ...\n\n# Python 2.x 中遍历键值\nfor key, value in d.iteritems():\n\n# Python 3.x 中遍历键值\nfor key, value in d.items():\n其他序列类型\n集合\n# Same as {\"a\", \"b\",\"c\"}\nnormal_set = set([\"a\", \"b\",\"c\"])\n \n# Adding an element to normal set is fine\nnormal_set.add(\"d\")\n \nprint(\"Normal Set\")\nprint(normal_set)\n \n# A frozen set\nfrozen_set = frozenset([\"e\", \"f\", \"g\"])\n \nprint(\"Frozen Set\")\nprint(frozen_set)\n \n# Uncommenting below line would cause error as\n# we are trying to add element to a frozen set\n# frozen_set.add(\"h\")\n函数\n函数定义\nPython 中的函数使用 def 关键字进行定义，譬如:\ndef sign(x):\n    if x > 0:\n        return 'positive'\n    elif x < 0:\n        return 'negative'\n    else:\n        return 'zero'\n\n\nfor x in [-1, 0, 1]:\n    print sign(x)\n# Prints \"negative\", \"zero\", \"positive\"\nPython 支持运行时创建动态函数，也即是所谓的 lambda 函数：\ndef f(x): return x**2\n\n# 等价于\ng = lambda x: x**2\n参数\nOption Arguments: 不定参数\ndef example(a, b=None, *args, **kwargs):\n  print a, b\n  print args\n  print kwargs\n\nexample(1, \"var\", 2, 3, word=\"hello\")\n# 1 var\n# (2, 3)\n# {'word': 'hello'}\n\na_tuple = (1, 2, 3, 4, 5)\na_dict = {\"1\":1, \"2\":2, \"3\":3}\nexample(1, \"var\", *a_tuple, **a_dict)\n# 1 var\n# (1, 2, 3, 4, 5)\n# {'1': 1, '2': 2, '3': 3}\n生成器\ndef simple_generator_function():\n    yield 1\n    yield 2\n    yield 3\n\nfor value in simple_generator_function():\n    print(value)\n\n# 输出结果\n# 1\n# 2\n# 3\nour_generator = simple_generator_function()\nnext(our_generator)\n# 1\nnext(our_generator)\n# 2\nnext(our_generator)\n#3\n\n# 生成器典型的使用场景譬如无限数组的迭代\ndef get_primes(number):\n    while True:\n        if is_prime(number):\n            yield number\n        number += 1\n装饰器\n装饰器是非常有用的设计模式:\n# 简单装饰器\n\nfrom functools import wraps\ndef decorator(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        print('wrap function')\n        return func(*args, **kwargs)\n    return wrapper\n\n@decorator\ndef example(*a, **kw):\n    pass\n\nexample.__name__  # attr of function preserve\n# 'example'\n# Decorator \n\n# 带输入值的装饰器\n\nfrom functools import wraps\ndef decorator_with_argument(val):\n  def decorator(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n      print \"Val is {0}\".format(val)\n      return func(*args, **kwargs)\n    return wrapper\n  return decorator\n\n@decorator_with_argument(10)\ndef example():\n  print \"This is example function.\"\n\nexample()\n# Val is 10\n# This is example function.\n\n# 等价于\n\ndef example():\n  print \"This is example function.\"\n\nexample = decorator_with_argument(10)(example)\nexample()\n# Val is 10\n# This is example function.\n类与对象\n类定义\nPython 中对于类的定义也很直接:\nclass Greeter(object):\n    \n    # Constructor\n    def __init__(self, name):\n        self.name = name  # Create an instance variable\n        \n    # Instance method\n    def greet(self, loud=False):\n        if loud:\n            print 'HELLO, %s!' % self.name.upper()\n        else:\n            print 'Hello, %s' % self.name\n        \ng = Greeter('Fred')  # Construct an instance of the Greeter class\ng.greet()            # Call an instance method; prints \"Hello, Fred\"\ng.greet(loud=True)   # Call an instance method; prints \"HELLO, FRED!\"\n# isinstance 方法用于判断某个对象是否源自某个类\nex = 10\nisinstance(ex,int)\nManaged Attributes: 受控属性\n# property、setter、deleter 可以用于复写点方法\n\nclass Example(object):\n    def __init__(self, value):\n       self._val = value\n    @property\n    def val(self):\n        return self._val\n    @val.setter\n    def val(self, value):\n        if not isintance(value, int):\n            raise TypeError(\"Expected int\")\n        self._val = value\n    @val.deleter\n    def val(self):\n        del self._val\n    @property\n    def square3(self):\n        return 2**3\n\nex = Example(123)\nex.val = \"str\"\n# Traceback (most recent call last):\n#   File \"\", line 1, in\n#   File \"test.py\", line 12, in val\n#     raise TypeError(\"Expected int\")\n# TypeError: Expected int\n类方法与静态方法\nclass example(object):\n  @classmethod\n  def clsmethod(cls):\n    print \"I am classmethod\"\n  @staticmethod\n  def stmethod():\n    print \"I am staticmethod\"\n  def instmethod(self):\n    print \"I am instancemethod\"\n\nex = example()\nex.clsmethod()\n# I am classmethod\nex.stmethod()\n# I am staticmethod\nex.instmethod()\n# I am instancemethod\nexample.clsmethod()\n# I am classmethod\nexample.stmethod()\n# I am staticmethod\nexample.instmethod()\n# Traceback (most recent call last):\n#   File \"\", line 1, in\n# TypeError: unbound method instmethod() ...\n对象\n实例化\n属性操作\nPython 中对象的属性不同于字典键，可以使用点运算符取值，直接使用 in 判断会存在问题:\nclass A(object):\n    @property\n    def prop(self):\n        return 3\n\na = A()\nprint \"'prop' in a.__dict__ =\", 'prop' in a.__dict__\nprint \"hasattr(a, 'prop') =\", hasattr(a, 'prop')\nprint \"a.prop =\", a.prop\n\n# 'prop' in a.__dict__ = False\n# hasattr(a, 'prop') = True\n# a.prop = 3\n建议使用 hasattr、getattr、setattr 这种方式对于对象属性进行操作:\nclass Example(object):\n  def __init__(self):\n    self.name = \"ex\"\n  def printex(self):\n    print \"This is an example\"\n\n\n# Check object has attributes\n# hasattr(obj, 'attr')\nex = Example()\nhasattr(ex,\"name\")\n# True\nhasattr(ex,\"printex\")\n# True\nhasattr(ex,\"print\")\n# False\n\n# Get object attribute\n# getattr(obj, 'attr')\ngetattr(ex,'name')\n# 'ex'\n\n# Set object attribute\n# setattr(obj, 'attr', value)\nsetattr(ex,'name','example')\nex.name\n# 'example'\n异常与测试\n异常处理\nContext Manager - with\nwith 常用于打开或者关闭某些资源:\nhost = 'localhost'\nport = 5566\nwith Socket(host, port) as s:\n    while True:\n        conn, addr = s.accept()\n        msg = conn.recv(1024)\n        print msg\n        conn.send(msg)\n        conn.close()\n单元测试\nfrom __future__ import print_function\n\nimport unittest\n\ndef fib(n):\n    return 1 if n<=2 else fib(n-1)+fib(n-2)\n\ndef setUpModule():\n        print(\"setup module\")\ndef tearDownModule():\n        print(\"teardown module\")\n\nclass TestFib(unittest.TestCase):\n\n    def setUp(self):\n        print(\"setUp\")\n        self.n = 10\n    def tearDown(self):\n        print(\"tearDown\")\n        del self.n\n    @classmethod\n    def setUpClass(cls):\n        print(\"setUpClass\")\n    @classmethod\n    def tearDownClass(cls):\n        print(\"tearDownClass\")\n    def test_fib_assert_equal(self):\n        self.assertEqual(fib(self.n), 55)\n    def test_fib_assert_true(self):\n        self.assertTrue(fib(self.n) == 55)\n\nif __name__ == \"__main__\":\n    unittest.main()\n存储\n文件读写\n路径处理\nPython 内置的 __file__ 关键字会指向当前文件的相对路径，可以根据它来构造绝对路径，或者索引其他文件:\n# 获取当前文件的相对目录\ndir = os.path.dirname(__file__) # src\\app\n\n## once you're at the directory level you want, with the desired directory as the final path node:\ndirname1 = os.path.basename(dir) \ndirname2 = os.path.split(dir)[1] ## if you look at the documentation, this is exactly what os.path.basename does.\n\n# 获取当前代码文件的绝对路径，abspath 会自动根据相对路径与当前工作空间进行路径补全\nos.path.abspath(os.path.dirname(__file__)) # D:\\WorkSpace\\OWS\\tool\\ui-tool-svn\\python\\src\\app\n\n# 获取当前文件的真实路径\nos.path.dirname(os.path.realpath(__file__)) # D:\\WorkSpace\\OWS\\tool\\ui-tool-svn\\python\\src\\app\n\n# 获取当前执行路径\nos.getcwd()\n可以使用 listdir、walk、glob 模块来进行文件枚举与检索：\n# 仅列举所有的文件\nfrom os import listdir\nfrom os.path import isfile, join\nonlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]\n\n# 使用 walk 递归搜索\nfrom os import walk\n\nf = []\nfor (dirpath, dirnames, filenames) in walk(mypath):\n    f.extend(filenames)\n    break\n\n# 使用 glob 进行复杂模式匹配\nimport glob\nprint(glob.glob(\"/home/adam/*.txt\"))\n# ['/home/adam/file1.txt', '/home/adam/file2.txt', .... ]\n简单文件读写\n# 可以根据文件是否存在选择写入模式\nmode = 'a' if os.path.exists(writepath) else 'w'\n\n# 使用 with 方法能够自动处理异常\nwith open(\"file.dat\",mode) as f:\n    f.write(...)\n    ...\n    # 操作完毕之后记得关闭文件\n    f.close()\n\n# 读取文件内容\nmessage = f.read()\n复杂格式文件\nJSON\nimport json\n\n# Writing JSON data\nwith open('data.json', 'w') as f:\n     json.dump(data, f)\n\n# Reading data back\nwith open('data.json', 'r') as f:\n     data = json.load(f)\nXML\n我们可以使用 lxml 来解析与处理 XML 文件，本部分即对其常用操作进行介绍。lxml 支持从字符串或者文件中创建 Element 对象：\nfrom lxml import etree\n\n# 可以从字符串开始构造\nxml = '<a xmlns=\"test\"><b xmlns=\"test\"/></a>'\nroot = etree.fromstring(xml)\netree.tostring(root)\n# b'<a xmlns=\"test\"><b xmlns=\"test\"/></a>'\n\n# 也可以从某个文件开始构造\ntree = etree.parse(\"doc/test.xml\")\n\n# 或者指定某个 baseURL\nroot = etree.fromstring(xml, base_url=\"http://where.it/is/from.xml\")\n其提供了迭代器以对所有元素进行遍历：\n# 遍历所有的节点\nfor tag in tree.iter():\n    if not len(tag):\n        print tag.keys() # 获取所有自定义属性\n        print (tag.tag, tag.text) # text 即文本子元素值\n\n# 获取 XPath\nfor e in root.iter():\n    print tree.getpath(e)\nlxml 支持以 XPath 查找元素，不过需要注意的是，XPath 查找的结果是数组，并且在包含命名空间的情况下，需要指定命名空间：\nroot.xpath('//page/text/text()',ns={prefix:url})\n\n# 可以使用 getparent 递归查找父元素\nel.getparent()\nlxml 提供了 insert、append 等方法进行元素操作：\n# append 方法默认追加到尾部\nst = etree.Element(\"state\", name=\"New Mexico\")\nco = etree.Element(\"county\", name=\"Socorro\")\nst.append(co)\n\n# insert 方法可以指定位置\nnode.insert(0, newKid)\nExcel\n可以使用 [xlrd]() 来读取 Excel 文件，使用 xlsxwriter 来写入与操作 Excel 文件。\n# 读取某个 Cell 的原始值\nsh.cell(rx, col).value\n# 创建新的文件\nworkbook = xlsxwriter.Workbook(outputFile)\nworksheet = workbook.add_worksheet()\n\n# 设置从第 0 行开始写入\nrow = 0\n\n# 遍历二维数组，并且将其写入到 Excel 中\nfor rowData in array:\n    for col, data in enumerate(rowData):\n        worksheet.write(row, col, data)\n    row = row + 1\n\nworkbook.close()\n文件系统\n对于高级的文件操作，我们可以使用 Python 内置的 shutil\n\n# 递归删除 appName 下面的所有的文件夹\nshutil.rmtree(appName)\n网络交互\nRequests\nRequests 是优雅而易用的 Python 网络请求库:\nimport requests\n\nr = requests.get('https://api.github.com/events')\nr = requests.get('https://api.github.com/user', auth=('user', 'pass'))\n\nr.status_code\n# 200\nr.headers['content-type']\n# 'application/json; charset=utf8'\nr.encoding\n# 'utf-8'\nr.text\n# u'{\"type\":\"User\"...'\nr.json()\n# {u'private_gists': 419, u'total_private_repos': 77, ...}\n\nr = requests.put('http://httpbin.org/put', data = {'key':'value'})\nr = requests.delete('http://httpbin.org/delete')\nr = requests.head('http://httpbin.org/get')\nr = requests.options('http://httpbin.org/get')\n数据存储\nMySQL\nimport pymysql.cursors\n\n# Connect to the database\nconnection = pymysql.connect(host='localhost',\n                             user='user',\n                             password='passwd',\n                             db='db',\n                             charset='utf8mb4',\n                             cursorclass=pymysql.cursors.DictCursor)\n\ntry:\n    with connection.cursor() as cursor:\n        # Create a new record\n        sql = \"INSERT INTO `users` (`email`, `password`) VALUES (%s, %s)\"\n        cursor.execute(sql, ('webmaster@python.org', 'very-secret'))\n\n    # connection is not autocommit by default. So you must commit to save\n    # your changes.\n    connection.commit()\n\n    with connection.cursor() as cursor:\n        # Read a single record\n        sql = \"SELECT `id`, `password` FROM `users` WHERE `email`=%s\"\n        cursor.execute(sql, ('webmaster@python.org',))\n        result = cursor.fetchone()\n        print(result)\nfinally:\n    connection.close()\n\n                ", "mainLikeNum": ["50 "], "mainBookmarkNum": "224"}