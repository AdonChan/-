{"title": "Python方法(二) - 类与继承 - 终南山下 ", "index": "python", "content": "类定义\n\n类对象：创建一个类之后，可以通过类名访问、改变其属性、方法\n实例对象：类实例化后，可以使用其属性，可以动态的为实例对象添加属性(类似javascript)而不影响类对象。\n\n\n类的属性\n\n\n访问\n\ngetattr(obj, name[, default]) : 访问对象的属性\nhasattr(obj,name) : 检查是否存在一个属性\nsetattr(obj,name,value) : 设置一个属性。如果属性不存在，会创建一个新属性\ndelattr(obj, name) : 删除属性\n\n\n\n内置类属性\n __dict__ : 类的属性（包含一个字典，由类的数据属性组成）\n __doc__ :类的文档字符串\n __name__: 类名\n __module__: 类定义所在的模块（类的全名是'__main__.className'，如果类位于一个导入模块mymod中，那么className.__module__ 等于 mymod）\n _bases__ : 类的所有父类构成元素（包含了一个由所有父类组成的元组）\n\n\n类的专有方法\n    在类地内部，使用def关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数self，且为第一个参数\n   __init__ 构造函数，在生成对象时调用\n   __del__ 析构函数，释放对象时使用\n   __repr__ 打印，转换\n   __setitem__按照索引赋值\n   __getitem__按照索引获取值\n   __len__获得长度\n   __cmp__比较运算\n   __call__函数调用\n   __add__加运算\n   __sub__减运算\n   __mul__乘运算\n   __div__除运算\n   __mod__求余运算\n   __pow__称方\n\n\n类的封装\n    python通过变量名命名来区分属性和方法的访问权限，默认权限相当于c++和java中的public\n   类的私有属性： __private_attrs：两个下划线开头，声明该属性为私有，不能在类地外部被使用或直接访问。在类内部的方法中使用时self.__private_attrs。\n    类的私有方法：__private_method：两个下划线开头，声明该方法为私有方法，不能在类地外部调用。在类的内部调用 self.__private_methods\n    虽然python不允许实例化的类访问私有数据，但可以使用 object._className__attrName 访问属性。\n    其实python内部私有化的实现只是将attrName属性变为了_className__attrName而已\n\n\n类的继承\n   面向对象的编程带来的主要好处之一是代码的重用，实现这种重用的方法之一是通过继承机制。继承完全可以理解成类之间的类型和子类型关系。\n\n   需要注意的地方：继承语法 class 派生类名（基类名）：//... 基类名写作括号里，基本类是在类定义的时候，在元组之中指明的。\n\n   在python中继承中的一些特点：\n\n   1：在继承中基类的构造（__init__()方法）不会被自动调用，它需要在其派生类的构造中亲自专门调用。使用super().__init__()或parentClassName.__init__()\n   2：在调用基类的方法时，需要加上基类的类名前缀，且需要带上self参数变量。区别于在类中调用普通函数时并不需要带上self参数\n   3：Python总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）。\n   如果在继承元组中列了一个以上的类，那么它就被称作\"多重继承\" 。\n\n多态\n\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "0"}