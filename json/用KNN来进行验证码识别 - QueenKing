{"title": "用KNN来进行验证码识别 - QueenKing ", "index": "python,knn,ocr,机器学习,matlab", "content": "前言\n之前做了一个校园交友的APP，其中一个逻辑是通过用户的教务系统来确认用户是一名在校大学生，基本的想法是通过用户的账号和密码，用爬虫的方法来确认信息，但是许多教务系统都有验证码，当时是通过本地服务器去下载验证码，然后分发给客户端，然后让用户自己填写验证码，与账号密码一并提交给服务器，然后服务器再去模拟登录教务系统以确认用户能否登录该教务系统。验证码无疑让我们想使得用户快速认证的想法破灭了，但是当时也没办法，最近看了一些机器学习的内容，觉得对于大多数学校的那些极简单的验证码应该是可以用KNN这种方法来破解的，于是整理了一下思绪，撸起袖子做起来！\n分析\n我们学校的验证码是这样的：，其实就是简单地把字符进行旋转然后加上一些微弱的噪点形成的。我们要识别，就得逆行之，具体思路就是，首先二值化去掉噪点，然后把单个字符分割出来，最后旋转至标准方向，然后从这些处理好的图片中选出模板，最后每次新来一张验证码就按相同方式处理，然后和这些模板进行比较，选择判别距离最近的一个模板作为其判断结果（亦即KNN的思想，本文取K=1）。接下来按步骤进行说明。\n获得验证码\n首先得有大量的验证码，我们通过爬虫来实现，代码如下\n#-*- coding:UTF-8 -*-\nimport urllib,urllib2,cookielib,string,Image\ndef getchk(number):\n    #创建cookie对象\n    cookie = cookielib.LWPCookieJar()\n    cookieSupport= urllib2.HTTPCookieProcessor(cookie)\n    opener = urllib2.build_opener(cookieSupport, urllib2.HTTPHandler)\n    urllib2.install_opener(opener) \n    #首次与教务系统链接获得cookie#\n    #伪装browser\n    headers = {\n        'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\n        'Accept-Encoding':'gzip,deflate',\n        'Accept-Language':'zh-CN,zh;q=0.8',\n        'User-Agent':'Mozilla/5.0 (Windows NT 6.2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.111 Safari/537.36'\n    }\n    req0 = urllib2.Request(\n            url ='http://mis.teach.ustc.edu.cn',\n            headers = headers               #请求头\n    )\n    # 捕捉http错误\n    try :\n        result0 = urllib2.urlopen(req0)\n    except urllib2.HTTPError,e:\n        print e.code\n    #提取cookie\n    getcookie = ['',]\n    for item in cookie:\n        getcookie.append(item.name)\n        getcookie.append(\"=\")\n        getcookie.append(item.value)\n        getcookie = \"\".join(getcookie)\n\n    #修改headers\n    headers[\"Origin\"] = \"http://mis.teach.ustc.edu.cn\"\n    headers[\"Referer\"] = \"http://mis.teach.ustc.edu.cn/userinit.do\"\n    headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\"\n    headers[\"Cookie\"] = getcookie\n    for i in range(number):\n        req = urllib2.Request(\n            url =\"http://mis.teach.ustc.edu.cn/randomImage.do?date='1469451446894'\",\n            headers = headers                 #请求头\n        )\n        response = urllib2.urlopen(req)\n        status = response.getcode()\n        picData = response.read()\n        if status == 200:\n            localPic = open(\"./source/\"+str(i)+\".jpg\", \"wb\")\n            localPic.write(picData)\n            localPic.close()\n        else:\n            print \"failed to get Check Code \"\nif __name__ == '__main__':\n    getchk(500)\n这里下载了500张验证码到source目录下面。如图：\n二值化\nmatlab丰富的图像处理函数能给我们省下很多时间，，我们遍历source文件夹，对每一张验证码图片进行二值化处理，把处理过的图片存入bw目录下。代码如下\nmydir='./source/';\nbw = './bw/';\nif mydir(end)~='\\'\n    mydir=[mydir,'\\'];\nend\nDIRS=dir([mydir,'*.jpg']);  %扩展名\nn=length(DIRS);\nfor i=1:n\n    if ~DIRS(i).isdir\n        img = imread(strcat(mydir,DIRS(i).name ));\n        img = rgb2gray(img);%灰度化\n        img = im2bw(img);%0-1二值化\n        name = strcat(bw,DIRS(i).name)\n        imwrite(img,name);\n    end\nend\n\n处理结果如图：\n分割\nmydir='./bw/';\nletter = './letter/';\nif mydir(end)~='\\'\n    mydir=[mydir,'\\'];\nend\nDIRS=dir([mydir,'*.jpg']);  %扩展名\nn=length(DIRS);\nfor i=1:n\n    if ~DIRS(i).isdir\n        img = imread(strcat(mydir,DIRS(i).name ));\n        img = im2bw(img);%二值化\n        img = 1-img;%颜色反转让字符成为联通域，方便去除噪点\n        for ii = 0:3\n            region = [ii*20+1,1,19,20];%把一张验证码分成四个20*20大小的字符图片\n            subimg = imcrop(img,region);\n            imlabel = bwlabel(subimg);\n%             imshow(imlabel);\n            if max(max(imlabel))>1 % 说明有噪点，要去除\n%                 max(max(imlabel))\n%                 imshow(subimg);\n                stats = regionprops(imlabel,'Area');\n                area = cat(1,stats.Area); \n                maxindex = find(area == max(area));\n                area(maxindex) = 0;          \n                secondindex = find(area == max(area));        \n                imindex = ismember(imlabel,secondindex);\n                subimg(imindex==1)=0;%去掉第二大连通域，噪点不可能比字符大，所以第二大的就是噪点\n            end\n            name = strcat(letter,DIRS(i).name(1:length(DIRS(i).name)-4),'_',num2str(ii),'.jpg')\n            imwrite(subimg,name);\n        end\n    end\nend\n处理结果如图：\n旋转\n接下来进行旋转，哪找一个什么标准呢？据观察，这些字符旋转不超过60度，那么在正负60度之间，统一旋转至字符宽度最小就行了。代码如下\nif mydir(end)~='\\'\n    mydir=[mydir,'\\'];\nend\nDIRS=dir([mydir,'*.jpg']);  %扩展名\nn=length(DIRS);\nfor i=1:n\n    if ~DIRS(i).isdir\n        img = imread(strcat(mydir,DIRS(i).name ));\n        img = im2bw(img);\n        minwidth = 20;\n        for angle = -60:60\n            imgr=imrotate(img,angle,'bilinear','crop');%crop 避免图像大小变化\n            imlabel = bwlabel(imgr);\n            stats = regionprops(imlabel,'Area');\n            area = cat(1,stats.Area);\n            maxindex = find(area == max(area));\n            imindex = ismember(imlabel,maxindex);%最大连通域为1\n            [y,x] = find(imindex==1);\n            width = max(x)-min(x)+1;\n            if width<minwidth\n                minwidth = width;\n                imgrr = imgr;\n            end\n        end\n        name = strcat(rotate,DIRS(i).name)\n        imwrite(imgrr,name);\n    end\nend\n处理结果如图，一共2000个字符的图片存在rotate文件夹中\n模板选取\n现在从rotate文件夹中选取一套模板，涵盖每一个字符，一个字符可以选取多个图片，因为即使有前面的诸多处理也不能保证一个字符的最终呈现形式只有一种，多选几个才能保证覆盖率。把选出来的模板图片存入samples文件夹下，这个过程很耗时耗力。可以找同学帮忙~，如图\n测试\n测试代码如下首先对测试验证码进行上述操作，然后和选出来的模板进行比较，采用差分值最小的模板作为测试样本的字符选择，代码如下\n% 具有差分最小值的图作为答案\nmydir='./test/';\nsamples = './samples/';\nif mydir(end)~='\\'\n    mydir=[mydir,'\\'];\nend\nif samples(end)~='\\'\n    samples=[samples,'\\'];\nend\nDIRS=dir([mydir,'*.jpg']);  %扩展?\nDIRS1=dir([samples,'*.jpg']);  %扩展名\nn=length(DIRS);%验证码总图数\nsingleerror = 0;%单个错误\nuniterror = 0;%一张验证码错误个数\nfor i=1:n\n    if ~DIRS(i).isdir\n        realcodes = DIRS(i).name(1:4);\n        fprintf('验证码实际字符:%s\\n',realcodes);\n        img = imread(strcat(mydir,DIRS(i).name ));\n        img = rgb2gray(img);\n        img = im2bw(img);\n        img = 1-img;%颜色反转让字符成为联通域\n        subimgs = [];\n        for ii = 0:3\n            region = [ii*20+1,1,19,20];%奇怪,为什么这样才能均分？\n            subimg = imcrop(img,region);\n            imlabel = bwlabel(subimg);\n            if max(max(imlabel))>1 % 说明有杂点\n                stats = regionprops(imlabel,'Area');\n                area = cat(1,stats.Area); \n                maxindex = find(area == max(area));\n                area(maxindex) = 0;          \n                secondindex = find(area == max(area));        \n                imindex = ismember(imlabel,secondindex);\n                subimg(imindex==1)=0;%去掉第二大连通域\n            end\n            subimgs = [subimgs;subimg];\n        end\n        codes = [];\n        for ii = 0:3\n            region = [ii*20+1,1,19,20];\n            subimg = imcrop(img,region);\n            minwidth = 20;\n            for angle = -60:60\n                imgr=imrotate(subimg,angle,'bilinear','crop');%crop 避免图像大小变化\n                imlabel = bwlabel(imgr);\n                stats = regionprops(imlabel,'Area');\n                area = cat(1,stats.Area);\n                maxindex = find(area == max(area));\n                imindex = ismember(imlabel,maxindex);%最大连通域为1\n                [y,x] = find(imindex==1);\n                width = max(x)-min(x)+1;\n                if width<minwidth\n                    minwidth = width;\n                    imgrr = imgr;\n                end\n            end\n            mindiffv = 1000000;\n            for jj = 1:length(DIRS1)\n                imgsample = imread(strcat(samples,DIRS1(jj).name ));\n                imgsample = im2bw(imgsample);\n                diffv = abs(imgsample-imgrr);\n                alldiffv = sum(sum(diffv));\n                if alldiffv<mindiffv\n                    mindiffv = alldiffv;\n                    code = DIRS1(jj).name;\n                    code = code(1);\n                end\n            end\n            codes = [codes,code];\n        end\n        fprintf('验证码测试字符:%s\\n',codes);\n        num = codes-realcodes;\n        num = length(find(num~=0));\n        singleerror = singleerror + num;\n        if num>0\n            uniterror = uniterror +1;\n        end\n        fprintf('错误个数:%d\\n',num);\n    end\nend\nfprintf('\\n-----结果统计如下-----\\n\\n');\nfprintf('测试验证码的字符数量:%d\\n',n*4);\nfprintf('测试验证码的字符错误数量:%d\\n',singleerror);\nfprintf('单个字符识别正确率:%.2f%%\\n',(1-singleerror/(n*4))*100);\nfprintf('测试验证码图的数量:%d\\n',n);\nfprintf('测试验证码图的错误数量:%d\\n',uniterror);\nfprintf('填对验证码的概率:%.2f%%\\n',(1-uniterror/n)*100);\n结果：\n验证码实际字符:2B4E\n验证码测试字符:2B4F\n错误个数:1\n验证码实际字符:4572\n验证码测试字符:4572\n错误个数:0\n验证码实际字符:52CY\n验证码测试字符:52LY\n错误个数:1\n验证码实际字符:83QG\n验证码测试字符:85QG\n错误个数:1\n验证码实际字符:9992\n验证码测试字符:9992\n错误个数:0\n验证码实际字符:A7Y7\n验证码测试字符:A7Y7\n错误个数:0\n验证码实际字符:D993\n验证码测试字符:D995\n错误个数:1\n验证码实际字符:F549\n验证码测试字符:F5A9\n错误个数:1\n验证码实际字符:FMC6\n验证码测试字符:FMLF\n错误个数:2\n验证码实际字符:R4N4\n验证码测试字符:R4N4\n错误个数:0\n\n-----结果统计如下-----\n\n测试验证码的字符数量:40\n测试验证码的字符错误数量:7\n单个字符识别正确率:82.50%\n测试验证码图的数量:10\n测试验证码图的错误数量:6\n填对验证码的概率:40.00%\n\n可见单个字符准确率是比较高的的了，但是综合准确率还是不行，观察结果至，错误的字符就是那些易混淆字符，比如E和F,C和L,5和3，4和A等，所以我们能做的事就是增加模板中的样本数量，以期尽量减少混淆。增加了几十个样本过后再次试验，结果：\n验证码实际字符:2B4E\n验证码测试字符:2B4F\n错误个数:1\n验证码实际字符:4572\n验证码测试字符:4572\n错误个数:0\n验证码实际字符:52CY\n验证码测试字符:52LY\n错误个数:1\n验证码实际字符:83QG\n验证码测试字符:83QG\n错误个数:0\n验证码实际字符:9992\n验证码测试字符:9992\n错误个数:0\n验证码实际字符:A7Y7\n验证码测试字符:A7Y7\n错误个数:0\n验证码实际字符:D993\n验证码测试字符:D993\n错误个数:0\n验证码实际字符:F549\n验证码测试字符:F5A9\n错误个数:1\n验证码实际字符:FMC6\n验证码测试字符:FMLF\n错误个数:2\n验证码实际字符:R4N4\n验证码测试字符:R4N4\n错误个数:0\n\n-----结果统计如下-----\n\n测试验证码的字符数量:40\n测试验证码的字符错误数量:5\n单个字符识别正确率:87.50%\n测试验证码图的数量:10\n测试验证码图的错误数量:4\n填对验证码的概率:60.00%\n可见无论是单个字符识别正确率还是整个验证码正确的概率都有了提升。能够预见：随着模板数量的增多，正确率会不断地提高。\n总结\n这种方法的可扩展性很弱，而且只适用于简单的验证码，12306那种根本就别提了。总之就是学习的道路还很长，我会慢慢的改善这种方法的。\n更新7.28\n再增加了几十个模板后结果如下：\n验证码实际字符:2B4E\n验证码测试字符:2B4E\n错误个数:0\n验证码实际字符:4572\n验证码测试字符:4572\n错误个数:0\n验证码实际字符:52CY\n验证码测试字符:52LY\n错误个数:1\n验证码实际字符:83QG\n验证码测试字符:83QG\n错误个数:0\n验证码实际字符:9992\n验证码测试字符:9992\n错误个数:0\n验证码实际字符:A7Y7\n验证码测试字符:A7Y7\n错误个数:0\n验证码实际字符:D993\n验证码测试字符:D993\n错误个数:0\n验证码实际字符:F549\n验证码测试字符:F549\n错误个数:0\n验证码实际字符:FMC6\n验证码测试字符:FMLF\n错误个数:2\n验证码实际字符:R4N4\n验证码测试字符:R4N4\n错误个数:0\n\n-----结果统计如下-----\n\n测试验证码的字符数量:40\n测试验证码的字符错误数量:3\n单个字符识别正确率:92.50%\n测试验证码图的数量:10\n测试验证码图的错误数量:2\n填对验证码的概率:80.00%\n增加测试集至20个，结果如下：\n验证码实际字符:2B4E\n验证码测试字符:2B4E\n错误个数:0\n验证码实际字符:4572\n验证码测试字符:4572\n错误个数:0\n验证码实际字符:4Q33\n验证码测试字符:4Q33\n错误个数:0\n验证码实际字符:52CY\n验证码测试字符:52LY\n错误个数:1\n验证码实际字符:6S3C\n验证码测试字符:6S3C\n错误个数:0\n验证码实际字符:7456\n验证码测试字符:74F5\n错误个数:2\n验证码实际字符:775D\n验证码测试字符:775D\n错误个数:0\n验证码实际字符:792Z\n验证码测试字符:7PZZ\n错误个数:2\n验证码实际字符:83QG\n验证码测试字符:83QG\n错误个数:0\n验证码实际字符:8JXB\n验证码测试字符:BJXB\n错误个数:1\n验证码实际字符:9992\n验证码测试字符:9992\n错误个数:0\n验证码实际字符:9LW7\n验证码测试字符:9LW7\n错误个数:0\n验证码实际字符:A7Y7\n验证码测试字符:A7Y7\n错误个数:0\n验证码实际字符:D993\n验证码测试字符:D993\n错误个数:0\n验证码实际字符:F549\n验证码测试字符:F549\n错误个数:0\n验证码实际字符:FMC6\n验证码测试字符:FMLF\n错误个数:2\n验证码实际字符:KXCV\n验证码测试字符:KXCV\n错误个数:0\n验证码实际字符:L9AC\n验证码测试字符:E9AC\n错误个数:1\n验证码实际字符:R4N4\n验证码测试字符:R4N4\n错误个数:0\n验证码实际字符:Z89V\n验证码测试字符:Z89V\n错误个数:0\n\n-----结果统计如下-----\n\n测试验证码的字符数量:80\n测试验证码的字符错误数量:9\n单个字符识别正确率:88.75%\n测试验证码图的数量:20\n测试验证码图的错误数量:6\n填对验证码的概率:70.00%\n结果还算是比较稳定的,再次增加模板数量：\n验证码实际字符:2B4E\n验证码测试字符:2B4E\n错误个数:0\n验证码实际字符:4572\n验证码测试字符:4572\n错误个数:0\n验证码实际字符:4Q33\n验证码测试字符:4Q33\n错误个数:0\n验证码实际字符:52CY\n验证码测试字符:52LY\n错误个数:1\n验证码实际字符:6S3C\n验证码测试字符:6S3C\n错误个数:0\n验证码实际字符:7456\n验证码测试字符:74F5\n错误个数:2\n验证码实际字符:775D\n验证码测试字符:775D\n错误个数:0\n验证码实际字符:792Z\n验证码测试字符:792Z\n错误个数:0\n验证码实际字符:83QG\n验证码测试字符:83QG\n错误个数:0\n验证码实际字符:8JXB\n验证码测试字符:8JXB\n错误个数:0\n验证码实际字符:9992\n验证码测试字符:9992\n错误个数:0\n验证码实际字符:9LW7\n验证码测试字符:9LW7\n错误个数:0\n验证码实际字符:A7Y7\n验证码测试字符:A7Y7\n错误个数:0\n验证码实际字符:D993\n验证码测试字符:D993\n错误个数:0\n验证码实际字符:F549\n验证码测试字符:F549\n错误个数:0\n验证码实际字符:FMC6\n验证码测试字符:FMLF\n错误个数:2\n验证码实际字符:KXCV\n验证码测试字符:KXCV\n错误个数:0\n验证码实际字符:L9AC\n验证码测试字符:E9AC\n错误个数:1\n验证码实际字符:R4N4\n验证码测试字符:R4N4\n错误个数:0\n验证码实际字符:Z89V\n验证码测试字符:Z89V\n错误个数:0\n\n-----结果统计如下-----\n\n测试验证码的字符数量:80\n测试验证码的字符错误数量:6\n单个字符识别正确率:92.50%\n测试验证码图的数量:20\n测试验证码图的错误数量:4\n填对验证码的概率:80.00%\n正确率有提升，但是也不是很明显。\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "28"}