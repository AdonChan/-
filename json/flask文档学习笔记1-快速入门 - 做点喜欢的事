{"title": "flask文档学习笔记1-快速入门 - 做点喜欢的事 ", "index": "flask,python", "content": "开始决定认真的在网上写一些东西，主要原因还是在于希望能提升学习效果。虽说python写了有几年，但是web后端框架的确没怎么接触过，买了本狗书寥寥草草的过了一遍，发现很多东西还是理解不深，真的是好记性不如烂笔头，知识也要从基础开始，退回来好好看看官方文档，再去看狗书吧。  网上有翻译好的官方文档，基本是基于0.10.1版本翻译的，和目前版本对比了一下，细节上还是有一些不同（狗书也存在这个问题），所以还是老老实实的看英文原版学习吧，目前的版本是0.12.2\n“微型”的含义\n众所周知，flask是一个使用Python开发的“微型”Web框架，文档中特意强调了，所谓“微型”并不意味着Web应用的开发只能写在一个Python文件里，也不意味着flask自身功能不够丰富。“微型”的目的在于，保持一个“简单”并且“可扩展”的框架核心，为开发者提供一个选择自由的Web框架。基于此，开发者可以自由的选择数据库或模板引擎，为自己的Web应用做合适的选择。\n最小应用\n通过flask实现一个Hello World只需要几行代码\nfrom flask import Flask\napp = Flask(__name__)\n\n@app.route('/')\ndef hello_world():\n    return 'Hello, World!'\n把一头大象放进冰箱只需三步：\n\n引用Flask类，并创建Flask类的实例。这个实例就是HelloWorld应用的WSGI接口。\n编写hello_world函数，返回'hello, World!'字符串消息。\n使用route装饰器，为hello_world创建路径为'/'的路由。\n\n这个示例代码与0.10版不同，在旧版文档中，通过在代码中添加app.run()方法来运行这个Web应用，而在0.12版文档中，应用的启动工作使用了命令行的方式来处理:\n$ export FLASK_APP=hello.py\n$ flask run\n * Running on http://127.0.0.1:5000/\n或者：\n$ export FLASK_APP=hello.py\n$ python -m flask run\n * Running on http://127.0.0.1:5000/\n通过给FLASK_APP环境变量赋值，告诉flask它的web应用是哪个。我尝试了在代码中使用app.run()方法启动，也一样可以执行。\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello_world():\n    return 'Hello World!'\n\nif __name__ == '__main__':\n    app.run('0.0.0.0')\nDebug模式\n开启debug模式可实现代码变更的热加载，即：代码修改后，不需要重启flask server，就可以自动触发变更代码的载入。另外，开启debug模式可以实现在页面查看运行中的错误信息，追踪错误发生原因，适合开发过程中的错误调试。开启Debug模式的方法包括：\n$ export FLASK_DEBUG=1\n$ flask run\n以及在代码中，为Flask类实例的run方法中，指明debug参数为True：\napp.run(debug=True)\n路由\n在Flask下，用户可以使用@app.route()装饰器为页面设计具有可读性的静态路由，也可以在路由部分中加入变量，以使路由动态可变。路由的形式类似于linux下的文件路径。示例如下：\n#静态路由\n@app.route('/hello')\ndef hello():\n    return 'Hello, World'\n#使用动态变量的路由（未指定变量类型）\n@app.route('/user/<username>')\ndef show_user_profile(username):\n    # show the user profile for that user\n    return 'User %s' % username\n\n#使用动态变量的路由（指定变量类型）\n@app.route('/post/<int:post_id>')\ndef show_post(post_id):\n    # show the post with the given id, the id is an integer\n    return 'Post %d' % post_id\n指定的路由变量，可以作为被装饰的函数参数传入进来。当路由尾部加入'/'时，无论在浏览器地址栏中输入的网址尾部是否加'/'，浏览器都会自动重定向到有/的路由上。\nurl_for()函数\nflask模块提供了url_for()函数用于获取函数的URL，因此在项目中所有引用到URL字符串的地方，都可以使用url_for(func, **kwargs)来获取函数的URL，这样做的好处在于，可以使项目更容易维护。当某函数URL发生变更时，只需修改一处地方即可，而无须修改每一处URL引用。个人认为，在开发过程的任何时候，使用硬编码都是极为不妥的。\nHTTP方法\nhttp作为客户端与服务端的交互协议，包含了不同类型的请求方法（method），Flask中，最长使用的是GET、PUT和POST方法，一条路由适用哪种方法，可以在route装饰器中定义。如不明确定义，route装饰器中默认定义为GET方法。官方例子：\nfrom flask import request\n\n@app.route('/login', methods=['GET', 'POST'])\ndef login():\n    if request.method == 'POST':\n        do_the_login()\n    else:\n        show_the_login_form()\nhttp还包括HEAD以及OPTIONS方法，在较新的Flask中，已经为用户内部实现，因此一般开发过程中无需在意。\n静态文件\nFlask的静态文件目录默认为项目目录内的static目录，一般所有静态文件都存放在这个目录内。\n模板渲染\nFlask内置了Jinja2作为模板引擎，并提供render_template方法用于模板渲染，使用起来很方便，只需在方法内指定需要渲染的html文件名称，并传入模板变量值即可实现模板渲染。官方示例：\nfrom flask import render_template\n\n@app.route('/hello/')\n@app.route('/hello/<name>')\ndef hello(name=None):\n    return render_template('hello.html', name=name)\n默认情况下，Flask会到当前项目目录下的templates目录内寻找模板文件。官方模板文件示例：\n<!doctype html>\n<title>Hello from Flask</title>\n{% if name %}\n  <h1>Hello {{ name }}!</h1>\n{% else %}\n  <h1>Hello, World!</h1>\n{% endif %}\n模板文件之间可实现继承，这一特性保证了不同页面内的重复页面元素（页头、页脚、导航栏）等，可通过模板继承的方式迅速实现。\n访问请求数据\n来自客户端的http请求，在server端以request对象存在。Flask为每一个request创建一个处理线程，并在线程内部创建上下文实现线程安全。因此开发者在开发过程中不需要为线程安全费太多心思。关于request对象，获取客户端传输来的数据方式非常简单，类似于字典的形式，只需要在request.method中指明key的值即可实现：\n#获取登录表单数据\n@app.route('/login', methods=['POST', 'GET'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if valid_login(request.form['username'],\n                       request.form['password']):\n            return log_the_user_in(request.form['username'])\n        else:\n            error = 'Invalid username/password'\n    # the code below is executed if the request method\n    # was GET or the credentials were invalid\n    return render_template('login.html', error=error)\n文档在此处还提及了文件上传场景以及cookie的简单用法，后续文档应当有更加详细的记录，在此不详述。\n错误与重定向\nFlask使用redirect()函数处理重定向逻辑。使用abort(error_code)处理错误返回。若希望对错误页面进行定制，可使用errorhandler(error_code)装饰器修饰对应的视图函数，定义本地错误页面。\n关于应答\nflask有自己的应答处理逻辑，可大致总结为：1.视图函数返回字符串时，flask会自动将返回字符串封装如标准response对象内2.用户也可以在视图函数内使用make_response()函数创建response对象并返回，这样做的意义是，在返回前用户可以对response对象的部分内容进行设置，例如cookie。3.如果返回对象是一个tuple，那么内容顺序格式应满足(response, status, headers)这样的格式\n会话session\nsession记录了客户端与server之间的一些信息，官方文档给出了用户登陆状态的例子。通过判断session中是否存在username键值来判断用户是否已登录，以此为依据返回不同的展示内容。示例如下：\nfrom flask import Flask, session, redirect, url_for, escape, request\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    if 'username' in session:\n        return 'Logged in as %s' % escape(session['username'])\n    return 'You are not logged in'\n\n@app.route('/login', methods=['GET', 'POST'])\ndef login():\n    if request.method == 'POST':\n        session['username'] = request.form['username']\n        return redirect(url_for('index'))\n    return '''\n        <form method=\"post\">\n            <p><input type=text name=username>\n            <p><input type=submit value=Login>\n        </form>\n    '''\n\n@app.route('/logout')\ndef logout():\n    # remove the username from the session if it's there\n    session.pop('username', None)\n    return redirect(url_for('index'))\n\n# set the secret key.  keep this really secret:\napp.secret_key = 'A0Zr98j/3yX R~XHH!jmN]LWX/,?RT'\n使用session的前提是必须设置密钥，密钥的获取可以使用python提供的随机函数生成。\n>>> import os\n>>> os.urandom(24)\n日志模块\nflask的日志模块与python的logging模块使用方式类似，应该是做了内部集成，代码形式略微不同，在此做记录：\napp.logger.debug('A value for debugging')\napp.logger.warning('A warning occurred (%d apples)', 42)\napp.logger.error('An error occurred')\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "2"}