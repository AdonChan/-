{"title": "[Learning Python] Chapter 5 Numeric Types - 潜入深蓝 ", "index": "python", "content": "1, 在Python 2.x 中。Python的integer，有两种类型，normal和long。Normal通常是32位的。Long表示无限精度，由计算机决定。如果数字后面有l或者L，这会强制将该数字转换为long类型。但其实，用户不必这样做，因为Python会在数值溢出的情况下自动将normal的类型转换为long类型。然而，在Python 3.x中，normal和long合并了，没有区别了。此时不可再在数字尾部加入l或者L了。\n2，integer可以用十进制（decimal）、十六进制（hexadecimal）、八进制（octal）、二进制（binary）来表示。后面三种在编程领域很常见。十六进制（hexadecimal）：以0x或者0X开头，接0~9或者A~F，大小写没有关系；八进制（octal）：以0o或者0O开头，接0~7；二进制（binary）：以0b或者0B开头，接0~1.想要将数字转换为十进制的，可以用int（数值）方法：如int（0o100）=64；想要将数字转换为八进制的，可以用oct（数值）方法，如oct（0x40）= 0o100；想要将数字转换为十六进制的，可以用hex（数值）方法，如hex（64）= 0x40；想要将数字转换为二进制的，可以用bin（数值）方法，如bin（64）= 0b1000000；\n3，使用如下的方法可以将integer I 转换为十六进制数、八进制数、二进制数：hex（I）、oct（I）、bin（I）。\n4，复数 complex numbers。由实数+虚数组成。其中，虚数要以j或者J结尾。复数可以没有实数部分。\n5, str()和repr()这两个方法都是可以将数值转换为字符串，不同的是，str（）对用户比较友好，repr()对Python比较友好。但通常情况下，它们都是相同的。\n6，在Python中，除法分为三种：6.1，true：表示真正的除法，返回值包含小数部分，属于float型，而不管除数和被除数是什么类型的数据。跟数学里面的除法概念吻合;6.2，classic：如果除数或被除数之一是float类型的数据，classic除法的商保留小数部分，为float型数据。而如果除数和被除数皆为integer，则商会去掉小数部分，往下取整（比如，本来是2.6，取整后为2。而本来是-2.7，取整后为-3）。6.3，floor：这种除法的商会去掉小数部分，向小的方向靠拢。如果除数和被除数皆为integer 类型，这商也是integer。而如果除数和被除数之一是float型，则商也是float型。\n7， 在Python 2.X中，/表示classic型除法，//表示floor型除法。在Python 3.x中，/表示true型除法，//表示floor型除法。Python 3.x已经没有classic型除法了。ps: 如果在Python2.x中想要用到3.x的除法，可以在开头加入这样的statement：\nfrom __future__ import division\n\n8，为了让代码在Python2.x和3.x中都兼容，如果需要取整的操作，总是用//比较好。\n9，在math模块中，提供了floor和trunc的方法。非常有用：\n>>>import math\n>>>math.floor(2.5)   # closest number below value\n2\n>>>math.floor(-2.5)\n-3\n>>>math.trunc(2.5)  # truncate fractional part\n2\n>>>math.trunc(-2.5)\n-2\n注意：int（I）也有truncate的功能。\n10, 在Python中，实部和虚部都是float型的，虚部以j或者J结尾。\n11，在Python 2.x中，八进制可以以0开头，但是在Python 3.x中，不能以0开头，一定要以0o或者0O开头！\n12，位的运算bitwise operations\n<<表示位向左移动\n>>表示位向右移动\n| 表示或运算\n& 表示AND运算\n^ 表示异或运算（两者不同为1，相同为0）\n\n可以用bit_lenth()方法计算二进制数有多少位。或者len（bin（））-2。因为len（）会包含开头的0b这两位。\n13，位的运算对Python这种高级语言不重要，如果需要做很多位运算，应该考虑低级语言如C语言。\n14，round（）方法可以做小数的四舍五入。如round（3.78）= 4.0, round(3,789, 2) = 3.79, round()里面的第二个参数表示的是保留多少位小数。\n15，Python中的pow（）函数用来计算指数。比如pow（2,4）=16， 和 2 ** 4一样的结果。\n16，Python中，有自带的min和max（）方法。min和max方法接受任意个单独的参数。如min（3， 1， 2， 4）= 1.\n17，Python中有sum方法，可以将一列数相加起来，但是这列数应该写在括号内作为一个sequence，比如sum（（1,2,3,4）） = 10，也可以是这样的sum（[1, 2, 3, 4]）。\n18，abs函数可以取绝对值。\n19，在Python中，有三种方法可以计算平方根：\nA, math.sqrt(144)   #Module\nB, 144 ** .5        #Expression\nC, pow(144, .5)    #Built-in\n\n20, 在Python中，计算0.1 + 0.1 + 0.1 – 0.3 并不会得到0这个准确的值。这是由于计算机由于缺少精确度而无法精确地保存数据引起的。这个时候，decimal模块很好的解决了这个问题，通过调用decimal模块的Decimal构造函数，把数据转换为str型传入，再进行运算，结果就会返回精确的0，如下：\nfrom decimal import Decimal\nprint Decimal('0.1') + Decimal('0.1') + Decimal('0.1') - Decimal('0.3')\n\n结果：0.0如果传入的参数仍然是float型，将无法获得这个结果。\n21，使用Decimal（）函数的时候。也可以设定全局精确度：\ndecimal.getcontext().prec = 4  #设定全局精确度为4位小数。\n\n22，使用Fraction()函数，也可以获得和Decimal（）一样的精确效果。Fraction（）函数位于fractions 模块中，需要先import才可以使用。Fraction（numerator, denominator），会自动的简化分数。Fraction()还可以将str参数转换为分数，比如Fraction(‘.25’)=Fraction(1, 4)\n23, 初始化一个空的set，使用S = set()。创建一个新的set并且赋值，使用 S = {1， 2， 3， 4}。后续若需再想set里面增加item，可以用S.add(‘…’)\n24, set的运算，&表示交集，| 表示并集，- 表示差别，> 表示super set，返回布尔值。这些运算必须都是set类型。\n25，union也可以用来创造出并集运算。Union里的参数可以是list，可以是set，还可以是tuple。{1，2, 3}.union([3, 4]){1，2, 3}.union({3, 4})\n26，intersection也可以用来计算交集，参数可以是list，可以是set，还可以是tuple。\n27，issubset()函数可以判断某set是否是令一个set的子集\n28，set和tuple的区别：\nSet在后续可以增加值，减少值，但tuple不能\nSet里面的值必须是互不相同的，但tuple可以接受相同的值。\nSet可以内嵌tuple，不能内嵌list，dictionary。\nhttp://blog.csdn.net/u0103675...\n29，set comprehensions\n{x ** 2 for x in [1, 2, 3, 4]}\n{16, 1, 4, 9}\n\n30, set可以用来过滤掉重复的item：\n>>> L = [1, 2, 1, 3, 2, 4, 5]\n>>> set(L)\n{1, 2, 3, 4, 5}\n\n31，set的运算：\n>>> engineers = {'bob', 'sue', 'ann', 'vic'}\n>>> managers = {'tom', 'sue'}\n>>> 'bob' in engineers # Is bob an engineer?\nTrue\n>>> engineers & managers # Who is both engineer and manager?\n{'sue'}\n>>> engineers | managers # All people in either category\n{'bob', 'tom', 'sue', 'vic', 'ann'}\n>>> engineers - managers # Engineers who are not managers\n{'vic', 'ann', 'bob'}\n>>> managers - engineers # Managers who are not engineers\n{'tom'}\n>>> engineers > managers # Are all managers engineers? (superset)\nFalse\n>>> {'bob', 'sue'} < engineers # Are both engineers? (subset)\nTrue\n>>> (managers | engineers) > managers # All people is a superset of managers\nTrue\n>>> managers ^ engineers # Who is in one but not both?\n{'tom', 'vic', 'ann', 'bob'}\n>>> (managers | engineers) - (managers ^ engineers) # Intersection!\n{'sue'}\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}