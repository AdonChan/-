{"title": "PyTips 0x01 - 迭代器与生成器 - PyTips ", "index": "python3.5,pytips,python", "content": "项目地址：https://git.io/pytips\n迭代器与生成器\n迭代器（iterator）与生成器（generator）是 Python 中比较常用又很容易混淆的两个概念，今天就把它们梳理一遍，并举一些常用的例子。\nfor 语句与可迭代对象（iterable object）：\nfor i in [1, 2, 3]:\n    print(i)\n1\n2\n3\n\nobj = {\"a\": 123, \"b\": 456}\nfor k in obj:\n    print(k)\nb\na\n\n这些可以用在 for 语句进行循环的对象就是可迭代对象。除了内置的数据类型（列表、元组、字符串、字典等）可以通过 for 语句进行迭代，我们也可以自己创建一个容器，包含一系列元素，可以通过 for 语句依次循环取出每一个元素，这种容器就是迭代器（iterator）。除了用 for 遍历，迭代器还可以通过 next() 方法逐一读取下一个元素。要创建一个迭代器有3种方法，其中前两种分别是：\n\n为容器对象添加 __iter__() 和 __next__() 方法（Python 2.7 中是 next()）；__iter__() 返回迭代器对象本身 self，__next__() 则返回每次调用 next() 或迭代时的元素；\n内置函数 iter() 将可迭代对象转化为迭代器\n\n# iter(IterableObject)\nita = iter([1, 2, 3])\nprint(type(ita))\n\nprint(next(ita))\nprint(next(ita))\nprint(next(ita))\n\n# Create iterator Object\nclass Container:\n    def __init__(self, start = 0, end = 0):\n        self.start = start\n        self.end = end\n    def __iter__(self):\n        print(\"[LOG] I made this iterator!\")\n        return self\n    def __next__(self):\n        print(\"[LOG] Calling __next__ method!\")\n        if self.start < self.end:\n            i = self.start\n            self.start += 1\n            return i\n        else:\n            raise StopIteration()\nc = Container(0, 5)\nfor i in c:\n    print(i)\n        \n<class 'list_iterator'>\n1\n2\n3\n[LOG] I made this iterator!\n[LOG] Calling __next__ method!\n0\n[LOG] Calling __next__ method!\n1\n[LOG] Calling __next__ method!\n2\n[LOG] Calling __next__ method!\n3\n[LOG] Calling __next__ method!\n4\n[LOG] Calling __next__ method!\n\n创建迭代器对象的好处是当序列长度很大时，可以减少内存消耗，因为每次只需要记录一个值即刻（经常看到人们介绍 Python 2.7 的 range 函数时，建议当长度太大时用 xrange 更快，在 Python 3.5 中已经去除了 xrange 只有一个类似迭代器一样的 range）。\n生成器\n前面说到创建迭代器有3种方法，其中第三种就是生成器（generator）。生成器通过 yield 语句快速生成迭代器，省略了复杂的 __iter__() & __next__() 方式：\ndef container(start, end):\n    while start < end:\n        yield start\n        start += 1\nc = container(0, 5)\nprint(type(c))\nprint(next(c))\nnext(c)\nfor i in c:\n    print(i)\n<class 'generator'>\n0\n2\n3\n4\n\n简单来说，yield 语句可以让普通函数变成一个生成器，并且相应的 __next__() 方法返回的是 yield 后面的值。一种更直观的解释是：程序执行到 yield 会返回值并暂停，再次调用 next() 时会从上次暂停的地方继续开始执行：\ndef gen():\n    yield 5\n    yield \"Hello\"\n    yield \"World\"\n    yield 4\nfor i in gen():\n    print(i)\n5\nHello\nWorld\n4\n\nPython 3.5 （准确地说应该是 3.3 以后）中为生成器添加了更多特性，包括 yield from 以及在暂停的地方传值回生成器的 send()等，为了保持简洁这里就不深入介绍了，有兴趣可以阅读官方文档说明以及参考链接2。\n参考\n\nIterators & Generators\nHow the heck does async/await work in Python 3.5?\nPython's yield from\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "8"}