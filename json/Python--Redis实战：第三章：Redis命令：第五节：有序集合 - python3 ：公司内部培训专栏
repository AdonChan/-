{"title": "Python--Redis实战：第三章：Redis命令：第五节：有序集合 - python3 ：公司内部培训专栏 ", "index": "redis,python", "content": "上一篇文章：Python--Redis实战：第三章：Redis命令：第四节：散列下一篇文章：Python--Redis实战：第三章：Redis命令：第六节：发布与订阅\n\n和散列存储着键与值之间的映射类似，有序集合也存储着成员与分值之间的映射，并且提供了分值处理命令，已经根据分值大小有序的获取（fetch）和扫描（scan）成员和分值的命令。本书曾在第一章使用有序集合实现过基于发布时间排序的文章列表和基于投票数量排序的文章列表，还在第二章使用有序集合存储过cookie的过期时间。\n这些分值在Redis中以IEEE754双精度点数的格式存储。\n本节将对操作有序集合的命令进行介绍，其中包括向有序集合添加新元素的命令、更细已有元素的命令、以及对有序集合进行交集运算和并集运算的命令。\n下表展示了一部分常用的有序集合命令：\n\n\n命令\n用例\n用例描述\n\n\n\nzadd\nzadd key-name score memeber [score member ...]\n将带有给定分值的成员添加到有序集合里面\n\n\nzrem\nzrem key-name member [member ...]\n从有序集合里面移除给定的成员，并返回被移除成员的数量\n\n\nzcard\nzcard key-name\n返回有序集合包含的成员数量\n\n\nzincrby\nzincrby key-name increment member\n将merber成员的分值加上increment\n\n\nzcount\nzcount key-name min max\n返回分值介于min和max之间的成员数量\n\n\nzrank\nzrank key-name member\n返回成员member有序集合中的排名。\n\n\nzscore\nzsore key-name member\n返回成员member的分值\n\n\nzrange\nzrange key-name start stop [WITHSCORES]\n返回有序集合中排名介于start和stop之间的成员，如果给定了可选的WITHSCORES选项，那么命令会将成员的分值也一并返回。\n\n\n\n实例：\nimport redis # 导入redis包包\n\n\n# 与本地redis进行链接，地址为：localhost，端口号为6379\nr = redis.StrictRedis(host='localhost', port=6379)\n\nr.delete('zset-key')\n\nprint(r.zadd('zset-key',3,'a',2,'b',1,'c'))\n\nprint(r.zcard('zset-key'))\n\nprint(r.zincrby('zset-key','c',3))\n\nprint(r.zscore('zset-key','b'))\n\nprint(r.zrank('zset-key','c'))\n\n#返回介于0-3之间的成员数量\nprint(r.zcount('zset-key',0,3))\n\nprint(r.zrem('zset-key','b'))\n\nprint(r.zrange('zset-key',0,-1,withscores=True))\n结果：\n3\n3\n4.0\n2.0\n2\n2\n1\n[(b'a', 3.0), (b'c', 4.0)]\n因为zadd、zrem、zincrby、zscore和zrange都已经在第一章和第二章介绍过了，所以读者应该不会对它们感到陌生。zcount命令和其他命令不太相同，它主要拥挤计算分值在给定范围内的成员数量。\n下表展示了另外一些非常有用的有序集合命令：\n有序集合的范围型数据获取命令和范围型数据删除命令，以及并集命令和交集命令：\n\n\n命令\n用例\n用例描述\n\n\n\nzrevrank\nzrevrank key-name merber\n返回有序集合里面成员member的排名，成员按照分值从大到小排列\n\n\nzrevrange\nzrevrange key-name start stop [WITHSCORES]\n返回有序集合给定排名范围内的成员，成员按照分值从大到小排列\n\n\nzrangebysocre\nzrangebyscore by min max [WITHSCORES] [LIMIT offset count]\n返回有序集合中，分值介于min和max之间的所有成员。\n\n\nzrevrangebyscore\nzrevrangebyscore key max min [WITHSCORES] [LIMIT offset count]\n获取有序集合中分值介于min和max之间的所有成员，并按照分值从大到小的顺序来返回它们。\n\n\nzremrangebyrank\nzremrangebyrank key-name start stop\n移除有序集合中排名介于start和stop之间的所有成员。\n\n\nzremrangebyscore\nzremrangebyscore key-name min max\n移除有序集合中分值介于min和max之间的所有成员。\n\n\nzinterstore\nzinterstore dest-key key-count key [key ...]\n对给定的有序集合执行类似于集合的交集运算。\n\n\nzunionstore\nzunionstore dest-key key-count key [key ...] [weights weight [weight ...]][aggregate summinmax]\n对给定的有序集合执行类似于集合的并集运算。\n\n\n\n上表展示的命令里面，有几个是之前没介绍过的新命令。除了使用逆序来处理有序集合之外，zrev*命令的工作方式和相对应的非逆序命令的工作方式完全一样（逆序就是指元素按照从大到小地排列）。\n实例：\nimport redis # 导入redis包包\n\n\n# 与本地redis进行链接，地址为：localhost，端口号为6379\nr = redis.StrictRedis(host='localhost', port=6379)\n\nr.delete('zset-key1')\nr.delete('zset-key2')\nr.delete('zset-key-i')\nr.delete('zset-key-u')\nr.delete('zset-key-u2')\nr.delete('set-1')\n\n#首先创建两个有序集合\n#a b c d\n#1 2 3\n# 4 1 0\nprint(r.zadd('zset-key1',1,'a',2,'b',3,'c'))\nprint(r.zadd('zset-key2',4,'b',1,'c',0,'d'))\n\n\n#zinterstore和zunionstore默认使用的聚合函数为sum，这个函数会把各个有序集合的成员的分值都加起来\nprint(r.zinterstore('zset-key-i',['zset-key1','zset-key2']))\n\nprint(r.zrange('zset-key-i',0,-1,withscores=True))\n\n#用户可以在执行并集运算和交集运算的时候传入不同的聚合函数，共有sum、min、max三个聚合函数可选。\nprint(r.zunionstore('zset-key-u',['zset-key1','zset-key2'],aggregate='min'))\n\nprint(r.zrange('zset-key-u',0,-1,withscores=True))\n\nprint(r.sadd('set-1','a','d'))\n\n#用户可以把集合作为输入传给zinterstore和zunionstore，命令会将集合看作是成员分值全为1的有序集合来处理。\nprint(r.zunionstore('zset-key-u2',['zset-key1','zset-key2','set-1']))\n\nprint(r.zrange('zset-key-u2',0,-1,withscores=True))\n结果：\n3\n3\n2\n[(b'c', 4.0), (b'b', 6.0)]\n4\n[(b'd', 0.0), (b'a', 1.0), (b'c', 1.0), (b'b', 2.0)]\n2\n4\n[(b'd', 1.0), (b'a', 2.0), (b'c', 4.0), (b'b', 6.0)]\n有序集合的并集运算和交集运算在刚开始接触时可能会比较难懂，我们将以表格来展示交集运算和并集运算的执行过程。\n对两个输入有序集合执行【交集】运算并得到输出有序集合\n这次交集运算使用的是默认的聚合函数sum，所有输出有序集合成员的分值都是通过加法计算得到的。\nzset-key1：\n\n\na\nb\nc\nd\n\n\n1\n2\n3\n \n\n\nzset-key2\n\n\na\nb\nc\nd\n\n\n \n4\n1\n0\n\n\nzset-key-i\n\n\na\nb\nc\nd\n\n\n \n6\n4\n \n\n\n执行r.zinterstore('zset-key-i',['zset-key1','zset-key2'])，将使得同时存在于zset-key1和zset-key2里面的元素被添加到z-set-key-i中。\n对两个输入有序集合执行【并集】运算并得到输出有序集合\n并集运算和交集运算不同，只要某个成员存在于至少一个输入有序集合里面，那么这个成员就会被包含在输出有序集合里面。下表展示了使用聚合函数min执行并集运算的过程，min函数在多个输入有序集合都包含同一个成员的情况下，会将最小的那个分值设置Wie这个成员的输出有序集合的分值。\nzset-key1\n\n\na\nb\nc\nd\n\n\n1\n2\n3\n \n\n\nzset-key2\n\n\na\nb\nc\nd\n\n\n \n4\n1\n0\n\n\nzset-key-u\n\n\na\nb\nc\nd\n\n\n1\n2(取小的那个)\n1（取小的那个）\n0\n\n\n执行r.zunionstore('zset-key-u',['zset-key1','zset-key2'],aggregate='min')，会将存在于zset-key1或者zset-key2里面的元素通过min函数组合到zset-key-u里面。\n使用zunionstore命令来将两个有序集合和一个集合组合成一个有序集合\nzset-key1\n\n\na\nb\nc\nd\n\n\n1\n2\n3\n \n\n\nzset-key2\n\n\na\nb\nc\nd\n\n\n \n4\n1\n0\n\n\nset-1\n\na\n \n \nd\n\nzset-key-u2\n\n\na\nb\nc\nd\n\n\n2\n6\n4\n1\n\n\n执行r.zunionstore('zset-key-u2',['zset-key1','zset-key2','set-1'])，将使得所有存在于zset-key1、zset-key2或者set-1里面的元素都被添加到zset-key-u2里面\n后面讲使用zinterstore和zunionstore来构建几个不同类型的搜索系统，并说明如果通过可选的weights参数来以几种不同的防暑组合有序集合的分值，从而使得集合和有序集合可以用于解决更多问题。\n读者在开发应用的过程中，也许曾经听说过发布与订阅（publish、subscribe）模式，又称pub/sub模式，Redis也实现了这种模式，接下来的一节将对其进行介绍。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}