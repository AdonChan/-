{"title": "Django基础之七（数据库操作） - 个人文章 ", "index": "mysql,django,python", "content": "Django数据库操作\n创建对象\nDjango 使用一种直观的方式把数据库表中的数据表示成Python 对象：\n\n一个模型类代表数据库中的一个表，一个模型类的实例代表这个数据库表中的一条特定的记录。\n使用关键字参数实例化模型实例来创建一个对象，然后调用save() 把它保存到数据库中。\n也可以使用一条语句创建并保存一个对象，使用create()方法\n\n准备models模型\n#dashboard/model.py\nfrom django.db import models\n# Create your models here.\nclass User(models.Model):\n    id = models.AutoField(max_length=11,primary_key=True)\n    username = models.CharField(max_length=32,null=False)\n    class Meta:\n        managed = False\n        db_table = \"user\"\n        ordering = [\"username\"]\n        verbose_name = \"\"\n\nclass Idc(models.Model):\n    name = models.CharField(\"IDC名称\",max_length=128,blank=False,null=False)\n    address = models.CharField(\"IDC地址\",max_length=200,default=\"\")\n    phone = models.CharField(\"IDC联系电话\",max_length=15,null=True)\n    #user = models.CharField(\"IDC联系人\",max_length=32,null=True)\n同步数据\npython manage.py makemigrations dashboard\npython manage.py migrate dashboard\n进入shell：\n(venv3) [vagrant@localhost devops]$ python manage.py shell\nIn [1]: from dashboard.models import Idc                                                \nIn [2]: idc = Idc()                                                                     \nIn [3]: idc.name = \"北京机房\"                                                           \nIn [4]: idc.address = \"北京\"                                                            \nIn [5]: idc.phone = \"1234553\"                                                           \nIn [6]: idc.save()                                                                      \nIn [7]: data = {}                                                                       \nIn [8]: data[\"name\"] = \"上海机房\"                                                       \nIn [9]: data[\"address\"] = \"上海\"                                                        \nIn [10]: data[\"phone\"] = \"123445566\"                                                    \nIn [11]: Idc.objects.create(**data)   \n查询对象\n通过模型中的管理器构造一个查询集，来从你的数据库中获取对象。查询集(queryset)表示从数据库中取出来的对象的集合。它可以含有零个、一个或者多个过滤器。过滤器基于所给的参数限制查询的结果。 从SQL 的角度，查询集和SELECT 语句等价，过滤器是像WHERE 和LIMIT 一样的限制子句。你可以从模型的管理器那里取得查询集,每个模型都至少有一个管理器,它默认命名为objects。通过模型类来直接访问它管理器只可以通过模型的类访问，而不可以通过模型的实例访问，目的是为了强制区分“表级别”的操作和“记录级别”的操作。对于一个模型来说，管理器是查询集的主要来源。例如，User.objects.all() 返回包含数据库中所有User 对象的一个查询集。\n获取一个表中所有对象的最简单的方式是全部获取。可以使用管理器的all() 方法：all()方法返回包含数据库中所有对象的一个查询集all_users = User.objects.all()\n(venv3) [vagrant@localhost devops]$ python manage.py shell\nIn [1]: from django.contrib.auth.models import User                                                                                                                                                                                              \nIn [2]: user = User.objects.all()                                                                                                                                                                                                                \nIn [3]: print(user.query)                                                                                                                                                                                                                        \nSELECT `auth_user`.`id`, `auth_user`.`password`, `auth_user`.`last_login`, `auth_user`.`is_superuser`, `auth_user`.`username`, `auth_user`.`first_name`, `auth_user`.`last_name`, `auth_user`.`email`, `auth_user`.`is_staff`, `auth_user`.`is_active`, `auth_user`.`date_joined` FROM `auth_user`\n使用过滤器获取特定对象\nall() 方法返回了一个包含数据库表中所有记录查询集。但在通常情况下，你往往想要获取的是完整数据集的一个子集要创建这样一个子集，你需要在原始的的查询集上增加一些过滤条件。两个最普遍的途径是：filter(**kwargs) 返回一个新的查询集，它包含满足查询参数的对象。exclude(**kwargs) 返回一个新的查询集，它包含不满足查询参数的对象。查询参数（上面函数定义中的**kwargs）需要满足特定的格式，下面字段查询一节中会提到\n- 要获取年份为2006的所有文章的查询集，可以使用filter()方法：\n  Entry.objects.filter(pub_date__year=2006)\n- 利用默认的管理器，它相当于：\n  Entry.objects.all().filter(pub_date__year=2006)\n- 查询集的筛选结果本身还是查询集，所以可以将筛选语句链接在一起。像这样：\n  Entry.objects.filter(\n    headline__startswith='What’\n  ).exclude(\n    pub_date__gte=datetime.date.today()\n  ).filter(\n    pub_date__gte=datetime(2005, 1, 30)\n  )\n# 这个例子最开始获取数据库中所有对象的一个查询集，之后增加一个过滤器，然后又增加一个排除，再之后又是另外一个过滤器。最后的结果仍然是一个查询集，它包含标题以”What“开头、发布日期在2005年1月30日至当天之间的所有记录。\n查询的特性\n过滤后的查询集是独立的\n每次你筛选一个查询集，得到的都是全新的另一个查询集，它和之前的查询集之间没有任何绑定关系。每次筛选都会创建一个独立的查询集，它可以被存储及反复使用。\n q1 = Entry.objects.filter(headline__startswith=\"What\")\n q2 = q1.exclude(pub_date__gte=datetime.date.today())\n q3 = q1.filter(pub_date__gte=datetime.date.today())\n查询集是惰性执行的\n查询集是惰性执行的 —— 创建查询集不会带来任何数据库的访问。你可以将过滤器保持一整天，直到查询集 需要求值时，Django 才会真正运行这个查询。\n  >>> q = Entry.objects.filter(headline__startswith=\"What\")\n  >>> q = q.filter(pub_date__lte=datetime.date.today())\n  >>> q = q.exclude(body_text__icontains=\"food\")\n  >>> print(q)\n虽然它看上去有三次数据库访问，但事实上只有在最后一行（print(q)）时才访问一次数据库。一般来说，只有在“请求”查询集 的结果时才会到数据库中去获取它们。当你确实需要结果时，查询集 通过访问数据库来求值\n获取单一的元素\nfilter() 始终给你一个查询集，即使只有一个对象满足查询条件 —— 这种情况下，查询集将只包含一个元素。如果你知道只有一个对象满足你的查询，你可以使用管理器的get() 方法，它直接返回该对象：\none_entry = Entry.objects.get(pk=1)\n可以对get() 使用任何查询表达式，和filter() 一样\n使用get() 和使用filter() 的切片[0] 有一点区别。如果没有结果满足查询，get() 将引发一个DoesNotExist 异常。这个异常是正在查询的模型类的一个属性 —— 所以在上面的代码中，如果没有主键为1 的Entry 对象，Django 将引发一个Entry.DoesNotExist。\n如果有多条记录满足get() 的查询条件，Django 也将报错。这种情况将引发MultipleObjectsReturned，它同样是模型类自身的一个属性。\n限制查询集\n可以使用Python 的切片语法来限制查询集记录的数目 。它等同于SQL 的LIMIT 和OFFSET 子句。\n  >>> Entry.objects.all()[:5]\n  >>> Entry.objects.all()[5:10]\n字段查询\n字段查询是指如何指定SQL WHERE 子句的内容。它们通过查询集方法filter()、exclude() 和 get() 的关键字参数指定。查询的关键字参数的基本形式是field__lookuptype=value（中间是两个下划线）\n>>> Entry.objects.filter(pub_date__lte='2006-01-01')\n  SELECT * FROM blog_entry WHERE pub_date <= '2006-01-01';\nexact “精确”匹配\n  >>> Entry.objects.get(headline__exact=\"Man bites dog\")\n  SELECT ... WHERE headline = 'Man bites dog';\n  >>> Blog.objects.get(id__exact=14)\n  >>> Blog.objects.get(id=14)\n\niexact 大小写不敏感的匹配\ncontains 大小写敏感的包含指定字符串\nicontains 大小写不敏感的包含指定字符串\nstartswith, endswith 以指字字符串开头或结尾\nistartswith, iendswith\nin 在给定的列表内\ngt 大于\ngte 大于或等于\nlt 小于\nlte 小于或等于\nrange 在指定范围内\nyear /month / day/ week_day 对于日期和日期时间字段，匹配年/月/日/星期\n\n查询的快捷方式pk\nDjango 提供一个查询快捷方式pk ，它表示“primary key” 的意思\n  >>> Blog.objects.get(id__exact=14)\n  >>> Blog.objects.get(id=14)\n  >>> Blog.objects.get(pk=14)\norder_by\n默认情况下，QuerySet 根据模型Meta 类的ordering 选项排序。你可以使用order_by 方法给每个QuerySet 指定特定的排序\nEntry.objects.filter(pub_date__year=2005).order_by('-pub_date', 'headline')\n上面的结果将按照pub_date 降序排序，然后再按照headline 升序排序。\"-pub_date\" 前面的负号表示降序排序。隐式的是升序排序。若要随机排序，请使用\"?\"，像这样：\nEntry.objects.order_by('?')\nvalues\n返回一个ValuesQuerySet —— QuerySet 的一个子类，迭代时返回字典而不是模型实例对象。每个字典表示一个对象，键对应于模型对象的属性名称。values() 接收可选的位置参数*fields，它指定SELECT 应该限制哪些字段。如果指定字段，每个字典将只包含指定的字段的键/值。如果没有指定字段，每个字典将包含数据库表中所有字段的键和值。\nUser.objects.values(\"id\", \"username\")\nvalues_list\n与values() 类似，只是在迭代时返回的是元组而不是字典。每个元组包含传递给values_list() 调用的字段的值 —— 所以第一个元素为第一个字段，以此类推。\nUser.objects.values_list('id', 'username')\ndefer\n在一些复杂的数据建模情况下，您的模型可能包含大量字段，其中一些可能包含大量数据需要昂贵的处理来将它们转换为Python对象。（例如，文本字段），或者如果您在某些情况下使用查询集的结果，当您最初获取数据时不知道是否需要这些特定字段，可以告诉Django不要从数据库中检索它们\nUser.objects.defer(\"username\", \"email\")\n删除对象\n删除对象使用delete()。这个方法将立即删除对象且没有返回值。\nEntry.objects.filter(pub_date__year=2005).delete()\n拷贝\n虽然没有内建的方法用于拷贝模型实例，但还是很容易创建一个新的实例并让它的所有字段都拷贝过来。最简单的方法是，只需要将pk 设置为None。\n  blog = Blog(name='My blog', tagline='Blogging is easy')\n  blog.save() # blog.pk == 1\n  blog.pk = None\n  blog.save() # blog.pk == 2\n更新对象\n更新对象使用update()\nEntry.objects.filter(pub_date__year=2007).update(headline='Everything is the same')\nupdate() 方法会立即执行并返回查询匹配的行数(如果有些行已经具有新的值，返回的行数可能和被更新的行数不相等)\nF() -- 专门取对象中某列值的操作\nF()允许Django在未实际链接数据的情况下具有对数据库字段的值的引用。通常情况下我们在更新数据时需要先从数据库里将原数据取出后方在内存里，然后编辑某些属性，最后提交。例如\n  order = Order.objects.get(orderid='123456789')\n  order.amount += 1\n  order.save()\n这时就可以使用F()方法，代码如下\n  from django.db.models import F\n  order = Order.objects.get(orderid='123456789')\n  order.amount = F('amount') - 1\n  order.save()\nQ() -- 对对象的复杂查询\nQ对象(django.db.models.Q)可以对关键字参数进行封装，从而更好地应用多个查询。可以组合使用 &（and）,|（or），~（not）操作符，当一个操作符是用于两个Q的对象,它产生一个新的Q对象。\n  Order.objects.get(\n    Q(desc__startswith='Who'),\n    Q(create_time=date(2016, 10, 2)) | Q(create_time=date(2016, 10, 6))\n  )\n\n相当于\n  SELECT * from polls WHERE question LIKE 'Who%'\n  AND (pub_date = '2005-05-02' OR pub_date = '2005-05-06')\n序列化模型对象\n  from django.core import serializers\n  data = serializers.serialize(\"json\", SomeModel.objects.all())\n序列化子集\nfrom django.core import serializers\ndata = serializers.serialize(\"json\", User.objects.all()[0:10], fields=('username','is_active'))\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}