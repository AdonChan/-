{"title": "用 Django 零成本快速实现 API 服务 - python web 学习轨迹 ", "index": "序列化,api,django,python", "content": "写后台的时候经常需要写数据接口，这时就需要用到序列化工具， 而默认到序列化工具对 Django model 的序列化支持有限。 同时 Django 本身的序列化工具我在使用时也觉得有诸多不便，因此我尝试自己写了一个快速序列化工具，帮助我快速简单的实现数据接口。\nDjango Simple Serializer 是一个可以帮助开发者快速将 Django 数据或者 python data 序列化为 json|raw 数据的工具。\n为什么要用 Django Simple Serializer ?\n对于序列化 Django 数据的解决方案已经有以下几种：\ndjango.core.serializers\nDjango内建序列化器, 它可以序列化Django model query set 但无法直接序列化单独的Django model数据。如果你的model里含有混合数据 , 这个序列化器同样无法使用(如果你想直接使用序列化数据). 除此之外, 如果你想直接把序列化数据返回给用户,显然它包含了很多敏感及对用户无用对信息。\nQuerySet.values()\n和上面一样, 如果你的model里有 DateTimeField 或者其他特殊的 Field 以及额外数据， QuerySet.values() 同样没法工作。\ndjango-rest-framework serializers\ndjango-rest-framework 是一个可以帮助你快速构建 REST API 的强力框架。 他拥有完善的序列化器，但在使用之前你需要花费一些时间入门, 并学习 cbv 的开发方式, 对于有时间需求的项目或者已经存在的项目需要增加数据接口时显然这不是最好的解决方案。\ndjango simple serializer\n我希望可以快速简单的序列化数据, 所以我设计了一种可以不用任何额外的配置与学习而将Django data 或者 python data 序列化为相应的数据的简单的方式。 这就是为什么我写了 django simple serializer。\n\n运行需求\nDjango >= 1.5\nPython 2.5 及以上 (暂不支持 python 3)\n安装\nInstall using pip:\npip install django-simple-serializer\n\n使用 django simple serializer 进行开发\n序列化Django data\n假设我们有以下Django models：\nclass Classification(models.Model):\n    c_name = models.CharField(max_length=30, unique=True)\n\nclass Article(models.Model):\n    caption = models.CharField(max_length=50)\n    classification = models.ForeignKey(Classification, related_name='cls_art')\n    content = models.TextField()\n    publish = models.BooleanField(default=False)\n\n使用django simple serializer的简单例子：\nfrom dss.Serializer import serializer\narticle_list = Article.objects.all()\ndata = serializer(article_list)\n\ndata:\n[{'read_count': 0, 'create_time': 1432392456.0, 'modify_time': 1432392456.0, 'sub_caption': u'first', 'comment_count': 0, u'id': 31}, {'read_count': 0, 'create_time': 1432392499.0, 'modify_time': 1432392499.0, 'sub_caption': u'second', 'comment_count': 0, u'id': 32}]\n\n默认情况下, 序列器会返回一个 list 或者 dict(对于单个model实例), 你可以设置参数 “output_type” 来决定序列器返回 json/raw.\n\nAPI 手册\ndss.Serializer\n提供序列器\nfunction serializer(data, datetime_format='timestamp', output_type='raw', include_attr=None, except_attr=None, foreign=False, many=False)\nParameters:\n\ndata(_Required_|(QuerySet, Page, list, django model object))-待处理数据\ndatetime_format(_Optional_|string)-如果包含 datetime 将 datetime 转换成相应格式.默认为 \"timestamp\"（时间戳）\noutput_type(_Optional_|string)-serialize type. 默认“raw”原始数据，即返回list或dict\ninclude_attr(_Optional_|(list, tuple))-只序列化 include_attr 列表里的字段。默认为 None\nexclude_attr(_Optional_|(list, tuple))-不序列化 except_attr 列表里的字段。默认为 None\nforeign(_Optional_|bool)-是否序列化 ForeignKeyField 。include_attr 与 exclude_attr 对   ForeignKeyField 依旧有效。 默认为 False\nmany(_Optional_|bool)-是否序列化 ManyToManyField 。include_attr 与 exclude_attr 对 ManyToManyField 依旧有效 默认为 False\n\n用法:\ndatetime_format:\n\n\nparameters\nintro\n\n\n\nstring\n转换 datetime 为字符串。如： \"2015-05-10 10:19:22\"\n\n\ntimestamp\n转换 datetime 为时间戳。如： \"1432124420.0\"\n\n\n\n例子:\nfrom dss.Serializer import serializer\narticle_list = Article.objects.all()\ndata = serializer(article_list, datetime_format='string', output_type='json')\n\ndata:\n[\n    {\n        \"read_count\": 0,\n        \"sub_caption\": \"first\",\n        \"publish\": true,\n        \"content\": \"first article\",\n        \"caption\": \"first\",\n        \"comment_count\": 0,\n        \"create_time\": \"2015-05-23 22:47:36\",\n        \"modify_time\": \"2015-05-23 22:47:36\",\n        \"id\": 31\n    },\n    {\n        \"read_count\": 0,\n        \"sub_caption\": \"second\",\n        \"publish\": false,\n        \"content\": \"second article\",\n        \"caption\": \"second\",\n        \"comment_count\": 0,\n        \"create_time\": \"2015-05-23 22:48:19\",\n        \"modify_time\": \"2015-05-23 22:48:19\",\n        \"id\": 32\n    }\n]\n\noutput_type\n\n\nparameters\nintro\n\n\n\nraw\n将list或dict中的特殊对象序列化后输出为list或dict\n\n\ndict\n同 raw\n\n\njson\n转换数据为 json\n\n\n\nxml 转换数据为 xml  (暂时去除)\n例子:\nfrom dss.Serializer import serializer\narticle_list = Article.objects.all()[0]\ndata = serializer(article_list, output_type='json')\n\ndata:\n{\n        \"read_count\": 0,\n        \"sub_caption\": \"first\",\n        \"publish\": true,\n        \"content\": \"first article\",\n        \"caption\": \"first\",\n        \"comment_count\": 0,\n        \"create_time\": \"2015-05-23 22:47:36\",\n        \"modify_time\": \"2015-05-23 22:47:36\",\n        \"id\": 31\n    }\n\ninclude_attr\n例子:\nfrom dss.Serializer import serializer\narticle_list = Article.objects.all()\ndata = serializer(article_list, output_type='json', include_attr=('content', 'caption',))\n\ndata:\n[\n    {\n        \"content\": \"first article\",\n        \"caption\": \"first\"\n    },\n    {\n        \"content\": \"second article\",\n        \"caption\": \"second\"\n    }\n]\n\nexclude_attr\n例子:\nfrom dss.Serializer import serializer\narticle_list = Article.objects.all()\ndata = serializer(article_list, output_type='json', except_attr=('content',))\n\ndata:\n    [\n        {\n            \"read_count\": 0,\n            \"sub_caption\": \"first\",\n            \"publish\": true,\n            \"caption\": \"first\",\n            \"comment_count\": 0,\n            \"create_time\": 1432392456,\n            \"modify_time\": 1432392456,\n            \"id\": 31\n        },\n        {\n            \"read_count\": 0,\n            \"sub_caption\": \"second\",\n            \"publish\": false,\n            \"caption\": \"second\",\n            \"comment_count\": 0,\n            \"create_time\": 1432392499,\n            \"modify_time\": 1432392499,\n            \"id\": 32\n        }\n    ]\n    \nforeign\n序列化数据中的 ForeignKeyField 及其子项目\n例子:\nfrom dss.Serializer import serializer\narticle_list = Article.objects.all()\ndata = serializer(article_list, output_type='json', include_attr=('classification', 'caption', 'create_time', foreign=True)\n\ndata:\n    [\n        {\n            \"caption\": \"first\",\n            \"create_time\": 1432392456,\n            \"classification\": {\n                \"create_time\": 1429708506,\n                \"c_name\": \"python\",\n                \"id\": 1,\n                \"modify_time\": 1429708506\n            }\n        },\n        {\n            \"caption\": \"second\",\n            \"create_time\": 1432392499,\n            \"classification\": {\n                \"create_time\": 1430045890,\n                \"c_name\": \"test\",\n                \"id\": 5,\n                \"modify_time\": 1430045890\n            }\n        }\n    ]\n\nmany序列化 ManyToManyField\nexample:\nfrom dss.Serializer import serializer\narticle_list = Article.objects.all()\ndata = serializer(article_list, output_type='json', include_attr=('classification', 'caption', 'create_time', many=True)\n\n测试数据无 ManyToManyField ，数据格式同上\ndss.Mixin\n提供序列器 Mixin\nclass JsonResponseMixin(object)\n    datetime_type = 'string'                # 输出datetime时间格式。默认为“string”，可选参数相见dss.Serializer.serializer\n    foreign = False                         # 是否序列化ForeignField。默认为False\n    many = False                            # 是否序列化ManyToManyField。默认为False\n    include_attr = None                     # 只序列化include_attr包含的属性。默认为None,接受一个包含属性名称的tuple\n    exclude_attr = None                     # 不序列化exclude_attr包含的属性。默认为None,接受一个包含属性名称的tuple\n\n说明:\n将普通class based view 转换为返回json数据的class based view，适用于DetailView等\n用法:\n例子:\n# view.py\nfrom dss.Mixin import JsonResponseMixin\nfrom django.views.generic import DetailView\nfrom model import Article\n\nclass TestView(JsonResponseMixin, DetailView):\n    model = Article\n    datetime_type = 'string'\n    pk_url_kwarg = 'id'\n\n\n# urls.py\nfrom view import TestView\nurlpatterns = patterns('',\n    url(r'^test/(?P<id>(\\d)+)/$', TestView.as_view()),\n)\n    \n访问：localhost:8000/test/1/\nresponse:\n{\n    \"article\": {\n        \"classification_id\": 5, \n        \"read_count\": 0, \n        \"sub_caption\": \"second\", \n        \"comments\": [], \n        \"content\": \"asdfasdfasdf\", \n        \"caption\": \"second\", \n        \"comment_count\": 0, \n        \"id\": 32, \n        \"publish\": false\n    }, \n    \"object\": {\n        \"classification_id\": 5, \n        \"read_count\": 0, \n        \"sub_caption\": \"second\", \n        \"comments\": [], \n        \"content\": \"asdfasdfasdf\", \n        \"caption\": \"second\", \n        \"comment_count\": 0, \n        \"id\": 32, \n        \"publish\": false\n    }, \n    \"view\": \"\"\n}\n\nclass MultipleJsonResponseMixin(JsonResponseMixin):\n说明:\n将列表类视图转换为返回json数据的类视图，适用于ListView等\n用法:\n例子:\n# view.py\nfrom dss.Mixin import MultipleJsonResponseMixin\nfrom django.views.generic import ListView\nfrom model import Article\n\nclass TestView(MultipleJsonResponseMixin, ListView):\n    model = Article\n    query_set = Article.objects.all()\n    paginate_by = 1\n    datetime_type = 'string'\n\n\n# urls.py\nfrom view import TestView\nurlpatterns = patterns('',\n    url(r'^test/$', TestView.as_view()),\n)\n    \n访问：localhost:8000/test/\nresponse:\n{\n    \"paginator\": \"\", \n    \"article_list\": [\n        {\n            \"classification_id\": 1, \n            \"read_count\": 2, \n            \"sub_caption\": \"first\", \n            \"content\": \"first article\", \n            \"caption\": \"first\", \n            \"comment_count\": 0, \n            \"publish\": false, \n            \"id\": 31\n        }, \n        {\n            \"classification_id\": 5, \n            \"read_count\": 0, \n            \"sub_caption\": \"\", \n            \"content\": \"testseteset\", \n            \"caption\": \"hehe\", \n            \"comment_count\": 0, \n            \"publish\": false, \n            \"id\": 33\n        }, \n        {\n            \"classification_id\": 5, \n            \"read_count\": 0, \n            \"sub_caption\": \"second\", \n            \"content\": \"asdfasdfasdf\", \n            \"caption\": \"second\", \n            \"comment_count\": 0, \n            \"publish\": false, \n            \"id\": 32\n        }\n    ], \n    \"object_list\": [\n        {\n            \"classification_id\": 1, \n            \"read_count\": 2, \n            \"sub_caption\": \"first\", \n            \"content\": \"first article\", \n            \"caption\": \"first\", \n            \"comment_count\": 0, \n            \"publish\": false, \n            \"id\": 31\n        }, \n        {\n            \"classification_id\": 5, \n            \"read_count\": 0, \n            \"sub_caption\": \"\", \n            \"content\": \"testseteset\", \n            \"caption\": \"hehe\", \n            \"comment_count\": 0, \n            \"publish\": false, \n            \"id\": 33\n        }, \n        {\n            \"classification_id\": 5, \n            \"read_count\": 0, \n            \"sub_caption\": \"second\", \n            \"content\": \"asdfasdfasdf\", \n            \"caption\": \"second\", \n            \"comment_count\": 0, \n            \"publish\": false, \n            \"id\": 32\n        }\n    ], \n    \"page_obj\": {\n        \"current\": 1, \n        \"next\": 2, \n        \"total\": 3, \n        \"page_range\": [\n            {\n                \"page\": 1\n            }, \n            {\n                \"page\": 2\n            }, \n            {\n                \"page\": 3\n            }\n        ], \n        \"previous\": null\n    }, \n    \"is_paginated\": true, \n    \"view\": \"\"\n}\n\nclass FormJsonResponseMixin(JsonResponseMixin):\n说明:\n将普通class based view 转换为返回json数据的class based view，适用于CreateView、UpdateView、FormView等\n用法:\n例子:\n# view.py\nfrom dss.Mixin import FormJsonResponseMixin\nfrom django.views.generic import UpdateView\nfrom model import Article\n\nclass TestView(FormJsonResponseMixin, UpdateView):\n    model = Article\n    datetime_type = 'string'\n    pk_url_kwarg = 'id'\n\n\n# urls.py\nfrom view import TestView\nurlpatterns = patterns('',\n    url(r'^test/(?P<id>(\\d)+)/$', TestView.as_view()),\n)\n    \n访问：localhost:8000/test/1/\nresponse:\n{\n    \"article\": {\n        \"classification_id\": 5, \n        \"read_count\": 0, \n        \"sub_caption\": \"second\", \n        \"content\": \"asdfasdfasdf\", \n        \"caption\": \"second\", \n        \"comment_count\": 0, \n        \"id\": 32, \n        \"publish\": false\n    }, \n    \"form\": [\n        {\n            \"field\": \"caption\"\n        }, \n        {\n            \"field\": \"sub_caption\"\n        }, \n        {\n            \"field\": \"read_count\"\n        }, \n        {\n            \"field\": \"comment_count\"\n        }, \n        {\n            \"field\": \"classification\"\n        }, \n        {\n            \"field\": \"content\"\n        }, \n        {\n            \"field\": \"publish\"\n        }\n    ], \n    \"object\": {\n        \"classification_id\": 5, \n        \"read_count\": 0, \n        \"sub_caption\": \"second\", \n        \"content\": \"asdfasdfasdf\", \n        \"caption\": \"second\", \n        \"comment_count\": 0, \n        \"id\": 32, \n        \"publish\": false\n    }, \n    \"view\": \"\"\n}\n\n对额外数据的序列化支持:\n当我们想在 model 中加入一些额外的数据并也想被序列化时, 现在可以这样做:\n    def add_extra(article):\n        comments = Comment.objects.filter(article=article)\n        setattr(article, 'comments', comments)\n    \n    articles = Article.objects.all()\n    map(add_extra, articles)\n    result = serializer(articles)\n序列化的结果数据中将会包含\"comments\"哦.\n额外加入的数据可以是一个普通的数据类型、 另一个 Django model、 字典、 列表甚至 QuerySet\ndjango simple serializer 的实际例子: 个人网站后台数据接口 \n项目地址： django-simple-serializer\n欢迎大家拍砖并提供宝贵意见。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "16"}