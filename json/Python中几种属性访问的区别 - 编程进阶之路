{"title": "Python中几种属性访问的区别 - 编程进阶之路 ", "index": "python", "content": "起步\npython的提供一系列和属性访问有关的特殊方法：__get__, __getattr__, __getattribute__, __getitem__ 。本文阐述它们的区别和用法。\n属性的访问机制\n一般情况下，属性访问的默认行为是从对象的字典中获取，并当获取不到时会沿着一定的查找链进行查找。例如 a.x 的查找链就是，从 a.__dict__['x'] ，然后是 type(a).__dict__['x'] ，再通过 type(a) 的基类开始查找。\n若查找链都获取不到属性，则抛出 AttributeError 异常。\n\n__getattr__ 方法\n这个方法是当对象的属性不存在是调用。如果通过正常的机制能找到对象属性的话，不会调用 __getattr__ 方法。\nclass A:\n    a = 1\n    def __getattr__(self, item):\n        print('__getattr__ call')\n        return item\n\nt = A()\nprint(t.a)\nprint(t.b)\n# output\n1\n__getattr__ call\nb\n\n__getattribute__ 方法\n这个方法会被无条件调用。不管属性存不存在。如果类中还定义了 __getattr__ ，则不会调用 __getattr__() 方法，除非在 __getattribute__ 方法中显示调用__getattr__() 或者抛出了 AttributeError 。\nclass A:\n    a = 1\n    def __getattribute__(self, item):\n        print('__getattribute__ call')\n        raise AttributeError\n\n    def __getattr__(self, item):\n        print('__getattr__ call')\n        return item\n\nt = A()\nprint(t.a)\nprint(t.b)\n所以一般情况下，为了保留 __getattr__ 的作用，__getattribute__() 方法中一般返回父类的同名方法：\ndef __getattribute__(self, item):\n    return object.__getattribute__(self, item)\n使用基类的方法来获取属性能避免在方法中出现无限递归的情况。\n\n__get__ 方法\n这个方法比较简单说明，它与前面的关系不大。\n如果一个类中定义了 __get__(), __set__() 或 __delete__() 中的任何方法。则这个类的对象称为描述符。\nclass Descri(object):\n    def __get__(self, obj, type=None):\n        print(\"call get\")\n\n    def __set__(self, obj, value):\n        print(\"call set\")\n\n\nclass A(object):\n    x = Descri()\n\na = A()\na.__dict__['x'] = 1  # 不会调用 __get__\na.x                  # 调用 __get__\n如果查找的属性是在描述符对象中，则这个描述符会覆盖上文说的属性访问机制，体现在查找链的不同，而这个行文也会因为调用的不同而稍有不一样：\n\n如果调用是对象实例(题目中的调用方式)，a.x 则转换为调用： 。type(a).__dict__['x'].__get__(a, type(a))\n\n如果调用的是类属性, A.x 则转换为：A.__dict__['x'].__get__(None, A)\n\n其他情况见文末参考资料的文档\n\n\n__getitem__ 方法\n这个调用也属于无条件调用，这点与 __getattribute__ 一致。区别在于 __getitem__ 让类实例允许 [] 运算，可以这样理解：\n\n\n__getattribute__ 适用于所有 . 运算符；\n\n__getitem__ 适用于所有 [] 运算符。\n\nclass A(object):\n    a = 1\n\n    def __getitem__(self, item):\n        print('__getitem__ call')\n        return item\n\nt = A()\nprint(t['a'])\nprint(t['b'])\n如果仅仅想要对象能够通过 [] 获取对象属性可以简单的：\ndef __getitem(self, item):\n    return object.__getattribute__(self, item)\n总结\n当这几个方法同时出现可能就会扰乱你了。我在网上看到一份示例还不错，稍微改了下：\nclass C(object):\n    a = 'abc'\n\n    def __getattribute__(self, *args, **kwargs):\n        print(\"__getattribute__() is called\")\n        return object.__getattribute__(self, *args, **kwargs)\n\n    #        return \"haha\"\n    def __getattr__(self, name):\n        print(\"__getattr__() is called \")\n        return name + \" from getattr\"\n\n    def __get__(self, instance, owner):\n        print(\"__get__() is called\", instance, owner)\n        return self\n\n    def __getitem__(self, item):\n        print('__getitem__ call')\n        return object.__getattribute__(self, item)\n\n    def foo(self, x):\n        print(x)\n\n\nclass C2(object):\n    d = C()\n\n\nif __name__ == '__main__':\n    c = C()\n    c2 = C2()\n    print(c.a)\n    print(c.zzzzzzzz)\n    c2.d\n    print(c2.d.a)\n    print(c['a'])\n可以结合输出慢慢理解，这里还没涉及继承关系呢。总之，每个以 __ get 为前缀的方法都是获取对象内部数据的钩子，名称不一样，用途也存在较大的差异，只有在实践中理解它们，才能真正掌握它们的用法。\n参考\n\nhttps://docs.python.org/3/ref...\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}