{"title": "Python序列化模型数据为JSON - 曾经的自己 ", "index": "orm,python", "content": "原文地址:\nhttp://52sox.com/use-python-serialization-orm-data-to-json/\n相信使用Python做Web开发的朋友都会遇到这样1个问题,那就是在项目开发中使用模型框架,比如SQLAlchemy、Peewee,我们在做RESTful接口时如何将这些模型序列化为JSON数据。  关于这个问题,跟隔壁那位搞Python的哥们有关系。我不得不佩服这位哥们竟然自己写了1套ORM框架,而且用起来的那么遛,不得不让我汗颜。  但是,在给前端提供接口的时候,如何序列化为JSON数据确实困扰了我们那么一阵子,毕竟占据我们很大一部分时间来进行序列化操作。    这里,我们使用peewee来定义1个简单的例子来说明:\nfrom peewee import SqliteDatabase\nfrom peewee import Model, CharField, DateField, BooleanField, ForeignKeyField\n\ndb = SqliteDatabase('dev.sqlite3')\n\nclass BaseModel(Model):\n    class Meta:\n        database = db\n\nclass Person(BaseModel):\n    name = CharField(max_length= 20)\n    birthday = DateField()\n    sex = BooleanField()\n\nclass Pet(BaseModel):\n    owner = ForeignKeyField(Person, related_name= 'pets')\n    name = CharField(max_length= 10)\n    animal_type = CharField(max_length= 20)\n在这里我们定义了Person和Pet这2个模型,每个Person可能有1个Pet的宠物。  我们插入一些数据,现在假设我们现在有如下的数据:\nsqlite> select * from person;\n1|Bob|1960-01-15|1\n2|Grandma|1935-03-01|0\n3|Herb|1950-05-05|1\nsqlite> select * from pet;\n1|1|Kitty|cat\n2|3|Fido|dog\n3|3|Mittens|cat\n4|2|Jack|cat\n\n现在,我们假设我们接口需要返回的接口是每个用户的名称、生日及其对应的宠物的信息。  我们可以通过连表的方式轻松的获取到我们需要的数据:\nquery=Person.select(Person,Pet).join(Pet)\n那么我们怎么将这个模型数据转换为我们需要的JSON数据呢?一般情况下,我们会这样操作:\ndata = []\nfor person in query.aggregate_rows():\n    d={}\n    d['username'] = person.name\n    d['birthday'] = person.birthday\n    d['pet'] = []\n    for pet in person.pets:\n        o = {}\n        o['name'] = pet.name\n        o['animal_type'] = pet.animal_type\n        d['pet'].append(o)\n    data.append(d)\n最后我们将得到如下的结果:\n[{'birthday': datetime.date(1960, 1, 15),\n  'pet': [{'animal_type': u'cat', 'name': u'Kitty'}],\n  'username': u'Bob'},\n {'birthday': datetime.date(1950, 5, 5),\n  'pet': [{'animal_type': u'dog', 'name': u'Fido'},\n   {'animal_type': u'cat', 'name': u'Mittens'}],\n  'username': u'Herb'},\n {'birthday': datetime.date(1935, 3, 1),\n  'pet': [{'animal_type': u'cat', 'name': u'Jack'}],\n  'username': u'Grandma'}]\n\n可以看到,这么1个简单的例子,我们已经对序列化操作处理的已经够呛的。对于那些更为复杂的模型,我们预计只有哭的份了。  因此,我们希望能找到1个库可以减轻我们的工作量,于是我们找到了1个marshallow的库。  下面我们来说说如何使用marshallow来减轻序列化模型的工作量。  主要包括如下2个步骤:\n\n定义模式\n序列化模型\n\n下面我们分别来看看。\n定义模式\n如果你使用过Flask-RESTful,你应该知道该库提供了1个marshal_with的函数。其中我们就需要定义我们给定字段返回的数据类型,但是Flask-RESTful没有提供字段不同返回的操作。  我们通过如下的方式导入模式及其对应的字段:\nfrom marshmallow import Schema, fields\n接下来,我们定义1个继承自Schema的类,然后定义其对应的字段:\nclass PetSchema(Schema):\n    name = fields.String()\n    animal_type = fields.String()\n    \nclass PersonSchema(Schema):\n    name = fields.String(dump_to = 'username')\n    birthday = fields.Date()\n    pets = fields.Nested(PetSchema,dump_to='pet',many=True)\n由于这里,我们将用户的name属性修改为username,因此我们需要在字段中使用dump_to参数将其修改为我们需要的字段。另外,用户的pet字段对应的是宠物的信息,因此我们采用嵌套模式来实现这样需求。\n序列化模型\n上面我们已经定义好了我们的模式了,下一步是序列化模型的操作了。  我们可以这样来操作:\nquery=Person.select(Person, Pet).join(Pet)\n接着,我们实例化我们的模式,然后传入需要序列化的模型:\nperson, error = PersonSchema(many = True).dumps(query.aggregate_rows())\n在这里,我们调用PersonSchema实例的dumps来生成JSON数据,另外它还有1个dump方法用于生成Python对象。由于我们的渲染的数据有多条,因此我们需要在实例化PersonSchema类时传入关键字参数many为True,不然没有任何数据。  通过这种方式,PersonSchema会查看它自己的属性,将数据模型中对应的数据先序列化出来,然后是查询嵌套模式中的字段,如果符合对应的名称则将其序列化出来,最后我们将得到这样的数据:\n[\n    {\n        \"username\": \"Bob\",\n        \"pet\": [\n            {\n                \"animal_type\": \"cat\",\n                \"name\": \"Kitty\"\n            }\n        ],\n        \"birthday\": \"1960-01-15\"\n    },\n    {\n        \"username\": \"Herb\",\n        \"pet\": [\n            {\n                \"animal_type\": \"dog\",\n                \"name\": \"Fido\"\n            },\n            {\n                \"animal_type\": \"cat\",\n                \"name\": \"Mittens\"\n            }\n        ],\n        \"birthday\": \"1950-05-05\"\n    },\n    {\n        \"username\": \"Grandma\",\n        \"pet\": [\n            {\n                \"animal_type\": \"cat\",\n                \"name\": \"Jack\"\n            }\n        ],\n        \"birthday\": \"1935-03-01\"\n    }\n]\n\n可以看到,通过marshallow得到的结果与之前我们编写的序列化操作的结果是一样的。  不得不说,marshallow这个库对于序列化模型其实挺实用的。当然对于复杂的模型,我们需要利用合适的方式将其搜索出来,不然还是序列化不了的。  \n参考文章:\nhttps://marshmallow.readthedocs.io/en/latest/quickstart.html\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "10"}