{"title": "[Violent Python for Hackers]常用工具收集整理 - cherishsir ", "index": "python,hacker,web", "content": "0：常用工具\n#后面的三个工具无法安装，原因目前不知，后面用来时再寻找解决方法\npip install python-nmap python-bluez bluetooth python obexftp\n\n#pycrypto是一个非常强大的加密解密module,对于信息的加密和破解是需要经常用到的\npip install pycrypto   #在windows下，安装报错后，需要安装一个VCForPython27.msi的软件即可，详细看安装的报错信息\n\n#在windows下import crypt，发现找不到此module,发现只在linux系统下Python才自带有此模块\ncrypt.crypt(word, salt) #这个module只有这一个函数\n\n1：Python基础\n#导入自己写的module\nimport sys\nsys.path.append(\"C:/pyqt/chap02\") #把我们写的module路径添加到了path路径，这里我们就可以import自己写的module了\n\n#data type \nport=23\nbanner=\"hello hacker\"\ntype(port)\ntype(banner)\nbanner.upper()\nbanner.lower()\nbanner.replace(\"old\",\"new\")\nbanner.find(\"hacker\")\n\n#list \nportlist=[]\nportlist.append(22)\nportlist.append(80)\nprint portlist\nportlist.sort() #对portlist进行排序 \npos=portlist.index(80)\nportlist.remove(443)\nprint portlist\ncnt=len(portlist)\n\n#dictionary\nservices={\"ftp\":21,\"ssh\":22,\"smtp\":25,\"http\":80}\nservices.keys() # return list\nservices.items()  #change to tuple couple\nservices.has_key(\"ftp\")  #true or false\nservices[\"ftp\"]  # return value\n\n2：Networking部分\nimport socket\nsocket.setdefaulttimeout(2) #2秒时长没有收到想要的数据长度，就返回了socket.timeout 异常\ns=socket.socket() #创建一个socket对象\ns.connect((\"8.8.8.8\",21))\nans=s.recv(1024) #从服务器接收 1024个数据 ，如果在2秒内，没有接收完，就会返回 socket.timeo9ut异常 \n    \n3: Python简单异常处理\ntry:\n    3/0\nexcept:\n    print \"3/0 is illegal\"\n\n#下面是除0后，得到的ZeroDivisionError\n>>> 3/0\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nZeroDivisionError: integer division or modulo by zero\n\n#异常处理可以保证，程序出错后，自动处理错误，程序可以接着运行下\n#没有异常处理，程序会由于这些异常直接退出\n    \n#查看异常类型：\ntry:\n    15/0\nexcept Exception, e:\n    print \"Error\"+str(e)\n        \n    \n#socket中使用异常处理\nimport socket\nsocket.setdefaulttimeout(2)\ns=socket.socket()\ntry:\n    s.connect((\"8.8.8.8\",21))  #  成功后，不会运行except部分\nexcept Exception,e:\n    print \"error\"+str(e)       #  connect失败后，会运行这部分代码\n4：函数的使用\nimport socket\ndef abc(arg1,arg2):\n    try:\n            socket.setdefaulttimeout(2)\n            xxx\n            return \n    except:\n            return \ndef main():\n        xxx\n\nif __name__==\"__main__\":\n    main()  \n\n5：IP,Port的扫描\nportList=[21,22,25,80,110]\nfor x in range (1,255):\n    for port in  portList:\n        print \"Checkingt 192.168.1\"+str(x)+\":\"+str(port)\n        \n#文件的行读取\nf=open(\"hello.txt\",\"r\")\nfor line in f.readlines():\n    if line.strip(\"\\n\") in banner:  #从文件中读取到的行内容是否有用 \n         print \"xxxx\"\n6：sys,os,系统模块\nimport sys\nif len(sys.argv)==2:\n    filename=sys.argv[1]\n    print \"filename\"+filename\n    \nimport os\nif not os.path.isfile(filename)\n    pirnt filename+\" does not exist\"\n    return \nif not os.access(filename,os.R_OK):  #chmod 000 a.txt  后，就无法access\n    print filename+\" access denied\"\n    return \n\n7:运行时决定是否生成函数\nimport sys\nif sys.version_info[:2] <(2,4): #小于2.4的版本没有sorted这个函数，那么我们自己写一个，用自己的\n    def sorted(items):\n        xxx\n        xxx\n        return items\n8：Python异常处理\n#运行过程：\n#先try,输出 hello ahc,然后运行3/0后报错\n#接下来进行except,输出except happened\n#接下来程序接着往下走（不会执行else)\nfor i in dir(a):\n    try:\n        print \"hello ahc\"\n        3/0\n    except:\n        print \"except happened\"\n    else:\n        print \"run without except\"\n\\\n#运行过程：\n#输出hello ahc,由于没有异常，所以会运行else,输出run always\ntry:\n    print \"hello ahc\"\nexcept:\n    print \"except happened\"\nelse:\n    print \"run without except\"\n\n# 下面是一个标准的异常处理过程\ntry:\n    process()\nexcept IndexError, e:\n    print \"Error: %s\" % e\nexcept LookupError, e:\n    print \"Error: %s\" % e\n\n9:根据不同的操作系统，选择采用不同的文件路径表达形式(实用)\nimport platform\nos_type=platform.platform().lower()\nif  \"windows\" in os_type:\n    fontfile=r\"C:\\Windows\\Fonts\\timesi.ttf\"\nelse:\n    fontfile=\"/usr/share/fonts/truetype/msttcorefonts/Times_New_Roman_Italic.ttf\"\n\n10:nmap常用指令\nnmamp -sP 192.168.1.1/24   #simple information\nsudo namp -O -PN 192.168.1.1/24  #detail infromation\n11:python socket发送http get请求\n#!/usr/bin/env python\n# Foundations of Python Network Programming - Chapter 1 - search4.py\nimport socket\nsock = socket.socket()\nsock.connect(('maps.google.com', 80))\nsock.sendall(\n 'GET /maps/geo?q=207+N.+Defiance+St%2C+Archbold%2C+OH'\n '&output=json&oe=utf8&sensor=false HTTP/1.1\\r\\n'\n 'Host: maps.google.com:80\\r\\n'\n 'User-Agent: search4.py\\r\\n'\n 'Connection: close\\r\\n'\n '\\r\\n')\nrawreply = sock.recv(4096)\nprint rawreply\n12:socket编程要求点\nimport socket\n创建sock对象\ns=socket.socket(socket.AF_INET,socket.SOCK_DGRAM) #使用ipv4,使用udp协议\n\nserver:\n    创建sock\n    s.bind((\"ip\",port))        #绑定地址 ip是0.0.0.0时，是监听全网,ip是127.0.0.1时，只监听内网\n    data,address=s.recvfrom()  #监听消息 在此block \n    s.sendto(\"msg\",address)    #利用上面的地址(ip,port),来发送msg\n\nclient:\n    创建sock\n    s.sendto(\"msg\",address)  #操作系统会根据需要，随机分配port\n    data,addr=s.recv(MAX)    #这里得到的addr就是上面sendto使用的地址(ip,port)\n\n13:socket编程处理服务器端丢包问题\nimport socket\ns=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)\ns.connect((hostname,port))\ndelay=0.1\nwhile True:\n    s.send(\"this is another message\")\n    s.settimeout(delay)\n14:使用socket发送二进制原始数据(DNS协议的研究)\nimport socket\ndata=\"8d890100000100000000000005626169647503636f6d0000010001\"\nrawdata=bytes.fromhex(data) # dns raw data to get baidu ip\ns=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)\nDNSserver=\"202.114.0.242\"\ns.connect((DNSserver,53))\ns.send(rawdata)  #这里直接发送的是16进制的数据   \nrecvData=s.recv(266) #得到的数据也是最原始的16进制数据，需要阅读DNS协议的格式，然后对数据进行解包\nprint(recvData)\n15:使用下面程序研究两个主机之间UDP包能传送的最大数据量是多少\n一般的udp包能传送的最大数据量为1500bytes\n#client\nimport IN,socket,sys\ns=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)\nMAX=65535\nPORT =1060\ns.connect((\"192.168.1.1\",PORT))\ns.setsockopt(socket.IPPROTO_IP,IN.IP_MTU_DISCOVER,IN.IP_PMTUDISC_DO)\ntry:\n        s.send(\"#\"*2500)\nexcept socket.error:\n    print \"message did not make it\"\n    option=getattr(IN,\"IP_MTU\",14)\n    print \"MTU:\",s.getsockopt(socket.IPPROTO_IP,option)\nelse:\n    print \"the big message was sent! Your network supports really big packet\"\n16：socket的一些属性的设置和得到\ns=socket.socket(xx)\ns.setsockopt(xxx)\nvalue=s.getsockopt(xx)\n\n#例子，是否允许广播UDP包\nvalue=s.getsockopt(socket.SOL_SOCKET,socket.SO_BROADCAST)\ns.setsockopt(socket.SOL_SOCKET,socket.SO_BROADCAST,value)\n\nSO_DONTROUTE:只允许包发送给子网host\nSO_TYPE:当把这个参数传递给getsockopt函数时，得到当前socket使用的是tcp or udp\n17:如何发送UDP广播包 (broadcast packet)\n客户端可以开启广播选项：这样发的广播包其它的机器都能接到服务器端也可开启接收广播包的选项？才能接收广播包？这个要到后面实验看效果：不需要进行其它的配置，只需使用使用sendto时，把具体的server ip地址换成广播地址\n###client:\nimport socket\nport=1080\nbroadcastip=\"192.168.191.255\" #mask =255.255.255.0 network addr=192.168.191.0\ns=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)\n#s.setsockopt(socket.SOL_SOCKET,socket.SO_BROADCAST,1)\nprint (\"sending message to %s:%s\" %(broadcastip,port))\ns.sendto(\"this is a broadcast message\",(broadcastip,port))\n\n###server:\nimport socket\n\ndef getLocalIPandHeader(): #得到本机ip地址的函数\n    \"\"\"\n    return localIP and IPhead \n    like this :192.168.1.11  , 192.168.1.\n    \"\"\"\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    s.connect(('baidu.com', 0))\n    ip=s.getsockname()[0]\n    lastdotpos=ip.rfind(\".\")\n    iphead=ip[:lastdotpos+1]\n    return ip,iphead\n\nport=1080\nbindip,iphead=getLocalIPandHeader()\n\ns=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)\n#s.setsockopt(socket.SOL_SOCKET,socket.SO_BROADCAST,1)\ns.bind((bindip,port))\nwhile True:\n    data,addr=s.recvfrom(200)\n    pmsg=\"i got message from %s say: %s\" %(addr,data)\n    print(pmsg)\n\n\n\n18:关于文件路径的操作\n#__file__ 这个变量中保存了该程序的文件名\nabspath=os.path.abspath(__file__)    # a.py ---> /home/gaoy/pyweb/a.py\ncurrent_dir=os.path.dirname(abspath) #/home/gaoy/pyweb/a.py --->/home/gaoy/pyweb\n\n19:python装饰器的运行过程\ndef skin(func):\n    print \"in skin\"\n    def run():\n        print \"in run\"\n        func()\n        print \"after func\"\n    return run\n\n@skin\ndef myprint():\n    print \"in my print function\"\n\nmyprint()\n\n#运行结果如下 ：\n==========================\nin skin\nin run\nin my print function\nafter func\n==========================\n#如上myprint()函数被skin装饰\n\n当我们调用myprint()函数时，发生了什么？如下：\n首先skin(myrint())函数会被调用，所以会打印出 \"in skin\"字符串\n由于run中函数是在skin函数中定义的并没有调用，所以不会马上运行，\n重点就在这里的return run，return的run函数给谁呢？python解释器会把\n这个return的值赋值给myprint，然后调用“新的”myprint()函数\n\n简单的说，如果函数被装饰后，按下面方式运行：\n1：运行skin(myprint)     #decorator(func)\n2：运行装饰器内部定义的函数 #run()\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "3"}