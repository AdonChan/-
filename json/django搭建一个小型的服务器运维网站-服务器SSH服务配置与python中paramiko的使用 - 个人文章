{"title": "django搭建一个小型的服务器运维网站-服务器SSH服务配置与python中paramiko的使用 - 个人文章 ", "index": "django,python,html,javascript", "content": "目录\n\n\n项目介绍和源码；\n\n拿来即用的bootstrap模板；\n服务器SSH服务配置与python中paramiko的使用；\n\n用户登陆与session;\n\n最简单的实践之修改服务器时间；\n\n查看和修改服务器配置与数据库的路由；\n\n基于websocket的实时日志实现；\n\n查看服务器中的日志与前端的datatable的利用；\n\n重启服务器进程。\n\n前言\n  我们的Web小项目需要用到python中的paramiko这个模块去和服务器简单交互,python中的paramiko模块已经帮我们实现了基于SSH的远程服务器连接方法，本篇文章会介绍一下如何在服务器上配置一个ssh服务器，并结合网站的需求介绍下paramiko的功能，给出一些需要使用到的函数。\n配置SSH服务器\n  本地安装paramiko只需要执行pip install paramiko即可，然后把网站需要用到的服务器功能封装成函数方便调用。除此之外我们还需要在Linux服务器上配置好SSH服务，通过SSH客户端登陆服务器有三种方式，分别是：用户名+密码、用户名+私钥，后者也可以叫做免密登陆。我们先在Linux上安装一个SSH服务：\n\n执行ps -e | grep ssh*查看服务器是否开启了ssh服务，若没有则在服务器上利用sudo apt-get install openssh-server openssh-client安装ssh服务。\n安装好后开启ssh服务：执行/etc/init.d/ssh start开启服务，如图1，利用ifconfig获取到服务器的ip地址。\n\n\n打开Xsehll工具，填好服务器上面查询到的ip地址和端口号（默认为22），输入密码之后，就可以登陆到我们的服务器了，下图图2和图3。\n\n若需要免密登陆，就需要配置好公钥和私钥，为了保证安全，在自己的用户名下创建密钥对就好：\nlishouxian@lishouxian:~$ ssh-keygen                                     <== 建立密钥对\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/home/lishouxian/.ssh/id_rsa):     <== 密钥对生成的地方\nEnter passphrase (empty for no passphrase):                             <== 密钥密码，可留空\nEnter same passphrase again: \nYour identification has been saved in /home/lishouxian/.ssh/id_rsa.     <== 私钥\nYour public key has been saved in /home/lishouxian/.ssh/id_rsa.pub.     <== 公钥\nThe key fingerprint is:\nSHA256:1Qj14JZLLGhekIjSY7rsCBoDAQ4QeoMvVKN4jxqzzrQ lishouxian@lishouxian\nThe key's randomart image is:\n+---[RSA 2048]----+\n|Bo + .....o      |\n|B.B o .o + *     |\n|+O+.  o o O o    |\n|++ + o . = .     |\n|*.o . . S .      |\n|=B               |\n|B+               |\n|*..              |\n| E               |\n+----[SHA256]-----+\n\n用自己的用户账号切换到自己用户名的.ssh目录下安装公钥cat id_rsa.pub >> authorized_keys，并执行chmod 600 authorized_keys获得权限。\n打开配置文件vim /etc/ssh/sshd_config，设置RSAAuthentication和PubkeyAuthentication两个字段为yes。\n把私钥id_rsa拷贝到本地，在服务器上执行/etc/init.d/ssh restart重启SSH服务，这个时候在本地就可以打开Xshell用用户名和密钥登陆服务器了，因为我们没有设置密钥密码，所以登陆时可以不用输入图4红框中的密码。\n\n\npython中的paramiko使用\n服务器的登陆\n  服务器登录可通过用户名+密码和用户名+密钥免密登陆，下面代码会给出这两种登陆方式对应的代码：\n# -*- coding: utf-8 -*-\nimport paramiko\nimport os\nimport time\nimport re\nimport sys\n\nreload(sys)\nsys.setdefaultencoding('utf-8')\n\nlogin_config = {\n    \"hostip\": \"\",                 # 服务器的ip（需要填写）\n    \"hostport\": 22,               # 端口号\n    \"username\": \"lishouxian\",     # 登陆的用户名\n    \"userpwd\": \"\",                # 登陆密码（需要填写）\n    \"rootusr\": \"root\",            # root 用户\n    \"rootpwd\": \"root\",            # root 密码\n    # 私钥，将配置好的id_rsa文件放在项目目录下\n    \"keypath\": os.path.join(os.path.dirname(os.path.abspath(__file__)), \"id_rsa\"),\n}\n\n\n# 通过密钥登陆服务器\ndef login_server_by_rsa():\n    try:\n        server_ssh = paramiko.SSHClient()\n        server_ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n        pkey = paramiko.RSAKey.from_private_key_file(login_config[\"keypath\"])\n        server_ssh.connect(hostname=login_config[\"hostip\"],\n                           port=login_config[\"hostport\"],\n                           username=login_config[\"username\"],\n                           pkey=pkey)\n        return server_ssh\n    except Exception, e:\n        print e\n\n\n# 通过密码登陆服务器\ndef login_server_by_pwd():\n    try:\n        server_ssh = paramiko.SSHClient()\n        server_ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n        server_ssh.connect(hostname=login_config[\"hostip\"],\n                           port=login_config[\"hostport\"],\n                           username=login_config[\"username\"],\n                           password=login_config[\"userpwd\"])\n        return server_ssh\n    except Exception, e:\n        print e\n  登陆服务器之后可以操作查看时间、查看文件之类的操作。\n获得root权限\n  因为我们以用户名登陆，修改其他用户名下的文件、修改时间、上传或者删除文件这些需要root权限，获得root权限的代码如下，这种交互方式像在一问一答，代码运行结果如图5，代码送指令并获得反馈，每当执行下一步操作都需要一个状态进行判断while not buff.endswith('Password: ')语句用来判断是否到了服务器问代码要密码的阶段。\n# 获得root权限\ndef authenticating_channel(login_ssh):\n    channel = login_ssh.invoke_shell()\n    try:\n        print '............Authenticating............'\n        channel.send(\"su %s\\n\" % login_config[\"rootusr\"])\n        buff = ''\n        while not buff.endswith('Password: '):\n            resp = channel.recv(10000)\n            buff += resp\n        print buff\n        channel.send(\"%s\\n\" % login_config[\"rootpwd\"])\n        buff = ''\n        while not buff.endswith('# '):\n            resp = channel.recv(10000)\n            buff += resp\n        print buff\n    except Exception, e:\n        print e\n        channel.close()\n        login_ssh.close()\n    return channel\n\n网站中用到的一些操作\n  这些操作基本上都是利用代码向服务器发送Linux命令，然后获得结果。\n\n获得服务器时间，用到的Linux命令：date +%Y-%m-%d\\ %H:%M:%S。\n# 获取服务器时间\ndef get_server_time():\n    ssh = login_server_by_pwd()\n    stdin, stdout, stderr = ssh.exec_command('date +%Y-%m-%d\\ %H:%M:%S')\n    servertime = stdout.read()\n    ssh.close()\n    return servertime\n\n\nprint get_server_time()\n\n修改服务器时间，需要权限，用到的Linux命令：date +%Y-%m-%d\\ %H:%M:%S，结果如图6所示。\n# 重置服务器时间\ndef restore_server_time():\n    local_time = time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime())\n    modify_server_time(local_time)\n\n\n# 修改服务器时间\ndef modify_server_time(newtime):\n    ssh = login_server_by_pwd()\n    channel = authenticating_channel(ssh)\n    print '............Sending ModifyTime Commander............'\n    channel.send(\"sudo date -s \\\"%s\\\" \\n\" % newtime)\n    buff = ''\n    while not buff.endswith('# '):\n        resp = channel.recv(10000)\n        buff += resp\n    print buff.decode('utf-8')\n    ssh.close()\n\n\nmodify_server_time('2018-08-08 08:08:08')\n# restore_server_time()\n\n\n获得配置文件，一般情况下服务器的配置文件会写在某个文件夹里面，例子中的配置文件皆为json格式的文件，不同类型的配置文件会用不同的子文件夹装着，考虑到这种情况，可以把 Linux命令写复杂点，但是这样不利于程序的扩展。ls -lR遍历文件夹下的所有的文件（包含子文件夹），grep ^-只显示文件名，不显示文件夹的名字，awk \\'{ print $9 }\\'用来获取这些配置文件的名字（\\'为转义字符），图7是服务器的所有配置文件，图8是程序返回的配置名列表。\n# 获取文件配置\ndef get_serverconfig_lists():\n    ssh = login_server_by_pwd()\n    # execute command\n    stdin, stdout, stderr = ssh.exec_command(\n        'ls -lR /home/configs/ |  grep ^- | awk \\'{ print $9 }\\'')\n    file_list = stdout.read().split(\"\\n\")[:-1]\n    return file_list\n\n\nprint get_serverconfig_lists()\n\n\n查看配置文件，find \\\"$PWD\\\" -name XXX在本目录和子目录下查找XXX的文件（\\\"为转义字符），| xargs cat将上一个命令的结果作为下一个指令的参数，这里的意思是将找到的文件名作为cat的参数，结果就是打开这个文件，结果如图9。\n#读取配置配置\ndef read_serverconfig(filename):\n    ssh = login_server_by_rsa()\n    # execute command\n    try:\n        stdin, stdout, stderr = ssh.exec_command(\n            'cd /home/configs/; find \\\"$PWD\\\" -name ' + filename + ' | xargs cat')\n        read = stdout.read().decode('utf-8')\n        return read\n    except Exception, e:\n        print e\n\n\nprint read_serverconfig('setting_1.json')\n\n\n修改配置文件，我们采用了一个最简单的修改文件方法，直接覆盖原来的文件，所以在本地产生一个文件，输入文件内容（是否符合json文件格式在后面利用javascript在前端页面做了）然后利用paramiko中的sftp模块上传。由于修改文件需要权限，所以有个折衷的办法是：先把文件上传到自己的服务器文件夹下，然后在服务器获得root权限，把自己服务器文件夹下的文件覆盖掉配置文件夹中的同名文件。\n# 修改配置文件\ndef generate_config_upload_file(filename, json_str):\n    local_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), filename).replace('\\\\', '/')\n    # 登陆服务器\n    ssh = login_server_by_rsa()\n    # 获得配置文件所在的位置\n    stdin, stdout, stderr = ssh.exec_command('cd /home/configs/; find \\\"$PWD\\\" -name ' + filename)\n    to_path = stdout.read()\n    # 本地产生一个json文件的配置\n    with open(local_path, 'w') as config_file:\n        config_file.write(json_str)\n    # 上传配置文件\n    my_server_path = \"/home/lishouxian/\" + filename\n    try:\n        transport = ssh.get_transport()\n        sftp = paramiko.SFTPClient.from_transport(transport)\n        sftp.put(local_path, my_server_path)\n        os.remove(local_path)\n    except Exception, e:\n        print e\n        ssh.close()\n        os.remove(local_path)\n        return 'Unsuccessful Upload'\n    sftp.close()\n    # 将文件从自己的项目文件夹转移到配置文件夹下\n    channel = authenticating_channel(ssh)\n    print '............Sending Upload Commander............'\n    channel.send(\"cp /home/lishouxian/\" + filename + \" \" + to_path + \"\\n\")\n    buff = ''\n    while not buff.endswith('# '):\n        resp = channel.recv(10000)\n        buff += resp\n    print buff\n    ssh.close()\n    return 'Successful Upload'\n\n\njson_config = '{\"name\": \"data_3\", \"id\": \"2\"}'\nprint generate_config_upload_file('data_3.json', json_config)\n\n删除配置文件，Linux命令解释如上面的读取配置。\n# 删除配置文件\ndef delete_config(filename):\n    ssh = login_server_by_rsa()\n    # delete config\n    channel = authenticating_channel(ssh)\n    try:\n        print '............Sending Delete Commander............'\n        channel.send('cd /home/configs/; find \\\"$PWD\\\" -name ' + filename + ' | xargs rm \\n')\n        buff = ''\n        while not buff.endswith('# '):\n            resp = channel.recv(10000)\n            buff += resp\n        print buff\n    except e:\n        print e\n        ssh.close()\n    ssh.close()\n    return 'Successful Delete'\n\n\nprint delete_config('config_4.json')\n\n调用shell脚本，为了演示，重启进程这个服务器的操作我们用自己的写的shell脚本替代，shell脚本会延时一分钟然后输出结果，最后演变成利用paramiko执行用户自定义的Linux脚本过程，我们在服务器的/home/目录下创建一个shell脚本：\n#!/bin/sh\necho 'Rebooting...'\nsleep 10\necho 'Suceessful rebooted!'\n  在代码中调用shell代码如下：\n# 重启某个进程，调用shell脚本\ndef rebootserver():\n    ssh = login_server_by_rsa()\n    channel = authenticating_channel(ssh)\n    # reboot game server\n    print '............Sending Reboot Commander............'\n    channel.send(\"bash /home/reboot.sh restart; echo \\\"quit:$?\\\" \\n\")\n    resp = ''\n    while not resp.endswith('# '):\n        resp = channel.recv(10000)\n        print resp\n        quit_num = re.findall(\"quit:(\\d+)\", resp, re.M)\n        if len(quit_num) > 0:\n            if quit_num[0] == '0':\n                ssh.close()\n                return \"Successful Rebooted!\"\n            else:\n                ssh.close()\n                return \"Unsuccessful Rebooted!\"\n    ssh.close()\n\n\nprint rebootserver()\n结语\n  本篇文章介绍了如何在服务器上搭建一个支持客户端免密和使用密码登陆的ssh服务，然后利用python中的paramiko模块登陆服务器，后面的网站都是基于paramiko和服务器进行交互。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "1"}