{"title": "python学习笔记-python的调试 - helloword ", "index": "python", "content": "我们在写代码的时候，往往会有一大堆错误。我们该如何调试呢？\n用print语句打印\n我们可以用print语句打印我们想要的内容，然后在输出中查看。\nprint \"hah\"\n但是在调试之后，我们还需要手动删除print语句，比较麻烦。\nassert\n前面用print的地方，我们可以使用assert语句来替代。例如：\ndef foo(s):\n    s = int(s)\n    assert s != 0, \"s is Zero\"\n    return 10.0 / s\n\nfoo('0')\nassert语句后紧跟着一句判断语句，再更着错误信息。如果判断语句不符合，则抛出一个AssertionError.例如：\nTraceback (most recent call last):\n  File \"/Users/W/Code/Python/Demo/AssertDemo.py\", line 7, in <module>\n    foo('0')\n  File \"/Users/W/Code/Python/Demo/AssertDemo.py\", line 3, in foo\n    assert s != 0, \"s is Zero\"\nAssertionError: s is Zero\n我们可以在执行的时候带上参数-o统一关闭assert。关闭后，assert语句就不再生效。\nlogging\n可以将print语句替换成logging。logging不会像assert那样抛出错误信息。logging的好处有很多，一个是可以制定输出特定级别的信息。\nLevel:  CRITICAL Numeric value: 50 \nLevel:  ERROR     Numeric value: 40\nLevel:  WARNING Numeric value: 30 \nLevel:  INFO          Numeric value: 20\nLevel:  DEBUG      Numeric value: 10\nLevel:  NOTSET    Numeric value: 0\n我们可以用\nlogging.basicConfig(level=logging.DEBUG)\n对logging进行简单的配置。小于该level的warning都会被忽略。另外我们也可以对logging输出的位置进行配置，例如是输出到console还是到某一个debug文件。关于更多logging的配置，可以阅读：https://segmentfault.com/a/11...。\n调试器 pdb，the python debugger\npdb的启动方式为\npython -m pdb test.py\npdb常用的命令\nn: 即next，用于执行下一步\nl: 应该是list，查看下面要执行的代码\np 变量名: p应该是parameter的首字母，查看某一个变量的值\nq: quit, 退出程序\npdb可以控制python的一步一步执行，理论上是万能的debugger。但是在处理很长的代码的时候，显得效率低下。分析一下我们的需求，我们其实是需要在一些关键的点设置一下断点，让我们看一下执行的结果即可，而不是像前面那样查看每一步。接下来我们就来看一下pdb.set_trace().\npdb.set_trace()\n我们只需要在让程序暂停的地方写一行代码：\npdb.set_trace()\nPython编辑器在遇到pdb.set_trace()时候，程序就会暂停，我们就可以用上面提到的pdb命令来查看各个参数的值了。\n当然，很多现代化的IDE比如Pycharm等都提供了很多方便的可视化的debug工具，可以很方便的上手。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "3"}