{"title": "流畅的python读书笔记-第八章-对象引用、可变性和垃圾回收 - 个人文章 ", "index": "python", "content": "对象不是个盒子\n\nclass Gizmo:\n    def __init__(self):\n        print('Gizmo id: %d' % id(self))\n\nx = Gizmo()\nprint(x)\n\ny = Gizmo() * 10\nprint(y)\n\nprint(dir())\n❶ 输出的 Gizmo id: ... 是创建 Gizmo 实例的副作用。❷ 在乘法运算中使用 Gizmo 实例会抛出异常。❸ 这里表明，在尝试求积之前其实会创建一个新的 Gizmo 实例。❹ 但是，肯定不会创建变量 y，因为在对赋值语句的右边进行求值时抛出了异常。\n　为了理解 Python 中的赋值语句，应该始终先读右边。对象在右边创建或获取，在此之后左边的变量才会绑定到对象上，\n标识、相等性和别名\nlonge = {'name': 'longe', 'born': 1993}\nliang = longe\nprint(liang is longe)\n\nprint(id(liang), id(longe))\n\nlonge['balance'] = 950\n\nprint(liang)\n\n## 冒充的longe信息\n\nother  = {'name': 'longe', 'born': 1993, 'balance': 950}\nprint(other)\n\nprint(other is longe)\n\n❶ liang 是 longe 的别名。❷ is 运算符和 id 函数确认了这一点。❸ 向 liang 中添加一个元素相当于向 longe 中添加一个元素。\n\n在那段代码中，liang 和 longe 是别名，即两个变量绑定同一个对象。而 other 不是 longe 的别名，因为二者绑定的是不同的对象。\nother 和longe 绑定的对象具有相同的值（== 比较的就是值），但是它们的标识不同。\n\n\n每个变量都有标识、类型和值。对象一旦创建，它的标识绝不会变；\n你可以把标识理解为对象在内存中的地址。\nis 运算符比较两个对象的标识；\nid() 函数返回对象标识的整数表示。\n\n在==和is之间选择\n== 运算符比较两个对象的值（对象中保存的数据），而 is 比较对象的标识。\n\nis 运算符比 == 速度快，因为它不能重载，所以 Python 不用寻找并调用特殊方法，而是 直接比较两个整数 ID\n\neq 方法，会考虑对象属性的值。相等性测试可能涉及大量处理工作，例如，比较大型集合或嵌套层级深的结构时。\n\n元组的相对不可变性\n元组的不可变性其实是指 tuple 数据结构的物理内容（即保存的引用）不可变，与引用的对象无关\n\n元组的值会随着引用的可变对象的变化而变。\n元组中不可变的是元素的标识。内存地址\n\n>>> t1 = (1, 2, [30, 40]) ➊\n>>> t2 = (1, 2, [30, 40]) ➋\n>>> t1 == t2 ➌\nTrue\n>>> id(t1[-1]) ➍\n4302515784\n>>> t1[-1].append(99) ➎\n>>> t1\n(1, 2, [30, 40, 99])\n>>> id(t1[-1]) ➏\n4302515784\n>>> t1 == t2 ➐\nFalse\n基础理解!!!还是可以的\n默认浅复制\n>>> l1 = [3, [55, 44], (7, 8, 9)]\n>>> l2 = list(l1) ➊\n>>> l2\n[3, [55, 44], (7, 8, 9)]\n>>> l2 == l1 ➋\nTrue\n>>> l2 is l1 ➌\nFalse\n然而，构造方法或 [:] 做的是浅复制（即复制了最外层容器，副本中的元素是源容器中元素的引用）。如果所有元素都是不可变的，那么这样没有问题，还能节省内存。\n为任意对象做深复制和浅复制\nimport copy\nclass Bus:\n    def __init__(self, passengers=None):\n        if passengers is None:\n            self.passengers = []\n        else:\n            self.passengers = list(passengers)\n\n    def pick(self, name):\n        self.passengers.append(name)\n\n    def drop(self, name):\n        self.passengers.remove(name)\n\n\nbus1 = Bus(['Alice', 'Bill', 'Claire', 'David'])\nbus2 = copy.copy(bus1)\nbus3 = copy.deepcopy(bus1)\n\nprint(id(bus1), id(bus2), id(bus3))\n\nbus1.drop('Bill')\nprint(bus2.passengers)\n\nprint(id(bus1.passengers), id(bus2.passengers), id(bus3.passengers))\n\nprint(bus3.passengers)\n\n❸ 审查 passengers 属性后发现，bus1 和 bus2 共享同一个列表对象，因为 bus2 是bus1 的浅复制副本。❹ bus3 是 bus1 的深复制副本，因此它的 passengers 属性指代另一个列表。\n注意，一般来说，深复制不是件简单的事。如果对象有循环引用，那么这个朴素的算法会进入无限循环\n深复制\n>>> a = [10, 20]\n>>> b = [a, 30]\n>>> a.append(b)\n>>> a\n[10, 20, [[...], 30]]\n>>> from copy import deepcopy\n>>> c = deepcopy(a)\n>>> c\n[10, 20, [[...], 30]]\n深复制有时可能太深了。例如，对象可能会引用不该复制的外部资源或单例值。我们可以实现特殊方法 __copy__() 和 __deepcopy__()，控制 copy 和 deepcopy 的行为\n函数的参数作为引用时\n共享传参指函数的各个形式参数获得实参中各个引用的副本。也就是说，函数内部的形参是实参的别名。\ndef f(a, b):\n    a += b\n    return a\n\n\na = [1, 2]\nb = [3, 4]\n\nprint(f(a, b))\nprint(a, b)\n\n这里变量全都是引用,无论局部变量还是全局.所以上面案例中,a会变化\n不要使用可变类型作为参数的默认值\nclass HauntedBus:\n    \"\"\"备受幽灵乘客折磨的校车\"\"\"\n    def __init__(self, passengers=[]):  #别使用这种可变类型 作为默认参数\n        self.passengers = passengers \n防御性编程(对待可变类型)\nclass TwilightBus:\n    \"\"\"正常的校车\"\"\"\n\n    def __init__(self, passengers=None):\n\n        if passengers is None:\n            self.passengers = []\n        else:\n            self.passengers = list(passengers) ##这里会产生副本(可以理解为深拷贝)\n\n    def pick(self, name):\n        self.passengers.append(name)\n\n    def drop(self, name):\n        self.passengers.remove(name)\n\n\nbus1 = TwilightBus((\"sfs\", 'sdf'))\nbus2 = TwilightBus([\"sdfsdfsfd111\"])\n\nbus1.pick(\"ppxia\")\nbus1.drop(\"sfs\")\nprint(bus1.passengers)\n\nbus2.drop(\"sdfsdfsfd111\")\nprint(bus2.passengers)\n\nhttp://www.pythontutor.com/vi...\n尽量别用可变类型做默认参数值, 实在要用,必须使其产生副本\ndel和垃圾回收\n\n有个 del 特殊方法，但是它不会销毁实例，不应该在代码中调用。\n即将销毁实例时，Python 解释器会调用 del 方法，给实例最后的机会，释放外资源。\n自己编写的代码很少需要实现 del 代码，有些 Python 新手会花时间实现，但却吃力不讨好，因为 del 很难用对。\n\n垃圾计数器\n\n在 CPython 中，垃圾回收使用的主要算法是引用计数。\n实际上，每个对象都会统计有多少引用指向自己。\n当引用计数归零时，对象立即就被销毁：CPython 会在对象上调用__del__ 方法（如果定义了），然后释放分配给对象的内存。\n\n为了演示对象生命结束时的情形，示例 8-16 使用 weakref.finalize 注册一个回调函数，在销毁对象时调用。\n>>> import weakref\n>>> s1 = {1, 2, 3}\n>>> s2 = s1 ➊\n>>> def bye(): ➋\n... print('Gone with the wind...')\n...\n>>> ender = weakref.finalize(s1, bye) ➌\n>>> ender.alive ➍\nTrue\n>>> del s1\n>>> ender.alive ➎\nTrue\n>>> s2 = 'spam' ➏\nGone with the wind...\n>>> ender.alive\nFalse\n❺ 如前所述，del 不删除对象，而是删除对象的引用。❻ 重新绑定最后一个引用 s2，让 {1, 2, 3} 无法获取。对象被销毁了，调用了 bye 回调，ender.alive 的值变成了 False。\n　弱引用\n\n正是因为有引用，对象才会在内存中存在。当对象的引用数量归零后，垃圾回收程序会把对象销毁。但是，有时需要引用对象，而不让对象存在的时间超过所需时间。\n弱引用不会增加对象的引用数量。引用的目标对象称为所指对象（referent）。因此我们说，弱引用不会妨碍所指对象被当作垃圾回收。\n弱引用在缓存应用中很有用，因为我们不想仅因为被缓存引用着而始终保存缓存对象。\n\n弱引用是可调用的对象，返回的是被引用的对象；\n>>> import weakref\n>>> a_set = {0, 1}\n>>> wref = weakref.ref(a_set) ➊\n>>> wref\n<weakref at 0x100637598; to 'set' at 0x100636748>\n>>> wref() ➋\n{0, 1}\n>>> a_set = {2, 3, 4} ➌\n>>> wref() ➍\n{0, 1}\n>>> wref() is None ➎\nFalse\n>>> wref() is None ➏\nTrue\n❷ 调用 wref() 返回的是被引用的对象，{0, 1}。因为这是控制台会话，所以 {0, 1}会绑定给 _ 变量。❸ a_set 不再指代 {0, 1} 集合，因此集合的引用数量减少了。但是 _ 变量仍然指代它。❹ 调用 wref() 依旧返回 {0, 1}。❺ 计算这个表达式时，{0, 1} 存在，因此 wref() 不是 None。但是，随后 _ 绑定到结果值 False。现在 {0, 1} 没有强引用了。❻ 因为 {0, 1} 对象不存在了，所以 wref() 返回 None。\n弱引用到此为止,用到再来查 page 289\n总结\n\n变量的不是盒子,是便利贴(就是c的指针)\n==是值相等 is是(内存地址相等)\n默认是浅复制,就内存地址复制.深复制会有一些过深危险(可以重写特殊方法 __copy__() 和 __deepcopy__())\n尽量别用可变类型做默认参数值, 实在要用,必须使其产生副本\n实际上，每个对象都会统计有多少引用指向自己。 Cpython中, 当引用计数归零时，对象立即就被销毁：CPython会在对象上调用__del__ 方法（如果定义了），然后释放分配给对象的内存\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}