{"title": "Python装饰器探究——装饰器参数 - Python提高班 ", "index": "python", "content": "探究装饰器参数\n\n编写传参的装饰器\n\n通常我们见到的简单装饰器这样的：\nimport json\nimport functools\n\ndef json_output(func):\n    @functools.wraps(decorated)\n    def inner(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return json.dumps(result)\n    return inner\n\n@json_output\ndef f():\n    return {'status': 'done'}\n\n当装饰器应用于函数 f 上时，它接受 f 作为其参数，返回一个函数 inner ，且将他绑定到变量f上。\n示例中我们编写的装饰器 json_output 只接受一个隐式参数——即被装饰的方法，在使用此装饰器时本身看上去是并没有参数的。然而有时候需要让装饰器自身带有一些需要的信息，从而使装饰器可以使用恰当的方式装饰方法。比如上面的例子中，我们想通过向装饰器传入不同的参数来控制输出结果的缩进(indent)和排序(sort)。我们可以这么做:\nimport json\nimport functools\n\ndef json_output(indent=None, sort_keys=False):\n    def actual_decorator(func):\n        @functools.wraps(func)\n        def inner(*args, **kwargs):\n            result = func(*args, **kwargs)\n            return json.dumps(result, indent=indent, sort_keys=sort_keys)\n        return inner\n    return actual_decorator\n\n@json_output(indent=4)\ndef f():\n    return {'status': 'done'}\n\n理解传参的装饰器\n\n初次看起来会觉得比较绕人，因为函数里嵌套了两个函数定义，然而实际上和之前一个版本的区别在于为了接收json序列化的参数多包装了一层，所以\n@json_output(indent=4)\ndef f():\n    return {'status': 'done'}\n\n# 相当于\n@actual_decorator\ndef f():\n    return {'status': 'done'}\n\n这样看起来就会明晰很多。\n实际上, 装饰器里的 @ 后接收一个函数，该函数以被装饰的函数(例子中是f)为参数，并且返回一个函数。当需要在装饰函数的同时传入参数的话，那么就需要多包装一层，先传入参数(例子中是 indent=4 )返回一个装饰的函数(例子中是 actual_decorator ), 这个返回的的函数 就跟以前一样接受被装饰的函数(f)作为参数并且返回一个函数作为装饰最后的方法供调用。\n传参和不传参的兼容\n\n然而当我们像上面那样定义装饰器时，就不能这样调用:\nimport json\nimport functools\n\ndef json_output(indent=None, sort_keys=False):\n    def actual_decorator(func):\n        @functools.wraps(func)\n        def inner(*args, **kwargs):\n            result = func(*args, **kwargs)\n            return json.dumps(result, indent=indent, sort_keys=sort_keys)\n        return inner\n    return actual_decorator\n\n@json_output\ndef f():\n    return {'status': 'done'}\n\n在实际的项目过程中，有时会出现这样的状况: 一开始写的装饰器时不需要使用时传参数的，后来发现有必要传参数，改好后原来不传参的装饰器不能正常使用了，这是修改原来使用的地方是项痛苦的事情。这时候就需要对装饰器做一个兼容，使它在以下情况都可用:\n@json_output\n@json_output()\n@json_output(indent=4)\n\n具体做法如下:\nimport json\nimport functools\n\ndef json_output(decorated_=None, indent=None, sort_keys=False):\n    if decorated_ and (indent or sort_keys):\n        raise\n\n    def actual_decorator(func):\n        @functools.wraps(func)\n        def inner(*args, **kwargs):\n            result = func(*args, **kwargs)\n            return json.dumps(result, indent=indent, sort_keys=sort_keys)\n        return inner\n    if decorated_:\n        return actual_decorator(decorated_)\n    else:\n        return actual_decorator\n\n\n@json_output(indent=4)\ndef f1():\n    return {'status': 'done'}\n\n@json_output\ndef f2():\n    return {'status': 'done'}\n\n@json_output()\ndef f3():\n    return {'status': 'done'}\n\nprint f1()\nprint f2()\nprint f3()\n\n代码中关键的地方在于 json_output 在最后对参数 decorated 进行了判断，有的话证明是不传参调用，那么直接返回 actual_decorator 的调用；没有的话则代表是传参类型的调用（虽然参数可能不存在），那么返回 actual_decorator 。其中有点需要注意， josn_output 的传参需要使用关键字参数，如果像下面这样直接传一个位置参数，那么根据现在的实现会出现错误（因为它会被当成 decorated_ ）。\n@json_output(4)  #错误的使用方法\ndef f4():\n    return {'status': 'done'}\n\n参考资料\n\n《Python高级编程》 by Luke Sneeriger\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "4"}