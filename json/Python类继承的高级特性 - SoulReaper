{"title": "Python类继承的高级特性 - SoulReaper ", "index": "python", "content": "昨天在Python类的多重继承那里纠结了好久,在提问版块提了个问题探讨了探讨(链接)才完全搞明白,现在把类的特性整理下,供以后参考\n\n正文\n\n首先得说明的是,Python的类分为经典类 和 新式类\n经典类是python2.2之前的东西,但是在2.7还在兼容,但是在3之后的版本就只承认新式类了\n新式类在python2.2之后的版本中都可以使用\n\n经典类和新式类的区别在于:\n\n\n经典类是默认没有派生自某个基类的,而新式类是默认派生自object这个基类的:\n\n# old style\nclass A():pass\n\n# new style\nclass A(obejct):pass\n\n\n2.经典类在类多重继承的时候是采用从左到右深度优先原则匹配方法的..而新式类是采用C3算法(不同于广度优先)进行匹配的\n\n3.经典类是没有__MRO__和instance.mro()调用的,而新式类是有的.\n\n为什么不用经典类，要更换到新式类\n\n因为在经典类中的多重继承会有些问题...可能导致在继承树中的方法查询绕过后面的父类:\n\nclass A():\n    def foo1(self):\n        print \"A\"\nclass B(A):\n    def foo2(self):\n        pass\nclass C(A):\n    def foo1(self):\n        print \"C\"\nclass D(B, C):\n    pass\n\nd = D()\nd.foo1()\n\n\n按照经典类的查找顺序从左到右深度优先的规则，在访问d.foo1()的时候,D这个类是没有的..那么往上查找,先找到B,里面没有,深度优先,访问A,找到了foo1(),所以这时候调用的是A的foo1()，从而导致C重写的foo1()被绕过.\n\n所以python引入了新式类的概念,每个基类都继承自object并且,他的匹配规则也从深度优先换到了C3\n\n\nC3算法\n\nC3算法是怎么做匹配的呢..在问答版块上面讨论之后,归结如下:\n\nC3算法的一个核心是merge.\n\n\n  在merge列表中，如果第一个序列mro的第一个类是出现在其它序列，并且也是第一个，或者不出现其它序列，那么这个类就会从这些序列中删除，并合到访问顺序列表中\n\n\n比如:(引用问题中zhuangzebo的回答@zhuangzebo)\n\nclass A(O):pass\nclass B(O):pass\nclass C(O):pass\nclass D(A,B):pass\nclass E(C,D):pass\n\n\n首先需要知道 O(object)的mro(method resolution order)列表是[O,]\n那么接下来是:\n\nmro(A) = [A, O]\nmro(B) = [B, O]\nmro(C) = [C, O]\nmro(D) = [D] + merge(mro(A), mro(B), [A, B])\n= [D] + merge([A, O], [B, O], [A, B])\n= [D, A] + merge([O], [B, O], [B])\n= [D, A, B] + merge([O], [O])\n= [D, A, B, O]\nmro(E) = [E] + merge(mro(C), mro(D), [C, D])\n= [E] + merge([C, O], [D, A, B, O], [C, D])\n= [E, C] + merge([O], [D, A, B, O], [D])\n= [E, C, D] + merge([O], [A, B, O])\n= [E, C, D, A, B] + merge([O], [O])\n= [E, C, D, A, B, O]\n\n\n然后还有一种特殊情况:\n比如：merge(DO,CO,C) 先merge的是Dmerge(DO,CO,C) 先merge的是C\n意思就是.当出现有 一个类出现在两个序列的头(比如C) 这种情况和 这个类只有在一个序列的头(比如D) 这种情况同时出现的时候,按照顺序方式匹配。\n\n新式类生成的访问序列被存储在一个叫MRO的只读列表中..\n你可以使用instance.__MRO__或者instance.mro()来访问\n\n最后匹配的时候就按照MRO序列的顺序去匹配了\n\nC3和广度优先的区别:\n\n举个例子就完全明白了:\n\nclass A(object):pass\nclass B(A):pass\nclass C(B):pass\nclass D(A):pass\nclass E(D):pass\nclass F(C, E):pass\n\n\n按照广度优先遍历,F的MRO序列应该是[F,C,E,B,D,A]\n但是C3是[F,E,D,C,B,A]\n意思是你可以当做C3是在一条链路上深度遍历到和另外一条链路的交叉点,然后去深度遍历另外一条链路,最后遍历交叉点\n\n新式类和经典类的super和按类名访问问题\n\n在经典类中,你如果要访问父类的话,是用类名来访问的..\n\nclass A():\n    def __init__(self):\n        print \"A\"\nclass B(A):\n    def __init__(self):\n        print \"B\"\n        A.__init__(self)  #python不会默认调用父类的初始化函数的\n\n\n这样子看起来没三问题,但是如果类的继承结构比较复杂，会导致代码的可维护性很差..\n所以新式类推出了super这个东西...\n\nclass A():\n    def __init__(self):\n        print \"A\"\nclass B(A):\n    def __init__(self):\n        print \"B\"\n        super(B,self).__init__()\n\n\n这时候，又有一个问题:当类是多重继承的时候,super访问的是哪一个类呢?\nsuper实际上是通过__MRO__序列来确定访问哪一个类的...实际上就是调用__MRO__中此类后面的一个类的方法.\n比如序列为[F,E,D,C,B,A]那么F中的super就是E,E的就是D\n\n\nsuper和按照类名访问 混合使用带来的坑\n\nclass A(object):\n  def __init__(self):\n   print \"enter A\"\n   print \"leave A\"\n\n class B(object):\n  def __init__(self):\n   print \"enter B\"\n   print \"leave B\"\n\n class C(A):\n  def __init__(self):\n   print \"enter C\"\n   super(C, self).__init__()\n   print \"leave C\"\n\n class D(A):\n  def __init__(self):\n   print \"enter D\"\n   super(D, self).__init__()\n   print \"leave D\"\n class E(B, C):\n  def __init__(self):\n   print \"enter E\"\n   B.__init__(self)\n   C.__init__(self)\n   print \"leave E\"\n\n class F(E, D):\n  def __init__(self):\n   print \"enter F\"\n   E.__init__(self)\n   D.__init__(self)\n   print \"leave F\"\n\n\n这时候打印出来是：\n\n enter F\n enter E\n enter B\n leave B\n enter C\n enter D\n enter A\n leave A\n leave D\n leave C\n leave E\n enter D\n enter A\n leave A\n leave D\n leave F\n\n\n可以看出来D和A的初始化函数被乱入了两次！按类名访问就相当于C语言之前的GOTO语句...乱跳,然后再用super按顺序访问..就有问题了\n\n所以建议就是要么一直用super,要么一直用按照类名访问\n\n最佳实现:\n\n\n避免多重继承\nsuper使用一致\n不要混用经典类和新式类\n调用父类的时候注意检查类层次\n\n参考资料：\n\n\n《python高级编程》\nhttp://www.cnblogs.com/lovemo1314/archive/2011/05/03/2035005.html\nhttp://www.cnblogs.com/i2u9/archive/2013/03/19/pythonmroc3.html\n\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "35"}