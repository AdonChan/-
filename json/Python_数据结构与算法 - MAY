{"title": "Python_数据结构与算法 - MAY ", "index": "python,算法", "content": "数据结构和算法基础\n什么是数据结构和算法：兵法，计算的方法。算法是独立存在的一种解决问题的方法和思想。\n算法的特征：\n\n输入：算法具有0个或多个输入\n输出：算法至少有1个或多个输出\n有穷性：算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成\n确定性：算法中的每一步都有确定的含义，不会出现二义性\n可行性：算法的每一步都是可行的，也就是说每一步都能执行有限的次数完成\n\n时间复杂度和大O表示法\n算法的优劣： 实现算法程序的执行时间可以反应出算法的效率\n时间复杂度：步骤的执行速度(基本执行数量总和) + 程序运行环境（包括硬件和操作系统）\n假设存在函数g，使得算法A处理规模为n的问题示例所用时间为T(n)=O(g(n))，则称O(g(n))为算法A的渐近时间复杂度，简称时间复杂度，记为T(n)T: time三个1000次for循环: T = 1000 * 1000 * 1000 * 2 -> T(n) = n ^ 3 * 2 -> g(n) = n ^ 3, T(n) = k * g(n) -> T(n) = O(g(n))\n“大O记法”：对于单调的整数函数f，如果存在一个整数函数g和实常数c>0，使得对于充分大的n总有f(n) <= c*g(n)，就说函数g是f的一个渐近函数（忽略常数），记为f(n)=O(g(n))。也就是说，在趋向无穷的极限意义下，函数f的增长速度受到函数g的约束，亦即函数f与函数g的特征相似。\n最坏时间复杂度\n\n算法完成工作最少需要多少基本操作，即最优时间复杂度\n\n算法完成工作最多需要多少基本操作，即最坏时间复杂度\n\n算法完成工作平均需要多少基本操作，即平均时间复杂度\n\n\n最优时间复杂度，其价值不大。最坏时间复杂度，提供了一种保证，（只要关注，最坏时间复杂度）平均时间复杂度，是对算法的一个全面评价。\n时间复杂度的几条基本计算规则\n\n基本步骤，即只有常数项，认为其时间复杂度为O(1)\n\n顺序结构，时间复杂度按加法进行计算\n循环结构，时间复杂度按乘法进行计算\n分支结构，时间复杂度取最大值（if 或者 else 哪个步数最多）\n判断一个算法的效率时，往往只需要关注操作数量的最高次项，其它次要项和常数项可以忽略\n在没有特殊说明时，所分析的算法的时间复杂度都是指最坏时间复杂度\n\n\n计算方式：\n# for a in range(0, n):\n#     for b in range(0, n):\n#         c = 1000 - a - b\n#         if a ** 2 + b ** 2 == c **2:\n#             print('a, b, c为：%d'%(a, b, c))\n\n\n# T(1000) = 1000 * 1000 * (1 + 1)\n# T(n) = n * n * (1 + max(1, 0))\n#  = n ^ 2 * 2\n#  = O(n ^ 2)\n常见时间复杂度与大小关系\n\n\n执行次数函数\n阶\n非正式术语\n\n\n\n12\nO(1)\n常数阶\n\n\n2n+3\nO(n)\n线性阶\n\n\n3n^2+2n+1\nO(n^2)\n平方阶\n\n\n5log2n+20\nO(logn)\n对数阶\n\n\n2n+3nlog2n+19\nO(nlogn)\nnlogn阶\n\n\n6n^3+2n^2+3n+4\nO(n^3)\n立方阶\n\n\n2n\nO(2n)\n指数阶\n\n\n\nNote: 经常将log2n（以2为底的对数）简写成logn\n\n所消耗的时间从小到大:O(1) < O(logn) < O(n) < O(nlogn) < O(n2) < O(n3) < O(2n) < O(n!) < O(n^n)\nNote：函数是步骤和执行结构的综合\nPython内置类型性能\ntimeit模块作用：测试一小段Python代码代码的执行速度\nclass timeit.Timer(stmt='pass', setup='pass', timer=<timer function>)Timer是测量小段代码执行速度的类。stmt参数是要测试的代码语句（statment）；setup参数是运行代码时需要的设置；timer参数是一个定时器函数，与平台有关。\n#coding=utf-8\n\nfrom timeit import Timer\n\n\ndef test1():\n    li = []\n    for i in range(10000):\n        li.append(i)\n\ndef test2():\n    li = []\n    for i in range(10000):\n        li += [i]\n\ndef test3():\n    li = [i for i in range(10000)]\n\ndef test4():\n    li = list(range(10000))\n\ntimer1 = Timer('test1()', 'from __main__ import test1')\nprint('append: ',timer1.timeit(1000)) # 测算次数, 返回值测算时间\n\ntimer2 = Timer('test2()', 'from __main__ import test2')\nprint('+: ',timer1.timeit(1000))\n\ntimer3 = Timer('test3()', 'from __main__ import test3')\nprint('[]: ',timer1.timeit(1000))\n\ntimer4 = Timer('test4()', 'from __main__ import test4')\nprint('list: ',timer1.timeit(1000))\nlist内置操作的时间复杂度:\n\nn: 列表长度k: 范围\n主要：\nindex[] -> O(1)\nappend -> O(1)\npop(i) -> O(n)\ninsert(i, item) -> O(n)\ncontains(in) -> O(n)\ndict内置操作的时间复杂度:\n\n数据结构引入\n算法关注在解决问题的步骤和思想上面。\n什么是数据结构：数据的组织结构方式,（一组数据如何存储），基本数据类型（int， float，char）的封装\n算法与数据结构的区别：数据结构只是静态的描述了数据元素之间的关系。高效的程序需要在数据结构的基础上设计和选择算法。\n程序 = 数据结构 + 算法\n总结：算法是为了解决实际问题而设计的，数据结构是算法需要处理的问题载体\n最常用的数据运算有五种:\n\n插入\n删除\n修改\n查找\n排序\n\n顺序表\n内存\n32位机器：一个int, 占四个字节。\n变量表示起始地址位置\n内存的基本信息：\n\n单位：字节， 1byte == 8bit\n\n连续的存储空间\n一个字节表示一个地址单元\n\n类型本质\n任何变量，函数原则上都是一块块大小各异的内存，而类型则是和系统对这块内存含义的约定（固定内存块大小的别名）\n决定在内存中占多少个单元\n基本顺序表与元素外围顺序表\n顺序表的基本布局：\n\n数据元素本身连续存储，每个元素所占的存储单元大小固定相同，元素的下标是其逻辑地址，而元素存储的物理地址（实际内存地址）可以通过存储区的起始地址Loc (e0)加上逻辑地址（第i个元素）与存储单元大小（c）的乘积计算而得\n所以，访问指定元素时无需从头遍历，通过计算便可获得对应地址，其时间复杂度为O(1)\n下标：地址单元的偏移量，才会规定为从0开始。\n\n顺序表的元素外置基本布局：\n元素外置在内存中存储地址，地址字节是相同的（可以使用顺序表），而非变化的字节。\n\n顺序表的一体式结构与分离式结构\n顺序表 = 数据区(元素集合) + 表头信息(容量 + 元素个数)\n容量: 在最初始的时候，就要预估当前规模，一次性向操作系统申请内存地址 （最大存储多少）元素个数：当前存储多少\n\n顺序表的基本实现方式（表头和数据区如何组合在一起）：\n\n一体式结构：优点: 一次性申请， 整体性强，易于管理。缺点：元素存储区就固定。当数据存储不下的时候，需要整体替换重新向操作系统申请\n分离式结构：优点：元素存储区不固定。 缺点：分二次申请，不易管理\n\n最大区别：分离式其实位置（表头）的地址不变，而一体式，需要整体替换（表头和数据区）都需要重新申请。\n\n顺序表数据区替换与扩充\n重新扩充的两种策略：\n\n每次扩充增加固定数目的存储位置，如每次扩充增加10个元素位置，这种策略可称为线性增长。特点：节省空间，但是扩充操作频繁，操作次数多。\n每次扩充容量加倍，如每次扩充增加一倍存储空间。特点：减少了扩充操作的执行次数，但可能会浪费空间资源。以空间换时间，推荐的方式。\n\n顺序表的操作\n添加元素:\n\n尾端加入元素，时间复杂度为O(1)保序的元素加入，时间复杂度为O(n)\n删除元素:\n\n删除表尾元素，时间复杂度为O(1)保序的元素删除，时间复杂度为O(n)\nPython中的list和tuple两种类型采用了顺序表的实现技术.list就是一种采用分离式技术实现的动态顺序表\nlist实现采用了如下的策略：在建立空表（或者很小的表）时，系统分配一块能容纳8个元素的存储区；在执行插入操作（insert或append）时，如果元素存储区满就换一块4倍大的存储区。但如果此时的表已经很大（目前的阀值为50000），则改变策略，采用加一倍的方法。引入这种改变策略的方式，是为了避免出现过多空闲的存储位置。\n单链表\n为什么需要链表\n顺序表缺点：\n\n需要预先知道数据大小来申请存储空间\n进行扩充时需要进行数据的搬迁\n灵活性低\n\n手拉手的方式（线串）去存储，而非通过元素外置的方式去存储，元素外置需要预先知道数据大小。\n线性表：一维空间的一条线去组织数据，呈线性状态。\n\n顺序表：将元素顺序地存放在一块连续的存储区里，元素间的顺序关系由它们的存储顺序自然表示。\n链表：将元素存放在通过链接构造起来的一系列存储块中。\n\n\n原本的数据区，不单单仅仅存储数据，而会增加一个下一个的单元地址\n单链表的ADT模型\n\n头节点：开始存储的变量尾节点：往后就是空指针\n变量p指向链表的头节点（首节点）的位置，从p出发能找到表中的任意节点。\n单链表的操作:\nis_empty() 链表是否为空\nlength() 链表长度\ntravel() 遍历整个链表\nadd(item) 链表头部添加元素\nappend(item) 链表尾部添加元素\ninsert(pos, item) 指定位置添加元素\nremove(item) 删除节点\nsearch(item) 查找节点是否存在\nPython中变量标识的本质: 存储地址，引用指向到一个实际数据\n单链表的实现\n# coding=utf-8\n# single_link_list\n\nclass Node(object):\n    '''节点'''\n    def __init__(self, elem):\n        self.elem = elem\n        self.next = None\n\n# node = Node(100) # 保存  elem, next\n\nclass SingleLinkList(object):\n    '''单链表'''\n    def __init__(self, node=None):\n        self.__head = node # 头节点\n    def is_empty(self):\n        '''链表是否为空'''\n        return self.__head == None\n\n    def length(self):\n        '''链表长度'''\n        # 游标, 指针\n        # cur游标，用来移动遍历节点\n        cur = self.__head\n        # count记录数量\n        count = 0\n        while cur != None: # cur.next == None\n            count += 1\n            cur = cur.next\n        return count\n\n    def travel(self):\n        '''遍历整个链表'''\n        cur = self.__head\n        while cur != None:\n            print(cur.elem, end=' ')\n            cur = cur.next\n\n    def add(self, item):\n        '''链表头部添加元素，头插法'''\n        node = Node(item)\n        node.next = self.__head # 保证链表中的所有关系不打断\n        self.__head = node\n\n    def append(self, item):\n        '''链表尾部添加元素，尾插法'''\n        # item 数据元素\n        node = Node(item)\n        if self.is_empty():\n            self.__head = node\n        else:     \n            cur = self.__head\n            while cur.next != None: # 从头往后走，然后最后挂载一个新的游标\n                cur = cur.next\n            cur.next = node\n\n    def insert(self, pos, item):\n        '''指定位置添加元素\n            :param pos 从0开始\n        '''\n        if pos < 0:\n            self.add(item)\n        elif pos > self.length() - 1:\n            self.append(item)\n        else:\n            # pre用来指向指定位置pos的前一个位置pos-1，初始从头节点开始移动到指定位置\n            pre = self.__head # pre, prior\n            count = 0\n            while count < pos - 1:\n                count += 1\n                pre = pre.next\n            # 当循环退出后，pre指向pos-1的位置\n            node = Node(item)\n            # 先将新节点node的next指向插入位置的节点\n            node.next = pre.next\n            # 将插入位置的前一个节点的next指向新节点\n            pre.next = node\n    def remove(self, item):\n        '''删除节点'''\n        # pre 与 cur 二个游标，需要隔开移动\n        cur = self.__head\n        pre = None\n        while cur != None:\n            if cur.elem == item:\n                # 如果第一个就是删除的节点\n                if cur == self.__head:\n                # 判断子节点是否是头节点\n                    self.__head = cur.next # 将头指针指向头节点的后一个节点\n                else:\n                    # 将删除位置前一个节点的next指向删除位置的后一个节点\n                    pre.next = cur.next\n                break\n            else:\n                # 继续按链表后移节点\n                pre = cur\n                cur = cur.next\n    def search(self, item):\n        '''查找节点是否存在'''\n        cur = self.__head\n        while cur != None:\n            if cur.elem == item:\n                return True\n            else:\n                cur = cur.next\n        return False\n\nif __name__ == '__main__':\n    sll = SingleLinkList()\n    print('is_empty', sll.is_empty())\n    print('length', sll.length())\n    sll.append(100)\n    print('is_empty', sll.is_empty())\n    print('length', sll.length())\n\n    sll.append(22)\n    sll.add(7)\n    sll.append(20)\n    sll.insert(2, 777)\n\n    sll.travel()\n    sll.remove(7)\n    sll.travel()\n\ninsert示意图:\n\nremove示意图：\n\n后继结点：当前节点的下一个节点\n单链表与顺序表的对比\n链表失去了顺序表随机读取的优点，同时链表由于增加了节点的指针域，空间开销比较大，但对存储空间的使用要相对灵活。\n链表与顺序表的各种操作复杂度：\n\n\n操作\n链表\n顺序表\n\n\n\n访问元素\nO(n)\nO(1)\n\n\n在头部插入/删除\nO(1)\nO(n)\n\n\n在尾部插入/删除\nO(n)\nO(1)\n\n\n在中间插入/删除\nO(n)\nO(n)\n\n\n\n链表不能一次性找到位置，都需要通过循环来找到该位置；而顺序表则直接找到位置。\n双链表\n\n数据包含：数据区 + 前驱结点 + 后继结点\n# coding=utf-8\n# double_link_list\n\nclass Node(object):\n    '''节点'''\n    def __init__(self, elem):\n        self.elem = elem\n        self.next = None\n        self.prev = None\n\nclass DoubleLinkList(object):\n    \"\"\"双链表\"\"\"\n    def __init__(self, node=None):\n        self.__head = node\n    def is_empty(self):\n        return self.__head is None\n\n    def length(self):\n        count = 0\n        cur = self.__head\n        while cur != None:\n            count += 1\n            cur = cur.next\n        return count\n    def travel(self):\n        cur = self.__head\n        while cur != None:\n            print(cur.elem, end=' ')\n            cur = cur.next\n        print('')\n    def add(self, item):\n        node = Node(item)\n        node.next = self.__head\n        self.__head = node\n        node.next.prev = node\n\n    def append(self, item):\n        node = Node(item)\n        cur = self.__head\n\n        if self.is_empty():\n            self.__head = node\n        else:    \n            while cur.next != None:\n                cur = cur.next\n            cur.next = node\n            node.prev = cur \n\n    def insert(self, pos, item):\n        if pos <= 0:\n            self.add(item)\n        elif pos > (self.length() - 1):\n            self.append(item)\n        else:\n            cur = self.__head\n            count = 0\n            while count < pos:\n                count += 1\n                cur = cur.next\n            # 当循环退出的时候，cur指针指向的就是pos的位置\n            node = Node(item)\n            # 将node的prev指向cur\n            node.next = cur\n            #  将node的next指向cur的下一个节点\n            node.prev = cur.prev # 当前节点的上一个，指向到插入节点的前指针\n            # 将cur的下一个节点的prev指向node\n            cur.prev.next = node\n            # 将cur的next指向node\n            cur.prev = node\n\n    def remove(self, item):\n        cur = self.__head\n        while cur != None:\n            if cur.elem == item:\n                if cur == self.__head:\n                    self.__head = cur.next\n                    if cur.next: # 判断双链表是否之后一个节点\n                        cur.next.prve = None\n                else:\n                    # 将cur的前一个节点的next指向cur的后一个节点\n                    cur.prev.next = cur.next\n                    if cur.next:\n                        # 将cur的后一个节点的prev指向cur的前一个节点\n                        cur.next.prev = cur.prev\n                break\n            else:\n                cur = cur.next\n\n    def search(self, item):\n        cur = self.__head\n        while cur != None:\n            if cur.elem == item:\n                return True\n            else:\n                cur = cur.next\n        return False\n\nif __name__ == '__main__':\n    dll = DoubleLinkList()\n\n    print('is_empty', dll.is_empty())\n    print('length', dll.length())\n    dll.append(100)\n    print('is_empty', dll.is_empty())\n    print('length', dll.length())\n\n    dll.append(22)\n    dll.add(7)\n    dll.append(20)\n    dll.insert(2, 777)\n\n    dll.travel()\n    dll.remove(7)\n    dll.travel()\n单项循环链表\n\n# coding=utf-8\n# single_cycle_link_list\n\nclass Node(object):\n    '''节点'''\n    def __init__(self, node):\n        self.elem = node\n        self.next = None\n\nclass SingleCycleLinkList(object):\n    '''单链表'''\n    def __init__(self, node=None):\n        self.__head = node # 头节点\n        if node:\n            node.next = node\n\n    def is_empty(self):\n        '''链表是否为空'''\n        return self.__head == None\n\n    def length(self):\n        '''链表长度'''\n        if self.is_empty():\n            return 0\n        cur = self.__head\n        # count记录数量\n        count = 1 # count从1开始\n        while cur.next != self.__head: # cur.next == None\n            count += 1\n            cur = cur.next\n        return count\n\n    def travel(self):\n        '''遍历整个链表'''\n        if self.is_empty():\n            return\n        cur = self.__head\n        while cur.next != self.__head:\n            cur = cur.next\n            print(cur.elem, end=' ')\n        # print(cur.elem, '-------')\n        # print('')\n\n    def add(self, item):\n        '''链表头部添加元素，头插法'''\n        node = Node(item)\n        if self.is_empty():\n            # 如果为空，指向节点，然后节点的指针指向自己\n            self.__head = node\n            node.next = node\n        else:\n            cur = self.__head\n            # 指针先移动到尾端\n            while cur.next != self.__head:\n                cur = cur.next\n            # 退出循环，cur指向尾节点\n            # 改变指针指向\n            node.next = self.__head\n            self.__head = node\n            # cur.next = node\n            cur.next = node\n\n    def append(self, item):\n        '''链表尾部添加元素，尾插法'''\n        node = Node(item)\n        if self.is_empty():\n            self.__head = node\n            node.next = node\n        else:\n            cur = self.__head\n            while cur.next != self.__head:\n                cur = cur.next\n            node.next = self.__head\n            cur.next = node\n\n    def insert(self, pos, item):\n        '''指定位置添加元素\n            :param pos 从0开始\n        '''\n        if pos < 0:\n            self.add(item)\n        elif pos > (self.length() - 1):\n            self.append(item)\n        else:\n            pre = self.__head\n            count = 0\n            while count < (pos - 1):\n                count += 1\n                pre = pre.next\n            node = Node(item)\n            node.next = pre.next\n            pre.next = node\n\n    def remove(self, item):\n        '''删除节点'''\n        '''\n            1. 头节点\n            2. 尾节点\n            3. 中间节点\n            4. 只存在一个节点\n            5. 空链表\n            6. 首节点就是删除的节点\n        '''\n        if self.is_empty():\n            return\n        cur = self.__head\n        pre = None\n        while cur.next != self.__head:\n            if cur.elem == item:\n                if cur == self.__head:\n                    # 头节点的情况\n                    # 找到尾节点\n                    rear = self.__head\n                    # 为了顺利把尾节点的指针指向到头节点，先把指针便利到尾部\n                    while rear.next != self.__head:\n                        rear = rear.next\n                    self.__head = cur.next\n                    rear.next = self.__head\n                else:\n                    # 中间节点\n                    pre.next = cur.next\n                return\n            else:\n                # 两个游标顺次往链表后边移动\n                pre = cur\n                cur = cur.next\n        # 尾部情况\n        # 退出循环，cur指向尾节点\n        if cur.elem == item:\n            if self.__head == cur:\n                # 只有一个节点\n                self.__head = None\n            else:\n                pre.next = cur.next\n\n    def search(self, item):\n        '''查找节点是否存在'''\n        if self.is_empty():\n            return False\n        cur = self.__head\n        while cur.next != self.__head:\n            if cur.elem == item:\n                return True\n            else:\n                cur = cur.next\n        # 退出循环，cur指向尾节点        \n        if cur.elem == item:\n            return True\n        return False\n\nif __name__ == '__main__':\n    scll = SingleCycleLinkList()\n    print('is_empty', scll.is_empty())\n    print('length', scll.length())\n\n    scll.append(100)\n    print('is_empty', scll.is_empty())\n    print('length', scll.length())\n\n    scll.append(22)\n    scll.add(7)\n    scll.append(20)\n    scll.insert(2, 777)\n\n    scll.travel()\n    scll.remove(7)\n    scll.travel()\n\n栈\n线性表：顺序表（连续存放），链表（离散存放）。存储线性的数据。 --> 解决数据怎么存放的问题\n栈与队列基础\n栈：容器，可以利用线性表的特性，来实现数据的操作。\n由于栈数据结构只允许在一端进行操作，因而按照后进先出（LIFO, Last In First Out）的原理运作。\n\n栈的实现\n在python的list是顺序表，借助list来实现栈.\n栈顶：栈的头部栈低：栈的底部\n#coding=utf-8\n\n\nclass Stack(object):\n    '''栈'''\n    def __init__(self):\n        self.__list = []\n\n    def push(self, item):\n        '''添加一个新的元素item到栈顶'''\n        self.__list.append(item)\n        # 确定是尾部还是头部插入数据\n        # 选择在尾部添加，而非头部插入，顺序表对于尾部操作的时间复杂度是O(1)\n        # self.__list.insert(0, item)\n    def pop(self):\n        '''弹出栈顶元素'''\n        return self.__list.pop()\n        # self.__list.pop(0)\n\n    def size(self):\n        '''返回栈的元素个数'''\n        return len(self.__list)\n\n    def is_empty(self):\n        '''判断栈是否为空'''\n        # '', 0, {}, [], ()\n        return self.__list == []\n\n    def peek(self):\n        '''返回栈顶元素'''\n        if self.__list:\n            return self.__list[-1]\n        else:\n            return None\n\nif __name__ == '__main__':\n    stack = Stack()\n\n    stack.push(11)\n    stack.push(1000)\n    print(stack.size(), 'stack.size()')\n    print(stack.pop(), 'stack.pop()')\n\n队列\n队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。队列不允许在中间部位进行操作。\n可以在tree中使用.\n队列\n队列头：取的那一端，叫做队头队列尾：添加队一端，叫做队尾\n队列\n#coding=utf-8\n\n\nclass Queue(object):\n    def __init__(self):\n        self.__list = []\n\n    def enqueue(self, item):\n        '''往队列中添加一个item元素'''\n        self.__list.append(item) # 尾部插入\n        # self.__list.insert(0, item) # 头部插入\n\n    def dequeue(self):\n        '''从队列头部删除一个元素'''\n        return self.__list.pop(0) # 尾部删除\n        # return self.__list.pop() # 头部删除\n\n    def is_empty(self):\n        '''判断一个队列是否为空'''\n        return not self.__list\n\n    def size(self):\n        '''返回队列的大小'''\n        return len(self.__list)\n\nif __name__ == '__main__':\n\n    queue = Queue()\n    queue.enqueue(10)\n    queue.enqueue(13)\n\n    print(queue.size())\n    print(queue.dequeue())\n\n双端队列\n两端都可以出队列，也都可以入队列。\n#coding=utf-8\n\nclass Dqueue(object):\n    '''双端队列'''\n    def __init__(self):\n        self.__list = []\n\n    def add_front(self, item):\n        '''添加一个新的元素item到栈顶'''\n        self.__list.insert(0, item) # 头部添加\n\n    def add_rear(self, item):\n        self.__list.append(item) # 尾部添加\n\n    def pop_fornt(self):\n        return self.__list.pop(0)\n    \n    def pop_rear(self):\n        return self.__list.pop()\n\n    def size(self):\n        '''返回栈的元素个数'''\n        return len(self.__list)\n\n    def is_empty(self):\n        '''判断栈是否为空'''\n        # '', 0, {}, [], ()\n        return self.__list == []\n\nif __name__ == '__main__':\n    dq = Dqueue()\n\n    dq.add_front(11)\n    dq.add_front(100)\n    dq.add_rear(1000)\n    print(dq.size(), 'dq.size()')\n    print(dq.pop_fornt(), 'dq.pop_fornt()')\n\n排序\n排序算法：是一种能将一串数据依照特定顺序进行排列的一种算法。\n排序算法的稳定性\n稳定排序算法会让原本有相等键值的记录维持相对次序。也就是如果一个排序算法是稳定的，当有两个相等键值的纪录R和S，且在原本的列表中R出现在S之前，在排序过的列表中R也将会是在S之前。（特指排序条件相等的两个元素，排序后的顺序是否和排序前一致。有时候需要按照多个条件排序）\n如果排序算法是稳定的，可以先按照第一个条件排序后再按照其它条件排序，则结果就是想要的。若果是不稳定的排序，需要额外的步骤保证结果的正确性。\n冒泡排序\n\n比较相邻的元素。如果第一个比第二个大（升序），就交换它们两个。\n对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。\n针对所有的元素重复以上的步骤，除了最后一个。\n持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n\n#condig-utf8\n\ndef bubble_sort(alist):\n    '''冒泡排序'''\n    n = len(alist)\n\n    # 走多少次\n    # 从头走到尾\n\n    for j in range(n - 1):# 走多少次\n        count = 0\n        for i in range(0, n - 1 - j): # 从头走到尾\n            if alist[i] > alist[i+1]:\n                # 位置调换\n                alist[i], alist[i+1] = alist[i+1], alist[i]\n                count += 1\n        if 0 == count: # 常量 ，变量\n            return\n\n    # i 0 ~ n-2  range(0, n-1) j=0\n    # i 1 ~ n-3  range(0, n-1-1) j=1\n    # i 2 ~ n-4  range(0, n-1-1-1) j=2\n    # j=n i range(0, n-1-j)\n\nif __name__ == '__main__':\n    li = [54, 26, 93, 17, 77, 34]\n    bubble_sort(li)\n    print(li)\n\n时间复杂度：\n\n最优时间复杂度：O(n) （表示遍历一次发现没有任何可以交换的元素，排序结束。）\n最坏时间复杂度：O(n^2)\n\n稳定性：稳定\n\n选择排序\n从未排序的列表中选择一个最小的排到前面去\n# alist = [12, 34, 3453, 456, 4, 45, 2, 5, 100]\n#           0   1   2    3    4   5  6  7  8\n\n# min = 0\n# min = 6\n# alist[0], alist[6] = alist[6], alist[0]\n\n\n\n# alist = [2,     34, 3453, 456, 4, 45, 12, 5, 100]\n#           0      1    2    3   4  5    6  7   8\n\n# min = 1\n# min = 4\n# alist[1], alist[4] = alist[4], alist[1]\n\n# 从未排序的列表中选择一个最小的排到前面去\n\n\n# 选择排序，看未排序的后边部分\n\n# 插入排序，把未排序的序列放在，已经排序的序列那一个位置中。\n\n# 比较的位置\n# j = 0\n# min = 0 + 1\n\n# j = 1\n# min = 1 + 1\n\nalist = [12, 34, 3453, 456, 4, 45, 2, 5, 100]\n\ndef select_sort(alist):\n  '''选择排序'''\n  n = len(alist)\n\n  for j in range(0, n-1): # 产生n-2, 这边需要写n-1, 及 (0 ~ n-2)\n    min_index = j\n    for i in range(j+1, n): # 需要到 (n-1) 的位置  时间复杂度：1-n, 2-n, 3-n\n    # 分为左右两边，完成的序列 和 未完成的序列\n      if alist[min_index] > alist[i]:\n        min_index = i\n    alist[j], alist[min_index] = alist[min_index], alist[j]\n\n\nprint(alist)\nselect_sort(alist)\nprint(alist)\n\n时间复杂度：\n\n最优时间复杂度：O(n^2)\n\n最坏时间复杂度：O(n^2)\n\n稳定性：不稳定（考虑升序每次选择最大的情况）\n\n相同数据中，排列之后的位置一样，具有稳定性。\n插入排序\n#coding=utf-8\n\nli = [54, 26, 93, 17, 77, 34]\n\n# 后续的无需序列，与前面的有序序列中的最后一个元素比较\n\ndef insert_sort(alist):\n    n = len(alist)\n    # 从右边的无序序列中取出多少个元素执行这个的过程\n    for j in range(0, n):\n        i = j\n        # 执行从右边的无序序列中取出第一个元素，即i位置的元素，然后将其插入到前面正确的位置中\n        while i > 0: \n            if alist[i] < alist[i-1]:\n                alist[i], alist[i-1] = alist[i-1], alist[i]\n                i -= 1\n            else:\n                break\n\nprint(li)\ninsert_sort(li)\nprint(li)\n\n时间复杂度：\n\n最优时间复杂度：O(n) （升序排列，序列已经处于升序状态）\n最坏时间复杂度：O(n^2)\n\n稳定性：稳定\n\n希尔排序\n插入排序的改进版本\n#coding=utf-8\nalist = [12, 34, 3453, 456, 4, 45, 2, 5, 100]\n\ndef shell_sort(alist):\n    '''希尔排序'''\n    n = len(alist) # n = 9\n    gap = n // 2 # n = 4\n\n    # i = 1\n    # i = gap\n    # gap变化到0之前，插入算法执行到次数\n    while gap > 0: # 可以等于0\n        # 希尔算法 与普通的 插入算法的区别就是 gap 步长\n        for j in range(gap, n): # 一次性循环全部处理完成\n            # 控制子序列中的所有元素\n            # j = [gap, gap+1, gap+2, gap+3, ... , n-1]\n            i = j\n            while i > 0: # 控制子序列中的比较和交换的算法\n                if alist[i] < alist[i-gap]:\n                    alist[i], alist[i-gap] = alist[i-gap], alist[i]\n                    i -= gap\n                else:\n                    break\n        gap //= 2 # 缩短gap步长\n\n\nprint(alist)\nshell_sort(alist)\nprint(alist)\n时间复杂度：\n\n最优时间复杂度：根据步长序列的不同而不同\n最坏时间复杂度：O(n^2)\n稳定性：不稳定\n\n快速排序\n一个数字，在序列的那个位置。按照当前的数字，每次分开两部分。\n步骤：\n\n从数列中挑出一个元素，称为\"基准\"（pivot），\n重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。\n递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。\n\n\n核心代码:取第一个位置保存中间值(middle_value), 第一个位置是空位置，就该high的位置来判断了，当合适就换位置，并且移动对方的指针（low），当不合适移动当前指针(high)。\nmiddle_value = 10\n\nlow = 0\nhigh = len(list)\n\nif alist[high] < middle_value:\n    alist[low] = alist[high]\n    low += 1\nelif alist[high] > middle_value:\n    high -= 1\n    \nif alist[low] < middle_value:\n    alist[high] = alist[low]\n    hight -= 1\nelif alist[low] > middle_value:\n    low += 1\n    \nif low == high:    \n    alist[low] = middle_value            \n\n#conding=utf-8\n\ndef quick_sort(alist, first, last):\n    '''快速排序'''\n    if first >= last:\n        return\n\n    # mid_value = alist[0] # 中间值\n    mid_value = alist[first] # 中间值\n    # n = len(alist)\n    # 左右游标\n    # low = 0\n    low = first\n    # high = n-1\n    high = last\n\n    while low < high:\n        # high 游标 左移动\n        while low < high and alist[high] >= mid_value:\n            high -= 1\n        alist[low] = alist[high]\n        # low += 1\n\n        # low 游标 右移动\n        while low < high and alist[low] < mid_value:\n            low += 1\n        alist[high] = alist[low]\n        # high -= 1\n\n        # 等于的情况放到其中一边去处理\n        # 为了保证二个指针不错过，注释 【low += 1】和 【high -= 1】\n\n    # 退出循环的时候，low == high\n    alist[low] = mid_value # 中间值赋值到该位置\n\n    # 递归\n    # 对low左边的列表执行快速排序\n    quick_sort(alist, first, low-1)\n    # 对low右边的列表执行快速排序\n    quick_sort(alist, low+1, last)\n\nif __name__ == '__main__':\n    li = [54, 26, 93, 17, 77, 34]\n    print(li)\n    quick_sort(li, 0, len(li)-1)\n    print(li)\n\n时间复杂度：\n\n最优时间复杂度：O(nlogn): 2*2*2... = n, n个元素对2取对数。 log2(n)以2为底的对数\n最坏时间复杂度：O(n^2)\n\n稳定性：不稳定\n\n时间复杂度不好从代码中分析，通过画图中理解每次循环中操作。横向和纵向来区分判断。\n归并排序\n\n先把序列从头开始往下拆，直到只有一个元素。紧接着开始，二个部分合并到一起，然后再次合并，直到完成序列合并。\n需要使用到递归。\n#coding=utf-8\n\ndef merge_sort(alist):\n  '''归并排序'''\n\n  '''\n    分裂\n  '''\n  n = len(alist)\n  if n <= 1:\n    return alist\n  mid = n // 2\n  # left, right 采用归并排序后形成的有序的新的列表\n  left_li = merge_sort(alist[:mid]) # 传新的列表\n  right_li = merge_sort(alist[mid:])\n\n  '''\n    合并\n  '''\n  # 将两个有序的子序列合并为一个新的整体\n  # merge(left, right)\n  left_pointer, right_pointer = 0, 0\n  result = []\n\n  while left_pointer < len(left_li) and right_pointer < len(right_li):\n    if left_li[left_pointer] < right_li[right_pointer]: # 左边\n      result.append(left_li[left_pointer])\n      left_pointer += 1\n    else: # 右边\n      result.append(right_li[right_pointer])\n      right_pointer += 1\n  result += left_li[left_pointer:] # 加上剩下数据\n  result += right_li[right_pointer:]\n  return result\n\nalist = [1, 23, 34, 6,2, 12, 12, 1, 2]\nprint(alist)\nnew_alist = merge_sort(alist) # 返回新的列表\nprint(new_alist)\n时间复杂度：\n\n最优时间复杂度：O(nlogn), 2*2*2... = n, n个元素对2取对数。 log2(n)以2为底的对数\n最坏时间复杂度：O(nlogn)\n\n稳定性：稳定\n\n搜索\n搜索：在一个项目集合中找到特定项目的算法过程。搜索结果：通常的答案是真或假,因为该项目是否存在。\n常见搜索方法：顺序查找，二分法查找，二叉树查找，哈希查找\n二分查找\n二分查找，需要定位到索引，也就是说，只能作用到顺序表上，而且是排序过后的，有序顺序表中。\n非递归实现需要关注：头和尾的下标，来计算二分位置的下标。（原因在原有的列表上去找）指明查找的范围，需要二个指针来控制前后移动\ndef binary_search_2(alist, item):\n  '''二分查找'''\n  n = len(alist)\n  first = 0\n  last = n - 1\n  while first <= last: # 中间最小之后一个值，需要包含等于\n    mid = (first + last) // 2\n    if alist[mid] == item:\n      return True\n    elif item < alist[mid]:\n      last = mid - 1\n    else:\n      first = mid + 1\n  return False\n递归实现\ndef binary_search(alist, item):\n  '''二分查找'''\n  n = len(alist)\n  if n > 0:\n    mid = n//2 # 新的列表\n\n    if alist[mid] == item:\n      return True\n    elif item < alist[mid]:\n      return binary_search(alist[:mid], item)\n    else:\n      return binary_search(alist[mid+1:], item)\n  return False\n时间复杂度：\n\n最优时间复杂度：O(1)\n\n最坏时间复杂度：O(logn)\n\n\n二叉树\n用来模拟具有树状结构性质的数据集合，它是由n(n>=1)个有限节点组成一个具有层次关系的集合。\n二叉树是二维空间上的表现，图是三维空间上的表现。\n特点：\n\n每个节点有零个或多个子节点（每个节点都会有数据区和链接区）\n没有父节点的节点称为根节点\n每一个非根节点有且只有一个父节点\n除了根节点外，每个子节点可以分为多个不相交的子树(每个节点只有一个父级)\n\n树的术语\n\n节点的度：一个节点含有的子树的个数称为该节点的度（有几个下级，几个下级子节点）\n树的度：一棵树中，最大的节点的度称为树的度；\n叶节点或终端节点：度为零的节点；\n父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；\n孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；\n兄弟节点：具有相同父节点的节点互称为兄弟节点；\n节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；\n树的高度或深度：树中节点的最大层次；\n堂兄弟节点：父节点在同一层的节点互为堂兄弟；\n节点的祖先：从根到该节点所经分支上的所有节点；\n子孙：以某节点为根的子树中任一节点都称为该节点的子孙。\n森林：由m（m>=0）棵互不相交的树的集合称为森林；\n\n树的种类\n\n无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树；\n\n有序树：树中任意节点的子节点之间有顺序关系（树的节点直接有某种特殊的意义在），这种树称为有序树；\n\n\n二叉树：每个节点最多含有两个子树的树称为二叉树（节点的度最高到2）\n\n完全二叉树：对于一颗二叉树，假设其深度为d(d>1)。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树，其中满二叉树的定义是所有叶节点都在最底层的完全二叉树\n平衡二叉树（AVL树）：当且仅当任何节点的两棵子树的高度差不大于1的二叉树\n排序二叉树（二叉查找树（英语：Binary Search Tree），也称二叉搜索树、有序二叉树）\n\n\n霍夫曼树（用于信息编码）：带权路径最短的二叉树称为哈夫曼树或最优二叉树\nB树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多余两个子树\n\n\n\n树的存储与表示\n虽然树是二维的，但是可以用一维的顺序表存储起来。\n\n顺序存储：将数据结构存储在固定的数组中，然在遍历速度上有一定的优势，但因所占空间比较大，是非主流二叉树。二叉树通常以链式存储。(把连续的空间和树上的节点做对应关系。按照节点的层次来存储数据)\n链式存储：缺陷，指针域指针个数不定\n\n由于对节点的个数无法掌握，常见树的存储表示都转换成二叉树进行处理，子节点个数最多为2\n最常用的树的存储，是链式存储，多存储后记链接区。\n常见应用场景\n\n\nxml，html等，那么编写这些东西的解析器的时候，不可避免用到树\n路由协议就是使用了树的算法\n\nmysql数据库索引\n文件系统的目录结构\n所以很多经典的AI算法其实都是树搜索，此外机器学习中的decision tree也是树结构\n\n二叉树介绍\n每个节点最多有两个子树的树结构。(最大的度只能是2)通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）\n二叉树的数学上的一些性质(特性)\n\n在二叉树的第i层上至多有2^(i-1)个结点（i>0）\n\n深度为k的二叉树至多有2^k - 1个结点（k>0）\n\n对于任意一棵二叉树，如果其叶结点数为N0（度数为0），而度数为2的结点总数为N2，则N0=N2+1;\n具有n个结点的完全二叉树的深度必为 log2(n+1)(和特性2在数学上是相反的)\n对完全二叉树，若从上至下、从左至右编号，则编号为i 的结点，其左孩子编号必为2i，其右孩子编号必为2i＋1；其双亲的编号必为i/2（i＝1 时为根,除外）\n\n二叉树的实现\n添加的方式：二叉树的广度优先遍历（广度层次遍历），通过队列，取出头的元素，判断是否有左子节点与右子节点，如果都有往队列中添加，如果没有，挂载到节点上。\n深度遍历：\n\n先序遍历（从最小的三个节点二叉树的先根节点遍历，左子节点，右子节点的遍历）-> 根，左，右\n中序遍历（把根放到中间，就是左子节点，根，右子节点的顺序遍历）-> 左，根，右\n后序遍历（把根放到最后一个上面，左子节点，右子节点的顺序遍历）-> 左，右，根\n\n无论把根放到那个位置上，子节点都是先左边后右边\n#coding=utf-8\n\nclass Node(object):\n    '''节点类'''\n    def __init__(self, item):\n        self.elem = item\n        self.lchild = None\n        self.rchild = None\n\nclass Tree(object):\n    '''二叉树'''\n    def __init__(self):\n        self.root = None        \n\n    # 插入 （广度优先遍历）\n    def add (self, item):\n        node = Node(item)\n        if self.root is None:\n            self.root = node\n            return\n        queue = [self.root]\n\n        while queue: # 不为空列表\n            cur_node = queue.pop(0)\n            if cur_node.lchild is None:\n                cur_node.lchild = node\n                return\n            else:\n                queue.append(cur_node.lchild)\n            if cur_node.rchild is None:\n                cur_node.rchild = node\n                return\n            else:\n                queue.append(cur_node.rchild)\n    def breadth_travel(self):\n        '''广度遍历'''\n        '''层次遍历'''\n        if self.root is None:\n            return\n        queue = [self.root]\n\n        while queue:\n            cur_node = queue.pop(0)\n            print(cur_node.elem, end=' ')\n            if cur_node.lchild is not None:\n                queue.append(cur_node.lchild)\n            if cur_node.rchild is not None:\n                queue.append(cur_node.rchild)\n    def preorder(self, node): # 中序，先序，后序，根节点都在变化，为了调用自身，而且是调用不同的子树，所以根节点作为参数传入\n        '''先序遍历'''\n        if node is None:\n            return\n        print(node.elem, end=' ') # 根\n        self.preorder(node.lchild) # 左边\n        self.preorder(node.rchild) # 右边\n\n    def inorder(self, node):\n        '''中序遍历'''\n        if node is None:\n            return\n        self.inorder(node.lchild)\n        print(node.elem, end=' ')\n        self.inorder(node.rchild)\n    \n    def postorder(self, node):\n        '''后序遍历'''\n        if node is None:\n            return\n        self.postorder(node.lchild)\n        self.postorder(node.rchild)\n        print(node.elem, end=' ')\n\nif __name__ == '__main__':\n    tree = Tree()\n\n    tree.add(0)\n    tree.add(1)\n    tree.add(2)\n    tree.add(3)\n    tree.add(4)\n    tree.add(5)\n    tree.add(6)\n    tree.add(7)\n    tree.add(8)\n    tree.add(9)\n    tree.breadth_travel()\n    print(' ')\n    tree.preorder(tree.root)\n    print(' ')\n    tree.inorder(tree.root)\n    print(' ')\n    tree.postorder(tree.root)\n    print(' ')\n\n\n层次遍历： 0 1 2 3 4 5 6 7 8 9\n先序遍历： 0 1 3 7 8 4 9 2 5 6\n中序遍历： 7 3 8 1 9 4 0 5 2 6\n后序遍历： 7 8 3 9 4 1 5 6 2 0\n给出遍历结果，然后确定一颗二叉树。给其中二个种遍历结果，就可以写出二叉树（先序和中序，或者，中序和后序），一定需要一个中序，不然，左右子树无法分开。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "2"}