{"title": "流畅的python读书笔记-第一章Python 数据模型 - 个人文章 ", "index": "python", "content": "第一章 python数据类型\n1 隐式方法\n利用collections.namedtuple 快速生成字典\nimport collections\n\n\nCard = collections.namedtuple('Card', ['rank', 'suit'])\n\nclass FrenchDeck:\n    ranks = [str(n) for n in range(2, 11)] + list('JQKA')\n    suits = 'spades diamonds clubs hearts'.split()\n\n    def __init__(self):\n        self._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks]\n\n    def __len__(self):\n        return len(self._cards)\n\n    def __getitem__(self, position):\n        return self._cards[position]\n\n1.1 __getitem__方法\ndeck = FrenchDeck()\n>>> deck[0]\nCard(rank='2', suit='spades')\n>>> deck[-1]\nCard(rank='A', suit='hearts')\n__getitem__方法\n\n通过下标找元素\n自动支持切片（slicing）操作\n可迭代\n\n1.2 __len__方法 与 len(my_object)\n\n如果my_object 是一个自定义类的对象，那么 Python 会自己去调用其中由 你实现的 len 方法。\nPython 内置的类型，比如列表（list）、字符串（str）、 字节序列（bytearray）等，那么 CPython   会抄个近路，__len__ 实际 上会直接返回 PyVarObject 里的 ob_size 属性。\n\n1.3 其他方法 特殊方法的调用是隐式的\nfor i in x: 这个语句\n背后其实用的是 iter(x)而这个函数的背后则是 x.__iter__() 方法。\n1.4  不要自己想当然地随意添加特殊方法\n比如 foo 之类的因为虽然现在这个名字没有被 Python 内部使用，以后就不一定了\n一个轮子 随机抽牌\n>>> from random import choice\n>>> choice(deck)\nCard(rank='3', suit='hearts')\n>>> choice(deck)\nCard(rank='K', suit='spades')\n>>> choice(deck)\nCard(rank='2', suit='clubs')\n2 字符串表示形式 repr 和 str\n\n\n__repr__和__str__这两个方法都是用于显示的\n__str__是面向用户的，而__repr__面向程序员。\n一个对象没有 str 函数，解释器会用 repr 作为替代。\n\n3 算术运算符\nadd 和 __mul__，类带来了 + 和 * 这两个算术运算符。\n4 布尔值\n\n列表项目bool(x) 的背后是调用x.__bool__() 的结果；\n如果不存在 bool 方法，那么 bool(x) 会尝试调用 x.__len__()。\n若返回 0，则 bool 会返回 False；否则返回True。\n\n5 其他隐式方法请见 书1.3 特殊方法一览\n小总结\n\ncollections.namedtuple 快速生成字典\n__getitem__方法\n\n\n通过下标找元素\n自动支持切片（slicing）操作\n可迭代\n\n\n\n\nlen()\n\nlen(my_obj )自定义类的对象,自定义实现的 len 方法。\npython内置类型,通过内部类型的属性直接取得\n\n\n\nrepr__和__str\n\n__repr__和__str__这两个方法都是用于显示的\n__str__是面向用户的，而__repr__面向程序员。\n一个对象没有 str 函数，解释器会用 repr 作为替代。\n\n\nfrom random import choice 一个随机选取的轮子\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}