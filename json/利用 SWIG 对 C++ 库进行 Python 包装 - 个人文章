{"title": "利用 SWIG 对 C++ 库进行 Python 包装 - 个人文章 ", "index": "python,c,c++,swig", "content": "如果你也像我们一样，同时使用Python和C++，以获得两种语言的优势，一定也会希望寻找一种好的方式集成这两种语言，相比而言，让Python能够方便使用C++的库更加重要，我们选择SWIG来实现这一需求，原因请见”途径”一节对几种实现途径的比较。\n这篇博文介绍使用SWIG将C++库包装成Python接口，建议将”常用功能说明”之后的内容当做参考使用，因为那些内容牵涉到C++语言的各个特性，但不影响对SWIG整体使用的理解，可以在需要时参考。\n另外，这篇博文中有很多例示代码，解释不多。是因为我觉得例示代码本身是很好的解释，清楚、准确、简练。如有问题，欢迎留言交流。\n转载者的话 by amc\n\n本文章除了本小节是博主 amc 写的之外，其他部分均为转载，不同的是博主尽可能还原了原文的格式。\n本文转载自这里：“利用SWIG对C++库进行Python包装”，然而这篇文章也是转载的，但是却不注明出处！！而原文到底是哪一篇、在哪里，也找不到了……\n此外，那篇文章转载了之后，但是只是普通的复制粘贴，格式什么的根本就不管，导致文章看起来实在是太难受了，所以我干脆自己转载一份好了。如果本文章的原作者看到了，请务必联系我，我会将最原创的链接完整附上。\n最后，感谢原创者的贡献，同时谴责一下转载不注明出处的博主们。\n途径\n为C++库提供Python接口有以下几种常见途径:\nPython C API\nPython解释器提供的一组C API，利用这组API，可以用C/C++实现Python module，也可以将Python解释器做为一个脚本引擎嵌入到C/C++程序中，为C/C++程序提供运行Python脚本的能力。Python C API是其他途径的基础，其他途径最终都以某种方式以Python C API实现。然而，直接使用Python C API相当繁琐，容易出错，因此很少直接使用。\nctypes\nctypes是Python标准库提供的调用动态链接库的模块，使用这个模块可以直接在Python里加载动态链接库，调用其中的函数。使用ctypes 的优势是门槛低，不用编写或修改C/C++代码。然而我只简单地使用过这种方式，没有深入研究，不了解它对C/C++的支持是否完整。\nBoost.Python\nBoost.Python是Boost提供的一个C++的模板库，用以支持Python和C++的无缝互操作。相对SWIG来说，这个库的优势是功能通过C++ API完成，不用学习写新的接口文件。对C++的支持更自然、完整。这个库的问题是：1)有外部依赖；2)文档不好，我看到有人说他看到三个不同的Boost.Python的tutorial，而这三个tutorial却完全不一样。我花了两个小时尝试Boost.Python，连tutorial的例子都没跑通，就放弃了。\nSWIG\nSWIG是本文描述的重点，也是我们采用的途径。SWIG完整支持ANSI C，支持除嵌套类外的所有C++特性。SWIG是一个接口编译器，旨在为C/C++方便地提供脚本语言接口。SWIG不仅可以为C/C++程序生成 Python接口，目前可以生成CLISP,Java,Lua,PHP,Ruby,Tcl等19种语言的接口。SWIG被Subversion, wxPython, Xapian等项目使用。值得一提的是，Google也使用SWIG。\nSWIG的工作方式\nSWIG本质上是个代码生成器，为C/C++程序生成到其他语言的包装代码(wrapper code)，这些包装代码里会利用各语言提供的C API，将C/C++程序中的内容暴露给相应语言。为了生成这些包装代码，SWIG需要一个接口描述文件，描述将什么样的接口暴露给其他语言。\nSWIG的 接口描述文件可以包含以下内容：\n\nANSI C函数原型声明\nANSI C变量声明\nSWIG指示器(directive)相关内容\n\nSWIG可以直接接受 .h 头文件做为接口描述文件。在有了接口描述文件后，就可以利用 swig 命令生成包装代码了，然后将包装代码编译链接成可被其他语言调用的库。\nSWIG对Python支持到何种程度？\n利用SWIG，可以现实以下功能：\n\n用Python调用C/C++库\n用Python继承C++类，并在Python中使用该继承类\nC++使用Python扩展（通过文档描述应该可以支持，未验证）\n\n版本说明\nSWIG的最新版本为2.0.1。因为我们现在使用的SWIG版本为1.3.40，本篇博客里的说明仅针对1.3.40版\nSWIG文档说明\nSWIG的文档非常详尽，我甚至觉得太过详尽，不可能全看。我刚开始因为对SWIG文档组织不熟悉，看完一部分SWIG Basices就开始尝试，一路摸索到可以使用，后来才发现SWIG还有针对Python的专门文档。相比之下我之前摸索到的方案相当丑陋。\nSWIG文档大体分两部分：\n\n一部分为SWIG本身：SWIG基本使用，对C及C++的支持，SWIG库及扩展等\n另一部分为SWIG对每一个目标语言的文档，如SWIG和Python的文档。\n\n我建议只看和具体语言相关的文档，遇到问题时再去看SWIG本身的相关部分。\n这篇博文应该会描述到用SWIG对C++进行Python包装的各个方面，不过喜欢原汁原味且有充足时间又comfortable with English的同学可直接看SWIG的文档。\nSWIG包含的内容\nSWIG包含以下几部分内容：\n\n一个代码生成器(swig)：代码生成器根据接口说明文件，生成相应的包装代码。\n一个库：SWIG将常用的内容放到SWIG库里了，比如对数组、指针的支持，字符串支持，STL支持等。可以在接口文件中直接引用库里的内容，大大方便接口文件的编写。\n一个简单示例\n\n本节给出一个简单示例，提供对SWIG的直观认识，文章末尾处给出了一个更完整的例子。\nexample.h\n#include <iostream>\nusing namespace std;\nclass Example{\n    public:\n    void say_hello();\n};\n\n\nexample.cpp\n#include \"example.h\"\n\nvoid Example::say_hello(){\n    cout<<\"hello\"<<endl;\n}\n\nexample.i\n%module example\n%{\n#include \"example.h\"\n%}\n%include \"example.h\"\nsetup.py\n#!/usr/bin/env python\n\n\"\"\"\nsetup.py file for SWIG C\\+\\+/Python example\n\"\"\"\nfrom distutils.core import setup, Extension\n\nexample_module = Extension('_example',\n    sources=['example.cpp', 'example_wrap.cxx',],\n)\nsetup (\n    name = 'example',\n    version = '0.1',\n    author = \"www.99fang.com\",\n    description = \"\"\"Simple swig C\\+\\+/Python example\"\"\",\n    ext_modules = [example_module],\n    py_modules = [\"example\"],\n)\n\n\n运行以下命令:\nswig -c\\+\\+ -python example.i\npython setup.py build_ext --inplace\n\n如果编译无误的话，就可以测试啦：\n>>> import example\n>>> example.Example().say_hello()\nhello\n\n以上我用distutils构建了example module，也可以通过编译器直接构建, 比如：\ngcc -fPIC -I/usr/include/python2.5/ -lstdc\\+\\+ -shared -o _example.so example_wrap.cxx example.cpp\n\n注意，-fPIC和-lstdc++都是必要的。_example.so前的’_'也是必要的。\nSWIG生成代码说明\nswig -c++ -python example.i 命令生成了两个文件：example_wrap.cxx, example.py。example_wrap.cxx里会对Example类提供类使以下的扁平接口:\nExample* new_Example();\nvoid say_hello(Example* example);\nviod delete_Example(Example *example);\n\n这个接口被编译到_example.so里，_example可以做为一个 Python module 直接加载到 Python 解释器中。 example.py 利用 _example 里提供的接口，将扁平的接口还原为 Python 的 Example 类，这个类做为 C++ Example 类的代理类型，这样使用方式就更加自然了。\nSWIG接口文件的结构\nSWIG 接口文件指导 SWIG 生成包装代码，其中包含 %module 声明，接口声明 (%include “example.h”)，以及 %{ … %} 中的内容。%{ … %} 中的内容会原封不动地拷贝到生成的包装代码中，上节例子中的 #include “example.h” 是必要的，因为接口声明中仅是声明接口中要暴露哪些内容(Example类)，但如果没有 #include “example.h” 的话，生成的包装代码是无法通过编译的。\n常用功能说明\n处理输入输出参数\nC++包装的一个常见问题是有的C++函数以指针做为函数参数, 如：\nvoid add(int x, int y, int *result) {\n    *result = x + y;\n}\n\n或\nint sub(int *x, int *y) {\n    return *x-*y;\n}\n\n处理这种情况的最方便方式是使用SWIG库里的typemaps.i (关于SWIG库和Typemap见之后内容):\n%module example\n%include \"typemaps.i\"\n\nvoid add(int, int, int *OUTPUT);\nint sub(int *INPUT, int *INPUT);\n\n>>> a = add(3,4)\n>>> print a\n7\n>>> b = sub(7,4)\n>>> print b\n3\n\n另一种写法：\n\n%module example\n%include \"typemaps.i\"\n\n%apply int *OUTPUT { int *result };\n%apply int *INPUT { int *x, int *y};\n\nvoid add(int x, int y, int *result);\nint sub(int *x, int *y);\n\n对于既是输入又是输出参数的处理：\nvoid negate(int *x) {\n*x = -(*x);\n}\n-----------------------------\n%include \"typemaps.i\"\n...\nvoid negate(int *INOUT);\n\n-----------------------------\n>>> a = negate(3)\n>>> print a\n-3\n\n对于多个返回参数的处理：\n\n/* send message, return number of bytes sent, along with success code */\nint send_message(char *text, int len, int *success);\n-----------------------------\n\n%module example\n%include \"typemaps.i\"\n%apply int *OUTPUT { int *success };\n...\nint send_message(char *text, int *success);\n-----------------------------\n\nbytes, success = send_message(\"Hello World\")\nif not success:\nprint \"Whoa!\"\nelse:\nprint \"Sent\", bytes\n\n当输出都通过参数给出情况的处理：\nvoid get_dimensions(Matrix *m, int *rows, int *columns);\n\n%module example\n%include \"typemaps.i\"\n%apply int *OUTPUT { int *rows, int *columns };\n...\nvoid get_dimensions(Matrix *m, int *rows, *columns);\n\n>>> r,c = get_dimensions(m)\n\n注意，typemaps.i只支持了基本数据类型，所以不能写void foo(Bar *OUTPUT);，因为typemaps.i里没有对Bar定义OUTPUT规则。\nC数组实现\n有的C函数要求传入一个数组作为参数，调用这种函数时不能直接传入一个Python list或tuple, 有三种方式能解决这个问题：\n使用类型映射(Typemap), 将数组代码生成为Python list或tuple相应代码使用辅助函数，用辅助函数生成和操作数组对象，再结合在接口文件中插入一些Python代码，也可使Python直接传入list或tuple。这种方式在之后说明。使用SWIG库里的carrays.i这里先介绍carrays.i方式：\nint sumitems(int *first, int nitems) {\n    int i, sum = 0;\n    for (i = 0; i < nitems; i\\+\\+) {\n        sum += first[i];\n    }\n    return sum;\n}\n\n%include \"carrays.i\"\n%array_class(int, intArray);\n\n\n>>> a = intArray(10000000) # Array of 10-million integers\n>>> for i in xrange(10000): # Set some values\n... a[i] = i\n>>> sumitems(a,10000)\n49995000\n\n通过 %array_class 创建出来的数组是C数组的直接代理，非常底层和高效，但是，它也和C数组一样不安全，一样没有边界检查。\nC/C++辅助函数\n可以通过辅助函数来完一些SWIG本身不支持的功能。事实上，辅助函数可谓SWIG包装的瑞士军刀，一旦了解它使用，你可以使SWIG支持几乎所有你需要的功能，不过提醒一下，有很多C++特性是SWIG本身支持或者通过库支持的，不需要通过辅助函数实现。\n同样的，直接上例示代码：\nvoid set_transform(Image *im, double m[4][4]);\n\n>>> a = [\n... [1,0,0,0],\n... [0,1,0,0],\n... [0,0,1,0],\n... [0,0,0,1]]\n>>> set_transform(im,a)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in ?\nTypeError: Type error. Expected _p_a_4__double\n\n可以看到，set_transform是不能接受Python二维List的，可以用辅助函数帮助实现：\n%inline %{\n    /* Note: double[4][4] is equivalent to a pointer to an array double (*)[4] */\n    double (*new_mat44())[4] {\n    return (double (*)[4]) malloc(16*sizeof(double));\n}\nvoid free_mat44(double (*x)[4]) {\n    free(x);\n}\nvoid mat44_set(double x[4][4], int i, int j, double v) {\n    x[i][j] = v;\n}\ndouble mat44_get(double x[4][4], int i, int j) {\n    return x[i][j];\n}\n%}\n\n>>> a = new_mat44()\n>>> mat44_set(a,0,0,1.0)\n>>> mat44_set(a,1,1,1.0)\n>>> mat44_set(a,2,2,1.0)\n...\n>>> set_transform(im,a)\n>>>\n\n当然，这样使用起来还不够优雅，但可以工作了，接下来介绍通过插入额外的Python代码来让使用优雅起来。\n插入额外的Python代码\n为了让set_transform函数接受Python二维list或tuple，我们可以对它的Python代码稍加改造：\nvoid set_transform(Image *im, double x[4][4]);\n\n...\n/* Rewrite the high level interface to set_transform */\n%pythoncode %{\n    def set_transform(im,x):\n    a = new_mat44()\n    for i in range(4):\n    for j in range(4):\n    mat44_set(a,i,j,x[i][j])\n    _example.set_transform(im,a)\n    free_mat44(a)\n%}\n\n>>> a = [\n... [1,0,0,0],\n... [0,1,0,0],\n... [0,0,1,0],\n... [0,0,0,1]]\n>>> set_transform(im,a)\n\nSWIG还提供了%feature(“shadow”), %feature(“pythonprepend”), %feature(“pythonappend”)来支持重写某函数的代理函数，或在某函数前后插入额外代码，在%feature(“shadow”)中 可用$action来指代对C++相应函数的调用：\n%module example\n\n// Rewrite bar() python code\n\n%feature(\"shadow\") Foo::bar(int) %{\ndef bar(*args):\n#do something before\n$action\n#do something after\n%}\n\nclass Foo {\n    public:\n       int bar(int x);\n}\n\n或者：\n%module example\n\n// Add python code to bar() \n\n%feature(\"pythonprepend\") Foo::bar(int) %{\n#do something before C\\+\\+ call\n%}\n\n%feature(\"pythonappend\") Foo::bar(int) %{\n#do something after C\\+\\+ call\n%}\n\nclass Foo {\npublic:\nint bar(int x);\n}\n\n用%extend指示器扩展C++类\n你可以通过%extend指示器扩展C++类，甚至可用通过这种方式重载Python运算符：\n%module example\n%{\n#include \"someheader.h\"\n%}\n\nstruct Vector {\n   double x,y,z;\n};\n\n%extend Vector {\nchar *__str__() {\n    static char tmp[1024];\n    sprintf(tmp,\"Vector(%g,%g,%g)\", $self->x,$self->y,$self->z);\n    return tmp;\n}\nVector(double x, double y, double z) {\n    Vector *v = (Vector *) malloc(sizeof(Vector));\n    v->x = x;\n    v->y = y;\n    v->z = z;\n    return v;\n}\n\nVector __add__(Vector *other) {\n    Vector v;\n    v.x = $self->x + other->x;\n    v.y = $self->y + other->y;\n    v.z = $self->z + other->z;\n    return v;\n}\n\n};\n\n>>> v = example.Vector(2,3,4)\n>>> print v\nVector(2,3,4)\n>>> v = example.Vector(2,3,4)\n>>> w = example.Vector(10,11,12)\n>>> print v+w\nVector(12,14,16)\n\n注意，在%extend里this用$self代替。\n字符串处理\nSWIG将char 映射为Python的字符串，但是Python字符串是不可修改的（immutable），如果某函数有修改char ，很可能导致Python解释器崩溃。对由于这种情况，可以使用SWIG库里的cstring.i。\n模块\nSWIG通过%module指示器指定Python模块的名字\n函数及回调函数\n全局函数被包装为%module指示模块下的函数，如：\n%module example\nint add(int a, int b);\n\n>>>import example\n>>>print example.add(3, 4)\n7\n\n全局变量\nSWIG创建一个特殊的变量’cvar’来存取全局变量，如：\n%module example\n%inline %{\ndouble density = 2.5;\n%}\n\n>>>import example\n>>>print example.cvar.density\n2.5\n\ninline是另一个常见的SWIG指示器，用来在接口文件中插入C/C++代码，并将代码中声明的内容输出到接口中。\n常量和枚举变量\n用#define, enum或者%constant指定常量：\n#define PI 3.14159\n#define VERSION \"1.0\"\n\nenum Beverage { ALE, LAGER, STOUT, PILSNER };\n\n%constant int FOO = 42;\n%constant const char *path = \"/usr/local\";\n\n指针，引用，值和数组\nSWIG完整地支持指针：\n%module example\nFILE *fopen(const char *filename, const char *mode);\nint fputs(const char *, FILE *);\nint fclose(FILE *);\n\n>>> import example\n>>> f = example.fopen(\"junk\",\"w\")\n>>> example.fputs(\"Hello World\\n\", f)\n>>> example.fclose(f)\n>>> print f\n<Swig Object at _08a71808_p_FILE>\n>>> print str(f)\n_c0671108_p_FILE\n\n指针的裸值可以通过将指针对象转换成int获得，不过，无法通过一个int值构造出一个指针对象。\n>>> print int(f)\n135833352\n\n’0′或NULL被表示为None.\n对指针的类型转换或运算必须通过辅助函数完成，特殊要注意的是，对C++指针的类型转换，应该用C++方式的转换，而不是用C方式的转换，因为在转换无法完成是，C++方式的转换会返回NULL，而C方式的转换会返回一个无效的指针：\n%inline %{\n/* C-style cast */\nBar *FooToBar(Foo *f) {\n    return (Bar *) f;\n}\n\n/* C\\+\\+-style cast */\nFoo *BarToFoo(Bar *b) {\n   return dynamic_cast<Foo*>(b);\n}\n\nFoo *IncrFoo(Foo *f, int i) {\n   return f+i;\n}\n\n在C++中，函数参数可能是指针，引用，常量引用，值，数据等，SWIG将这些类型统一为指针类型处理（通过相应的包装代码）:\nvoid spam1(Foo *x); // Pass by pointer\nvoid spam2(Foo &x); // Pass by reference\nvoid spam3(const Foo &x);// Pass by const reference\nvoid spam4(Foo x); // Pass by value\nvoid spam5(Foo x[]); // Array of objects\n\n>>> f = Foo() # Create a Foo\n>>> spam1(f) # Ok. Pointer\n>>> spam2(f) # Ok. Reference\n>>> spam3(f) # Ok. Const reference\n>>> spam4(f) # Ok. Value.\n>>> spam5(f) # Ok. Array (1 element)\n\n返回值是也同样的：\nFoo *spam6();\nFoo &spam7();\nFoo spam8();\nconst Foo &spam9();\n\n这些函数都会统一为返回一个Foo指针。\n结构和类，以及继承结构和类是以Python类来包装的：\nstruct Vector {\n   double x,y,z;\n};\n\n>>> v = example.Vector()\n>>> v.x = 3.5\n>>> v.y = 7.2\n>>> print v.x, v.y, v.z\n7.8 -4.5 0.0\n>>>\n\n如果类或结构中包含数组，该数组是通过指针来操纵的：\nstruct Bar {\nint x[16];\n};\n\n>>> b = example.Bar()\n>>> print b.x\n_801861a4_p_int\n>>>\n\n对于数组赋值，SWIG会做数据的值拷贝：\n>>> c = example.Bar()\n>>> c.x = b.x # Copy contents of b.x to c.x\n\n但是，如果一个类或结构中包含另一个类或结构成员，赋值操作完全和指针操作相同。对于静态类成员函数，在Python中有三种访问方式:\nclass Spam {\n    public:\n        static int bar;\n        static void foo();\n};\n\n>>> example.Spam_foo() # Spam::foo()\n>>> s = example.Spam()\n>>> s.foo() # Spam::foo() via an instance\n>>> example.Spam.foo() # Spam::foo(). Python-2.2 only\n\n其中第三种方式Python2.2及以上版本才支持，因为之前版本的Python不支持静态类成员函数。\n静态类成员变量以全局变量方式获取：\n>>> print example.cvar.Spam_bar\n\nSWIG支持C++继承，可以用Python工具函数验证这一点：\nclass Foo {\n    ...\n};\n\nclass Bar : public Foo {\n    ...\n};\n\n>>> b = Bar()\n>>> instance(b,Foo)\n1\n>>> issubclass(Bar,Foo)\n1\n>>> issubclass(Foo,Bar)\n0\n\n同时，如果有形如void spam(Foo *f);的函数，可以传b = Bar()进去。\nSWIG支持多继承。\n重载\nSWIG支持C++重载：\nvoid foo(int);\nvoid foo(char *c);\n\n>>> foo(3) # foo(int)\n>>> foo(\"Hello\") # foo(char *c)\n但是，SWIG不能支持所有形式的C++重载，如：\n\nvoid spam(int);\nvoid spam(short);\n\n或\nvoid foo(Bar *b);\nvoid foo(Bar &b);\n\n这种形式的声明会让SWIG产生警告，可以通过重名命或忽略其中一个来避免这个警告：\n%rename(spam_short) spam(short);\n\n或\n%ignore spam(short);\n\n运算符重载\nSWIG能够自动处理运算符重载：\nclass Complex {\n    private:\n        double rpart, ipart;\n    public:\n        Complex(double r = 0, double i = 0) : rpart(r), ipart(i) { }\n        Complex(const Complex &c) : rpart(c.rpart), ipart(c.ipart) { }\n        Complex &operator=(const Complex &c);\n        \n        Complex operator+=(const Complex &c) const;\n        Complex operator+(const Complex &c) const;\n        Complex operator-(const Complex &c) const;\n        Complex operator*(const Complex &c) const;\n        Complex operator-() const;\n        \n        double re() const { return rpart; }\n        double im() const { return ipart; }\n};\n\n>>> c = Complex(3,4)\n>>> d = Complex(7,8)\n>>> e = c + d\n>>> e.re()\n10.0\n>>> e.im()\n12.0\n>>> c += d\n>>> c.re()\n10.0\n>>> c.im()\n12.0\n\n如果重载的运算符不是类的一部分，SWIG无法直接支持，如：\nclass Complex {\n    ...\n    friend Complex operator+(double, const Complex &c);\n    ...\n};\n\n这种情况下SWIG是报一个警告，不过还是可以通过一个特殊的函数，来包装这个运算符：\n%rename(Complex_add_dc) operator+(double, const Complex &);\n\n不过，有的运算符无法清晰地映射到Python表示，如赋值运算符，像这样的重载会被忽略。\n名字空间\n名字空间不会映射成Python的模块名，如果不同名字空间有同名实体要暴露到接口中，可以通过重命名指示器解决：\n%rename(Bar_spam) Bar::spam;\n\nnamespace Foo {\n    int spam();\n}\n\nnamespace Bar {\n    int spam();\n}\n\n模板\nSWIG对C/C++的包装是二进制级别的，但C++模板根本不是二进制级别的概念，所以对模板的包装需要将模板实例化，SWIG提供%template指示器支持这项功能：\n%module example\n%{\n#include \"pair.h\"\n%}\n\ntemplate<class T1, class T2>\nstruct pair {\n    typedef T1 first_type;\n    typedef T2 second_type;\n    T1 first;\n    T2 second;\n    pair();\n    pair(const T1&, const T2&);\n    ~pair();\n};\n\n%template(pairii) pair<int,int>;\n\n>>> import example\n>>> p = example.pairii(3,4)\n>>> p.first\n3\n>>> p.second\n4\n\n如果你要同时映射一个模板，以及以这个模板为参数的另一个模板，还要做一点特殊的工作, 比如，同时映射pair< string, string >和 vector< pair <string, string> >，需要像下面这样做：\n%module testpair\n%include \"std_string.i\"\n%include \"std_vector.i\"\n%include \"std_pair.i\"\n%{\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n%}\n\n%template(StringPair) std::pair<std::string ,std::string>;\nSWIG_STD_VECTOR_SPECIALIZE_MINIMUM(StringPair, std::pair< std::string, std::string >);\n%template(StringPairVector) std::vector< std::pair<std::string, std::string> >;\n\n遗憾的是，我并没有在文档中发现对这种做法的说明，以上做法是在swig用户组中问到的。\n智能指针\n有的函数的返回值是智能指针，为了调用这样的函数，只需要对智能指针类型做相应声明：\n%module example\n...\n%template(SmartPtrFoo) SmartPtr<Foo>;\n...\n\n>>> p = example.CreateFoo() # CreatFool()返回一个SmartPtr<Foo>\n>>> p.x = 3 # Foo::x\n>>> p.bar() # Foo::bar\n\n可以通过p.__deref__()得到相应的Foo*\n引用记数对象支持\n对于使用引用记数惯例的C++对象，SWIG提供了%ref和%unref指示器支持，使用Python里使用时不用手工调用ref和unref函数。因为我们目前没有使用引用记数技术，具体细节这里不详述了。\n内存管理\nSWIG是通过在Python里创建C++相应类型的代理类型来包装C++的，每个Python代理对象里有一个.thisown的标志，这个标志 决定此代理对象是否负责相应C++对象的生命周期：如果.thisown这个标志为1，Python解释器在回收Python代理对象时也会销毁相应的 C++对象，如果没有这个标志或这个标志的值是0，则Python代理对象回收时不影响相应的C++对象。\n当创建对象，或通过值返回方式获得对象时，代理对象自动获得.thisown标志。当通过指针方式获得对象时，代理对象.thisown的值为0：\nclass Foo {\n    public:\n        Foo();\n        Foo bar();\n        Foo *spam();\n};\n\n>>> f = Foo()\n>>> f.thisown\n1\n>>> g = f.bar()\n>>> g.thisown\n1\n>>> f = Foo()\n>>> s = f.spam()\n>>> print s.thisown\n0\n\n当这种行为不是期望的行为的时候，可以人工设置这个标志的值：\n>>> v.thisown = 0\n\n跨语言多态\n当你希望用Python扩展（继承）C++的类型的时候，你就需要跨语言多态支持了。SWIG提供了一个调度者(director)特性支持此功能，但此特性默认是关闭的，通过以下方式打开此特性：\n首先，在module指示器里打开\n%module(directors=\"1\") modulename\n\n其次，通过%feature指示器告诉SWIG哪些类和函数需要跨语言多态支持：\n// generate directors for all classes that have virtual methods\n%feature(\"director\"); \n\n// generate directors for all virtual methods in class Foo\n%feature(\"director\") Foo; \n\n// generate a director for just Foo::bar()\n%feature(\"director\") Foo::bar;\n\n可以使用%feature(“nodirector”)指示器关闭某个类型或函数的的跨语言多态支持：\n%feature(\"director\") Foo;\n%feature(\"nodirector\") Foo::bar;\n\n类型映射(Typemaps)\n类型映射是SWIG最核心的一部分，类型映射就是告诉SWIG对某个C类型，生成什么样的代码。不过，SWIG的文档里说类型映射是SWIG的高级自定义部分，不是使用SWIG需要理解的，除非你要提升自己的NB等级 \n以下的类型映射可用于将整数从Python转换为C:\n%module example\n\n%typemap(in) int {\n    $1 = (int) PyLong_AsLong($input);\n    printf(\"Received an integer : %d\\n\",$1);\n}\n%inline %{\n    int add(int a, int b){\n    return a+b;\n}\n%}\n\n>>> import example\n>>> example.add(3,4)\nReceived an integer : 3\nReceived an integer : 4\n7\n\nSWIG库\nSWIG提供了一组库文件，用以支持常用的包装，如数组，标准库等。可以在接口文件中引入这些库文件。比如，在%include “std_string.i”后，就可以直接给需要string参数数的函数传Python字符串了。对”std_vector.i”举例如下：\n%module example\n%include \"std_vector.i\"\n\nnamespace std {\n%template(vectori) vector<int>;\n};\n\n>>> from example import *\n>>> v = vectori()\n>>> v.push_back(1)\n>>> print v.size()\n1\n\n参考资料\n\nSWIG和Python: http://www.swig.org/Doc1.3/SWIGDocumentation.html#Python\n\nSWIG基础： http://www.swig.org/Doc1.3/SWIGDocumentation.html#SWIG\n\nSWIG和C++: http://www.swig.org/Doc1.3/SWIGDocumentation.html#SWIGPlus\n\n\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "1"}