{"title": "Flask 扩展系列之 Flask-RESTful - 一口袋码 ", "index": "flask-restful,flask,python", "content": "大纲\n\n简介\n安装\n\n快速入门\n\n一个最小的 api 例子\n资源丰富的路由\n端点\n参数解析\n数据格式化\n\n\n完整 TODO 应用例子\n\n简介\nFlask-RESTful是一个Flask的扩展，它增加了对快速构建REST APIs的支持。它是一种轻量级的抽象，可以与现有的ORM/库一起工作。Flask-RESTful励以最少的安装方式进行最佳实践。如果你对Flask很熟悉的，Flask-RESTful会很容易上手。\n安装\n本文环境：python3\npip3 install flask-restful\n快速入门\n一个最小的API\n下面来编写一个最小的Flask-RESTful API:\nfrom flask import Flask\nfrom flask_restful import Resource, Api\n\napp = Flask(__name__)\napi = Api(app)\n\nclass HelloWorld(Resource):\n    def get(self):\n        return {'hello': 'world'}\n\napi.add_resource(HelloWorld, '/')\n\nif __name__ == '__main__':\n    app.run(debug=True) \n保存代码到api.py测试时打开debug模式会提供代码重载，以及更详细的错误信息。注意调试模式不可用在生产环境。接下来打开命令窗口输入命令执行py 文件\n$ python api.py\n * Running on http://127.0.0.1:5000/\n * Restarting with reloader\n新建一个命令窗口，使用curl测试下API\n$ curl http://127.0.0.1:5000/\n{\"hello\": \"world\"}\n资源丰富的路由\nFlask-RESTful 提供的最主要的基础就是资源，资源是构建在Flask 可插拔的视图之上，只要在你的资源上定义方法就能很容易的访问多个 HTTP 方法，一个待办事项应用的基础 CRUD资源的编写像这样：\nfrom flask import Flask, request\nfrom flask_restful import Resource, Api\n\napp = Flask(__name__)\napi = Api(app)\n\ntodos = {}\n\nclass TodoSimple(Resource):\n    def get(self, todo_id):\n        # 从 todos 字典中读取数据 注:此处没有对不存在的 key 做处理\n        return {todo_id: todos[todo_id]}\n\n    def put(self, todo_id):\n        # 将数据保存到 todos 字典中\n        todos[todo_id] = request.form['data']\n        return {todo_id: todos[todo_id]}\n\n# 增加资源到 api, 匹配字符串到资源方法的变量\napi.add_resource(TodoSimple, '/<string:todo_id>')\n\nif __name__ == '__main__':\n    app.run(debug=True)\n保存到文件后执行，使用 curl测试一下\n$ curl http://localhost:5000/todo1 -d \"data=Remember the milk\" -X PUT\n{\"todo1\": \"Remember the milk\"}\n\n$ curl http://localhost:5000/todo1\n{\"todo1\": \"Remember the milk\"}\n\n$ curl http://localhost:5000/todo2 -d \"data=Change my brakepads\" -X PUT\n{\"todo2\": \"Change my brakepads\"}\n\n$ curl http://localhost:5000/todo2\n{\"todo2\": \"Change my brakepads\"}\n如果有安装 python 的 requests 库也可以用以下方法测试 （Python库系列之requests）：\n>>> from requests import put, get\n>>> put('http://localhost:5000/todo1', data={'data': 'Remember the milk'}).json()\n{'todo1': 'Remember the milk'}\n>>> get('http://localhost:5000/todo1').json()\n{u'todo1': u'Remember the milk'}\n>>> put('http://localhost:5000/todo2', data={'data': 'Change my brakepads'}).json()\n{u'todo2': u'Change my brakepads'}\n>>> get('http://localhost:5000/todo2').json()\n{u'todo2': u'Change my brakepads'}\nFlask-RESTful支持视图方法多种类型的返回值，像 Flask 一样，你可以返回任何迭代器，它会被转化成一个包含原始响应对象的响应，Flask-RESTful还支持使用多个返回时来设置响应码以及响应头，如下：\nclass Todo1(Resource):\n    def get(self):\n        # 默认返回200\n        return {'task': 'Hello world'}\n\nclass Todo2(Resource):\n    def get(self):\n        # 将响应码设为201\n        return {'task': 'Hello world'}, 201\n\nclass Todo3(Resource):\n    def get(self):\n        # 将响应码设置为201,并返回自定义头\n        return {'task': 'Hello world'}, 201, {'Etag': 'some-opaque-string'}\n\napi.add_resource(Todo1, '/t1')\napi.add_resource(Todo2, '/t2')\napi.add_resource(Todo3, '/t3')\n保存到文件后执行，使用 curl 测试一下\n$curl http://127.0.0.1:5000/t1 -I\nHTTP/1.0 200 OK\nContent-Type: application/json\nContent-Length: 30\nServer: Werkzeug/0.12.2 Python/3.6.4\nDate: Wed, 03 Jan 2018 15:07:07 GMT\n\n$curl http://127.0.0.1:5000/t2 -I\nHTTP/1.0 201 CREATED\nContent-Type: application/json\nContent-Length: 30\nServer: Werkzeug/0.12.2 Python/3.6.4\nDate: Wed, 03 Jan 2018 15:07:10 GMT\n\n$curl http://127.0.0.1:5000/t3 -I\nHTTP/1.0 201 CREATED\nContent-Type: application/json\nContent-Length: 30\nEtag: some-opaque-string\nServer: Werkzeug/0.12.2 Python/3.6.4\nDate: Wed, 03 Jan 2018 15:05:58 GMT\n端点\n很多时候在一个 API 中，你的资源可以通过多个URLs访问。你可以把多个 URLs 传给 Api 对象的 add_resource() 方法。每一个 URL 都能访问到你的资源\napi.add_resource(HelloWorld,\n    '/',\n    '/hello')\n你还可以将路径的部分匹配为资源方法的变量\napi.add_resource(Todo,\n    '/todo/<int:todo_id>', endpoint='todo_ep')\n注：如果一个请求与你的应用程序端点中的任何一个都不匹配，Flask-RESTful 将会返回404错误，并附带一段有关其它最相似匹配的端点建议。你可以通过在配置中将ERROR_404_HELP设置为 False禁用此项。\n\n参数解析\n尽管 Flask 提供了便捷的方式获取请求的数据（例：查询字符串或POST 表单编码的数据），验证表单依旧很痛苦。Flask-RESTful 内置了支持验证请求数据，它使用了一个类似argparse 的库。\nfrom flask_restful import reqparse\n\nparser = reqparse.RequestParser()\nparser.add_argument('rate', type=int, help='Rate to charge for this resource')\nargs = parser.parse_args()\n注：与 argparse 模块不同的是，reqparse.RequestParser.parse_args() 返回了 Python 字典而不是一个自定义的数据结构。\n使用 reqparse 模块同样可以自由地提供全面的错误信息。如果一个参数没有通过校验，Flask-RESTful 将会以一个400的错误请求以及高亮的错误信息回应。\n$ curl -d 'rate=foo' http://127.0.0.1:5000/todos\n{'status': 400, 'message': 'foo cannot be converted to int'}\ninputs模块提供许多常用的转换函数，像 inputs.date() 和 inputs.url()。\n调用 parse_args 传入 strict=True 能够确保当请求包含了你的解析器中未定义的参数时抛出一个异常。\nargs = parser.parse_args(strict=True)\n数据格式化\n默认情况下，在你的迭代返回中所有的字段都将会原样呈现。当你处理 Python 数据结构的时候会觉得它很棒，但在处理对象时会变得非常令人沮丧。为了解决这个问题，Flask-RESTful 提供了fields 模块以及 marshal_with()装饰器。类似 Django ORM 和 WTForm ，你可以使用 fields 模块来描述响应的数据结构。\nfrom flask_restful import fields, marshal_with\n\nresource_fields = {\n    'task':   fields.String,\n    'uri':    fields.Url('todo_ep')\n}\n\nclass TodoDao(object):\n    def __init__(self, todo_id, task):\n        self.todo_id = todo_id\n        self.task = task\n\n        # This field will not be sent in the response\n        self.status = 'active'\n\nclass Todo(Resource):\n    @marshal_with(resource_fields)\n    def get(self, **kwargs):\n        return TodoDao(todo_id='my_todo', task='Remember the milk')\n上面的例子接收了一个 python对象并准备将其序列化。marshal_with()装饰器会通过resource_fields()进行转换。从对象中提取的唯一字段是 task。fields.Url是一个特殊的字段，它接受端点名称并为响应中的端点生成一个URL。您需要的许多字段类型已经包含在其中。可以查看 fields 项查看完整列表。\n完整 TODO 应用例子\nfrom flask import Flask\nfrom flask_restful import reqparse, abort, Api, Resource\n\napp = Flask(__name__)\napi = Api(app)\n\nTODOS = {\n    'todo1': {'task': 'build an API'},\n    'todo2': {'task': '?????'},\n    'todo3': {'task': 'profit!'},\n}\n\n\ndef abort_if_todo_doesnt_exist(todo_id):\n    if todo_id not in TODOS:\n        abort(404, message=\"Todo {} doesn't exist\".format(todo_id))\n\nparser = reqparse.RequestParser()\nparser.add_argument('task')\n\n\n# Todo\n# 显示单个待办任务，并允许删除待办任务项\nclass Todo(Resource):\n    def get(self, todo_id):\n        abort_if_todo_doesnt_exist(todo_id)\n        return TODOS[todo_id]\n\n    def delete(self, todo_id):\n        abort_if_todo_doesnt_exist(todo_id)\n        del TODOS[todo_id]\n        return '', 204\n\n    def put(self, todo_id):\n        args = parser.parse_args()\n        task = {'task': args['task']}\n        TODOS[todo_id] = task\n        return task, 201\n\n\n# TodoList\n# 展示所有 todos 的列表，允许以POST的方式新建一个 tasks\nclass TodoList(Resource):\n    def get(self):\n        return TODOS\n\n    def post(self):\n        args = parser.parse_args()\n        todo_id = int(max(TODOS.keys()).lstrip('todo')) + 1\n        todo_id = 'todo%i' % todo_id\n        TODOS[todo_id] = {'task': args['task']}\n        return TODOS[todo_id], 201\n\n# 设置 api 资源路由\napi.add_resource(TodoList, '/todos')\napi.add_resource(Todo, '/todos/<todo_id>')\n\n\nif __name__ == '__main__':\n    app.run(debug=True)\n例子使用：\n$ python api.py\n * Running on http://127.0.0.1:5000/\n * Restarting with reloader\n获取 Todo 列表\n$ curl http://localhost:5000/todos\n{\"todo1\": {\"task\": \"build an API\"}, \"todo3\": {\"task\": \"profit!\"}, \"todo2\": {\"task\": \"?????\"}}\n获取单个 Todo 任务\n$ curl http://localhost:5000/todos/todo3\n{\"task\": \"profit!\"}\n删除一个任务\n$ curl http://localhost:5000/todos/todo2 -X DELETE -v\n\n> DELETE /todos/todo2 HTTP/1.1\n> Host: localhost:5000\n> User-Agent: curl/7.52.1\n> Accept: */*\n>\n* HTTP 1.0, assume close after body\n< HTTP/1.0 204 NO CONTENT\n< Content-Type: application/json\n< Content-Length: 0\n< Server: Werkzeug/0.12.2 Python/3.6.4\n< Date: Wed, 03 Jan 2018 16:07:19 GMT\n添加一个新的任务\n$ curl http://localhost:5000/todos -d \"task=something new\" -X POST -v\n\n> POST /todos HTTP/1.1\n> Host: localhost:5000\n> User-Agent: curl/7.52.1\n> Accept: */*\n> Content-Length: 18\n> Content-Type: application/x-www-form-urlencoded\n>\n* upload completely sent off: 18 out of 18 bytes\n* HTTP 1.0, assume close after body\n< HTTP/1.0 201 CREATED\n< Content-Type: application/json\n< Content-Length: 32\n< Server: Werkzeug/0.12.2 Python/3.6.4\n< Date: Wed, 03 Jan 2018 16:05:27 GMT\n<\n{\n    \"task\": \"something new\"\n}\n* Curl_http_done: called premature == 0\n* Closing connection 0\n更新任务\n$ curl http://localhost:5000/todos/todo3 -d \"task=something different\" -X PUT -v\n\n> PUT /todos/todo3 HTTP/1.1\n> Host: localhost:5000\n> User-Agent: curl/7.52.1\n> Accept: */*\n> Content-Length: 24\n> Content-Type: application/x-www-form-urlencoded\n>\n* upload completely sent off: 24 out of 24 bytes\n* HTTP 1.0, assume close after body\n< HTTP/1.0 201 CREATED\n< Content-Type: application/json\n< Content-Length: 38\n< Server: Werkzeug/0.12.2 Python/3.6.4\n< Date: Wed, 03 Jan 2018 16:09:05 GMT\n<\n{\n    \"task\": \"something different\"\n}\n* Curl_http_done: called premature == 0\n* Closing connection 0\n本文关键词\n\nPython\nFlask-RESTful\ncurl\nrequests\n\n更多阅读\nFlask-RESTful — Flask-RESTful 0.3.6 documentation \n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "5"}