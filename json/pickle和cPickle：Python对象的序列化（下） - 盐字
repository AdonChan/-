{"title": "pickle和cPickle：Python对象的序列化（下） - 盐字 ", "index": "技术文档,多进程,序列化,python", "content": "\n  承接上文 pickle和cPickle：Python对象的序列化（上） 。\n\n\n重构对象的问题\n\n当与你自己的类一起工作时，你必须保证类被腌渍出现在读取pickle的进程的命名空间中。只有该实例的数据而不是类定义被腌渍。类名被用于在反腌渍时，找到构造器（constructor）以创建新对象。以此——往一个文件写入一个类的实例为例：\n\npythontry:\n    import cPickle as pickle\nexcept:\n    import pickle\nimport sys\n\nclass SimpleObject(object):\n\n    def __init__(self, name):\n        self.name = name\n        l = list(name)\n        l.reverse()\n        self.name_backwards = ''.join(l)\n        return\n\nif __name__ == '__main__':\n    data = []\n    data.append(SimpleObject('pickle'))\n    data.append(SimpleObject('cPickle'))\n    data.append(SimpleObject('last'))\n\n    try:\n        filename = sys.argv[1]\n    except IndexError:\n        raise RuntimeError('Please specify a filename as an argument to %s' % sys.argv[0])\n\n    out_s = open(filename, 'wb')\n    try:\n        # 写入流中\n        for o in data:\n            print 'WRITING: %s (%s)' % (o.name, o.name_backwards)\n            pickle.dump(o, out_s)\n    finally:\n        out_s.close()\n\n\n在运行时，该脚本创建一个以在命令行指定的参数为名的文件：\n\npython$ python pickle_dump_to_file_1.py test.dat\n\nWRITING: pickle (elkcip)\nWRITING: cPickle (elkciPc)\nWRITING: last (tsal)\n\n\n一个在读取结果腌渍对象失败的简化尝试：\n\npythontry:\n    import cPickle as pickle\nexcept:\n    import pickle\nimport pprint\nfrom StringIO import StringIO\nimport sys\n\n\ntry:\n    filename = sys.argv[1]\nexcept IndexError:\n    raise RuntimeError('Please specify a filename as an argument to %s' % sys.argv[0])\n\nin_s = open(filename, 'rb')\ntry:\n    # 读取数据\n    while True:\n        try:\n            o = pickle.load(in_s)\n        except EOFError:\n            break\n        else:\n            print 'READ: %s (%s)' % (o.name, o.name_backwards)\nfinally:\n    in_s.close()\n\n\n该版本失败的原因在于没有 SimpleObject 类可用：\n\npython$ python pickle_load_from_file_1.py test.dat\n\nTraceback (most recent call last):\n  File \"pickle_load_from_file_1.py\", line 52, in <module>\n    o = pickle.load(in_s)\nAttributeError: 'module' object has no attribute 'SimpleObject'\n\n\n正确的版本从原脚本中导入 SimpleObject ，可成功运行。\n添加：\n\npythonfrom pickle_dump_to_file_1 import SimpleObject\n\n\n至导入列表的尾部，接着重新运行该脚本：\n\npython$ python pickle_load_from_file_2.py test.dat\n\nREAD: pickle (elkcip)\nREAD: cPickle (elkciPc)\nREAD: last (tsal)\n\n\n当腌渍有值的数据类型不能被腌渍时（套接字、文件句柄（file handles）、数据库连接等之类的），有一些特别的考虑。因为使用值而不能被腌渍的类，可以定义 __getstate__() 和 __setstate__() 来返回状态（state）的一个子集，才能被腌渍。新式类（New-style classes）也可以定义__getnewargs__()，该函数应当返回被传递至类内存分配器（the class memory allocator）（C.__new__()）的参数。使用这些新特性的更多细节，包含在标准库文档中。\n\n环形引用（Circular References）\n\npickle协议（pickle protocol）自动处理对象间的环形引用，因此，即使是很复杂的对象，你也不用特别为此做什么。考虑下面这个图：\n\n\n\n上图虽然包括几个环形引用，但也能以正确的结构腌渍和重新读取（reloaded）。\n\npythonimport pickle\n\nclass Node(object):\n    \"\"\"\n    一个所有结点都可知它所连通的其它结点的简单有向图。\n    \"\"\"\n    def __init__(self, name):\n        self.name = name\n        self.connections = []\n        return\n\n    def add_edge(self, node):\n        \"创建两个结点之间的一条边。\"\n        self.connections.append(node)\n        return\n\n    def __iter__(self):\n        return iter(self.connections)\n\ndef preorder_traversal(root, seen=None, parent=None):\n    \"\"\"产生器（Generator ）函数通过一个先根遍历（preorder traversal）生成（yield）边。\"\"\"\n    if seen is None:\n        seen = set()\n    yield (parent, root)\n    if root in seen:\n        return\n    seen.add(root)\n    for node in root:\n        for (parent, subnode) in preorder_traversal(node, seen, root):\n            yield (parent, subnode)\n    return\n\ndef show_edges(root):\n    \"打印图中的所有边。\"\n    for parent, child in preorder_traversal(root):\n        if not parent:\n            continue\n        print '%5s -> %2s (%s)' % (parent.name, child.name, id(child))\n\n# 创建结点。\nroot = Node('root')\na = Node('a')\nb = Node('b')\nc = Node('c')\n\n# 添加边。\nroot.add_edge(a)\nroot.add_edge(b)\na.add_edge(b)\nb.add_edge(a)\nb.add_edge(c)\na.add_edge(a)\n\nprint 'ORIGINAL GRAPH:'\nshow_edges(root)\n\n# 腌渍和反腌渍该图来创建\n# 一个结点集合。\ndumped = pickle.dumps(root)\nreloaded = pickle.loads(dumped)\n\nprint\nprint 'RELOADED GRAPH:'\nshow_edges(reloaded)\n\n\n重新读取的诸多节点（译者注：对应图中的圆圈）不再是同一个对象，但是节点间的关系保持住了，而且读取的仅仅是带有多个引用的对象的一个拷贝。上面所说的可以通过测试各节点在pickle处理前和之后的id()值来验证。\n\npython$ python pickle_cycle.py\n\nORIGINAL GRAPH:\n root ->  a (4299721744)\n    a ->  b (4299721808)\n    b ->  a (4299721744)\n    b ->  c (4299721872)\n    a ->  a (4299721744)\n root ->  b (4299721808)\n\nRELOADED GRAPH:\n root ->  a (4299722000)\n    a ->  b (4299722064)\n    b ->  a (4299722000)\n    b ->  c (4299722128)\n    a ->  a (4299722000)\n root ->  b (4299722064)\n\n\n\n  原文 pickle and cPickle – Python object serialization - Python Module of the Week 的后半部分。\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "3"}