{"title": "让我们一起来构建一个模板引擎（三） - mozillazg 的学习笔记 ", "index": "模板引擎,python", "content": "在 上篇文章 中我们的模板引擎实现了对 if 和 for 对支持，同时在文章的最后我给大家留了一个 问题：如何实现支持 include 和 extends 的标签功能。\n在本篇文章中我们将一起来动手实现这两个功能。\ninclude\ninclude 标签对语法是这样的：假设有一个 item.html 模板文件，它的内容如下:\n<li>{{ item }}</li>\n还有一个我们要渲染的模板 list.html 内容如下:\n<ul>\n  {% for item in items %}\n    {% include \"item.html\" %}\n  {% endfor %}\n</ul>\n渲染 list.html 后的结果类似:\n<ul>\n  <li>item1</li>\n  <li>item2</li>\n  <li>item3</li>\n</ul>\n从上面可以看出来 include 标签的作用类似使用 include 所在位置的名字空间 渲染另一个模板然后再使用渲染后的结果。所以我们可以将 include 的模板文件 当作普通的模板文件来处理，用解析那个模板生成后的代码替换 include 所在的位置， 再将结果追加到 result_var 。 生成的代码类似:\ndef func_name():\n    result = []\n\n    # 解析 include 的模板\n    def func_name_include():\n        result_include = []\n        return ''.join(result_include)\n    # 调用生成的 func_name_include 函数获取渲染结果\n    result.append(func_name_include())\n\n    return ''.join(result)\n生成类似上面的代码就是 include 的关键点，下面看一下实现 include 功能 都做了哪些改动 (可以从 Github 上下载 template3a.py):\nclass Template:\n\n    def __init__(self, ..., template_dir='', encoding='utf-8'):\n        # ...\n        self.template_dir = template_dir\n        self.encoding = encoding\n        # ...\n\n    def _handle_tag(self, token):\n        \"\"\"处理标签\"\"\"\n        # ...\n        tag_name = tag.split()[0]\n        if tag_name == 'include':\n            self._handle_include(tag)\n        else:\n            self._handle_statement(tag)\n\n    def _handle_include(self, tag):\n        filename = tag.split()[1].strip('\"\\'')\n        included_template = self._parse_another_template_file(filename)\n        # 把解析 include 模板后得到的代码加入当前代码中\n        # def __func_name():\n        #    __result = []\n        #    ...\n        #    def __func_name_hash():\n        #        __result_hash = []\n        #        return ''.join(__result_hash)\n        self.code_builder.add(included_template.code_builder)\n        # 把上面生成的代码中函数的执行结果添加到原有的结果中\n        # __result.append(__func_name_hash())\n        self.code_builder.add_line(\n            '{0}.append({1}())'.format(\n                self.result_var, included_template.func_name\n            )\n        )\n\n    def _parse_another_template_file(self, filename):\n        template_path = os.path.realpath(\n            os.path.join(self.template_dir, filename)\n        )\n        name_suffix = str(hash(template_path)).replace('-', '_')\n        func_name = '{}_{}'.format(self.func_name, name_suffix)\n        result_var = '{}_{}'.format(self.result_var, name_suffix)\n        with open(template_path, encoding=self.encoding) as fp:\n            template = self.__class__(\n                fp.read(), indent=self.code_builder.indent,\n                default_context=self.default_context,\n                func_name=func_name, result_var=result_var,\n                template_dir=self.template_dir\n            )\n        return template\n首先是 __init__ 增加了两个参数 template_dir 和 encoding:\n\ntemplate_dir: 指定模板文件夹路径，因为 include 的模板是相对路径所以需要这个 选项来获取模板的绝对路径\nencoding: 指定模板文件的编码，默认是 utf-8\n\n然后就是 _parse_another_template_file 了，这个方法是用来解析 include 中 指定的模板文件的，其中的 func_name 和 result_var 之所以加了个 hash 值 作为后缀是不想跟其他函数变量重名。\n_handle_include 实现的是解析 include 的模板， 然后将生成的代码和代码中函数的执行结果添加到当前代码中。\n下面来看一下实现的效果。还是用上面的模板文件:\nitem.html:\n<li>{{ item }}</li>\nlist.html:\n<ul>\n  {% for item in items %}\n    {% include \"item.html\" %}\n  {% endfor %}\n</ul>\n先来看一下生成的代码:\n>>> from template3a import Template\n>>> text = open('list.html').read()\n>>> t = Template(text)\n>>> t.code_builder\ndef __func_name():\n    __result = []\n    __result.extend(['<ul>\\n  '])\n    for item in items:\n        __result.extend(['\\n    '])\n        def __func_name_7654650009897399020():\n            __result_7654650009897399020 = []\n            __result_7654650009897399020.extend(['<li>',str(item),'</li>\\n'])\n            return \"\".join(__result_7654650009897399020)\n        __result.append(__func_name_7654650009897399020())\n        __result.extend(['\\n  '])\n    __result.extend(['\\n</ul>\\n'])\n    return \"\".join(__result)\n然后是渲染效果:\n>>> print(t.render({'items': ['item1', 'item2', 'item3']}))\n<ul>\n\n    <li>item1</li>\n\n\n    <li>item2</li>\n\n\n    <li>item3</li>\n\n\n</ul>\ninclude 已经实现了，下面让我们一起来实现 extends 功能。\nextends\nextends 标签实现的是模板继承的功能，并且只能在第一行出现，语法如下:\n假设有一个 parent.html 文件它的内容是:\n<div id=\"header\">{% block header %} parent_header {% endblock header %}</div>\n<div id=\"footer\">{% block footer %} parent_footer {% endblock footer %}</div>\n还有一个 child.html 文件:\n{% extends \"parent.html\" %}\n{% block header %} child_header {{ block.super }} {% endblock header %}\nchild.html 渲染后的结果:\n<div id=\"header\"> child_header parent_header </div>\n<div id=\"footer\"> parent_footer </div>\n可以看到 extends 的效果类似用子模板里的 block 替换父模板中定义的同名 block, 同时又可以使用 {{ block.super }} 引用父模板中定义的内容，有点类似 class 的继承效果。\n注意我刚才说的是: 类似用子模板里的 block 替换父模板中定义的同名 block 。\n这个就是 extends 的关键点，我们可以先找出子模板里定义的 block ， 然后用子模板里的 block 替换父模板里的同名 block , 最后只处理替换后的父模板就可以了。\n暂时先不管 block.super ，支持 extends 的代码改动如下(可以从 Github 下载 template3b.py ):\nclass Template:\n    def __init__(self, ...):\n        # extends\n        self.re_extends = re.compile(r'\\{% extends (?P<name>.*?) %\\}')\n        # blocks\n        self.re_blocks = re.compile(\n            r'\\{% block (?P<name>\\w+) %\\}'\n            r'(?P<code>.*?)'\n            r'\\{% endblock \\1 %\\}', re.DOTALL)\n\n    def _parse_text(self):\n        # extends\n        self._handle_extends()\n\n        tokens = self.re_tokens.split(self.raw_text)\n        # ...\n\n    def _handle_extends(self):\n        match_extends = self.re_extends.match(self.raw_text)\n        if match_extends is None:\n            return\n\n        parent_template_name = match_extends.group('name').strip('\"\\' ')\n        parent_template_path = os.path.join(\n            self.template_dir, parent_template_name\n        )\n        # 获取当前模板里的所有 blocks\n        child_blocks = self._get_all_blocks(self.raw_text)\n        # 用这些 blocks 替换掉父模板里的同名 blocks\n        with open(parent_template_path, encoding=self.encoding) as fp:\n            parent_text = fp.read()\n        new_parent_text = self._replace_parent_blocks(\n            parent_text, child_blocks\n        )\n        # 改为解析替换后的父模板内容\n        self.raw_text = new_parent_text\n\n    def _replace_parent_blocks(self, parent_text, child_blocks):\n        \"\"\"用子模板的 blocks 替换掉父模板里的同名 blocks\"\"\"\n        def replace(match):\n            name = match.group('name')\n            parent_code = match.group('code')\n            child_code = child_blocks.get(name)\n            return child_code or parent_code\n        return self.re_blocks.sub(replace, parent_text)\n\n    def _get_all_blocks(self, text):\n        \"\"\"获取模板内定义的 blocks\"\"\"\n        return {\n            name: code\n            for name, code in self.re_blocks.findall(text)\n        }\n从上面的代码可以看出来我们遵循的是使用子模板 block 替换父模板同名 block 然后改为解析替换后的父模板的思路. 即，虽然我们要渲染的是:\n{% extends \"parent.html\" %}\n{% block header %} child_header {% endblock header %}\n实际上我们最终渲染的是替换后的父模板:\n<div id=\"header\"> child_header </div>\n<div id=\"footer\"> parent_footer </div>\n依旧是来看一下实际效果:\nparent1.html:\n<div id=\"header\">{% block header %} parent_header {% endblock header %}</div>\n<div id=\"footer\">{% block footer %} parent_footer {% endblock footer %}</div>\nchild1.html:\n{% extends \"parent1.html\" %}\n{% block header %} {{ header }} {% endblock header %}\n看看最后要渲染的模板字符串:\n>>> from template3b import Template\n>>> text = open('child1.html').read()\n>>> t = Template(text)\n>>> print(t.raw_text)\n<div id=\"header\"> {{ header }} </div>\n<div id=\"footer\"> parent_footer </div>\n可以看到确实是替换后的内容，再来看一下生成的代码和渲染后的效果:\n>>> t.code_builder\ndef __func_name():\n    __result = []\n    __result.extend(['<div id=\"header\"> ',str(header),' </div>\\n<div id=\"footer\"> parent_footer </div>\\n'])\n    return \"\".join(__result)\n\n>>> print(t.render({'header': 'child_header'}))\n<div id=\"header\"> child_header </div>\n<div id=\"footer\"> parent_footer </div>\nextends 的基本功能就这样实现了。下面再实现一下 {{ block.super }} 功能。\nblock.super\n{{ block.super }} 类似 Python class 里的 super 用来实现对父 block 的引用，让子模板可以重用父 block 中定义的内容。 只要改一下 _replace_parent_blocks 中的 replace 函数让它支持 {{ block.super }} 就可以了(可以从 Github 下载 template3c.py):\nclass Template:\n    def __init__(self, ....):\n        # blocks\n        self.re_blocks = ...\n        # block.super\n        self.re_block_super = re.compile(r'\\{\\{ block\\.super \\}\\}')\n\n    def _replace_parent_blocks(self, parent_text, child_blocks):\n        def replace(match):\n            ...\n            parent_code = match.group('code')\n            child_code = child_blocks.get(name, '')\n            child_code = self.re_block_super.sub(parent_code, child_code)\n            new_code = child_code or parent_code\n            return new_code\n效果:\nparent2.html:\n<div id=\"header\">{% block header %} parent_header {% endblock header %}</div>\nchild2.html:\n{% extends \"parent2.html\" %}\n{% block header %} child_header {{ block.super }} {% endblock header %}\n>>> from template3c import Template\n>>> text = open('child2.html').read()\n>>> t = Template(text)\n>>> t.raw_text\n'<div id=\"header\"> child_header  parent_header  </div>\\n'\n\n>>> t.render()\n'<div id=\"header\"> child_header  parent_header  </div>\\n'\n到目前为主我们已经实现了现代 python 模板引擎应有的大部分功能了:\n\n变量\nif\nfor\ninclude\nextends, block, block.super\n\n后面需要做的工作就是完善我们代码了。\n不知道大家有没有注意到，我之前都是用生成 html 来试验模板引擎的功能的， 这是因为模板引擎确实是在 web 开发中用的比较多，既然是生成 html 源码那就需要考虑 针对 html 做一点优化，比如去掉多余的空格，转义之类的，还有就是一些 Web 安全方面的考虑。\n至于怎么实现这些优化项，我将在 第四篇文章 中向你详细的讲解。敬请期待。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "7"}