{"title": "1. Python3源码—内建对象 - 个人文章 ", "index": "源码,函数,api,python", "content": "1.1. Python内的对象\nPython中的类和实例都是通过Python内的对象来实现的。Python中已经预先定义了一些类型对象。这些内建类型对象通过实例化，可以创建内建类型对象的实例对象。\n在Python中，对象就是为C中的结构体在堆上申请的一块内存，一般来说，对象是不能被静态初始化的，并且也不能在栈空间上生存。唯一的例外就是类型对象，Python中所有的内建的类型对象都是被静态初始化的。\n在Python中，一个对象一旦被创建，它在内存中的大小就是不变的了。这就意味着那些需要容纳可变长度数据的对象只能在对象内维护一个指向一块可变大小的内存区域的指针。\n1.2. PyObject\nPyObject是整个Python对象机制的核心，定义如下：\n// object.h\ntypedef struct _object {\n    _PyObject_HEAD_EXTRA\n    Py_ssize_t ob_refcnt;\n    struct _typeobject *ob_type;\n} PyObject;\n其中_PyObject_HEAD_EXTRA定义如下：\n// object.h\n#ifdef Py_TRACE_REFS\n/* Define pointers to support a doubly-linked list of all live heap objects. */\n#define _PyObject_HEAD_EXTRA            \\\n    struct _object *_ob_next;           \\\n    struct _object *_ob_prev;\n\n#define _PyObject_EXTRA_INIT 0, 0,\n\n#else\n#define _PyObject_HEAD_EXTRA\n#define _PyObject_EXTRA_INIT\n#endif\n可以看到release编译时不会定义Py_TRACE_REFS。\nPyObject类中ob_refcnt与内存引用计数相关，ob_type用来指定一个对象类型的类型对象。在Python中，对象机制的核心一个是引用计数，一个就是类型信息。\n每一个Python对象除了必须有这个PyObject内容外，还应该占有一些额外的内存，放置些其他的东西。比如float对象除了PyObject，还有一个额外的double变量，如下定义：\n// object.h\n/* PyObject_HEAD defines the initial segment of every PyObject. */\n#define PyObject_HEAD PyObject ob_base;\n1.3. PyVarObject\n把浮点对象这样不包含可变长度数据的对象称为“定长对象”，而字符串对象这样包含可变长度数据的对象称为“变长对象”，它们的区别在于定长对象的不同对象占用的内存大小是一样的，而变长对象的不同对象占用的内存可能是不一样的。\n表示变长对象的结构体PyVarObject定义如下：\n// object.h\ntypedef struct {\n    PyObject ob_base;\n    Py_ssize_t ob_size; /* Number of items in variable part */\n} PyVarObject;\n每一个可变Python对象除了有PyVarObject内容外，还占有一些额外的内存，放置些其他的东西。比如list对象为变长对象，它的结构体如下：\n// listobject.h\ntypedef struct {\n    PyObject_VAR_HEAD\n    PyObject **ob_item;\n    Py_ssize_t allocated;\n} PyListObject;\n其中PyObject_VAR_HEAD定义了PyVarObject类型对象，如下：\n// object.h\n/* PyObject_VAR_HEAD defines the initial segment of all variable-size container objects. */\n#define PyObject_VAR_HEAD     PyVarObject ob_base;\n1.4. PyTypeObject\n对象对应的类型对象定义如下：\n// object.h\ntypedef struct _typeobject {\n    PyObject_VAR_HEAD\n    const char *tp_name; \n\n    Py_ssize_t tp_basicsize, tp_itemsize;\n\n    /* Methods to implement standard operations */\n    destructor tp_dealloc;\n    printfunc tp_print;\n    \n       // ...\n} PyTypeObject;\n定义中包含了许多信息，主要分为4类：\n\n类型名，tp_name，主要是Python内部以及调试的时候使用；\n创建该类型对象时分配内存空间大小的信息，即tp_basicsize和tp_itemsize；\n与该类型对象相关联的操作信息，诸如tp_print这样的函数；\n类型的类型信息；\n\n在PyTypeObject中定义了大量的函数指针，这些函数指针最终都会指向某个函数，或者指向NULL，可以视为类型对象中所定义的操作。在这些操作信息中，有三组非常重要的操作族：tp_as_number，tp_as_sequence和tp_as_mapping，分别指向PyNumberMethods，PySequenceMethods和PyMappingMethods函数族。PyNumberMethods、PySequenceMethods、PyMappingMethods分别定义了作为一个数值对象、序列对象和关联对象应该支持的操作。\n类型对象的类型是PyType_Type：\nPyTypeObject PyType_Type = {\n    PyVarObject_HEAD_INIT(&PyType_Type, 0)\n    \"type\",                            /* tp_name */\n    sizeof(PyHeapTypeObject),          /* tp_basicsize */\n    sizeof(PyMemberDef),               /* tp_itemsize */\n    (destructor)type_dealloc,          /* tp_dealloc */\n    0,                                 /* tp_print */\n    0,                                 /* tp_getattr */\n    0,                                 /* tp_setattr */\n    0,                                 /* tp_reserved */\n    (reprfunc)type_repr,               /* tp_repr */\n    0,                                 /* tp_as_number */\n    0,                                 /* tp_as_sequence */\n    0,                                 /* tp_as_mapping */\n    0,                                 /* tp_hash */\n    (ternaryfunc)type_call,            /* tp_call */\n    0,                                 /* tp_str */\n    (getattrofunc)type_getattro,       /* tp_getattro */\n    (setattrofunc)type_setattro,       /* tp_setattro */\n    0,                                 /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |\n        Py_TPFLAGS_BASETYPE | Py_TPFLAGS_TYPE_SUBCLASS,                                                   /* tp_flags */\n    type_doc,                          /* tp_doc */\n    (traverseproc)type_traverse,       /* tp_traverse */\n    (inquiry)type_clear,               /* tp_clear */\n    0,                                 /* tp_richcompare */\n    offsetof(PyTypeObject, tp_weaklist),  /* tp_weaklistoffset */\n    0,                                  /* tp_iter */\n    0,                                  /* tp_iternext */\n    type_methods,                       /* tp_methods */\n    type_members,                       /* tp_members */\n    type_getsets,                       /* tp_getset */\n    0,                                  /* tp_base */\n    0,                                  /* tp_dict */\n    0,                                  /* tp_descr_get */\n    0,                                  /* tp_descr_set */\n    offsetof(PyTypeObject, tp_dict),    /* tp_dictoffset */\n    type_init,                          /* tp_init */\n    0,                                  /* tp_alloc */\n    type_new,                           /* tp_new */\n    PyObject_GC_Del,                    /* tp_free */\n    (inquiry)type_is_gc,                /* tp_is_gc */\n};\n1.5. Python对外提供的C API\nPython的C API分为两类，一类称为范性的API（AOL，Abstract Object Layer），这类API都具有诸如PyObject_*的形式，可以应用在任何Python对象上；另一类是与类型相关的API（COL，Concrete Object Layer），这类API通常只能作用在某一种类型的对象上，对于每一种内建对象，Python都提供了这样的一组API。\n1.6 参考\nPython源码剖析\n本文作者：whj0709阅读原文本文为云栖社区原创内容，未经允许不得转载。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}