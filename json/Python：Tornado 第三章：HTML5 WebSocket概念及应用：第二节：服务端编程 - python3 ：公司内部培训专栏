{"title": "Python：Tornado 第三章：HTML5 WebSocket概念及应用：第二节：服务端编程 - python3 ：公司内部培训专栏 ", "index": "python", "content": "上一篇文章：Python：Tornado 第三章：HTML5 WebSocket概念及应用：第一节：WebSocket概念下一篇文章： Python：Tornado 第三章：HTML5 WebSocket概念及应用：第三节：客户端编程\n\nTornado定义了tornado.websocket.WebSocketHandler类用于处理WebSocket链接的请求，应用开发者应该继承该类并实现其中的open()、on_message()、on_close()函数。\n\nWebSocketHandler.open()函数：在一个新的WebSocket链接建立时，Tornado框架会调用此函数。在本函数中，开发者可以和在get()、post()等函数中一样用get_argument()函数获取客户端提交的参数，以及用get_secure_cookie/set_secure_cookir等操作Cookie等。\nWebSocketHandler.on_message(message)函数：建立WebSocket链接后，当收到来自客户端的消息时，Tornado框架会调用本函数。通常，这是服务器端WebSocket编程的核心函数，通过解析收到的消息做出相应的处理。\nWebSocketHandler.on_close()函数：当WebSocket链接被关闭时，Tornado框架会调用本函数。在本函数中，可以通过访问self.close_code和self.close_reason查询关闭的原因。\n\n\n除了这三个Tornado框架自动调用的入口函数，WebSocketHandler还提供了两个开发者主动操作WebSocket函数。\n\nWebSocketHandler.write_message(message,binary=False)函数：用于向与本链接相对于的客户端写入消息。\nWebSocketHandler.close(code=None,reason=None)函数：主动关闭WebSocket链接。其中的code和reason用于告诉客户端链接被关闭的原因。参数code必须是一个数值，而reason是一个字符串。\n\n下面是持续为客户端推送时间消息的Tornado WebSocket程序：\nimport tornado.ioloop\nimport tornado.web\nimport tornado.websocket\nfrom tornado import gen\nfrom tornado.options import define,options,parse_command_line\nimport asyncio\n\nclients=dict()#客户端Session字典\n\nclass IndexHandler(tornado.web.RequestHandler):\n    @tornado.web.asynchronous\n    @gen.coroutine\n    def get(self):\n        print(\"123\")\n        self.render(\"index.html\")\n\nclass MyWebSocketHandler(tornado.websocket.WebSocketHandler):\n    def open(self, *args, **kwargs): #有新链接时被调用\n        self.id=self.get_argument(\"Id\")\n        self.stream.set_nodelay(True)\n        clients[self.id]={\"id\":self.id,\"object\":self}#保存Session到clients字典中\n\n    def on_message(self, message):#收到消息时被调用\n        print(\"Client %s received a message:%s\"%(self.id,message))\n\n    def on_close(self): #关闭链接时被调用\n        if self.id in clients:\n            del clients[self.id]\n            print(\"Client %s is closed\"%(self.id))\n\n    def check_origin(self, origin):\n        return True\napp=tornado.web.Application([\n    (r'/',IndexHandler),\n    (r'/websocket',MyWebSocketHandler),\n])\n\n\nimport threading\nimport time\nclass SendThread(threading.Thread):\n    # 启动单独的线程运行此函数，每隔1秒向所有的客户端推送当前时间\n    def run(self):\n        # tornado 5 中引入asyncio.set_event_loop,不然会报错\n        asyncio.set_event_loop(asyncio.new_event_loop())\n        import datetime\n        while True:\n            for key in clients.keys():\n                msg = str(datetime.datetime.now())\n                clients[key][\"object\"].write_message(msg)\n                print(\"write to client %s:%s\" % (key, msg))\n            time.sleep(1)\n\n\n\n\n\nif __name__ == '__main__':\n    #启动推送时间线程\n    SendThread().start()\n    parse_command_line()\n    app.listen(8888)\n    #挂起运行\n    tornado.ioloop.IOLoop.instance().start()\n解析上述代码如下：\n\n定义了全局变量字典clients，用于保存所有与服务器建立WebSocket链接的客户端信息。字典的键是客户端id，值是一个由id与相应的WebSocketHandler实例构成的元组（Tuple）\nIndexHandler是一个普通的页面处理器，用于向客户端渲染主页index.html。本页面中包含了WebSocket的客户端程序。\nMyWebSocketHandler是本例的核心处理器，继承自tornado.web.WebSocketHandler。其中的open()函数将所有客户端链接保存到clients字典中；on_message()用于显示客户端发来的消息；on_close()用于将已经关闭的WebSocket链接从clients字典中移除。\n函数sendTime()运行在单独的线程中，每隔1秒轮询clients中的所有客户端并通过MyWebSocketHandler.write_message()函数向客户端推送时间消息。\n本例的tornado.web.Application实例中只配置了两个路由，分别指向IndexHandler和MyWebSocketHandler，仍然由Tornado IOLoop启动并运行。\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}