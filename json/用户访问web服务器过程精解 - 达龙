{"title": "用户访问web服务器过程精解 - 达龙 ", "index": "mysql,nginx,linux,python", "content": "博文参考\nhttp://www.hackdig.com/\nhttp://www.hackdig.com/07/hack-47475.htm\nhttp://www.cnblogs.com/yuteng/articles/1904215.html\nhttp://blog.csdn.net/bpingchang/article/details/51328941\nhttp://blog.csdn.net/boer521314/article/details/41460865\n\n概括预览\n当一个用户在浏览器里输入www.google.com这个URL时，将会发生如下操作\n1 首先，浏览器会请求DNS把这个域名解析成对应的IP地址；\n2 然后，根据这个IP地址在互联网上找到对应的服务器，建立Socket连接，向这个服务器发起一个HTTP Get请求，由这个服务器决定返回默认的数据资源给访问的用户；\n3 在服务器端实际上还有复杂的业务逻辑：服务器可能有多台，到底指定哪台服务器处理请求，这需要一个负载均衡设备来平均分配所有用户的请求；\n4 还有请求的数据是存储在分布式缓存里还是一个静态文件中，或是在数据库里；\n5 当数据返回浏览器时，浏览器解析数据发现还有一些静态资源（如：css，js或者图片）时又会发起另外的HTTP请求，而这些请求可能会在CDN上，那么CDN服务器又会处理这个用户的请求；\n\nHTTP协议解析\nHTTP协议\n最重要的就是要熟悉HTTP协议中的HTTP Header，HTTP Header控制着互联网上成千上万的用户的数据传输。最关键的是，它控制着用户浏览器的渲染行为和服务器的执行逻辑。\n\n 200： 成功，请求数据通过响应报文的entity-body部分发送;OK 301： 请求的URL指向的资源已经被删除；但在响应报文中通过首部Location指明了资源在所处的新位置； Moved Permanently 302： 与301相似，但在响应报文中通过Location指明资源现在所处临时新位置; Moved Temporarily 304： 客户端发出了条件式请求，但服务器上的资源未曾发生改变，则通过响应此响应状态码通知客户端； Not Modified 401： 需要输入账号和密码认证方能访问资源； Unauthorized 403： 请求被禁止； Forbidden 404： 服务器无法找到客户端请求的资源； Not Found 500： 服务器内部错误； Internal Server Error 502： 代理服务器从后端服务器收到了一条伪响应，如无法连接到父网关； Bad Gateway\n浏览器缓存机制\n当我们使用Ctrl+F5组合键刷新一个页面时，首先是在浏览器端，会直接向目标URL发送请求，而不会使用浏览器缓存的数据；其次即使请求发送到服务端，也有可能访问到的是缓存的数据。所以在HTTP的请求头中会增加一些请求头，它告诉服务端我们要获取最新的数据而非缓存。最重要的是在请求头中增加了两个请求项Pragma:no-cache和Cache-Control:no-cache。\n1  Cache-Control/Pragma这个HTTP Head字段用于指定所有缓存机制在整个请求/响应链中必须服从的指令，如果知道该页面是否为缓存，不仅可以控制浏览器，还可以控制和HTTP协议相关的缓存或代理服务器。Http Head字段的可选值： \nCache-Control请求字段被各个浏览器支持的较好，而且它的优先级也比较高，它和其他一些请求字段（如Expires）同时出现时，Cache-Control会覆盖其他字段。\nPragma字段的作用和Cache-Control有点类似，它也是在HTTP头中包含一个特殊的指令，使相关的服务器来遵守，最常用的就是Pragma:no-cache，它和Cache-Control:no-cache的作用是一样的。\n\n2 Expires 缓存过期时间Expires通常的使用格式是Expires:Sat,25 Feb 2012 12:22:17 GMT，后面跟着一个日期和时间，超过这个值后，缓存的内容将失效，也就是浏览器在发出请求之前检查这个页面的这个字段，看该页面是否已经过期了，过期了将重新向服务器发起请求。\n3 Last-Modified/Etag 最后修改时间Last-Modified字段一般用于表示一个服务器上的字段的最后修改时间，资源可以是静态（静态内容自动加上Last-Modified）或者动态的内容（如Servlet提供了一个getLastModified方法用于检查某个动态内容是否已经更新），通过这个最后修改时间可以判断当前请求的资源是否是最新的。一般服务器端在响应头中返回一个Last-Modified字段，告诉浏览器这个页面的最后修改时间，如：Sat,25 Feb 2012 12:55:04 GMT，浏览器再次请求时在请求头中增加一个If-Modified-Since:Sat,25 Feb 2012 12:55:04 GMT字段，询问当前缓存的页面是否是最新的，如果是最新的就会返回304状态码，告诉浏览器是最新的，服务器也不会传输新的数据。\n\n与Last-Modified字段有类似功能的还有一个Etag字段，这个字段的作用是让服务端给每个页面分配一个唯一编号，然后通过这个编号来区分当前这个页面是否是最新的。这种方式比使用Last-Modified更加灵活，但是在后端的Web服务器有多台时比较难处理，因为每个Web服务器都要记住网站的所有资源编号，否则浏览器返回这个编号就没有意义了。\nWEB工作流程\n上网过程\n浏览器本身是一个客户端，当你输入URL的时候，首先浏览器会去请求DNS服务器，通过DNS获取相应的域名对应的IP，然后通过IP地址找到IP对应的服务器后，要求建立TCP连接，等浏览器发送完HTTP Request（请求）包后，服务器接收到请求包之后才开始处理请求包，服务器调用自身服务，返回HTTP Response（响应）包；客户端收到来自服务器的响应后开始渲染这个Response包里的主体（body），等收到全部的内容随后断开与该服务器之间的TCP连接。\n\nWeb服务器的工作原理可以简单地归纳为\n\n浏览器通过DNS域名解析到服务器IP；\n客户机通过TCP/IP协议建立到服务器的TCP连接；\n客户端向服务器发送HTTP协议请求包，请求服务器里的资源文档；\n服务器向客户机发送HTTP协议应答包，如果请求的资源包含有动态语言的内容，那么服务器会调用动态语言的解释引擎负责处理“动态内容”，并将处理得到的数据返回给客户端；\n客户机与服务器断开。由客户端解释HTML文档，在客户端屏幕上渲染图形结果；\n\nDNS域名解析\n当用户在浏览器中输入域名，如：www.google.com，并按下回车后，DNS解析过程大体如下\n\n（1）浏览器先查缓存，若缓存中有域名对应IP地址，则解析结束。（存活时间TTL）\n（2）若浏览器缓存中没有，浏览器会查询操作系统中缓存缓存是否有这个域名对应的DNS解析结果。（hosts 文件）\n（3）如果在本机中仍然无法完成域名的解析，则会真正请求域名服务器来解析这个域名了。操作系统会把域名发送给设置的LDNS（cat /etc/resolv.conf）。\n（4）若LDNS没有命中，就直接到Root Server域名服务器请求解析。\n（5）根域名服务器返回本地域名服务器一个所查询域的主域名服务器（gTLD Server）地址。GTLD是国际顶级域名服务器，如.com、.cn、.org等，全球只有13台左右。\n（6）本地域名服务器（Local DNS Server)再向上一步返回的GTLD服务器发送请求。\n（7）接受请求的GTLD服务器查找并返回此域名对应的Name Server域名服务器，这个Name Server通常就是你注册的域名服务器，例如你在某个域名服务提供商申请的域名，那么这个域名解析任务就有这个域名提供商的服务器来完成。\n（8）Name Server返回IP记录和TTL（缓存时间）。\n（9）LDNS缓存该记录，缓存时间有TTL控制。\n（10）解析结果返回给用户，用户根据TTL值缓存在本地系统缓存中，域名解析过程结束。\n几种域名解析方式\n1    A记录，A代表的是Address，用来指定域名对应的IP地址如将item.taobao.com指定到115.238.23.241，将switch.taobao.com指定到121.14.24.241。A记录可以将多个域名解析到一个IP地址，但是不能将一个域名解析到多个IP地址。\n2    MX记录，表示的是Mail Exchange，就是可以将某个域名下的邮件服务器指向自己的Mail Server如taobao.com域名的A记录IP地址是115.238.25.245，如果MX记录设置为115.238.25.246，是xxx@taobao.com的邮件路由，DNS会将邮件发送到115.238.25.246所在的服务器，而正常通过Web请求的话仍然解析到A记录的IP地址。\n3    CNAME记录，全称是Canonical Name（别名解析），所谓的别名解析就是可以为一个域名设置一个或者多个别名如将taobao.com解析到xulingbo.net，将srcfan.com也解析到xulingbo.net，其中xulingbo.net分别是taobao.com和srcfan.com的别名。前面的跟踪域名解析中的“www.taobao.com. 1542 IN CNAME www.gslb.taobao.com”就是CNAME解析。\n4    NS记录，为某个域名指定DNS解析服务器，也就是这个域名有指定的IP地址的DNS服务器去解析前面的“google.com. 172800 IN NS ns4.google.com.”就是NS解析。\n5    TXT记录，为某个主机名或域名设置说明如可以为google.com设置TXT记录为“谷歌|中国”这样的说明。\n\n发起TCP协议\n三次握手连接\n拿到域名对应的IP地址之后，User-Agent（一般是指浏览器）会以一个随机端口（1024 < 端口 < 65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求。这个连接请求（原始的http请求经过TCP/IP4层模型的层层封包）到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。\n\n   Client首先发送一个连接试探，ACK=0 表示确认号无效，SYN = 1 表示这是一个连接请求或连接接受报文，同时表示这个数据报不能携带数据，seq = x 表示Client自己的初始序号（seq = 0 就代表这是第0号包），这时候Client进入syn_sent状态，表示客户端等待服务器的回复。\n   Server监听到连接请求报文后，如同意建立连接，则向Client发送确认。TCP报文首部中的SYN 和 ACK都置1 ，ack = x + 1表示期望收到对方下一个报文段的第一个数据字节序号是x+1，同时表明x为止的所有数据都已正确收到（ack=1其实是ack=0+1,也就是期望客户端的第1个包），seq = y 表示Server自己的初始序号（seq=0就代表这是服务器这边发出的第0号包）。这时服务器进入syn_rcvd，表示服务器已经收到Client的连接请求，等待client的确认。\n   Client收到确认后还需再次发送确认，同时携带要发送给Server的数据。ACK 置1 表示确认号ack= y + 1 有效（代表期望收到服务器的第1个包），Client自己的序号seq= x + 1（表示这就是我的第1个包，相对于第0个包来说的），一旦收到Client的确认之后，这个TCP连接就进入Established状态，就可以发起http请求了。\n建立TCP连接发起http请求\n经过TCP3次握手之后，浏览器发起了http的请求（看第⑫包），使用的http的方法 GET 方法，请求的URL是 / ,协议是HTTP/1.0：\n抓包实战\n\n以上的报文是HTTP请求报文。那么HTTP请求报文和响应报文会是什么格式呢？\n起始行：如 GET / HTTP/1.0 （请求的方法 请求的URL 请求所使用的协议）\n\n头部信息：User-Agent Host等成对出现的值\n\n主体\n不管是请求报文还是响应报文都会遵循以上的格式。那么起始行中的请求方法有哪些种呢？\nGET: 完整请求一个资源 （常用）\n\nHEAD: 仅请求响应首部\n\nPOST: 提交表单 （常用）\n\nPUT: 上传\n\nDELETE: 删除\n\nOPTIONS: 返回请求的资源所支持的方法的方法\n\nTRACE: 追求一个资源请求中间所经过的代理\n\n那什么是URL、URI、URN？\nURI Uniform Resource Identifier 统一资源标识符，如：scheme://[username:password@]HOST:port/path/to/source\n\nURL Uniform Resource Locator 统一资源定位符，如：http://www.magedu.com/downloads/nginx-1.5.tar.gz\n\nURN Uniform Resource Name 统一资源名称\n\n请求的协议有哪些种？有以下几种\nhttp/0.9: stateless\n\nhttp/1.0: MIME, keep-alive (保持连接), 缓存\n\nhttp/1.1: 更多的请求方法，更精细的缓存控制，持久连接(persistent connection) 比较常用\n\n\n\n    Accept 就是告诉服务器端，接受那些MIME类型\n\n    Accept-Encoding 这个看起来是接受那些压缩方式的文件\n\n    Accept-Lanague 告诉服务器能够发送哪些语言\n\n    Connection 告诉服务器支持keep-alive特性\n\n    Cookie 每次请求时都会携带上Cookie以方便服务器端识别是否是同一个客户端\n\n    Host 用来标识请求服务器上的那个虚拟主机，比如Nginx里面可以定义很多个虚拟主机，那这里就是用来标识要访问那个虚拟主机。\n\n    User-Agent 用户代理，一般情况是浏览器，也有其他类型，如：wget curl 搜索引擎的蜘蛛等\n\n    条件请求头部：If-Modified-Since是浏览器向服务器端询问某个资源文件如果自从什么时间修改过，那么重新发给我，这样就保证服务器端资源文件更新时，浏览器再次去请求，而不是使用缓存中的文件。\n\n    安全请求头部：Authorization: 客户端提供给服务器的认证信息；\n网页处理过程\nhtml → head → title → #text(网页标题) → style → 加载样式 → 解析样式 → link → 加载外部样式表文件 → 解析外部样式表 → script → 加载外部脚本文件 → 解析外部脚本文件 → 执行外部脚本 → body → div → script → 加载脚本 → 解析脚本 → 执行脚本 → img → script → 加载脚本 → 解析脚本 → 执行脚本 → 加载外部图像文件 → 页面初始化完毕\nhttpd请求过程\n<1>.客户端发送请求。客户端浏览器向服务器发送请求URL；\n<2>.服务器接收请求。服务器接收到该浏览器发送的请求；\n<3>.服务器生成HTML。服务器解析请求的URL，根据URL确定请求的目标资源文件；这个资源文件通常是一个动态页面（如ASP，PHP，JSP，ASPX等文件）的网络地址（MVC结构的程序例外）。Web服务器根据动态页面文件的内容和URL中的参数，调用相应的资源（数据库数据或图片文件等等）组织数据，生成HTML页面。\n<4>.服务端响应请求。生成HTML文档以后，服务器响应浏览器的请求，将生成的HTML文档发送给客户端浏览器；\n<5>.客户端接收响应。浏览器接收服务端发出的请求得来HTML文档；\n<6>.客户端解析HTML。浏览器对HTML文档进行解析，并加载相关的资源文件（JS，CSS，多媒体资源，内嵌网页）等，(在这里浏览器解悉完HTML文档以后，就会进行呈现，但同时也会向服务器发送请求来请求其它相关的资源文件)\n<7>.服务器发送资源文件。服务器接到浏览器对资源文件的请求，将相应的资源文件响应给客户端浏览器；\n<8>.客户端加载资源文件。客户端浏览器将接收服务器发送的资源文件，整理并呈现到页面中；\n<9>.客户端从上到下加载。在进行页面呈现的时候，浏览器会从上到下执行HTML文档，当遇到相应的页面脚本的时候，会对脚本进行分析，并解释执行相应的脚本代码。\n在第6步以后，我们就可以看到一部分页面内容了，不过可能是纯文本内容，没有样式，没有图片或其它资源。待到浏览器请求得到某资源的时候就会进行组织呈现，直到整个页面所有资源加载完毕,显示完成，请求响应完毕。\n\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "5"}