{"title": "Flask-APScheduler使用教程 ", "index": "APScheduler", "content": "项目中需要用到定时器和循环执行。去网上搜了一下，比较常见的有一下集中。运用Python线程执行轮询操作，也有运用Linux系统的Cron,Celery的文章最多，但是太麻烦。看看就知道，Celery 需要一个发送和接受消息的传输者。RabbitMQ 和 Redis 中间人的消息传输支持所有特性，但也提供大量其他实验性方案的支持，包括用 SQLite 进行本地开发。需要用到队列，对于这点需求简直就是大材小用。最后找到了比较合适的Flask-APScheduler。\n\n介绍\n看看  github的flask-apscheduler介绍。\n\nLoads scheduler configuration from Flask configuration.(支持从Flask中加载调度)\nLoads job definitions from Flask configuration.(支持从Flask中加载任务配置)\nAllows to specify the hostname which the scheduler will run on.(允许指定服务器运行任务)\nProvides a REST API to manage the scheduled jobs.(提供Rest接口管理任务)\nProvides authentication for the REST API.(提供Rest接口认证)\n\n安装及配置\npip install Flask-APScheduler\n在Flask配置文件中添加\nSCHEDULER_API_ENABLED = True\nJOBS = [\n        {\n            'id': 'job_1h_data',\n            'func': job_1h_data,\n            'args': '',\n            'trigger': {\n                'type': 'cron',\n                'day_of_week': \"0-6\",\n                'hour': '*',\n                'minute': '1',\n                'second': '0'\n            }\n\n\n        },\n\n        {\n            'id': 'job_announce',\n            'func': exchange_an,\n            'args': '',\n            'trigger': 'interval',\n            'seconds': 300\n        }\n]\n上面指定了每一小时获取所有货币24h最高位以及交易所公告。\n获取公告\ndef exchange_an():\n    \"\"\"\n\n    :param start_date: 开始时间 YYYY-MM-DD HH:MM:SS\n    :param end_date: 结束时间 YYYY-MM-DD HH:MM:SS\n    :return: 推送消息,保持数据库\n    \"\"\"\n    current_local = time.time()\n    start_date = time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime(current_local - 300))\n    end_date = time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime(current_local))\n    announce = pro.query('exchange_ann', start_date=start_date, end_date=end_date)\n    print('请求交易所公告...')\n    for x in announce.values:\n        s = {\n            'title': x[0],\n            'content': x[1],\n            'type': x[2],\n            'url': x[3],\n            'datetime': x[4]\n        }\n        value = json.dumps(s)\n        print(value)\n        mqttClient.publish('system/ex_announce', value)\n动态添加任务\n# coding:utf-8\nfrom apscheduler.schedulers.blocking import BlockingScheduler\nimport datetime\n\n\ndef aps_test(x):\n    print datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'), x\n\nscheduler = BlockingScheduler()\nscheduler.add_job(func=aps_test, args=('定时任务',), trigger='cron', second='*/5')\nscheduler.add_job(func=aps_test, args=('一次性任务',), next_run_time=datetime.datetime.now() + datetime.timedelta(seconds=12))\nscheduler.add_job(func=aps_test, args=('循环任务',), trigger='interval', seconds=3, id='interval_task')\n\nscheduler.start()\n\"\"\"\n暂停任务\n\"\"\"\nscheduler.pause_job('interval_task')\n\"\"\"\n恢复任务\n\"\"\"\nscheduler.resume_job('interval_task')\n\"\"\"\n删除任务\n\"\"\"\nscheduler.remove_job('interval_task')\napscheduler支持添加三种方式的任务，分别是定时任务，一次性任务及循环任务。同时也包含了对任务的控制。\n总结\n因为是单机版本，所以指定服务器运行任务，Rest接口管理任务，Rest接口认证就不写了。后续有需求在继续。\n\n欢迎长按下图 -> 识别图中二维码或者微信扫一扫关注我的公众号\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}