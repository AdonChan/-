{"title": "python实现客户端和服务器端传输图片 - 个人文章 ", "index": "windows,ubuntu,linux,python", "content": "问题：以windows作为客户端，linux作为服务器端，进行传输图片\n\n程序：\n'''\nFuction：客户端发送图片和数据\nDate：2018.9.8\nAuthor：snowking\n'''\n###客户端client.py\nimport socket\nimport os\nimport sys\nimport struct\n\ndef sock_client_image():\n    while True:\n        try:\n            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            s.connect(('服务器的ip', 6666))  #服务器和客户端在不同的系统或不同的主机下时使用的ip和端口，首先要查看服务器所在的系统网卡的ip\n            # s.connect(('127.0.0.1', 6666))  #服务器和客户端都在一个系统下时使用的ip和端口\n        except socket.error as msg:\n            print(msg)\n            print(sys.exit(1))\n        filepath = input('input the file: ')   #输入当前目录下的图片名 xxx.jpg\n        fhead = struct.pack(b'128sq', bytes(os.path.basename(filepath), encoding='utf-8'), os.stat(filepath).st_size)  #将xxx.jpg以128sq的格式打包\n        s.send(fhead)\n\n        fp = open(filepath, 'rb')  #打开要传输的图片\n        while True:\n            data = fp.read(1024) #读入图片数据\n            if not data:\n                print('{0} send over...'.format(filepath))\n                break\n            s.send(data)  #以二进制格式发送图片数据\n        s.close()\n        # break    #循环发送\n   \nif __name__ == '__main__':\n    sock_client_image()\n\n###服务器端server.py\nimport socket\nimport os\nimport sys\nimport struct\n\ndef socket_service_image():\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        # s.bind(('127.0.0.1', 6666))\n        s.bind(('服务器的ip', 6666))\n        s.listen(10)\n    except socket.error as msg:\n        print(msg)\n        sys.exit(1)\n\n    print(\"Wait for Connection.....................\")\n\n    while True:\n        sock, addr = s.accept()  #addr是一个元组(ip,port)\n        deal_image(sock, addr)\ndef deal_image(sock, addr):\n    print(\"Accept connection from {0}\".format(addr))  #查看发送端的ip和端口\n\n    while True:\n        fileinfo_size = struct.calcsize('128sq')\n        buf = sock.recv(fileinfo_size)   #接收图片名\n        if buf:\n            filename, filesize = struct.unpack('128sq', buf)\n            fn = filename.decode().strip('\\x00')\n            new_filename = os.path.join('./', 'new_' + fn)  #在服务器端新建图片名（可以不用新建的，直接用原来的也行，只要客户端和服务器不是同一个系统或接收到的图片和原图片不在一个文件夹下）\n\n            recvd_size = 0\n            fp = open(new_filename, 'wb')\n\n            while not recvd_size == filesize:\n                if filesize - recvd_size > 1024:\n                    data = sock.recv(1024)\n                    recvd_size += len(data)\n                else:\n                    data = sock.recv(1024)\n                    recvd_size = filesize\n                fp.write(data)  #写入图片数据\n            fp.close()\n        sock.close()\n        break\n        \nif __name__ == '__main__':\n    socket_service_image()\n\n运行结果：服务器端：\n\n客户端：\n\n补充说明：1.首先在linux系统下运行server.py(python server.py),然后在windows python 终端下运行client.py，在终端输入当前目录下要传输的图片名，即heat.jpg，可以看到在服务器的路径下出现了new_heat.jpg图片文件，证明文件传输成功。2.刚开始在参考网上的代码时出现了各种错误，其中在调试时一直出现接收到的图片数据丢失，打不开图片，弄懂struct.pack的压缩格式之后，发现是因为参数设置的问题，原来是128sl，其中l是长整型，超出范围的话接收到的图片数据就丢失，故改为q之后范围变大，能够正常接收图片。下图是struct.pack的压缩格式和数据范围对应表：\n声明:该图表来自https://blog.csdn.net/u011006...\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}