{"title": "Tensorflow Python API 翻译（math_ops）（第一部分） - 个人文章 ", "index": "python", "content": "作者：chen_h微信号 & QQ：862251340微信公众号：coderpai简书地址：https://www.jianshu.com/p/ce4...\n\n计划现将 tensorflow 中的 Python API 做一个学习，这样方便以后的学习。原文链接\n\n该章介绍有关数学符号操作的API\n\n\n第一部分\n第二部分\n\n\n算术运算符\nTensorFlow提供了一些操作，你可以使用基本的算术运算符添加到你的图表。\n\ntf.add(x, y, name = None)\n解释：这个函数返回x与y逐元素相加的结果。\n注意：tf.add操作支持广播形式，但是tf.add_n操作不支持广播形式。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \n\na = tf.constant(2)\nb = tf.constant(3)\nc = tf.add(a, b)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\nx: 一个Tensor，数据类型是必须是以下之一：float32，float64，int8，int16，int32，complex64，int64。\n\ny: 一个Tensor，数据类型必须和x相同。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和x相同。\n\ntf.sub(x, y, name = None)\n解释：这个函数返回x与y逐元素相减的结果。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \n\na = tf.constant([1,2])\nb = tf.constant(2)\nc = tf.sub(a, b)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\nx: 一个Tensor，数据类型是必须是以下之一：float32，float64，int8，int16，int32，complex64，int64。\n\ny: 一个Tensor，数据类型必须和x相同。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和x相同。\n\ntf.mul(x, y, name = None)\n解释：这个函数返回x与y逐元素相乘的结果。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \n\na = tf.constant([1,2])\nb = tf.constant(2)\nc = tf.mul(a, b)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\nx: 一个Tensor，数据类型是必须是以下之一：float32，float64，int8，int16，int32，complex64，int64。\n\ny: 一个Tensor，数据类型必须和x相同。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和x相同。\n\ntf.div(x, y, name = None)\n解释：这个函数返回x与y逐元素相除的结果。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \n\na = tf.constant([1,2])\nb = tf.constant(2)\nc = tf.div(a, b)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\nx: 一个Tensor，数据类型是必须是以下之一：float32，float64，int8，int16，int32，complex64，int64。\n\ny: 一个Tensor，数据类型必须和x相同。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和x相同。\n\ntf.mod(x, y, name = None)\n解释：这个函数返回x与y逐元素取余的结果。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \n\na = tf.constant([1,2])\nb = tf.constant(2)\nc = tf.mod(a, b)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\nx: 一个Tensor，数据类型是必须是以下之一：int16，int32，float32，float64。\n\ny: 一个Tensor，数据类型必须和x相同。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和x相同。\n\n基础的数学函数\nTensorFlow提供了一些操作，你可以使用基本的数学函数，将它们添加到你的图表。\n\ntf.add_n(inputs, name = None)\n解释：这个函数的作用是对inputs列表中的元素相应位置累加。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \n\na = tf.constant([1,2], tf.int32)\nb = tf.constant([3,4], tf.int32)\nc = tf.add_n([a,b])\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\ninputs: 一个列表，其中至少有一个Tensor，数据类型是必须是以下之一：float32，float64，int64，int32，uint8，int16，int8，complex64，qint8，quint8，quint32。并且列表中的每个Tensor必须有相同的数据维度。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和inputs相同。\n\ntf.abs(x, name = None)\n解释：这个函数的作用返回x的绝对值。\n给定x，它是一个实数Tensor。这个操作返回一个tensor，这个tensor中的每个值是对应于x中的每个值得绝对值。\n如果，你需要处理复数的绝对值，那么可以使用tf.complex_abs()函数。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \n\na = tf.constant([1,-2])\nc = tf.abs(a)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\nx: 一个Tensor，数据类型是必须是以下之一：float，double，int64或者int32。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和数据维度都和x相同。\n\ntf.neg(x, name = None)\n解释：这个函数的作用是得到x中每个值得负数，即y = -x\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \n\na = tf.constant([1,-2])\nc = tf.neg(a)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\nx: 一个Tensor，数据类型是必须是以下之一：float32，float64，int32，complex64，int64。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和x相同。\n\ntf.sign(x, name = None)\n解释：这个函数是一个符号函数，按照如下规则转换x中的每一个值。\n如果 x < 0，y = sign(x) = -1；如果 x == 0，y = sign(x) = 0；如果 x > 0，y = sign(x) = 1；\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \n\na = tf.constant([1,-2,0])\nc = tf.sign(a)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\nx: 一个Tensor，数据类型是必须是以下之一：float32，float64，int32，int64。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和x相同。\n\ntf.inv(x, name = None)\n解释：这个函数是计算x中每个元素的倒数，即y = 1/x。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \n\na = tf.constant(7.0)\nc = tf.inv(a)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\nx: 一个Tensor，数据类型是必须是以下之一：float32，float64，int32，complex64，int64。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和x相同。\n译者注：我测试了一下这个API，但好像x的数据类型只有是float类型时才能成功。\n\ntf.square(x, name = None)\n解释：这个函数是计算x中每个元素的平方，即y = x*x = x^2。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \n\na = tf.constant([2.0,7.0])\nc = tf.square(a)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\nx: 一个Tensor，数据类型是必须是以下之一：float32，float64，int32，complex64，int64。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和x相同。\n\ntf.round(x, name = None)\n解释：这个函数是得到x中每个元素离它最接近的整数。\n比如：\n# 'a' is [0.9, 2.5, 2.3, -4.4]\ntf.round(a) ==> [ 1.0, 3.0, 2.0, -4.0 ]\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \n\na = tf.constant([2.9, 0.0, -2.1, 2.0, 7.2])\nc = tf.round(a)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\nx: 一个Tensor，数据类型是float或者double。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和x相同，数据维度和x相同。\n\ntf.sqrt(x, name = None)\n解释：这个函数是得到x中每个元素的开平方值，即y = x^{1/2}。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \n\na = tf.constant([2, 3], tf.float32)\nc = tf.sqrt(a)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\nx: 一个Tensor，数据类型必须是以下之一：float32，float64，int32，complex64，int64。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和x相同。\n\ntf.rsqrt(x, name = None)\n解释：这个函数是得到x中每个元素的开平方值的导数，即y = 1/x^{1/2}。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \n\na = tf.constant([2, 3], tf.float32)\nc = tf.rsqrt(a)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\nx: 一个Tensor，数据类型必须是以下之一：float32，float64，int32，complex64，int64。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和x相同。\n\ntf.pow(x, y, name = None)\n解释：这个函数是计算幂运算。\n给定一个x和y，对应x和y中的每一个值，计算x^y。\n比如：\n# tensor 'x' is [[2, 2]], [3, 3]]\n# tensor 'y' is [[8, 16], [2, 3]]\ntf.pow(x, y) ==> [[256, 65536], [9, 27]]\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \n\na = tf.constant([2, 3])\nb = tf.constant([2, 3])\nc = tf.pow(a, b)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\nx: 一个Tensor，数据类型必须是以下之一：float，double，int32，complex64，int64。\n\ny: 一个Tensor，数据类型必须是以下之一：float，double，int32，complex64，int64。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor。\n\ntf.exp(x, name = None)\n解释：这个函数是计算x中每个元素的指数，即y = e^x。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \n\na = tf.constant([2.0, 1], tf.float32)\nc = tf.exp(a)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\nx: 一个Tensor，数据类型必须是以下之一：float32，float64，int32，complex64，int64。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和x相同。\n\ntf.log(x, name = None)\n解释：这个函数是计算x中每个元素的自然对数，即y = log(x)。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \n\na = tf.constant([2.0, 1], tf.float32)\nc = tf.log(a)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\nx: 一个Tensor，数据类型必须是以下之一：float32，float64，int32，complex64，int64。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和x相同。\n\ntf.ceil(x, name = None)\n解释：这个函数是返回不小于x中每个元素的最小整数。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \n\na = tf.constant([2.2, -1.8], tf.float32)\nc = tf.ceil(a)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\nx: 一个Tensor，数据类型必须是以下之一：float32，float64。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和x相同。\n\ntf.floor(x, name = None)\n解释：这个函数是返回不大于x中每个元素的最大整数。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \n\na = tf.constant([2.2, -1.8], tf.float32)\nc = tf.floor(a)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\nx: 一个Tensor，数据类型必须是以下之一：float32，float64。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和x相同。\n\ntf.maximum(x, y, name = None)\n解释：这个函数是逐个比较x和y中的值，求得最大值，即x > y ? x : y。该函数支持广播形式。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \n\na = tf.constant([2.2, -1.8, 0.0])\nb = tf.constant(1.0)\nc = tf.maximum(a, b)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\nx: 一个Tensor，数据类型必须是以下之一：float32，float64，int32，int64。\n\ny: 一个Tensor，数据类型和x相同。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和x相同。\n\ntf.minimum(x, y, name = None)\n解释：这个函数是逐个比较x和y中的值，求得最小值，即x < y ? x : y。该函数支持广播形式。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \n\na = tf.constant([2.2, -1.8, 0.0])\nb = tf.constant(1.0)\nc = tf.minimum(a, b)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\nx: 一个Tensor，数据类型必须是以下之一：float32，float64，int32，int64。\n\ny: 一个Tensor，数据类型和x相同。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和x相同。\n\ntf.cos(x, name = None)\n解释：这个函数是计算x中每个元素的余弦值。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \n\na = tf.constant([2.2, -1.8, 0.0])\nc = tf.cos(a)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\nx: 一个Tensor，数据类型必须是以下之一：float32，float64，int32，complex64，int64。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和x相同。\n\ntf.sin(x, name = None)\n解释：这个函数是计算x中每个元素的正弦值。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \n\na = tf.constant([2.2, -1.8, 0.0])\nc = tf.sin(a)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\nx: 一个Tensor，数据类型必须是以下之一：float32，float64，int32，complex64，int64。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和x相同。\n\n矩阵数学函数\nTensorFlow提供了一些操作，你可以使用添加基本的矩阵数学函数在你的图中。\n\ntf.diag(diagonal, name = None)\n解释：这个函数是给定一个对角值diagonal，然后返回一个对角tensor。\n给定一个对角值diagonal，这个操作返回一个对角tensor，对角线上面的值是diagonal，其余值都用0来填充。\n假设diagonal的维度为[D1, D2, ..., Dk]，那么输出tensor的秩为2k，维度是[D1, D2, ..., Dk, D1, D2, ..., Dk]，如下：\noutput[i1, i2, ..., ik, i1, i2, ..., ik] = diagonal[i1, .., ik]，其余值都是0。\n比如：\n# 'diagonal' is [1, 2, 3, 4]\ntf.diag(diagonal) ==> [[1, 0, 0, 0]\n                       [0, 2, 0, 0]\n                       [0, 0, 3, 0]\n                       [0, 0, 0, 4]]\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \n\na = tf.constant([2.2, -1.8, 1.0])\nc = tf.diag(a)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\ndiagonal: 一个Tensor，数据类型必须是以下之一：float32，float64，int32，int64。它的秩最大为3。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和diagonal相同。\n\ntf.transpose(a, perm = None, name = 'transpose')\n解释：将a进行转置，并且根据perm参数重新排列输出维度。\n输出数据tensor的第i维将根据perm[i]指定。比如，如果perm没有给定，那么默认是perm = [n-1, n-2, ..., 0]，其中rank(a) = n。默认情况下，对于二维输入数据，其实就是常规的矩阵转置操作。\n比如：\ninput_data.dims = (1, 4, 3)\nperm = [1, 2, 0]\n\n# 因为 output_data.dims[0] = input_data.dims[ perm[0] ]\n# 因为 output_data.dims[1] = input_data.dims[ perm[1] ]\n# 因为 output_data.dims[2] = input_data.dims[ perm[2] ]\n# 所以得到 output_data.dims = (4, 3, 1)\noutput_data.dims = (4, 3, 1)\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \n\nsess = tf.Session()\ninput_data = tf.constant([[1,2,3],[4,5,6]])\nprint sess.run(tf.transpose(input_data))\nprint sess.run(input_data)\nprint sess.run(tf.transpose(input_data, perm=[1,0]))\ninput_data = tf.constant([[[1,2,3],[4,5,6],[7,8,9],[10,11,12]]])\nprint 'input_data shape: ', sess.run(tf.shape(input_data))\noutput_data = tf.transpose(input_data, perm=[1, 2, 0])\nprint 'output_data shape: ', sess.run(tf.shape(output_data))\nprint sess.run(output_data)\nsess.close()\n输入参数：\n\n\na: 一个Tensor。\n\nperm: 一个对于a的维度的重排列组合。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个经过翻转的Tensor。\n\ntf.matmul(a, b, transpose_a = False, transpose_b = False, a_is_sparse = False, b_is_sparse = False, name = None)\n解释：将矩阵a和矩阵b进行相乘，得到矩阵a*b。\n输入数据必须是一个二维的矩阵，经过转置或者不转置，内部维度必须相匹配。\n输入矩阵必须有相同的数据类型，数据类型为：float，double，int32，complex64。\n矩阵可以被设置为转置操作，即transpose_a = True, transpose_b = True。默认情况下，该标记都是被设置为False。\n如果矩阵中存在很多的0，那么我们可以使用sparse标记，即a_is_sparse = True, b_is_sparse = True。默认情况下，该标记都是被设置为False。\n比如：\n# 2-D tensor `a`\na = tf.constant([1, 2, 3, 4, 5, 6], shape=[2, 3]) => [[1. 2. 3.]\n                                                      [4. 5. 6.]]\n# 2-D tensor `b`\nb = tf.constant([7, 8, 9, 10, 11, 12], shape=[3, 2]) => [[7. 8.]\n                                                         [9. 10.]\n                                                         [11. 12.]]\nc = tf.matmul(a, b) => [[58 64]\n                        [139 154]]\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np\n\na = tf.constant(np.random.rand(2,3))\nb = tf.constant(np.random.rand(1,3))\nc = tf.matmul(a, b, transpose_b = True)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\na: 一个Tensor，数据类型是float，double，int32或者complex64。\n\nb: 一个Tensor，数据类型和a相同。\n\ntranspose_a: 如果该值维True，那么在矩阵计算之前，先将a进行转置。\n\ntranspose_b: 如果该值维True，那么在矩阵计算之前，先将b进行转置。\n\na_is_sparse: 如果该值维True，那么在矩阵计算的时候，将a当做一个sparse矩阵考虑。\n\nb_is_sparse: 如果该值维True，那么在矩阵计算的时候，将b当做一个sparse矩阵考虑。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和a相同。\n\ntf.batch_matmul(x, y, adj_x = None, adj_y = None, name = None)\n解释：这个函数的作用是将两个张量按批切片进行相乘。\n将张量x和y进行切片（每个切片就是一个批的元素），然后将对应的x和y的每个切片进行相乘，将得到的结果按照原来批的大小进行重新安排。如果我们把adj_x或者adj_y设置成True，在做乘法之前，每个独立的切片可以组成它的共轭（其实相当于转置）。\n输入的x和y是三维tensor，或者更高维度的[..., r_x, c_x]和[..., r_y, c_y]。\n输出tensor是一个三维的，或者更高维度的[..., r_o, c_o]，其中：\nr_o = c_x if adj_x else r_x\nc_o = r_y if adj_y else c_y\n计算过程如下：\nout[..., :, :] = matrix(x[..., :, :]) * matrix(y[..., :, :])\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np\n\na = tf.constant(np.random.rand(2, 2, 3))\nb = tf.constant(np.random.rand(3, 3, 1))\nc = tf.batch_matmul(a, b)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np\n\na = tf.constant(np.random.rand(3, 2, 3, 1))\nb = tf.constant(np.random.rand(3, 2, 3, 1))\nc = tf.batch_matmul(a, b, adj_x = False, adj_y = True )\nsess = tf.Session()\nprint sess.run(c)\nprint sess.run(tf.shape(c))\nsess.close()\n输入参数：\n\n\nx: 一个Tensor，数据类型是float32，float64，int32或者complex64，数据维度是三维的，或者更高维度[..., r_x, c_x]。\n\ny: 一个Tensor，数据类型和x相同，数据维度是三维的，或者更高维度[..., r_y, c_y]。\n\nadj_x: 这是一个可选的布尔类型的值，默认情况下是False。如果我们设置为True，x的每个切片将进行转置。\n\nadj_y: 这是一个可选的布尔类型的值，默认情况下是False。如果我们设置为True，y的每个切片将进行转置。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和x相同，数据维度是三维的，或者更高维度[..., r_o, c_o]。\n\ntf.matrix_determinant(input, name=None)\n解释：这个函数的作用是计算n阶矩阵的行列式。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np\n\na = tf.constant(np.random.rand(3, 3))\nc = tf.matrix_determinant(a)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\ninput: 一个Tensor，数据类型是float32或者float64，数据维度是[M, M]。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor的标量，数据类型和input相同。\n\ntf.batch_matrix_determinant(input, name=None)\n解释：这个函数的作用是计算每个批（切片）的n阶矩阵的行列式。\n输入tensor的数据维度必须是[..., M, M]，其中内部必须是一个二维的方阵，对于所有的子矩阵，输出结果是一个一维的tensor。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np\n\na = tf.constant(np.random.rand(4, 2, 3, 3))\nc = tf.batch_matrix_determinant(a)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\ninput: 一个Tensor，数据类型是float32或者float64，数据维度是[..., M, M]。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和input相同，数据维度是[...]。\n\ntf.matrix_inverse(input, name=None)\n解释：这个函数的作用是计算n阶矩阵的逆矩阵，并且检查可逆性。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np\n\na = tf.constant(np.random.rand(3, 3))\nc = tf.matrix_inverse(a)\nsess = tf.Session()\nprint sess.run(c)\nd = tf.matmul(a, c)\nprint sess.run(d)\ne = tf.matrix_determinant(d)\nprint sess.run(e)\nsess.close()\n输入参数：\n\n\ninput: 一个Tensor，数据类型是float32或者float64，数据维度是[M, M]。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和input相同，数据维度是[M, M]。\n\ntf.batch_matrix_inverse(input, name=None)\n解释：这个函数的作用是计算每个批（切片）的n阶矩阵的逆矩阵，并且检查可逆性。\n输入tensor的数据类型是[..., M, M]，其中内部必须是一个二维的方阵，对于每一个子矩阵，输出的矩阵的逆和输入数据有相同的数据维度。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np\n\na = tf.constant(np.random.rand(2, 3, 3))\nc = tf.batch_matrix_inverse(a)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\ninput: 一个Tensor，数据类型是float32或者float64，数据维度是[..., M, M]。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和input相同，数据维度是[..., M, M]。\n\ntf.cholesky(input, name=None)\n解释：这个函数的作用是计算n阶矩阵的Cholesky分解。\n输入数据必须是一个对称的正定矩阵，并且这个操作我们只会读入矩阵的下三角部分，不会读取矩阵的上三角部分。\n输出结果是经过Cholesky分解之后的一个对角线元素为正数的下三角实矩阵。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np\n\na = tf.constant([[2, np.random.rand()], [-2, 5]], tf.float32)\nc = tf.cholesky(a)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\ninput: 一个Tensor，数据类型是float32或者float64，数据维度是[M, M]。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和input相同，数据维度是[M, M]。\n\ntf.batch_cholesky(input, name=None)\n解释：这个函数的作用是计算每个批（切片）的n阶矩阵的Cholesky分解。\n输入tensor的数据类型是[..., M, M]，其中内部必须是一个二维的方阵，并且满足Cholesky分解的条件。输出tensor和输入数据有相同的数据类型，并且每个切片都是经过Cholesky分解之后的值。\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np\n\na = tf.constant([[[2, np.random.rand()], [-2, 5]], [[2, np.random.rand()], [-2, 5]]], tf.float32)\nc = tf.batch_cholesky(a)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\ninput: 一个Tensor，数据类型是float32或者float64，数据维度是[..., M, M]。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型和input相同，数据维度是[..., M, M]。\n\n复数函数\nTensorFlow提供了一些复数函数，使得你可以去操作复数，你可以将它们添加到你的图表。\n\ntf.complex(real, imag, name=None)\n解释：这个函数的作用是将两个实数转换成一个复数。\n这个操作就是去计算复数a + bj，其中a来自于输入数据real，表示实部，b来自于输入数据imag，表示虚部。\n输入数据real和imag必须拥有相同的数据维度。\n比如：\n# tensor 'real' is [2.25, 3.25]\n# tensor `imag` is [4.75, 5.75]\ntf.complex(real, imag) ==> [[2.25 + 4.74j], [3.25 + 5.75j]]\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np\n\na = tf.constant([2.25, 3.25])\nb = tf.constant([4.75, 5.75])\nc = tf.complex(a, b)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\nreal: 一个Tensor，数据类型是float。\n\nimag: 一个Tensor，数据类型是float。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型是complex64。\n\ntf.complex_abs(x, name=None)\n解释：这个函数的作用是计算复数的绝对值。\n给定一个复数张量x，这个操作是计算x中的每个值的绝对值，并且返回一个float类型的张量。在x中的所有复数的形式必须是a + bj的形式，那么绝对值计算公式如下：\n\n比如：\n# tensor 'x' is [[-2.25 + 4.75j], [-3.25 + 5.75j]]\ntf.complex_abs(x) ==> [5.25594902, 6.60492229]\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np\n\na = tf.constant([2.25 + 3.25j])\nc = tf.complex_abs(a)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\nx: 一个Tensor，数据类型是complex64。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型是float32。\n\ntf.conj(in_, name=None)\n解释：这个函数的作用是计算复数的复共轭。\n给定一个复数张量in_，这个操作是计算in_中的每一个复数的复共轭。在in_中所有复数的形式必须是a + bj的形式，其中a是实数部分，b是虚数部分。\n经过这个操作，复共轭的返回形式是a - bj。\n比如：\n# tensor 'in' is [-2.25 + 4.75j, 3.25 + 5.75j]\ntf.conj(in) ==> [-2.25 - 4.75j, 3.25 - 5.75j]\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np\n\na = tf.constant([2.25 + 3.25j])\nc = tf.conj(a)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\nx: 一个Tensor，数据类型是complex64。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型是complex64。\n\ntf.imag(in_, name=None)\n解释：这个函数的作用是返回复数的虚部。\n给定一个复数张量in_，这个操作是返回in_中的每一个复数的虚部。在in_中所有复数的形式必须是a + bj的形式，其中a是实数部分，b是虚数部分。\n比如：\n# tensor 'in' is [-2.25 + 4.75j, 3.25 + 5.75j]\ntf.imag(in) ==> [4.75, 5.75]\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np\n\na = tf.constant([2.25 + 3.25j])\nc = tf.imag(a)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\nx: 一个Tensor，数据类型是complex64。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型是float32。\n\ntf.real(in_, name=None)\n解释：这个函数的作用是返回复数的实部。\n给定一个复数张量in_，这个操作是返回in_中的每一个复数的实部。在in_中所有复数的形式必须是a + bj的形式，其中a是实数部分，b是虚数部分。\n比如：\n# tensor 'in' is [-2.25 + 4.75j, 3.25 + 5.75j]\ntf.real(in) ==> [-2.25, 3.25]\n使用例子：\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport tensorflow as tf \nimport numpy as np\n\na = tf.constant([2.25 + 3.25j])\nc = tf.real(a)\nsess = tf.Session()\nprint sess.run(c)\nsess.close()\n输入参数：\n\n\nx: 一个Tensor，数据类型是complex64。\n\nname:（可选）为这个操作取一个名字。\n\n输出参数：\n一个Tensor，数据类型是float32。\n\n作者：chen_h微信号 & QQ：862251340简书地址：https://www.jianshu.com/p/ce4...\nCoderPai 是一个专注于算法实战的平台，从基础的算法到人工智能算法都有设计。如果你对算法实战感兴趣，请快快关注我们吧。加入AI实战微信群，AI实战QQ群，ACM算法微信群，ACM算法QQ群。长按或者扫描如下二维码，关注 “CoderPai” 微信号（coderpai）\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}