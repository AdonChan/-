{"title": "看例子，学 Python（二） - 止于至善 ", "index": "python", "content": "看例子，学 Python（二）\n看例子，学 Python（一）看例子，学 Python（三）\n模块\n文件 mymath.py 定义了函数 fib 和 fac，mymath.py 就是一个模块。\nA module is a file containing Python definitions and statements.\n自定义模块\n导入模块：\n>>> import mymath\nmymath.py 须在当前目录。\n查看模块帮助：\n>>> help(mymath)\nHelp on module mymath:\n\nNAME\n    mymath\n\nFUNCTIONS\n    fib(n)\n...\n列出模块属性：\n>>> dir(mymath)\n['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'fac', 'fib']\n访问模块属性：\n>>> mymath.__name__\n'mymath'\n>>> mymath.__doc__\n>>>\n模块暂时还没有 docstring，所以 mymath.__doc__ 为空。访问函数属性：\n>>> mymath.fac\n<function fac at 0x00000000026DBA60>\n>>> mymath.__dict__['fac']\n<function fac at 0x00000000026DBA60>\n两种方式效果一样。__dict__（字典）隐含于每个对象中，模块对象也不例外。\n为模块 mymath 添加 docstring：\n\"\"\"My math utilities.\"\"\"\n\ndef fib(n):\n    ...\n那么，下次调用 help 就能显示这个 docstring 了：\n>>> help(mymath)\nHelp on module mymath:\n\nNAME\n    mymath - My math utilities.\n...\n内建模块\nPython 自带了 math 模块，来研究一下：\n>>> import math\n>>> help(math)\nHelp on built-in module math:\n\nNAME\n    math\n...\n列出属性：\n>>> dir(math)\n['__doc__', '__loader__', ..., 'factorial', ...]\n可见内建模块 math 也提供了阶乘（factorial），看看它怎么用：\n>>> help(math.factorial)\nHelp on built-in function factorial in module math:\n\nfactorial(...)\n    factorial(x) -> Integral\n\n    Find x!. Raise a ValueError if x is negative or non-integral.\n调用试试：\n>>> math.factorial(4)\n24\n>>> math.factorial(-1)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: factorial() not defined for negative values\n>>>\n内建函数在异常处理方面做得会比较好。值得注意的是，内建模块并不一定由 Python 文件定义，比如 Python 的安装目录下其实并没有 math.py。\ndoctest\n顾名思义，docstring 里嵌测试用例，就是 doctest。好处是，既可做文档又可做测试，也避免了注释里的示例代码失效的问题。为 fac 添加 doctest：\ndef fac(n):\n    \"\"\"\n    >>> fac(4)\n    24\n    \"\"\"\n    ...\n这就像交互环境下的输入输出一样。>>> 打头的是输入，紧接着的便是输出。下面来运行试试：\n$ python -m doctest -v mymath.py\nTrying:\n    fac(4)\nExpecting:\n    24\nok\n2 items had no tests:\n    mymath\n    mymath.fib\n1 items passed all tests:\n   1 tests in mymath.fac\n1 tests in 3 items.\n1 passed and 0 failed.\nTest passed.\n-m 指定使用 Python 的内建模块 doctest，-v 表示显示详细信息。这只是运行 doctest 的方式之一，还可以添加代码到 mymath.py 的 main 函数：\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)\n后续就不必指定命令行参数 -m -v 了。\n作为练习，我们可以为 fib 添加 doctest：\ndef fib(n):\n    \"\"\"Get the nth Fibonacci number.\n    \n    >>> fib(0)\n    0\n    >>> fib(1)\n    1\n    >>> fib(2)\n    1\n    >>> fib(6)\n    8\n    \"\"\"\n   ...\n字典\n对应于官方教程 5.5. Dictionaries。前面介绍模块时，提到了对象的特殊属性 __dict__ ，它其实就是一个字典（dict）。Python 的字典，类似于 C++ 或 Java 的 map，是存储键值映射关系的一种数据结构。我们且不去关心它的实现细节，是平衡二叉树还是哈希表，目前并不重要。\nChar Counter\n第一个例子，实现函数 char_counter，以字典的形式，返回字符串中每个字符出现的次数。函数的 doctest 已经写出来了，你只要让它通过即可。\ndef char_counter(chars):\n    \"\"\"Count the number of each character.\n\n    >>> d = char_counter('banana')\n    >>> d['a']\n    3\n    >>> d['b']\n    1\n    >>> d['n']\n    2\n    \"\"\"\n    pass\n第一版\ndef char_counter(chars):\n    counter = {}  # 初始化为空字典\n    for c in chars:\n        counter[c] += 1  # KeyError!\n    return counter\ncounter[c] += 1 一句将引发 KeyError 异常，因为它没有考虑字典中键不存在的情况。\n第二版\ndef char_counter(chars):\n    counter = {}\n    for c in chars:\n        if c in counter:\n            counter[c] += 1\n        else:\n            counter[c] = 1\n    return counter\n此版处理了键不存在的问题，但是 if...else 总归显得不够优雅，Python 是一门简洁优雅的语言，应该有更好的方法。\n第三版\ndef char_counter(chars):\n    counter = {}\n    for c in chars:\n        counter[c] = counter.get(c, 0) + 1\n    return counter\n通过字典的 get 方法，保证当键不存在时，也能得到妥善初始化了的值。\nWord Counter\nWord Counter 与 Char Counter 类似，以字典形式返回一段文本中每个单词出现的次数。\n给定一段文本如下：\ntext = \"\"\"Remember me when I am gone away,\nGone far away into the silent land;\nWhen you can no more hold me by the hand,\nNor I half turn to go yet turning stay.\nRemember me when no more day by day\nYou tell me of our future that you plann'd:\nOnly remember me; you understand\nIt will be late to counsel then or pray.\nYet if you should forget me for a while\nAnd afterwards remember, do not grieve:\nFor if the darkness and corruption leave\nA vestige of the thoughts that once I had,\nBetter by far you should forget and smile\nThan that you should remember and be sad.\"\"\"\n首先通过 str.split 把 text 分割成单词的列表，然后计数的过程就跟 Char Counter 一样了，各位可以当做练习。\n不难发现，Char Counter 和 Word Counter 在算法上有相似的地方，所以 Python 其实已经提供了这样一个算法。\n>>> import collections\n>>> help(collections.Counter)\nHelp on class Counter in module collections:\n\nclass Counter(builtins.dict)\n |  Dict subclass for counting hashable items.  Sometimes called a bag\n |  or multiset.  Elements are stored as dictionary keys and their counts\n |  are stored as dictionary values.\n...\n根据帮助信息，Counter 是一个类，并且继承自 dict。姑且跳过类定义的语法，篇幅所限。使用 collections.Counter：\nfrom collections import Counter\ncounter = Counter(text.split())\nprint(counter['you'])  # 6\n既然继承自字典，Counter 必定提供了一些额外的方法，比如获取出现频率最高的几个键值对：\nprint(counter.most_common(3))\n# [('you', 6), ('me', 5), ('the', 4)]\n这就涉及了一个对字典以值来排序的问题。怎么对字典以值来排序呢？确实有几种方式，下面以 Char Counter 为例。\n使用 dict.get\n首先，排序用 sorted。\n>>> help(sorted)\n...\nsorted(iterable, key=None, reverse=False)\n输入是一个 iterable，可以用 for 迭代的便是 iterable 的，字典当然也是。但是如果直接对字典排序，便是以键来排序：\ncounter = char_counter('banana')\nprint(sorted(counter))\n# ['a', 'b', 'n']\n为了以值来排序，可以为 sorted 指定 key：\ncounter = char_counter('banana')\nprint(sorted(counter, key=counter.get))\n# ['b', 'n', 'a']\n这样 sorted 在比较时，就不是比较键，而是比较 counter.get(键)。然而这样的排序结果并不是我们想要的，因为它只有键而没有值。\n使用 itemgetter\n字典的 items 方法返回「键值对」列表，我们可以对这个列表按值排序。\nprint(counter.items())\n# dict_items([('b', 1), ('a', 3), ('n', 2)])\n这个列表里的每个元素都是一个键值对，由元组（tuple）表示。元组相当于只读的列表，后面会有介绍。\nfrom operator import itemgetter\nprint(sorted(counter.items(), key=itemgetter(1)))\n# [('b', 1), ('n', 2), ('a', 3)]\n指定 sorted 的 key 为 itemgetter(1)，便以每个键值对元组下标为 1 的元素进行排序。\n最后，不妨来看一下 dict.items 的帮助：\n>>> help(dict.items)\n\nitems(...)\n    D.items() -> list of D's (key, value) pairs, as 2-tuples\n使用 lambda\n除了 itemgetter，还可以用 lambda。简单来说，lambda 就是匿名函数（没有名字的函数），短小精悍，临时创建临时使用，一般作为参数传递，没必要有名字。\n方式一：\nsorted(counter.items(), key=lambda x: x[1])\nx 为键值对元组。\n方式二：\nsorted(counter.items(), key=lambda (k,v): v)\n直接在参数上把元组展开。\n方式三：\nsorted(counter.items(), key=lambda (k,v): (v,k))\n交互键值顺序，元组在比较时，依次比较里面的每个元素。\n降序排序\n降序排序，只需指定 reverse 参数即可：\nsorted(counter.items(), key=itemgetter(1), reverse=True)\n元组\n元组（tuple）是只读的列表，虽然在底层实现上有很大不同。\n>>> a = (1, \"hello\")\n>>> a[0]\n1\n>>> a[0] = 2\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: 'tuple' object does not support item assignment\n可将其它序列类型（str, list）转换成元组：\n>>> s = tuple(\"abcde\")\n>>> s\n('a', 'b', 'c', 'd', 'e')\n看例子，学 Python（一）看例子，学 Python（三）\n\n                ", "mainLikeNum": ["5 "], "mainBookmarkNum": "14"}