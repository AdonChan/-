{"title": "《Python基础教程》第六章--读书笔记 - michael翔的IT私房菜 ", "index": "读书笔记,python", "content": "第六章：抽象\n本章会介绍如何将语句组织成函数。还会详细介绍参数（parameter）和作用域（scope）的概念，以及递归的概念及其在程序中的用途。\n懒惰即美德\n斐波那契数列：任何一个数都是前两个数之和的数字序列。\n创建函数\n内建的callable函数可以用来判断函数是否可调用：\n>>>import math\n>>>x = 1\n>>>y = math.sqrt\n>>>callable(x)\nFalse\n>>>callable(y)\nTrue\n注：函数callable在python3.0中不再可用，需要使用表达式hasattr(func,__call__)代替。创建斐波那契数列列表的函数：\ndef fibs(num):\n    result=[0,1]\n    for i in range(num-2):\n        result.append(result[-2]+result[-1])\n    return result\nfibs(8)\n文档化函数\n\n如果想要给函数写文档，让其他使用函数人能理解的话，可以加入注释（以#开头）。\n另外一个方式就是直接写上字符串。这类字符串在其他地方可能会非常有用，比如在def语句后面。\n\n如果在函数的开头写下字符串，他就会作为函数的一部分进行存储，这成为文档字符串。\ndef square(x):\n    'Calculate the square of the number'\n    return x*x\n>>>square.__doc__\n'Calculate the square of the number'\n注：__DOC__是函数属性。第七章会介绍更多关于属性的知识。属性名中的双下划线是个特殊属性。这类特殊和“魔法”属性会在第9章讨论。\nhelp内建函数是非常有用的。可以得到关于函数，包括它的文档字符串信息：\nHelp on function square in module __main__:\n \nsquare(x)\n    Calculate the square of the number\n并非真正函数的函数\n数学意义上的函数，总在计算其参数后返回点什么。python有些函数却并不返回任何东西。\npython的函数就是函数，即便它从学术上讲并不是函数。没有return语句，或者虽然有return语句，但是return后边乜有跟任何值得函数不返回值：\ndef test():\n    print 'this is michael'\n    return\n    print 'this is not'\n>>>x = test()\nthis is michael\n>>>x\n>>>print x\nNone\n可以看到，return后边的语句被跳过了（类似于循环中的break`语句，不过这里是跳出函数）。\nx貌似没东西，但是其实有个很熟悉的值None。所以，所有的函数的确否返回了东西：当不需要它们返回值得时候，它们返回None。看来刚才“有些函数并不是真的是函数”的说法有些不公平了。\n参数魔法\n函数使用起来简单，创建起来也并不复杂。但函数参数的用法有时候就有些神奇了。\n值从哪里来\n参数错误的话显然会导致失败（一般来说，这时候就要用断言和异常）。\n写在def语句中函数名后面的变量通常叫做函数的形参（parameter），而调用函数的时候提供的值是实参（argument）或者成为参数。\n我能改变参数吗？\ndef try_to_change(n):\n    n = \"Mr. Michael\"\nname = \"qq\"\ntry_to_change(name)\n具体的工作方式类似这样：\n>>>name= \"qq\"\n>>>n = name    #这句的作用基本上等于传参\n>>>n = \"qq\"\n>>>name\n\"michael\"\n上面的例子中，由于参数是字符串（不可变序列），即无法被修改（也就是说只能用新的值覆盖）。但是，如果将可变的数据结构如列表用作参数的话，那么就有可能改变了。\n这里具体例子就不讲了，因为再看《js高级程序设计》时，有相关类似的概念。值传递，引用传递。\n为什么要改变参数\n使用函数改变数据结构（比如列表或字典）是一种将程序抽象化的好方法。\n关键字参数和默认值\n目前为止，我们使用的参数都是位置参数，因为它们的位置很重要，事实上比它们的名字更重要。\ndef hello(greeting='hello',name='michael'):\n    print '%s,%s'%(greeting,name)\n>>>hello(\"qiuqiu\",greeting=\"hah\")\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n<ipython-input-42-311701c038b1> in <module>()\n      1 def hello(greeting='hello',name='michael',):\n      2     print '%s,%s'%(greeting,name)\n----> 3 hello(\"qiuqiu\",greeting=\"hah\")\n \nTypeError: hello() got multiple values for keyword argument 'greeting'\n错误的意思，按照我自己的理解就是，为参数greeting赋予了多个值。这时候肯定就会出错了！为什么会这样呢？\n位置参数和关键字参数混合使用的情况，位置参数是要放在关键字参数之前的。这里，不是这个原因。\n我猜想 位置参数和位置肯定有关系，当使用它时，它会默认赋值给它位置对应的参数，那么，这里就是greeting。所以呢，这里才会赋值两次。做修改：\ndef hello(name='michael',greeting='hello'):\n    print '%s,%s'%(greeting,name)\n>>>hello(\"qiuqiu\",greeting=\"hah\")\nhah,qiuqiu\n默认参数值在函数被定义时已经计算出来，而不是在程序运行时。Python程序员经常犯的一个错误是把可变的数据类型（例如列表或者字典）当做默认参数值。\n收集参数\n有些时候可以让用户提供任意数量的参数是很有用的。\ndef print_params(*params):\n    print params\n参数前加*，结果打印出来是元祖。参数前的星号将所有值放置在同一个元祖中。可以说是将这些值收集起来。同时，也能和普通参数联合使用：\ndef print_params2(title,*params):\n    print title\n    print params\nprint_params2(\"test\",1,2,3)\ntest\n(1, 2, 3)\n星号的意思就是“收集其余的位置参数”。如果不提供任何供收集的元素，params就是个空数组。\nprint_params2('nothing')  \nnothing\n()\n能不能处理关键字参数呢？\n>>>print_params2('humm',something=42)\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n<ipython-input-49-31af1f150edb> in <module>()\n----> 1 print_params2('humm',something=42)\n \nTypeError: print_params2() got an unexpected keyword argument 'something'\n使用两个**，能处理关键字参数的“收集操作”。\ndef print_params3(**params):\n    print params\nprint_params3(x=1,y=2,z=3)\n{'y': 2, 'x': 1, 'z': 3}\n返回的是字典而不是元祖了。放在一起看看：\ndef print_params4(x,y,z=3,*pospar,**keypar):\n    print x,y,z\n    print pospar\n    print keypar\nprint_params4(1,2,4,\"michael\",name=\"michael\",age=\"24\")\n1 2 4\n('michael',)\n{'age': '24', 'name': 'michael'}\n参数收集的逆过程\n如何将参数收集为元祖和字典已经讨论过了，但是事实上，如果使用*和**的话也可以执行相反的操作。看如下例子：\n#定义函数\ndef add(x,y): \n    return x+y\n有一个由两个数字组成的元祖：params=(1,2)\n此时使用*元算符就简单多了——不过是在调用而不是在定义时使用，作用就相反了！栗子1：\n>>>add(*params)\n3\n栗子2：\ndef hello3(greeting=\"hello\",name=\"world\"):\n    print '%s,%s'%(greeting,name)\nparams={'name':'michael','greeting':'well done'}\nhello3(**params)\nwell done,michael    #结果\n作用域\n什么是变量？可以把它们看作是值的名字。在执行x=1赋值语句后，名称x引用到值1.这就像用字典一样，键引用值，当然，变量和所对应的值用的是个“不可见”的字典。实际上这么说已经很接近真实情况了。内建的vars函数可以返回这个字典：\n>>>x=1\n>>>y=1\n>>>scope=vars()\n>>>scope['x']\n1\n\nvars可以返回全局变量的字典。\nlocals返回局部变量的字典。\n\nvars函数官方说明这类“不可见字典”叫做命名空间或者作用域。\n除了全局作用域外，每个函数调用都会创建一个新的作用域：\n>>>def foo():x=42\n>>>x=1\n>>>foo()\n>>>x\n1\n当调用foo的时候，新的命名空间就被创建了，它作用于foo内的代码块。赋值语句x=42只在内部作用域（局部命名空间）起作用，它并不影响外部（全局）作用域中的x。\n函数内的变量被称为局部变量（local variable)。\n太痛苦了，这里的知识之前在学习JS时就已经了解的挺多，作用域链等等。还是记载以下我遗忘的知识好了。不赘述了。\nx='michael'\ndef print_name(x):\n    print x+x\nprint_name('qiuqiu')\nqiuqiuqiuqiu    #结果\n这里因为参数名和全局变量名重复了，因此，全局变量就被屏蔽了（如果不重复，是可以读取到全局变量值的）。我记得在JS中时，也有类似知识点，会逐步向上搜索作用域链中的变量值。\n那么该怎么达成效果呢？怎么避免被屏蔽呢？使用globals函数获取全局变量值！\nx='michael'\ndef print_name(x):\n    print x+globals()['x']\nprint_name('qiuqiu')\nqiuqiumichael   #结果\n除非告知python将其声明为全局变量，否则，在函数内的新变量赋值会自动成为局部变量：\nx=2\ndef gl(x):\n    global x\n    x+=2\n    print x\ngl(3)\nx\nFile \"<ipython-input-76-22d2ecf63f0c>\", line 2\n    def gl(x):\nSyntaxError: name 'x' is local and global\n为啥这里出错了呢？因为x作为形参，是局部变量，而函数里通过global又定义x是全局变量，因此出现了错误提示中的错误。\n嵌套作用域（闭包）\npython的函数是可以嵌套的，也就是说可以将一个函数放在另一个里面。\n万万没想到，又看到闭包了！python中也是有闭包的嘛，看来各个语言的机理概念都大同小异啊~\n在其他函数内写函数：\ndef multiplier(factor):\n    def multiplyByFactor(number):\n        return number*factor\n    return multiplyByFactor\n每次调用外层函数（此处的multiplier),它内部的函数都被重新绑定，factor变量每次都有一个新值！\n>>>double=multiplier(2)\n>>>double(5)\n10\n>>>multiplier(5)(4)\n20\n类似multiplierByFactor函数存储子封闭作用域的行为叫做闭包（closure）。\n外部作用域的变量一般是不能进行重新绑定的。但是python3中，nonlocal关键字被引入。它和global关键字的使用方式类似，可以让用户对外部作用域（但并非全局作用域）的变量进行赋值。\n递归（recursion)\n递归简单来说就是引用（或者调用）自身的意思。\ndef recursion():\n    return recursion()\n为了深入了解它，读者应该买本计算机科学方面的好书。常用python解释器也能帮助理解。\n无穷递归（infinite recursion），类似于以white True开始的无穷循环，中间没有break或者return语句。\n有用的递归函数包括以下部分：\n\n当函数直接返回值时有基本实例（最小可能性问题）。\n递归实例，包括一个或者多个问题最小部分的递归调用。\n\n这里的关键就是将问题分解为小部分，递归不能永远继续下去，因为它总是以最小可能性问题结束，而这些问题又存贮在基本实例中的。（就不能讲人话吗？！读不懂……）\n两个经典：阶乘和幂\n阶乘\n可以使用循环：\ndef factorial(n):\n    result=n\n    for i in range(1,n):\n        result*=i\n    return result   \n关键在于阶乘的定义：\n\n1的阶乘是1\n大于1的数n的阶乘是n乘n-1的阶乘现在看看递归的版本：\n\ndef factorial(n):\n    if n==1:\n        return 1\n    else:\n        return n*factorial(n-1)\n幂\n假设需要计算幂，就像内建函数pow函数或者**运算符一样。先看一个简单的例子：power(x,n)(x的n次幂）。\ndef power(x,n):\n    result =1\n    for i in range(n):\n        result*=x\n    return result\n把它改为递归版本：\n\n对于任意数字x来说，power(x,0)是1；    这就是上面递归条件的第一个，最小可能性问题吧\n对于任意大于0的数来说，power(x,n)是x乘以power（x,n-1)的结果。\n\n理解定义是最困难的部分——实现起来就简单了。\ndef power(x,n):\n    if n==0:\n        return 1\n    else:\n        return x*power(x,n-1)\n提示：如果函数或者算法很复杂而且难懂的话，在实现前用自己的话明确一下定义是很有帮助的。\n函数式编程\npython在应对“函数式编程”方面有一些有用的函数：\nmap\n使用map函数将序列中的元素全部传递给函数\n>>>map(str,range(10))    #Equivalent to [str(i) for i in range(10)]\n['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']\nmap函数：\nApply function to every item of iterable and return a list of the results.\nfilter\nfilter函数可以基于一个返回布尔值的函数对元素进行过滤：\ndef func(x):\n    return x.isalnum()\n\n>>>seq=['foo','x41','?!','***']\n>>>filter(func,seq)\n['foo','x41']\nNote that filter(function, iterable) is equivalent to [item for item in iterable if function(item)]str.isalpha()Return true if all characters in the string are alphabetic and there is at least one character, false otherwise.\n本章小结\n这章的知识确实有点多啊，递归一直不是特别灵活运用，或许真该找本书看看。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "5"}