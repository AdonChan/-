{"title": "线性结构  队列与栈 - 小马的技术笔记 ", "index": "es6,javascript,python,数据结构", "content": "线性结构  队列与栈\n栈\n栈(Stack)是一种遵循先进后出(LIFO)原则的有序列表，新添加或待删除的元素都保存在栈的一端，这一端被称作为栈顶，另一端被称作为栈底。在栈里，新元素都靠近栈顶，旧元素都靠近栈底。\n栈的操作\n\n\n方法\n操作\n\n\n\npush\n添加新元素到栈顶\n\n\npop\n移除并返回栈顶元素\n\n\npeek\n返回栈顶元素\n\n\nsize\n返回栈大小\n\n\nclear\n移除栈内所有元素\n\n\nisEmpty\n判断栈是否为空\n\n\n\nPython实现栈\n# python3\nclass Stack:\n    def __init__(self):\n        self.items = []\n\n    def push(self, item):\n        self.items.append(item)\n\n    def pop(self):\n        return self.items.pop()\n\n    def peek(self):\n        return self.items[-1]\n\n    def size(self):\n        return len(self.items)\n\n    def clear(self):\n        self.items = []\n\n    def is_empty(self):\n        return self.items == []\nJavaScript实现栈\n// ES6\nclass Stack {\n    constructor() {\n        this.items = [];\n    }\n    push(item) {\n        this.items.push(item);\n    }\n    pop() {\n        return this.items.pop();\n    }\n    peek() {\n        return this.items[-1];\n    }\n    size() {\n        return this.items.length;\n    }\n    clear() {\n        this.items = [];\n    }\n    isEmpty() {\n        return this.items.length === 0;\n    }\n}\n队列\n队列(Queue)是一种遵循先进先出(FIFO)原则的有序列表。队列在尾部添加新元素，从顶部移除元素。最新添加的元素必须排列在队列的末尾。\n队列操作\n\n\n方法\n操作\n\n\n\nenqueue\n添加新元素到队列尾部\n\n\ndequeue\n移除并返回队首元素\n\n\nfront\n返回队首元素\n\n\nsize\n返回队列大小\n\n\nclear\n移除队列内所有元素\n\n\nisEmpty\n判断队列是否为空\n\n\n\nPython实现队列\n# python3\nclass Queue:\n    def __init__(self):\n        self.items = []\n\n    def enqueue(self, item):\n        self.items.append(item)\n\n    def dequeue(self):\n        return self.items.pop(0)\n\n    def front(self):\n        return self.items[0]\n\n    def size(self):\n        return len(self.items)\n\n    def clear(self):\n        self.items = []\n    \n    def is_empty(self):\n        return self.items == []\nJavaScript实现队列\n// ES6\nclass Queue {\n    constructor() {\n        this.items = [];\n    }\n    enqueue(item) {\n        this.items.push(item);\n    }\n    dequeue() {\n        return this.items.shift();\n    }\n    front() {\n        return this.items[0];\n    }\n    size() {\n        return this.items.length;\n    }\n    def clear() {\n        this.items = [];\n    }\n    isEmpty () {\n        return this.items.length === 0;\n    }\n}\n栈的应用\n回文检索\n回文是指一种现象，一个单词、短语或数字，从前往后和从后往前都是一样的。\n# 单词\ndad\nracecar\n# 数字\n1001\n使用栈，可以轻松判断一个字符串是否是回文。将字符串的每个字符按顺序亚入栈。当字符串中的字符都入栈后，栈内就保存了一个反转后的字符串。通过弹出栈内每个字母可以得到一个新字符，只需要比较两个字符串即可。\n# python3\ndef palindrome(word):\n    s = Stack()\n    word = str(word)\n    rword = ''\n\n    for i in word:\n        s.push(i)\n\n    while not s.is_empty():\n        rword += s.pop()\n    \n    return word == rword\n// ES6\nfunction palindrome(word) {\n    let s = new Stack();\n    word = String(word);\n    let rword = '';\n    for (i of word) {\n        s.push(i);\n    }\n    while (! s.isEmpty()) {\n        rword += s.pop();\n    }\n    return word === rword;\n}\n简单括号匹配\n在表达式中，括号必须以匹配的方式出现。括号匹配意味着每个开始符号具有相应的结束符号，并且括号能被正确嵌套。\n(5+6)*(7+8)/(4+3)  # 括号匹配\n(2+3)+24/12+(4-2   # 括号不匹配\n栈可以用来判断一个表达式中的括号是否匹配。从空栈开始，从左到右处理表达式。如果一个符号是一个开始符号，将其作为一个信号，对应的结束符号稍后会出现。另一方面，如果符号是结束符号，弹出栈，只要弹出栈的开始符号可以匹配每个结束符号，则括号保持匹配状态。如果任何时候栈上没有出现符合开始符号的结束符号，则字符串不匹配。最后，当所有符号都被处理后，栈应该是空的。\n# python3\ndef par_checker(expression):\n    s = Stack()\n    balanced = True\n    index = 0\n    while index < len(expression) and balanced:\n        symbol = expression[index]\n        if symbol == '(':\n            s.push(symbol)\n        elif symbol == ')':\n            item = s.pop()\n            if item != '(':\n                balanced = False\n        index += 1\n    return balanced and s.is_empty()\n// ES6\nfunction parChecker(expression) {\n    let s = new Stack();\n    let balanced = true;\n    let index = 0;\n    while (index < expression.length && balanced) {\n        symbol = expression[index]\n        if (symbol === '(') {\n            s.push(symbol);\n        } else if (symbol === ')') {\n            let item = s.pop();\n            if (item !== '(') {\n                balanced = false;\n            }\n        }\n        index += 1;\n    }\n    return balanced && s.isEmpty();\n}\n进制转换\n在生活中，我们主要使用十进制数。但在计算科学中，二进制非常重要，因为计算机里的内容都是用二进制数字表示的(0和1)。如果没有进制转化的能力，与计算机交流就会非常困难。\n要把十进制数转化成二进制的算法，将十进制数与2相除，并取余数。\n10 => 1010\n10/2 = 5, rem = 0\n 5/2 = 2, rem = 1\n 2/2 = 1, rem = 0\n 1/2 = 0, rem = 1\nPython实现\n# python3\ndef divide_by2(dec_str):\n    s = Stack()\n    dec_num = int(dec_str)\n    bin_str = ''\n    while dec_num > 0:\n        rem = dec_num % 2\n        s.push(rem)\n        dec_num //= 2\n\n    while not s.is_empty():\n        bin_str += str(s.pop())\n\n    return bin_str\n同理，我们可以推导出十进制数转化八进制和十六进制算法。以下是完整的进制转换算法。\n# python3\ndef base_converter(dec_str, base):\n    s = Stack()\n    digits = \"0123456789ABCDEF\"\n    dec_num = int(dec_str)\n    new_str = ''\n\n    while dec_num > 0:\n        rem = dec_num % base\n        s.push(rem)\n        dec_num //= base\n\n    while not s.is_empty():\n        new_str += digits[s.pop()]\n\n    return new_str\n// ES6\nfunction baseConverter(decStr, base) {\n    let s = new Stack();\n    let digits = \"0123456789ABCDEF\";\n    let decNum = Number(decStr);\n    let newStr = '';\n    while (decNum > 0) { \n        rem = decNum % base;\n        s.push(rem)\n        decNum = Math.floor(decNum/base);\n    }\n    while (! s.isEmpty()) {\n        newStr += digits[s.pop()]\n    }\n    return newStr;\n}\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}