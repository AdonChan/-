{"title": "SQLAlchemy入门（一） - 止于至善 ", "index": "python,orm,sqlalchemy,mysql,数据库", "content": "环境：Ubuntu 15.10 64-bit\nSQLAlchemy 是 Python 的 ORM 框架，它的理念是：数据库的量级和性能重要于对象集合，而对象集合的抽象又重要于表和行。\n安装\n直接通过 pip 安装：\n$ pip install sqlalchemy\n打开 Python，测试是否安装成功：\n>>> import sqlalchemy\n>>> sqlalchemy.__version__\n'1.0.9'\n创建引擎\nSQLite\n首先以 SQLite 为例，因为它比较简单。\nfrom sqlalchemy import create_engine, MetaData\n\nengine = create_engine('sqlite:///foo.db', echo=True)\nmetadata = MetaData(engine)\n参数 sqlite:///foo.db 解释为：\nsqlite://<nohostname>/<path>\n其中foo.db是相对路径。也可写成：\nsqlite:///./foo.db\nSQLAlchemy 缺省使用 Python 内建的 sqlite3 模块来连接或创建 SQLite 数据库。执行完 create_engine 后，可以发现当前目录多了 foo.db 文件，不妨用 sqlite 打开看看。\n$ sqlite3 foo.db\nSQLite version 3.8.11.1 2015-07-29 20:00:57\nEnter \".help\" for usage hints.\nsqlite> .tables\n注意这里用的是 sqlite3 而非 sqlite，因为 foo.db 是经由 Python 内建的 sqlite3 模块创建的。\nMySQL\n再来看看连接 MySQL 时怎么创建引擎。本文后续示例全部基于 MySQL，这是与官方文档不同的地方。先在MySQL里创建一个测试数据库：sa_test，后续示例都将基于这个数据库。\nmysql> CREATE DATABASE sa_test DEFAULT CHARACTER SET UTF8;\nfrom sqlalchemy import create_engine, MetaData\n\nengine = create_engine('mysql+mysqldb://root:******@localhost/sa_test', echo=True)\nmetadata = MetaData(engine)\n这里的参数看上去就比较复杂了，完整的格式为：\ndialect+driver://username:password@host:port/database\n这里 driver 用了 mysqldb，详见：MySQLdb：Python 操作 MySQL 数据库 \n引擎配置的详细信息可参考官方文档：Engine Configuration\nMetaData\n前面在创建 MetaData 时绑定了引擎：\nmetadata = MetaData(engine)\n当然也可以不绑定。绑定的好处是，后续很多调用 （比如 MetaData.create_all()，Table.create()，等等）就不用指定引擎了。\n创建表\n创建两张表，user 和 address，address 表里有一个 user id 的外键。注意：表名没有像官方文档及很多人推荐的那样使用复数形式，个人偏好而已，详细讨论请见 StackOverflow 的这个问题：Table Naming Dilemma: Singular vs. Plural Names （中文版）\nfrom sqlalchemy import create_engine, MetaData,\\\n        Table, Column, Integer, String, ForeignKey\n\nengine = create_engine('mysql+mysqldb://root:******@localhost/sa_test', echo=True)\nmetadata = MetaData(engine)\nuser_table = Table('user', metadata,\n        Column('id', Integer, primary_key=True),\n        Column('name', String(50)),\n        Column('fullname', String(100))\n        )\n\naddress_table = Table('address', metadata,\n        Column('id', Integer, primary_key=True),\n        Column('user_id', None, ForeignKey('user.id')),\n        Column('email', String(128), nullable=False)\n        )\n\nmetadata.create_all()\n执行完 metadata.create_all() 这一句，两张表就创建好了，可以在 MySQL 里立即查看。\nMetaData.create_all() 可以多次调用，不会报错，它在内部会检查表是否已经创建。因为 MetaData 创建时已经绑定了引擎，所以此处 create_all() 就不必再指定了，否则得写成：\nmetadata.create_all(engine)\n创建引擎时，echo 参数为 True，程序运行时便有很多调试信息打印出来。在这些调试信息中，可以看到如下两条 MySQL的CREATE TABLE 语句：\nCREATE TABLE user (\n    id INTEGER NOT NULL AUTO_INCREMENT,\n    name VARCHAR(50),\n    fullname VARCHAR(100),\n    PRIMARY KEY (id)\n)\n\nCREATE TABLE address (\n    id INTEGER NOT NULL AUTO_INCREMENT,\n    user_id INTEGER,\n    email VARCHAR(128) NOT NULL,\n    PRIMARY KEY (id),\n    FOREIGN KEY(user_id) REFERENCES user (id)\n)\n除了 metadata.create_all()，Table 自己也有 create 方法：\ncreate(bind=None, checkfirst=False)\n参数 bind 一般就是指引擎。参数 checkfirst 表示是否检查表已经存在。为 True 时，若表已经存在，不报错，只是什么也不做；为False 时，若表已经存在，则将引发异常。使用这个方法来创建这两张表：\nuser_table.create(checkfirst=True)\naddress_table.create(checkfirst=True)\n这里忽略了 bind 参数，因为创建 MetaData 对象时已经绑定了引擎，而创建表对象时又传入了 metadata，所以顺藤摸瓜，表自己是知道引擎的。如果调整一下表的创建顺序，就会报错，因为 address 表里有一个 user 表的外键，而这时候 user 表还没创建呢。所以，还是建议使用 MetaData.create_all() 吧，毕竟它也会检查表是否已经存在。\n表的反射（Table Reflection）\n表创建好了，一般也就不动了。所以实际应用时，往往表都已经存在，并不需要创建，只需把它们”导入”进来即可，这时就得使用 autoload 参数。\nfrom sqlalchemy import create_engine, MetaData, Table\n\nengine = create_engine('mysql+mysqldb://root:******@localhost/sa_test', echo=False)\nmetadata = MetaData(engine)\n\nuser_table = Table('user', metadata, autoload=True)\n\nprint 'user' in metadata.tables\nprint [c.name for c in user_table.columns]\n\naddress_table = Table('address', metadata, autoload=True)\nprint 'address' in metadata.tables\n输出：\nTrue\n['id', 'name', 'fullname']\nTrue\n如果 MetaData 没有绑定引擎，则另需指定 autoload_with 参数：\nuser_table = Table('user', metadata, autoload=True, autoload_with=engine)\n如果被反射的表外键引用了另一个表，那么被引用的表也会一并被反射。比如只反射 address 表，user 表也一并被反射了。\nfrom sqlalchemy import create_engine, MetaData, Table\n\nengine = create_engine('mysql+mysqldb://root:******@localhost/sa_test', echo=False)\nmetadata = MetaData(engine)\n\naddress_table = Table('address', metadata, autoload=True)\n\nprint 'user' in metadata.tables\nprint 'address' in metadata.tables\n输出：\nTrue\nTrue\n插入数据\n插入数据之前，必须要有表对象，不管是新创建的，还是通过反射导入的。\nInsert 对象\n要往表里插数据，先创建一个 Insert 对象：\nins = user_table.insert()\nprint ins\n打印这个 Insert 对象，可以看到它所对应的 SQL 语句：\nINSERT INTO user (id, name, fullname) VALUES (%s, %s, %s)\n如果连接的数据库不是 MySQL 而是 SQLite，那输出可能就是下面这样：\nINSERT INTO user (id, name, fullname) VALUES (?, ?, ?)\n可见 SQLAlchemy 帮我们封装了不同数据库之间语法的差异。如果 MetaData 创建时没有绑定引擎，那么输出会略有不同：\nINSERT INTO \"user\" (id, name, fullname) VALUES (:id, :name, :fullname)\n这时 SQLAlchemy 还不知道具体的数据库语法，表名加了引号（\"user\"），列名也改用为:id之类一般性的格式。此外，这条INSERT语句列出了 user 表里的每一列，而id在插入时一般是不需要指定的，可以通过Insert.values() 方法加以限制：\nins = ins.values(name='adam', fullname='Adam Gu')\nprint ins\n限制后，id 列已经没有了：\nINSERT INTO user (name, fullname) VALUES (%s, %s)\n可见 values() 方法限制了 INSERT 语句所包含的列。但是我们指定的 name 和 fullname 的值并没有打印出来，这两个值保存在 Insert 对象里，只有等到执行时才会用到。\n执行\n我们一直在说的引擎，可以理解成一个数据库连接对象的仓库，通过连接对象可以往数据库发送具体的 SQL 语句。调用引擎的 connect() 方法可以获取一个连接：\nconn = engine.connect()\n现在把前面的 Insert 对象丢给它来执行：\nresult = conn.execute(ins)\n由调试信息可见具体的 INSERT 语句：\nINSERT INTO user (name, fullname) VALUES (%s, %s)\n('adam', 'Adam Gu')\nCOMMIT\n返回值 result 是一个 ResultProxy 对象，ResultProxy 是对 DB-API 中 cursor 的封装。插入语句的结果并不常用，但是查询语句肯定是要用到它的。不妨在 MySQL 里看一下刚插入的数据。\nmysql> select * from user;\n+----+------+----------+\n| id | name | fullname |\n+----+------+----------+\n|  1 | adam | Adam Gu  |\n+----+------+----------+\n1 row in set (0.00 sec)\n执行多条语句\n还记得前面的 Insert 对象使用 values() 方法来限制列吗？\nins = ins.values(name='adam', fullname='Adam Gu')\n这种方式其实不利于 Insert 对象的复用，更好的做法是把参数通过 execute() 方法传进去：\nins = user_table.insert()\nconn.execute(ins, name='adam', fullname='Adam Gu')\nInsert 对象本身还是会包含所有列，最终 INSERT 语句里的列由 execute() 的参数决定。由调试信息可见具体的 INSERT 语句：\nINSERT INTO user (name, fullname) VALUES (%s, %s)\n('adam', 'Adam Gu')\nCOMMIT\n一次插入多条记录也很简单，只要传一个字典列表（每个字典的键必须一致）给 execute() 即可。\nconn.execute(address_table.insert(), [\n    { 'user_id': 1, 'email': 'sprinfall@gmail.com' },\n    { 'user_id': 1, 'email': 'sprinfall@hotmail.com' },\n    ])\n调试信息里具体的 INSERT 语句：\nINSERT INTO address (user_id, email) VALUES (%s, %s)\n((1, 'sprinfall@gmail.com'), (1, 'sprinfall@hotmail.com'))\nCOMMIT\n在 MySQL 里看一下插入的地址：\nmysql> select * from address;\n+----+---------+-----------------------+\n| id | user_id | email                 |\n+----+---------+-----------------------+\n|  1 |       1 | sprinfall@gmail.com   |\n|  2 |       1 | sprinfall@hotmail.com |\n+----+---------+-----------------------+\n2 rows in set (0.00 sec)\n第一部分到此结束。\n\n                ", "mainLikeNum": ["6 "], "mainBookmarkNum": "19"}