{"title": "python奇遇记：深入理解装饰器 - 码上就来 ", "index": "python", "content": "什么是装饰器\n装饰器是什么，简单来说，装饰器可以改变一个函数的行为，比如原本有一个函数用来计算菲波那切数列，我们给这个函数加个计算执行时间的装饰器，这样原来的函数不仅能够计算菲波那切数列，而且还可以输出计算花费了多少时间。\n在Python中，有几个很常见的内置装饰器：比如@staticmethod， 它可以将一个类的方法声明为静态的。@property， 为类中的变量设置get和set方法，保证了封装性。\n如果你使用过python的web框架（比如flask）开发过网站，你应该经常会见到装饰器，像下面这样：\n@app.route(\"/\")\ndef hello():\n    return \"Hello World!\"\n这段代码把路由绑定到hello函数上，这样你输入网址之后就可以看到Hello World 。\n先来看个很简单的例子：\n# 定义了一个装饰器\ndef deco(func):\n  def hah():\n      print('hahha')\n  return hah\n上面我们定义了一个装饰器，打印hahah，接下来使用：\n# 使用这个装饰器\n@deco\ndef lal():\n    pritn('lalalala')\n\nlal()\n执行lal()会输出hahha。 可见deco装饰器改变了lal函数的功能。上面的代码中，我们实际上是把lal函数放入了deco函数，像这样：\nlal = deco(lal)\n只不过，直接使用@标志把装饰器放在某个函数上更方便一点而已。\n装饰器其实就是一个函数嵌套另一个函数（这里涉及到一个概念叫做闭包，下面会讲到）。在装饰器的定义中，需要把内部的函数返回（像hah），内部函数用来真正的改变被装饰函数的功能。\n不过，上面定义的装饰器好像没什么用，我们来真正的写一个装饰器，像文章开头说的那样，定义一个装饰器计算函数执行的时间。\n实现一个简单的装饰器\nimport time\n# 这个装饰器接收一个函数作为参数\ndef clock(func):\n  # clocked用来改变被装饰函数功能\n  # 接收任意可变参数\n    def clocked(*args):\n      #先计算时间\n        t0 = time.perf_counter()\n        # 然后运行被装饰的函数\n        result = func(*args)\n        # 计算运行前后的时间差\n        elapsed = time.perf_counter()-t0\n        # 函数的名字\n        name = func.__name__\n        # 被装饰函数的所有变量\n        arg_str = ','.join(repr(arg) for arg in args)\n        # 输出\n        print('[%0.8fs] %s(%s) -> %r' % (elapsed, name, arg_str, result))\n        # 返回被装饰函数执行结果\n        # 可见装饰器是在原来的函数上增加了某些功能\n        # 而不是完全改变被装饰函数\n        return result\n     # 把clocked函数返回\n    return clocked\n来使用一下上面定义的装饰器：\n@clock\ndef factorial(n):\n    return 1 if n<2 else n*factorial(n-1)\n  \nresult = factorial(6)\nprint(result)\n执行结果：\n[0.00000030s] factorial(1) -> 1\n[0.00004588s] factorial(2) -> 2\n[0.00007184s] factorial(3) -> 6\n[0.00060794s] factorial(4) -> 24\n[0.00064205s] factorial(5) -> 120\n[0.00066801s] factorial(6) -> 720\n720\n可以看到，在输出计算结果的同时，输出了每一步的执行时间。\n装饰器除了改变函数功能之外还有一个特性是，函数装饰器在导入模块时立即执行，而被装饰的函数只在明确调用时运行。这点需要注意。\n当然了，装饰器之上还可以放一个装饰器，不过是多了一层嵌套而已。\npython中还有一个内置的模块functools，这里面定义了一些常用的装饰器函数，帮助你更好地定义自己的装饰器。这里就不讲了。\n闭包\n说到闭包，在上面的代码中我们已经见识到了，函数中嵌套函数就是闭包。严格来说，闭包是指延伸了作用域的函数，怎么理解？不如来看个例子：\n我们定义一个函数不断计算平均值，它会记住上一次计算的值进行累计。\n# 先看一些效果\navg = make_averager()\nprint(avg(10))\nprint(avg(11))\nprint(avg(12))\n输出如下：\n10.0\n10.5\n11.0\n第一次输出10，第二次输出10加11的平均值，第三次输出10加11加12的平均值。\n怎么实现的？\ndef make_averager():\n  # 局部变量series\n  # 用来保存每次输入的值\n    series = []\n    def averager(new_value):\n        series.append(new_value)\n        total = sum(series)\n        return total/len(series)\n    return averager\n上面的函数中，series是局部变量。当我们调用avg(10)的时候，函数已经返回了，按理说它的本地作用域已经不存在了，但是我们还是可以继续使用。这是因为series其实是自由变量，它不受本地作用域的限制。需要注意的是，对于不可变类型，需要显示用关键字nonlocal 声明自由变量，如果不声明的话，会隐式的创建局部变量，这样自由变量就会失效。而可变类型则不需要。比如，我们来更改一下上面的代码：\n# 改一下求平均值的函数\n# 用另一种方法\ndef make_averager():\n   count = 0\n   total = 0\n   def averager(new_value):\n      # count、total是不可变类型\n      # 需要声明为自由变量\n     nonlocal count, total\n     count += 1\n     total += new_value\n     return total / count\n   return averager\n\n除了上面说的装饰器的用法之外，我们还可以为装饰器添加参数，像app.route('/') 这样，限于篇幅，下一篇文章再介绍。\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "3"}