{"title": "用python写一个简单的推荐系统 - 肥兔子de碎碎语 ", "index": "机器学习,推荐系统,python", "content": "前言\n在上篇文章豆瓣电影，电视剧DM实战中提及到，我和室友们产生了剧荒，萌生出要做一个个人用的推荐系统，解决剧荒的问题的想法，经过一轮的死缠烂打，这个个人推荐系统终于成型了。\n今天来分享一下心得，对此感兴趣的朋友可以自己对着写一个。\n传统推荐系统算法\n首先介绍一下传统的推荐系统方法，之所以叫它传统，是因为大部分学习资料上都是用这一个方法。\n我们来假设有这么一个矩阵(用python的列表表示):\n  [# A B C D E\n    [2,0,0,4,4], #1\n    [5,5,5,3,3], #2\n    [2,4,2,1,2]  #3\n    ......\n  ]\n\n矩阵的行代表用户，列表示物品，其交点表示用户对该物品的评分。\n假设现在用户1需要选商品，推荐系统则假设其会选择并未选择过的商品，因此，系统会在第一行中寻找评分为0的物品，显然会找到B和C。这时，该怎么知道是推荐B还是C呢？(假设用户只需推荐一个),这时则需要计算B、C和用户以前选择过的物品(已评分)的相似度。\n仅仅算出相似度还不够，因为你不能判断这到底是好的那一部分相似还是坏的部分相似。所以这时，我们需要引入用户的评分作为相似度计算的权重，评分X相似度得到最后的得分（该得分会一直累加，则B的推荐得分会是B与A，D，E的相似得分的累加和）。这样一来，评分低物品的最后得分自然就低，评分高的物品自然得分就高，这时问题就简化成排序问题了。\n显然，上述问题的核心在于如何计算相似度。\n这里给出计算相似度的两种方法：\n\n欧式距离法  以B和A的相似度为例：similar = 1/sqrt((0-2)^2 + (5-5)^2 + (4-2)^2 ……) 最后B与A的相似得分还得乘上评分，score = similar * 2\n余弦相似度  $$costheta=frac{A cdot B}{||A||||B||}$$AB为两列向量，||A||表示A的2范数特别注意一点的是，cos的取值是-1~1,我们需要将其归一化，即把范围弄成在0~1上。于是相似度计算公司变成0.5 + 0.5*cos\n\n少用户推荐系统的创新\n在上述的内容中，我们可以发现传统的方法有一个特出的问题，传统的算法需要大量的用户评分，即矩阵的行数需要较多才能得出的结果才值得参考。这一个需求咋看起来是没什么问题，也符合我们的逻辑，唯有数据量足够，我们才能找到较为准确的规律嘛。\n但回到我的需求上来说，这可是一个明显的缺点，在前言我说明的需求上说过这是一个给宿舍甚至是个人使用的推荐系统。\n也就是说:\n\n我们无法提供大量数据。\n我们很懒，我们最可能是告诉系统我从它的推荐中采纳了哪一部的电影，而不会去评分，我们可能告诉它质量是否可以接受，但不会像豆瓣用户那样给出0~10的准确分数。\n\n因此，传统的推荐算法有很多不适合我需求的地方，但是看问题要看本质。无非就是根据用户的特性，或者根据商品特性，进行与训练好的模型进行相似性比较。抓住这些特点，我做了少少的\"创新\"\n不基于用户的评分作相似度，而是用商品的label做标准 现在很多商品尤其是音乐或者电影，都会具有自己的label，比如说喜剧，悬疑，其次还有主演，导演等可以作为其特征。电商平台上也有诸如商品种类衣服,女鞋，包包,等，而某些物品，例如衣服，那么衣服的品牌，size，都可以作为用户的一个选择的特征。\n用户模型是动态更新的 这一点不难理解，如果一个用户长期使用使用该系统，那么他的选择中很可能已经覆盖了大量的label，这时基于label的推荐系统则很难区分该用户的喜好。这时我们有两个解决方法。第一个是允许用户自定义label，比如SF就可以自定义问题或文章的标签，这样增大了label的多样性。当然，这个解决方案只能算一个缓解的方案，要想彻底解决，我觉得需要给特征选定有效期。增加有效期后，用户的选择可以反应出一个时间段内的需求。假设这样一个场景，一名用户准备去旅游了，他可能会大量浏览旅游用品的出售页面，例如一次性牙膏等，这时，就可以向该用户推荐出售旅行用品的网站了。而超过了特征的有效期，例如一周，这时用户已经旅游回来，因为特征已经无效，推荐系统不再推荐旅游用品（这样用户不会觉得莫名其妙。个人经历，现在某些网站就往往会出现明显已经超过我感兴趣时限的推荐），而是开始重新收集用户新一周浏览的特征，动态构建用户模型，推荐用户下一阶段他可能需要的物品\n实现上述想法，在python中，我们可以这么做,实现如下字典\nrecord = {\n    \"labelName\":(weight,time),\n    \"labelName2\":(weight,time)\n    ……\n}\n\n#labelName是标签名称，在该标签下有一个元组，元组的第一个字段是这个标签的权重。\n#权重越大，表示用户越喜欢这个标签。\n#第二个字段是创建该标签的起始时间\n在实现推荐时，则较为容易实现，给定testList。这时需要:\n\n创建名res的空字典\n遍历testList，每一个对象命名为t\n遍历t具有的label，根据label从record上获取信息。\n同时获取当前时间time2，如果time2-time超出了规定时限，则该标签的信息无效，忽略该label，同时删除record里面的对应的字段。\n若该标签有效，则t的得分加1，并将t的下标index作为key假如到一个res中\n遍历完成后，对res字典按value排序\n最后，可以根据需要对排序结果进行访问。比如只获取最高的前5名。\n\n这样，一个适合少用户的推荐系统就弄出来啦~\n现在正在宿舍投入运行，至于效果如何可能要一段时间才知道了\n后话\ngithub 地址\n说明一下，github上只是提供了一个实现了上述改进后思路的类recommend.py，并不是一个成型的推荐系统，你可以下载后，根据这个类进行二次开发，比如:\n\n利用flask框架包装成一个web应用\n结合该类并利用SMTP协议，弄一个自动往邮箱发信息的脚本，推荐的电影信息\n将类实例化，弄出简单的命令行应用\n\n迟下我会上传一个使用falsk封装的一个简单的webserver去github,可以通过web API请求，返回json格式的电影信息。\n如有错误，望指正。\n\n                ", "mainLikeNum": ["7 "], "mainBookmarkNum": "52"}