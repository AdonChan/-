{"title": "Flask 源码阅读笔记 开篇 - python大法好 ", "index": "python", "content": "\nFlask 是一个 Python 实现的 Web 开发微框架, 有丰富的生态资源。本文从一段官方的示例代码通过一步步打断点方式解释 Flask 内部的运行机制，在一些关键概念会有相关解释，这些前提概念对整体理解 Flask框架十分重要，本文基于flask 0.1 版本进行相应的分析。\n\n官方demo示例\nfrom flask import Flask\napp = Flask(__name__)\n\n@app.route('/')\ndef hello_world():\n    return 'Hello World!'\n\nif __name__ == '__main__':\n    app.run()\n第一行import Flask 类对象，这个无需解释。跳到第二行，使用当前模块的名字传入Flask类中，并实例化Flask对象，我们在这个地方打个断点，看看Flask类别里有什么。上图可以看出，Flask类中定义jinia_options、request_class、response_class等属性，这里我们不关系具体作用，先看看源码中Flask 是不是定义了这些属性。\nclass Flask(object):\n    # 省略了注释部分\n    # flask 用作请求对象的类\n    request_class = Request\n    # flask 用作响应对象的类\n    response_class = Response\n    # 静态文件路径\n    static_path = '/static'\n    # 密钥，用于加密 session 或其它涉及安全的东西\n    secret_key = None\n    #存储session对象数据的cookie名称\n    session_cookie_name = 'session'\n    # Jinja2环境的一些选项\n    jinja_options = dict(\n        autoescape=True,\n        extensions=['jinja2.ext.autoescape', 'jinja2.ext.with_']\n    )\n这部分是初始化Flask类中默认设置的一些属性，其实通过名字也可以大概知道每个属性的作用。看到这个地方时是不是一脸懵逼，Request、Response 是什么东西，有什么作用？Jinja2 又是什么东西？ 别急，下面慢慢解释这几个东西的作用。\nRequest && Response\nfrom werkzeug import Request as RequestBase, Response as ResponseBase\n\nclass Request(RequestBase):\n    \"\"\"The request object used by default in flask.  Remembers the\n    matched endpoint and view arguments.\n\n    It is what ends up as :class:`~flask.request`.  If you want to replace\n    the request object used you can subclass this and set\n    :attr:`~flask.Flask.request_class` to your subclass.\n    \"\"\"\n\n    def __init__(self, environ):\n        RequestBase.__init__(self, environ)\n        self.endpoint = None     # 请求对象的端点\n        self.view_args = None    # 请求视图函数的参数\n\nclass Response(ResponseBase):\n    \"\"\"The response object that is used by default in flask.  Works like the\n    response object from Werkzeug but is set to have a HTML mimetype by\n    default.  Quite often you don't have to create this object yourself because\n    :meth:`~flask.Flask.make_response` will take care of that for you.\n\n    If you want to replace the response object used you can subclass this and\n    set :attr:`~flask.Flask.request_class` to your subclass.\n    \"\"\"\n    default_mimetype = 'text/html'\n通过源码的注释我们可以知道，Request、Response都只是对 werkzeug 库的Request、Response 进行了一层包装并加入一些属性。先说一下它们的作用：\n\nRequest 的作用：是 flask 默认的请求对象，用来记住匹配的endpoint(端点）和view arguments(视图参数)\nResponse 的作用：是 flask 默认的响应对象，默认设置MIME类型默认设置为HTML(即是定义了内容类型 Content-Type 返回的类型为HTML), 默认情况下，你不用自己创建这个对象，因为下面的 make_response 函数会帮你处理。\n\n看完上面源码和解释，是不是有新的疑问了，werkzeug又是什么？端点又是什么概念？额，werkzeug的作用真的很大，整个框架都是基于它实现的，下面会有一个部分专门说明这个库。说明： werkzeug 库和 jinja2 是 flask 的两个依赖库，会分出一篇文章专门介绍，这篇文章重点是整个 Flask 内部的机制，建议看到对应部分，先提前去读两个依赖库的文章。\n接下来继续下一步的调试，初始化一个Flask类, 先看看 Flask 类的初始化函数：\n\ndef _get_package_path(name):\n    \"\"\"Returns the path to a package or cwd if that cannot be found.\"\"\"\n    # 获取 模块包 路径，被 Flask 引用\n    try:\n        return os.path.abspath(os.path.dirname(sys.modules[name].__file__))\n    except (KeyError, AttributeError):\n        return os.getcwd()\n\nclass Flask(object):\n      # 简化版，已经去掉注释，建议看源码注释加上这个理解\n     def __init__(self, package_name):\n        # 设置是否开启调试模式，若开启，会监视项目代码变化，\n        # 开发服务器重载 Flask 应用\n        self.debug = False\n\n        # 包或模块的名字，模块的名称将会因其作为单独应用启动还是作为模块导入而不同\n        # Flask 才知道到哪去找模板、静态文件\n        self.package_name = package_name\n\n        # 根据 Flask 传入的__name__, 找到项目的根路径\n        self.root_path = _get_package_path(self.package_name)\n\n        # 已注册的所有视图函数的字典，字典的键是函数名称，可以用来生成URL(url_for函数)\n        # 字典的值是函数本身, 想要注册视图函数，可以使用 route 装饰器 \n        self.view_functions = {}\n\n        # 所有已注册错误处理程序的字典, 字典的键是一个整数类型（integer)的错误码\n        # 字典的值是对应错误的函数，想要注册错误handler, 可以使用 errorhandler 装饰器\n        self.error_handlers = {}\n\n        # 请求开始进入时，但还请求还没调度前调用的函数列表，也就是预处理操作\n        # 可用于打开数据库连接或获取当前登录用户，使用 before_route 装饰器注册\n        self.before_request_funcs = []\n\n        # 请求结束时调用的函数列表，这些函数会被传入当前响应对象并将其修改或替换它。\n        self.after_request_funcs = []\n \n        # 不带参数调用的函数列表，用于填充模板上下文，每个应该返回更新模板上下文的字典\n        # 默认的处理器用来注入session、request和g\n        self.template_context_processors = [_default_template_ctx_processor]\n        \n        # 使用 werkzeug 的 routing.Map, 用于给应用增加一些URL规则，\n        # URL规则形成一个Map实例的过程中会生成对应的正则表达式，可以进行URL匹配\n        self.url_map = Map()\n        \n        # 添加静态文件的URL映射规则\n        # SharedDataMiddleware中间件用来为程序添加处理静态文件的能力\n        if self.static_path is not None:\n            self.url_map.add(Rule(self.static_path + '/<filename>',\n                                  build_only=True, endpoint='static'))\n            if pkg_resources is not None:\n                target = (self.package_name, 'static')\n            else:\n                target = os.path.join(self.root_path, 'static')\n            self.wsgi_app = SharedDataMiddleware(self.wsgi_app, {\n                self.static_path: target   # URL路径和实际文件目录（static文件夹）的映射\n            })\n        \n        # Jinja2 环境，它通过jinja_options创建，加载器（loader）通过\n        self.jinja_env = Environment(loader=self.create_jinja_loader(),\n                                     **self.jinja_options)\n        # 将url_for, get_flashed_message 作为全局对象填充入模板上下文中，可以在模板中调用它们\n        self.jinja_env.globals.update(\n            url_for=url_for,\n            get_flashed_messages=get_flashed_messages\n        )\n上面就是一个 Flask 实例化时所做的工作，其实就是保存了一下配置信息，设置了一下Jinja2 环境，并定义了一个URL 映射对象，用于映射URL 到函数之间的关系。\n总结\n开篇主要讲了初始化一个Flask对象，内部做了什么工作，配置了一下信息，设置了一下Jinja2 环境，定义了一些视图函数存放的数据结构，定义了一个Map对象用于后面保存URL 和 视图函数的映射关系。接下来会有更多关于werkzeug, jinja2 和 WSGI 相关文章放出来，敬请期待！！！\n参考\nflask文档flask项目源码0.1版本flask注释版\n\n                ", "mainLikeNum": ["8 "], "mainBookmarkNum": "3"}