{"title": "Python中单线程、多线程和多进程的效率对比实验 - 木之阳兮，卿云烂兮 ", "index": "python,多线程,多进程", "content": "\ntitle: Python中单线程、多线程与多进程的效率对比实验date: 2016-09-30 07:05:47tags: [多线程,多进程,Python]categories: [Python]\nmeta: Python中多线程和多进程的对比\nPython是运行在解释器中的语言，查找资料知道，python中有一个全局锁（GIL），在使用多进程(Thread)的情况下，不能发挥多核的优势。而使用多进程(Multiprocess)，则可以发挥多核的优势真正地提高效率。\n对比实验\n资料显示，如果多线程的进程是CPU密集型的，那多线程并不能有多少效率上的提升，相反还可能会因为线程的频繁切换，导致效率下降，推荐使用多进程；如果是IO密集型，多线程进程可以利用IO阻塞等待时的空闲时间执行其他线程，提升效率。所以我们根据实验对比不同场景的效率\n\n\n操作系统\nCPU\n内存\n硬盘\n\n\nWindows 10\n双核\n8GB\n机械硬盘\n\n\n<!--more-->\n(1)引入所需要的模块\nimport requests\nimport time\nfrom threading import Thread\nfrom multiprocessing import Process\n(2)定义CPU密集的计算函数\ndef count(x, y):\n    # 使程序完成50万计算\n    c = 0\n    while c < 500000:\n        c += 1\n        x += x\n        y += y\n（3）定义IO密集的文件读写函数\ndef write():\n    f = open(\"test.txt\", \"w\")\n    for x in range(5000000):\n        f.write(\"testwrite\\n\")\n    f.close()\n\ndef read():\n    f = open(\"test.txt\", \"r\")\n    lines = f.readlines()\n    f.close()\n(4) 定义网络请求函数\n_head = {\n            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.116 Safari/537.36'}\nurl = \"http://www.tieba.com\"\ndef http_request():\n    try:\n        webPage = requests.get(url, headers=_head)\n        html = webPage.text\n        return {\"context\": html}\n    except Exception as e:\n        return {\"error\": e}\n(5)测试线性执行IO密集操作、CPU密集操作所需时间、网络请求密集型操作所需时间\n# CPU密集操作\nt = time.time()\nfor x in range(10):\n    count(1, 1)\nprint(\"Line cpu\", time.time() - t)\n\n# IO密集操作\nt = time.time()\nfor x in range(10):\n    write()\n    read()\nprint(\"Line IO\", time.time() - t)\n\n# 网络请求密集型操作\nt = time.time()\nfor x in range(10):\n    http_request()\nprint(\"Line Http Request\", time.time() - t)\n输出\n\n\n \n \n \n \n \n\n\n\nCPU密集\n95.6059999466\n91.57099986076355\n92.52800011634827\n99.96799993515015\n\n\nIO密集\n24.25\n21.76699995994568\n21.769999980926514\n22.060999870300293\n\n\n网络请求密集型\n4.519999980926514\n8.563999891281128\n4.371000051498413\n14.671000003814697\n\n\n\n(6)测试多线程并发执行CPU密集操作所需时间\ncounts = []\nt = time.time()\nfor x in range(10):\n    thread = Thread(target=count, args=(1,1))\n    counts.append(thread)\n    thread.start()\n\nwhile True:\n    e = len(counts)\n    for th in counts:\n        if not th.is_alive():\n            e -= 1\n    if e <= 0:\n        break\nprint(time.time() - t)\n\noutput\n\n99.9240000248\n101.26400017738342\n102.32200002670288\n\n\n(7)测试多线程并发执行IO密集操作所需时间\ndef io():\n    write()\n    read()\n\nt = time.time()\nios = []\nt = time.time()\nfor x in range(10):\n    thread = Thread(target=count, args=(1,1))\n    ios.append(thread)\n    thread.start()\n\n\nwhile True:\n    e = len(ios)\n    for th in ios:\n        if not th.is_alive():\n            e -= 1\n    if e <= 0:\n        break\nprint(time.time() - t)\n\nOutput\n\n25.69700002670288\n24.02400016784668\n\n\n(8)测试多线程并发执行网络密集操作所需时间\nt = time.time()\nios = []\nt = time.time()\nfor x in range(10):\n    thread = Thread(target=http_request)\n    ios.append(thread)\n    thread.start()\n\nwhile True:\n    e = len(ios)\n    for th in ios:\n        if not th.is_alive():\n            e -= 1\n    if e <= 0:\n        break\nprint(\"Thread Http Request\", time.time() - t)\n\nOutput\n\n0.7419998645782471\n0.3839998245239258\n0.3900001049041748\n\n\n(9)测试多进程并发执行CPU密集操作所需时间\ncounts = []\nt = time.time()\nfor x in range(10):\n    process = Process(target=count, args=(1,1))\n    counts.append(process)\n    process.start()\n\nwhile True:\n    e = len(counts)\n    for th in counts:\n        if not th.is_alive():\n            e -= 1\n    if e <= 0:\n        break\nprint(\"Multiprocess cpu\", time.time() - t)\n\nOutput\n\n54.342000007629395\n53.437999963760376\n\n\n(10)测试多进程并发执行IO密集型操作\nt = time.time()\nios = []\nt = time.time()\nfor x in range(10):\n    process = Process(target=io)\n    ios.append(process)\n    process.start()\n\n\nwhile True:\n    e = len(ios)\n    for th in ios:\n        if not th.is_alive():\n            e -= 1\n    if e <= 0:\n        break\nprint(\"Multiprocess IO\", time.time() - t)\n\nOutput\n\n12.509000062942505\n13.059000015258789\n\n\n(11)测试多进程并发执行Http请求密集型操作\nt = time.time()\nhttprs = []\nt = time.time()\nfor x in range(10):\n    process = Process(target=http_request)\n    ios.append(process)\n    process.start()\n\nwhile True:\n    e = len(httprs)\n    for th in httprs:\n        if not th.is_alive():\n            e -= 1\n    if e <= 0:\n        break\nprint(\"Multiprocess Http Request\", time.time() - t)\n|Output||0.5329999923706055||0.4760000705718994|\n\n实验结果\n\n\n \nCPU密集型操作\nIO密集型操作\n网络请求密集型操作\n\n\n\n线性操作\n94.91824996469\n22.46199995279\n7.3296000004\n\n\n多线程操作\n101.1700000762\n24.8605000973\n0.5053332647\n\n\n多进程操作\n53.8899999857\n12.7840000391\n0.5045000315\n\n\n\n通过上面的结果，我们可以看到：\n\n多线程在IO密集型的操作下似乎也没有很大的优势（也许IO操作的任务再繁重一些就能体现出优势），在CPU密集型的操作下明显地比单线程线性执行性能更差，但是对于网络请求这种忙等阻塞线程的操作，多线程的优势便非常显著了\n多进程无论是在CPU密集型还是IO密集型以及网络请求密集型（经常发生线程阻塞的操作）中，都能体现出性能的优势。不过在类似网络请求密集型的操作上，与多线程相差无几，但却更占用CPU等资源，所以对于这种情况下，我们可以选择多线程来执行\n\n\n\n此文为1年随手写的，多谢评论区指出谬误，因数据是平均数，影响不大，故未做修改\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "10"}