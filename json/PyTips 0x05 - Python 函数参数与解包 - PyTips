{"title": "PyTips 0x05 - Python 函数参数与解包 - PyTips ", "index": "pytips,python3.5,python", "content": "项目地址：https://git.io/pytips\n函数调用的参数规则与解包\nPython 的函数在声明参数时大概有下面 4 种形式：\n\n不带默认值的：def func(a): pass\n带有默认值的：def func(a, b = 1): pass\n任意位置参数：def func(a, b = 1, *c): pass\n任意键值参数：def func(a, b = 1, *c, **d): pass\n\n在调用函数时，有两种情况：\n\n没有关键词的参数：func(\"G\", 20)\n带有关键词的参数：func(a = \"G\", b = 20)（其中带有关键词调用可以不考虑顺序：func(b = 20, a = \"G\"）\n\n当然，这两种情况是可以混用的：func(\"G\", b = 20)，但最重要的一条规则是位置参数不能在关键词参数之后出现：\ndef func(a, b = 1):\n    pass\nfunc(a = \"G\", 20) # SyntaxError 语法错误\n  File \"<ipython-input-1-3ca775953480>\", line 3\n    func(a = \"G\", 20) # SyntaxError 语法错误\n                 ^\nSyntaxError: positional argument follows keyword argument\n\n另外一条规则是：位置参数优先权：\ndef func(a, b = 1):\n    pass\nfunc(20, a = \"G\") # TypeError 对参数 a 重复赋值\n---------------------------------------------------------------------------\n\nTypeError                                 Traceback (most recent call last)\n\n<ipython-input-2-cbaa9a1fe24d> in <module>()\n      1 def func(a, b = 1):\n      2     pass\n----> 3 func(20, a = \"G\") # TypeError 对参数 a 重复赋值\n\n\nTypeError: func() got multiple values for argument 'a'\n\n最保险的方法就是全部采用关键词参数。\n任意参数\n任意参数可以接受任意数量的参数，其中*a的形式代表任意数量的位置参数，**d代表任意数量的关键词参数：\ndef concat(*lst, sep = \"/\"):\n    return sep.join((str(i) for i in lst))\n\nprint(concat(\"G\", 20, \"@\", \"Hz\", sep = \"\"))\nG20@Hz\n\n上面的这个def concat(*lst, sep = \"/\")的语法是PEP 3102提出的，在 Python 3.0 之后实现。这里的关键词函数必须明确指明，不能通过位置推断：\nprint(concat(\"G\", 20, \"-\")) # Not G-20\nG/20/-\n\n**d则代表任意数量的关键词参数\ndef dconcat(sep = \":\", **dic):\n    for k in dic.keys():\n        print(\"{}{}{}\".format(k, sep, dic[k]))\n\ndconcat(hello = \"world\", python = \"rocks\", sep = \"~\")\nhello~world\npython~rocks\n\nUnpacking\nPython 3.5 添加的新特性（PEP 448），使得*a、**d可以在函数参数之外使用：\nprint(*range(5))\nlst = [0, 1, 2, 3]\nprint(*lst)\n\na = *range(3), # 这里的逗号不能漏掉\nprint(a)\n\nd = {\"hello\": \"world\", \"python\": \"rocks\"}\nprint({**d}[\"python\"])\n0 1 2 3 4\n0 1 2 3\n(0, 1, 2)\nrocks\n\n所谓的解包（Unpacking）实际上可以看做是去掉()的元组或者是去掉{}的字典。这一语法也提供了一个更加 Pythonic 地合并字典的方法：\nuser = {'name': \"Trey\", 'website': \"http://treyhunner.com\"}\ndefaults = {'name': \"Anonymous User\", 'page_name': \"Profile Page\"}\n\nprint({**defaults, **user})\n{'page_name': 'Profile Page', 'name': 'Trey', 'website': 'http://treyhunner.com'}\n\n在函数调用的时候使用这种解包的方法则是 Python 2.7 也可以使用的：\nprint(concat(*\"ILovePython\"))\nI/L/o/v/e/P/y/t/h/o/n\n\n参考\nThe Idiomatic Way to Merge Dictionaries in Python\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "6"}