{"title": "opencv python 使用特征匹配和单应性查找对象 - 个人文章 ", "index": "opencv-python,opencv,python", "content": "Feature Matching + Homography to find Objects \n联合使用特征提取和 calib3d 模块中的 findHomography 在复杂图像中查找已知对象.\n之前在一张杂乱的图像中找到了一个对象（的某些部分）的位置.这些信息足以帮助我们在目标图像中准确的找到（查询图像）对象.为了达到这个目的可以使用 calib3d 模块中的cv2.findHomography()函数.如果将这两幅图像中的特征点集传给这个函数，他就会找到这个对象的透视图变换.然后就可以使用函数 cv2.perspectiveTransform() 找到这个对象了.至少要 4 个正确的点才能找到这种变换.在匹配过程可能会有一些错误，而这些错误会影响最终结果。为了解决这个问题，算法使用 RANSAC 和 LEAST_MEDIAN(可以通过参数来设定).所以好的匹配提供的正确的估计被称为 inliers，剩下的被称为outliers.cv2.findHomography() 返回一个掩模，这个掩模确定了 inlier 和outlier 点.\nimport numpy as np\nimport cv2\nimport matplotlib.pyplot as plt\n\nMIN_MATCH_COUNT = 10\n\nimg1 = cv2.imread('img.jpg',0)          # queryImage\nimg2 = cv2.imread('img1.jpg',0) # trainImage\n\n# Initiate SIFT detector\nsift = cv2.xfeatures2d.SIFT_create()\n\n\n# find the keypoints and descriptors with SIFT\nkp1, des1 = sift.detectAndCompute(img1,None)\nkp2, des2 = sift.detectAndCompute(img2,None)\n\nFLANN_INDEX_KDTREE = 0\nindex_params = dict(algorithm = FLANN_INDEX_KDTREE, trees = 5)\nsearch_params = dict(checks = 50)\n\nflann = cv2.FlannBasedMatcher(index_params, search_params)\n\nmatches = flann.knnMatch(des1,des2,k=2)\n\n# store all the good matches as per Lowe's ratio test.\ngood = []\nfor m,n in matches:\n    if m.distance < 0.7*n.distance:\n        good.append(m)\nif len(good)>MIN_MATCH_COUNT:\n    src_pts = np.float32([ kp1[m.queryIdx].pt for m in good ]).reshape(-1,1,2)\n    dst_pts = np.float32([ kp2[m.trainIdx].pt for m in good ]).reshape(-1,1,2)\n\n    M, mask = cv2.findHomography(src_pts, dst_pts, cv2.RANSAC,5.0)\n    matchesMask = mask.ravel().tolist()\n\n    h,w = img1.shape\n    pts = np.float32([ [0,0],[0,h-1],[w-1,h-1],[w-1,0] ]).reshape(-1,1,2)\n    dst = cv2.perspectiveTransform(pts,M)\n\n    img2 = cv2.polylines(img2,[np.int32(dst)],True,255,3, cv2.LINE_AA)\n\nelse:\n    print(\"Not enough matches are found - %d/%d\" % (len(good),MIN_MATCH_COUNT))\n    matchesMask = None\n\n# Finally we draw our inliers (if successfully found the object) or matching keypoints (if failed).\n\ndraw_params = dict(matchColor = (0,255,0), # draw matches in green color\n                   singlePointColor = None,\n                   matchesMask = matchesMask, # draw only inliers\n                   flags = 2)\n\nimg3 = cv2.drawMatches(img1,kp1,img2,kp2,good,None,**draw_params)\n\nplt.imshow(img3, 'gray'),plt.show()\n\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}