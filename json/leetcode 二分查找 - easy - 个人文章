{"title": "leetcode 二分查找 - easy - 个人文章 ", "index": "二分查找,python", "content": "\n有时候会抽时间看看题目，锻炼一下简单记录下二分查找吧，会持续更新的啊哈~~~仅供参考，路过看下就行，欢迎交流~\n\n第35题\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。例如：输入: [1,3,5,6], 5    输出: 2输入: [1,3,5,6], 2    输出: 1输入: [1,3,5,6], 7    输出: 4输入: [1,3,5,6], 0    输出: 0\n想法：简单粗暴一点，因为是排序数组，所以直接for遍历就可以了。\nclass Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        # 如果target大于max(nums),则直接插入最后位置\n        for i in range(0,len(nums)):\n            if nums[i] >= target:\n                return i\n        return len(nums)\n但是若目标值若是最大的，则得等循环len(nums)遍才能找到，时间复杂度高。也因为是排序的数组，所以可以考虑二分法。\nclass Solution(object):\n    def searchInsert(self, nums, target):\n        left = 0\n        right = len(nums)-1\n        while left <= right :\n            # 中间的数\n            middle = (right-left) / 2 + left\n            if nums[middle] == target:\n                return middle\n            elif nums[middle] > target : # 即target在左边\n                right = middle - 1 \n            else :\n                left = middle + 1\n        return left\n\n第69题：x的平方根\n实现 int sqrt(int x) 函数。计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。输入: 8输出: 2说明: 8 的平方根是 2.82842...,\n 由于返回类型是整数，小数部分将被舍去。\nclass Solution(object):\n    def mySqrt(self, x):\n        l, r = 0, x\n        while l <= r:\n            mid = l + (r-l)//2\n            if mid * mid <= x < (mid+1)*(mid+1):\n                return mid\n            elif x < mid * mid:\n                r = mid\n            else:\n                l = mid + 1\n\n第367题：有效的完全平方数\n给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。说明：不要使用任何内置的库函数，如  sqrt。输入：16    输出：True输入：14    输出：False\nclass Solution:\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        left = 0\n        right = num\n        #tag = None\n        while left <= right :\n            mid = (right-left)//2  + left   # 减少循环次数\n            val = mid *mid \n            if val == num :\n                #tag = True\n                return True\n            elif val > num :\n                #tag = False\n                right = mid - 1 \n            else:\n                #tag = False\n                left = mid + 1\n        #return tag  \n        # 注释掉部分减少运行时间，其次通过val来减少中间运算\n        return False\n\n第441题：排列硬币\n你总共有 n 枚硬币，你需要将它们摆成一个阶梯形状，第 k 行就必须正好有 k 枚硬币。给定一个数字 n，找出可形成完整阶梯行的总行数。n 是一个非负整数，并且在32位有符号整型的范围内。n = 5硬币可排列成以下几行:¤¤ ¤¤ ¤因为第三行不完整，所以返回2.\nn = 8硬币可排列成以下几行:¤¤ ¤¤ ¤ ¤¤ ¤因为第四行不完整，所以返回3.\nclass Solution(object):\n    def arrangeCoins(self, n):\n        if n == 0:\n            return 0\n        left = 1\n        right = n/2\n        while left <= right:\n            mid = (right-left)/2+left\n            total = (mid * (mid+1)) / 2\n            if total > n:\n                right = mid - 1\n            elif n - total < mid + 1:\n                return mid\n            elif n-total == mid + 1:\n                return mid+1\n            else:\n                left = left + 1\n        return left\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "1"}