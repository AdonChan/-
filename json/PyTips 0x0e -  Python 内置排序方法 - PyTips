{"title": "PyTips 0x0e -  Python 内置排序方法 - PyTips ", "index": "pytips,python3.5,python", "content": "项目地址：https://git.io/pytips\nPython 提供两种内置排序方法，一个是只针对 List 的原地（in-place）排序方法 list.sort()，另一个是针对所有可迭代对象的非原地排序方法 sorted()。\n所谓原地排序是指会立即改变被排序的列表对象，就像 append()/pop() 等方法一样：\nfrom random import randrange\nlst = [randrange(1, 100) for _ in range(10)]\nprint(lst)\nlst.sort()\n\nprint(lst)\n[57, 81, 32, 74, 12, 89, 76, 21, 75, 6]\n[6, 12, 21, 32, 57, 74, 75, 76, 81, 89]\n\nsorted() 不限于列表，而且会生成并返回一个新的排序后的列表，原有对象不受影响：\nlst = [randrange(1, 100) for _ in range(10)]\ntup = tuple(lst)\n\nprint(sorted(tup)) # return List\nprint(tup)\n[11, 36, 39, 41, 48, 48, 50, 76, 79, 99]\n(11, 41, 79, 48, 48, 99, 39, 76, 36, 50)\n\n虽然不是原地排序，但如果是传入生成器，还是会被循环掉的：\ntup = (randrange(1, 100) for _ in range(10))\nprint(sorted(tup))\nfor i in tup:\n    print(i)\n[5, 12, 15, 21, 57, 69, 73, 83, 90, 95]\n\nKey\n对简单的迭代对象进行排序只需要逐次提取元素进行比较即可，如果想要对元素进行一些操作再进行比较，可以通过 key 参数指定一个取值函数。这里的 key 用法很像 0x02 函数式编程提到的 map/filter 所接受的函数，不同之处在于这里的 key 函数只是在排序比较前对元素进行处理，并不会改变元素原本的值，例如我们对一组整数按照（key 可以理解为按照的意思）绝对值进行排序：\nlst = [randrange(-10, 10) for _ in range(10)]\nprint(lst)\nprint(sorted(lst, key=abs))\n[0, 7, 0, -10, 3, 7, -9, -10, -7, -10]\n[0, 0, 3, 7, 7, -7, -9, -10, -10, -10]\n\n或者，当迭代对象的元素较为复杂时，可以只按照其中的某些属性进行排序：\nlst = list(zip(\"hello world hail python\".split(), [randrange(1, 10) for _ in range(4)]))\nprint(lst)\nprint(sorted(lst, key=lambda item: item[1]))\n[('hello', 3), ('world', 3), ('hail', 9), ('python', 9)]\n[('hello', 3), ('world', 3), ('hail', 9), ('python', 9)]\n\nPython 的 operator 标准库提供了一些操作符相关的方法，可以更方便地获取元素的属性：\nfrom operator import itemgetter, attrgetter\n\nprint(lst)\nprint(sorted(lst, key=itemgetter(1)))\n\n# 一切都只是函数\nfitemgetter = lambda ind: lambda item: item[ind]\nprint(sorted(lst, key=fitemgetter(1)))\n\nclass P(object):\n    def __init__(self, w, n):\n        self.w = w\n        self.n = n\n    def __repr__(self):\n        return \"{}=>{}\".format(self.w, self.n)\nps = [P(i[0], i[1]) for i in lst]\n\nprint(sorted(ps, key=attrgetter('n')))\n[('hello', 3), ('world', 3), ('hail', 9), ('python', 9)]\n[('hello', 3), ('world', 3), ('hail', 9), ('python', 9)]\n[('hello', 3), ('world', 3), ('hail', 9), ('python', 9)]\n[hello=>3, world=>3, hail=>9, python=>9]\n\n经过 key 处理之后会通过 < 符号对两个元素进行比较，在 Python 2.7 的版本中，sorted() 还可以接收另外一个参数 cmp，用来接管 < 的比较过程。但是在 Python 3.5 中已经全面摒弃了这一做法，包括 sorted() 中的 cmp 参数和对象中的 __cmp__ 比较操作，只有在需要向后兼容的时候才可能在 Python 3.5 用到这一功能，其替换的方法为：\nfrom functools import cmp_to_key as new_cmp_to_key\n\n# new_cmp_to_key works like this\ndef cmp_to_key(mycmp):\n    'Convert a cmp= function into a key= function'\n    class K:\n        def __init__(self, obj, *args):\n            self.obj = obj\n        def __lt__(self, other):\n            return mycmp(self.obj, other.obj) < 0\n    return K\ndef reverse_cmp(x, y):\n    return y[1] - x[1]\nsorted(lst, key=cmp_to_key(reverse_cmp))\n\n[('hail', 9), ('python', 9), ('hello', 3), ('world', 3)]\n\n如果想要按照递减排序，只需要设定参数 reverse = True 即可。\n\n欢迎关注公众号 PyHub！\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "5"}