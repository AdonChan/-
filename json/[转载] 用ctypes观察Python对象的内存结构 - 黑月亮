{"title": "[转载] 用ctypes观察Python对象的内存结构 - 黑月亮 ", "index": "python", "content": "转载地址：http://hyry.dip.jp/tech/slice/slice.html/10\n在 Python 中一切皆是对象，而在实现 Python 的 C 语言中，这些对象只不过是一些比较复杂的结构体而已。本文通过 ctypes 访问对象对应的结构体中的数据，加深对 Python 对象的理解。\n对象的两个基本属性\nPython 所有对象结构体中的头两个字段都是相同的：\n\nrefcnt：对象的引用次数，若引用次数为 0 则表示此对象可以被垃圾回收了。\n\ntypeid：指向描述对象类型的对象的指针。\n通过 ctypes，我们可以很容易定义一个这样的结构体：PyObject。\n注意：本文只描述在 32 位操作系统下的情况，如果读者使用的是 64 位操作系统，需要对程序中的一些字段类型做一些改变。\n\n\nfrom ctypes import *\n\nclass PyObject(Structure):\n    _fields_ = [(\"refcnt\", c_size_t),\n                (\"typeid\", c_void_p)]\n下面让我们用 PyObject 做一些实验帮助理解这两个字段的含义：\n>>> a = \"this is a string\"\n>>> obj_a = PyObject.from_address(id(a)) ❶\n>>> obj_a.refcnt ❷\n1L\n>>> b = [a]*10\n>>> obj_a.refcnt ❸\n11L\n>>> obj_a.typeid ❹\n505269056\n>>> id(type(a))\n505269056\n>>> id(str)\n505269056\n\n❶通过 id(a) 可以获得对象 a 的内存地址，而 PyObject.from_address()可以将指定的内存地址的内容转换为一个 PyObject 对象。通过此 PyObject 对象obj_a 可以访问对象 a 的结构体中的内容。❷查看对象 a 的引用次数，由于只有 a 这个名字引用它，因此值为 1。接下来创建一个列表，此列表中的每个元素都是对象 a，因此此列表应用了它 10 次，❸所以引用次数变为了 11。❸查看对象 a 的类型对象的地址，它和 id(type(a)) 相同，而由于对象a的类型为str，因此也就是 id(str)。\n下面查看str类型对象的这两个字段：\n>>> obj_str = PyObject.from_address(id(str))\n>>> obj_str.refcnt\n252L\n>>> obj_str.typeid\n505208152\n>>> id(type)\n505208152\n\n可以看到 str 的类型就是type。再看看 type 对象：\n>>> type_obj = PyObject.from_address(id(type))\n>>> type_obj.typeid\n505208152\n\ntype 对象的类型指针就指向它自己，因为 type(type) is type。\n整数和浮点数对象\n接下来看看整数和浮点数对象，这两个对象除了有 PyObject 中的两个字段之外，还有一个 val 字段保存实际的值。因此 Python 中一个整数占用 12 个字节，而一个浮点数占用 16 个字节：\n>>> sys.getsizeof(1)\n12\n>>> sys.getsizeof(1.0)\n16\n我们无需重新定义 refcnt 和 typeid 这两个字段，通过继承 PyObject，可以很方便地定义整数和浮点数对应的结构体，它们会继承父类中定义的字段：\nclass PyInt(PyObject):\n    _fields_ = [(\"val\", c_long)]\n\nclass PyFloat(PyObject):\n    _fields_ = [(\"val\", c_double)]\n下面是使用 PyInt 查看整数对象的例子：\n>>> i = 2000\n>>> i_obj = PyInt.from_address(id(a))\n>>> i_obj.refcnt\n1L\n>>> i_obj.val\n2000\n\n通过 PyInt 对象，还可以修改整数对象的内容：修改不可变对象的内容会造成严重的程序错误，请不要用于实际的程序中。\n>>> j = i\n>>> i_obj.val = 2012\n>>> j\n2012\n\n由于i和j引用的是同一个整数对象，因此i和j的值同时发生了变化。\n结构体大小不固定的对象\n表示字符串和长整型数的结构体的大小不是固定的，这些结构体在 C 语言中使用了一种特殊的字段定义技巧，使得结构体中最后一个字段的大小可以改变。由于结构体需要知道最后一个字段的长度，因此这种结构中包含了一个 size 字段，保存最后一个字段的长度。在 ctypes 中无法表示这种长度不固定的字段，因此我们使用了动态创建结构体类的方法。\nclass PyVarObject(PyObject):\n    _fields_ = [(\"size\", c_size_t)]\n\nclass PyStr(PyVarObject):\n    _fields_ = [(\"hash\", c_long),\n                (\"state\", c_int),\n                (\"_val\", c_char*0)]  ❶\n\nclass PyLong(PyVarObject):\n    _fields_ = [(\"_val\", c_uint16*0)]\n\ndef create_var_object(struct, obj):\n    inner_type = None\n    for name, t in struct._fields_:\n        if name == \"_val\":                      ❷\n            inner_type = t._type_\n    if inner_type is not None:\n        tmp = PyVarObject.from_address(id(obj))  ❸\n        size = tmp.size\n        class Inner(struct):              ❹\n            _fields_ = [(\"val\", inner_type*size)]\n        Inner.__name__ = struct.__name__\n        struct = Inner\n    return struct.from_address(id(obj))\n❶在定义长度不固定的字段时，使用长度为 0 的数组定义一个不占内存的伪字段 _val。 create_var_object() 用来创建大小不固定的结构体对象，❷首先搜索名为 _val 的字段，并将其类型保存到 inner_type 中。❸然后创建一个PyVarObject 结构体读取obj对象中的 size 字段。❹再通过 size 字段的大小创建一个对应的 Inner 结构体类，它可以从 struct 继承，因为 struct  中的 _val 字段不占据内存。下面我们用上面的程序做一些实验：\n>>> s_obj = create_var_object(PyStr, s)\n>>> s_obj.size\n9L\n>>> s_obj.val\n'abcdegfgh'\n当整数的范围超过了 0x7fffffff 时，Python 将使用长整型整数：\n>>> l = 0x1234567890abcd\n>>> l_obj = create_var_object(PyLong, l)\n>>> l_obj.size\n4L\n>>> val = list(l_obj.val)\n>>> val\n[11213, 28961, 20825, 145]\n\n可以看到 Python 用了 4 个 16 位的整数表示 0x1234567890abcd，下面我们看看长整型数是如何用数组表示的：\n>>> hex((val[3] << 45) + (val[2] << 30) + (val[1] << 15) + val[0])\n'0x1234567890abcdL'\n即数组中的后面的元素表示高位，每个 16 为整数中有 15 位表示数值。\n列表对象\n列表对象的长度是可变的，因此不能采用字符串那样的结构体，而是使用了一个指针字段items指向可变长度的数组，而这个数组本身是一个指向 PyObject 的指针。 allocated 字段表示这个指针数组的长度，而 size 字段表示指针数组中已经使用的元素个数，即列表的长度。列表结构体本身的大小是固定的。\nclass PyList(PyVarObject):\n    _fields_ = [(\"items\", POINTER(POINTER(PyObject))),\n                (\"allocated\", c_size_t)]\n\n    def print_field(self):\n        print self.size, self.allocated, byref(self.items[0])\n我们用下面的程序查看往列表中添加元素时，列表结构体中的各个字段的变化：\ndef test_list():\n    alist = [1,2.3,\"abc\"]\n    alist_obj = PyList.from_address(id(alist))\n\n    for x in xrange(10):\n        alist_obj.print_field()\n        alist.append(x)\n运行 test_list() 得到下面的结果：\n>>> test_list()\n3 3 <cparam 'P' (02B0ACE8)>  ❶\n4 7 <cparam 'P' (028975A8)>  ❷\n5 7 <cparam 'P' (028975A8)>\n6 7 <cparam 'P' (028975A8)>\n7 7 <cparam 'P' (028975A8)>\n8 12 <cparam 'P' (02AAB838)>\n9 12 <cparam 'P' (02AAB838)>\n10 12 <cparam 'P' (02AAB838)>\n11 12 <cparam 'P' (02AAB838)>\n12 12 <cparam 'P' (02AAB838)>\n❶一开始列表的长度和其指针数组的长度都是 3，即列表处于饱和状态。因此❷往列表中添加新元素时，需要重新分配指针数组，因此指针数组的长度变为了 7，而地址也发生了变化。这时列表的长度为 4，因此指针数组中还有 3 个空位保存新的元素。由于每次重新分配指针数组时，都会预分配一些额外空间，因此往列表中添加元素的平均时间复杂度为 O(1)。\n下面再看看从列表删除元素时，各个字段的变化：\ndef test_list2():\n    alist = [1] * 10000\n    alist_obj = PyList.from_address(id(alist))\n\n    alist_obj.print_field()\n    del alist[10:]\n    alist_obj.print_field()\n运行test_list2()得到下面的结果：\n>>> test_list2()\n10000 10000 <cparam 'P' (034E5AB8)>\n10 17 <cparam 'P' (034E5AB8)>\n可以看出大指针数组的位置没有发生变化，但是后面额外的空间被回收了。\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "7"}