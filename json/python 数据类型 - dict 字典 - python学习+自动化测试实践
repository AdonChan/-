{"title": "python 数据类型 - dict 字典 - python学习+自动化测试实践 ", "index": "python", "content": "Dict 字典\n概述\n\ndict全称dictionary。Python内置了字典dict的支持。\ndict是一种映射类型，可以将一个物件和另外一个东西关联起来，组成一个key-value 数据对，而不管他 们各自的类型是什么。\n字典的键值key必须是可哈希的。数字和字符串可以作为键值，但是列表和其他字典不可以。\n\n键key具备唯一性，一个dict中key值唯一，当key发生冲突时，取最后该key的赋值value。\ndict是无序的、可变的，使用键-值（key-value）对存储，具有极快的查找速度。\n\n与list相比：在list中查找元素的方法，list越大，查找越慢。但是dict的实现方式，根据key值计算出value的存放位置，然后再去取存放位置的值。一个key只能对应一个value值，提高了查找速度。\n\n一、创建字典\n1、直接创建\n\n2、使用dict()创建\n使用dict创建，提供的参数必须成对出现。当不提供任何参数时，创建的是一个空字典。\n例如dict(([1,’x’],[2,’y’]))、dict(zip((1,2),(‘x’,’y’)))。\n\n3、fromkeys(key,value)创建\n\n\n二、操作\n（1） for 循环\nfor循环遍历字典的key，例如：\nfor key in dict_name:\n    print(dict_name[key])\n    # 根据字典键key进行排序输出\n    for key in sorted(dict_name):    # 是sorted()，不是sort()\n        print(dict_name[key])\n（2）in 关键字\n通过in关键字，判断某键值key是否存在，返回True or False。例如\n'pi' in d\nFalse\n（3）get( key,default=None)\nget()函数获取字典中指定key的value值，如果不存在则返回默认值。\n同时也可以自己制定默认返回值，例如get('pi',0)，当存在key为pi时，则返回0.\n>>> d.get('xiong')    # 也可以直接  d['xiong']\n90\n>>> d.get('pi',0)     # 自己指定。如果不存在该key，就返回0，存在返回原值。\n0\n（4）dict更新\n当dict里存在list类型时，可以把list当作一个item，且可以对其进行list的操作。例如：\ninventory = {\n    'gold' : 500,\n    'pouch' : ['flint', 'twine', 'gemstone'],\n    'backpack' : ['xylophone','dagger', 'bedroll','bread loaf']\n}\n# 新添加一个key-value\ninventory['burlap bag'] = ['apple', 'small ruby', 'three-toed sloth']\ninventory['gold'] += 50\ninventory['backpack'].sort()\ninventory['backpack'].remove('dagger')\n（5）pop()：删除dict中的key-value，指定或者默认key。\n>>> d = {'xiong':90,'li':95,'ping':100}\n>>> d.pop('xiong')\n90\n>>> d\n{'li': 95, 'ping': 100}\n（6）del：删除dict中的元素\n语法形式：del dict_name[key_name]\n>>> del  d['ping']\n>>> d\n{'li': 95}\n（7）clear()\nclear()清空字典中的所有元素，字典仍存在，只不过为空字典。\n# 语法形式\n>>> dict_name.clear()\n（8）len()\n统计一个dict的长度，即统计有多少个键值对，使用形式：len(dict_name)。\n（9）❤ dict的三个方法：keys()、values()、items()\nkeys()、values()、items()3个方法返回值类型不再是列表，而是视图对象(view objects)。其中：\nkeys()：返回dict_keys对象，可以查看字典的所有key，使用方法：dict_name.keys()。\nvalues()：返回dict_keys对象，可以查看字典的value，使用方法：dict_name.values()。\nitems()：返回dict_items对象，可以查看字典所有的(key,value)二元元祖，dict.items()。\n例如：\n>>> d_1 = {1:'x',2:'y',3:'z'}\n>>> d_1.keys()\ndict_keys([1, 2, 3])\n>>>\n>>> d_1.values()\ndict_values(['x', 'y', 'z'])\n>>>\n>>> d_1.items()\ndict_items([(1, 'x'), (2, 'y'), (3, 'z')])\n>>>\n>>> type(d_1.keys()),type(d_1.values()),type(d_1.items())\n(<class 'dict_keys'>, <class 'dict_values'>, <class 'dict_items'>)\n视图对象可以动态查看字典的内容，每次字典变化时，视图会自动更改：\n\n（10）copy()：字典拷贝\n例如现在有dict1，要创建一个一样的dict2，我们可以通过赋值操作“=”来创建一个内容一样的dict2，但是修改dict2的值会该表dict1的值：\n>>> dict1 = {'up':'down','right':'left','true':'false'}\n>>> dict2 = dict1\n>>> dict2['up']='change'  #对赋值而来dict2的修改会同时修改dict1（源） \n>>> dict1\n{'up': 'change', 'right': 'left', 'true': 'false'}\n这是为什么呢？可以看下图，通过赋值操作“=”创建的新的字典变量，其指向的id都是一样的，所以当修改新变量的内容引用时，源指向的id内容也发生了改变。\n\n如果要想修改新创建的变量而不影响源变量，可以使用copy()。例如，如下copy的值不会修改dict1的值\n>>> dict1 = {'up':'down','right':'left','true':'false'}\n>>> copy = dict1.copy()    # 字典copy是对dict1的拷贝\n>>> copy['up'] = 'change2'\n>>> dict1                  # 对拷贝的copy字典修改不会修改源字典\n{'up': 'change', 'right': 'left', 'true': 'false'}\n总结：\n\ndict内部存放的顺序和key放入的顺序是没有关系的，即dict是无序的。\ndict查找和插入的速度极快，不会随着key的增加而变慢，平均复杂度为O(1)。\ndict需要占用大量的内存，内存浪费多。\n\n而list相反：\n\n查找和插入的时间随着元素的增加而增加，时间复杂度为O(n)\n占用空间小，浪费内存很少。\n\n所以，dict是用空间来换取时间的一种方法。dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是不可变对象。\n\n三、注意陷阱\n❤ 在有些python中，dict并不一定会按照键-值的添加顺序来保存元素的顺序。若要保证字典的顺序性，则可以使用Python标准库collections模块OrderDict的有序字典。使用方式：\nfrom collections import OrderDict\nOrderDict().keys()\n❤ 在复制和遍历字典时，最坏情况的复杂度为O(n)，n为字典曾经达到的最大元素数目，而不是当前字典的大小。So此时遍历这个字典可能需要花相当长的时间。如果要频繁地遍历这个字典，最好的方式是创建一个新的字典对象，而不是在旧的字典中对元素进行操作，删除元素。\n\n❤持续更新ing...\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "0"}