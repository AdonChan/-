{"title": "Python 2.7.x 和 Python 3.x 的主要区别 - yexiaoxiaobai ", "index": "python,python3.x", "content": "\n  注：本文的原文地址为Key differences between Python 2.7.x and Python 3.x\n\n\n许多 Python 初学者想知道他们应该从 Python 的哪个版本开始学习。对于这个问题我的答案是 “你学习你喜欢的教程的版本，然后检查他们之间的不同。\"\n\n但是如果你开始一个新项目，并且有选择权？我想说的是目前没有对错，只要你计划使用的库 Python 2.7.x 和 Python 3.x 双方都支持的话。尽管如此，当在编写它们中的任何一个的代码，或者是你计划移植你的项目的时候，是非常值得看看这两个主要流行的 Python 版本之间的差别的，以便避免常见的陷阱，\n\n章节\n\n\n使用 __future__ 模块\nprint 函数\nInteger division\nUnicode\nxrange\nRaising exceptions\nHandling exceptions\nnext() 函数 和 .next() 方法\nFor 循环变量和全局命名空间泄漏\n比较不可排序类型\n通过 input() 解析用户的输入\n返回可迭代对象，而不是列表\n更多的关于 Python 2 和 Python 3 的文章\n\nfuture 模块\n\nPython 3.x 介绍的 一些Python 2 不兼容的关键字和特性可以通过在 Python 2 的内置 __future__ 模块导入。如果你计划让你的代码支持 Python 3.x，建议你使用 __future__ 模块导入。例如，如果我想要 在Python 2 中表现 Python 3.x 中的整除，我们可以通过如下导入\n\nfrom __future__ import division\n\n\n更多的 __future__ 模块可被导入的特性被列在下表中：\n\n\n\nfeature\n  optional in\n  mandatory in\n  effect\n\n\n\nnested_scopes\n  2.1.0b1\n  2.2\n  \nPEP 227: Statically Nested Scopes\n\n\ngenerators\n  2.2.0a1\n  2.3\n  \nPEP 255: Simple Generators\n\n\ndivision\n  2.2.0a2\n  3.0\n  \nPEP 238: Changing the Division Operator\n\n\nabsolute_import\n  2.5.0a1\n  3.0\n  \nPEP 328: Imports: Multi-Line and Absolute/Relative\n\n\nwith_statement\n  2.5.0a1\n  2.6\n  \nPEP 343: The “with” Statement\n\n\nprint_function\n  2.6.0a2\n  3.0\n  \nPEP 3105: Make print a function\n\n\nunicode_literals\n  2.6.0a2\n  3.0\n  \nPEP 3112: Bytes literals in Python 3000\n\n\n\n(Source: https://docs.python.org/2/library/future.html)\n\nfrom platform import python_version\n\n\n\nprint 函数\n\n[跳转到章节预览]\n\n很琐碎，而 print 语法的变化可能是最广为人知的了，但是仍值得一提的是： Python 2 的 print 声明已经被 print() 函数取代了，这意味着我们必须包装我们想打印在小括号中的对象。\nPython 2 不具有额外的小括号问题。但对比一下，如果我们按照 Python 2 的方式不使用小括号调用 print 函数，Python 3 将抛出一个语法异常（SyntaxError）。\n\nPython 2\n\nprint 'Python', python_version()\nprint 'Hello, World!'\nprint('Hello, World!')\nprint \"text\", ; print 'print more text on the same line'\n\n\nPython 2.7.6\nHello, World!\nHello, World!\ntext print more text on the same line\n\n\n\nPython 3\n\nprint('Python', python_version())\nprint('Hello, World!')\n\nprint(\"some text,\", end=\"\") \nprint(' print more text on the same line')\n\n\nPython 3.4.1\nHello, World!\nsome text, print more text on the same line\n\n\nprint 'Hello, World!'\n\n\nFile \"<ipython-input-3-139a7c5835bd>\", line 1\n    print 'Hello, World!'\n                        ^\nSyntaxError: invalid syntax\n\n\n注意\n\n以上通过 Python 2 使用 Printing \"Hello, World\" 是非常正常的，尽管如此，如果你有多个对象在小括号中，我们将创建一个元组，因为 print 在 Python 2 中是一个声明，而不是一个函数调用。\n\nprint 'Python', python_version()\nprint('a', 'b')\nprint 'a', 'b'\n\n\nPython 2.7.7\n('a', 'b')\na b\n\n\n整除\n\n[跳转到章节预览]\n\n如果你正在移植代码，这个变化是特别危险的。或者你在 Python 2 上执行 Python 3 的代码。因为这个整除的变化表现在它会被忽视（即它不会抛出语法异常）。\n\n因此，我还是倾向于使用一个 float(3)/2 或 3/2.0 代替在我的 Python 3 脚本保存在 Python 2 中的 3/2 的一些麻烦（并且反而过来也一样，我建议在你的 Python 2 脚本中使用 from __future__ import division）\n\nPython 2\n\nprint 'Python', python_version()\nprint '3 / 2 =', 3 / 2\nprint '3 // 2 =', 3 // 2\nprint '3 / 2.0 =', 3 / 2.0\nprint '3 // 2.0 =', 3 // 2.0\n\n\nPython 2.7.6\n3 / 2 = 1\n3 // 2 = 1\n3 / 2.0 = 1.5\n3 // 2.0 = 1.0\n\n\nPython 3\n\nprint('Python', python_version())\nprint('3 / 2 =', 3 / 2)\nprint('3 // 2 =', 3 // 2)\nprint('3 / 2.0 =', 3 / 2.0)\nprint('3 // 2.0 =', 3 // 2.0)\n\n\nPython 3.4.1\n3 / 2 = 1.5\n3 // 2 = 1\n3 / 2.0 = 1.5\n3 // 2.0 = 1.0\n\n\nUnicode\n\n[跳转到章节预览]\n\nPython 2 有 ASCII str() 类型，unicode() 是单独的，不是 byte 类型。\n\n现在， 在 Python 3，我们最终有了 Unicode (utf-8) 字符串，以及一个字节类：byte 和 bytearrays。\n\nPython 2\n\nprint 'Python', python_version()\n\n\nPython 2.7.6\n\n\nprint type(unicode('this is like a python3 str type'))\n\n<type 'unicode'>\n\n\nprint type(b'byte type does not exist')\n\n<type 'str'>\n\n\nprint 'they are really' + b' the same'\n\nthey are really the same\n\n\nprint type(bytearray(b'bytearray oddly does exist though'))\n\n<type 'bytearray'>\n\n\nPython 3\n\nprint('Python', python_version())\nprint('strings are now utf-8 \\u03BCnico\\u0394é!')\n\nPython 3.4.1\nstrings are now utf-8 μnicoΔé!\n\n\nprint('Python', python_version(), end=\"\")\nprint(' has', type(b' bytes for storing data'))\n\nPython 3.4.1 has <class 'bytes'>\n\n\nprint('and Python', python_version(), end=\"\")\nprint(' also has', type(bytearray(b'bytearrays')))\n\nand Python 3.4.1 also has <class 'bytearray'>\n\n\n'note that we cannot add a string' + b'bytes for data'\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n<ipython-input-13-d3e8942ccf81> in <module>()\n----> 1 'note that we cannot add a string' + b'bytes for data'\n\nTypeError: Can't convert 'bytes' object to str implicitly\n\n\nxrange\n\n[跳转到章节预览]\n\n在 Python 2 中 xrange() 创建迭代对象的用法是非常流行的。比如： for 循环或者是列表/集合/字典推导式。\n\n这个表现十分像生成器（比如。“惰性求值”）。但是这个 xrange-iterable 是无穷的，意味着你可以无限遍历。\n\n由于它的惰性求值，如果你不得仅仅不遍历它一次，xrange() 函数 比 range() 更快（比如 for 循环）。尽管如此，对比迭代一次，不建议你重复迭代多次，因为生成器每次都从头开始。\n\n在 Python 3 中，range() 是像 xrange() 那样实现以至于一个专门的 xrange() 函数都不再存在（在 Python 3 中 xrange() 会抛出命名异常）。\n\nimport timeit\n\nn = 10000\ndef test_range(n):\n    return for i in range(n):\n        pass\n\ndef test_xrange(n):\n    for i in xrange(n):\n        pass   \n\n\nPython 2\n\nprint 'Python', python_version()\n\nprint '\\ntiming range()' \n%timeit test_range(n)\n\nprint '\\n\\ntiming xrange()' \n%timeit test_xrange(n)\n\nPython 2.7.6\n\ntiming range()\n1000 loops, best of 3: 433 µs per loop\n\n\ntiming xrange()\n1000 loops, best of 3: 350 µs per loop\n\n\nPython 3\n\nprint('Python', python_version())\n\nprint('\\ntiming range()')\n%timeit test_range(n)\n\nPython 3.4.1\n\ntiming range()\n1000 loops, best of 3: 520 µs per loop\n\n\nprint(xrange(10))\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\n<ipython-input-5-5d8f9b79ea70> in <module>()\n----> 1 print(xrange(10))\n\nNameError: name 'xrange' is not defined\n\n\nPython 3 中的 range 对象的 __contains__ 方法\n\n另外一件值得一提的事情就是在 Python 3 中 range 有一个新的 __contains__ 方法（感谢 Yuchen Ying 指出了这个），__contains__ 方法可以加速 \"查找\" 在 Python 3.x 中显著的整数和布尔类型。\n\nx = 10000000\n\ndef val_in_range(x, val):\n    return val in range(x)\n\ndef val_in_xrange(x, val):\n    return val in xrange(x)\n\nprint('Python', python_version())\nassert(val_in_range(x, x/2) == True)\nassert(val_in_range(x, x//2) == True)\n%timeit val_in_range(x, x/2)\n%timeit val_in_range(x, x//2)\n\nPython 3.4.1\n1 loops, best of 3: 742 ms per loop\n1000000 loops, best of 3: 1.19 µs per loop\n\n\n基于以上的 timeit 的结果，当它使一个整数类型，而不是浮点类型的时候，你可以看到执行查找的速度是 60000 倍快。尽管如此，因为 Python 2.x 的 range 或者是 xrange 没有一个 __contains__ 方法，这个整数类型或者是浮点类型的查询速度不会相差太大。\n\nprint 'Python', python_version()\nassert(val_in_xrange(x, x/2.0) == True)\nassert(val_in_xrange(x, x/2) == True)\nassert(val_in_range(x, x/2) == True)\nassert(val_in_range(x, x//2) == True)\n%timeit val_in_xrange(x, x/2.0)\n%timeit val_in_xrange(x, x/2)\n%timeit val_in_range(x, x/2.0)\n%timeit val_in_range(x, x/2)\n\nPython 2.7.7\n1 loops, best of 3: 285 ms per loop\n1 loops, best of 3: 179 ms per loop\n1 loops, best of 3: 658 ms per loop\n1 loops, best of 3: 556 ms per loop\n\n\n下面说下 __contain__ 方法并没有加入到 Python 2.x 中的证据：\n\nprint('Python', python_version())\nrange.__contains__\n\nPython 3.4.1\n\n<slot wrapper '__contains__' of 'range' objects>\n\n\nprint 'Python', python_version()\nrange.__contains__\n\n\nPython 2.7.7\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\n<ipython-input-7-05327350dafb> in <module>()\n      1 print 'Python', python_version()\n----> 2 range.__contains__\n\nAttributeError: 'builtin_function_or_method' object has no attribute '__contains__'\n\n\nprint 'Python', python_version()\nxrange.__contains__\n\nPython 2.7.7\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\n<ipython-input-8-7d1a71bfee8e> in <module>()\n      1 print 'Python', python_version()\n----> 2 xrange.__contains__\n\nAttributeError: type object 'xrange' has no attribute '__contains__'\n\n\n**注意在 Python 2 和 Python 3 中速度的不同***\n\n有些猿类指出了 Python 3 的 range() 和 Python 2 的 xrange() 之间的速度不同。因为他们是用相同的方法实现的，因此期望相同的速度。尽管如此，这事实在于 Python 3 倾向于比 Python 2 运行的慢一点。\n\ndef test_while():\n    i = 0\n    while i < 20000:\n        i += 1\n    return\n\n\nprint('Python', python_version())\n%timeit test_while()\n\nPython 3.4.1\n100 loops, best of 3: 2.68 ms per loop\n\n\nprint 'Python', python_version()\n%timeit test_while()\n\nPython 2.7.6\n1000 loops, best of 3: 1.72 ms per loop\n\n\nRaising exceptions\n\n[跳转到章节预览]\n\nPython 2 接受新旧两种语法标记，在 Python 3 中如果我不用小括号把异常参数括起来就会阻塞（并且反过来引发一个语法异常）。\n\nPython 2\n\nprint 'Python', python_version()\n\nPython 2.7.6\n\n\nraise IOError, \"file error\"\n\n\n---------------------------------------------------------------------------\nIOError                                   Traceback (most recent call last)\n<ipython-input-8-25f049caebb0> in <module>()\n----> 1 raise IOError, \"file error\"\n\nIOError: file error\n\n\nraise IOError(\"file error\")\n\n---------------------------------------------------------------------------\nIOError                                   Traceback (most recent call last)\n<ipython-input-9-6f1c43f525b2> in <module>()\n----> 1 raise IOError(\"file error\")\n\nIOError: file error\n\n\nPython 3\n\nprint('Python', python_version())\n\nPython 3.4.1\n\n\nraise IOError, \"file error\"\n\n\n  File \"<ipython-input-10-25f049caebb0>\", line 1\n    raise IOError, \"file error\"\n                 ^\nSyntaxError: invalid syntax\nThe proper way to raise an exception in Python 3:\n\n\nprint('Python', python_version())\nraise IOError(\"file error\")\n\n\nPython 3.4.1\n---------------------------------------------------------------------------\nOSError                                   Traceback (most recent call last)\n<ipython-input-11-c350544d15da> in <module>()\n      1 print('Python', python_version())\n----> 2 raise IOError(\"file error\")\n\nOSError: file error\n\n\nHandling exceptions\n\n在 Python 3 中处理异常也轻微的改变了，在 Python 3 中我们现在使用 as 作为关键词。\n\npython 2\n\nprint 'Python', python_version()\ntry:\n    let_us_cause_a_NameError\nexcept NameError, err:\n    print err, '--> our error message'\n\n\nPython 2.7.6\nname 'let_us_cause_a_NameError' is not defined --> our error message\n\n\nPython 3\n\nprint('Python', python_version())\ntry:\n    let_us_cause_a_NameError\nexcept NameError as err:\n    print(err, '--> our error message')\n\n\nPython 3.4.1\nname 'let_us_cause_a_NameError' is not defined --> our error message\n\n\nnext() 函数 and .next() 方法\n\n因为 next() (.next()) 是一个如此普通的使用函数（方法），这里有另外一个语法改变（或者是实现上改变了），值得一提的是：在 Python 2.7.5 中函数和方法你都可以使用，next() 函数在 Python 3 中一直保留着（调用 .next() 抛出属性异常）。\n\nPython 2\n\nprint 'Python', python_version()\n\nmy_generator = (letter for letter in 'abcdefg')\n\nnext(my_generator)\nmy_generator.next()\n\n\nPython 2.7.6\n\n'b'\n\n\nPython 3\n\nprint('Python', python_version())\n\nmy_generator = (letter for letter in 'abcdefg')\n\nnext(my_generator)\n\n\nPython 3.4.1\n\n'a'\n\n\nmy_generator.next()\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\n<ipython-input-14-125f388bb61b> in <module>()\n----> 1 my_generator.next()\n\nAttributeError: 'generator' object has no attribute 'next'\n\n\nFor 循环变量和全局命名空间泄漏\n\n好消息：在 Python 3.x 中 for 循环变量不会再导致命名空间泄漏。\n\n在 Python 3.x 中做了一个改变，在 What’s New In Python 3.0 中有如下描述：\n\n\"列表推导不再支持 [... for var in item1, item2, ...] 这样的语法。使用 [... for var in (item1, item2, ...)] 代替。也需要提醒的是列表推导有不同的语义：  他们关闭了在 `list()` 构造器中的生成器表达式的语法糖, 并且特别是循环控制变量不再泄漏进周围的作用范围域.\"\n\n\nPython 2\n\nprint 'Python', python_version()\n\ni = 1\nprint 'before: i =', i\n\nprint 'comprehension: ', [i for i in range(5)]\n\nprint 'after: i =', i\n\n\nPython 2.7.6\nbefore: i = 1\ncomprehension:  [0, 1, 2, 3, 4]\nafter: i = 4\n\n\nPython 3\n\nprint('Python', python_version())\n\ni = 1\nprint('before: i =', i)\n\nprint('comprehension:', [i for i in range(5)])\n\nprint('after: i =', i)\n\n\nPython 3.4.1\nbefore: i = 1\ncomprehension: [0, 1, 2, 3, 4]\nafter: i = 1\n\n\n比较不可排序类型\n\n在 Python 3 中的另外一个变化就是当对不可排序类型做比较的时候，会抛出一个类型错误。\n\nPython 2\n\nprint 'Python', python_version()\nprint \"[1, 2] > 'foo' = \", [1, 2] > 'foo'\nprint \"(1, 2) > 'foo' = \", (1, 2) > 'foo'\nprint \"[1, 2] > (1, 2) = \", [1, 2] > (1, 2)\n\n\nPython 2.7.6\n[1, 2] > 'foo' =  False\n(1, 2) > 'foo' =  True\n[1, 2] > (1, 2) =  False\n\n\nPython 3\n\nprint('Python', python_version())\nprint(\"[1, 2] > 'foo' = \", [1, 2] > 'foo')\nprint(\"(1, 2) > 'foo' = \", (1, 2) > 'foo')\nprint(\"[1, 2] > (1, 2) = \", [1, 2] > (1, 2))\n\n\nPython 3.4.1\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n<ipython-input-16-a9031729f4a0> in <module>()\n      1 print('Python', python_version())\n----> 2 print(\"[1, 2] > 'foo' = \", [1, 2] > 'foo')\n      3 print(\"(1, 2) > 'foo' = \", (1, 2) > 'foo')\n      4 print(\"[1, 2] > (1, 2) = \", [1, 2] > (1, 2))\n\nTypeError: unorderable types: list() > str()\n\n\n通过 input() 解析用户的输入\n\n幸运的是，在 Python 3 中已经解决了把用户的输入存储为一个 str 对象的问题。为了避免在 Python 2 中的读取非字符串类型的危险行为，我们不得不使用 raw_input() 代替。\n\nPython 2\n\nPython 2.7.6 \n[GCC 4.0.1 (Apple Inc. build 5493)] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n\n>>> my_input = input('enter a number: ')\n\nenter a number: 123\n\n>>> type(my_input)\n<type 'int'>\n\n>>> my_input = raw_input('enter a number: ')\n\nenter a number: 123\n\n>>> type(my_input)\n<type 'str'>\n\n\nPython 3\n\nPython 3.4.1 \n[GCC 4.2.1 (Apple Inc. build 5577)] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n\n>>> my_input = input('enter a number: ')\n\n\nenter a number: 123\n\n\n>>> type(my_input)\n<class 'str'>\n\n\n返回可迭代对象，而不是列表\n\n如果在 xrange 章节看到的，现在在 Python 3 中一些方法和函数返回迭代对象 -- 代替 Python 2 中的列表\n\n因为我们通常那些遍历只有一次，我认为这个改变对节约内存很有意义。尽管如此，它也是可能的，相对于生成器 --- 如需要遍历多次。它是不那么高效的。\n\n而对于那些情况下，我们真正需要的是列表对象，我们可以通过 list() 函数简单的把迭代对象转换成一个列表。\n\nPython 2\n\nprint 'Python', python_version() \n\nprint range(3) \nprint type(range(3))\n\n\nPython 2.7.6\n[0, 1, 2]\n<type 'list'>\n\n\nPython 3\n\nprint('Python', python_version())\n\nprint(range(3))\nprint(type(range(3)))\nprint(list(range(3)))\n\n\nPython 3.4.1\nrange(0, 3)\n<class 'range'>\n[0, 1, 2]\n\n\n在 Python 3 中一些经常使用到的不再返回列表的函数和方法：\n\n\nzip()\nmap()\nfilter()\ndictionary's .keys() method\ndictionary's .values() method\ndictionary's .items() method\n\n更多的关于 Python 2 和 Python 3 的文章\n\n下面是我建议后续的关于 Python 2 和 Python 3 的一些好文章。\n\n移植到 Python 3\n\n\nShould I use Python 2 or Python 3 for my development activity?\nWhat’s New In Python 3.0\nPorting to Python 3\nPorting Python 2 Code to Python 3\nHow keep Python 3 moving forward\n\nPython 3 的拥护者和反对者\n\n\n10 awesome features of Python that you can't use because you refuse to upgrade to Python 3\nEverything you did not want to know about Unicode in Python 3\nPython 3 is killing Python\nPython 3 can revive Python\nPython 3 is fine\n\n\n                ", "mainLikeNum": ["5 "], "mainBookmarkNum": "52"}