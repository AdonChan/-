{"title": "Python 函数 类 语法糖  - 名称是什么鬼~ ", "index": "语法糖,类,函数,python", "content": "Python 语法糖\n\\，换行连接\ns = ''\ns += 'a' + \\\n     'b' + \\\n     'c'\nn = 1 + 2 + \\\n3\n# 6\nwhile，for 循环外的 else\n如果 while 循环正常结束（没有break退出）就会执行else。\nnum = [1,2,3,4]\nmark = 0\nwhile mark < len(num):\n    n = num[mark]\n    if n % 2 == 0:\n        print(n)\n        # break\n    mark += 1\nelse: print(\"done\")\nzip() 并行迭代\na = [1,2,3]\nb = ['one','two','three']\nlist(zip(a,b))\n# [(1, 'one'), (2, 'two'), (3, 'three')]\n列表推导式\nx = [num for num in range(6)]\n# [0, 1, 2, 3, 4, 5]\ny = [num for num in range(6) if num % 2 == 0]\n# [0, 2, 4]\n\n# 多层嵌套\nrows = range(1,4)\ncols = range(1,3)\nfor i in rows:\n    for j in cols:\n        print(i,j)\n# 同\nrows = range(1,4)\ncols = range(1,3)\nx = [(i,j) for i in rows for j in cols]\n字典推导式\n{ key_exp : value_exp fro expression in iterable }\n#查询每个字母出现的次数。\nstrs = 'Hello World'\ns = { k : strs.count(k) for k in set(strs) }\n集合推导式\n{expression for expression in iterable }\n元组没有推导式\n本以为元组推导式是列表推导式改成括号，后来发现那个 生成器推导式。\n生成器推导式\n>>> num = ( x for x in range(5) )\n>>> num\n...:<generator object <genexpr> at 0x7f50926758e0>\n\n函数\n函数关键字参数，默认参数值\ndef do(a=0,b,c)\n    return (a,b,c)\n\ndo(a=1,b=3,c=2)\n函数默认参数值在函数定义时已经计算出来，而不是在程序运行时。  列表字典等可变数据类型不可以作为默认参数值。\ndef buygy(arg, result=[]):\n    result.append(arg)\n    print(result)\nchanged：\ndef nobuygy(arg, result=None):\n    if result == None:\n        result = []\n    result.append(arg)\n    print(result)\n# or\ndef nobuygy2(arg):\n    result = []\n    result.append(arg)\n    print(result)\n*args 收集位置参数\ndef do(*args):\n    print(args)\ndo(1,2,3)\n(1,2,3,'d')\n**kwargs 收集关键字参数\ndef do(**kwargs):\n  print(kwargs)\ndo(a=1,b=2,c='la')\n# {'c': 'la', 'a': 1, 'b': 2}\nlamba 匿名函数\na = lambda x: x*x\na(4)\n# 16\n生成器\n生成器是用来创建Python序列的一个对象。可以用它迭代序列而不需要在内存中创建和存储整个序列。  通常，生成器是为迭代器产生数据的。\n生成器函数函数和普通函数类似，返回值使用 yield 而不是 return 。\ndef my_range(first=0,last=10,step=1):\n    number = first\n    while number < last:\n        yield number\n        number += step\n\n>>> my_range()\n... <generator object my_range at 0x7f02ea0a2bf8>\n装饰器\n有时需要在不改变源代码的情况下修改已经存在的函数。  装饰器实质上是一个函数，它把函数作为参数输入到另一个函数。举个栗子：\n# 一个装饰器\ndef document_it(func):\n    def new_function(*args, **kwargs):\n        print(\"Runing function: \", func.__name__)\n        print(\"Positional arguments: \", args)\n        print(\"Keyword arguments: \", kwargs)\n        result = func(*args, **kwargs)\n        print(\"Result: \" ,result)\n        return result\n    return new_function\n\n# 人工赋值\ndef add_ints(a, b):\n    return a + b\n\ncooler_add_ints = document_it(add_ints) #人工对装饰器赋值\ncooler_add_ints(3,5)\n\n# 函数器前加装饰器名字\n@document_it\ndef add_ints(a, b):\n    return a + b\n可以使用多个装饰器，多个装饰由内向外向外顺序执行。\n命名空间和作用域\na = 1234\ndef test():\n    print(\"a = \",a) # True\n####\na = 1234\ndef test():\n    a = a -1    #False\n    print(\"a = \",a)\n可以使用全局变量 global a 。\na = 1234\ndef test():\n    global a\n    a = a -1    #True\n    print(\"a = \",a)\nPython 提供了两个获取命名空间内容的函数local()global()\n_ 和 __\nPython 保留用法。举个栗子：\ndef amazing():\n    '''This is the amazing.\n    Hello\n    world'''\n    print(\"The function named: \", amazing.__name__)\n    print(\"The function docstring is: \\n\", amazing.__doc__)\n异常处理，try...except\n只有错误发生时才执行的代码。举个栗子：\n>>> l = [1,2,3]\n>>> index = 5\n>>> l[index]\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nIndexError: list index out of range\n再试下：\n>>> l = [1,2,3]\n>>> index = 5\n>>> try:\n...     l[index]\n... except:\n...     print(\"Error: need a position between 0 and\", len(l)-1, \", But got\", index)\n...\nError: need a position between 0 and 2 , But got 5\n没有自定异常类型使用任何错误。\n获取异常对象，except exceptiontype as name\nshort_list = [1,2,3]\nwhile 1:\n    value = input(\"Position [q to quit]? \")\n    if value == 'q':\n        break\n    try:\n        position = int(value)\n        print(short_list[position])\n    except IndexError as err:\n        print(\"Bad index: \", position)\n    except Exception as other:\n        print(\"Something else broke: \", other)\n自定义异常\n异常是一个类。类 Exception 的子类。\nclass UppercaseException(Exception):\n    pass\n\nwords = ['a','b','c','AA']\nfor i in words:\n    if i.isupper():\n        raise UppercaseException(i)\n# error\nTraceback (most recent call last):\n  File \"<stdin>\", line 3, in <module>\n__main__.UppercaseException: AA\n命令行参数\n命令行参数\npython文件：\nimport sys\nprint(sys.argv)\nPPrint()友好输出\n与print()用法相同，输出结果像是列表字典时会不同。\n类\n子类super()调用父类方法\n举个栗子：\nclass Person():\n    def __init__(self, name):\n        self.name = name\n\nclass email(Person):\n    def __init__(self, name, email):\n        super().__init__(name)\n        self.email = email\n\na = email('me', 'me@me.me')\n>>> a.name\n... 'me'\n>>> a.email\n... 'me@me.me'\nself.__name 保护私有特性\nclass Person():\n    def __init__(self, name):\n        self.__name = name\na = Person('me')\n>>> a.name\n... AttributeError: 'Person' object has no attribute '__name'\n\n# 小技巧\na._Person__name\n实例方法( instance method )\n实例方法，以self作为第一个参数，当它被调用时，Python会把调用该方法的的对象作为self参数传入。\nclass A():\n    count = 2\n    def __init__(self): # 这就是一个实例方法\n        A.count += 1\n类方法 @classmethod\nclass A():\n    count = 2\n    def __init__(self):\n        A.count += 1\n    @classmethod\n    def hello(h):\n        print(\"hello\",h.count)\n注意，使用h.count(类特征)，而不是self.count(对象特征)。\n静态方法 @staticmethod\n\nclass A():\n    @staticmethod\n    def hello():\n        print(\"hello, staticmethod\")\n>>> A.hello()\n创建即用，优雅不失风格。\n特殊方法(sqecial method)\n一个普通方法：\nclass word():\n    def __init__(self, text):\n        self.text = text\n    def equals(self, word2): #注意\n        return self.text.lower() == word2.text.lower()\na1 = word('aa')\na2 = word('AA')\na3 = word('33')\na1.equals(a2)\n# True\n使用特殊方法：\nclass word():\n    def __init__(self, text):\n        self.text = text\n    def __eq__(self, word2): #注意，使用__eq__\n        return self.text.lower() == word2.text.lower()\na1 = word('aa')\na2 = word('AA')\na3 = word('33')\na1 == a2\n# True\n其他还有：\n*方法名*                        *使用*\n__eq__(self, other)            self == other\n__ne__(self, other)            self != other\n__lt__(self, other)            self < other\n__gt__(self, other)            self > other\n__le__(self, other)            self <= other\n__ge__(self, other)            self >= other\n\n__add__(self, other)        self + other\n__sub__(self, other)        self - other\n__mul__(self, other)        self * other\n__floordiv__(self, other)    self // other\n__truediv__(self, other)        self / other\n__mod__(self, other)        self % other\n__pow__(self, other)        self ** other\n\n__str__(self)                str(self)\n__repr__(self)                repr(self)\n__len__(self)                len(self)\n文本字符串\n'%-10d | %-10f | %10s | %10x' % ( 1, 1.2, 'ccc', 0xf )\n#\n'1          | 1.200000   |        ccc |         33'\n{} 和 .format\n'{} {} {}'.format(11,22,33)\n# 11 22 33\n'{2:2d} {0:-10d} {1:10d}'.format(11,22,33)\n# :后面是格式标识符\n# 33 11 22\n\n'{a} {b} {c}'.format(a=11,b=22,c=33)\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "11"}