{"title": " 从0开始用python写一个命令行小游戏（五） - 个人文章 ", "index": "python3.x,python", "content": "今天我时间有点紧张，所以不说废话了，直接进入正题。前作链接：\n\n从0开始用python写一个命令行小游戏（一）\n从0开始用python写一个命令行小游戏（二）\n从0开始用python写一个命令行小游戏（三）\n从0开始用python写一个命令行小游戏（四）\n\n用户界面：第2.5步(第三步的前半步)\n上次我们的Game类是这样的：\nimport game_obj as o\n\nclass Game:\n    def __init__(self):\n        o.sunlight = 50\n        o.board = [0] * 10\n        self.sunlight = o.sunlight\n        self.board = o.board\n        import json\n        with open(\"level.json\") as fr:\n            self.steps = json.load(fr)\n    def step(self):\n        print(\"Sunlight: %d.\" % self.sunlight)\n        print(\"Current state:\")\n        for obj in self.board:\n            if isinstance(obj, o.GameObject):\n                obj.step()\n            print(obj, end='  ')\n这个类离全自动还差这些元素：\n\n自动出现的僵尸；\n用户可控的植物；\n自动重复执行step()的方法。\n\n下面就先解决前两个！\n自动出现的僵尸\n之前，我们已经有了配置文件。我们现在要做的就是每步都看看这一步有没有在配置文件中出现。\nimport game_obj as o\n\nclass Game:\n    def __init__(self):\n        o.sunlight = 50\n        o.board = [0] * 10\n        self.sunlight = o.sunlight\n        self.board = o.board\n        self.step_num = 0\n        import json\n        with open(\"level.json\") as fr:\n            self.steps = json.load(fr)\n    def step(self):\n        self.step_num += 1\n        print(\"Sunlight: %d.\" % self.sunlight)\n        print(\"Current state:\")\n        for obj in self.board:\n            if isinstance(obj, o.GameObject):\n                obj.step()\n            print(obj, end='  ')\n        if str(self.step_num) in self.steps.keys():\n            action = self.steps[str(self.step_num)]\n            if action == \"zombie\":\n                o.Zombie(9)\n            elif action == \"exit zombie\":\n                o.Zombie(9, die_to_exit=True)\n好！现在，游戏可以自动产生僵尸了。然后呢？\n用户可控的植物\n真正的植物大战僵尸游戏可以让玩家用鼠标控制游戏。由于这是命令行游戏，所以我们得用命令控制。我突然发现，居然还得编写处理命令的方法！\ndef process_command(self, commands):\n    for command in commands:\n        command_list = command.split()\n        if command_list[0] == 'plant' and len(command_list) == 3:\n            plant_type = command_list[1]\n            try:\n                pos = int(command_list[2])\n            except ValueError:\n                print(\"Invalid command.\")\n            else:\n                if plant_type == 's':\n                    o.Sunflower(pos)\n                elif plant_type == 'p':\n                    o.Peashooter(pos)\n        else:\n            print(\"Invalid command.\")\n好，用用它吧(当然，是在step()里面)！\ndef step(self):\n    pass            # 同前\n    first_command = input(\"next step: \")\n    if first_command:\n        commands = [first_command]\n        next_command = 'some content'\n        while next_command:\n            next_command = input(\"        -: \")\n            commands.append(next_command)\n    else:\n        commands = []\n    self.process_command(commands)\n后来我又知道，可以把不依赖实例的方法声明为@staticmethod，并把self参数去掉，于是把process_command改为：\n@staticmethod\ndef process_command(commands):\n    pass           # 同前\n好了！至此，我们的三个需求只剩一个了，而这一个将会在第三步的后半步解决！欢迎继续关注！\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}