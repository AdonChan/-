{"title": "Django REST FrameWork中文教程5：关系和超链接API - 个人文章 ", "index": "python2.x,python,python2.7,django,django-rest-framework", "content": "目前我们的API中的关系通过使用主键来表示。在本教程的这一部分中，我们将改进API的内聚力和可发现性，而不是使用超链接来进行关系。\n为我们的API的根创建一个端点现在我们有'snippets'和'users'的端点，但是我们的API没有一个入口点。要创建一个，我们将使用一个常规的基于函数的视图和@api_view我们之前介绍的装饰器。在你的snippets/views.py添加：\nfrom rest_framework.decorators import api_view\nfrom rest_framework.response import Response\nfrom rest_framework.reverse import reverse\n\n\n@api_view(['GET'])\ndef api_root(request, format=None):\n    return Response({\n        'users': reverse('user-list', request=request, format=format),\n        'snippets': reverse('snippet-list', request=request, format=format)\n    })\n\n这里应该注意两件事情。首先，我们使用REST框架的reverse功能来返回完全限定的URL; 第二，URL模式是通过方便的名称来识别的，我们稍后会在此声明snippets/urls.py。\n为突出显示的片段创建端点我们的pastebin API中仍然缺少的另一个明显的事情是代码突出显示端点。\n与所有其他API端点不同，我们不想使用JSON，而只是呈现HTML表示。REST框架提供了两种HTML渲染器样式，一种用于处理使用模板呈现的HTML，另一种用于处理预呈现的HTML。第二个渲染器是我们要用于此端点的渲染器。\n在创建代码高亮度视图时，我们需要考虑的另一件事是，我们可以使用现有的具体通用视图。我们不是返回一个对象实例，而是一个对象实例的属性。\n而不是使用具体的通用视图，我们将使用基类来表示实例，并创建我们自己的.get()方法。在你的snippets/views.py添加：\nfrom rest_framework import renderers\nfrom rest_framework.response import Response\n\nclass SnippetHighlight(generics.GenericAPIView):\n    queryset = Snippet.objects.all()\n    renderer_classes = (renderers.StaticHTMLRenderer,)\n\n    def get(self, request, *args, **kwargs):\n        snippet = self.get_object()\n        return Response(snippet.highlighted)\n\n像往常一样，我们需要添加我们在URLconf中创建的新视图。我们将为我们的新API根添加一个url模式snippets/urls.py：\nurl(r'^$', views.api_root),\n\n然后为代码片段添加一个url模式：\nurl(r'^snippets/(?P<pk>[0-9]+)/highlight/$', views.SnippetHighlight.as_view()),\n\n超链接我们的API处理实体之间的关系是Web API设计中更具挑战性的方面之一。我们可以选择代表关系的一些不同的方式：\n使用主键\n在实体之间使用超链接。\n在相关实体上使用唯一的标识字段。\n使用相关实体的默认字符串表示形式。\n将相关实体嵌套在父表示内。\n一些其他自定义表示。\nREST框架支持所有这些样式，并且可以将它们应用于正向或反向关系，也可以在诸如通用外键之类的自定义管理器上应用。\n在这种情况下，我们希望在实体之间使用超链接样式。为了这样做，我们将修改我们的序列化程序来扩展HyperlinkedModelSerializer而不是现有的ModelSerializer。\n在HyperlinkedModelSerializer有以下区别ModelSerializer：\nid默认情况下不包括该字段。\n它包括一个url字段，使用HyperlinkedIdentityField。\n关系使用HyperlinkedRelatedField，而不是PrimaryKeyRelatedField。\n我们可以轻松地重新编写我们现有的序列化程序来使用超链接。在你的snippets/serializers.py添加：\nclass SnippetSerializer(serializers.HyperlinkedModelSerializer):\n    owner = serializers.ReadOnlyField(source='owner.username')\n    highlight = serializers.HyperlinkedIdentityField(view_name='snippet-highlight', format='html')\n\n    class Meta:\n        model = Snippet\n        fields = ('url', 'id', 'highlight', 'owner',\n                  'title', 'code', 'linenos', 'language', 'style')\n\n\nclass UserSerializer(serializers.HyperlinkedModelSerializer):\n    snippets = serializers.HyperlinkedRelatedField(many=True, view_name='snippet-detail', read_only=True)\n\n    class Meta:\n        model = User\n        fields = ('url', 'id', 'username', 'snippets')\n\n请注意，我们还添加了一个新的'highlight'字段。该字段与url字段的类型相同，只是它指向'snippet-highlight'url模式，而不是'snippet-detail'url模式。\n因为我们已经包括格式后缀的URL '.json'，所以我们还需要在highlight字段上指出任何格式后缀的超链接它应该使用'.html'后缀。\n确保我们的URL模式被命名如果我们要有一个超链接的API，我们需要确保我们命名我们的URL模式。我们来看看我们需要命名的URL模式。\n我们的API的根源是指'user-list'和'snippet-list'。\n我们的片段序列化程序包括一个引用的字段'snippet-highlight'。\n我们的用户串行器包括一个引用的字段'snippet-detail'。\n我们的片段和用户序列化程序包括'url'默认情况下将引用的字段，'{model_name}-detail'在这种情况下将是'snippet-detail'和'user-detail'。\n将所有这些名字添加到我们的URLconf中后，我们的最终snippets/urls.py文件应该如下所示：\nfrom django.conf.urls import url, include\nfrom rest_framework.urlpatterns import format_suffix_patterns\nfrom snippets import views\n\n# API endpoints\nurlpatterns = format_suffix_patterns([\n    url(r'^$', views.api_root),\n    url(r'^snippets/$',\n        views.SnippetList.as_view(),\n        name='snippet-list'),\n    url(r'^snippets/(?P<pk>[0-9]+)/$',\n        views.SnippetDetail.as_view(),\n        name='snippet-detail'),\n    url(r'^snippets/(?P<pk>[0-9]+)/highlight/$',\n        views.SnippetHighlight.as_view(),\n        name='snippet-highlight'),\n    url(r'^users/$',\n        views.UserList.as_view(),\n        name='user-list'),\n    url(r'^users/(?P<pk>[0-9]+)/$',\n        views.UserDetail.as_view(),\n        name='user-detail')\n])\n\n# Login and logout views for the browsable API\nurlpatterns += [\n    url(r'^api-auth/', include('rest_framework.urls',\n                               namespace='rest_framework')),\n]\n\n添加分页用户和代码段的列表视图可能会返回相当多的实例，因此我们希望确保分页结果，并允许API客户端逐步浏览每个单独的页面。\n我们可以通过tutorial/settings.py稍微修改我们的文件来更改默认列表样式来使用分页。添加以下设置：\nREST_FRAMEWORK = {\n    'PAGE_SIZE': 10\n}\n\n请注意，REST框架中的设置都命名为单个字典设置，名为“REST_FRAMEWORK”，这有助于保持与其他项目设置的良好分离。\n我们也可以自定义分页风格，如果我们也需要，但在这种情况下，我们将坚持默认。\n浏览API如果我们打开浏览器并导航到可浏览的API，那么您将发现您现在可以通过以下链接了解API的方法。\n您还可以在代码段实例上看到“突出显示”链接，这将使您转到突出显示的代码HTML表示。\n在本教程的第6部分中，我们将介绍如何使用ViewSets和路由器来减少构建API所需的代码量。\nDjango REST FrameWork中文文档目录：Django REST FrameWork 中文教程1:序列化\nDjango REST FrameWork 中文教程2:请求和响应\nDjango REST FrameWork 中文教程3:基于类的视图\nDjango REST FrameWork 中文教程4：验证和权限\nDjango REST FrameWork 中文教程5：关系和超链接API\nDjango REST FrameWork 中文教程6: ViewSets＆Routers\nDjango REST FrameWork 中文教程7：模式和客户端库\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}