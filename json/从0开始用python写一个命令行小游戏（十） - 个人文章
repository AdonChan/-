{"title": "从0开始用python写一个命令行小游戏（十） - 个人文章 ", "index": "python3.x,python", "content": "前几天出去旅游了，所以没能更新文章，但转眼间，“从0开始用python写一个命令行小游戏”系列已经更新到了第十篇。闲话少说，今天我们要开始重构了！但第一件事还是上篇的链接：从0开始用python写一个命令行小游戏（九）。\n重构\n控制游戏结束\n之前我们是直接sys.exit()结束程序的，灵活性不高，尤其是需要连续玩游戏时。所以，我们需要一个标志变量，以标志游戏的结束。所以，在game_obj.py开头加上：\nexited = False\n然后把BaseZombie类中的die()方法修改为：\ndef die(self):\n    if self.die_to_exit:\n        exited = True\n然后把game.py中的Game类的start()方法的while循环改为：\nwhile not o.exited:\n    pass            # 内部同前\n这里说明一下：为了减少我的打字量，之后会把类似于 “game.py中的Game类的start()方法” 改写为Python path的形式，即：game.Game.start()方法。\n然后我们会发现，之前我们使用的在游戏最后判断输赢并输出的代码不再能正确地判断输赢了，它永远报告你输了，即使你赢了也是如此。那怎么办呢？答案是：再使用一个标志变量！\n判断输赢\n为解决刚才的问题，可以使用另一个标志变量：plant_win。顾名思义，它指的是植物是否赢了。在game_obj.py开头再次添加：\nplant_win = False\n然后把game_obj.BaseZombie.die()方法改为：\nif self.die_to_exit:\n    exited = True\n    plant_win = True\n在这个类的step()方法开头添加：\nif self.x == 0:\n    exited = True\n    plant_win = False\n至于如何根据这个标志判断输赢，呃，你们自己想吧，太明显了。\n下集预告\n下次，我们将引入一个配置文件，使代码变得更加优雅。敬请继续关注！\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}