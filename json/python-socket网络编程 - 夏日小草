{"title": "python-socket网络编程 - 夏日小草 ", "index": "python", "content": "\n  http://homeway.me/\n\n\n\n\npython网络编程学习\n\n本文主要介绍socket网络通信，以及python的socket通信例子\n\n\n\n0x01.socket网络通信\n\nsocket是嵌套字的意思，可以理解为server与client们间的在线会话。\n\n\n\n\n\n\n\n关于socket通信可以看这里：\n\nhttp://queengina.com/2014/10/09/简单理解Socket/\n\n\n\n\n\n\n0x02.多线程socket\n\n\n\npython下开启一个socket\n\n对于server服务端，python socket需要做4件事情\n\n1.开启socket\n\n2.设置配置socket\n\n3.绑定端口\n\n4.帧监听，收发包\n\n\n\n多线程socket\n\n\n  => server.py\n\n\n#!/usr/bin/python\n# -*- coding:utf-8 -*-\nimport socket \nimport threading \nimport time\nimport sys\n\nclients = [] \nclass RecvMsg(threading.Thread): \n    def __init__(self, sock): \n        threading.Thread.__init__(self) \n        self.sock = sock \n    def run(self): \n        global clients \n        while True: \n            msg = self.sock.recv(512) \n            print 'recv=>',msg \n            for client in clients: \n                if client != self.sock:\n                    message = {}\n                    message['id'] = self.sock\n                    message['time'] = time.time()\n                    message['type'] = 'server send'\n                    print 'send=>', message\n                    client.send( str(message) )\n                    pass\n                pass\n\ndef main( port ): \n    sock = socket.socket() \n    sock.bind(( socket.gethostname(), int(port) )) \n    sock.listen(5) \n    while True: \n        client, address = sock.accept() \n        print 'a client connected' \n        if client not in clients: \n            clients.append(client) \n            recvMsg = RecvMsg(client)\n            recvMsg.start() \n    sock.close() \n\nif __name__ == \"__main__\": \n    port = sys.argv[1]\n    main( port ) \n\n\n\n  python server.py 56565\n\n\n\n\n\n\n\n\n  => client.py\n\n\n#!/usr/bin/python\n# -*- coding:utf-8 -*-\nimport socket  \nimport threading \nimport os,time \nimport sys\n\nclass RecvMsg(threading.Thread): \n    def __init__(self, sock): \n        threading.Thread.__init__(self) \n        self.sock = sock \n\n    def run(self): \n        while True: \n            recvMsg = self.sock.recv(512) \n            print 'recv=>',recvMsg \n\ndef sendMsg(sock): \n    msg = time.time()\n    message = {} \n    message['id'] = os.getpid() \n    message['msg'] = msg \n    print 'send=>', message \n    sock.send(str(message)) \n\ndef main( port ): \n    sock = socket.socket() \n    sock.connect(( socket.gethostname(), int(port) )) \n    recvMsg = RecvMsg(sock) \n    recvMsg.start() \n    while True:\n        time.sleep(1.5) \n        sendMsg(sock) \n\nif __name__ == \"__main__\":\n    port = sys.argv[1] \n    main( port ) \n\n\n\n  python client.py 56565\n\n\n\n\n关于报错\n\nsocket模块提供4个error函数。\n\n1.关于一般I/O和通信有关的问题 socket.error\n\n2.与查询地址有关 socket.gaierror\n\n3.与其他地址错误有关 socket.herror\n\n4.与上个socket调用timeout有关 socket.timeout\n\n举个例子：(保存为error.py)\n\n#!/usr/bin/python\n# -*- coding:utf-8 -*-\nfrom socket import *\nimport time,sys\n\nHOST = socket.gethostname()\nPORT = sys.argv[0] \nBUFSIZ = 1024\nADDR = ( HOST, int(PORT) )\n\nSerSock = socket(AF_INET, SOCK_STREAM)\n\ntry:\n    SerSock.bind(ADDR)\nexcept socket.error, e:\n    print 'socket.error=>',e\nexcept socket.gaierror, e:\n    print 'socket.gaierror=>',e\nexcept socket.herror, e:\n    print 'socket.herror=>',e\n\nSerSock.listen(5)\n\nwhile True:\n    print 'waiting for message...'\n    CliSock, addr = tcpSerSock.accept()\n    print '...connect from :', addr\n    while True:\n        data = CliSock.recv(BUFSIZ)\n        if not data:\n            break\n        CliSock.send('[%s] %s' % (time.ctime(), data))\n    CliSock.close()\nSerSock.close()\n\n\n\n  python error.py 54545\n\n\n\n\n\n\n\n\n\n\n\n\n本文出自 夏日小草,转载请注明出处: http://homeway.me/2014/10/21/python-socket-1/\n\n\n\n\n-by小草\n\n2014-10-21 22:34:54\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "16"}