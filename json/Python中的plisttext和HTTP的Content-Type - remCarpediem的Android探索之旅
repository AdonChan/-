{"title": "Python中的plisttext和HTTP的Content-Type - remCarpediem的Android探索之旅 ", "index": "http,python", "content": " 这段时间本人在学习Android Service相关的内容，临时需要一个可以提供文件上传和下载功能的服务器，于是上网查找了一个简单服务器的python实现代码，本着温顾一下HTTP协议的想法，于是深入研究了一下其中的代码，发现大家对SimpleHTTPRequestsHandler中的self.headers.plisttext.split(\"=\")[1]语句的含义不是很理解，于是自己查阅了一下python源码定义和相关HTTP协议文档，理解了这段代码的含义。\n源码定义\n 我们先来看一下关于plisttext的源码定义。\n#https://svn.python.org/projects/python/branches/alpha100/Lib/mimetools.py\nclass Message(rfc822.Message):\n    def __init__(self, fp):\n    ....\n        self.typeheader = \\\n            self.getheader('content-type')\n        ....\n    def parsetype(self):\n        str = self.typeheader\n        if str == None:\n            str = 'text/plain'\n        if ';' in str:\n            i = string.index(str, ';')\n            self.plisttext = str[i:]\n            str = str[:i]\n        else:\n            self.plisttext = ''\n        ....\n 从源码中可以得出，plisttext与HTTP头部content-type有关，这里我们就要回想一下content-type的有关定义了。 在w3c的文档给出了content-type的格式定义,我们可以发现，content-type对的值有可选的内容，使用；隔开，所以plisttext的值就是parameter的内容。\nContent-Type := type \"/\" subtype *[\";\" parameter] \n\ntype :=          \"application\"     / \"audio\" \n          / \"image\"           / \"message\" \n          / \"multipart\"  / \"text\" \n          / \"video\"           / x-token \n\nx-token := <The two characters \"X-\" followed, with no \n           intervening white space, by any token> \n\nsubtype := token \n\nparameter := attribute \"=\" value \n\nattribute := token \n\nvalue := token / quoted-string \n\ntoken := 1*<any CHAR except SPACE, CTLs, or tspecials> \n\ntspecials :=  \"(\" / \")\" / \"<\" / \">\" / \"@\"  ; Must be in \n           /  \",\" / \";\" / \":\" / \"\\\" / <\">  ; quoted-string, \n           /  \"/\" / \"[\" / \"]\" / \"?\" / \".\"  ; to use within \n           /  \"=\"                        ; parameter values \n使用原理\n 知道了plisttext代表的含义，我们再来看一下它在文件上传过程中的作用吧。我们先来看一下它在处理文件上传的post请求时的作用吧。\nboundary = self.headers.plisttext.split(\"=\")[1]\nremainbytes = int(self.headers['content-length'])\nline = self.rfile.readline()\nremainbytes -= len(line)\nif not boundary in line:\n    return (False,\"Content NOT begin with boundary\")\nline = self.rfile.readline()\nremainbytes -= len(line)\nfilename = re.findall(r'Content-Disposition.*name=\"file\"; filename=\"(.*)\"',line)\nif not fn:\n    return (False,\"Can't find out file name\")\n 我们都知道当通过html的form来进行文件提交时，浏览器会发送POST请求，并且content-type为multipart/form-data; boundary=----WebKitFormBoundaryqdHXHkzdBEGWWZka,所以，plisttext的值为boundary=----WebKitFormBoundaryqdHXHkzdBEGWWZka。boundary在HTTP的body中会使用到，因为post请求提交了很多类型的数据，所以必须使用boundary进行间隔，也就是所谓的Multipart Content-Type时的body格式。详细的body的格式在w3c的文档中有详细的介绍。\n 这里贴一张wireShark截获的tcp包的信息，来帮助大家理解一下这段python代码的原理。通过form提交一份文件和一个名为other的字符串。\n POST / HTTP/1.1\nHost: localhost:8080\nConnection: keep-alive\nContent-Length: 269353\nCache-Control: max-age=0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\nOrigin: http://localhost:8080\nUser-Agent: Mozilla/5.0 (X11; Linux i686) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/43.0.2357.81 Chrome/43.0.2357.81 Safari/537.36\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryqdHXHkzdBEGWWZka\nReferer: http://localhost:8080/\nAccept-Encoding: gzip, deflate\nAccept-Language: en-US,en;q=0.8,zh-CN;q=0.6,zh;q=0.4\n\n------WebKitFormBoundaryqdHXHkzdBEGWWZka\nContent-Disposition: form-data; name=\"file\"; filename=\"AndroidStudy.png\"\nContent-Type: image/png\n..... //图片内容\n------WebKitFormBoundaryqdHXHkzdBEGWWZka\nContent-Disposition: form-data; name=\"other\"\n\nddd\n------WebKitFormBoundaryqdHXHkzdBEGWWZka--\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}