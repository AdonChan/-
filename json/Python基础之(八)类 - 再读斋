{"title": "Python基础之(八)类 - 再读斋 ", "index": "python", "content": "类\n创建类\n第一形式\n# !/usr/bin/env python\n# coding=utf-8\n\nclass Person(object): #object表示继承自object类，Python3中可省略次内容\n    \"\"\"\n    This is a sample of Class\n    \"\"\"\n    breast = 90  #类的属性 是静态变量\n    \n    def __init__(self, name): #初始化方法  self为对象实例本身\n        self.name = name\n        \n    def get_name(self):  #类的方法\n        return self.name\n    \n    def color(self,color):\n        d = {}\n        d[self.name] = color;\n        return d\n    \nif __name__ == \"__main__\":\n    girl = Person(\"songjia\")\n    print girl.name\n    girl.name =\"liu\"\n    print girl.get_name()\n    print girl.color(\"white\")\n    girl.breast = 80 #修改实例的属性\n    print girl.breast\n    print Person.breast #类属性不会随实例属性的改变而改变\n    Person.breast = 100\n    print Person.breast\n    print girl.breast\n第二种形式\n>>> __metaclass__ = type\n>>> class CC:\n...     pass\n... \n>>> cc = CC()\n>>> cc.__class__\n<class '__main__.CC'>\n>>> type(cc)\n<class '__main__.CC'>\n实例\ngirl = Person(\"songjia\")\n类属性\n>>> class A(object):    #Python 3: class A:\n...         x = 7  #类的属性\n... \n下面列出类的几种特殊属性的含义:\n\nC.__name__：以字符串的形式，返回类的名字，注意这时候得到的仅仅是一个字符串，它不是一个类对象\nC.__doc__：显示类的文档\nC.__base__：类C的所有父类。如果是按照上面方式定义的类，应该显示object，因为以上所有类都继承了它。等到学习了“继承”，再来看这个属性，内容就丰富了\nC.__dict__：以字典形式显示类的所有属性\nC.__module__：类所在的模块\n\n实例属性\n>>> class A(object):    #Python 3: class A:\n...         x = 7  #类的属性\n... \n>>> foo = A()\n>>> foo.x #实例属性\n类中变量引用可变数据\n>>> class B(object):\n...     y = [1, 2, 3]\n    \n   >>> B.y         #类属性\n[1, 2, 3]\n>>> bar = B()\n>>> bar.y       #实例属性\n[1, 2, 3]\n\n>>> bar.y.append(4)\n>>> bar.y\n[1, 2, 3, 4]\n>>> B.y\n[1, 2, 3, 4]\n\n>>> B.y.append(\"aa\")\n>>> B.y\n[1, 2, 3, 4, 'aa']\n>>> bar.y\n[1, 2, 3, 4, 'aa']\n当类中变量引用的是可变对象是，类属性和实例属性都能直接修改这个对象，从而影响另一方的值。\n访问限制\n# !/usr/bin/env python\n# coding=utf-8\n\nclass Person(object):\n    \"\"\"\n    This is a sample of Class\n    \"\"\"\n    \n    def __init__(self, name): #初始化方法  self为对象实例本身\n        self.__name = name #__xx双下划线表示类的私有变量\n        \n    def get_name(self):  #类的方法\n        return self.__name #类的内部可以访问\n    \nif __name__ == \"__main__\":\n    girl = Person(\"songjia\")\n    print girl.get_name()\n    print girl._name #无法访问类的私有变量\n文档字符串\n在函数、类或者文件开头的部分写文档字符串说明，一般采用三重引号。这样写的最大好处是能够用help()函数看。\n\"\"\"This is python lesson\"\"\"\n\ndef start_func(arg):\n   \"\"\"This is a function.\"\"\"\n   pass\n\nclass MyClass:\n   \"\"\"This is my class.\"\"\"\n   def my_method(self,arg):\n       \"\"\"This is my method.\"\"\"\n       pass\n继承\n单继承\n#!/usr/bin/env python\n# coding=utf-8\n\nclass Person(object):        #Python 3: class Person:\n    def __init__(self, name):\n        self.name = name\n    \n    def height(self, m):\n        h = dict(([\"height\", m],))\n        return h\n\n    def breast(self, n):\n        b = dict(([\"breast\", n],))\n        return b\n\nclass Girl(Person):  #继承\n    def get_name(self):\n        return self.name\n\nif __name__ == \"__main__\":\n    cang = Girl(\"liuguoquan\")\n    print cang.get_name()        #Python 3: print(cang.get_name())，下同，从略\n    print cang.height(160)\n    print cang.breast(90)\n调用覆盖的方法\nclass Girl(Person):\n   def __init__(self, name):\n       #Person.__init__(self, name) #调用父类的方法\n       super(Girl, self).__init__(name) #调用父类的方法常用写法\n       self.real_name = \"Aoi sola\"\n\n   def get_name(self):\n       return self.name\n       \nif __name__ == \"__main__\":\n   cang = Girl(\"canglaoshi\")\n   print cang.real_name\n   print cang.get_name()\n   print cang.height(160)\n   print cang.breast(90)\n\n执行结果为：\n\n    Aoi sola\n    canglaoshi\n    {'height': 160}\n    {'breast': 90}\n多继承\n#!/usr/bin/env python\n# coding=utf-8\n\nclass Person(object):        #Python 3: class Person:\n    def eye(self):\n        print \"two eyes\"\n\n    def breast(self, n):\n        print \"The breast is: \",n\n\nclass Girl(object):        #Python 3: class Gril:\n    age = 28\n    def color(self):\n        print \"The girl is white\"\n\nclass HotGirl(Person, Girl): #多重继承\n    pass\n\nif __name__ == \"__main__\":\n    kong = HotGirl()\n    kong.eye()\n    kong.breast(90)\n    kong.color()\n    print kong.age\n    \ntwo eyes\nThe breast is:  90\nThe girl is white\n28\n多重继承的顺序-广度优先\nclass K1(object):        #Python 3: class K1:\n   def foo(self):\n       print \"K1-foo\"    #Python 3: print(\"K1-foo\")，下同，从略\n\nclass K2(object):        #Python 3: class K2:\n   def foo(self):\n       print \"K2-foo\"\n   def bar(self):\n       print \"K2-bar\"\n\nclass J1(K1, K2):\n   pass\n\nclass J2(K1, K2):\n   def bar(self):\n       print \"J2-bar\"\n\nclass C(J1, J2):\npass\n   \nif __name__ == \"__main__\":\nprint C.__mro__\nm = C()\nm.foo()\nm.bar()\n   \nK1-foo\nJ2-bar\n代码中的print C.__mro__是要打印出类的继承顺序。从上面清晰看出来了。如果要执行foo()方法，首先看J1，没有，看J2，还没有，看J1里面的K1，有了，即C==>J1==>J2==>K1；bar()也是按照这个顺序，在J2中就找到了一个。\n这种对继承属性和方法搜索的顺序称之为“广度优先”。Python 2的新式类，以及Python 3中都是按照此顺序原则搜寻属性和方法的。\n方法\n绑定方法\n#!/usr/bin/env python\n# coding=utf-8\n\nclass Person(object):        #Python 3: class Person:\n    def eye(self):\n        print \"two eyes\"\n\n    def breast(self, n):\n        print \"The breast is: \",n\n\nclass Girl(object):        #Python 3: class Gril:\n    age = 28\n    def color(self):\n        print \"The girl is white\"\n\nclass HotGirl(Person, Girl): #多重继承\n    pass\n\nif __name__ == \"__main__\":\n    kong = HotGirl() #实例化实现了方法和实例的绑\n    kong.eye() #调用绑定方法\n非绑定方法\n在子类中，父类的方法就是非绑定方法，因为在子类中，没有建立父类的实例，却要是用父类的方法。\n静态方法和类方法\n#!/usr/bin/env python\n# coding=utf-8\n\n__metaclass__ = type\n\nclass StaticMethod: #静态方法\n    @staticmethod\n    def foo():\n        print \"This is static method foo().\"\n\nclass ClassMethod: #类方法\n    @classmethod\n    def bar(cls): #类方法必须有cls参数\n        print \"This is class method bar().\"\n        print \"bar() is part of class:\", cls.__name__\n\nif __name__ == \"__main__\":\n    static_foo = StaticMethod()    #实例化\n    static_foo.foo()               #实例调用静态方法\n    StaticMethod.foo()             #通过类来调用静态方法\n    print \"********\"\n    class_bar = ClassMethod()\n    class_bar.bar()\n    ClassMethod.bar()\n    \nThis is static method foo().\nThis is static method foo().\n********\nThis is class method bar().\nbar() is part of class: ClassMethod\nThis is class method bar().\nbar() is part of class: ClassMethod\n在python中：\n\n@staticmethod表示下面的方法是静态方法\n@classmethod表示下面的方法是类方法\n\n多态和封装\n多态\nclass Cat:\n   def speak(self):\n       print \"meow!\"\n\nclass Dog:\n   def speak(self):\n       print \"woof!\"\n\nclass Bob:\n   def bow(self):\n       print \"thank you, thank you!\"\n   def speak(self):\n       print \"hello, welcome to the neighborhood!\"\n   def drive(self):\n       print \"beep, beep!\"\n\ndef command(pet):\n   pet.speak()\n\npets = [ Cat(), Dog(), Bob() ]\n\nfor pet in pets:\n   command(pet)\nPython中的多态特点,Python不检查传入对象的类型，这种方式被称之为“隐式类型”（laten typing）或者“结构式类型”（structural typing），也被通俗的称为“鸭子类型”(duck typeing)，Python是弱类型语言。\nJava会检查传入对象的类型，所以是强类型语言。\n封装和私有化\n要了解封装，离不开“私有化”，就是将类或者函数中的某些属性限制在某个区域之内，外部无法调用。\nPython中私有化的方法也比较简单，就是在准备私有化的属性（包括方法、数据）名字前面加双下划线。例如：\n#!/usr/bin/env python\n# coding=utf-8\n\nclass ProtectMe(object):        #Python 3: class ProtectMe:\n    def __init__(self):\n        self.me = \"qiwsir\"\n        self.__name = \"kivi\" #私有变量\n\n    def __python(self): #私有方法\n        print \"I love Python.\"        \n\n    def code(self):\n        print \"Which language do you like?\"\n        self.__python()\n\nif __name__ == \"__main__\":\n    p = ProtectMe()\n    print p.me\n    print p.code()\n如何将一个方法变成属性调用？\n可以使用property函数。\n#!/usr/bin/env python\n# coding=utf-8\n\nclass ProtectMe(object):        #Python 3: class ProtectMe:\n    def __init__(self):\n        self.me = \"qiwsir\"\n        self.__name = \"kivi\" #私有变量\n\n    def __python(self): #私有方法\n        print \"I love Python.\"        \n\n    @property\n    def code(self):\n        print \"Which language do you like?\"\n        self.__python\n\nif __name__ == \"__main__\":\n    p = ProtectMe()\n    print p.me\n    print p.code #调用方法名即可\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "9"}