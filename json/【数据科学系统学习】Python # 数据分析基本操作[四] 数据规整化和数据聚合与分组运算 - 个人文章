{"title": "【数据科学系统学习】Python # 数据分析基本操作[四] 数据规整化和数据聚合与分组运算 - 个人文章 ", "index": "数据分析,python", "content": "本篇内容为整理《利用Python进行数据分析》，博主使用代码为 Python3，部分内容和书本有出入。\n在前几篇中我们介绍了 NumPy、pandas、matplotlib 三个库的基本操作，本篇介绍对数据的一些操作。\n\n数据规整化：清理、转换、合并、重塑\n数据聚合与分组运算\n\n\n数据规整化：清理、转换、合并、重塑\n合并数据集\n\n\npandas.merge：可根据一个或多个键将不同DataFrame中的行链接起来。\n\npandas.concat：可沿着一条轴将多个对象堆叠到一起。\n\ncombine_first：可将重复数据编接在一起，用一个对象中的值填充另一个对象中的缺失值。\n\n\n数据库风格的 DataFrame 合并\n\n数据集的合并或连接运算：通过一个或多个键将行链接起来。\n\n多对一的合并：\n\n若没有指定用哪个列进行连接，merge会将重叠列名当做键，指定如下：\n\n若两个对象的列名不同，可分别进行指定：\n\n默认情况下，merge做inner连接，结果中的键是交集。外连接求取的是键的并集：\n\n多对多的合并操作：\n\n连接方式只影响出现在结果中的键。\n根据多个键进行合并，传入一个由列名组成的列表：\n\n在进行列-列连接时，DataFrame对象中的索引会被丢弃。\nsuffixes选项：指定附加到左右两个DataFrame对象的重叠列名上的字符串。\n\n\n索引上的合并\n\n当DataFrame中的连接键位于其索引中时，传入left_index=True、 right_index=True，以说明索引应该被用作连接键：\n\n\n\n对于层次化索引的数据：\n\n必须以列表的形式指明用作合并键的列（注意对重复索引值的处理）：\n\n使用合并双方的索引：\n\n\nDataFrame的 join 实例方法：\n\n\n更方便的实现按索引合并，不管有没有重叠的列。在连接键上作左连接。\n\n支持参数DataFrame的索引跟调用者DataFrame的某个列之间的连接：\n\n\n对于简单的索引合并，可以向join传入一组DataFrame（concat 函数也是这个功能）：\n\n\n轴向连接\n\n数据合并运算：\n\n连接(concatenation)\n绑定(binding)\n堆叠(stacking)\n\nNumPy有一个用于合并原始NumPy数组的concatenation函数：\n\npandas的concat函数：\n\n默认情况下，concat在 axis=0 上工作，产生一个新Series。传入 axis=1，产生一个DataFrame：\n\n这种情况下，另外一条轴上没有重叠，传入 join = 'inner' 得到它们的交集：\n\n使用 key 参数，在连接轴上创建一个层次化索引：\n\n沿着 axis=1 对Series进行合并，keys 就会成为DataFrame的列头：\n\n对DataFrame对象也是如此：\n\n传入一个字典，则字典的键会被当做keys选项的值：\n\n用于管理层次化索引创建方式的参数：\n\n跟当前分析工作无关的DataFrame行索引：\n\n传入 ignore_index = True：\n\n\n合并重叠数据\n\n关于有索引全部或部分重叠的两个数据集。\nNumPy的where函数，用于表达一种矢量化的if-else：\n\n\nSeries的combine_first方法，实现与上面一样的功能，并会进行数据对齐：\n\n对于DataFrame 一样：\n\n\n可以看作用参数对象中的数据为调用者对象的缺失数据“打补丁”。\n\n重塑和轴向旋转\n用于重新排列表格型数据的基础运算：重塑(reshape)或轴向旋转(pivot)。\n\n重塑层次化索引\n\n\n\nstark：将数据的列“旋转”为行\n\nunstark：将数据的行“旋转”为列\n\n\n用stack方法将行转为列，得到一个Series：\n\n对层次化索引的Series，可以用unstack将其重新排为一个DataFrame：\n\n默认情况下，unstack操作最内层。\n传入分层级别的编号或名称可对其他级别进行unstack操作：\n\n如果不是所有的级别值都能在各分组找到的话，unstack操作可能会引入缺失数据：\n\nstack默认会滤除缺失数据，因此该运算是可逆的：\n\n对DataFrame进行unstack操作时，作为旋转轴的级别将会成为结果中的最低级别：\n\n\n\n将“长格式”旋转为“宽格式”\n\n时间序列数据通常以 “长格式(long)”或“堆叠格式(stacked)”存储在数据库和 CSV 中。\n\n转成DataFrame，用 pivot 方法：\n\n\n得到的DataFrame带有层次化的列：\n\n假设有两个需要参与重塑的数据列：\n\npivot其实只是一个快捷方式：用set_index创建层次化索引，再用unstack重塑。\n\n\n以上是数据的重排，下面是过滤、清理及其他转换工作。\n数据转换\n移除重复数据\n\nDataFrame中出现的重复行：\n\nDataFrame的duplicated方法返回一个布尔型Series，表示各行是否是重复行，drop_duplicates方法返回一个移除了重复行的DataFrame：\n\n指定部分列进行重复项判断，如只希望根据k1列过滤重复项：\n\nduplicated和drop_duplicates默认保留重复数值里第一次出现的组合，传入keep = last则保留最后一个：\n\n\n利用函数或映射进行数据转换\n\n根据数组、Series或DataFrame列中的值来实现转换。\n\n编写一个肉类到动物的映射：\n\nSeries的map方法：可以接受一个函数或含有映射关系的字典型对象，用于修改对象的数据子集。\n\n也可以传入一个能够完成全部这些工作的函数：\n\n\n替换值\n\nreplace方法 ：替换\n利用fillna方法填充缺失数据可以看作替换的一种特殊情况。\n替换一个值和一次性替换多个值：\n\n对不同的值进行不同的替换：\n\n传入的参数也可以是字典：\n\n\n重命名轴索引\n\n轴标签有一个map方法：\n\n对函数或映射进行转换，从而得到一个新对象。\n\n将其值赋给index，就可以对DataFrame进行就地修改了：\n\n\n要创建数据集的转换版，而不是修改原始数据，用rename：\n\nrename结合字典型对象可以实现对部分轴标签的更新：\n\nrename实现了复制DataFrame并对其索引和列标签进行赋值，就地修改某个数据集，传入inplace=True：\n\n\n离散化和面元划分\n\n为了便于分析，连续数据常常被离散化或拆分为“面元（bin)”。\n用pandas的cut函数：\n\npandas返回的是一个特殊的Categorical对象，它含有一个表示不同分类名称的数组和一个为年龄数据进行标号的属性：\n\n哪边是闭端可以通过right=False进行修改：\n\n设置自己的面元名称：\n\n将labels选项设置为一个列表或数组即可。\n\n如果向cut传入的是面元的数量而不是确切的面元边界，则它会根据数据的最小值和最大值计算等长面元：\n\n将一些均匀分布的数据分成了四组。\n\nqcut函数：根据样本分位数对数据进行面元划分。\n由于qcut使用的是样本分位数，可以得到大小基本相等的面元（而 cut 根据数据的分布情况，可能无法使各个面元中含有相同数量的数据点）。\n\n\n设置自定义的分位数：\n\n在聚合和分组运算时会再次用到cut 和 qcut 这两个离散化函数。\n\n检测和过滤异常值\n\n判断是否存在异常值（outlier )：\n\n找出某列中绝对值大小超过 3 的值：\n\n选出全部含有“超过 3 或 -3 的值”的行：\n\n将值限制在区间 -3 到 3 以内：\n\nnp.sign这个ufunc返回的是一个由 1 和 -1 组成的数组，表示原始值的符号。\n\n排列和随机采样\n\nnumpy.random.permutation函数：对Series和DataFrame的列排列。\n\nPermutation(5)：需要排列的轴的长度。\n然后就可以在基于ix的索引操作或take函数中使用该数组了：\n\n选取随机子集（非替换）：\n\n用替换的方式产生样本：\n\n\n计算指标／哑变量\n\n将分类变量(Categorical)转换为“哑变量矩阵(dummy matrix)”或“指标矩阵(indicator matrix)”。\n\n给DataFrame的列加上一个前缀，以便能够跟其他数据进行合并：\n\n用get_dummies的prefix参数。\n\nDataFrame中的某行同属于多个分类的情况，举个例子：\n\n要为每个genre添加指标变量就需要做一些数据规整操作，构建多成员指标变量：\n\n对于很大的数据，这种方式会变得非常慢，需要编写一个能够利用DataFrame内部机制的更低级的函数：\n\n用get_dummies和cut之类的离散化函数。\n\n字符串操作\n字符串对象方法\n\nPython 字符串对象的内置方法：\n\nfind找不到返回 -1，index找不到引发一个异常\n\n\n传入空字符串常常用于删除模式：\n\n\n正则表达式(regex)\n\n提供了一种灵活的在文本中搜索或匹配字符串模式的方式。python 内置的re模块负责对字符串应用正则表达式。\nre模块的函数分为三个大类：模式匹配、替换、拆分。\n\n描述一个或多个空白符的regex是 \\s+。\n调用re.split('\\s+', text)时，正则表达式会先被编译，然后再在text上调用其split方法。\n可以用re.compile自己编译一个regex，以得到一个可重用的regex对象，如上所示。如果打算对许多字符串应用同一条正则表达式，强烈建议通过这种方法，可以节省大量的 CPU 时间。\n\n得到匹配regex的所有模式：\n\n\n\nfindall：返回字符串中所有的匹配项。\n\nsearch：只返回第一个匹配项。\n\nmatch：只匹配字符串的首部。\n\n\n\nsub方法：将匹配到的模式替换为指定字符串，并返回所得到的新字符串。\n\n不仅想找出电子邮件地址，还想将各个地址分为 3 个部分，只需将待分段的模式的各部分用圆括号包起来：\n\n通过groups方法返回一个由模式各段组成的元组。\n\n对于带有分组功能的模式，findall会返回一个元组列表：\n\nsub还能通过诸如\\1, \\2之类的特殊符号访问各匹配项中的分组：\n\n为各个匹配分组加上一个名称，由这种正则表达式所产生的匹配对象可以得到一个简单易用的带有分组名称的字典：\n\n\npandas 中矢量化的字符串函数\n\n通过data.map，所有字符串和正则表达式方法都能被应用于各个值，但如存在NA就会报错，为了解决这个问题，Series有一些能够跳过NA值的字符串操作方法，通过Series的str属性即可访问这些方法：\n\n也可以用正则表达式：\n\n实现矢量化的元素获取操作，对str.get/str属性上使用索引：\n\n对字符串进行子串截取：\n\n\n数据聚合与分组运算\n对数据集进行分组并对各组应用一个函数。\n在将数据集准备好之后，通常的任务就是计算分组统计或生成透视表。pandas提供了一个灵活高效的gruopby功能，对数据集进行切片、切块、摘要等操作。\n用 python 和pandas强大的表达能力可以执行复杂的多的分组运算：利用任何可以接受pandas对象或NumPy数组的函数。\n\nGroupBy技术\n分组运算：split（拆分）--apply（应用）--combine（合并）。\n分组键的形式：\n\n列表或数组，其长度与待分组的轴一样。\n表示DataFrame某个列名的值。\n字典或Series，给出待分组轴上的值与分组名之间的对应关系。\n函数，用于处理轴索引或索引中的各个标签。\n\n\n\n访问data1，并根据key1调用groupby。\n变量grouped是一个GroupBy对象，它实际上还没有进行任何计算，只是含有一些有关分组键df['key1']的中间数据。\n例如，调用GroupBy的mean方法来计算分组平均值：\n\nSeries根据分组键进行了聚合，产生了一个新的Series，其索引为key1列中的唯一值。\n通过两个键对数据进行了分组后，得到的Series具有一个层次化索引：\n\n分组键可以是任何长度适当的数组：\n\n将列名用作分组键：\n\nGroupBy的size方法返回一个含有分组大小的Series：\n\n\n对分组进行迭代\n\nGroupBy对象支持迭代，可以产生一组二元元组（由分组名和数据块组成）。\n\n对于多重键，元组的第一个元素将会是由键值组成的元组。\n对数据片段进行操作，如将这些数据片段做成一个字典：\n\ngroupby默认在axis=0上进行分组，通过设置可以在其它任何轴上进行分组，如可以根据dtype对列进行分组：\n\n\n选取一个或一组列\n\n对于由DataFrame产生的GroupBy对象，用一个或一组（单个字符串或字符串数组）列名对其进行索引，就能实现选取部分列进行聚合的目的：\n\n例如，对部分列进行聚合：计算data2列的平均值并以DataFrame形式得到结果：\n\n返回一个已分组的DataFrame（传入的是列表或数组）或Series（传入的是标量形式的单个列名）：\n\n\n通过字典或 Series 进行分组\n\n除数组以外，分组信息还可以其他形式存在\n\n根据分组计算列的sum：\n\n将mapping这个字典传给groupby即可。\n用Series作为分组键：\n\n这里Series可以被看做一个固定大小的映射。pandas会检查Series以确保其索引根分组轴是对齐的。\n\n通过函数进行分组\n\n任何被当做分组键的函数都会在各个索引值上被调用一次，其返回值就会被用作分组名称。\n\n将函数根数组、列表、字典、Series混合使用（任何东西最终都会被转换为数组）：\n\nKey_list和人名对应，再在相同长度的对应一列里选min的值。\n\n根据索引级别分组\n\n层次化索引数据集通过level关键字传入级别编号或名称：\n\n\n数据聚合\n可以使用经过优化的GroupBy的方法，还可以使用自己发明的聚合运算，还可以调用分组对象上已经定义好的任何方法，如 quantile可以计算Series或DataFrame列的样本分位数：\n\nGroupBy会高效地对Series进行切片，然后对各片调用piece.quantile(0.9)，最后将这些结果组装成最终结果。\n使用自己的聚合函数，传入aggregate或agg方法即可：\n\n有些方法如describe也可以用，但严格来讲它们并非聚合运算。\n\n\n自定义聚合函数比表中的经过优化的函数慢得多，这是因为在构造中间分组数据块时存在非常大的开销（函数调用、数据重排等）。\n\n面向列的多函数应用\n\n根据 'smoker' 和 'size' 对 tips 进行分组：\n\n传入一组函数或函数名，得到的DataFrame的列就会以相应的函数命名：\n\n传入一个由（name, function )元组组成的列表，各元组的第一个元素会被用作DataFrame的列名：\n\n对于DataFrame，定义一组应用于全部列的函数，或不同的列应用不同的函数。\n\n结果的DataFrame拥有层次化的列。相当于分别对列['tip_pct']和列['total_bill']进行聚合，然后用concat将结果组装到一起（列名用作 keys 参数）。\n传入带有自定义名称的元组列表：\n\n对不同的列应用不同的函数：向agg传入一个从列名映射到函数的字典\n\n只有将多个函数应用到至少一列时，DataFrame才会拥有层次化的列：\n\n\n以“无索引”的形式返回聚合数据\n\n向groupby传入as_index=False，禁用功能由唯一的分组键组成索引：\n\n\n\n分组级运算和转换\n聚合只是分组运算的其中一种，它接受能够将一维数据简化为标量值的函数。\n接下来介绍 transform 和 apply 方法，执行更多其他的分组运算。\n为一个DataFrame添加一个用于存放各索引分组平均值的列：先聚合再合并。\n\n\n下面在GroupBy上使用transform方法：\n\n\ntransform会将一个函数应用到各个分组，然后将结果放置到适当的位置上。\n从各组中减去平均值：先创建一个距平化函数(demeaning function)，然后将其传给transform。\n\n检查demeaned现在的分组平均值是否为 0：\n\n跟aggregate一样，transform也是一个有着严格条件的特殊函数，传入的函数只能产生两种结果，一个可以广播的标量值（如 np.mean） 或一个相同大小的结果数组。\n\napply：一般性的“拆分-应用-合并”\n\n最一般化的GroupBy方法是apply：apply会将待处理的对象拆分成多个片段，然后对各片段调用传入的函数，最后尝试将各片段组合到一起。\n根据分组选出最高的 5 个tip_pct值：编写一个函数，在指定列找出最大值，然后把这个值所在的行选取出来。\n\n对smoker分组并用该分组函数调用apply，得到：\n\ntop函数在DataFrame的各个片段上调用，然后结果由pandas.concat组装到一起，并以分组名称进行了标记。\n最后结果就有了一个层次化索引，其内层索引值来自原DataFrame。\n如果传给apply的函数能够接受其他参数或关键字，可以将这些内容放在函数名后面一并传入：\n\n在GroupBy对象上调用describe：\n\n在GroupBy中，当调用如describe之类的方法时，实际上只是应用了下面两条代码的快捷方式：\n\n除这些基本用法之外，能否充分发挥apply的威力很大程度上取决于你的创造力，传入的哪个函数能做什么全由你说了算，它只需返回一个pandas 对象或标量值即可。\n\n禁止分组键\n\n分组键会跟原始对象的索引共同构成结果对象中的层次化索引，将group_keys=False传入groupby即可禁止该效果：\n\n\n\n分位数和桶分析\n\npandas有一些能根据指定面元或样本分位数将数据拆分成多块的工具（cut 和 qcut），将这些函数跟groupby结合起来，就能非常轻松地实现对数据集的桶或分位数分析了。\n\n桶：bucket\n分位数：quantile\n\n\n“长度相等的桶”指的是“区间大小相等”，“大小相等的桶”指的是“数据点数量相等”。\n利用cut将其装入长度相等的桶中：\n\n由cut返回的Factor对象可直接用于groupby，可以对data2做一些统计计算：\n\n要根据样本分位数得到大小相等的桶，使用qcut：\n\n传入labels=False，即可只获取分位数的编号。否则那段还是区间而不是编号：\n\n\n示例：用特定于分组的值填充缺失值\n\n对于缺失数据的清理工作，有时用dropna将其滤除，有时则希望用一个固定值或由数据集本身所衍生出来的值去填充NA值，用fillna这个工具。\n如用平均值去填充NA值：\n\n对不同的分组填充不同的值：将数据分组，并使用apply和一个能够对各数据块调用fillna的函数即可。\n\n用这个分组平均值去填充NA值：\n\n也可以在代码中预定义各组的填充值，由于分组具有一个name 属性：\n\n\n\n示例：随机采样和排列\n\n从一个大数据集中随机抽取样本以进行蒙特卡罗模拟（Monte Carlo simulation）或其他分析工作。抽取的方式很多，其中的一些效率会比其他的高很多\n一个办法是：选取np.random.permutation(N)的前K个元素，其中N为完整数据的大小，K为期望的样本大小。\n构造一副扑克牌：\n\n从整副牌中抽出 5 张：\n\n从每种花色中随机抽取两张牌，由于花色是牌名的最后一个字符，可以据此进行分组，并使用apply：\n\n另一种方法：\n\n\n示例：分组加权平均数和相关系数\n\n例如对这个数据集利用category计算分组加权平均数：\n\n来自 Yahoo! Finance 的数据集：\n\n计算一个由日收益率（通过百分数变化计算）与 SPX 之间的年度相关系数组成的DataFrame：\n\n计算列于列之间的相关系数：（苹果和微软的年度相关系数）\n\n\n示例：面向分组的线性回归\n\n还是上个例子，定义下面这个regress函数（利用 statsmodels 库）对各数据块执行普通最小二乘法回归（Ordinary Least Squares, OLS）。\n按年计算 AAPL 对 SPX 收益率的线性回归：\n\n\n透视表和交叉表\n透视表（pivot table）\n\n是各种电子表格程序和其他数据分析软件中一种常见的数据汇总工具。它根据一个或多个键对数据进行聚合，并根据行和列上的分组键将数据分配到各个矩形区域中。\n在小费数据集中，根据day和smoker计算分组平均数（pivot_table 的默认聚合类型）：\n\n只想聚合tip_pct和size，并根据day进行分组：\n\n传入margins=True添加分项小计，将会添加标签为All的行和列，其值对应于单个等级中所有数据的分组统计。\n\n这里All值为平均数。\n要使用其他的聚合函数，将其传给aggfunc即可。例如使用count或len得到有关分组大小的交叉表：\n\n存在NA值，就设置一个fill_value：\n\n\n交叉表（crosstab）\n\n是一种用于计算分组频率的特殊透视表。\n\n用pandas.crosstab函数（pivot_table 也能实现该功能：根据 Nationality 和 Handedness 对这段数据进行汇总）：\n\ncrosstab的前两个参数可以是数组、Series、数组列表：\n\n示例：2012联邦选举委员会数据库\n加载数据\n\n抽取有关赞助人和赞助模式的统计信息。\n通过unique，可以获取全部的候选人名单：\n\n利用字典说明党派关系：\n\n通过这个映射以及 Series对象的map方法，可以根据候选人姓名得到一组党派信息：\n\n注意，该数据集既包括赞助也包括退款（负的出资额），为了简化分析过程，限定该数据集只能有正的出资额：\n\n由于 Barack Obama 和 Mitt Romney 是最主要的两名候选人，专门准备了一个子集，只包含针对他们两人的竞选活动的赞助信息：\n\n根据职业和雇主统计赞助信息\n首先，根据职业计算出资总额：\n\n这里只列出了前10个，注意到 许多职业都涉及相同的基本工作类型或同一样东西有多种变体，清理一些这样的数据：将一个职业信息映射到另一个。\n\n对雇主信息也进行了同样的处理。\n这里利用了dict.get，它允许没有映射关系的职业也能“通过”。\n现在，可以通过pivot_table根据党派和职业对数据进行聚合，然后过滤掉总出资额不足 200 万美元对数据：\n\n做成柱状图：\n\n对 Obama 和 Romney 总出资额最高的职业和企业：先对候选人进行分组，然后求取最大值：\n\n\n对出资额分组\n利用cut函数根据出资额的大小将数据离散化到多个面元中：\n\n\n根据候选人姓名以及面元标签对数据进行分组：\n\n对出资额求和并在面元内规格化，以便图形化显示两位候选人各种赞助额度的比例：\n\n\n\n根据州统计赞助信息\n首先，根据候选人和州对数据进行聚合：\n\n对各行除以总赞助额，就得到各候选人在各州的总赞助额比例：\n\n\n\n不足之处，欢迎指正。\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "2"}