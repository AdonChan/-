{"title": "1.第一个Flask程序、DEBUG模式及URL传参 - 后端开发——Flask初体验 ", "index": "flask,python", "content": "--引言请见我的简书https://www.jianshu.com/p/e27...\n我们打开PyCharm，新建一个Project，在左侧选择Flask，右侧Location可选择项目存放的位置，Project Interpreter选择使用的编译器，我们当然可以选择已经安装在电脑上的Python 3.6，但我建议选择使用Virtualenv来建立一个虚拟的环境，这样在虚拟环境里安装包之类的，不会影响电脑上本身已经装的，并且后续如果项目较多的话也便于区分和管理。\n\n\n点击Create，创建好之后，PyCharm自动在项目的文件夹下建立了static、templates文件夹和HarpQA.py，此外还有一个venv文件夹，是虚拟环境用的，我们可以暂时不用管它。(如果你的PyCharm是社区版的，那么无法像专业版那样建立Flask项目，对应的文件夹需要自己手动建立)。HarpQA.py中的代码如下：\nfrom flask import Flask\n\napp = Flask(__name__)\n\n\n@app.route('/')\n\ndef hello_world(): \n\n    return 'Hello World!'\n    \n\nif __name__ == '__main__':\n\n    app.run()\n\n首先从flask导入Flask，（我并没有pip install flask，为何能导入呢？我理解是建立flask项目的时候PyCharm自动帮我们做了这个事情），然后初始化一个Flask对象app，参数是__name__，__name__代表的是本身这个模块的名字，我们暂时不用理解为何要传入这个参数。接下来是一个hello world函数，并且有一个装饰器@app.route('/')，意思是说，当接收到'/'这个网址的请求时，执行hello world这个函数，即返回字符串'Hello World!'（add_url_rule()也可以实现和@app.route一样的功能 ，但使用装饰器应该更pythonic吧），最后使用app.run()运行。运行脚本后，提示Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)我们在浏览器中输入http://127.0.0.1:5000/，就可以在网页中看到'Hello World!'了。\n\n\n我们还可以使用debug模式来运行flask的服务端，开启debug模式后，修改代码不需要关闭程序，可以实时生效。有多种方法来开启debug模式：\n\n在app.run()中添加参数，变为app.run(debug=True)；\n在run之前增加app.debug = True；\n新建config文件，在config文件中添加DEBUG = True，然后在程序中引入app.config.from_object(config)；\n在run之前增加app.config['DEBUG'] = True；\n\n我们使用第3种方法，新建一个独立的文件来保存各种参数，以后项目增大的时候参数增多，便于管理。同样在项目文件夹下新建config.py文件，添加DEBUG = True，DEBUG需大写。在HarpQA.py中import config并添加app.config.from_object(config)，再次运行HarpQA.py，提示：\n * Restarting with stat\n * Debugger is active!\n * Debugger PIN: 229-291-890\n * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)\n说明Debug模式已经打开，我们可以直接修改代码，例如把'Hello World!'修改成'Hello'并保存，显示：\n * Detected change in 'D:\\\\Flask\\\\HarpQA\\\\HarpQA.py', reloading\n * Restarting with stat\n * Debugger is active!\n * Debugger PIN: 229-291-890\n * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)\n说明DEBUG模式检测到了代码的变化并自动重载了，这时候刷新网页，结果也变成了只显示'Hello'。\n\n如果我们要处理很多URL，可以一个一个去给他们写对应的视图函数，这有时候是不切实际的，我们有更高效的做法，如以下代码:\n@app.route('/<name>/')\ndef hello(name):\n    return 'Hello %s' % name\n\n@app.route中装饰的地址是'/<name>/'，注意name外面用了尖括号，代表name是一个参数，例如我们请求http://127.0.0.1:5000/Harp/这个网址，其中的name就是Harp,这个参数会传递给视图函数hello，最终会返回'Hello Harp'。我们可以给将<name>写成<string:name>，表示传入的参数是字符串类型的，其他的类型还有int,float,path，几种类型的区别可以在网上搜索对比一下，例如path可以将参数里的'/'也传递过来。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}