{"title": "可变对象与不可变对象 - Crossin的编程教室 ", "index": "python", "content": "前阵子我们聊了下函数的参数传递以及变量赋值的一些内容：关于函数参数传递，80%人都错了\n简单回顾下要点：\n1. Python 中的变量不是装有对象的“ 容器 ”，而是贴在对象上的“ 标签 ”。\n\n2. 参数传递相当于一次 赋值 ：多贴了一个标签。\n3. 至于在函数内部对参数的修改是否会影响到外部变量的值，取决于你怎样修改：如果是重新赋值就不会，如果是修改对象自身内容则会。\n讲到这里就有个常被提及的概念：  可变对象和不可变对象\n在 Python 中，  可变对象 包括 list、dict、set、自定义类型 等；  不可变对象 包括 int、float、bool、str、tuple 等。\n不可变对象不允许对自身内容进行修改。如果我们对一个不可变对象进行赋值，实际上是生成一个新对象，再让变量指向这个对象。哪怕这个对象简单到只是数字 0 和 1：\n\n\na = 0\nprint('a', id(a))\na = 1\nprint('a', id(a))\n\n\n输出：\n\n\na 4463151440\na 4463151472\n\n\n因为对象不可变，所以为了提高效率，Python 会使用一些公用的对象：\n\n\na = 1\nprint('a', id(a))\nb = 1\nprint('b', id(b))\nprint(a == b)\nprint(a is b)\nc = 'hello world'\nprint('c', id(c))\nd = 'hello world'\nprint('d', id(d))\nprint(c == d)\nprint(c is d)\n\n\n输出：\n\n\na 4423761776\nb 4423761776\nTrue\nTrue\nc 4430180912\nd 4430180912\nTrue\nTrue\n\n\n这里顺便提一下 is 这个操作符。它和 == 的区别在于：== 只判断“值”是不是相等，而 is 则判断是否为同一个对象，也就是地址一致。比如：\n\n\na = 2\nb = 2.0\nprint(a == b)\nprint(a is b)\n\n\n输出：\n\n\nTrue\nFalse\n\n\n而可变对象则可以对自身内容进行修改，如：\n\n\nm = [1, 2, 3]\nprint('m', m, id(m))\nm[1] = 4\nprint('m', m, id(m))\nm.append(5)\nprint('m', m, id(m))\n\n\n输出：\n\n\nm [1, 2, 3] 4536815752\nm [1, 4, 3] 4536815752\nm [1, 4, 3, 5] 4536815752\n\n\n可以看到，虽然 m 的值发生了变化，但是地址没变，还是原来那个 m。\n上次我也说到，很多的教程都在用可变和不可变来谈论赋值和参数传递，我觉得这很不好。因为他们说到不可变对象时用的是赋值，而说到可变对象又用了 list 的索引、apeend 等方法，这根本是两码事。如果大家都是赋值，那么无论是否可变，效果都是一样的：\n\n\nm = [1, 2, 3]\nprint('m', m, id(m))\nm = [4, 5, 6]\nprint('m', m, id(m))\n\n\n输出\n\n\nm [1, 2, 3] 4329894024\nm [4, 5, 6] 4329910856\n\n\n所以理解了 Python 的赋值原理，就明白这与是否可变无关。而可变对象于不可变对象本身的不同仅在于一个可以修改变量的值，而另一个不允许。\n基于这一设定，两者在功能上的最大区别就是： 不可变对象可以作为字典 dict 的键 key ，而可变对象不行。比如 list 不能作为字典的键，但 tuple 可以。\n另外，明白了可变与不可变的区别，一些方法的效果也就自然理解了：\n\n\ns = 'abc'\ns2 = s.replace('b', 'd')\nprint('s', s)\nprint('s2', s2)\nm = [1, 2, 3]\nm2 = m.reverse()\nprint('m', m)\nprint('m2', m2)\n\n\n输出：\n\n\ns abc\ns2 adc\nm [3, 2, 1]\nm2 None\n\n\n因为 str 是不可变对象，所以它的方法如 replace、strip、upper 都不可能修改原对象， 只会返回一个新对象 ，比如重新赋值才可以。而 list 是可变对象，它的方法如 reverse、sort、append，都是 在原有对象上直接修改 ，无返回值。\n不过，有个特殊情况需要注意：\n\n\nm = [1, 2, 3]\nprint('m', m, id(m))\nm += [4]\nprint('m', m, id(m))\nm = m + [5]\nprint('m', m, id(m))\n\n\n输出\n\n\nm [1, 2, 3] 4494164104\nm [1, 2, 3, 4] 4494164104\nm [1, 2, 3, 4, 5] 4494181128\n\n\nm = m + 和 m += 虽然是一样的结果，但 m 指向的对象却发生了变化。原因在于，前者是做了赋值操作，而后者其实是调用的 __iadd__ 方法。\n如果我们就是需要产生一个 list 对象的副本，可以通过 [:]：\n\n\nm = [1, 2, 3]\nprint('m', m, id(m))\nn = m[:]\nprint('n', n, id(n))\nn[1] = 4\nprint('m', m)\nprint('n', n)\n\n\n这样对 n 的修改便不再会影响到 m，因为它们已不是同一个对象。\n那么如果是这样呢：\n\n\nm = [1, 2, [3]]\nn = m[:]\nn[1] = 4\nn[2][0] = 5\nprint(m)\n\n\n猜一猜 m 的结果是什么？\n\n[1, 2, [3]]\n[1, 4, [3]]\n[1, 2, [5]]\n[1, 4, [5]]\n其它结果\n\n再去 Python 里执行下看看输出，是不是和预期一样，想想为什么？这个牵涉到浅拷贝、深拷贝的概念，我们下次再聊。\n════  其他文章及回答：  如何自学Python | 新手引导 | 精选Python问答 | Python单词表 | 区块链 | 人工智能 | 双11 | 嘻哈 | 爬虫 | 排序算法 | 我用Python | 高考 | 世界杯 | 竞猜 | requests  欢迎搜索及关注： Crossin的编程教室\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}