{"title": "python 学习笔记2 --画图(networkx) - 我们俩 ", "index": "networkx,python", "content": "networkX tutorial\n\n\n  \n绘制基本网络图\n  绘制划分后的社区\n  \n\n\n\n绘制基本网络图\n\n用matplotlib绘制网络图\n基本流程：\n 1. 导入networkx，matplotlib包\n 2. 建立网络\n 3. 绘制网络 nx.draw()\n 4. 建立布局 pos = nx.spring_layout美化作用\n最基本画图程序\n\nimport import networkx as nx             #导入networkx包\nimport matplotlib.pyplot as plt \nG = nx.random_graphs.barabasi_albert_graph(100,1)   #生成一个BA无标度网络G\nnx.draw(G)                               #绘制网络G\nplt.savefig(\"ba.png\")           #输出方式1: 将图像存为一个png格式的图片文件\nplt.show()                            #输出方式2: 在窗口中显示这幅图像 \n\n\n\nnetworkx 提供画图的函数有：\n\n\n\ndraw（G，[pos,ax,hold]）\n\ndraw_networkx(G，[pos,with_labels])\n\ndraw_networkx_nodes(G,pos,[nodelist]) 绘制网络G的节点图\n\ndraw_networkx_edges(G,pos[edgelist]) 绘制网络G的边图\n\ndraw_networkx_edge_labels(G, pos[, ...]) 绘制网络G的边图，边有label\n---有layout 布局画图函数的分界线---\n\ndraw_circular(G, **kwargs)    Draw the graph G with a circular layout.\n\ndraw_random(G, **kwargs)  Draw the graph G with a random layout.\n\ndraw_spectral(G, **kwargs)    Draw the graph G with a spectral layout.\n\ndraw_spring(G, **kwargs)  Draw the graph G with a spring layout.\n\ndraw_shell(G, **kwargs)  Draw networkx graph with shell layout.\n\ndraw_graphviz(G[, prog])     Draw networkx graph with graphviz layout.\n\n\nnetworkx 画图参数：\n - node_size:  指定节点的尺寸大小(默认是300，单位未知，就是上图中那么大的点)\n - node_color:  指定节点的颜色 (默认是红色，可以用字符串简单标识颜色，例如'r'为红色，'b'为绿色等，具体可查看手册)，用“数据字典”赋值的时候必须对字典取值（.values()）后再赋值\n - node_shape:  节点的形状（默认是圆形，用字符串'o'标识，具体可查看手册）\n - alpha: 透明度 (默认是1.0，不透明，0为完全透明)\n - width: 边的宽度 (默认为1.0)\n - edge_color: 边的颜色(默认为黑色)\n - style: 边的样式(默认为实现，可选： solid|dashed|dotted,dashdot)\n - with_labels: 节点是否带标签（默认为True）\n - font_size: 节点标签字体大小 (默认为12)\n - font_color: 节点标签字体颜色（默认为黑色）\ne.g. nx.draw(G,node_size = 30, with_label = False)\n绘制节点的尺寸为30，不带标签的网络图。\n\n\n布局指定节点排列形式\n\npos = nx.spring_layout\n\n\n建立布局，对图进行布局美化，networkx 提供的布局方式有：\n- circular_layout：节点在一个圆环上均匀分布\n- random_layout：节点随机分布\n- shell_layout：节点在同心圆上分布\n- spring_layout： 用Fruchterman-Reingold算法排列节点（这个算法我不了解，样子类似多中心放射状）\n- spectral_layout：根据图的拉普拉斯特征向量排列节\n布局也可用pos参数指定，例如，nx.draw(G, pos = spring_layout(G)) 这样指定了networkx上以中心放射状分布.\n\n绘制划分后的社区\n\n先看一段代码，代码源自site\n\npartition = community.best_partition(User)\nsize = float(len(set(partition.values())))\npos = nx.spring_layout(G)\ncount = 0.\n\nfor com in set(partition.values()) :\n    count = count + 1.\n    list_nodes = [nodes for nodes in partition.keys()\n                                if partition[nodes] == com]                 \n    nx.draw_networkx_nodes(G, pos, list_nodes, node_size = 50,\n                                node_color = str(count / size))\n\nnx.draw_networkx_edges(User,pos,with_labels = True, alpha=0.5 )\nplt.show()\n\n\ncommunit.best_partition 是社区划分方法，算法是根据Vincent D.Blondel 等人于2008提出，是基于modularity optimization的heuristic方法.\npartition的结果存在字典数据类型：{'1': 0, '3': 1, '2': 0, '5': 1, '4': 0, '6': 0}\n单引号里的数据是key，也就是网络中节点编号。\n冒号后面的数值，表示网络中节点的编号属于哪个社区。也就是社区标号。如'6': 0表示6节点属于0社区\n\n list_nodes = [nodes for nodes in partition.keys()\n                                if partition[nodes] == com] \n\n\n每次循环list_nodes结果是社区i对应的用户编号。\n如第一次循环结果是com = 0, list_nodes= ['1','2','4','6']\n第二次循环的结果是com = 1, list_nodes = ['3','6']\n这样每次循环，画出一个社区的所有节点：\n\n nx.draw_networkx_nodes(G, pos, list_nodes, node_size = 50,\n                                node_color = str(count / size))\n\n\n循环结束后通过颜色来标识不同社区\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "10"}