{"title": "Python之MVC - chanbiao0816 ", "index": "python", "content": "写了几个小项目，在帮助同事的时候发现，每个人对MVC这种设计模式的理解各有千秋。我对于MVC的理解是M即Model，指的是数据库层面，V即View，指的是视图层面，至于C即Control，则是代码的逻辑部分。项目背景介绍，使用QT5写Gui，Mysql作为数据库。我采用C继承V，M继承C的模式来实现MVC。view层是将QT生成的ui文件转化成python代码，不直接修改view层的代码；model实现对数据库的CRUD操作，并return。control作为中间层，调用model层的方法获取结果，完成逻辑功能，再传递给view层实现数据渲染。\n# view.py\nclass View（QDialog）：\n    pass\n    \n    def render_view(self, data):\n        # render view\n        pass\n\n# control.py    \nclass Control(View):\n    pass\n    \n    def do_something(self):\n        data = self.get_data()\n        self.render_view(data)\n    \n# model.py  \nclass Model(Control):\n    pass\n    \n    def get_data(self):\n        return 'something'\n由于model层继承于control层，当我调用model层，也就是control的子类的方法时，它是不存在的，所以我得先声明一个空方法。\n#control.py    \nclass Control(View):\n    pass\n    \n    def do_something(self):\n        data = self.get_data()\n        self.render_view(data)\n        \n    def get_data(self):\n        pass\n但达到一定量的代码量时，发现control层的pass方法（方法体内只有pass）越来越多，觉得这样不妥呀~，而且当我要测试数据库交互是否正常时，也就是测试model层的代码，总是会弹出它爸爸的爸爸，也就是view层写的Gui，导致感觉非常难受。\n于是乎，选择重构，前后花了两周不到的时间，复用了部分逻辑，代码从18K+降到了11K左右。我选择将model层作为一个部件类，装配到control层，原先的view和control的关系不变。\n# view.py\nclass View（QDialog）：\n    pass\n    \n    def render_view(self, data):\n        # render view\n        pass\n\n# control.py    \nclass Control(View):\n    def __init__(self):\n        super().__init__()\n        self.model = Model()\n        pass\n    \n    def do_something(self):\n        data = self.model.get_data()\n        self.render_view(data)\n    \n# model.py  \nclass Model(object):\n    pass\n    \n    def get_data(self):\n        return 'something'\n这样处理后，我的model层至此和逻辑彻底分离，测试数据库交互方便多了，直接在model层下写个main方法就可以了，而且针对control层可以进行复用，也就是在相同Gui下，我可以在control层实例化多个不同的model，根据业务需要调用不同的model，提升代码的复用率。\n哇咔咔~~\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}