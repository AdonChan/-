{"title": "Python基础之(十)模块 - 再读斋 ", "index": "python", "content": "编写模块\n模块是程序\n模块就是一个扩展名为.py的Python程序。\n编写模块\n#!/usr/bin/env python\n# coding=utf-8\n\nlang = \"python\"\n引入模块\n>>> import sys\n>>> sys.path.append(\"~/Documents/VBS/StartLearningPython/2code/pm.py\")\n>>> import pm\n>>> pm.lang\n'python'\n当Python解释器读取了.py文件，先将它变成由字节码组成的.pyc文件，然后这个.pyc文件交给一个叫做Python虚拟机的东西去运行（那些号称编译型的语言也是这个流程，不同的是它们先有一个明显的编译过程，编译好了之后再运行）。如果.py文件修改了，Python解释器会重新编译，只是这个编译过程不是完全显示给你看的。\n我这里说的比较笼统，要深入了解Python程序的执行过程，可以阅读这篇文章：说说Python程序的执行过程\n有了.pyc文件后，每次运行就不需要重新让解释器来编译.py文件了，除非.py文件修改了。这样，Python运行的就是那个编译好了的.pyc文件。\nif name == \"__main__\"\n如果要作为程序执行，则__name__ == \"__main__\"；如果作为模块引入，则pm.__name__ == \"pm\"，即属性__name__的值是模块名称。\n模块的位置\n>>> import sys\n>>> import pprint\n>>> pprint.pprint(sys.path)  #查看所有模块的位置\n\n__all__在模块中的作用\n    # /usr/bin/env python\n    # coding:utf-8\n\n    __all__ = ['_private_variable', 'public_teacher']\n\n    public_variable = \"Hello, I am a public variable.\"\n    _private_variable = \"Hi, I am a private variable.\"\n\n    def public_teacher():\n        print \"I am a public teacher, I am from JP.\"    #Python 3: print(\"I am a public teacher, I am from JP.\")\n\n    def _private_teacher():\n        print \"I am a private teacher, I am from CN.\"    #Python 3:  print(\"I am a private teacher, I am from CN.\")\n__all__属性以及相应的值，在__all__属性列表中包含了一个私有变量的名字和一个函数的名字。这是在告诉引用本模块的解释器，这两个东西是有权限被访问的，而且只有这两个东西。\n包或者库\n包或者库，应该是比“模块”大的。也的确如此，一般来讲，一个“包”里面会有多个模块，当然，“库”是一个更大的概念了，比如Python标准库中的每个库都有好多个包，每个包都有若干个模块。\n一个包是由多个模块组成，即多个.py的文件，那么这个所谓“包”也就是我们熟悉的一个目录罢了。现在就需要解决如何引用某个目录中的模块问题了。解决方法就是在该目录中放一个__init__.py文件。__init__.py是一个空文件，将它放在某个目录中，就可以将该目录中的其它.py文件作为模块被引用。\n自带电池\n在Python被安装的时候，就有不少模块也随着安装到本地的计算机上了。这些东西就如同“能源”、“电力”一样，让Python拥有了无限生机，能够非常轻而易举地免费使用很多模块。所以，称之为“自带电池”。\n那些在安装Python时就默认已经安装好的模块被统称为“标准库”。\n引用的方式\n\nimport pprint #引入模块\n\nfrom pprint import pprint #引入该模块下的方法\n\nfrom pprint import * #引入该模块下的所有方法\n\nimport pprint as pr #重命名模块\n\nfrom pprint import pprint as pt  #重命名方法\n\n深入探究\n\ndir(),查看对象的属性和方法\nhelp()查看对象的含义\n\n帮助、文档和源码\nprint pprint.__doc__  #查看文档\nprint pprint.__file__ #查看模块的位置，根据这个位置查到源代码\n\n标准库\nsys\nsys.argv\nsys.argv是专门用来向python解释器传递参数，名曰“命令行参数”。\n    $ python --version # --veriosn就是命令行参数\n    Python 2.7.6\nsys.exit()\n退出当前程序.\n在大多数函数中会用到return，其含义是终止当前的函数，并向调用函数的位置返回相应值（如果没有就是None）。但是sys.exit()的含义是退出当前程序——不仅仅是函数，并发起SystemExit异常。这就是两者的区别了。\n如果使用sys.exit(0)表示正常退出。若需要在退出的时候有一个对人友好的提示，可以用sys.exit(\"I wet out at here.\")，那么字符串信息就被打印出来。\nsys.stdout\n与Python中的函数功能对照，sys.stdin获得输入（等价于Python 2中的raw_input()，Python 3中的input()），sys.stdout负责输出。\n    >>> f = open(\"stdout.md\", \"w\")\n    >>> sys.stdout = f  #重定向到文件\n    >>> print \"Learn Python: From Beginner to Master\"        #Python 3: print(\"Learn Python: From Beginner to Master\")\n    >>> f.close()\ncopy\nimport copy\ncopy.copy() #浅拷贝\ncopy.deepcopy() #深拷贝\nos\n操作文件\nimport os\nos.rename(\"22201.py\", \"newtemp.py\") #重命名文件\nos.remove(\"123.txt\") #删除一个文件，不能是目录\n操作目录\nos.listdir：显示目录中的内容（包括文件和子目录）os.getcwd：获取当前工作目录；os.pardir:获得上一级目录os.chdir：改变当前工作目录os.makedirs, os.removedirs：创建和删除目录\n文件和目录属性\nos.stat(p)显示文件或目录的属性os.chmod()改变权限\n操作命令\nos模块中提供了这样的方法，许可程序员在Python程序中使用操作系统的命令。\n    >>> p\n    '/home/qw/Documents/VBS/StarterLearningPython'\n    >>> command = \"ls \" + p #命令复制给Command变量\n    >>> command\n    >>> os.system(command) #执行命令\n需要注意的是，os.system()是在当前进程中执行命令，直到它执行结束。如果需要一个新的进程，可以使用os.exec或者os.execvp。对此有兴趣详细了解的读者，可以查看帮助文档了解。另外，os.system()是通过shell执行命令，执行结束后将控制权返回到原来的进程，但是os.exec()及相关的函数，则在执行后不将控制权返回到原继承，从而使Python失去控制。\n#!/usr/bin/env python\n# coding=utf-8\n\nimport webbrowser\nwebbrowser.open(\"http://www.baidu.com\") #跨平台打开浏览器\nheapq:堆\nheadpq模块\n    >>> import heapq\n    >>> heapq.__all__\n    ['heappush', 'heappop', 'heapify', 'heapreplace', 'merge', 'nlargest', 'nsmallest', 'heappushpop']\nheappush(heap, x)：将x压入堆heap\n    >>> import heapq\n    >>> heap = []    \n    >>> heapq.heappush(heap, 3)\n    >>> heapq.heappush(heap, 9)\n    >>> heapq.heappush(heap, 2)\n    >>> heapq.heappush(heap, 4)\n    >>> heapq.heappush(heap, 0)\n    >>> heapq.heappush(heap, 8)\n    >>> heap\n    [0, 2, 3, 9, 4, 8]\nheappop(heap)：删除最小元素\n    >>> heapq.heappop(heap)\n    0\n    >>> heap\n    [2, 4, 3, 9, 8]\nheapify()：将列表转换为堆\n    >>> hl = [2, 4, 6, 8, 9, 0, 1, 5, 3]\n    >>> heapq.heapify(hl)\n    >>> hl\n    [0, 3, 1, 4, 9, 6, 2, 5, 8]\nheapreplace()是heappop()和heappush()的联合，也就是删除一个，同时加入一个\n    >>> heap\n    [2, 4, 3, 9, 8]\n    >>> heapq.heapreplace(heap, 3.14)\n    2\n    >>> heap\n    [3, 4, 3.14, 9, 8]\ndeque:双端队列\n>>> qlst.append(5)        #从右边增加\n>>> qlst\ndeque([1, 2, 3, 4, 5])\n>>> qlst.appendleft(7)    #从左边增加\n>>> qlst\ndeque([7, 1, 2, 3, 4, 5])\n    \n>>> qlst.pop() #右边删除一个元素\n5\n>>> qlst\ndeque([7, 1, 2, 3, 4])\n>>> qlst.popleft() # 左边删除一个元素\n7\n>>> qlst\ndeque([1, 2, 3, 4])\n    \n>>> qlst.rotate(3) #循环移动n个位置\n>>> qlst\ndeque([2, 3, 4, 1])\n\ncalendar:日历\nimport calendar\ncal = calendar.month(2016,8)\nprint cal\n\n    August 2016\nMo Tu We Th Fr Sa Su\n 1  2  3  4  5  6  7\n 8  9 10 11 12 13 14\n15 16 17 18 19 20 21\n22 23 24 25 26 27 28\n29 30 31\ncalendar(year,w=2,l=1,c=6)返回year年的年历，3个月一行，间隔距离为c。 每日宽度间隔为w字符。每行长度为21* w+18+2* c。l是每星期行数。\nisleap(year)判断是否为闰年，是则返回true，否则false.\nleapdays(y1, y2)返回在y1，y2两年之间的闰年总数，包括y1，但不包括y2.\nmonth(year, month, w=2, l=1)返回year年month月日历，两行标题，一周一行。每日宽度间隔为w字符。每行的长度为7* w+6，l是每星期的行数。\nmonthcalendar(year,month)返回一个列表，列表内的元素还是列表。每个子列表代表一个星期，都是从星期一到星期日，如果没有本月的日期，则为0。\nmonthrange(year, month)返回一个元组，里面有两个整数。第一个整数代表着该月的第一天从星期几是（从0开始，依次为星期一、星期二，直到6代表星期日）。第二个整数是该月一共多少天。\nweekday(year,month,day)输入年月日，知道该日是星期几（注意，返回值依然按照从0到6依次对应星期一到星期六）。\ntime\n常用方法\ntime()获得的是当前时间（严格说是时间戳），只不过这个时间对人不友好，它是以1970年1月1日0时0分0秒为计时起点，到当前的时间长度（不考虑闰秒）。\nlocaltime()得到的结果可以称之为时间元组（也有括号），其各项的含义是：\n\n\n索引\n属性\n含义\n\n\n\n0\ntm_year\n年\n\n\n1\ntm_mon\n月\n\n\n2\ntm_mday\n日\n\n\n3\ntm_hour\n时\n\n\n4\ntm_min\n分\n\n\n5\ntm_sec\n秒\n\n\n6\ntm_wday\n一周中的第几天\n\n\n7\ntm_yday\n一年中的第几天\n\n\n8\ntm_isdst\n夏令时\n\n\n\ngmtime()localtime()得到的是本地时间，如果要国际化，就最好使用格林威治时间。\nasctime()\n    >>> time.asctime()\n    'Mon May  4 21:46:13 2015'\n    \n    time.asctime(h) #参数必须是时间元组，即localtime返回的值\nctime()\n>>> time.ctime()\n'Mon May  4 21:52:22 2015'\n    \n >>> time.ctime(1000000)  #参数是时间戳\n'Mon Jan 12 21:46:40 1970'\nmktime()mktime()也是以时间元组为参数，但是它返回的是时间戳\nstrftime()将时间元组按照指定格式要求转化为字符串。如果不指定时间元组，就默认为localtime()值。\n\n\n格式\n含义\n取值范围（格式）\n\n\n\n%y\n去掉世纪的年份\n00-99，如\"15\"\n\n\n%Y\n完整的年份\n如\"2015\"\n\n\n%j\n指定日期是一年中的第几天\n001-366\n\n\n%m\n返回月份\n01-12\n\n\n%b\n本地简化月份的名称\n简写英文月份\n\n\n%B\n本地完整月份的名称\n完整英文月份\n\n\n%d\n该月的第几日\n如5月1日返回\"01\"\n\n\n%H\n该日的第几时（24小时制）\n00-23\n\n\n%l\n该日的第几时（12小时制）\n01-12\n\n\n%M\n分钟\n00-59\n\n\n%S\n秒\n00-59\n\n\n%U\n在该年中的第多少星期（以周日为一周起点）\n00-53\n\n\n%W\n同上，只不过是以周一为起点\n00-53\n\n\n%w\n一星期中的第几天\n0-6\n\n\n%Z\n时区\n在中国大陆测试，返回CST，即China Standard Time\n\n\n%x\n日期\n日/月/年\n\n\n%X\n时间\n时:分:秒\n\n\n%c\n详细日期时间\n日/月/年 时:分:秒\n\n\n%%\n‘%’字符\n‘%’字符\n\n\n%p\n上下午\nAM    or    PM\n\n\n\nstrptime()作用是将字符串转化为时间元组,其参数要指定两个，一个是时间字符串，另外一个是时间字符串所对应的格式，格式符号用上表中的。\n    >>> today = time.strftime(\"%y/%m/%d\")\n    >>> today\n    '15/05/05'\n    >>> time.strptime(today, \"%y/%m/%d\")\n    time.struct_time(tm_year=2015, tm_mon=5, tm_mday=5, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=1, tm_yday=125, tm_isdst=-1)\ndatetime\ndatetime模块中有几个类：\n\ndatetime.date：日期类，常用的属性有year/month/day\ndatetime.time：时间类，常用的有hour/minute/second/microsecond\ndatetime.datetime：日期时间类\ndatetime.timedelta：时间间隔，即两个时间点之间的时间长度\ndatetime.tzinfo：时区类\n\ndate类\n\n# 生成日期对象\n>>> import datetime\n>>> today = datetime.date.today()\n>>> today\ndatetime.date(2015, 5, 5)\n\n# 操作日期对象\n\n>>> print today        #Python 3: print(today)\n2015-05-05\n>>> print today.ctime()        #Python 3: print(today.ctime())\nTue May  5 00:00:00 2015\n>>> print today.timetuple()        #Python 3: print(today.timetuple())\ntime.struct_time(tm_year=2015, tm_mon=5, tm_mday=5, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=1, tm_yday=125, tm_isdst=-1)\n>>> print today.toordinal()        #Python 3: print(today.toordinal())\n735723\n    \n>>> print today.year\n2015\n>>> print today.month\n5\n>>> print today.day\n5\n    \n# 时间戳与格式化时间格式的转换\n\n>>> to = today.toordinal()\n>>> to\n735723\n>>> print datetime.date.fromordinal(to)\n2015-05-05\n\n>>> import time\n>>> t = time.time()\n>>> t\n1430787994.80093\n>>> print datetime.date.fromtimestamp(t)\n2015-05-05\n\n# 修改日期。\n\n>>> d1 = datetime.date(2015,5,1)\n>>> print d1\n2015-05-01\n>>> d2 = d1.replace(year=2005, day=5)\n>>> print d2\n2005-05-05\ntime类\n\n# 生成time对象\n\n>>> t = datetime.time(1,2,3)\n>>> print t\n01:02:03\n\n# 常用属性：\n\n>>> print t.hour\n1\n>>> print t.minute\n2\n>>> print t.second\n3\n>>> t.microsecond\n0\n>>> print t.tzinfo\nNone\ntimedelta类\n主要用来做时间的运算。\n    >>> now = datetime.datetime.now()\n    >>> print now        #Python 3: print(now)\n    2015-05-05 09:22:43.142520\n\n# 对`now`增加5个小时；\n\n    >>> b = now + datetime.timedelta(hours=5)\n    >>> print b        #Python 3: print(b)\n    2015-05-05 14:22:43.142520\n\n# 增加两周；\n\n    >>> c = now + datetime.timedelta(weeks=2)\n    >>> print c        #Python 3: print(c)\n    2015-05-19 09:22:43.142520\n\n# 计算时间差：\n\n    >>> d = c - b\n    >>> print d        #Python 3: print(d)\n    13 days, 19:00:00\nurllib\nurllib模块用于读取来自网上（服务器上）的数据，比如不少人用Python做爬虫程序，就可以使用这个模块。\n# 在Python 2中，这样操作：\n    >>> import urllib\n    >>> itdiffer =  urllib.urlopen(\"http://www.itdiffer.com\")\n\n# 但是如果读者使用的是Python 3，必须换个姿势：\n\n    >>> import urllib.request\n    >>> itdiffer = urllib.request.urlopen(\"http://www.itdiffer.com\")\n    \n    >>> print itdiffer.read() #得到网页的内容\nurlopen()\nurlopen()主要用于打开url文件，然后就获得指定url的数据，然后就如同在操作文件那样来操作,得到的对象叫做类文件对象。\n参数说明一下：\n\nurl：远程数据的路径，常常是网址\ndata：如果使用post方式，这里就是所提交的数据\nproxies：设置代理\n\nurl编码、解码\nurl对其中的字符有严格的编码要求，要对url进行编码和解码。\n\nquote(string[, safe])：对字符串进行编码。参数safe指定了不需要编码的字符\nurllib.unquote(string) ：对字符串进行解码\nquote_plus(string [ , safe ] ) ：与urllib.quote类似，但这个方法用'+'来替换空格' '，而quote用'%20'来代替空格\nunquote_plus(string ) ：对字符串进行解码；\nurllib.urlencode(query[, doseq])：将dict或者包含两个元素的元组列表转换成url参数。例如{'name': 'laoqi', 'age': 40}将被转换为\"name=laoqi&age=40\"\npathname2url(path)：将本地路径转换成url路径\nurl2pathname(path)：将url路径转换成本地路径\n\nurlretrieve()\n将远程文件保存在本地存储器中.\nurllib.urlretrieve(url[, filename[, reporthook[, data]]])\n\nurl：文件所在的网址\nfilename：可选。将文件保存到本地的文件名，如果不指定，urllib会生成一个临时文件来保存\nreporthook：可选。是回调函数，当链接服务器和相应数据传输完毕时触发本函数\ndata：可选。如果用post方式所发出的数据\n\n函数执行完毕，返回的结果是一个元组(filename, headers)，filename是保存到本地的文件名，headers是服务器响应头信息。\nurllib2\n仅仅是针对Python 2的，在Python 3中，已经没有urllib2这个模块了，取代它的是urllib.request。\nRequest类\n>>>req = urllib2.Request(\"http://www.itdiffer.com\")\n\n# Python2\n    >>> response = urllib2.urlopen(req)\n    >>> page = response.read()\n    >>> print page\n\nPython 3:\n\n    >>> response = urllib.request.urlopen(req)\n    >>> page = response.read()\n    >>> print(page)\nurllib2或者urllib.request的东西还很多，比如还可以:\n\n设置HTTP Proxy\n设置Timeout值\n自动redirect\n处理cookie\n\nXML\nPython提供了多种模块来处理XML。\n\nxml.dom.* 模块：Document Object Model。适合用于处理 DOM API。它能够将XML数据在内存中解析成一个树，然后通过对树的操作来操作XML。但是，这种方式由于将XML数据映射到内存中的树，导致比较慢，且消耗更多内存。\nxml.sax.* 模块：simple API for XML。由于SAX以流式读取XML文件，从而速度较快，切少占用内存，但是操作上稍复杂，需要用户实现回调函数。\nxml.parser.expat：是一个直接的，低级一点的基于 C 的 expat 的语法分析器。 expat接口基于事件反馈，有点像 SAX 但又不太像，因为它的接口并不是完全规范于 expat 库的。\nxml.etree.ElementTree (以下简称 ET)：元素树。它提供了轻量级的Python式的API，相对于DOM，ET快了很多，而且有很多令人愉悦的API可以使用；相对于SAX，ET也有ET.iterparse提供了 “在空中” 的处理方式，没有必要加载整个文档到内存，节省内存。ET的性能的平均值和SAX差不多，但是API的效率更高一点而且使用起来很方便。\n\nElementTree在标准库中有两种实现。一种是纯Python实现：xml.etree.ElementTree ，另外一种是速度快一点：xml.etree.cElementTree 。\n如果使用的是Python 2，可以像这样引入模块：\n    try:\n        import xml.etree.cElementTree as ET\n    except ImportError:\n        import xml.etree.ElementTree as ET\n如果是Python 3以上，就没有这个必要了，只需要一句话import xml.etree.ElementTree as ET即可，然后由模块自动来寻找适合的方式。显然Python 3相对Python 2有了很大进步。\n常用属性和方法总结\nET里面的属性和方法不少，这里列出常用的，供使用中备查。\nElement对象\n常用属性：\n\ntag：string，元素数据种类\ntext：string，元素的内容\nattrib：dictionary，元素的属性字典\ntail：string，元素的尾形\n\n针对属性的操作\n\nclear()：清空元素的后代、属性、text和tail也设置为None\nget(key, default=None)：获取key对应的属性值，如该属性不存在则返回default值\nitems()：根据属性字典返回一个列表，列表元素为(key, value）\nkeys()：返回包含所有元素属性键的列表\nset(key, value)：设置新的属性键与值\n\n针对后代的操作\n\nappend(subelement)：添加直系子元素\nextend(subelements)：增加一串元素对象作为子元素\nfind(match)：寻找第一个匹配子元素，匹配对象可以为tag或path\nfindall(match)：寻找所有匹配子元素，匹配对象可以为tag或path\nfindtext(match)：寻找第一个匹配子元素，返回其text值。匹配对象可以为tag或path\ninsert(index, element)：在指定位置插入子元素\niter(tag=None)：生成遍历当前元素所有后代或者给定tag的后代的迭代器\niterfind(match)：根据tag或path查找所有的后代\nitertext()：遍历所有后代并返回text值\nremove(subelement)：删除子元素\n\nElementTree对象\n\nfind(match)\nfindall(match)\nfindtext(match, default=None)\ngetroot()：获取根节点.\niter(tag=None)\niterfind(match)\nparse(source, parser=None)：装载xml对象，source可以为文件名或文件类型对象.\nwrite(file, encoding=\"us-ascii\", xml_declaration=None, default_namespace=None,method=\"xml\")　\n\n实例\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<bookstore liu=\"a\">\n    <book category=\"COOKING\">\n        <title lang=\"en\">Everyday Italian</title>\n        <author>Giada De Laurentiis</author>\n        <year>2005</year>\n        <price>30.00</price>\n    </book>\n    <book category=\"CHILDREN\">\n        <title lang=\"en\">Harry Potter</title>\n        <author>J K. Rowling</author>\n        <year>2005</year>\n        <price>29.99</price>\n    </book>\n    <book category=\"WEB\">\n        <title lang=\"en\">Learning XML</title>\n        <author>Erik T. Ray</author>\n        <year>2003</year>\n        <price>39.95</price>\n    </book>\n</bookstore>\n#!/usr/bin/env python\n# coding=utf-8\n\nimport xml.etree.ElementTree as ET\n\nfd = open(\"xml.xml\")\n\ndata = fd.read()\n\ntree = ET.ElementTree(file=\"xml.xml\")\nprint tree\n\n#获得根元素\nroot = tree.getroot()\nprint root.tag\nprint root.attrib\n\n#获得根元素下面的元素\nfor child in root:\n    print child.tag,child.attrib\n    for gen in child:\n        print gen.tag,gen.text\nJSON\nJSON建构于两种结构：\n\n“名称/值”对的集合（A collection of name/value pairs）。不同的语言中，它被理解为对象（object），纪录（record），结构（struct），字典（dictionary），哈希表（hash table），有键列表（keyed list），或者关联数组 （associative array）。\n值的有序列表（An ordered list of values）。在大部分语言中，它被理解为数组（array）。\n\npython标准库中有JSON模块，主要是执行序列化和反序列化功能：\n\n序列化：encoding，把一个Python对象编码转化成JSON字符串\n反序列化：decoding，把JSON格式字符串解码转换为Python数据对象\n\nencoding: dumps()\ndata_json = json.dumps(data)\njson.dumps(data, sort_keys=True, indent=2) #格式化输出json数据\ndecoding: loads()\n大json字符串\n如果数据不是很大，上面的操作足够了。但现在是所谓“大数据”时代了，随便一个什么业务都在说自己是大数据，显然不能总让JSON很小，事实上真正的大数据，再“大”的JSON也不行了。前面的操作方法是将数据都读入内存，如果数据太大了就会内存溢出。怎么办？JSON提供了load()和dump()函数解决这个问题，注意，跟上面已经用过的函数相比，是不同的，请仔细观察。\n    >>> import tempfile    #临时文件模块\n    >>> data\n    [{'lang': ('python', 'english'), 'age': 40, 'name': 'qiwsir'}]\n    >>> f = tempfile.NamedTemporaryFile(mode='w+')\n    >>> json.dump(data, f)\n    >>> f.flush()\n    >>> print open(f.name, \"r\").read()        #Python 3: print(open(f.name, \"r\").read())\n    [{\"lang\": [\"python\", \"english\"], \"age\": 40, \"name\": \"qiwsir\"}]\n实例\n{\"code\":20,\"data\":\"liuguoquan\",\"person\":[{\"name\":\"zhang\",\"age\":19,\"sex\":\"male\"},{\"name\":\"zhang\",\"age\":20,\"sex\":\"male\"}]}\n#!/usr/bin/env python\n# coding=utf-8\n\nimport json\n\nclass B(object):\n    def __init__(self):\n        self.age = 0\n        self.name = \"\"\n        self.sex = \"\"\n\nclass A(object):  \n    def __init__(self):\n        self.code = 2\n        self.data = \"\"\n        self.person = []\n    \n\nf = open(\"sample.json\")\nvalue = f.read();\nprint value\n\nret = json.loads(value)\nprint type(ret)\n\na = A()\n#对象转为字典\na.__dict__ = ret\nprint a.code\nprint a.data\nprint a.person\nprint type(a.person)\n\nfor item in a.person:\n    b = B()\n    b.__dict__ = item;\n    print b.age\n    print b.name\n    print b.sex\n第三方库\n安装第三方库\n利用源码安装\n在github.com网站可以下载第三方库的源码,通常会看见一个 setup.py 的文件。\npython setup.py install\npip管理工具\npip是一个以Python计算机程序语言写成的软件包管理系统，它可以安装和管理软件包，另外不少的软件包也可以在“Python软件包索引”（英语：Python Package Index，简称PyPI）中找到。\npip install XXXXXX（XXXXXX代表第三方库的名字）即可安装第三方库。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "5"}