{"title": "理解线程3 c语言示例线程基本操作 - Python提高班 ", "index": "c,python", "content": "基本线程的动作\n\n继续之前C语言线程的文章:文章1 文章2 来了解基本的线程操作。\n设置线程属性\n\n设置脱离状态\n\n下面代码中关键的地方在于：\n\n通过 res = pthread_attr_init(&thread_attr); 初始化一个线程属性\n通过 res = pthread_attr_setdetachstate(&thread_attr, PTHREAD_CREATE_DETACHED); 将属性设置为脱离状态(PTHREAD_CREATE_DETACHED),即不能通过调用 pthread_join 来获得另一个线程的退出状态\n另外还有一个常用的默认状态是 PTHREAD_CREATE_JOINABLE ,可以允许两个线程重新合并。\n属性用完后对其进行清理回收 (void)pthread_attr_destroy(&thread_attr);\n通过共享的变量 thread_finished 来检测子线程是否已经结束\n\n代码如下:\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <pthread.h>\n\nvoid *thread_function(void *arg);\n\nchar message[] = \"Hello World\";\nint thread_finished = 0;\n\nint main() {\n  int res;\n  pthread_t a_thread;\n\n  pthread_attr_t thread_attr;\n\n  res = pthread_attr_init(&thread_attr);\n  if (res != 0) {\n    perror(\"Attribute creation failed\");\n    exit(EXIT_FAILURE);\n  }\n  res = pthread_attr_setdetachstate(&thread_attr, PTHREAD_CREATE_DETACHED);\n  if (res != 0) {\n    perror(\"Setting detached attribute failed\");\n    exit(EXIT_FAILURE);\n  }\n  res = pthread_create(&a_thread, &thread_attr, thread_function, (void *)message);\n  if (res != 0) {\n    perror(\"Thread creation failed\");\n    exit(EXIT_FAILURE);\n  }\n  (void)pthread_attr_destroy(&thread_attr);\n  while(!thread_finished) {\n    printf(\"Waiting for thread to say it's finished...\\n\");\n    sleep(1);\n  }\n  printf(\"Other thread finished, bye!\\n\");\n  exit(EXIT_SUCCESS);\n}\n\nvoid *thread_function(void *arg){\n  printf(\"thread_function is running. Argument was %s\\n\", (char *)arg);\n  sleep(4);\n  printf(\"Second thread setting finished flag, and exiting now\\n\");\n  thread_finished = 1;\n  pthread_exit(NULL);\n}\n\n设置调度属性\n\n线程库提供以下调度策略:\n| SCHED_FIFO  | 先进先出 (FIFO) 调度。每个线程都有一个固定的优先级；当多个线程具有相同的优先级时，它们按照先进先出 (FIFO) 的顺序运行直到完成 |\n| SCHED_RR    | 循环 (RR) 调度。每个线程都有固定的优先级；当多个线程具有相同的优先级时，它们按照先进先出 (FIFO) 的顺序在一个 固定的时间片内运行。 |\n| SCHED_OTHER | 缺省的 AIX® 调度。每个线程都有一个由调度程序根据线程的活动动态修改的初始优先级；线程的执行是按时间分割的。在其他系统上，这个调度策略可能会不同。 |\n\n设置调度属性和设置很相似:\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <pthread.h>\n\nvoid *thread_function(void *arg);\n\nchar message[] = \"Hello World\";\nint thread_finished = 0;\n\nint main() {\n    int res;\n    pthread_t a_thread;\n    pthread_attr_t thread_attr;\n\n    int max_priority;\n    int min_priority;\n    struct sched_param scheduling_value;\n\n    res = pthread_attr_init(&thread_attr);\n    if (res != 0) {\n        perror(\"Attribute creation failed\");\n        exit(EXIT_FAILURE);\n    }\n    res = pthread_attr_setschedpolicy(&thread_attr, SCHED_OTHER);\n    if (res != 0) {\n        perror(\"Setting schedpolicy failed\");\n        exit(EXIT_FAILURE);\n    }\n    res = pthread_attr_setdetachstate(&thread_attr, PTHREAD_CREATE_DETACHED);\n    if (res != 0) {\n        perror(\"Setting detached attribute failed\");\n        exit(EXIT_FAILURE);\n    }\n    res = pthread_create(&a_thread, &thread_attr, thread_function, (void *)message);\n    if (res != 0) {\n        perror(\"Thread creation failed\");\n        exit(EXIT_FAILURE);\n    }\n    max_priority = sched_get_priority_max(SCHED_OTHER);\n    min_priority = sched_get_priority_min(SCHED_OTHER);\n    scheduling_value.sched_priority = min_priority;\n    res = pthread_attr_setschedparam(&thread_attr, &scheduling_value);\n    if (res != 0) {\n        perror(\"Setting schedpolicy failed\");\n        exit(EXIT_FAILURE);\n    }\n    (void)pthread_attr_destroy(&thread_attr);\n    while(!thread_finished) {\n        printf(\"Waiting for thread to say it's finished...\\n\");\n        sleep(1);\n    }\n    printf(\"Other thread finished, bye!\\n\");\n    exit(EXIT_SUCCESS);\n}\n\nvoid *thread_function(void *arg) {\n    printf(\"thread_function is running. Argument was %s\\n\", (char *)arg);\n    sleep(4);\n    printf(\"Second thread setting finished flag, and exiting now\\n\");\n    thread_finished = 1;\n    pthread_exit(NULL);\n}\n\n取消线程\n\n\n通过 int pthread_cancel(pthread_t thread); 来请求一个线程终止\n通过 int pthread_setcancelstate(int state, int *oldstate) 来设置接受的进程是允许取消请求还是忽略它\n通过 int pthread_setcanceltype(int type, int *oldtype) 来设置取消类型, PTHREAD_CANCEL_ASYCHRONOUS 代表接收到取消请求后立即行动， THREAD_CANCEL_DEFERRED 表示在接收到请求后，等待函数执行下述动作之一后才取消线程: pthread_join, pthread_cond_wait, pthread_cond_timeout, pthread_test_cancel, sem_wait, sigwait 等\n\n代码如下:\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <pthread.h>\n\nvoid *thread_function(void *arg);\n\nint main () {\n  int res;\n  pthread_t a_thread;\n  void *thread_result;\n\n  res = pthread_create(&a_thread, NULL, thread_function, NULL);\n  if (res != 0){\n    perror(\"Thread creation failed\");\n    exit(EXIT_FAILURE);\n  }\n  sleep(3);\n  printf(\"Caceling thread...\\n\");\n  res = pthread_cancel(a_thread);\n  if (res != 0){\n    perror(\"Thread cancelation failed\");\n    exit(EXIT_FAILURE);\n  }\n  printf(\"Waiting for thread to finish...\\n\");\n  res = pthread_join(a_thread, &thread_result);\n  if (res != 0) {\n    perror(\"Thread join failed\");\n    exit(EXIT_FAILURE);\n  }\n  exit(EXIT_SUCCESS);\n}\n\nvoid *thread_function(void *arg) {\n  int i, res;\n  res = pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);\n  if (res != 0) {\n    perror(\"Thread pthread_setcalcelstate failed\");\n    exit(EXIT_FAILURE);\n  }\n  res = pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, NULL);\n  if (res != 0) {\n    perror(\"Thread pthread_setcanceltype failed\");\n    exit(EXIT_FAILURE);\n  }\n  printf(\"thread_function is running\\n\");\n  for(i=0; i<10; i++) {\n    printf(\"Thread is still running (%d)...\\n\", i);\n    sleep(1);\n  }\n  pthread_exit(0);\n}\n\n主线程创建多个线程示例\n\n代码如下：\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <pthread.h>\n\n#define NUM_THREADS 6\n\nvoid *thread_function(void *arg);\n\nint main() {\n    int res;\n    pthread_t a_thread[NUM_THREADS];\n    void *thread_result;\n    int lots_of_threads;\n\n    for(lots_of_threads = 0; lots_of_threads < NUM_THREADS; lots_of_threads++) {\n\n        res = pthread_create(&(a_thread[lots_of_threads]), NULL, thread_function, (void *)&lots_of_threads);\n        if (res != 0) {\n            perror(\"Thread creation failed\");\n            exit(EXIT_FAILURE);\n        }\n        sleep(1);\n    }\n    printf(\"Waiting for threads to finish...\\n\");\n    for(lots_of_threads = NUM_THREADS - 1; lots_of_threads >= 0; lots_of_threads--) {\n        res = pthread_join(a_thread[lots_of_threads], &thread_result);\n        if (res == 0) {\n            printf(\"Picked up a thread\\n\");\n        }\n        else {\n            perror(\"pthread_join failed\");\n        }\n    }\n    printf(\"All done\\n\");\n    exit(EXIT_SUCCESS);\n}\n\nvoid *thread_function(void *arg) {\n    int my_number = *(int *)arg;\n    int rand_num;\n\n    printf(\"thread_function is running. Argument was %d\\n\", my_number);\n    rand_num=1+(int)(9.0*rand()/(RAND_MAX+1.0));\n    sleep(rand_num);\n    printf(\"Bye from %d\\n\", my_number);\n    pthread_exit(NULL);\n}\n\n运行结果如下:\nthread_function is running. Argument was 0\nBye from 0\nthread_function is running. Argument was 1\nthread_function is running. Argument was 2\nBye from 1\nthread_function is running. Argument was 3\nthread_function is running. Argument was 4\nthread_function is running. Argument was 5\nWaiting for threads to finish...\nBye from 5\nPicked up a thread\nBye from 3\nBye from 2\nBye from 4\nPicked up a thread\nPicked up a thread\nPicked up a thread\nPicked up a thread\nPicked up a thread\nAll done\n\n了解更多\n\nPosix多线程编程—线程属性\n参考资料\n\n\n《Linux 程序设计》\nhttp://www.ibm.com/support/kn...\n\nPS\n\n不得不承认，我失败了。曾计划每天分享一篇python相关知识点但没有做到。失败的原因想找可以找很多比如最近在做一个小的项目、这几天出去聚会没有时间、工作出现问题加班到比较晚等等，然而总结起来不外乎在心里它的重要程度是怎么样的。我反思了下几乎做到一天一篇的这一个月过程做出改变，不再要求一天一篇，而是当我有好的素材要分享时才分享，这样与我与大家都是一件好事，我可以动态调度自己的精力和注意力，比如最近实现了一半的一个odoo项目依赖关系分析器可以尽快把它做完，对于读者来说也可以减少干扰看到更好的分享而不是像我之前有几篇那样划水的。但每周应该会有3-4篇Python的知识可以分享。另外我目前的工作是基于Odoo的，我计划尝试做一些基础的教程来分享这个我熟悉的框架，如果有进展一定会告知感兴趣的读者。感谢读者。\n最后向漩涡鸣人致敬，朝他的“说到做到，这就是我的忍道”努力。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}