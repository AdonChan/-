{"title": "[原] Python 开发者面向文档编程的正确姿势 - FinanceR ", "index": "python,r", "content": "概述\n\n秦人不暇自哀,而后人哀之;后人哀之而不鉴之,亦使后人而复哀后人也! --论面向文档编程的重要性\n如果想看见识一个人写代码的功力，注释其实是区分老司机和小鲜肉的一个显著的分界线（有没有观察到你们公司的领导基本都在开会或者写文档），通常情况下老司机的文档量与代码量是1：1的比例，而新人往往认为写完功能模块就已经可以完成任务了。生产环境中需要面对现实中大量复杂的业务逻辑和数据校验并与各方对接，文档质量和代码质量就被提升到了相同的高度。很多人没有写注释的习惯，大多数不是因为懒惰，一方面是没有意识到写文档的好处，另一方面是不了解这方面的工具。毕竟从管理上依赖于人的主动性是远不如依赖于工具有效的。本文介绍如何利用Python注释提升文档书写的质量以及效率的小技巧。\nPython\n在实际生产中，机器学习工作现在看起来，白天像是个算法工程师的活，晚上就变成运维+测试了。Python 一直以来也都受到测试工程师和运维工程师的偏爱，下面是几个经典的注释活用case。\n用注释写单元测试:doctest\n\n\n单元测试是代码开发环节必不可少的一环，对于Bug定位和代码质量而言是非常重要的。现在最广为人知的单元测试框架就是Unittest，它借鉴了Java中成熟的单元测试框架的JUnit。即使像Django还对这个框架有特殊的支持，然而在实现Unittest的时候会感觉确实比较啰嗦，setup，teardown...在维护单元测试的时候很多时候感觉力不从心。\n一个巧妙的方式可以是通过doctest，用docstring注释的方式来完成单元测试，由于每个方法def下面都先跟着一段测试用例，然后紧跟着就是代码正文，这样一来很方便我们测试现有代码的质量，另一方面又便于修改。\n举个例子：\ndef factorial(n):\n    \"\"\"Return the factorial of n, an exact integer >= 0.\n\n    >>> [factorial(n) for n in range(6)]\n    [1, 1, 2, 6, 24, 120]\n    >>> factorial(30)\n    265252859812191058636308480000000\n    >>> factorial(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: n must be >= 0\n\n    Factorials of floats are OK, but the float must be an exact integer:\n    >>> factorial(30.1)\n    Traceback (most recent call last):\n        ...\n    ValueError: n must be exact integer\n    >>> factorial(30.0)\n    265252859812191058636308480000000\n\n    It must also not be ridiculously large:\n    >>> factorial(1e100)\n    Traceback (most recent call last):\n        ...\n    OverflowError: n too large\n    \"\"\"\n\n    import math\n    if not n >= 0:\n        raise ValueError(\"n must be >= 0\")\n    if math.floor(n) != n:\n        raise ValueError(\"n must be exact integer\")\n    if n+1 == n:  # catch a value like 1e300\n        raise OverflowError(\"n too large\")\n    result = 1\n    factor = 2\n    while factor <= n:\n        result *= factor\n        factor += 1\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n上面是官网提供的一个求N的阶乘函数示例，在docstring 中通过 >>>符号来开始一个单元测试，之后换行输入预期结果即可。实际上就是复制粘贴一下调试过程和结果，真的再简单不过了，想实现TDD也因此变得非常轻松。\n用注释写API文档:apidoc\n\n\n在我们完成机器学习模型后，想要提供一个对外服务的接口以贡献我们的算力时就需要完备的API文档，也是通过API的调用才能为我们的模型提供源源不断的校验数据，对于提升模型效果有非常实际的意义。对大多数人而言调用API来完成开发都是一件比较开心的事情，因为我们可以少做很多工作就可以实现强大功能。然而，当我们需要对外提供API时就要面临不一样的考验了，接口鉴权、接口设计、版本控制、并发问题、日志埋点...这些都是需要面对的新问题，而利用 apidoc 可以很好地解决这些API文档中常见的诸多问题，相当于通过模板提升了我们的接口设计的能力。\napidoc为Python提供了一种类似于 docstring 的方式来写API文档，从语法上看比较类似于 R中的roxygen，都需要用户以 @xxx 符号作为一个开头，随后书写相关的定义和功能。\n举个例子：\n下面是一个API接口的定义方法，最核心的部分就是\n\n路由\nGET/POST方法\n名称/分组\n参数与调用例子\n\n（这年头没有用例的代码都是耍流氓）\n\"\"\"\n@api {get} /user/:id Request User information\n@apiName GetUser\n@apiGroup User\n\n@apiParam {Number} id Users unique ID.\n\n@apiSuccess {String} firstname Firstname of the User.\n@apiSuccess {String} lastname  Lastname of the User.\n\"\"\"\n我们可以直接撸一个官方示例来学习如何使用apidoc。\n首先，下载示例源码\ngit clone https://github.com/apidoc/apidoc\ncd apidoc\n然后，安装 apidoc 组件\nsudo npm install apidoc -g\n接着，利用官方代码来制作一个例子，并且访问即可。\napidoc -i example/ -o output/ -t template/\nopen output/index.html\n几个参数的含义如下：-i:input，表示输入的文件夹-o:output，表示输出文件夹-t:template，表示模板文件，通过替换模板我们可以修改文档皮肤\n在 example 文件夹下，我们需要在apidoc.json 中填写配置文件，定义文档的header和footer部分内容，其余的文件会被自动识别出其中的docstring作为API文档的一部分。\n由于apidoc的官方文档非常简单清晰，所以这里不过多强调语法。\n\napidoc 还为我们提供了接口调试的功能，在实际使用的时候要注意：\n\n我们需要一个web server 才可以使用这个接口调试的功能\n要注意跨域的问题。\n\n\n通过版本对比，我们还可以快速排查API接口的变化情况。需要注意的是这个功能要求我们要将历史的文档记录也要保存在该目录下的文件中，通常我们可以把历史的注释输出到一个特定文件中保存。\n总的来说，虽然，API文档的书写并不是一件难度非常高的事情，却能体现系统模块设计和用户体验设计的功力，我们应该对那些无代码示例，无版本控制的API文档say no！\n用注释写命令行接口docopt\n\n利用docopt，我们可以在注释中直接声明文件的命令行传入参数，而不需要通过 argvs变量来捕获输入值再做判断，这在调用运维脚本或者若干任务调度脚本的时候尤其管用，极大地提升了CLI的效率。\n举个例子：（此处代码仅供参考）\n\"\"\"Usage:\n  fiannceR.py tcp <host> <port> [--timeout=<seconds>]\n  fiannceR.py serial <port> [--baud=9600] [--timeout=<seconds>]\n  fiannceR.py -h | --help | --version\n\n\"\"\"\nfrom docopt import docopt\n\nif __name__ == '__main__':\n    arguments = docopt(__doc__, version='0.1.1rc')\n    print(arguments)\n随后，我们可以在命令行中成功调用\nfiannceR.py tcp 0.0.0.0 3838\n这里的 arguments 将传出一个字典对象，以Key-Value的形式将命令行中的输入值捕获。\n{'--baud': None,\n '--help': False,\n '--timeout': None,\n '--version': False,\n '-h': False,\n '<host>': '0.0.0.0',\n '<port>': '3838',\n 'serial': False,\n 'tcp': True}\n总结\n如果真的要从数据撸到模型、接口，那么一排注释的画面真是美得不敢想象。\n\"\"\"unitest\n>>> FinanceR('20161001')\n21.01\n\"\"\"\ndef FinanceR(date):\n    price = get_price(date)\n    return(price)\n\nclass(BaseHandler):\n    def get(self):   \n        \"\"\"apidoc\n           @api {get} /price/:date 获取当前价格\n           @apiName GetPrice\n           @apiGroup Quota\n\n           @apiParam {Number} date 交易日期\n\n           @apiSuccess {String} price\n        \"\"\"\n        date = self.get_argument('date',None)\n        try:\n            price = FinanceR(date)\n            self.write({'data':{'price':price},'response':{'message':'success','code':200}})\n        except Exception as e:\n            self.write({'data':None,'response':{'message':str(e),'code':404}})\n            \n\"\"\"Usage:\n  fiannceR.py tcp <host> <port> [--timeout=<seconds>]\n  fiannceR.py serial <port> [--baud=9600] [--timeout=<seconds>]\n  fiannceR.py -h | --help | --version\n\n\"\"\"\nfrom docopt import docopt\n\nif __name__ == '__main__':\n    arguments = docopt(__doc__, version='0.1.1rc')\n    print(arguments)\n欢迎大家留言讨论，给出更多应用案例，交流分享。\n参考文献\n\nAPIDoc\nPython 指南：测试你的代码\ndoctest\nnose is nicer testing for python\ntox: standardize testing in Python\nBiopython测试框架\nDocopt\nSphinx\ndocopt.R\n\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "10"}