{"title": "django搭建一个小型的服务器运维网站-查看服务器中的日志与前端的datatable的利用 - 个人文章 ", "index": "django,python,html,javascript", "content": "目录\n\n\n项目介绍和源码；\n\n拿来即用的bootstrap模板；\n\n服务器SSH服务配置与python中paramiko的使用；\n\n用户登陆与session;\n\n最简单的实践之修改服务器时间；\n\n查看和修改服务器配置与数据库的路由；\n\n基于websocket的实时日志实现；\n查看服务器中的日志与前端的datatable的利用；\n\n重启服务器进程。\n\n前言\n  除了能够支持实时的日志之外，小项目还需要增加一个回看日志的页面，页面的效果如图1所示。这个页面的作用是按用户的需求（日志的日期、日志内容的时间、日志的内容）筛选出需要的日志并且展示到这个datatable的动态表格中，它的实现原理很简单，但是具有一定的局限性。但是可以满足一些本身不多的日志的查看，如错误日志、测试日志、服务器日志这些。\n\n功能内容\n显示页面\n  页面由一个Datatable和自己写的一些input组件组成，其html脚本如下。\n{% extends \"./base.html\" %}\n\n{% block othercss %}\n<link href=\"https://cdn.datatables.net/1.10.16/css/jquery.dataTables.min.css\" rel=\"stylesheet\" />\n{% endblock %}\n{% block title %}{{ title }}{% endblock %}\n{% block log %}{{ title }}{% endblock %}\n{% block username %}{{ username }}{% endblock %}\n\n\n{% block mainbody %}\n<section class=\"wrapper site-min-height\">\n    <h3><i class=\"fa fa-angle-right\"></i> 查找日志 <i class=\"fa fa-desktop\"></i></h3>\n    <div class=\"row mt\">\n        <div class=\"form-panel\">\n            <div class=\"col-lg-12 row mt\">\n                <div class=\"col-sm-6\">\n                    <h4 class=\"mb\" style=\"float:left;dispaly:block;\">查找日志</h4>\n                </div>\n                <div class=\"col-sm-5 search\">\n                    <input type=\"text\" class=\"form-control\" id='contentkey' placeholder='关键内容或日志名(可填)'>\n                    <input type=\"text\" class=\"form-control\" id=\"date\">\n                    <div class=\"row\">\n                        <div class=\"col-sm-8\">\n                            <input type=\"text\" class=\"form-control\" id=\"time\" placeholder='选择时间段(必填)'>\n                        </div>\n                        <div class=\"col-sm-4\">\n                            <button type=\"button\" class=\"btn btn-theme02\" id='searchlog' style=\"float:right;\">查找日志</button>\n                        </div>\n                    </div>\n                </div>\n            </div>\n            <div>\n                <div class=\"progress progress-striped active\" style=\"display:none\" id=\"loading\">\n                    <div class=\"progress-bar\" role=\"progressbar\" aria-valuenow=\"100\" aria-valuemin=\"0\" aria-valuemax=\"100\" style=\"width: 100%\"></div>\n                </div>\n                <table id=\"logtable\" class=\"table-striped dataTable table-advance table-hover\" style=\"word-break:break-all;\">\n                    <thead>\n                        <tr>\n                            <th style=\"width:25%;\">日志时间</th>\n                            <th style=\"width:15%;\">名字</th>\n                            <th>日志内容</th>\n                        </tr>\n                    </thead>\n                    <tbody id=\"log\">\n                    </tbody>\n                </table>\n            </div>\n        </div>\n    </div>\n</section>\n{% endblock %}\n  控制这个html界面的javascript代码如下，代码中laydate组件的作用是针对图2中的蓝框中的时间选择器，它的引用在文章最简单的实践之修改服务器时间中提到过，具体的使用方法可以移步文章layDate 日期与时间组件， $('#logtable').DataTable({...})用来初始化一个定制的动态响应表格，后文中会具体说说它的使用。当用户填好内容之后点击查找日志按钮，会执行$(\"#searchlog\").click(function(){...})函数，它会依次判断日期、时间段是否已经填写，由于筛选日志时候用的是时间段，所以还会判断一下首尾时间是否相等。\n\n{% block scripts %}\n<script>\n// 获取当前的日期，在用户选择日期的时候input栏默认显示为当前日期\nvar formatDate = function (date) {  \n    var y = date.getFullYear();  \n    var m = date.getMonth() + 1;  \n    m = m < 10 ? '0' + m : m;  \n    var d = date.getDate();  \n    d = d < 10 ? ('0' + d) : d;  \n    return y + '-' + m + '-' + d;  \n};  \n\n$(document).ready(function (){\n    $('#logtable').DataTable({\n        \"scrollCollapse\": true,\n        'columnDefs':[{\n        'targets' : [0,1,2],    //除时间列以外都不排序\n        'orderable' : false\n        }],\n        \"order\": [[0 , \"asc\" ]],\n        \"oLanguage\": {\n            \"sZeroRecords\": \"无结果！\",\n            \"sSearch\": \"日志过滤：\",\n        },\n    });\n\n    laydate.render({\n        theme: 'molv',\n        elem: '#date',\n        // input栏默认当前日期\n        value: formatDate(new Date())\n    });\n    // 时间范围\n    laydate.render({\n        theme: 'molv',\n        elem: '#time',\n        type: 'time',\n        format: 'H点',\n        range: true\n    });\n});\n$(\"#searchlog\").click(function(){\n    keycontent = $(\"#contentkey\").val();\n    date = $(\"#date\").val();\n    if(date == ''){\n        swal('', '请选择日期!', 'error')\n        return ;\n    }\n    time = $(\"#time\").val();\n    if(time == ''){\n        swal('', '请填写时间段!', 'error')\n        return ;\n    }\n    // 判定首尾时间是否相等，由于是取时间段，首尾时间相等时是不允许的\n    _time = time.split(\"-\");\n    begin_time = _time[0].replace(/\\s/ig,'');\n    end_time = _time[1].replace(/\\s/ig,'');\n    if(begin_time == end_time){\n        swal('', '首位时间相等，请重新输入!', 'error')\n        return ;\n    }\n        \n    var table = $('#logtable').DataTable().clear().draw();\n    table.clear().draw();\n    $.ajax({\n        url:\"searchlog\",\n        type:'POST',\n        data:{'keycontent':keycontent, 'date':date, 'time':time},\n        success: function(arg){\n            ret = eval(arg);\n            logs = ret.logs;\n            for(j = 0,len = logs.length; j < len; j++) {\n                logtime = logs[j][0];\n                logname = logs[j][1];\n                logcontent = logs[j][2];\n                table.row.add([logtime,logname,logcontent]).draw(true);\n            }\n        }\n    });\n});\n</script>\n<script src=\"/templates/servermaterial/assets/laydate/laydate.js\"></script>\n<script src=\"https://cdn.datatables.net/1.10.16/js/jquery.dataTables.min.js\"></script>\n{% endblock %}\n  添加server/urls.py中的url函数url(r'^searchlog', views.searchlog)。  在server/views.py中添加页面渲染函数log和由url请求过来的searchlog功能函数：\n# -*- coding: utf-8 -*-\nfrom __future__ import unicode_literals\n\nfrom django.contrib.auth import logout\nfrom django.shortcuts import render_to_response\nfrom django.http import JsonResponse\nfrom django.contrib.auth.decorators import login_required\nimport json\nimport time\n\n'''以下这些函数是渲染前端模板的函数'''\n# 服务器的名字\nhtmltitle = '服务器工具'\n\n\n# 页面渲染函数\n@login_required(login_url='/loginpage')\ndef log(request):\n    username = request.session.get('username')\n    pagedict = {'title': htmltitle, 'username': username}\n    return render_to_response(\"servermaterial/log.html\", pagedict)\n    \n\n# 查找日志\ndef searchlog(request):\n    ret = {'status': False, 'logs': ''}\n    if request.method == 'POST':\n        from WebTool.functions import get_filter_log\n        # 关键内容\n        keycontent = request.POST.get('keycontent')\n        # 日志日期\n        logdate = request.POST.get('date')\n        # 日志筛选的时间段\n        logtime = request.POST.get('time')\n        filter_list = [keycontent, logdate, logtime]\n        logs = get_filter_log(filter_list)\n        ret['status'] = True\n        ret['logs'] = logs\n    return JsonResponse(ret)\n  searchlog中的get_filter_log函数是根据服务器中日志的形式单独定制的，所以在前面的文章中没有写过它的实现，下面的服务器中的日志内容中会实现一个get_filter_log函数。\n服务器中的日志内容\n服务器中日志格式\n  如图3，服务器中的日志名字规律用log-(日期)的格式存放着，每个txt日志的文档内容都形如图4所示，日志中会记录条目生成的时间，名字和内容。\n\n\nparamiko实现get_filter_log函数\n  根据日志的名字规律和格式可以单独写一个paramiko函数如下，写好的函数放在Webtool/Webtool中的functions文件中。用到了一些简单的Linux命令行。  'find /home/logs -name *' + filter_date + '*.txt'用来在日志文件夹下查找给定日期的日志文件。  | xargs cat将查找到的结果执行cat。  grep -E \\'' + filter_time + '\\' | grep -i ' + filter_content用来在cat的结果中查找符合时间段和内容的结果。  可以看出这里，查找日志的方式是使用cat一步到位的，所以对于日志内容很大的情况，需要很长一段时间，特别是还要传递到前端的datatable中显示。\n# 获得服务器的日志\ndef get_filter_log(filter_list):\n    ssh = login_server_by_pwd()\n    # 筛选日志的时期\n    filter_date = filter_list[1].replace('-', '')\n    _filter_date = filter_list[1]\n    # 筛选日志的时间\n    filter_content = filter_list[0]\n    # 筛选日志的时间范围\n    time_range = filter_list[2]\n    beg_time, end_time = re.findall(\"\\d+\", time_range)\n    beg_time = int(beg_time)\n    end_time = int(end_time)\n    if beg_time > end_time:\n        beg_time, end_time = end_time, beg_time\n    # 根据首尾时间生成每个单独时间用于日志帅选\n    time_list = [\"%02d\" % num for num in range(beg_time, end_time)]\n    filter_time = ''\n    # 可被Linux执行的命令行\n    for _time in time_list:\n        filter_time += (_filter_date + ' ' + _time + ':|')\n    filter_time = filter_time[:-1]\n    # 检查是否存在该天的日志\n    stdin, stdout, stderr = ssh.exec_command('find /home/logs -name *' + filter_date + '*.txt')\n    istxt = bool(len(stdout.read()))\n    # 如果存在改天的日志\n    if istxt:\n        # 如果有需要进一步筛选内容\n        if filter_content:\n            filter_command = 'find /home/logs -name \"*' \\\n                             + filter_date + '*.txt\" | xargs cat | grep -E \\'' \\\n                             + filter_time + '\\' | grep -i ' + filter_content\n        else:\n            filter_command = 'find /home/logs -name \"*' \\\n                             + filter_date + '*.txt\" | xargs cat | grep -E \\'' + filter_time + '\\''\n            print filter_command\n        stdin, stdout, stderr = ssh.exec_command(filter_command)\n        raw_log = stdout.read()\n        log = re.findall(\"\\[(.*?)\\]\\[(.*?)\\],({.*})\", raw_log)\n        return log\nDatatable的使用\n  关于Datatable的使用可以参考的文章很多，这里只是说下这个页面中dataatable的使用。它的javascript函数很简单，如下：\n$('#logtable').DataTable({\n    \"scrollCollapse\": true,\n    'columnDefs':[{\n        'targets' : [1,2],    // 除时间列以外都不排序，0列为时间，1列为名字，2列为内容\n        'orderable' : false\n        }],\n    \"order\": [[0 , \"asc\" ]],  // 时间列默认按升序排列\n    \"oLanguage\": {            \n         \"sZeroRecords\": \"无结果！\",   // 表格没有内容的时候显示无结果！，如图5红色框\n         \"sSearch\": \"日志过滤：\",      // 搜索栏的提示，如图5蓝色框\n    },\n});\n\n  下面的javascript代码通过ajax请求到后台之后，将后台传递上来的日志结果一个个增加到表格中，table.row.add([logtime,logname,logcontent]).draw(true)这个函数用来向datatable中增加数据。\n$.ajax({\n        url:\"searchlog\",\n        type:'POST',\n        data:{'keycontent':keycontent, 'date':date, 'time':time},\n        success: function(arg){\n            ret = eval(arg);\n            logs = ret.logs;\n            for(j = 0,len = logs.length; j < len; j++) {\n                logtime = logs[j][0];\n                logname = logs[j][1];\n                logcontent = logs[j][2];\n                table.row.add([logtime,logname,logcontent]).draw(true);\n            }\n        }\n    });\n结语\n  这里说了下怎么实现查看服务器已经存在的日志，但是这个方法本身是存在缺陷的，它只适用于比较小的日志文件的显示，大文件需要很长一段时间。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}