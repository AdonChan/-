{"title": "delorean使用教程 - 捕蛇者说 ", "index": "日期转换,python", "content": "首先，约定三个概念。\n\nnavie datetime:没有指定时区的datetime对象\nlocalized datetime:指定时区的datetime对象\nlocalizing:指定市区的的navie datetime\nnormalizing:datetime时区切换\n\n一些例子\n首先，导入Delorean\n*>>> from delorean import Delorean\n\n使用UTC格式的当前时间创建一个datetime\n\n*>>> d = Delorean()\n*>>> d\nDelorean(datetime=datetime.datetime(2013, 1, 12, 6, 10, 33, 110674),  timezone='UTC')\n\n简单的时区切换\n*>>> d = d.shift('US/Eastern')\n*>>> d\nDelorean(datetime=datetime.datetime(2013, 1, 12, 1, 10, 38, 102223), timezone='US/Eastern')\n\n转换成datetime看看\n*>>> d.datetime\ndatetime.datetime(2013, 1, 12, 01, 10, 38, 102223, tzinfo=<DstTzInfo 'US/Eastern' EST-1 day, 19:00:00 STD>)\n*>>> d.date\ndatetime.date(2013, 1, 12)\n\n单纯的输入时间看看\n\n*>>> d.naive()\ndatetime.datetime(2013, 1, 12, 1, 10, 38, 102223)\n*>>> d.epoch()\n1357971038.102223\n\n也是用unix时间戳初始化Delorean\n\n*>>> from delorean import epoch\n*>>> epoch(1357971038.102223).shift(\"US/Eastern\")\nDelorean(datetime=datetime.datetime(2013, 1, 12, 1, 10, 38, 102223), timezone='US/Eastern')\n\n初始化后，就可以方便的切换到自己所需的时区Delorean也可以使用指定的datetime对象进行初始化，Delorean会自动处理时区和时间\n*>>> tz = timezone(\"US/Pacific\")\n*>>> dt = tz.localize(datetime.utcnow())\ndatetime.datetime(2013, 3, 16, 5, 28, 11, 536818, tzinfo=<DstTzInfo 'US/Pacific' PDT-1 day, 17:00:00 DST>)\n*>>> d = Delorean(datetime=dt)\n*>>> d\nDelorean(datetime=datetime.datetime(2013, 3, 16, 5, 28, 11, 536818), timezone='US/Pacific')\n*>>> d = Delorean(datetime=dt, timezone=\"US/Eastern\")\n*>>> d\nDelorean(datetime=datetime.datetime(2013, 3, 16, 5, 28, 11, 536818), timezone='US/Pacific')\n\nDelorean支持timedelta的时间加减法。Delorean可以使用timedelta进行加减，得到一个Delorean对象\n\n*>>> d = Delorean()\n*>>> d\nDelorean(datetime=datetime.datetime(2014, 6, 3, 19, 22, 59, 289779), timezone='UTC')\n*>>> d += timedelta(hours=2)\n*>>> d\nDelorean(datetime=datetime.datetime(2014, 6, 3, 21, 22, 59, 289779), timezone='UTC')\n*>>> d - timedelta(hours=2)\nDelorean(datetime=datetime.datetime(2014, 6, 3, 19, 22, 59, 289779), timezone='UTC')\n*>>> d2 = d + timedelta(hours=2)\n*>>> d2 - d\ndatetime.timedelta(0, 7200)\n\nDelorean也支持两个时间比较\n*>>> d1 = Delorean(datetime(2015, 1, 1), timezone='US/Pacific')\n*>>> d2 = Delorean(datetime(2015, 1, 1, 8), timezone='UTC')\n*>>> d1 == d2\nTrue\n\nDelorean提供多种方法获取一个指定的时间，如明年或者下周三Delorean提供了一些方便的方法进行如上操作。\n*>>> d = Delorean()\n*>>> d\nDelorean(datetime=datetime.datetime(2013, 1, 20, 19, 41, 6, 207481), timezone='UTC')\n*>>> d.next_tuesday()\nDelorean(datetime=datetime.datetime(2013, 1, 22, 19, 41, 6, 207481), timezone='UTC')\n\n上周二、过去第二个周二午夜\n*>>> d.last_tuesday()\nDelorean(datetime=datetime.datetime(2013, 1, 15, 19, 41, 6, 207481), timezone='UTC')\n*>>> d.last_tuesday(2).midnight()\ndatetime.datetime(2013, 1, 8, 0, 0, tzinfo=<UTC>)\n\n过滤\n通常情况下我们不关心有多少微妙或者多少秒。例如，我们很难区别同一分钟的两个datetime对象。我们补习吧不关心的字段设置为0。Delorean提供了很方便的方法按照微妙、秒、分钟、小时进行过滤\n*>>> d = Delorean()\n*>>> d\nDelorean(datetime=datetime.datetime(2013, 1, 21, 3, 34, 30, 418069), timezone='UTC')\n*>>> d.truncate('second')\nDelorean(datetime=datetime.datetime(2013, 1, 21, 3, 34, 30), timezone='UTC')\n*>>> d.truncate('hour')\nDelorean(datetime=datetime.datetime(2013, 1, 21, 3, 0), timezone='UTC')\n\n同样，也支持按照年、月份\n*>>> d = Delorean(datetime=datetime(2012, 5, 15, 03, 50, 00, 555555), timezone=\"US/Eastern\")\n*>>> d\nDelorean(datetime=datetime.datetime(2012, 5, 15, 3, 50, 0, 555555), timezone='US/Eastern')\n*>>> d.truncate('month')\nDelorean(datetime=datetime.datetime(2012, 5, 1), timezone='US/Eastern')\n*>>> d.truncate('year')\nDelorean(datetime=datetime.datetime(2012, 1, 1), timezone='US/Eastern')\n字符串处理\n另一个麻烦事是处理datetime格式的字符串。Delorean可以很方便的处理\n*>>> from delorean import parse\n*>>> parse(\"2011/01/01 00:00:00 -0700\")\nDelorean(datetime=datetime.datetime(2011, 1, 1, 7), timezone='UTC')    \n歧义字段的处理\nDelorean提供了两个字段dayfirst=True and yearfirst=True用来处理相应格式的字符串，如果dayfirst和yearfirst是True\n\nYY-MM-DD\nDD-MM-YY\n\n\n\nMM-DD-YY\n默认情况下，对于May 6th, 2013格式，Delorean返回‘2013-05-06\n*>>> parse(\"2013-05-06\")   Delorean(datetime=datetime.datetime(2013, 5, 6), timezone='UTC')\ndayfirst和yearfirst的配置如下：\n\n\n如果dayfirst是False，yearfirst是False\n\nMM-DD-YY\nDD-MM-YY\nYY-MM-DD\n\n\n\n如果dayfirst是True，yearfirst是False\n\nDD-MM-YY\nMM-DD-YY\nYY-MM-DD\n\n\n\n如果dayfirst是False，yearfirst是True\n\nYY-MM-DD\nMM-DD-YY\nDD-MM-YY\n\n\n\n时间步进\n*>>> import delorean\n*>>> from delorean import stops\n*>>> for stop in stops(freq=delorean.HOURLY, count=10):    print stop\n...\nDelorean(datetime=datetime.datetime(2013, 1, 21, 6, 25, 33), timezone='UTC')\nDelorean(datetime=datetime.datetime(2013, 1, 21, 7, 25, 33), timezone='UTC')\nDelorean(datetime=datetime.datetime(2013, 1, 21, 8, 25, 33), timezone='UTC')\nDelorean(datetime=datetime.datetime(2013, 1, 21, 9, 25, 33), timezone='UTC')\nDelorean(datetime=datetime.datetime(2013, 1, 21, 10, 25, 33), timezone='UTC')\nDelorean(datetime=datetime.datetime(2013, 1, 21, 11, 25, 33), timezone='UTC')\nDelorean(datetime=datetime.datetime(2013, 1, 21, 12, 25, 33), timezone='UTC')\nDelorean(datetime=datetime.datetime(2013, 1, 21, 13, 25, 33), timezone='UTC')\nDelorean(datetime=datetime.datetime(2013, 1, 21, 14, 25, 33), timezone='UTC')\nDelorean(datetime=datetime.datetime(2013, 1, 21, 15, 25, 33), timezone='UTC')\n注意：stops只接受naive datetime    可以指定开始和结束的时间\n*>>> for stop in stops(freq=delorean.DAILY, count=10, timezone=\"US/Eastern\", start=d1, stop=d2):    print stop\n...\nDelorean(datetime=datetime.datetime(2012, 5, 6), timezone='US/Eastern')\nDelorean(datetime=datetime.datetime(2012, 5, 7), timezone='US/Eastern')\nDelorean(datetime=datetime.datetime(2012, 5, 8), timezone='US/Eastern')\nDelorean(datetime=datetime.datetime(2012, 5, 9), timezone='US/Eastern')\nDelorean(datetime=datetime.datetime(2012, 5, 10), timezone='US/Eastern')\nDelorean(datetime=datetime.datetime(2012, 5, 11), timezone='US/Eastern')\nDelorean(datetime=datetime.datetime(2012, 5, 12), timezone='US/Eastern')\nDelorean(datetime=datetime.datetime(2012, 5, 13), timezone='US/Eastern')\nDelorean(datetime=datetime.datetime(2012, 5, 14), timezone='US/Eastern')\nDelorean(datetime=datetime.datetime(2012, 5, 15), timezone='US/Eastern')\n\n只指定结束时间是不行的\n\n*>>> for stop in stops(freq=delorean.DAILY, timezone=\"US/Eastern\", stop=d2):    print stop\n...\nTraceback (most recent call last):\n    File \"<stdin>\", line 1, in <module\n    File \"delorean/interface.py\", line 63, in stops\n      bysecond=None, until=until, dtstart=start):\nTypeError: can't compare offset-naive and offset-aware datetimes\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}