{"title": "django开发-聚合函数的使用 - wyzane ", "index": "python,django", "content": "在django开发中，获取一些统计数据时，需要用到model中的聚合函数；下面就聊一下django中跟统计、聚合有关的方法。\n1.aggregate: 对QuerySet进行汇总后得到的数据1)求所有订单的平均消费:\nfrom django.db.models import Avg, Count\navg_price = OrderModel.objects.all().aggregate(Avg('total_price'))\n给结果指定别名:{'hehe': 12.00}\navg_price = OrderModel.objects.all().aggregate(hehe=Avg('total_price'))\n2)求订单的最大消费，和平均消费\navg_max_price = OrderModel.objects.all().aggregate(Avg('total_price'), Max('total_price'))\n3)统计某菜品在所有评价中的点赞数量，order时订单号\norder_evaluation = OrderEvaluationModel.objects.filter(food=food_code).filter(is_good=1).aggregate(count=Count(\"order\"))\n4)统计菜品的月销量，此处使用到了extra，extra下面会讲到\nday_now = time.localtime()   # 当前时间\nmonth_first = '%d-%02d-01' % (day_now.tm_year, day_now.tm_mon)  # 月初\nlogger.debug(\"month_first:%s\", month_first)\nmonth_sales = OrderDetailModel.objects.filter(food=food_code).extra(where=[\"time > %s\"], params=[month_first]).aggregate(count=Count(\"order\", distinct=True))\n2.annotate: 给返回的记录添加一个额外的临时字段(不好理解，看下面的具体例子)1）第一个annotate:\norders = OrderDetailModel.objects.annotate(Count(\"order\"))\nannotate这个函数不是太好理解，使用logger.debug(orders.query)打印出的sql语句如下:\nSELECT `orders_detail`.`id`, `orders_detail`.`order_id`, `orders_detail`.`user`, `orders_detail`.`payman`, `orders_detail`.`food_id`, `orders_detail`.`name`, `orders_detail`.`type`, `orders_detail`.`price`, `orders_detail`.`machine`, `orders_detail`.`amount`, `orders_detail`.`time`, COUNT(`orders_detail`.`order_id`) AS `order__count` FROM `orders_detail` GROUP BY `orders_detail`.`id` ORDER BY NULL\n从上面的sql语句可以看出上一个查询的意思是以orders_detail.id分组，统计orders_detail.order_id的数量, 其他字段不变，增加了COUNT(orders_detail.order_id) AS order__count这一列。\n2)再看一个annotate:\norders = OrderDetailModel.objects.values(\"food\").annotate(Count(\"order\"))\n打印的sql语句如下:\nSELECT `orders_detail`.`food_id`, COUNT(`orders_detail`.`order_id`) AS `order__count` FROM `orders_detail` GROUP BY `orders_detail`.`food_id` ORDER BY NULL\n看着sql语句我们就很好理解了，就是以values中指定的字段分组，统计order_id的数量。再结合上一个例子看，如果没有使用values()函数，则便是按照所有字段分组，统计Count()中指定字段的数量。\n3）统计每个用户的平均消费:\norders = OrderModel.objects.values(\"user\").annotate(Avg(\"total_price\"))\nsql语句如下:\nSELECT `orders_info`.`user_id`, AVG(`orders_info`.`total_price`) AS `total_price__avg` FROM `orders_info` GROUP BY `orders_info`.`user_id` ORDER BY NULL\n4）统计每个用户的平均消费，并排序\norders = OrderModel.objects.values(\"user\").annotate(avg_price=Avg(\"total_price\")).order_by(\"avg_price\")\nsql语句如下:\nSELECT `orders_info`.`user_id`, AVG(`orders_info`.`total_price`) AS `avg_price` FROM `orders_info` GROUP BY `orders_info`.`user_id` ORDER BY `avg_price` ASC\navg_price就是给统计字段起的别名\n5）annotate后面还可以加filter等过滤函数，如下:\norders = OrderModel.objects.values(\"user\").annotate(avg_price=Avg(\"total_price\")).filter(avg_price__gt=100).order_by(\"avg_price\")\nsql语句如下:\nSELECT `orders_info`.`user_id`, AVG(`orders_info`.`total_price`) AS `avg_price` FROM `orders_info` GROUP BY `orders_info`.`user_id` HAVING AVG(`orders_info`.`total_price`) > 100.0 ORDER BY `avg_price` ASC\n加在annotate后面的filter函数实际上是HAVING子句，即分组后需要执行的条件。\n当然，annotate中还可以执行Max()等其它聚合函数。\n3.extra: 主要作用是可以用来写原生的sql语句，当遇到复杂的查询时，可以使用这个方法下面看几个例子:1）查询订单金额小于100元的订单信息:\nOrderModel.objects.all().extra(where=[\"total_price < 100\"])\nsql语句如下:\nSELECT `orders_info`.`order_id`, `orders_info`.`total_price`, `orders_info`.`method`, `orders_info`.`remark`, `orders_info`.`time` FROM `orders_info` WHERE (total_price < 100)\n2）where查询\nOrderModel.objects.all().extra(where=[\"status = '%s'\"], params=['os001'])\nsql如下:\nSELECT `orders_info`.`order_id`, `orders_info`.`user_id`, `orders_info`.`status` FROM `orders_info` WHERE (status = 'os001')\nwhere参数中可以先用%s占位，后面再用params参数去填充。\n3）关联查询\nOrderModel.objects.all().extra(tables=[\"order_progress\"], where=[\"orders_info.status = order_progress.order_status\"])\nsql如下:\n SELECT `orders_info`.`order_id`, `orders_info`.`user_id`, `orders_info`.`status`, `orders_info`.`total_price`, \n`orders_info`.`remark`, `orders_info`.`time` \n FROM `orders_info` , `order_progress` WHERE (orders_info.status = order_progress.order_status)\n这种就是数据库中的inner join关联查询。\n以上就是django中一些统计函数的用法，如有错误，欢迎交流指正！\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}