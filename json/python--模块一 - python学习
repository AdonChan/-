{"title": "python--模块一 - python学习 ", "index": "python", "content": "常用模块\ncollections模块\n在内置数据类型（dict、list、set、tuple）的基础上，collections模块还提供了几个额外的数据类型：Counter、deque、defaultdict、namedtuple和OrderedDict等。\n1.namedtuple: 生成可以使用名字来访问元素内容的tuple\n2.deque: 双端队列，可以快速的从另外一侧追加和推出对象\n3.Counter: 计数器，主要用来计数\n4.OrderedDict: 有序字典\n5.defaultdict: 带有默认值的字典\n1.namedtuple\n- tuple可以表示不变集合，例如，一个点的二维坐标就可以表示成：\np = (1,2)\n- 看不出来1,2用来表示坐标，用namedtuple实现方法\nfrom collections import namedtuple\nPoint = namedtuple('Point',[\"x\",\"y\"])\np = Point(1,2)\nprint(p.x)\nprint(p.y)\n- 定义方式：namedtuple('名称', [属性list])\n2.deque\n使用list存储数据时，按索引访问元素很快，但是插入和删除元素就很慢了，因为list是线性存储，数据量大的时候，插入和删除效率很低。deque是为了高效实现插入和删除操作的双向列表，适合用于队列和栈：\nfrom collections import deque\nq = deque([\"a\",\"b\",\"c\"])\nq.append(\"x\")\nq.appendleft(\"y\")\nprint(q)\n#deque(['y', 'a', 'b', 'c', 'x'])\ndeque除了实现list的append()和pop()外，还支持appendleft()和popleft()，这样就可以非常高效地往头部添加或删除元素。\n3.defaultdict\n有如下值集合 [11,22,33,44,55,66,77,88,99,90...]，将所有大于 66 的值保存至字典的第一个key中，将小于 66 的值保存至第二个key的值中。即： {'k1': 大于66 , 'k2': 小于66}\ndic = {\"k1\":[],\"k2\":[]}\nl1 = [11,22,33,44,55,66,77,88,99,90]\nfor number in l1:\n    if number > 66:\n        dic[\"k1\"].append(number)\n    elif number < 66:\n        dic[\"k2\"].append(number)\nprint(dic)\n#普通字典需要先定义好一个字典，字典必须有k1,k2的key值\n使用dict时，如果引用的Key不存在，就会抛出KeyError。如果希望key不存在时，返回一个默认值，就可以用defaultdict：\nfrom collections import defaultdict\nl1 = [11,22,33,44,55,66,77,88,99,90]\ndic = defaultdict(list)\nfor number in l1:\n    if number > 66:\n        dic[\"k1\"].append(number)\n    elif number < 66:\n        dic[\"k2\"].append(number)\n    elif number == 66:\n        dic[\"k3\"].append(number)\nprint(dic)\ntime模块\n1.常用方法：\n1.time.sleep(secs)\n(线程)推迟指定的时间运行。单位为秒\n2.time.time()\n获取当前时间戳\n2.表示时间的三种方式:\n1.时间戳(timestamp) ：通常来说，时间戳表示的是从1970年1月1日00:00:00开始按秒计算的偏移量。我们运行“type(time.time())”，返回的是float类型。\n2.格式化的时间字符串(Format String)： ‘1999-12-06’\n%y 两位数的年份表示（00-99）\n%Y 四位数的年份表示（000-9999）\n%m 月份（01-12）\n%d 月内中的一天（0-31）\n%H 24小时制小时数（0-23）\n%I 12小时制小时数（01-12）\n%M 分钟数（00=59）\n%S 秒（00-59）\n%a 本地简化星期名称\n%A 本地完整星期名称\n%b 本地简化的月份名称\n%B 本地完整的月份名称\n%c 本地相应的日期表示和时间表示\n%j 年内的一天（001-366）\n%p 本地A.M.或P.M.的等价符\n%U 一年中的星期数（00-53）星期天为星期的开始\n%w 星期（0-6），星期天为星期的开始\n%W 一年中的星期数（00-53）星期一为星期的开始\n%x 本地相应的日期表示\n%X 本地相应的时间表示\n%Z 当前时区的名称\n%% %号本身\n3.struct_time) ：struct_time元组共有9个元素共九个元素:(年，月，日，时，分，秒，一年中第几周，一年中第几天等）\nimport time\n#时间戳\nprint(time.time())\n#字符串时间\nprint(time.strftime(\"%Y-%m-%d %H:%M:%S\"))\n#时间元组：localtime将一个时间戳转换为当前时区的struct_time\nprint(time.localtime())\n#打印结果：\n1530693574.325\n2018-07-04 16:39:34\ntime.struct_time(tm_year=2018, tm_mon=7, tm_mday=4, tm_hour=16, tm_min=39, tm_sec=34, tm_wday=2, tm_yday=185, tm_isdst=0)\n总结：时间戳是计算机能够识别的时间；时间字符串是人能够看懂的时间；元组则是用来操作时间的时间格式的转化：\n\n#1.时间戳转结构化时间\nimport time\nprint(time.gmtime()) #UTC时间，与英国伦敦当地时间一致\nprint(time.localtime()) #当地时间。例如我们现在在北京执行这个方法：与UTC时间相差8小时，UTC时间+8小时 = 北京时间\n\n#2.结构化时间转时间戳\n#获取本地时间的结构化时间\ntime_tuple = time.localtime()\nprint(time_tuple)\n#将结构化时间转化为时间戳\nprint(time.mktime(time_tuple))\n\n#3.结构化时间转字符串时间\n#time.strftime(\"格式定义\",\"结构化时间\")  结构化时间参数若不传，则现实当前时间\nprint(time.strftime(\"%y-%m-%d %H:%M:%S\"))\nprint(time.strftime(\"%Y-%m-%d\",time.localtime()))\n\n#4.字符串时间转结构化时间\n#time.strptime(时间字符串,字符串对应格式)\nprint(time.strptime(\"2018-07-04\",\"%Y-%m-%d\"))\n#time.struct_time(tm_year=2018, tm_mon=7, tm_mday=4, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=2, tm_yday=185, tm_isdst=-1)\n计算时间差：\nimport time\ntrue_time=time.mktime(time.strptime('2017-09-11 08:30:00','%Y-%m-%d %H:%M:%S'))\ntime_now=time.mktime(time.strptime('2017-09-12 11:00:00','%Y-%m-%d %H:%M:%S'))\ndif_time=time_now-true_time\nstruct_time=time.gmtime(dif_time)\nprint('过去了%d年%d月%d天%d小时%d分钟%d秒'%(struct_time.tm_year-1970,struct_time.tm_mon-1,\n                                       struct_time.tm_mday-1,struct_time.tm_hour,\n                                       struct_time.tm_min,struct_time.tm_sec))\nrandom模块\n1.随机小数\nimport random\nprint(random.random()) #大于0且小于一的小数\nprint(random.uniform(1,3))  #大于1且小于3的小数\n2.随机整数\nimport random\nprint(random.randint(1,3)) #>=1且<=3的随机整数\nprint(random.randrange(1,10,2)) #大于等于1且小于10之间的奇数\n3.随机返回\nimport random\nprint(random.choice([1,2,3,4,5,[6,7]])) #在列表中随机选择一个元素返回\nprint(random.sample([1,2,3,4,5,6],3)) #列表内任意3个组合\n4.打乱列表顺序\nimport random\nl1 = [1,2,3,4,5]\nprint(random.shuffle(l1))\nprint(l1)\n生成随机验证码：\ndef random_number(numer,alpath=True):\n    \"\"\"\n    :param numer: 生成几位\n    :param alpath: 默认包括数字\n    :return:\n    \"\"\"\n    code = \"\"\n    for i in range(numer):\n        choice = random.randint(0,9)\n        if alpath:\n            number2 = chr(random.randint(65,90)) #大写\n            number3 = chr(random.randint(97,122)) #小写\n            choice = random.choice([choice,number2,number3])\n            print(choice)\n        code += str(choice)\n    return code\nos模块\nos模块是一个于操作系统交互的一个接口\nimport os\nos.getcwd()           #获取当前的工作目录当前的工作目录\nos.chdir(\"E:\\python\\day08\") #改变脚本工作目录，相当于shell下的cd\nos.curdir             #返回当前目录  .\nos.pardir             #返回到父集目录 ..\nos.makedirs(\"linux\\go\") #递归创建目录，相当于shell的mkdir -p\nos.removedirs(\"linux\\go\") #若目录为空则删除，并递归到上一层目录，如果上一次目录也为空，也删除。依次类推\nos.mkdir(\"python\")  #生成单级目录，相当于shell中的mkdir path\nos.rmdir(\"python\")   #删除单级空目录，不为空则无法删除\nprint(os.listdir(\"E:\\python\\day08\")) #列出指定目录下的所有文件和目录，包括隐藏文件，以列表的方式打印\nos.remove(\"1.py\") #删除某个文件\nos.rename(\"day08.zip\",\"day8.zip\")  #重命名目录/文件\nos.stat(\"README\") #获取文件/目录信息，以一个元组的方式返回，可以按照索引取值\nos.sep #在pycharm中打印的结果是：/,在windows解释器是：//,linux下为：/\nprint(os.name) #输出当前使用平台，win=“nt”，linux=“posix”\nos.system(\"bash commond\") #运行shell命令\nos.popen(\"bash commond\").read() #运行shell命令，获取执行结果\nprint(os.environ) #获取系统变量\nos.path.abspath(path) #返回path规范化的绝对路径 os.path.split(path) 将path分割成目录和文件名二元组返回\nos.path.dirname(path) #返回path的目录。其实就是os.path.split(path)的第一个元素 os.path.basename(path) 返回path最后的文件名。如何path以／或\\结尾，那么就会返回空值。即os.path.split(path)的第二个元素\nprint(os.path.exists(\"E:\\python\")) #判断目录/文件是否存在，存在返回True，反之false\nprint(os.path.isabs(\"E:\\python\")) #如果path是绝对路径返回true，反之false\nprint(os.path.isfile(\"Calculator.py\")) #判断文件是否存在，存在true，反之false\nprint(os.path.isdir(\"python\"))  #判断目录是否存在，存在true，反之false\nos.path.getatime(\"E:\\python\\day08\")  #返回path所指向的文件或者目录的最后访问时间戳\nos.path.getmtime(\"E:\\python\\day08\")  #返回path所指向的文件或者目录的最后修改时间戳\nos.path.getsize(\"E:\\python\\day08\") #返回path的大小\nsys模块\nsys模块是一个与python解释器交互的模块\nimport sys\nprint(sys.argv) #命令行参数list，返回的是程序本身的路径\nsys.exit(n)   #退出程序，正常退出是exit(0),错误退出是exit(1)\nprint(sys.version) #返回python解释器的版本信息\nprint(sys.path) #返回模块的搜索路径\nprint(sys.platform) #返回操作平台名称\nre模块\n正则：1.字符组 ： [字符组]\n- 在同一个位置可能出现的各种字符组成了一个字符组，在正则表达式中用[]表示\n- 字符分为很多类，比如数字、字母、标点等等。\n- 假如你现在要求一个位置\"只能出现一个数字\",那么这个位置上的字符只能是0、1、2...9这10个数之一。\n\n\n2.字符：\n\n3.量词：\n\n\n\n注意：前面的*,+,?等都是贪婪匹配，也就是尽可能匹配，后面加?号使其变成惰性匹配\n4.字符集：\n\n5.分组 ()与 或 ｜［^］身份证号码是一个长度为15或18个字符的字符串，如果是15位则全部🈶️数字组成，首位不能为0；如果是18位，则前17位全部是数字，末位可能是数字或x，下面我们尝试用正则来表示：\n\n6.转义符 \\python中，无论是正则表达式，还是待匹配的内容，都是以字符串的形式出现的，在字符串中也有特殊的含义，本身还需要转义。所以如果匹配一次\"d\",字符串中要写成'\\d'，那么正则里就要写成\"\\\\d\",这样就太麻烦了。这个时候我们就用到了r'd'这个概念，此时的正则是r'\\d'就可以了。\n\n7.贪婪匹配贪婪匹配：在满足匹配时，匹配尽可能长的字符串，默认情况下，采用贪婪匹配\n\n常用的：\n*? 重复任意次，但尽可能少重复\n+? 重复1次或更多次，但尽可能少重复\n?? 重复0次或1次，但尽可能少重复\n{n,m}? 重复n到m次，但尽可能少重复\n{n,}? 重复n次以上，但尽可能少重复\nre模块常用用法:\nimport re\n\nret = re.findall('a', 'eva egon yuan')  # 返回所有满足匹配条件的结果,放在列表里\nprint(ret) #结果 : ['a', 'a']\n\nret = re.search('a', 'eva egon yuan').group()\nprint(ret) #结果 : 'a'\n# 函数会在字符串内查找模式匹配,只到找到第一个匹配然后返回一个包含匹配信息的对象,该对象可以\n# 通过调用group()方法得到匹配的字符串,如果字符串没有匹配，则返回None。\n\nret = re.match('a', 'abc').group()  # 同search,不过尽在字符串开始处进行匹配\nprint(ret)\n#结果 : 'a'\n\nret = re.split('[ab]', 'abcd')  # 先按'a'分割得到''和'bcd',在对''和'bcd'分别按'b'分割\nprint(ret)  # ['', '', 'cd']\n\nret = re.sub('\\d', 'H', 'eva3egon4yuan4', 1)#将数字替换成'H'，参数1表示只替换1个\nprint(ret) #evaHegon4yuan4\n\nret = re.subn('\\d', 'H', 'eva3egon4yuan4')#将数字替换成'H'，返回元组(替换的结果,替换了多少次)\nprint(ret)\n\nobj = re.compile('\\d{3}')  #将正则表达式编译成为一个 正则表达式对象，规则要匹配的是3个数字\nret = obj.search('abc123eeee') #正则表达式对象调用search，参数为待匹配的字符串\nprint(ret.group())  #结果 ： 123\n\nimport re\nret = re.finditer('\\d', 'ds3sy4784a')   #finditer返回一个存放匹配结果的迭代器\nprint(ret)  # <callable_iterator object at 0x10195f940>\nprint(next(ret).group())  #查看第一个结果\nprint(next(ret).group())  #查看第二个结果\nprint([i.group() for i in ret])  #查看剩余的左右结果\nfindall优先级查询\nimport re\n\nret = re.findall('www.(baidu|wangyi).com', 'www.wangyi.com')\nprint(ret)  # ['wangyi']     这是因为findall会优先把匹配结果组里内容返回,如果想要匹配结果,取消权限可\nret = re.findall('www.(?:baidu|wangyi).com', 'www.oldboy.com')\nprint(ret)  # ['www.wangyi.com']\nsplit的优先级查询\nret=re.split(\"\\d+\",\"eva3egon4yuan\")\nprint(ret) #结果 ： ['eva', 'egon', 'yuan']\n\nret=re.split(\"(\\d+)\",\"eva3egon4yuan\")\nprint(ret) #结果 ： ['eva', '3', 'egon', '4', 'yuan']\n\n#在匹配部分加上（）之后所切出的结果是不同的，\n#没有（）的没有保留所匹配的项，但是有（）的却能够保留了匹配的项，\n#这个在某些需要保留匹配部分的使用过程是非常重要的。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "0"}