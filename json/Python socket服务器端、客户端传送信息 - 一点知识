{"title": "Python socket服务器端、客户端传送信息 - 一点知识 ", "index": "linux,python", "content": "问题\n在windows环境主机A上想每隔15分钟获取远程Linux主机B上定时监控的logFile文件，但通过在A主机上：telnet B'ip port (例：telnet 158.123.12.1 21)查看远程主机没开放21、22端口，好像不能使用ftp或者sftp来获取（应该是不可以吧）。想自己写个简单服务器实现：1、服务器端能够正确读取logFile内容2、客户端访问时，服务器端能够返回logFile的内容2、客户端能够正确获取logFile内容并写入本地文件中\n解决\n使用Python的socket模块，自己新增一个可以直接访问的PORT。为了保证数据准确性，使用比较简单的方法：客户端与服务器端通过TCP方式通信。服务器端先启动后，循环等待客户端访问。由于是单个客户端每隔15分钟访问，每完成一次访问便断开连接，所以采用了单线程阻塞的方法实现的服务器端：\n远程Linux主机B 服务器端代码：\n    #coding=utf-8\n    #!/usr/bin/python\n    \n    from socket import *\n    \n    HOST = '158.123.12.1'\n    PORT = 8083\n    BUFSIZE = 65535\n    ADDR = (HOST, PORT)\n    \n    tcpSerSock = socket(AF_INET, SOCK_STREAM)\n    tcpSerSock.bind(ADDR)\n    tcpSerSock.listen(5)\n    \n    welcomeStr = 'Welcome to 12.1 python socket server'\n    \n    def logFileRead(logFile):\n        '''\n        Read logFile by line\n        return List\n        '''\n        logFileDealList = []\n        with open(logFile, 'r') as logFileContent:\n            for line in logFileContent.readlines():\n                logFileDealList.append(line)\n        return logFileDealList\n    \n    if __name__ == \"__main__\":\n        fileDir = 'filePath/warningMessage.txt'\n    \n        while True:\n            print 'Enter 12.1 python socket server'\n            tcpCliSock, addr = tcpSerSock.accept()\n            print 'Connected from : ', addr\n            data = tcpCliSock.recv(BUFSIZE)\n    \n            if not data:\n                break\n            print data\n            logFileContentList = logFileRead(fileDir)\n            # print logFileContentList\n            for fileContent in logFileContentList:\n                if fileContent.find('pending') == -1:\n                    continue\n                tcpCliSock.send('%s' % fileContent)\n            tcpCliSock.close()\n    \n        tcpSerSock.close()\n\n\nADDR 中PORT为int类型，要选取不冲突的PORT，在Linux上可以通过netstat -anp | grep PORT'id 例：netstat -anp | grep 8083，查看端口号占用情况。\n\nsocket(AF_INET, SOCK_STREAM)：使用HOST+PORT时，要使用AF_INET网络协议搜索主机（也可以使用 TCP 和本地[非网络的 AF_LOCAL/AF_UNIX]套接字，但是很明显此时并没有使用 IP）；使用TCP方式时，要使用SOCK_STREAM基于流套接字（创建 UDP 套接字，必须使用SOCK_DGRAM作为套接字类型）。\n\nbind(ADDR)：将地址（主机名、端口号对）绑定到套接字上\n\nlisten(5)：设置并启动TCP监听器，参数5是在连接被转接或拒绝之前，传入连接请求的最大数连接队列最大值。如果Client端请求超过5个，Linux中Server会延迟到连接数低于5时响应连接。未测试过，具体处理流程可以参考：TCP握手与socket通信细节。由于当前只有一个Client客户端，所以5足够使用。\n\ndef logFileRead(logFile)：读取文件的function\n\naccept()：被动接受TCP客户端连接，持续等待直到连接到达（阻塞等待）\n\ntcpCliSock.recv(BUFSIZE)：接收TCP消息，BUFSIZE定义的为缓冲区大小。接收的是Client端传送过来的消息。\n\ntcpCliSock.send('%s' % fileContent)：发送TCP消息，将结果返回给Client段\n\ntcpCliSock.close()：关闭客户端连接\n\ntcpSerSock.close()：退出服务器端\n执行时，可以将Server端挂载到后台不退出\n\n本地Windows主机A 客户端代码：\n    #coding=utf-8\n    #!/usr/bin/python\n    \n    from socket import *\n    \n    HOST = '158.123.12.1'\n    PORT = 8083\n    BUFSIZE = 65535\n    ADDR = (HOST, PORT)\n    \n    welcomeStr = 'Welcome to 12.1 python socket server'\n    \n    def fileWrite(record, fileName):\n         with open(fileName, 'w') as logFile:\n            for recordItem in record:\n                logFile.write(recordItem)\n    \n    def main():\n        tcpCliSock = socket(AF_INET, SOCK_STREAM)\n        tcpCliSock.connect(ADDR)\n        fileDir = 'filePath/warnLogFile.txt'\n        print 'Will connect 12.1 python socket server'\n        data = 'hello'\n        tcpCliSock.send(data)\n    \n        retDataAll = ''\n    \n        while True:\n            retDataTmp = tcpCliSock.recv(BUFSIZE)\n            if not retDataTmp:\n                break\n            if not len(retDataTmp):\n                break\n            print retDataTmp\n            retDataAll = retDataAll + retDataTmp\n        print 'end '\n        tcpCliSock.close()\n        fileWrite(retDataAll, fileDir)\n    \n    if __name__ == '__main__':\n        main()\n\n\n\nADDR = (HOST, PORT)：与Server端HOST、PROT相同\n\ndef fileWrite(record, fileName)：覆盖写入文件，注意如果该文件不存在会报错\n\ntcpCliSock.send(data)：发送消息给服务器端\n\ntcpCliSock.recv(BUFSIZE)：注意接收服务器端返回消息时，有可能超过BUFSIZE或者超过了MTU等限制，单次获取的记录不完整。所以使用TCP协议时，通过循环判断是否存在待接收消息，直到无消息时才断开连接\n\n参考文章\nPython核心编程(第3版)TCP握手与socket通信细节Python中使用socket发送HTTP请求数据接收不完整问题解决方法\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "3"}