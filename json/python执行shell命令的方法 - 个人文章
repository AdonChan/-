{"title": "python执行shell命令的方法 - 个人文章 ", "index": "linux,python", "content": "python执行shell命令的方法\nos模块\n\nos.system方式：\nimport os\nos.system('top')\nos.system('cat /proc/cpuinfo')\n说明\n这个调用相当直接，且是同步进行的，程序需要阻塞并等待返回。返回值是依赖于系统的，直接返回系统的调用返回值，所以windows和linux是不一样的。强调的一点是，不支持参数，不支持管道\n\nos.open方式：\nimport os\noutput = os.popen('df')\nprint output.read()   #如果命令自身无报错，则返回正确的值\n说明\npopen方法通过p.read()获取终端输出，而且popen需要关闭close().当执行成功时，close()不返回任何值，失败时，close()返回系统返回值..可见它获取返回值的方式和os.system不同强调的一点是，不支持参数，不支持管道\ncommands模块\n使用commands模块的getoutput方法，这种方法同popend的区别在于popen返回的是一个文件句柄，而本方法将外部程序的输出结果当作字符串返回，很多情况下用起来要更方便些。主要方法:\n\ncommands.getstatusoutput(cmd)         返回(status, output)\ncommands.getoutput(cmd)               只返回输出结果\ncommands.getstatus(file)              返回ls -ld file的执行结果字符串，调用了getoutput，不建议使用此方法\n\na = commands.getoutput('ps -ef ')\nb = commands.getstatusoutput('vmstat') \nsubprocess模块\n说明\n使用subprocess模块能够创建新的进程。能够与新建进程的输入/输出/错误管道连通。并能够获得新建进程运行的返回状态。使用subprocess模块的目的是替代os.system()、os.popen()、commands.等旧的函数或模块。\nsubprocess.call([\"some_command\",\"some_argument\",\"another_argument_or_path\")\nfrom subprocess import call\ncall(['ls','-l','/boot','/sys'])    #\ncall('ls -a /',shell=True)\nsubprocess.Popen(command,shell=True)\nsubprocess.Popen(args, bufsize=0, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=False, shell=False, cwd=None, env=None, universal_newlines=False, startupinfo=None, creationflags=0)\n参考博客\n\nhttps://blog.csdn.net/longerz...\nhttps://python.freelycode.com...\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}