{"title": "【过时】MySQLdb：Python 操作 MySQL 数据库 - 止于至善 ", "index": "python,mysql", "content": "NOTE（2017-11-18）: MySQLdb 不支持 Python 3，而 Python 3 是主流，所以就没有学习的必要了。\n环境：MySQL 5.6.27, Ubuntu 15.10 64-bit\n个人笔记，可读性较差。寻教程请移步：MySQL Python tutorial\n官方简介\nMySQLdb is an thread-compatible interface to the popular MySQLdatabase server that provides the Python database API.\n安装\n通过 pip 安装\n$ apt-get install python-dev libmysqlclient-dev\n$ pip install MySQL-python\n详见：How to install Python MySQLdb module using pip?\n通过 apt 安装\n$ sudo apt-get install python-mysqldb\n模块 _mysql\nMySQLdb 安装好后，有两个模块或方式可用。模块 _mysql 提供的是类似于 MySQL C 接口的 API，而模块 MySQLdb 在 _mysql 基础上又做了进一步封装，使之符合 Python 的数据库 API 规范。推荐使用后者。\n使用 _mysql 的例子：\nimport _mysql\nimport sys\n\ntry:\n    con = _mysql.connect('localhost', 'root', '******', 'test')\n\n    con.query('select version()')\n    result = con.use_result()\n\n    print 'MySQL version: %s' % result.fetch_row()[0]\n\nexcept _mysql.Error, e:\n    print 'Error %d: %s' % (e.args[0], e.args[1])\n    sys.exit(1)\n\nfinally:\n    if con:\n        con.close()\n改用 MySQLdb：\nimport MySQLdb as mdb\nimport sys\n\ntry:\n    con = mdb.connect('localhost', 'root', '******', 'test')\n\n    cur = con.cursor()\n    cur.execute('select version()')\n\n    ver = cur.fetchone()\n\n    print 'MySQL version: %s' % ver\n\nexcept mdb.Error, e:\n    print 'Error %d: %s' % (e.args[0], e.args[1])\n    sys.exit(1)\n\nfinally:\n    if con:\n        con.close()\n创建表，插入数据\n# coding: utf-8\n\nimport MySQLdb as mdb\n\ncon = mdb.connect('localhost', 'root', '******', 'test')\n\nwith con:\n    cur = con.cursor()\n    cur.execute('drop table if exists writers')\n    cur.execute('create table writers(id int primary key auto_increment,\\\n            name varchar(25)) default charset utf8')\n    cur.execute('insert into writers(name) values(\"Jack London\")')\n    cur.execute('insert into writers(name) values(\"Honore de Balzac\")')\n    cur.execute('insert into writers(name) values(\"Lion Feuchtwanger\")')\n    cur.execute('insert into writers(name) values(\"Emile Zola\")')\n    cur.execute('insert into writers(name) values(\"Truman Capote\")')\n    cur.execute('insert into writers(name) values(\"曹雪芹\")')\n查询\n一次取回所有结果：fetchall\n\nimport MySQLdb as mdb\n\ncon = mdb.connect('localhost', 'root', '******', 'test')\n\nwith con:\n    cur = con.cursor()\n    cur.execute('select * from writers')\n\n    # 结果集 rows 为元组（tuple）的元组，每一个元组代表了表中的一行。\n    rows = cur.fetchall()\n    for row in rows:\n        print row\n挨个取回结果：fetchone\n\nimport MySQLdb as mdb\n\ncon = mdb.connect('localhost', 'root', '******', 'test')\n\nwith con:\n    cur = con.cursor()\n    cur.execute('select * from writers')\n\n    for i in range(cur.rowcount):\n        row = cur.fetchone()\n        print row\n使用字典 Cursor\nimport MySQLdb as mdb\n\ncon = mdb.connect('localhost', 'root', '******', 'test')\n\ndef test_dict_cursor():\n    with con:\n        cur = con.cursor(mdb.cursors.DictCursor) # 字典 cursor\n        cur.execute('select * from writers limit 4')\n\n        # rows 为字典的元组\n        rows = cur.fetchall()\n        for row in rows:\n            print row['id'], row['name'] # 通过列名访问结果\n打印列名\nimport MySQLdb as mdb\n\ncon = mdb.connect('localhost', 'root', '******', 'test')\n\nwith con:\n    cur = con.cursor()\n    cur.execute('select * from writers limit 4')\n\n    rows = cur.fetchall()\n        \n    # 元组的元组，每一个元组对应一个结果列，元组的第一个元素为列名。\n    desc = cur.description\n\n    # 打印前两个结果列的列名。\n    print '%s %3s' % (desc[0][0], desc[1][0])\n\n    for row in rows:\n        print '%2s %3s' % row\nPrepared Statements\nPrepared Statements 可以提高安全性和性能，特别是对于多次重复执行的查询。Python 的数据库 API 规范建议了 5 种不同的方式来构造 Prepared Statements，MySQLdb 只支持其中的一种，代码类似于 ANSI printf 的格式化操作。\nPrepared Statements 在 ORM 库（比如 SQLAlchemy）中应该会有更完善的支持。\n注（2016-01-10）：这里的 Prepared Statements 只是客户端的模拟，跟 MySQL Server 的 Prepared Statements 是两码事，所以并不能提高性能或安全性。（详见 C API Prepared Statements）\nimport MySQLdb as mdb\n\ncon = mdb.connect('localhost', 'root', '******', 'test')\n\nwith con:\n    cur = con.cursor()\n\n    cur.execute(\"update writers set name = %s where id = %s\",\n            (\"Guy de Maupasant\", \"4\"))\n\n    print \"Number of rows updated:\", cur.rowcount\n事务\n前面的例子一直使用 with 语句来管理链接 (connection) 对象，避免了 commit 的直接调用。\n一旦 cursor 创建，一个事务也就开始，结束时必须调用 commit 或 rollback。commit 提交修改，rollback 回滚。如果结合 with 语句使用的话，commit 和 rollback 都将自动完成，因为 MySQLdb 的链接对象可以当作 context manager 使用。\n# coding: utf-8\n\nimport MySQLdb as mdb\n\ntry:\n    con = mdb.connect('localhost', 'root', '******', 'test')\n\n    # Cursor 创建，事务开始。\n    cur = con.cursor()\n\n    cur.execute('drop table if exists writers')\n    # MyISAM doesn't support transaction.\n    cur.execute('create table writers(id int primary key auto_increment,\\\n            name varchar(25)) engine=innodb')\n\n    cur.execute('insert into writers(name) values(\"Jack London\")')\n    cur.execute('insert into writers(name) values(\"Honore de Balzac\")')\n    cur.execute('insert into writers(name) values(\"Lion Feuchtwanger\")')\n    cur.execute('insert into writers(name) values(\"Emile Zola\")')\n    cur.execute('insert into writers(name) values(\"Truman Capote\")')\n\n    # 显式地调用 commit 来结束一个事务。\n    con.commit()\n\nexcept mdb.Error, e:\n    # 异常发生时，调用 rollback 进行回滚。\n    if con:\n        con.rollback()\n\n    print \"Error %d: %s\" % (e.args[0], e.args[1])\n    sys.exit(1)\n\nfinally:\n    if con:\n        con.close()\nCursor 有必要 close 吗？\n原则上讲，不需要显式地调用 cursor 对象的 close 方法，因为当 cursor 对象生命期结束时，close 方法会被自动调用。源码如下：\nclass BaseCursor(object):\n    def __del__(self):\n        self.close()\n        self.errorhandler = None\n        self._result = None\n不过，还是建议主动调用 close，这样至少代码的行为更加明显。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "11"}