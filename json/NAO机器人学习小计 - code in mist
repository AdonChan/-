{"title": "NAO机器人学习小计 - code in mist ", "index": "python,c++", "content": "NAO APIs\nnao的接口全部以AL开头，全部继承自ALModule,它被包含在<alcommon/almodule.h>中。下面是ALModule的主要methods。\nALModule APIs\nnamespace : AL\n#include <alcommon/almodule.h>\n任务调度\nALModule::isRunning()\nbool ALModule::isRunning(const int& id);\n确定被一个‘post’创建的方法是否还在运行。(注：post可能类似于一个线程池管理员，方法的编号可能类似于线程号)。\n\nparams: id - 被post所返回的函数的编号\nreturn: true表示该方法正在被执行，false表示该方法没有被执行。\n\nALModule::wait()\nbool ALModule::wait(const int& id, const int& timeour);\n等待编号为id的方法执行完毕。\n\nparams: id - 被post所返回的函数的编号\n        timeout - ms为单位，表示\nreturn: true表示该方法正在被执行，false表示该方法没有被执行。\n\nALModule::stop()\nvoid ALModule::stop(const int& id);\n根据id停止相应方法。比较提倡模块开发人员实现这个接口，当模块内包含长时间执行的方法，而又希望允许用户打断。\n\nparams: id - 被post返回的方法的编号\nreturn:\n\nALModule::exit()\nvoid ALModule::exit();\n将这个模块从父经纪人(parent broker)中注销。一旦这个方法被调用，这个模块将不再可用。开发人员应该在希望执行彻底的关机任务时重写这个方法。\n\n\n——warning:\n不建议在核心模块（例如 ALMemory 或者 ALMotion）中存在别的模块或者方法正在调用它们时使用。\n\n\nBound Methods - Introspection(↑不太理解，字面翻译是：绑定的方法-反思)\nALModule::getBrokerName()\nstd::string ALModule::getBrokerName();\n获取父经纪人的名称\n\nreturn: 父经纪人的名称。\n\nALModule::getMethodList()\nstd::vectore<std::string> ALModule::getMethodList();\n获取当前模块的方法名称列表。\n\nreturn: 包含方法名称的向量。\n\nALModule::getMethodHelp()\nAL::ALValue ALModule::getMethodHelp(const std::string& methodName);\n获取一个方法的描述文档。\n\nparams: methodName - 方法的名称\nreturn: 一个包含了方法的描述内容的结构体\n\n注：\nAL::ALValue [\n    std::string methodName, \n    [ parameter, ... ]\n    std::string returnName,\n    std::string returnDescription\n]\n\nparameter:\n[\n    std::string parameterName,\n    std::string parameterDescription\n]\n\nALModule::getModuleHelp()\nAL::ALValue ALModule::getModuleHelp();\n获取当前模块的描述。\n\nreturn: 一个包含模块描述的结构体。\n\n注：\nAL::ALValue\n[\n    std::string moduleDescription,\n    [ moduleExample, ... ]\n]\n\nmoduleExample:\n[\n    std::string language,\n    std::string example\n]\n\nALModule::getUsage()\nstd::string ALModule::stop(const std::string& methodName);\n根据函数名称返回该函数的用法。\n\nparams: methodName - 函数名称。\nreturn: 总结了该函数用法的字符串。\n\nALModule::ping()\nbool ALModule::ping();\n单纯为了测试连接的ping。永远返回true\n\nreturn: true\n\nALModule::version()\nstd::string ALModule::version();\n返回模块的版本\n\nreturn: 模块的版本信息字符串。\n以上接口将作为公共接口存在于所有模块中。\n\n\n由于我们的项目以通信为主，因此我们优先关注通信模块ALConnectionManagerProxy。\n概览：ALConnectionManager提供管理网络连接的方法。它包含了一些允许你连接或配置一个网络的命令，并且也可以获取网络的属性或者创建一个网络。ALConnectionManager支持的网络包括：以太网、无线网和蓝牙。主要的特性包括：\n\n列举出所有可用的网路服务。\n连接到一个网络服务。\n创建一个网络服务（包括WiFi热点以及蓝牙个人局域网(Bluetooth PAN)）。\n列举可用的网络技术（WiFi、蓝牙、以太网）。\n对一个网络服务进行配置。\n\n这个模块提供网络服务的一些有用的信息，比如WiFi连接的强度、现在的状态、以及安全要求。\n这个模块通过事件机制来通知网络的变化。\n性能和约束：\n\nALConnectionManager只在机器人端可用。\n暂时不支持WPA安全加密。\n搜索可用wifi热点的功能在热点模式下不可用。\nALConnectionManager不处理蓝牙设备的配对过程。\n\nALConnectionManager APIs\nnamespace : AL\n#include <alproxies/alconnectionmanagerproxy.h>\n连接管理模块继承自ALModule API。它也有自有的下列方法：\nALConnectionManagerProxy::state()\nALConnectionManagerProxy::services()\nALConnectionManagerProxy::technologies()\nALConnectionManagerProxy::service()\nALConnectionManagerProxy::connect()\nALConnectionManagerProxy::disconnect()\nALConnectionManagerProxy::forget()\nALConnectionManagerProxy::setServiceConfiguration()\nALConnectionManagerProxy::setServiceInput()\nALConnectionManagerProxy::scan()\nALConnectionManagerProxy::enableTethering()\nALConnectionManagerProxy::disableTethering()\nALConnectionManagerProxy::getTetheringEnable()\nALConnectionManagerProxy::tetheringName()\nALConnectionManagerProxy::tetheringPassphrase()\nALConnectionManagerProxy::countries()\nALConnectionManagerProxy::country()\nALConnectionManagerProxy::setCountry()\nALConnectionManagerProxy::interfaces()\n\nALConnectionManagerProxy::state()\nstd::string ALConnectionManagerProxy::state();\n返回网络连接的状态（全局）。可能的值包括：\n· \"online\" - 当有互联网连接可用时。\n· \"ready\" - 至少有一个设备被成功地连接\n· \"offline\" - 目前没有设备连接到nao\n\nreturn: 全局的连接管理器状态。\n示例代码：\n#python 2.7\n \nfrom naoqi import ALProxy\n\nNAO_IP = \"127.0.0.1\"\n\nalConnectionManager = ALProxy(\"ALConnectionManager\", NAO_IP, 9559)\n\nprint \"network state: \" + alConnectionManager.state()\n\n\nALConnectionManagerProxy::scan()\nstd::string ALConnectionManagerProxy::state();\n搜索临近的网络服务（包括所有可用的网络技术）。可用服务的列表会被刷新，并在稍后被显示，这很有用。\n\nALConnectionManagerProxy::services()\nAL::ALValue ALConnectionManagerProxy::services();\n返回包含所有可用网络服务的名称以及属性的列表。在此之前调用`ALConnectionManagerProxy::scan()`会更有用。\n\nreturn: 一个ALValueNetworkInfo的数组。\n示例代码：\n#列出所有可用的网络服务\n\n#coding=utf-8\n\nfrom naoqi       import ALProxy\n\nNAO_IP = \"127.0.0.1\"\n\nalconnman = ALProxy(\"ALConnectionManager\", NAO_IP, 9559)\n\n#Scanning is required to update the services list\nalconnman.scan()\nservices = alconnman.services()\n\nfor service in services:\n    network = dict(service)\n    if network[\"Name\"] == \"\":\n        print \"{hidden} \" + network[\"ServiceId\"]\n    else:\n        print network[\"Name\"] + \" \" + network[\"ServiceId\"]\n\n\nALConnectionManagerProxy::service()\nAL::ALValue ALConnectionManagerProxy::service(const std::string& serviceId);\n返回一个指定的服务名称的服务的网络属性。网络信息NetworkInfo通过ALValue来表示。\n\nparams: serviceId - 希望获得属性的网络服务名称\nreturn: 指定的服务名称网络的属性。\nthrows: 该网络服务不可用时，抛出ALError\n示例代码：\n#获得一个网络服务的属性\n#coding=utf-8\nfrom naoqi import ALProxy\nimport sys\n\nNAO_IP = \"127.0.0.1\"\n\nif len(sys.argv) != 2:\n    print sys.argv[0] + \" <serviceId>\"\n    sys.exit(1)\n\nalconnman = ALProxy(\"ALConnectionManager\", NAO_IP, 9559)\n\ntry:\n  service = alconnman.service(sys.argv[1])\nexcept Exception as e:\n    print e.what()\n    sys.exit(1)\n\nservice = dict(service)\nprint \"Network Service: \" + sys.argv[1]\nfor key, value in service.iteritems():\n    print \"\\t\" + key + \": \" + str(value)\n\nALConnectionManagerProxy::connect()\nvoid ALConnectionManagerProxy::connect(const std::string& serviceId);\n连接到一个网络服务。\n\nparams: serviceId - 将要连接到的网络的名称\nthrows: 该网络服务不可用时，抛出ALError\n\n注意：\n如果在连接到这个网络时需要别的信息（比如需要登录密码，或者登录隐藏网络需要网络名称时），将会产生一个event。\nSee also\nNetworkServiceInputRequired(), NetworkConnectStatus()\n\n示例代码：\n#连接到一个网络\nfrom naoqi import ALProxy\nimport sys\n\nNAO_IP = \"127.0.0.1\"\n\nif len(sys.argv) != 2:\n    print sys.argv[0] + \" <serviceId>\"\n    sys.exit(1)\n\nalconnman = ALProxy(\"ALConnectionManager\", NAO_IP, 9559)\n\ntry:\n    alconnman.connect(sys.argv[1])\nexcept Exception as e:\n    print e.what()\n    sys.exit(1)\n\nALConnectionManagerProxy::disconnect()\nvoid ALConnectionManagerProxy::disconnect(const std::string& serviceId);\n断开到一个网络服务的连接。\n\nparams: serviceId - 将要断开的网络的名称\nthrows: 该网络服务不可用时，抛出ALError\n示例代码：\n#断开一个网络连接\nfrom naoqi import ALProxy\nimport sys\n\nNAO_IP = \"127.0.0.1\"\n\nif len(sys.argv) != 2:\n    print sys.argv[0] + \" <serviceId>\"\n    sys.exit(1)\n\nalconnman = ALProxy(\"ALConnectionManager\", NAO_IP, 9559)\n\ntry:\n  alconnman.disconnect(sys.argv[1])\nexcept Exception as e:\n    print e.what()\n    sys.exit(1)\nALConnectionManagerProxy::disconnect()\nvoid ALConnectionManagerProxy::forget(const std::string& serviceId);\n忘记一个偏好网络。需要获得网络服务的名称来忘记相关联的信息。这还会使得这个网络不再是偏好网络，并且不会被自动连接。\n\nparams: serviceId - 将要忘记的网络的名称\nthrows: 该网络服务不可用时，抛出ALError\n示例代码：\n#忘记一个网络\nfrom naoqi import ALProxy\nimport sys\n\nNAO_IP = \"127.0.0.1\"\n\nif len(sys.argv) != 2:\n    print sys.argv[0] + \" <serviceId>\"\n    sys.exit(1)\n\nalconnman = ALProxy(\"ALConnectionManager\", NAO_IP, 9559)\n\ntry:\n  service = alconnman.forget(sys.argv[1])\nexcept Exception as e:\n    print e.what()\n    sys.exit(1)\n\nALConnectionManagerProxy::setServiceConfiguration()\nvoid ALConnectionManagerProxy::setServiceConfiguration(const AL::ALValue& configuration)\n给定需要应用的静态网络配置。以下属性在静态配置中是可用的：\n· 是否自动连接\n· 域名\n· 域名服务器\n· IPv4\n· IPv6（实验性的）\n\nparams: configuration - 一个将要被应用网络配置的包含了NetWorkInfo的ALValue。\nthrows: 当网络服务不可用的时候抛出ALError\n        当配置信息不合法时抛出ALError\n        当网络服务不需要配置时抛出ALError\nSee alsoNetworkInfo\n(未完)\n\n\n\n\n\n\nALRobotPosture模块\n概览\n暂时现在看看motion部分的模块。ALRobotPosture模块允许用户将机器人定位到已经定义好的姿势。可以选择使用ALRobotPostureProxy::goToPosture()或者ALRobotPosture::applyPosture.\n\n如果想要创建一个自动化的应用，务必选择ALRobotPostureProxy::goToPosture().\n如果你仅仅希望在操控机器人时，迅速达到某个姿势，可以选择ALRobotPostureProxy::applyPosture，（你必须要协助机器人）。\n\n这如何工作？\n机器人会侦测到现在它正处于那种姿势，然后计算出一个路径，使得它可以从现在的姿势变换到目标姿势，然后执行这条线路。\n可能允许选择姿势变换的速度。\n定义\n姿势\n机器人的姿势是一个独特的，对他的关节和惯性传感器的配置。由于姿势是由一组实数（比如说float）定义的，所以会有无数种姿势。\n预定义的姿势\n下面是预定义的姿势列表：\n\n蹲伏(Crouch)\n仰面躺(LyingBack)\n面向下趴着(LyingBelly)\n正坐(Sit)\n箕踞(SitRelax)\n站立(Stand)\n预行走站立(StandInit)\n向前看齐(StandZero)\n\n有一些姿势（比如Sit或Lying）并不是对所有机器人都是可用的。\n使用ALRobotPostureProxy::getPostureList()来获取你的机器人上可用的预定义的姿势列表。\n姿势族\n由于姿势的种类有无数种，姿势被划分为姿势族，以是的姿势更加容易理解。以下是姿势族列表:\n使用ALRobotPostureProxy::getPostureFamilyList()，就可以知道你的机器人上有哪些可用的姿势族。它一定是下面这个列表的子集。\n\n\nPosture Family\nDescription\n\n\n\nStanding\n机器人的中心在脚上，并且机器人的躯干是笔直向上的的。\n\n\nSitting\n机器人的尾部接触地面，并且躯干是笔直向上的。\n\n\nSittingOnChair\n机器人的尾部接触一个高约10cm的椅子，并且躯干是笔直向上的。\n\n\nLyingBelly\n身体平展，并且面向下\n\n\nLyingBack\n身体平展，并且面向上\n\n\nLyingLeft\n身体平展，并且面向右侧\n\n\nLyingRight\n身体平展，并且面向左侧\n\n\nBelly\n面向下并且躯干悬空\n\n\nBack\n面向后并且躯干悬空\n\n\nLeft\n膝盖跪向左侧，并且手部着地\n\n\nRight\n膝盖跪向右侧，并且手部着地\n\n\n\nnamespace:AL\n方法列表\n和别的模块一样，这个模块继承自ALModule API。它也有自有的下列方法。\nclass ALRobotPostureProxy：\n\nALRobotPostureProxy::getPostureList()\nALRobotPostureProxy::getPosture()\nALRobotPostureProxy::goToPosture()\nALRobotPostureProxy::applyPosture()\nALRobotPostureProxy::stopMove()\nALRobotPostureProxy::getPostureFamily()\nALRobotPostureProxy::getPostureFamilyList()\nALRobotPostureProxy::setMaxTryNumber()\n\n事件\n\nPostureFamilyChanged()\nPostureChanged()\n\n方法\nALRobotPostureProxy::getPostureList()\nstd::vector<std::string> ALRobotPostureProxy::getPostureList();\n返回一个包含所有已经定义姿势的列表。\n\nreturn: 包含所有已定义姿势的向量\n\nALRobotPostureProxy::getPosture()\nstd::string ALRobotPostureProxy::getPosture()\n返回现在的**预定义姿势**名称。如果现在的姿势不是预定义姿势，就会返回\"Unknown\".\nreturn: 一个包含现在姿势的名称的字符串。\nALRobotPostureProxy::goToPoture()\nbool ALRobotPostureProxy::gotoPosture(const std::string postureName, const float speed);\n让机器人变换到预定义的姿势。速度可能是可以调节的。这个变化是“智能的”，它会从现在已有的开始姿势，自动选择每一步，以变换到目标姿势。\n这是一个会阻塞的函数调用。如果希望它不会阻塞线程，使用post。\nparams: postureName - 预定义的姿势名称字符串。\n        speed - 相对速度，范围从0.0 - 1.0\nreturn: 一个布尔值，表明目标姿势是否正确达到。\n\nALRobotPostureProxy::applyPosture()\nbool ALRobotPostureProxy::applyPosture(const std::string& postureName, const float& speed);\n将所有的预定义姿势中提到的关节设置到定义中的状态。\n在操控机器人时，使用这个方法以达到显示出动作的效果。请将他想象成一条姿势变换的捷径，假设这是你想要快速达到某一个姿势。机器人可能需要使用者的帮助以达到这个姿势。\n这个方法的效果是立即的，并且其中没有只能因素在里面。所以在设置姿势时，请小心。比方说，如果机器人现在正坐着，你调用了applyPosture(\"StandInit\", 1.0)。这对于机器人可能是非常危险的，如果你不帮助机器人站起来的话，它就会跌倒。\n如果你想要机器人独立地站起来，调用goToPosture().\n这是一个会阻塞的函数调用。如果希望它不会阻塞线程，使用post。\n\nparams: postureName - 预定义的姿势名称字符串。\n        speed - 相对速度，范围从0.0 - 1.0\nreturn: 一个布尔值，表明目标姿势是否正确达到。\n\nALRobotPostureProxy::stopMove()\nvoid ALRobotPostureProxy::stopMove();\n停止当前的姿势插补动作。\n\nALRobotPostureProxy::getPostureFamily()\nstd::string ALRobotPostureProxy::getPostureFamily();\n返回姿势族。\n\nreturn: 返回当前的姿势族名称。\n\nALRobotPostureProxy::getPostureFamilyList()\nstd::vector<std::string> ALRobotPostureProxy::getPostureFamilyList();\n返回一个包含了所有预定义的姿势族名称的向量。\n\nreturn: 一个包含了所有预定义姿势族名称的vector.\n\nALRobotPostureProxy::setMaxTryNumber(const int& maxTryNumber)\nvoid ALRobotPostureProxy::setMaxTryNumber(const int& maxTryNumber);\n设置当调用`ALRobotPostureProxy::goToPosture()`返回失败之前，最大的尝试次数。\n\nparams: maxTryNumber - 尝试的次数，默认值是3.\nEvent: \"PostureFamilyChanged\"\ncallback(std::string eventName, std::string PostureFamily, std::string subscriberIdentifier);\n当姿势族发生改变时，传递出姿势族的名称。\n这个事件的更新频率大约是一秒钟。\n\nEvent: \"PostureChanged\"\ncallback(std::string eventName, std::string Posture, std::string subscriberIdentifier)：\n当姿势发生改变时，传递出姿势的名称。\n这个事件的更新频率大约是一秒钟。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "3"}