{"title": "让我们一起来构建一个模板引擎（二） - mozillazg 的学习笔记 ", "index": "模板引擎,python", "content": "在 上篇文章中我们的模板引擎实现了变量和注释功能，同时在文章的最后我给大家留了一个 问题：如何实现支持 if 和 for 的标签功能:\n{% if user.is_admin %}\n    admin, {{ user.name }}\n{% elif user.is_staff %}\n    staff\n{% else %}\n    others\n{% endif %}\n\n{% for name in names %}\n    {{ name }}\n{% endfor %}\n在本篇文章中我们将一起来实现这个功能。\nif ... elif ... else ... endif\n首先我们来实现对 if 语句的支持。 if 语句的语法如下:\n{% if True %}\n...\n{% elif True %}\n...\n{% else %}\n...\n{% endif %}\n我们首先要做的跟之前一样，那就是确定匹配标签语法的正则表达式。这里我们用的是下面 的正则来匹配标签语法:\nre_tag = re.compile(r'\\{% .*? %\\}')\n\n>>> re_tag.findall('{% if True %}...{% elif True %}...{% else %}...{% endif %}')\n['{% if True %}', '{% elif True %}', '{% else %}', '{% endif %}']\n然后就是生成代码了， if 语句跟之前的变量不一样那就是：需要进行缩进切换，这一点需要注意一下。\n下面我们来看一下为了支持 if 标签增加了哪些代码吧(完整代码可以从 Github 上下载 template2a.py ):\nclass Template:\n\n    def __init__(self, ...):\n        # ...\n        # 注释\n        self.re_comment = re.compile(r'\\{# .*? #\\}')\n        # 标签\n        self.re_tag = re.compile(r'\\{% .*? %\\}')\n        # 用于按变量，注释，标签分割模板字符串\n        self.re_tokens = re.compile(r'''(\n            (?:\\{\\{ .*? \\}\\})\n            |(?:\\{\\# .*? \\#\\})\n            |(?:\\{% .*? %\\})\n        )''', re.X)\n    \n        # 生成 def __func_name():\n        # ...\n\n    def _parse_text(self):\n        # ...\n        for token in tokens:\n            # ...\n            if self.re_variable.match(token):\n                # ...\n            elif self.re_comment.match(token):\n                continue\n\n            # {% tag %}\n            elif self.re_tag.match(token):\n                # 将前面解析的字符串，变量写入到 code_builder 中\n                # 因为标签生成的代码需要新起一行\n                self.flush_buffer()\n\n                tag = token.strip('{%} ')\n                tag_name = tag.split()[0]\n                if tag_name in ('if', 'elif', 'else'):\n                    # elif 和 else 之前需要向后缩进一步\n                    if tag_name in ('elif', 'else'):\n                        self.code_builder.backward()\n                    self.code_builder.add_line('{}:'.format(tag))\n                    # if 语句条件部分结束，向前缩进一步，为下一行做准备\n                    self.code_builder.forward()\n                elif tag_name in ('endif',):\n                    # if 语句结束，向后缩进一步\n                    self.code_builder.backward()\n\n            else:\n                # ...\n上面代码的关键点是生成代码时的缩进控制:\n\n在遇到 if 的时候, 需要在 if 这一行之后将缩进往前移一步\n在遇到 elif 和 else 的时候, 需要将缩进先往后移一步，待 elif/ else 那一行完成后还需要把缩进再移回来\n在遇到 endif 的时候, 我们知道此时 if 语句已经结束了，需要把缩进往后移一步， 离开 if 语句的主体部分\n\n我们来看一下生成的代码:\n>>> from template2a import Template\n>>> t = Template('''\n   ... {% if score >= 80 %}\n   ... A\n   ... {% elif score >= 60 %}\n   ... B\n   ... {% else %}\n   ... C\n   ... {% endif %}\n   ... ''')\n>>> t.code_builder\ndef __func_name():\n    __result = []\n    __result.extend(['\\n'])\n    if score >= 80:\n        __result.extend(['\\nA\\n'])\n    elif score >= 60:\n        __result.extend(['\\nB\\n'])\n    else:\n        __result.extend(['\\nC\\n'])\n    __result.extend(['\\n'])\n    return \"\".join(__result)\n代码中的 if 语句和缩进没有问题。下面再看一下 render 的结果:\n>>> t.render({'score': 90})\n '\\n\\nA\\n\\n'\n>>> t.render({'score': 70})\n '\\n\\nB\\n\\n'\n>>> t.render({'score': 50})\n '\\n\\nC\\n\\n'\n对 if 语句的支持就这样实现了。有了这次经验下面让我们一起来实现对 for 循环的支持吧。\nfor ... endfor\n模板中的 for 循环的语法如下:\n{% for name in names %}\n    ...\n{% endfor %}\n从语法上可以看出来跟 if 语句是很相似了，甚至比 if 语句还要简单。只需在原有 if 语句代码 的基础上稍作修改就可以(完整版可以从 Github 上下载 template2b.py ):\nclass Template:\n\n    # ...\n\n    def _parse_text(self):\n        # ...\n            elif self.re_tag.match(token):\n                # ...\n                if tag_name in ('if', 'elif', 'else', 'for'):\n                    # ...\n                elif tag_name in ('endif', 'endfor'):\n                    # ...\n可以看到其实就是修改了两行代码。按照惯例我们先来看一下生成的代码:\n>>> from template2b import Template\n>>> t = Template('''\n   ... {% for number in numbers %}\n   ... {{ number }}\n   ... {% endfor %}\n   ... ''')\n>>> t.code_builder\ndef __func_name():\n    __result = []\n    __result.extend(['\\n'])\n    for number in numbers:\n        __result.extend(['\\n',str(number),'\\n'])\n    __result.extend(['\\n'])\n    return \"\".join(__result)\nrender 效果:\n>>> t.render({'numbers': range(3)})\n'\\n\\n0\\n\\n1\\n\\n2\\n\\n'\nfor ... endfor 语法就这样实现了。是不是很简单?？但是还没完?\n相信大家都知道在 python 中 for 循环其实还支持 break 和 else 。 下面我们就一起来让我们的模板引擎的 for 语法支持 break 和 else （可以从 Github 上下载: template2c.py ）\nclass Template:\n\n    # ...\n\n    def _parse_text(self):\n        # ...\n            elif self.re_tag.match(token):\n                # ...\n                if tag_name in ('if', 'elif', 'else', 'for'):\n                    # ...\n                elif tag_name in ('break',):\n                    self.code_builder.add_line(tag)\n                elif tag_name in ('endif', 'endfor'):\n                    # ...\n可以看到，其实也是只增加了两行代码。效果：\nfrom template2c import Template\n\n>>> t = Template('''\n... {% for number in numbers %}\n...    {% if number > 2 %}\n...       {% break %}\n...    {% else %}\n...       {{ number }}\n...    {% endif %}\n... {% else %}\n...    no break\n... {% endfor %}\n... ''')\n>>> t.code_builder\ndef __func_name():\n    __result = []\n    __result.extend(['\\n'])\n    for number in numbers:\n        __result.extend(['\\n   '])\n        if number > 2:\n            __result.extend(['\\n      '])\n            break\n            __result.extend(['\\n   '])\n        else:\n            __result.extend(['\\n      ',str(number),'\\n   '])\n        __result.extend(['\\n'])\n    else:\n        __result.extend(['\\n   no break\\n'])\n    __result.extend(['\\n'])\n    return \"\".join(__result)\n\n>>> t.render({'numbers': range(3)}).replace('\\n', '')\n'         0            1            2      no break'\n>>> t.render({'numbers': range(4)}).replace('\\n', '')\n'         0            1            2            '\n就这样我们的模板引擎对 for 的支持算是比较完善了。 至于生成的代码里的换行和空格暂时先不管，留待之后优化代码的时候再处理。\n重构\n我们的 Template._parse_text 方法代码随着功能的增加已经变成下面这样了:\ndef _parse_text(self):\n    \"\"\"解析模板\"\"\"\n    tokens = self.re_tokens.split(self.raw_text)\n\n    for token in tokens:\n        if self.re_variable.match(token):\n            variable = token.strip('{} ')\n            self.buffered.append('str({})'.format(variable))\n        elif self.re_comment.match(token):\n            continue\n        elif self.re_tag.match(token):\n            self.flush_buffer()\n\n            tag = token.strip('{%} ')\n            tag_name = tag.split()[0]\n            if tag_name in ('if', 'elif', 'else', 'for'):\n                if tag_name in ('elif', 'else'):\n                    self.code_builder.backward()\n                self.code_builder.add_line('{}:'.format(tag))\n                self.code_builder.forward()\n            elif tag_name in ('break',):\n                self.code_builder.add_line(tag)\n            elif tag_name in ('endif', 'endfor'):\n                self.code_builder.backward()\n        else:\n            self.buffered.append('{}'.format(repr(token)))\n有什么问题呢？问题就是 for 循环里的代码太长了，我们需要分割 for 循环里的 代码。比如把对变量，if/for 的处理封装到单独的方法里。\n下面展示了一种方法（可以从 Github 下载 template2d.py ):\ndef _parse_text(self):\n    \"\"\"解析模板\"\"\"\n    tokens = self.re_tokens.split(self.raw_text)\n    handlers = (\n        (self.re_variable.match, self._handle_variable),   # {{ variable }}\n        (self.re_tag.match, self._handle_tag),             # {% tag %}\n        (self.re_comment.match, self._handle_comment),     # {# comment #}\n    )\n    default_handler = self._handle_string                  # 普通字符串\n\n    for token in tokens:\n        for match, handler in handlers:\n            if match(token):\n                handler(token)\n                break\n        else:\n            default_handler(token)\n\ndef _handle_variable(self, token):\n    \"\"\"处理变量\"\"\"\n    variable = token.strip('{} ')\n    self.buffered.append('str({})'.format(variable))\n\ndef _handle_comment(self, token):\n    \"\"\"处理注释\"\"\"\n    pass\n\ndef _handle_string(self, token):\n    \"\"\"处理字符串\"\"\"\n    self.buffered.append('{}'.format(repr(token)))\n\ndef _handle_tag(self, token):\n    \"\"\"处理标签\"\"\"\n    # 将前面解析的字符串，变量写入到 code_builder 中\n    # 因为标签生成的代码需要新起一行\n    self.flush_buffer()\n    tag = token.strip('{%} ')\n    tag_name = tag.split()[0]\n    self._handle_statement(tag, tag_name)\n\ndef _handle_statement(self, tag, tag_name):\n    \"\"\"处理 if/for\"\"\"\n    if tag_name in ('if', 'elif', 'else', 'for'):\n        # elif 和 else 之前需要向后缩进一步\n        if tag_name in ('elif', 'else'):\n            self.code_builder.backward()\n        # if True:, elif True:, else:, for xx in yy:\n        self.code_builder.add_line('{}:'.format(tag))\n        # if/for 表达式部分结束，向前缩进一步，为下一行做准备\n        self.code_builder.forward()\n    elif tag_name in ('break',):\n        self.code_builder.add_line(tag)\n    elif tag_name in ('endif', 'endfor'):\n        # if/for 结束，向后缩进一步\n        self.code_builder.backward()\n这样处理后是不是比之前那个都放在 _parse_text 方法里要好很多？\n至此，我们的模板引擎已经支持了如下语法:\n\n变量: {{ variable }}\n注释: {# comment #}\nif 语句: {% if ... %} ... {% elif ... %} ... {% else %} ... {% endif %}\nfor 循环: {% for ... in ... %} ... {% break %} ... {% else %} ... {% endfor %}\n\n之后的文章还将实现其他实用的模板语法，比如 include, extends 模板继承等。\ninclude 的语法(item.html 是个独立的模板文件, list.html 中 include item.html):\n{# item.html #}\n<li>{{ item }}</li>\n\n{# list.html #}\n<ul>\n    {% for name in names %}\n        {% include \"item.html\" %}\n    {% endfor %}\n</ul>\nlist.html 渲染后将生成类似下面这样的字符串:\n<ul>\n    <li>Tom</li>\n    <li>Jim<li>\n</ul>\nextends 的语法(base.html 是基础模板, child.html 继承 base.html 然后重新定义 base.html 中定义过的 block):\n{# base.html #}\n<div id=\"content\">\n{% block content %}\n    parent_content\n{% endblock content %}\n</div>\n<footer id=\"footer\">\n{% block footer %}\n    (c) 2016 example.com\n{% endblock footer %}\n</footer>\nchild.html:\n{% extends \"base.html\" %}\n\n{% block content %}\n    child_content\n    {{ block.super }}\n{% endblock content %}\nchild.html 渲染后将生成类似下面这样的字符串:\n<div id=\"content\">\n    child_content\n    parent_content\n</div>\n<footer id=\"footer\">\n    (c) 2016 example.com\n</footer>\n那么，该如何实现 include 和 extends 功能呢？ 我将在 第三篇文章 中向你详细的讲解。敬请期待。\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "6"}