{"title": "基于 oracle 的 flask 项目（二）——用户登录 - 藕丝空间 ", "index": "sqlaclhemy,oracle,flask,python", "content": "flask 相对于很多国企的 oracle 数据库而言，是比较新的，因此很多古老的设计并不一定适合较新的 flask 的标准，但作为后来者，你得向前兼容，你得适应需求。本章内容就来解释一下上一章——基于 oracle 的 flask 项目（一）——配置项目留下的彩蛋——数据库到底留下了什么样的坑？\n项目描述\n绝对大多数的网站需要管理功能的，这个功能是不对外开放，需要有权限的用户登录后才能操作的。这个登录功能对于大牛来说，肯定是操作 session， cookies 了，其实不必这么麻烦， flask-login 插件可以解决你的登录问题，但是要注意一些小细节，本章内容就是来讨论一些细节内容。\n本章主要帮你解决你的项目的 DBA 管理员没有给你设置主键，主键也不是 id 的问题。\n创建登录模板\n\n在 app/templates/show 目录下新建一个 login.html 页面。\n同时，对模板进行分割，创建文件夹 common ， 将主模板 base.html，提示模板 alert.thml 、头文件 header.html，侧边栏 sidebar.html 等共用文件，都放入该文件夹。\n其中使用到一些 css 和 js 的内容，需要放在蓝图文件夹下的 static 文件夹里面。\n个性化你的 web 主页，设置你的 index.html。\n\n使用数据库及映射类\n使用数据库及映射类的时候，需要用到 sqlalchemy 第三方库， flask 也提供了一个封装好的插件 flask-sqlalchemy ，拿来使用即可。但是要使用 sqlalchemy， 在创建映射类的时候，必须得设置主键。但是很多前辈的 DBA 们的眼里可是没有 flask 的概念的，很多表是没有设置主键的，我们该怎么办？\n答：先对 DBA 管理员翻个白眼，然后自己默默的做事吧。还能怎么办呢！！！找个具有唯一性，不重复的字段，在创建映射类的时候，把该字段定义为主键。也就是说，不管数据库中是否定义了主键，只要映射类种定义了即可。当然，有的同学会说，我们找不到具有唯一性，不重复的字段，该怎么办？那就继续给你的 DBA 管理员翻白眼呗，翻到他清醒为止。\n还好，我的项目中的数据库还是有主键的，无需在映射类种，建立虚假的主键。\n内容不在赘述，请参加代码。\n设置 flask-login\n初始化 flask-login\n在 app/__init__.py 里进行设置：\nlogin_manager = LoginManager()\nlogin_manager.session_protection = 'strong' # 可以设置None,'basic','strong'  以提供不同的安全等级,一般设置strong,如果发现异常会登出用户。\nlogin_manager.login_view = 'show.login' # 这里填写你的登陆界面的路由\n\ndef create_app(config_name):\n    \"\"\" 使用工厂函数初始化程序实例\"\"\"\n    ....\n    login_manager.init_app(app=app)\n很多时候，我们会遇到 remember_me 无效的情况，请将 login_manager.session_protection 设置成 basic 试试。\n详细设置请看程序注释及[源代码02]()。\n配置 flask-login\n让 models.py 中的用户映射类继承 flask_login 中的 UserMixin 类，该类实现了 4 个用户方法，基本上能够满足用户登录的需求，如需其它的用户方法，可自行定义。\nclass OusiStaff(UserMixin, db.Model):\n    __tablename__ = 'ousi_staff'\n    sid = db.Column(db.Integer, primary_key=True)\n    department = db.Column(db.String(8))\n    name = db.Column(db.String(8))\n    password = db.Column(db.String(8))\n    phone = db.Column(db.String(11))\n    role = db.Column(db.String(8))\n\n    def is_admin(self): # 自行定义的方法,用于权限判断\n        return self.role == 'admin'\n\n\nclass AnonymousUser(AnonymousUserMixin):\n    '''\n    继承至该类的用户模型 将作为未登陆时的用户模型,可以保持代码的一致性。\n    '''\n    def is_admin(self): # 自行定义的方法,用于权限判断\n        return False\n\n\nlogin_manager.anonymous_user = AnonymousUser\n\n实现用户的回调函数\n也是在 models.py 里实现：\n@login_manager.user_loader\ndef load_user(user_id):\n    return OusiStaff.query.get(int(user_id))\n此处，不详细讲解，仅仅是实现了一个回调用户的函数。\n使用登录权限限制\n既然使用了登录功能，那么肯定是有些内容不能让未登录的用户观看，这就需要在试图函数定义的时候加上一个 login_required 装饰器了。\n这个功能的实现很简单，在 views.py 里进行修改：\n...\nfrom flask_login import login_required, login_user, logout_user\n...\n\n@show.route('/', methods = ['GET', 'POST'])\n@show.route('/index', methods = ['GET', 'POST'])\n@login_required\ndef index():\n\n    return render_template('show/index.html')\n至此，你可以测试自己的项目了。\n\n问题\n报 NotImplementedError: No 'id' attribute - override 'get_id' 错误的问题\n...\nbug 如影随从。这是你遇到的第一个错误。你会发现登录之后马上就报这个错误。那么兵来将挡水来土掩，找到问题，解决问题。\n首先，报错的地点显示是我们自己的代码中的 login_user，而真正报错的地点是 minins.py 源码中的 39 行，那么这一行的真面目是什么呢？\ndef get_id(self):\n    try:\n        return text_type(self.id)\n    except AttributeError:\n        raise NotImplementedError('No `id` attribute - override `get_id`')\n你可以清晰的看到，这个 get_id 函数的返回值是 return text_type(self.id) 是当前用户的 id。那么我们的 models.py 中定义的 OusiStaff 类有 id 这个字段吗？没有。只有一个作为主键的 sid 字段。看到这里，估计你会对以前的 DBA 管理员问候很多声了，OK，稍安勿躁，问候了之后还得解决问题。很直观的解决方法是，修改源码，将 return text_type(self.id) 修改为 return text_type(self.sid)。但是这样的方法很危险，很造成一些其它项目的兼容性问题。显得这个程序员很 low。\n再次我们用一种更好、更优雅的方法来解决。在 models.py 文件内的 OusiStaff 映射类中添加如下内容：\nclass OusiStaff(UserMixin, db.Model):\n    ...\n    ...\n    \n    @property\n    def id(self):\n        return self.sid\n增加一个 id 属性。解决问题。\n神奇的 @property。 彩蛋就如此简单的被解决。\n打开页面，显示正常。\n\n源码下载\n下节更精彩，我们将讲解使用 flask-sqlalchemy 来生成相关报表。\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "0"}