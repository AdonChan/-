{"title": "Python的赋值、浅拷贝、深拷贝 - python学习+自动化测试实践 ", "index": "python", "content": "\n在写dict数据类型时，有提到过“赋值语句”与copy()函数。其实说到深浅拷贝，需要考虑具体的数据类型。一部分是不可变对象，如数字、字符串；另一部分是可变对象，如列表、字典等。\n\n一、定义解释\n\n\n变量：一个系统表的元素，指向对象的连接空间。\n\n对象：被分配的一块内存，存储其实际的值。\n\n引用：从变量到对象的指针。\n\n不可变对象：一旦创建就不可以修改，如数字、字符串、元组。\n\n可变对象：可以修改的对象，如列表、字典。\n\n赋值：通过语句“=”实现。左边是新建的变量，右边可以是直接内容，或者已存在的变量。是对象的引用，Python没有拷贝该对象，只是拷贝了对象的引用，新变量指向源变量内存地址。\n\n浅拷贝：对一个对象进行拷贝。拷贝最外围的对象本身，内部的元素都只是拷贝了一个引用而已。即新创建了一个类型跟原对象一样、内容是原对象的引用。【浅拷贝对象是新的，对象的引用内容是旧的。】浅拷贝实现的几种方式：（1）切片：[:]；（2）工厂函数，比如list()、dict()；（3）使用copy()。\n\n深拷贝：外围和内部元素都进行了拷贝对象本身，而不是引用。即把对象复制一遍，并且该对象中引用的其他对象也复制。\n\n二、不可变对象\n对于不可变对象，例如数字和字符串而言，赋值（=）、浅拷贝（copy()）和深拷贝（deepcopy()）没有区别，因为他们的对象引用永远指向同一个内存地址。通过例子演示：\n>>> var_1 = 123\n>>> id(var_1)            # 通过id()查看地址\n1615552144\n>>> var_2 = var_1\n>>> id(var_2)\n1615552144\n>>>\n>>> import copy        # 浅、深拷贝需要导入copy模块\n>>> var_3 = copy.copy(var_1)\n>>> id(var_3)\n1615552144\n>>>\n>>> var_4 = copy.deepcopy(var_1)\n>>> id(var_4)\n1615552144\n你会发现var_1 ~ var_4 的id指向是一样的。\n三、可变对象\n对list、dict等数据类型而言，赋值、浅拷贝和深拷贝，他们对内存地址的变化是不同的。赋值浅拷贝：值相等，地址相等；copy浅拷贝：值相等，地址不相等；deepcopy深拷贝：值相等，地址不相等；\n例子一：base[0]=’name’，是一个string，不可变对象；base[1]=[‘age’,18],是list，可变对象。base_1、base_2均是base的浅拷贝，三者id()一样。当对第一个string元素进行不同的更改时，发现id各不相同，不会互相影响，因为字符串（不可变）被显示的拷贝，当修改后，新创建了一个字符对象。而修改第二个list元素时，不同的修改都只对最后一次修改生效，且互相影响，因为第二个元素列表只是简单的复制了其引用，修改任何一个浅拷贝，都会修改引用的内容。\n例子二：深拷贝创建一个字典对象，并使用深拷贝创建一个新的对象。\n>>>import copy\n>>> var = {\"a\":1,\"b\":2,\"c\":[3,'abc']}\n>>> var1 = copy.deepcopy(var)\n>>> id(var),id(var1)\n(17616992, 15671136)            # 地址不相同\n>>> id(var['c']),id(var1['c'])\n(15695144, 15695384)        \n>>> id(var['c'][0]),id(var1['c'][0])\n(1615550224, 1615550224)        # ‘c’元素的内存地址是相同的\n>>>\n>>> var1['c'][0] = 4\n>>> var\n{'a': 1, 'b': 2, 'c': [3, 'abc']}\n>>> var1\n{'a': 1, 'b': 2, 'c': [4, 'abc']}\n>>> id(var['c'][0]),id(var1['c'][0])\n(1615550224, 1615550240)        # 对var1的修改没有影响var       \n\n❤ thanks for watching, keep on updating...\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "0"}