{"title": "寻优算法之粒子群 - 个人文章 ", "index": "python,算法", "content": "导言\n粒子群PSO算法相比遗传算法实现会简单一点，核心就是根据算子更新个体历史最优和全局最优。粒子群用的不多，给我的感觉是收敛很快的一种算法。这种算法较为容易陷入局部最优，若问题具有欺骗性（具有多个假峰，且优化资源集中在其中一个峰上）就不容易找到全局最优。学院有个学长改进PSO发了篇论文，好像是将（全局最优-个体最优）加入到算子当中，这会一定程度上跳出局部最优。\n遗传算法回顾\n核心算子：\n v[i] = w * v[i] + c1 * rand() * (pbest[i] - present[i]) + c2 * rand() * (gbest - present[i])\n present[i] = present[i] + v[i]\n其中v[i]代表第i个粒子的速度，w代表惯性权值,c1和c2表示学习参数，rand()表示在0-1之间的随机数,pbest[i]代表第i个粒子搜索到的历史最优值,gbest代表整个集群搜索到的最优值,present[i]代表第i个粒子的当前位置。\n算法思想\n模拟一群鸟寻找食物的过程，每个鸟就是PSO中的粒子，也就是我们需要求解问题的可能解，这些鸟在寻找食物的过程中，会不停改变地自己在空中飞行的位置与速度。改变的方向会根据个体的历史最优p_best和全局最优g_best来做出改变，也就是上面的核心算子。可以比喻为每只鸟会一定程度上追随每次迭代中找食物最厉害的那只鸟，这里的找食物最厉害就是能最大可能解出目标函数。\n算法过程：\n还是解决遗传算法当中的简单单目标问题，求解函数f的最大值\nmax f (x1, x2) = 21.5 + x1·sin(4 pi x1) + x2·sin(20 pi x2)\ns. t. -3.0 <= x1 <= 12.1\n        4.1 <= x2 <= 5.8\n种群初始化：\nimport random\nimport numpy as np\n\npop_size = 100\ndec_num = 2    #变量个数\ndec_min_val = (-3, 4.1)    #变量约束范围\ndec_max_val = (12.1, 5.8) \npop_x = np.zeros((pop_size, dec_num))  # 所有粒子的位置\npop_v = np.zeros((pop_size, dec_num))  # 所有粒子的速度\np_best = np.zeros((pop_size, dec_num))  # 个体经历的最佳位置\n\ndef init_population(pop_size, dec_num, dec_min_val, dec_max_val, pop_x, pop_v, p_best):\n    for i in range(pop_size):\n        for j in range(dec_num):\n            pop_x[i][j] = random.uniform(dec_min_val[j], dec_max_val[j])\n            pop_v[i][j] = random.uniform(0, 1)\n        p_best[i] = pop_x[i]  # p_best存储个体的历史最优\n迭代更新：\nimport random\nimport matplotlib.pyplot as plt\nfrom Initialization import init_population\n\nmax_gen = 100\nw = 0.4  # 自身权重因子\nc1 = 2  # 学习因子\nc2 = 2\ng_best = np.zeros((1, dec_num))  # 全局最佳个体的位置\npopobj = []\n\ndef fitness(s):    #个体适应值计算\n    x1 = s[0]\n    x2 = s[1]\n    y = 21.5 + x1 * math.sin(4 * math.pi * x1) + x2 * math.sin(20 * math.pi * x2)\n    return y\n\n\nif __name__ == '__main__':\n    init_population(pop_size, dec_num, dec_min_val, dec_max_val, pop_x, pop_v, p_best)\n    temp = -1    \n    #    ------------更新全局最优-------------\n    for i in range(pop_size):   \n        fit = fitness(p_best[i])\n        if fit > temp:\n            g_best = p_best[i]\n            temp = fit\n    #    ------------迭代优化-------------\n    for i in range(max_gen):\n        for j in range(pop_size):\n            #   ----------------更新个体位置和速度-----------------\n            pop_v[j] = w * pop_v[j] + c1 * random.uniform(0, 1) * (p_best[j] - pop_x[j]) + \\\n                        c2 * random.uniform(0, 1) * (g_best - pop_x[j])\n            pop_x[j] = pop_x[j] + pop_v[j]\n            for k in range(dec_num):    # 越界保护\n                if pop_x[j][k] < dec_min_val[k]:\n                    pop_x[j][k] = dec_min_val[k]\n                if pop_x[j][k] > dec_max_val[k]:\n                    pop_x[j][k] = dec_max_val[k]\n            #   -----------------更新p_best和g_best-----------------\n            if fitness(pop_x[j]) > fitness(p_best[j]):\n                p_best[j] = pop_x[j]\n            if fitness(pop_x[j]) > fitness(g_best):\n                g_best = pop_x[j]\n        popobj.append(fitness(g_best))\n        print(fitness(g_best))\n\n    # -------------------画图--------------------\n    plt.figure(1)\n    plt.title(\"Figure1\")\n    plt.xlabel(\"iterators\", size=14)\n    plt.ylabel(\"fitness\", size=14)\n    t = [t for t in range(0, 100)]\n    plt.plot(t, popobj, color='b', linewidth=3)\n    plt.show()\n结果和遗传算法差不多，但速度是快了，不需要像遗传算法那样交叉变异，另一方面粒子群的参数设置有点多。\n\n\nGithub源码地址：https://github.com/kugua233/P...\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}