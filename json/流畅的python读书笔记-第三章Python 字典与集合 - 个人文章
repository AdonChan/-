{"title": "流畅的python读书笔记-第三章Python 字典与集合 - 个人文章 ", "index": "python", "content": "字典和集合\n标准库里的所有映射类型都是利用 dict 来实现的只有可散列的数据类型才能用作这些映射里的键(值不用)\n可散列\n\n一个对象是可散列的\n它的散列值是不变的\n对象需要实现 __hash__() 方法\n可散列对象还要有 __qe__() 方法\n\n字典推导\nDIAL_CODES = [(86, 'China'), (91, 'India'), (1, 'United States'), (62, 'Indonesia') ]\n\ncountry_code = {country: code        for code, country in DIAL_CODES     }\n结果{'China': 86, 'India': 91, 'United States': 1, 'Indonesia': 62}\n常见的映射方法 page137\n用setdefault处理找不到的键\n##找对应的key,没有的话返回默认值\nmy_dict = {\"name\":\"longe\",\"age\":8}\nmy_dict.setdefault(\"namerrr\",\"default\")\n\nprint(my_dict)\n用 setdefault 只需要一次就可以完成整个操作。\ndefaultdict找不到键返回某种默认值\n\n在实例化一个 defaultdict 的时候\n这个可调用对象会在 getitem 碰到找不到的键的时候被调用，\n让 getitem 返回某种默认值。\n\n实现方式\ndefaultdict 里的 default_factory 只会在__getitem__ 里被调用\n比如，dd 是个 defaultdict，k 是个找不到的键，\n\ndd[k] 这个表达式会调用 default_factory 创造某个默认值，\ndd.get(k) 则会返回 None。\n\n原理所有这一切背后的功臣其实是特殊方法 __missing__。它会在defaultdict 遇到找不到的键的时候调用 default_factory\n__missing__这个方法\n自定义一个映射类型，更合适的策略其实是继承collections.UserDict 类\n只是为了演示 missing 是如何被dict.__getitem__ 调用的。\nclass StrKeyDict0(dict):\n    def __missing__(self, key):\n\n        if isinstance(key, str):\n            raise KeyError(key)\n            return self[str(key)]\n\n    def get(self, key, default=None):\n        try:\n            return self[key]\n        except KeyError:\n            return default\n\n    def __contains__(self, key):\n        return key in self.keys() or str(key) in self.keys()\n\nisinstance(key, str) 测试在上面的__missing__ 中是必需的但是如果 str(k) 不是一个存在的键，代码就会陷入无限递归。\n这是因为 missing 的最后一行中的 self[str(key)] 会调用 __getitem__，而这个 str(key) 又不存在，于是 __missing__又会被调用。\n精简版本\nimport collections\n\n\nclass StrKeyDict(collections.UserDict):\n    def __missing__(self, key):\n        if isinstance(key, str):\n            raise KeyError(key)\n        return self[str(key)]\n\n    def __contains__(self, key):\n        return str(key) in self.data\n\n    def __setitem__(self, key, item):\n        self.data[str(key)] = item\n\n\nsetitem 会把所有的键都转换成字符串。由于把具体的实现委托给了 self.data 属性，这个方法写起来也不难\n字典的变种\ncollections.OrderedDict\n这个类型在添加键的时候会保持顺序，因此键的迭代次序总是一致的。\ncollections.ChainMap\n该类型可以容纳数个不同的映射对象，然后在进行键查找操作的时候，这些对象会被当作一个整体被逐个查找，直到键被找到为止。\ncollections.Counter\n这个映射类型会给键准备一个整数计数器。每次更新一个键的时候都会增加这个计数器。\ncolllections.UserDict\n这个类其实就是把标准 dict 用纯 Python 又实现了一遍。跟 OrderedDict、ChainMap 和 Counter 这些开箱即用的类型不同，UserDict 是让用户继承写子类的。下面就来试试。\n集合论\n集合推导\nfrom unicodedata import name\n\naa = {chr(i) for i in range(32, 256) if 'SIGN' in name(chr(i), '')}\nprint(aa)\n集合的数学运算 page161\n字典空间\n因为 Python 会设法保证大概还有三分之一的表元是空的，所以在快要达\n到这个阈值的时候，原有的散列表会被复制到一个更大的空间里面。\n散列表原理\n\n为了获取 my_dict[search_key] 背后的值\nPython 首先会调用hash(search_key) 来计算 search_key 的散列值，\n把这个值最低的几位数字当作偏移量\n在散列表里查找表元（具体取几位，得看当前散列表的大小\n若找到的表元是空的，则抛出 KeyError 异常。\n若不是空的，则表元里会有一对 found_key:found_value。\n这时候 Python 会检验 search_key == found_key 是否为真，如 果它们相等的话，就会返回found_value。\n如果 search_key 和 found_key 不匹配的话，这种情况称为散列 冲突。\n\n原理图\n\n添加新元素和更新现有键值\n添加新元素和更新现有键值的操作几乎跟上面一样。只不过对于前者，在发现空表元的时候会放入一个新元素；对于后者，在找到相对应的表元后，原表里的值对象会被替换成新值。\n优劣\n字典浪费存储空间(不过没有几百万对象,内存好几个G不用考虑)dict 的实现是典型的空间换时间：字典类型有着巨大的内存开销\n键的次序取决于添加顺序\n当往 dict 里添加新键而又发生散列冲突的时候，新键可能会被安排存放到另一个位置。\n注意:\n无论何时往字典里添加新的键，Python 解释器都可能做出为字典扩\n容的决定。\n\n扩容导致的结果就是要新建一个更大的散列表，并把字典里已有的元素添加到新表里。\n这个过程中可能会发生新的散列冲突，导致新散列表中键的次序变化。\n要注意的是，上面提到的这些变化是否会发生以及如何发生，都依赖于字典背后的具体实现，\n因此你不能很自信地说自己知道背后发生了什么。\n如果你在迭代一个字典的所有键的过程中同时对字典进行修改，那么这个循环很有可\n\n能会跳过一些键——甚至是跳过那些字典中已经有的键。\n更新字典的主要使用姿势\n\n由此可知，不要对字典同时进行迭代和修改。\n如果想扫描并修改一个字典，最好分成两步来进行：\n首先对字典迭代，以得出需要添加的内容，把这些内容放在一个新字典里；\n迭代结束之后再对原有字典进行更新。\n\n小总结:\n\n标准库里的所有映射类型都是利用 dict 来实现\n只有可散列的数据类型才能用作这些映射里的键(值不用)\n字典推导\n用setdefault处理找不到的键\ndefaultdict找不到键返回某种默认值\n底层是 getitem 与__miss__调用实现的\n字典插入更新原理!!!\n\n其他\n大多数映射类型都提供了两个很强大的方法：setdefault 和\nupdate。\nsetdefault 方法可以用来更新字典里存放的可变值（比如列\n表），从而避免了重复的键搜索。\nupdate 方法则让批量更新成为可能，它可以用来插入新值或者更新已有键值对，它的参数可以是包含(key, value) 这种键值对的可迭代对象，或者关键字参数。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}