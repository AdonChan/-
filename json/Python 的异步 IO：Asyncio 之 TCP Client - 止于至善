{"title": "Python 的异步 IO：Asyncio 之 TCP Client - 止于至善 ", "index": "python,asyncio,http,tcp", "content": "关于 Asyncio 的其他文章：\n\nPython 的异步 IO：Asyncio 简介\nPython 的异步 IO：Aiohttp Client 代码分析\n\n如果不知道 Asyncio 是什么，先看「Asyncio 简介」那一篇。\n一个简单的 HTTP Server\n首先，为了便于测试，我们用 Python 内建的 http 模块，运行一个简单的 HTTP Server。\n新建一个目录，添加文件 index.html，内容为 Hello, World!（不是合法的 HTML 格式也没有关系），然后运行如下命令（Ubuntu 请用 python3）：\n$ python -m http.server\nServing HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...\n后面不同的 Client 实现，都会连接这个 Server：Host 为 localhost，Port 为 8000。\n所有的示例代码，import 语句一律从略。\nimport asyncio\n第一版\n第一版改写自 Python 官方文档里的 例子。Python 的例子是 Echo Client，我们稍微复杂一点，是 HTTP Client，都是 TCP。\nclass ClientProtocol(asyncio.Protocol):\n    def __init__(self, loop):\n        self.loop = loop\n\n    def connection_made(self, transport):\n        request = 'GET / HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n'\n        transport.write(request.encode())\n\n    def data_received(self, data):\n        print(data.decode())\n\n    def connection_lost(self, exc):\n        self.loop.stop()\n\nasync def main(loop):\n    await loop.create_connection(\n        lambda: ClientProtocol(loop), 'localhost', 8000)\n\nloop = asyncio.get_event_loop()\nloop.run_until_complete(main(loop))\nloop.run_forever()\nTCP 连接由 loop.create_connection() 创建，后者需要一个 Protocol 工厂，即 lambda: ClientProtocol(loop)。Protocol 提供了 connection_made()，data_received()， connection_lost() 等接口，这些接口就像回调函数一样，会在恰当的时候被调用。我们在 connection_made() 中，通过参数 transport 发送一个 HTTP GET 请求，随后在 data_received() 里，将收到 HTTP 应答。当 connection_lost() 被调用时，表示 Server 已经断开连接。\n运行结果：\nHTTP/1.0 200 OK\nServer: SimpleHTTP/0.6 Python/3.6.3\nDate: Mon, 04 Dec 2017 06:11:52 GMT\nContent-type: text/html\nContent-Length: 13\nLast-Modified: Thu, 30 Nov 2017 05:37:31 GMT\n\n\nHello, World!\n这就是一个标准的 HTTP 应答，包含 Status Line，Headers 和 Body。\n值得注意的是，loop 其实运行了两遍：\nloop.run_until_complete(main(loop))  # 第一遍\nloop.run_forever()  # 第二遍\n如果没有 run_forever()，在收到数据之前，loop 可能就结束了。协程 main() 只是创建好连接，随后 run_until_complete() 自然也就无事可做而终。\n加了  run_forever() 后，data_received() 等便有了被调用的机会。但是也有问题，loop 一直在跑，程序没办法结束，所以才在 connection_lost() 里主动停止 loop：\n    def connection_lost(self, exc):\n        self.loop.stop()\n第二版：ClientSession\n第一版在 connection_made() 中 hard code 了一个 HTTP GET 请求，灵活性较差，以后必然还有 POST 等其他 HTTP 方法需要支持，所以有必要新增一个 ClientSession 类，来抽象客户端的会话。于是，HTTP 请求的发送，便从 connection_made() 挪到了 ClientSession.get()。\nClientSession 应该为每一个 HTTP 方法提供一个相应的方法，比如 post，put 等等，虽然我们只考虑  HTTP GET。\nclass ClientProtocol(asyncio.Protocol):\n    def __init__(self, loop):\n        self.loop = loop\n        self.transport = None\n\n    def connection_made(self, transport):\n        self.transport = transport\n\n    def data_received(self, data):\n        print(data.decode())\n\n    def connection_lost(self, exc):\n        self.loop.stop()\n\nclass ClientSession:\n    def __init__(self, loop):\n        self._loop = loop\n\n    async def get(self, url, host, port):\n        transport, protocol = await self._loop.create_connection(\n            lambda: ClientProtocol(loop), host, port)\n\n        request = 'GET {} HTTP/1.1\\r\\nHost: {}\\r\\n\\r\\n'.format(url, host)\n        transport.write(request.encode())\n首先，ClientProtocol 新增了一个属性 transport，是在 connection_made() 时保存下来的，这样在 ClientSession 里才能通过它来发送请求。\n第三版：去掉 run_forever()\n\n第三版的目的是：去掉 run_forever() 。\nclass ClientProtocol(asyncio.Protocol):\n    def __init__(self, loop):\n        self.loop = loop\n        self.transport = None\n        self._eof = False  # 有没有收到 EOF\n        self._waiter = None  # 用来等待接收数据的 future\n\n    def connection_made(self, transport):\n        self.transport = transport\n\n    def data_received(self, data):\n        print(data.decode())\n\n    def eof_received(self):\n        self._eof = True\n        self._wakeup_waiter()\n\n    def connection_lost(self, exc):\n        pass  # 不再调用 self.loop.stop()\n\n    async def wait_for_data(self):\n        assert not self._eof\n        assert not self._waiter\n\n        self._waiter = self.loop.create_future()\n        await self._waiter\n        self._waiter = None\n\n    def _wakeup_waiter(self):\n        waiter = self._waiter\n        if waiter:\n            self._waiter = None\n            waiter.set_result(None)\n\nclass ClientSession:\n    def __init__(self, loop):\n        self._loop = loop\n\n    async def get(self, url, host, port):\n        transport, protocol = await self._loop.create_connection(\n            lambda: ClientProtocol(loop), host, port)\n\n        request = 'GET {} HTTP/1.1\\r\\nHost: {}\\r\\n\\r\\n'.format(url, host)\n        transport.write(request.encode())\n\n        # 等待接收数据。\n        await protocol.wait_for_data()\n协程 main() 保持不变，但是 loop.run_forever() 已被剔除：\nloop = asyncio.get_event_loop()\nloop.run_until_complete(main(loop))\n# 不再需要 loop.run_forever()\nHTTP 请求发送之后，继续异步等待（await）数据的接收，即 protocol.wait_for_data()。这个等待动作，是通过往 loop 里新增一个  future 来实现的：\n    async def wait_for_data(self):\n        # ...\n        self._waiter = self.loop.create_future()\n        await self._waiter\n        self._waiter = None\nself._waiter 就是这个导致等待的 future，它会保证 loop 一直运行，直到数据接收完毕。eof_received() 被调用时，数据就接收完毕了（EOF 的意思不用多说了吧？）。\n    def eof_received(self):\n        self._eof = True\n        self._wakeup_waiter()\n_wakeup_waiter() 的作用是结束那个导致等待的 future，这样 loop 也就可以结束了：\n    def _wakeup_waiter(self):\n        waiter = self._waiter\n        if waiter:\n            self._waiter = None\n            # 结束 waiter future，以便 loop 结束。\n            waiter.set_result(None)\n第四版：Reader\n在 data_received() 里直接输出 HTTP 的应答结果，实在算不上什么完美的做法。\n    def data_received(self, data):\n        print(data.decode())\n为了解决这一问题，我们引入一个 Reader 类，用来缓存收到的数据，并提供「读」的接口给用户。\n首先，Protocol 被简化了，前一版引入的各种处理，都转交给了 Reader。\nclass ClientProtocol(asyncio.Protocol):\n    def __init__(self, loop, reader):\n        self.loop = loop\n        self.transport = None\n        self._reader = reader\n\n    def connection_made(self, transport):\n        self.transport = transport\n\n    def data_received(self, data):\n        self._reader.feed(data)  # 转交给 Reader\n\n    def eof_received(self):\n        self._reader.feed_eof()  # 转交给 Reader\n\n    def connection_lost(self, exc):\n        pass\n下面是 ClientSession.get() 基于 Reader 的实现：\nclass ClientSession:\n    async def get(self, url, host, port):\n        reader = Reader(self._loop)\n        transport, protocol = await self._loop.create_connection(\n            lambda: ClientProtocol(loop, reader), host, port)\n        # 发送请求，代码从略...\n        data = await reader.read()\n        print(data.decode())\nReader 本身是从上一版的 Protocol 抽取出来的，唯一不同的是，接收的数据被临时放在了一个 bytearray 缓存里。\nclass Reader:\n    def __init__(self, loop):\n        self._loop = loop\n        self._buffer = bytearray()  # 缓存\n        self._eof = False\n        self._waiter = None\n\n    def feed(self, data):\n        self._buffer.extend(data)\n        self._wakeup_waiter()\n\n    def feed_eof(self):\n        self._eof = True\n        self._wakeup_waiter()\n\n    async def read(self):\n        if not self._buffer and not self._eof:\n            await self._wait_for_data()\n            \n        data = bytes(self._buffer)\n        del self._buffer[:]\n        return data\n\n    async def _wait_for_data(self):\n        assert not self._eof\n        assert not self._waiter\n\n        self._waiter = self._loop.create_future()\n        await self._waiter\n        self._waiter = None\n\n    def _wakeup_waiter(self):\n        waiter = self._waiter\n        if waiter:\n            self._waiter = None\n            waiter.set_result(None)\n稍微解释一下 read()，比较重要的是开始的一句判断：\n        # 如果缓存为空，并且 EOF 还没收到，那就（继续）等待接收数据。\n        if not self._buffer and not self._eof:\n            # read() 会停在这个地方，直到 feed() 或 feed_eof() 被调用，\n            # 也就是说有数据可读了。\n            await self._wait_for_data()\n接下来就是把缓存倒空：\n        data = bytes(self._buffer)\n        del self._buffer[:]\n运行一下，不难发现，ClientSession.get() 里读数据的那一句是有问题的。\n        data = await reader.read()\n收到的 data 并不是完整的 HTTP 应答，可能只包含了 HTTP 的 Headers，而没有 Body。\n一个 HTTP 应答，Server 端可能分多次发送过来。比如这个测试用的 Hello World Server，Headers 和 Body 就分了两次发送，也就是说 data_received() 会被调用两次。\n之前我们在 eof_received() 里才唤醒 waiter（_wakeup_waiter()），现在在 data_received() 里就唤醒了，于是第一次数据收完， waiter 就结束了，loop 也便跟着结束。\n为了读到完整的 HTTP 应答，方法也很简单，把 read() 放在循环里：\n        blocks = []\n        while True:\n            block = await reader.read()\n            if not block:\n                break\n            blocks.append(block)\n        data = b''.join(blocks)\n        print(data.decode())\n每一次 read()，如果缓存为空，并且 EOF 还没收到的话，就会再次创建 waiter，放到 loop 里，继续等待接收数据。\n这个循环显然应该交给 Reader 处理，对 ClientSession 需保持透明。\nclass Reader:\n    async def read(self):\n        blocks = []\n        while True:\n            block = await self._read()\n            if not block:\n                break\n            blocks.append(block)\n        data = b''.join(blocks)\n        return data\n\n    async def _read(self):\n        if not self._buffer and not self._eof:\n            await self._wait_for_data()\n            \n        data = bytes(self._buffer)\n        del self._buffer[:]\n        return data\n最后，原来的 read() 重命名为 _read()，新的 read() 在循环中反复调用 _read()，直到无数据可读。ClientSession 这边直接调用新的 read() 即可。\n第五版：Writer\n到目前为止，发送 HTTP 请求时，都是直接调用较为底层的 transport.write()：\n    async def get(self, url, host, port):\n        # ...\n        transport.write(request.encode())\n可以把它封装在 Writer 中，与 Reader 的做法类似，但是 Writer 要简单得多：\nclass Writer:\n    def __init__(self, transport):\n        self._transport = transport\n\n    def write(self, data):\n        self._transport.write(data)\n然后在 ClientSession.get() 中创建 Writer：\n    async def get(self, url, host, port):\n        reader = Reader(self._loop)\n        transport, protocol = await self._loop.create_connection(\n            lambda: ClientProtocol(loop, reader), host, port)\n\n        writer = Writer(transport)\n        request = 'GET {} HTTP/1.1\\r\\nHost: {}\\r\\n\\r\\n'.format(url, host)\n        writer.write(request.encode())\n        # ...\n对 ClientSession 来说，只需知道 Reader 和 Writer 就足够了，所以不妨提供一个函数 open_connection()，直接返回 Reader 和 Writer。\nasync def open_connection(host, port, loop):\n    reader = Reader(loop)\n    protocol = ClientProtocol(loop, reader)\n    transport, _ = await loop.create_connection(lambda: protocol, host, port)\n    writer = Writer(transport)\n    return reader, writer\n然后 ClientSession 就可以简化成这样：\nclass ClientSession:\n    async def get(self, url, host, port):\n        reader, writer = await open_connection(host, port, self._loop)\n        # ...\n第六版：Asyncio Streams\n其实 Asyncio 已经提供了 Reader 和 Writer，详见 官方文档。\n下面以 Asyncio Streams 实现 ClientSession.get()：\nclass ClientSession:\n    async def get(self, url, host, port):\n        reader, writer = await asyncio.open_connection(\n            host, port, loop=self._loop)\n\n        request = 'GET {} HTTP/1.1\\r\\nHost: {}\\r\\n\\r\\n'.format(url, host)\n        writer.write(request.encode())\n\n        data = await reader.read(-1)\n        print(data.decode())\n        writer.close()\nasyncio.open_connection() 就相当于我们的 open_connection()。Reader 和 Writer 也都类似，只是复杂了一些。\n全文完\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "6"}