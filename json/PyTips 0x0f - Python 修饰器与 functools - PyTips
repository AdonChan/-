{"title": "PyTips 0x0f - Python 修饰器与 functools - PyTips ", "index": "pytips,python3.5,python", "content": "项目地址：https://git.io/pytips\nPython 的修饰器是一种语法糖（Syntactic Sugar），也就是说：\n@decorator\n@wrap\ndef func():\n    pass\n是下面语法的一种简写：\ndef func():\n    pass\nfunc = decorator(wrap(func))\n关于修饰器的两个主要问题：\n\n修饰器用来修饰谁\n谁可以作为修饰器\n\n修饰函数\n修饰器最常见的用法是修饰新定义的函数，在 0x0d 上下文管理器中提到上下文管理器主要是为了更优雅地完成善后工作，而修饰器通常用于扩展函数的行为或属性：\ndef log(func):\n    def wraper():\n        print(\"INFO: Starting {}\".format(func.__name__))\n        func()\n        print(\"INFO: Finishing {}\".format(func.__name__))\n    return wraper\n\n@log\ndef run():\n    print(\"Running run...\")\nrun()\nINFO: Starting run\nRunning run...\nINFO: Finishing run\n\n修饰类\n除了修饰函数之外，Python 3.0 之后增加了对新定义类的修饰（PEP 3129），但是对于类别属性的修改可以通过 Metaclasses 或继承来实现，而新增加的类别修饰器更多是出于 Jython 以及 IronPython 的考虑，但其语法还是很一致的：\nfrom time import sleep, time\ndef timer(Cls):\n    def wraper():\n        s = time()\n        obj = Cls()\n        e = time()\n        print(\"Cost {:.3f}s to init.\".format(e - s))\n        return obj\n    return wraper\n@timer\nclass Obj:\n    def __init__(self):\n        print(\"Hello\")\n        sleep(3)\n        print(\"Obj\")\no = Obj()\nHello\nObj\nCost 3.005s to init.\n\n类作为修饰器\n上面两个例子都是以函数作为修饰器，因为函数才可以被调用（callable） decorator(wrap(func))。除了函数之外，我们也可以定义可被调用的类，只要添加 __call__ 方法即可：\nclass HTML(object):\n    \"\"\"\n        Baking HTML Tags!\n    \"\"\"\n    def __init__(self, tag=\"p\"):\n        print(\"LOG: Baking Tag <{}>!\".format(tag))\n        self.tag = tag\n    def __call__(self, func):\n        return lambda: \"<{0}>{1}</{0}>\".format(self.tag, func(), self.tag)\n\n@HTML(\"html\")\n@HTML(\"body\")\n@HTML(\"div\")\ndef body():\n    return \"Hello\"\n\nprint(body())\nLOG: Baking Tag <html>!\nLOG: Baking Tag <body>!\nLOG: Baking Tag <div>!\n<html><body><div>Hello</div></body></html>\n\n传递参数\n在实际使用过程中，我们可能需要向修饰器传递参数，也有可能需要向被修饰的函数（或类）传递参数。按照语法约定，只要修饰器 @decorator 中的 decorator 是可调用即可，decorator(123) 如果返回一个新的可调用函数，那么也是合理的，上面的 @HTML('html') 即是一例，下面再以 flask 的路由修饰器为例说明如何传递参数给修饰器：\nRULES = {}\ndef route(rule):\n    def decorator(hand):\n        RULES.update({rule: hand})\n        return hand\n    return decorator\n@route(\"/\")\ndef index():\n    print(\"Hello world!\")\n\ndef home():\n    print(\"Welcome Home!\")\nhome = route(\"/home\")(home)\n\nindex()\nhome()\nprint(RULES)\nHello world!\nWelcome Home!\n{'/': <function index at 0x10706f730>, '/home': <function home at 0x10706f8c8>}\n\n向被修饰的函数传递参数，要看我们的修饰器是如何作用的，如果像上面这个例子一样未执行被修饰函数只是将其原模原样地返回，则不需要任何处理（这就把函数当做普通的值一样看待即可）：\n@route(\"/login\")\ndef login(user = \"user\", pwd = \"pwd\"):\n    print(\"DB.findOne({{{}, {}}})\".format(user, pwd))\nlogin(\"hail\", \"python\")\nDB.findOne({hail, python})\n\n如果需要在修饰器内执行，则需要稍微变动一下：\ndef log(f):\n    def wraper(*args, **kargs):\n        print(\"INFO: Start Logging\")\n        f(*args, **kargs)\n        print(\"INFO: Finish Logging\")\n    return wraper\n\n@log\ndef run(hello = \"world\"):\n    print(\"Hello {}\".format(hello))\nrun(\"Python\")\nINFO: Start Logging\nHello Python\nINFO: Finish Logging\n\nfunctools\n由于修饰器将函数（或类）进行包装之后重新返回：func = decorator(func)，那么有可能改变原本函数（或类）的一些信息，以上面的 HTML 修饰器为例：\n@HTML(\"body\")\ndef body():\n    \"\"\"\n        return body content\n    \"\"\"\n    return \"Hello, body!\"\nprint(body.__name__)\nprint(body.__doc__)\nLOG: Baking Tag <body>!\n<lambda>\nNone\n\n因为 body = HTML(\"body\")(body) ，而 HTML(\"body\").__call__() 返回的是一个 lambda 函数，因此 body 已经被替换成了 lambda，虽然都是可执行的函数，但原来定义的 body 中的一些属性，例如 __doc__/__name__/__module__ 都被替换了（在本例中__module__没变因为都在同一个文件中）。为了解决这一问题 Python 提供了 functools 标准库，其中包括了 update_wrapper 和 wraps 两个方法（源码）。其中 update_wrapper 就是用来将原来函数的信息赋值给修饰器中返回的函数：\nfrom functools import update_wrapper\n\"\"\"\nfunctools.update_wrapper(wrapper, wrapped[, assigned][, updated])\n\"\"\"\n\n\nclass HTML(object):\n    \"\"\"\n        Baking HTML Tags!\n    \"\"\"\n    def __init__(self, tag=\"p\"):\n        print(\"LOG: Baking Tag <{}>!\".format(tag))\n        self.tag = tag\n    def __call__(self, func):\n        wraper = lambda: \"<{0}>{1}</{0}>\".format(self.tag, func(), self.tag)\n        update_wrapper(wraper, func)\n        return wraper\n@HTML(\"body\")\ndef body():\n    \"\"\"\n        return body content!\n    \"\"\"\n    return \"Hello, body!\"\nprint(body.__name__)\nprint(body.__doc__)\nLOG: Baking Tag <body>!\nbody\n\n        return body content!\n    \n\n有趣的是 update_wrapper 的用法本身就很像是修饰器，因此 functools.wraps 就利用 functools.partial（还记得函数式编程中的偏应用吧！）将其变成一个修饰器：\nfrom functools import update_wrapper, partial\n\ndef my_wraps(wrapped):\n    return partial(update_wrapper, wrapped=wrapped)\n\ndef log(func):\n    @my_wraps(func)\n    def wraper():\n        print(\"INFO: Starting {}\".format(func.__name__))\n        func()\n        print(\"INFO: Finishing {}\".format(func.__name__))\n    return wraper\n\n@log\ndef run():\n    \"\"\"\n    Docs' of run\n    \"\"\"\n    print(\"Running run...\")\nprint(run.__name__)\nprint(run.__doc__)\nrun\n\n    Docs' of run\n    \n\n欢迎关注公众号 PyHub！\n\n参考\nPython修饰器的函数式编程\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "4"}