{"title": "Python学习之路17-Django入门 - VPointer ", "index": "python,django", "content": "《Python编程：从入门到实践》笔记。从本篇开始将是该书的最后一个项目，将用3篇文章来介绍Django的基础。完成一个“学习笔记”的小网站。\n1. 前言\n在本篇中，我们将：\n\n用Django来开发一个名为“学习笔记”(Learning Log)的项目；\n为这个项目制定规范，然后为应用程序使用的数据定义模型；\n使用Django的管理系统来输入一些初试数据，再学习编写视图和模板，让Django能够为我们的网站创建网页。\n\n不过在开始之前，请先新建一个虚拟环境并安装Django。如果没有虚拟环境，通过pip安装的所有库都会保存到python的site-packages目录下。开发多个项目时，都会用同一个python，而某些项目并不需要其中的所有第三方库，但如果将这些不需要库的删除，又会影响到其他项目。而且，如果A项目需要Django2.0.4，B项目需要Django2.0.0，这该怎么办？此时就需要虚拟环境。它其实就相当于一个新的文件夹，将新项目与其他项目隔离，本项目的库不与其他项目的库相关联，类似于操作系统的多用户概念。\n如果使用的是Python 3，可以使用命令：\npython -m venv ll_env\n如果该命令不成功，可能是没有安装virtualenv模块：\npip install virtualenv\n然后创建并激活虚拟环境：\nvirtualenv ll_env\n\n# linux:\nsource ll_env/bin/activate\n# windows:\nll_env\\Scripts\\activate\n\n# 停用：\ndeactivate\n管理虚拟环境的库还有很多，有兴趣的话可以到网上搜一搜。\n如果你使用的是新版的PyCharm，那么它在新建项目的时候默认就会创建新的虚拟环境。\n激活虚拟环境后就可以安装Django了：\npip install django\n2. 建立项目\n2.1 在Django中创建项目\n2.1.1 生成项目\n在虚拟环境中执行如下命令：\n# 主要最后有个实心句号！\n# 这个句点让新项目使用合适的目录结构，这样开发完成后可以轻松地将应用程序部署到服务器\ndjango-admin startproject learning_log .\n执行上述命令后，将多出一个manage.py文件和一个learning_log文件夹，当然还有本身的一个ll_env文件夹。\n而在learning_log文件夹中，又有四个文件：__init__.py，settings.py，urls.py，wsgi.py。\n\n\nmanage.py是一个简单的程序，它接收命令并将其交给Django的相关部分去运行；\n\nsettings.py指定Django如何与你的系统交互以及如何管理项目，其实就是配置文件；\n\nurls.py告诉Django应创建哪些网页来响应浏览器请求；\n\nwsgi.py是web server gateway interface(Web服务器网关接口)的缩写，帮助Django提供它创建的文件。\n\n至于__init__.py，它是个空文件，Python的每个模块下必须要有这个文件。\n2.1.2 创建数据库\nDjango将大部分与项目相关的信息都存储在数据库中，所有还需要创建一个供Django使用的数据库。依然是在虚拟环境下执行如下命令：\npython manage.py migrate\n在PyCharm中的话，可以通过点击工具栏Tools中的Run manage.py Task（Ctrl+Alt+R），在弹出的命令行中直接输入原命令中manage.py后面的部分，后面的命令也可以这样执行（[appname]是自动提示）。\n\n\"migrate\"这个单词其实是迁移的意思，并不是“创建(create)”。之所以使用这个词，是因为一般将修改数据库的过程称为迁移数据库（笔者数据库学得渣，这段解释直接从书里照搬的，希望哪位大神在留言区解释一波）。如果是刚创建的项目，并且第一次执行，将会得到如下输出：\nOperations to perform:\n  Apply all migrations: admin, auth, contenttypes, sessions\nRunning migrations:\n  Applying contenttypes.0001_initial... OK\n  -- snip --\n  Applying sessions.0001_initial... OK\n从第2行结果可以看出，Django将创建和修改数据库看做是对数据库的迁移，Apply all migrations确保数据库结构与当前代码匹配（比如你修改了类的结构，添加了属性，这就相当于修改了数据表）。\n执行命令后，项目的根目录下会多出一个名为db.sqlite3的数据库文件。SQLite是一种使用单个文件的轻量级数据库，常用于开发简单应用程序，它让你不用太关注数据库管理的问题。\n2.1.3 运行项目\n依然在项目的虚拟环境下输入如下命令：\npython manage.py runserver\n得到如下输出：\nPerforming system checks...\n\nSystem check identified no issues (0 silenced).\nApril 21, 2018 - 20:46:48\nDjango version 2.0.4, using settings 'learning_log.settings'\nStarting development server at http://127.0.0.1:8000/\nQuit the server with CTRL-BREAK.\n现在在浏览器中地址栏输入localhost:8000 (或者127.0.0.1:8000)，将得到如下页面：\n\n这是最新版的Django的默认启动界面。\n2.2 创建应用程序（APP）\n2.2.1 创建模型\nDjango项目由一系列应用程序组成，它们协同工作，让项目成为一个整体。我们在项目根目录下执行如下命令，创建一个名为learning_logs的应用程序：\npython manage.py startapp learning_logs\n执行命令后，根目录下会多出一个名为learning_logs的文件夹（笔者第一次接触Django的时候发现这玩意儿居然叫做APP，和平时用的手机上的各种APP相差也太大了，很不适应），它的结构如下：\n\n重要的是其中的models.py、admin.py和views.py文件，我们将使用models.py来定义我们要在应用程序中管理的数据。另外两个文件稍后再介绍。\n打开models.py文件，发现其中自带两行代码：\nfrom django.db import models\n\n# Create your models here.\n在代码层面，模型就是一个类，和之前的文章中的类一样，包含属性和方法。下面创建一个“主题”类：\nfrom django.db import models\n\nclass Topic(models.Model):\n    \"\"\"用户学习的主题\"\"\"\n    text = models.CharField(max_length=200)\n    date_added = models.DateTimeField(auto_now_add=True)\n\n    def __str__(self):\n        \"\"\"返回模型的字符串表示\"\"\"\n        return self.text\nModel类是Django中的一个定义了模型基本功能的类。Topic类只有两个属性text和date_added。模型中如CharField，DateTimeField这些字段还有很多，Django自动根据数据库的不同调用不同的SQL语句创建数据表，即屏蔽底层数据库的差异。\n同时还重写了__str__()方法，之所以说“重写”是因为每个类都有这个方法，当直接将一个类A放入print()之类的语句中时，就会调用A的__str__()方法。如果没有重写这个方法，一般会输出这个对象的内存地址之类的，大家可以苏随便写个类试一试。\n2.2.2 激活模型\n使用模型前，必须将APP包含到项目中，打开settings.py文件，将APP添加到INSTALLED_APPS中：\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    # 添加你的app，上面的都是自带的\n    \"learning_logs.apps.LearningLogsConfig\",\n]\n这里有个需要注意的地方，由于这本书的2016年出版的，当时Django还没有到达2.0版本，所以在书中，注册APP是这样写的：\nINSTALLED_APPS = [\n    -- snip --\n    # 添加你的app，上面的都是自带的\n    \"learning_logs\",\n]\n现在官方文档中是按照第一种方式注册APP，并且，最新版的Django在新建APP后，在APP的目录下还多了一个apps.py文件，该文件默认有一个根据APP名称创建的类，此处为LearningLogsConfig，内容如下：\nfrom django.apps import AppConfig\n\nclass LearningLogsConfig(AppConfig):\n    name = 'learning_logs'\n回到主线，在终端中输入：\npython manage.py makemigrations learning_logs\n\n# 输出\nMigrations for 'learning_logs':\n  learning_logs\\migrations\\0001_initial.py\n    - Create model Topic\nmakemigrations让Django确定该如何修改数据库，使其能够存储与我们定义的新模型相关联的数据。从输出可以看出，在APP目录下的migrations文件夹中创建了一个名为0001_initial.py的迁移文件，该文件将在数据库中为模型Topic创建一个表。\n最后，在命令行中输入:\npython manage.py migrate\n\n# 输出：\nRunning migrations:\n  Applying learning_logs.0001_initial... OK\n总结：每当需要修改模型时，都采取如下三个步骤：修改models.py，对你的APP调用makemigrations，让Django迁移项目migrate。\n2.2.3 Django管理网站\nDjango自带管理后台。首先为网站创建一个超级用户。在中断输入：\npython manage.py createsuperuser\n随后按提示输入用户名和密码即可，邮箱地址可以留空（直接回车）。\nDjango自动在管理网站中添加一些模型，如User和Group，但对于我们创建的模型，必须手工注册。\n注意前面提到的和models.py在同一目录的admin.py文件，这就是注册自行编写的模型的地方，在该文件中加入后两行代码：\n# 第一行代码是自带的\nfrom django.contrib import admin\nfrom learning_logs.models import Topic\n\nadmin.site.register(Topic)\n现在登录Django自带的网站管理页面 http://localhost:8000/admin/ 登录刚才创建的超级用户和密码后将出现如下界面：\n\n在这里你可以管理用户和组，以及和模型Topic相关的数据。\n现在先手动添加两个主题：点击Add创建Chess和Rock Climbing。\n\n2.2.4 定义模型Entry\n为使能在每个主题下添加条目，需要定义Entry模型，Entry与Topic的关系是多对一。同样是在models.py中添加模型：\nfrom django.db import models\n\nclass Topic(models.Model):\n    -- snip --\n    \nclass Entry(models.Model):\n    \"\"\"学到的有关某个主题的具体知识\"\"\"\n    # 由于和“主题”是多对一的关系，所以“主题”是“条目”的外键\n    topic = models.ForeignKey(Topic, on_delete=models.CASCADE)\n    text = models.TextField()\n    date_added = models.DateTimeField(auto_now_add=True)\n\n    class Meta:\n        verbose_name_plural = \"entries\"\n\n    def __str__(self):\n        \"\"\"返回模型的字符串表示\"\"\"\n        # 由于条目包含的文本可能很长，只显示前50个字符\n        return self.text[:50] + \"...\"\n注意其中嵌套了一个Meta类，它用于管理模型的额外信息。它让我们能够设置一个特殊属性，让Django在需要时使用Entries来表示多个条目。如果没有这个类，Django将使用Entrys来表示多个条目(保证英语语法正确......不得不说，本书作者还是很细心的)。\n添加了新模型，所以需要再次迁移数据库，过程就是前面讲的三个步骤中的后两步。然后在admin.py中注册Entry。\n为了让这个网站有一些初试数据，添加三个条目：两个Chess的，一个Rock Climbing的。在管理页面中点击Entries的Add按钮，你将看到一个下拉列表，用于选择Topic，还有个文本框，用于输入内容。随便输入一点内容就可以，具体内容不再详细列出。\n2.2.5 Django shell\n输入一些数据后，可通过交互式终端会话以编程方式查看这些数据。这种交互式环境称为Django shell，常用语测试项目和排除故障。以下是在shell中的一些操作：\n(ll_env)learning_log$ python manage.py shell   # 启动shell\n>>> from learning_logs.models import Topic\n>>> Topic.objects.all()   # 获得模型Topic的所有实例\n<QuerySet [<Topic: Chess>, <Topic: Rock Climbing>]>  # 返回了一个查询集QuerySet\n\n>>> topics = Topic.objects.all()  # 查询每个Topic对象\n>>> for topic in topics:\n...     print(topic.id, topic)\n...\n1 Chess\n2 Rock Climbing\n\n>>> t = Topic.objects.get(id=1) # 根据id查看Chess模型的具体内容\n>>> t.text\n'Chess'\n>>> t.date_added\ndatetime.datetime(2018, 4, 22, 2, 4, 3, 723045, tzinfo=<UTC>)\n\n>>> t.entry_set.all()  # 查看该主题下的所有条目，通过外键查询，进行了人为换行\n<QuerySet [<Entry: The opening is the first part of the game, roughly...>,\n<Entry: In the opening phase of the game, it's important t...>]>\n为了通过外键获取数据，注意查询时的语法：模型小写名称+下划线+set，如第19行代码。编写用户可请求的网页时将使用这样的语法。如果代码在shell中的行为符合预期，那么它们在项目文件中也能正确工作。\n3. 创建网页：学习笔记主页\n这一部分，书中内容和新版的Django出入比较多。\n3.1 映射URL\nDjango创建网页的过程通常分三个阶段：定义URL、编写视图和编写模板。\nURL模式描述了URL是如何设计的，让Django知道如何将浏览器请求与网站URL匹配，以确定返回哪个网页。每个URL都被映射到特定的视图——视图函数获取并处理网页所需的数据。视图函数通常调用一个模板，后者生成浏览器能够理解的网页。\n目前，基础URL(http://localhost:8000/ )返回默认的Django页面，现在修改这个映射，将其映射到我们自己编写的主页。\n打开learning_log文件夹中的urls.py，将看到如下内容：\nfrom django.contrib import admin\nfrom django.urls import path\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n]\n\n# 书中的内容和实际的内容有些出入，以下是书中内容：\n# 新版Django简化了URL路由写法\n# from django.conf.urls import include, url\n# from django.contrib import admin\n# \n# from django.conf.urls import include, url\n# from django.contrib import admin\n#\n# urlpatterns = [\n#    url(r'^admin/', include(admin.site.urls)),\n# ]\n变量urlpatterns包含项目中的APP的URL，admin.site.urls模块定义了可在管理网站中请求的所有URL。现在添加代码：\nfrom django.contrib import admin\nfrom django.urls import path, include\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path(\"\", include(\"learning_logs.urls\")),\n    # 书中代码：\n    # url(r\"\", include(\"learning_logs.urls\", namespace=\"learning_logs\")),\n]\n注意：书中在此处的include()函数中传入了关键字参数namespace=\"learning_logs\"，但在新版中，命名空间(namespace)是在APP的urls.py中设置的：在urlpatterns变量前新建一个值为\"learning_logs\"的app_name变量。\nnamespace让learning_logs的URL同项目中的其他URL区分开，对项目进行扩展时，这样做十分有用。\n还需要在learning_logs中创建另一个urls.py文件：\n\"\"\"定义learning_logs的URL模式\"\"\"\nfrom django.urls import path\n# 从当前的urls.py模块所在的文件夹中导入视图\nfrom . import views\n\n# 该变量包含该APP中可请求的网页\nurlpatterns = [\n    # 主页\n    path(\"\", views.index, name=\"index\"),\n]\npath()的第一个参数是正则表达式，第二个参数是要调用的视图函数（当请求的URL和第一个参数匹配时调用），第三个参数为这个URL模式指定一个名字，相当于将这个模式保存在变量index中，以后每当需要提供这个主页的连接时都使用这个名字，而不用再编写URL。\n3.2 编写视图\n视图函数接收请求中的信息，准备好生成网页所需的数据，再将这些数据发送给浏览器，在发送之前，还套用了网页的模板（如果有模板的话）。\n当我们在创建APP时，它的文件夹中有一个views.py文件，该文件默认只有一个导入语句，导入了函数render()，现在编写这个文件：\nfrom django.shortcuts import render\n\ndef index(request):\n    \"\"\"学习笔记主页\"\"\"\n    # 将请求的数据套用到模板中，然后返回给浏览器\n    # 第一个参数是原始请求对象，第二是可用于创建网页的模板\n    return render(request, \"learning_logs/index.html\")\n3.3 编写模板\n模板定义了网页的结构，指定了网页时什么样的。每当网页被请求时，Django将填入相关的数据。模板中能访问视图提供的任何数据。\n现在创建上面代码中的index.html模板：在learning_logs文件夹中新建一个templates文件夹，再在这个文件夹中新建一个和APP同名的文件夹，即learning_logs文件夹，最后，在这个learning_logs文件夹中新建index.html文件。看起来好像有点多余，但这是Django能够解析的目录结构。index.html文件的内容如下：\n<p>Learning Log</p>\n\n<p>Learning Log helps you keep track of your learning, \n    for any topic your're learning about.</p>\n现在当你访问http://localhost:8000 时，将看到如下主页：\n\n创建网页的过程看起来可能很复杂，实际上这就是一个简单的MVC（Model，View，Controller）模型，但在Django中被称为MVT（Model，View，Template）\n\n这种方式使代码结构清晰，修改方便，也让我们能各司其职，比如，数据库专家就专注于Model，程序员专注于View，Web设计人员专注于Template。\n4. 创建其他网页\n我们继续扩展我们的项目。创建两个用于显示数据的网页，其中给一个列出所有的主题，另一个显示特定主题的所有条目。对于每个网页都指定URL模式，编写一个视图函数，并编写一个模板。但这么做之前，我们先创建一个父模板，项目中的其他模板都将继承它。\n4.1 模板继承\n4.1.1 父模板base.html\n<p>\n  <a href=\"{% url 'learning_logs:index' %}\">Learning Log</a>\n</p>\n\n{% block content %}{% endblock content %}\n该文件存储在index.html所在的目录中。该文件包含所有页面都有的元素，其他模板继承自它。目前为止，所有页面共有的元素还只有顶端的标题。\n我们将这个标题设置为到主页的链接。为了创建这个链接，使用了模板标签(花括号加百分号的组合)，其中learning_logs是项目的命名空间，index就是这个项目主页的URL模式名（注意翻看前面小节的代码）。\n还创建了一个块标签(block)，这个块名为content，是一个占位符，其中包含的信息将由子模板指定。\n4.1.2 子模板\n从新编写index.html，使其继承base.html\n{% extends \"learning_logs/base.html\" %}\n\n{% block content %}\n    <p>Learning Log helps you keep track of your learning, \n        for any topic you're learning about.</p>\n{% endblock content %}\n第1行代码导入父模板中的所有内容；extends后面跟父模板所在的路径，虽然这俩文件都在同一目录下，但不能省略掉前面的learning_logs/。\n3到6行代码插入了一个名为content的块标签，不是从父模板继承的内容都包含在content块中。第6行代码指出内容定义的结束位置。\n注意：在大型项目中，通常有一个用于整个网站的父模板base.html，且网站的每个主要部分都有一个父模板。每个主要部分的父模板又都继承自base.html，而网站的每个网页都继承相应部分的父模板。\n4.2 主题页面\n该页面显示用户创建的所有主题。他是第一个需要使用数据的页面。\n4.2.1 定义URL模式\n在APP的urls.py中添加能转到topics.html的URL模式\nurlpatterns = [\n    # 主页\n    path(\"\", views.index, name=\"index\"),\n    path(\"topics/\", views.topics, name=\"topics\")\n]\n4.2.2 添加视图\n在views.py中添加相应的函数：\nfrom django.shortcuts import render\nfrom .models import Topic\n\ndef index(request):\n    -- snip --\n\ndef topics(request):\n    \"\"\"显示所有的主题\"\"\"\n    topics = Topic.objects.order_by(\"date_added\")\n    # 一个上下文字典，传递给模板\n    context = {\"topics\": topics}\n    return render(request, \"learning_logs/topics.html\", context)\n4.2.3 创建模板\n创建一个模板，用于显示所有的主题：\n{% extends \"learning_logs/base.html\" %}\n\n{% block content %}\n    <p>Topics</p>\n\n    <ul>\n        {% for topic in topics %}\n            <li>{{ topic }}</li>\n        {% empty %}\n            <li>No topics have been added yet.</li>\n        {% endfor %}\n    </ul>\n{% endblock content %}\n在这个模板中，我们使用了一个相当于for循环的模板标签，它遍历字典context中的列表topics。并且注意，该模板中没有出现context字样，相当于模板自动从context取得topics的内容。\n模板中使用的代码与Python代码存在一些重要差别：Python使用缩进来指出哪些代码行是for循环的组成部分，而在模板中，每个for循环都必须明确的指出结束为止。\n要在模板中打印变量，需要将变量名用双花括号括起来，每次循环时，该代码都会被替换为topic的当前值。\n还使用了空模板标签(empty)，它告诉Django在列表topics为空时该怎么办。\n这些花括号都不会出现在网页中，它们只是用于告诉Django我们使用了一个模板变量。\n修改父模板base.html，使其包含能转到主题页面的连接（第3行为添加的代码，第2行最后添加了一个连字符）：\n<p>\n    <a href=\"{% url 'learning_logs:index' %}\">Learning Log</a> -\n    <a href=\"{% url 'learning_logs:topics' %}\">Topics</a>\n</p>\n现在再次输入http://localhost:8000 将看到我们添加的Topics链接，点击它，将跳转到如下页面：\n\n4.3 特定主题页面\n该页面用于显示该主题下的所有条目。和上面的步骤一样，定义URL模式，编写views.py中的处理函数，编写网页模板。\n4.3.1 URL模式\nurlpatterns = [\n    -- snip --\n    path(\"topics/<int:topic_id>/\", views.topic, name=\"topic\"),\n]\n4.3.2 添加视图\ndef topic(request, topic_id):\n    \"\"\"显示单个主题及其所有的条目\"\"\"\n    # 通过Topic的id获得所有条目\n    topic = Topic.objects.get(id=topic_id)\n    # 前面的减号表示降序排序\n    entries = topic.entry_set.order_by(\"-date_added\")\n    context = {\"topic\": topic, \"entries\": entries}\n    return render(request, \"learning_logs/topic.html\", context)\n第4,6行的代码叫做查询，如果你和笔者一样是个初学者，比起代码都写完了，最后发现查询语句有问题，再来修改，那么先在Django shell中运行下代码看看结果，这样更高效。\n4.3.3 模板topic.html\n{% extends \"learning_logs/base.html\" %}\n\n{% block content %}\n\n  <p>Topic: {{ topic }}</p>\n\n  <p>Entries:</p>\n  <ul>\n    {% for entry in entries %}\n      <li>\n        <p>{{ entry.date_added|date:'M d, Y H:i' }}</p>\n        <p>{{ entry.text|linebreaks }}</p>\n      </li>\n    {% empty %}\n      <li>\n        There are no entries for this topic yet.\n      </li>\n    {% endfor %}\n  </ul>\n\n{% endblock content %}\n在Django模板中，竖线（|）表示模板过滤器（对模板变量的值进行修改的函数）。过滤器date: 'M d, Y H:i'以这样的格式显示时间戳：April 22, 2018 16:09。接下来的一行显示txt的完整值，而不仅仅是entry的前50个字符。过滤器linebreaks将包含换行符的长条目转换成浏览器能够理解的格式，以免显示一个不换行的文本块。\n4.3.4 修改topics.html模板\n-- snip --\n{% for topic in topics %}\n  <li>\n    <a href=\"{% url 'learning_logs:topic' topic.id %}\">{{ topic }}</a>\n  </li>\n{% empty %}\n-- snip --\n4.4 效果\n现在我们回到http://localhost:8000/topics/ 页面，随便点击一个主题，比如第一个，将得到以下界面：\n\n5. 小结\n上述内容主要有：\n\n在虚拟环境中安装Django，创建项目，并核实该项目已正确地创建；\n在项目中创建APP；\n创建表示APP数据的模型；\n创建数据库，以及在修改模型后，Django可以为迁移数据库提供什么样的帮助；\n创建超级用户，并使用管理网络输入初试数据；\nDjango shell；\n定义URL、创建视图函数、网页模板（包括继承）。\n\n下一篇中，我们将：\n\n创建对用户友好而直观的网页，让用户无需通过管理网站就能添加新的主题和条目（个人感觉没必要这么做，Django自带的管理系统挺好用的），以及编辑既有的条目；\n添加一个用户注册系统，让用户能够创建账户。\n\n\n迎大家关注我的微信公众号\"代码港\" & 个人网站 www.vpointer.net ~\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}