{"title": "python中for循环的工作原理 - Python之禅 ", "index": "python", "content": "for 循环用于迭代容器对象中的元素，这些对象可以是列表、元组、字典、集合、文件，甚至可以是自定义类或者函数，例如：\n作用于列表\n>>> for elem in [1,2,3]:\n...     print(elem)\n...\n1\n2\n3\n作用于元组\n>>> for i in (\"zhang\", \"san\", 30):\n...     print(i)\n...\nzhang\nsan\n30\n作用于字符串\n>>> for c in \"abc\":\n...     print(c)\n...\na\nb\nc\n作用于集合\n>>> for i in {\"a\",\"b\",\"c\"}:\n...     print(i)\n...\nb\na\nc\n作用于字典\n>>> for k in {\"age\":10, \"name\":\"wang\"}:\n...     print(k)\n...\nage\nname\n作用于文件\n>>> for line in open(\"requirement.txt\"):\n...     print(line, end=\"\")\n...\nFabric==1.12.0\nMarkdown==2.6.7\n可能有人不经要问，为什么这么多不同类型对象都支持 for 语句，还有哪些类型的对象可以作用在 for 语句中呢？回答这个问题之前，我们先要了解 for 循环背后的执行原理。\nfor 循环是对容器进行迭代的过程，什么是迭代？迭代就是从某个容器对象中逐个地读取元素，直到容器中没有更多元素为止。那么，哪些对象支持迭代操作？任何对象都可以吗？先随便自定义一个类试试，看行不行：\n>>> class MyRange:\n...     def __init__(self, num):\n...         self.num = num\n...\n>>> for i in MyRange(10):\n...     print(i)\n...\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: 'MyRange' object is not iterable\n错误堆栈日志非常清楚地告诉我们，MyRange 不是一个可迭代对象，所以它不能用于迭代，那么到底什么样的对象才称得上是可迭代对象(iterable)呢？\n可迭代对象需要实现__iter__方法，并返回一个迭代器，什么是迭代器呢？迭代器只需要实现 __next__方法。现在我们就来验证一下列表为什么支持迭代：\n>>> x = [1,2,3]\n>>> its = x.__iter__() # x有此方法，说明列表是可迭代对象\n>>> its\n<list_iterator object at 0x100f32198>\n\n>>> its.__next__()  # its有此方法，说明its是迭代器\n1\n>>> its.__next__()\n2\n>>> its.__next__()\n3\n>>> its.__next__()\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nStopIteration\n从试验结果来看，列表是一个可迭代对象，因为它实现了 __iter__方法，并且返回了一个迭代器对象（list_iterator），因为它实现了 __next__方法。我们看到它不断地调用__next__方法，其实就是不断地迭代获取容器中的元素，直到容器中没有更多元素抛出 StopIteration 异常为止。\n那么 for 语句又是如何循环的呢？到这里，恐怕你也猜到了，它的步骤是：\n\n先判断对象是否为可迭代对象，不是的话直接报错，抛出TypeError异常，是的话，调用 __iter__方法，返回一个迭代器\n不断地调用迭代器的__next__方法，每次按序返回迭代器中的一个值\n迭代到最后，没有更多元素了，就抛出异常 StopIteration，这个异常 python 自己会处理，不会暴露给开发者\n\n\n对于元组，字典，字符串也是同样的道理，弄明白了 for 的执行原理之后，我们就可以实现自己的迭代器用在 for 循环中。\n前面的 MyRange 报错是因为它没有实现迭代器协议里面的这两个方法，现在继续改进：\nclass MyRange:\n    def __init__(self, num):\n        self.i = 0\n        self.num = num\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self.i < self.num:\n            i = self.i\n            self.i += 1\n            return i\n        else:\n            # 达到某个条件时必须抛出此异常，否则会无止境地迭代下去\n            raise StopIteration() \n因为它实现了__next__方法，所以 MyRange 本身已经是一个迭代器了，所以 __iter__返回的就是对象本身 self。现在用在 for 循环中试试：\nfor i in MyRange(3):\n    print(i)\n# 输出\n 0\n 1\n 2\n有没有发现，自定义的 MyRange 功能和内建函数 range很相似。for 循环本质是不断地调用迭代器的__next__方法，直到有 StopIteration 异常为止，所以任何可迭代对象都可以作用在for循环中。\n原文首发于公众号：python之禅博客：https://foofish.net/how-for-w...\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "4"}