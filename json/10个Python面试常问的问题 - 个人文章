{"title": "10个Python面试常问的问题 - 个人文章 ", "index": "面试,python", "content": "概述\nPython是个非常受欢迎的编程语言，随着近些年机器学习、云计算等技术的发展，Python的职位需求越来越高。下面我收集了10个Python面试官经常问的问题，供大家参考学习。\n类继承\n有如下的一段代码：\nclass A(object):\n    def show(self):\n        print 'base show'\n\nclass B(A):\n    def show(self):\n        print 'derived show'\n \nobj = B()\nobj.show()\n\n如何调用类A的show方法了。方法如下：\nobj.__class__ = A\nobj.show() \n\n__class__方法指向了类对象，只用给他赋值类型A，然后调用方法show，但是用完了记得修改回来。\n方法对象\n问题：为了让下面这段代码运行，需要增加哪些代码？\nclass A(object):\n    def __init__(self,a,b):\n        self.__a = a\n        self.__b = b\n    def myprint(self):\n        print 'a=', self.__a, 'b=', self.__b\n    \n \na1=A(10,20)\na1.myprint()\n \na1(80)\n\n答案：为了能让对象实例能被直接调用，需要实现__call__方法\nclass A(object):\n    def __init__(self, a, b):\n        self.__a = a\n        self.__b = b\n    def myprint(self):\n        print 'a=', self.__a, 'b=', self.__b\n    def __call__(self, num):\n        print 'call:', num + self.__a\n\nnew和init\n下面这段代码输入什么？\nclass B(object):\n    def fn(self):\n        print 'B fn'\n    def __init__(self):\n        print \"B INIT\"\n \n \nclass A(object):\n    def fn(self):\n        print 'A fn'\n \n    def __new__(cls,a):\n            print \"NEW\", a\n            if a>10:\n                return super(A, cls).__new__(cls)\n            return B()\n \n    def __init__(self,a):\n        print \"INIT\", a\n \na1 = A(5)\na1.fn()\na2=A(20)\na2.fn()\n\n答案：\n\nNEW 5\nB INIT\nB fn\nNEW 20\nINIT 20\nA fn\n\n使用__new__方法，可以决定返回那个对象，也就是创建对象之前，这个可以用于设计模式的单例、工厂模式。__init__是创建对象是调用的。\nPython list和dict生成\n下面这段代码输出什么?\nls = [1,2,3,4]\nlist1 = [i for i in ls if i>2]\nprint list1\n \nlist2 = [i*2 for i in ls if i>2]\nprint list2\n \ndic1 = {x: x**2 for x in (2, 4, 6)}\nprint dic1\n \ndic2 = {x: 'item' + str(x**2) for x in (2, 4, 6)}\nprint dic2\n \nset1 = {x for x in 'hello world' if x not in 'low level'}\nprint set1\n\n答案:\n\n[3, 4]  \n[6, 8]\n{2: 4, 4: 16, 6: 36}\n{2: 'item4', 4: 'item16', 6: 'item36'}\nset(['h', 'r', 'd'])\n\n全局和局部变量\n下面这段代码输出什么?\nnum = 9\n\ndef f1():\n    num = 20\n \ndef f2():\n    print num\n \n \nf2()\nf1()\nf2()\n\n答案:\n\n9\n9\n\nnum不是个全局变量，所以每个函数都得到了自己的num拷贝，如果你想修改num，则必须用global关键字声明。比如下面这样\nnum = 9\n \ndef f1():\n    global num\n    num = 20\n \ndef f2():\n   print num\n \nf2()\nf1()\nf2()\n \n# prints:\n#      9\n#      20\n\n交换两个变量的值\n一行代码交换两个变量值\na=8\nb=9\n\n答案：\n\n(a,b) = (b,a)\n\n默认方法\n如下的代码\n\nclass A(object):\n    def __init__(self,a,b):\n        self.a1 = a\n        self.b1 = b\n        print 'init'\n    def mydefault(self):\n        print 'default'\n \na1 = A(10,20)\na1.fn1()\na1.fn2()\na1.fn3()\n\n方法 fn1/fn2/fn3 都没有定义，添加代码，是没有定义的方法都调用mydefault函数，上面的代码应该输出\ndefault\ndefault\ndefault\n\n答案：\nclass A(object):\n    def __init__(self,a,b):\n        self.a1 = a\n        self.b1 = b\n        print 'init'\n    def mydefault(self):\n        print 'default'\n    def __getattr__(self,name):\n        return self.mydefault\n \na1 = A(10,20)\na1.fn1()\na1.fn2()\na1.fn3()\n\n方法__getattr__只有当没有定义的方法调用时，才是调用他。当fn1方法传入参数时，我们可以给mydefault方法增加一个*args不定参数来兼容。\nclass A(object):\n    def __init__(self,a,b):\n        self.a1 = a\n        self.b1 = b\n        print 'init'\n    def mydefault(self,*args):\n        print 'default:' + str(args[0])\n    def __getattr__(self,name):\n        print \"other fn:\",name\n        return self.mydefault\n \na1 = A(10,20)\na1.fn1(33)\na1.fn2('hello')\na1.fn3(10)\n\n包管理\n一个包里有三个模块，mod1.py, mod2.py, mod3.py，但使用from demopack import *导入模块时，如何保证只有mod1、mod3被导入了。\n答案:增加__init__.py文件，并在文件中增加：\n__all__ = ['mod1','mod3']\n\n闭包\n写一个函数，接收整数参数n，返回一个函数，函数的功能是把函数的参数和n相乘并把结果返回。\n答案:\n\ndef mulby(num):\n    def gn(val):\n        return num * val\n \n    return gn\n \n \nzw = mulby(7)\nprint(zw(9));\n\n性能\n解析下面的代码慢在哪\ndef strtest1(num):\n    str='first'\n    for i in range(num):\n        str+=\"X\"\n    return str\n    \n答案：python的str是个不可变对象，每次迭代，都会生成新的str对象来存储新的字符串，num越大，创建的str对象越多，内存消耗越大。\n转载自我的博客捕蛇者说\n\n\n                ", "mainLikeNum": ["12 "], "mainBookmarkNum": "44"}