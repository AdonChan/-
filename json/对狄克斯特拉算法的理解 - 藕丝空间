{"title": "对狄克斯特拉算法的理解 - 藕丝空间 ", "index": "python,算法", "content": "狄克斯特拉算法是一种实现了在有障碍物的两个地点之间找出一条最短路径的高效算法，解决了机器人学中的一个十分关键的问题，即运动路径规划问题，至今仍被广泛应用。是“贪心方法（greedy method）”的一个成功范例。\n致敬\n首先向伟大的牛人致敬！\n\n使用狄克斯特拉算法\n如果所示：\n找出从起点到终点耗时最短的路径。其中，每个数字表示的都是时间，单位分钟。线路使用有方向的箭头线路表示，表示只有一个方向可以使用，统称有向图。\n常规思路\n为了找到从起点到终点耗时最短的路径，我们通常需要找出从起点到终点所有的路径，然后进行一一对比。\n路径一\n\n路径一是从起点出发，经过 A 节点，到达终点，共计用时 6 + 1 = 7 分钟。\n路径二\n\n路径二是从起点出发，经过 B 节点，到达终点，共计用时 2 + 5 = 7 分钟。\n路径三\n\n路径三从起点出发，经过 B 节点，再经过 A 节点，到达终点，共计用时 2 + 3 + 1 = 6 分钟。\n综上，我们已经穷举完了所有可能的路径，不可能再找出另外的路径了。同时，对比一下三种路径，你会发现路径三用时最短，只需要 6 分钟。呵呵，so easy，妈妈再也不用担心我的学习了。既然，人可以做出结果，那么计算机利用此种方法，也就是所谓的穷举法，当然也能找到最优路径。\n不过，别得意，你的妈妈还得担心你的学习。如果路途中，不止 A、B 两个节点，而是接近无穷多个节点，记住是接近无穷多个节点，......懵逼从天空飘过。\n此时，肯定有同学会跳出来反对，无穷多个节点，这就是无限。无限，也就是无界，就是死循环的问题了，肯定无法得到答案，此题出得有问题。\n这个问题提得好，必须有界才能有答案，该问题是接近无限多，也就是个很大很大的边界，是超出了人力范围的边界。......懵逼继续从天空飘过。 但是，计算机肯定是能够计算出有界的问题的，利用穷举法当然可以算出，不过这里又产生一个问题，穷举法是检索每条可能的路径，这肯定会消耗很大的计算机运算能力，那么有没有更优的方法，至少不用穷举出所有路径的方法呢？当然，有那么多的牛人供我们致敬，答案是肯定的。\n狄克斯特拉算法思路\n步骤或思路如下：\n\n找出最便宜的节点，即可在最短时间内前往的节点。\n对于该节点的所有邻居，检查是否有前往它们的更短路径，如果有，就更新其开销。\n处理过的节点，进行标记，以后将不再处理。\n重复以上过程，直到对图中的每个节点都这样做了。\n计算出最终路径。\n\n第一步：找出最便宜的节点。你站在起点，不知道该前往节点 A 还是节点 B ，茫然无措ing........。此时，散列表可以派上用场了。啥是散列表？你可以把它当做是一个列表，详细的东西问谷歌，请自备梯子。\n前往节点 A 需要6 分钟，而前往节点 B 需要 2 分钟。至于前往其它节点，你还不知道需要多长时间。那么散列表如下：\n\n\n父节点\n节点\n耗时\n\n\n\n起点\nA\n6\n\n\n起点\nB\n2\n\n\n起点\n终点\n∞\n\n\n\n第二步：由于从起到到节点 B 的路径耗时少，先计算经节点 B 前往其各个邻居所需的时间。\n\n\n父节点\n节点\n耗时\n\n\n\nB\nA\n5 更新耗时\n\n\n-\nB\n2\n\n\nB\n终点\n7 更新耗时\n\n\n\n这一步，找到了一条前往节点 A 的更短路径！直接前往节点 A 需要 6 分钟。但是经过节点 B 前往节点 A 只需要 5 分钟。\n对于节点 B 的邻居，如果找到前往它的更短路径，就更新其开销。\n\n前往节点 A 的更短路径，时间从 6 分钟缩短到 5 分钟。\n前往终点的更短路径，时间从无穷大缩短到 7 分钟。\n\n第三步：对节点 B 已进行处理，所以要对节点 B 进行标记，以后将不再处理节点 B。\n第四部： 重复！\n重复第一步：找出可在最短时间内前往的节点。除节点 B 之外，可以在最短时间内前往的节点是节点 A 。重复第二步：更新节点 A 的所有邻居的开销。\n\n\n父节点\n节点\n耗时\n\n\n\n-\nA\n5 已是最小耗时，无需更新\n\n\n-\nB\n2\n\n\nA\n终点\n6 更新耗时\n\n\n\n现在对每个节点都运行了狄克斯特拉算法（无需对终点这样做）。现在，你知道：\n\n前往节点 B 需要 2 分钟；\n前往节点A 需要 5 分钟；\n前往终点需要 6 分钟。\n\n所以你会发现，前往终点的时间为 6 分钟！！！\nPython代码实现\n实现一个能够找出开销最低节点的函数\ndef find_lowest_cost_node(costs):\n    lowest_cost = float(\"inf\") # 设置初始开销为无穷大，因为你现在很茫然\n    lowest_cost_node = None # 设置初始最低开销节点为 None\n    for node in costs: # 遍历所有的节点\n        cost = costs[node]\n        if cost < lowest_cost and node not in processed: # 如果当前节点的开销更低且未处理过，\n            lowest_cost = cost # 就将其视为开销最低的节点。\n            lowest_cost_node = node # 最低开销节点为当前的节点。\n    return lowest_cost_node\n创建用于存储所有节点及其前往邻居开销的散列表代码\ngraph[\"start\"] = {}\ngraph[\"start\"][\"a\"] = 6\ngraph[\"start\"][\"b\"] = 2\n\ngraph[\"a\"] = {}\ngraph[\"a\"][\"fin\"] =1\n\ngraph[\"b\"] = {}\ngraph[\"b\"][\"a\"] =3\ngraph[\"b\"][\"fin\"] = 5\n\ngraph[\"fin\"] = {} # 终点没有任何邻居\n表示整个图的散列表类似下面这样。\n\n\n父节点\n节点\n耗时\n\n\n\n起点\nA\n6\n\n\n起点\nB\n2\n\n\nA\n终点\n1\n\n\nB\nA\n3\n\n\nB\n终点\n5\n\n\n起点\n终点\n-\n\n\n\n按流程实现代码\n一、创建从起点开始的开销表代码如下：\ninfinity = float(\"inf\")\ncosts = {}\ncosts[\"a\"] = 6\ncosts[\"b\"] = 2\ncosts[\"fin\"] = infinity\n二、创建存储父节点的散列表代码如下：\nparents = {}\nparents[\"a\"] = \"start\"\nparents[\"b\"] = \"start\"\nparents[\"fin\"] = None\n三、创建一个数组，用于记录处理过的节点，对于同一个节点，不用多次处理。\nprocessed = []\n四、按照算法列出代码\nnode = find_lowest_cost_node(costs) # 在未处理的节点中找出开销最小的节点\nwhile node is None: # 这个 while 循环在所有节点都被处理过后结束\n    cost = costs[node]\n    neighbors = graph[node]\n    for n in neighbors.keys(): # 遍历当前节点的所有邻居\n        new_cost = cost + neighbors[n]\n        if costs[n] > new_cost: # 如果经当前节点前往该邻居最近，\n            costs[n] = new_cost # 就更新该邻居的开销\n            parents[n] = node # 同时将该邻居的父节点设置为当前节点\n    processed.append(node) # 将当前借调标记为已处理\n    node = find_lowest_cost_node(costs) # 找出接下来要处理的节点，并循环。\n按照个人的理解创建代码\n在 Python 3.5.2 上亲测有效。\n# -*- coding:utf-8 -*-\n__author__ = \"东方鹗\"\n__blog__ = \"www.os373.cn\"\n\ndef find_lowest_cost_node(costs, processed):\n    lowest_cost = float(\"inf\") # 设置初始开销为无穷大，因为你现在很茫然\n    lowest_cost_node = None # 设置初始最低开销节点为 None\n    for node in costs: # 遍历所有的节点\n        cost = costs[node]\n        if cost < lowest_cost and node not in processed: # 如果当前节点的开销更低且未处理过，\n            lowest_cost = cost # 就将其视为开销最低的节点。\n            lowest_cost_node = node # 最低开销节点为当前的节点。\n    return lowest_cost_node\n\n\ndef best_route():\n    ''' 存储所有节点及其下一个节点开销的字典 '''\n    graph = {\"start\": {\"a\": 6, \"b\": 2}, \"a\": {\"fin\": 1}, \"b\": {\"a\": 3, \"fin\": 5}, \"fin\": {}}\n\n    ''' 从起点开始，包含所有下一个节点开销的字典 '''\n    infinity = float(\"inf\")\n    costs = {\"a\": 6, \"b\": 2, \"fin\": infinity}\n\n    ''' 从起点开始，存储所有父节点的散列表 '''\n\n    parents = {\"a\": \"start\", \"b\": \"start\", \"fin\": None}\n    best_route = \"\"\n    processed = []\n\n    node = find_lowest_cost_node(costs, processed) # 在未处理的节点中找出开销最小的节点    \n    while node is not None: # 这个 while 循环在所有节点都被处理过后结束\n        cost = costs[node]\n        neighbors = graph[node]\n        for n in neighbors.keys(): # 遍历当前节点的所有邻居\n            new_cost = cost + neighbors[n]\n            if costs[n] > new_cost: # 如果经当前节点前往该邻居最近，\n                costs[n] = new_cost # 就更新该邻居的开销\n                parents[n] = node # 同时将该邻居的父节点设置为当前节点\n        processed.append(node) # 将当前借调标记为已处理\n        node = find_lowest_cost_node(costs, processed) # 找出接下来要处理的节点，并循环。\n    \n    p = parents[\"fin\"]\n    \n    while True:  \n        best_route += \"%s<——\" % p\n        p = parents[p]\n        \n        if p is \"start\":\n            break               \n        \n                \n    return \"到达终点的最终路径是: 终点<——%s起点。\\n最快到达的时间是%s分钟\" % (best_route, costs[\"fin\"])\n        \nif __name__ == \"__main__\":\n    best_route = best_route()\n    print(best_route)\n结果如下：\n到达终点的最终路径是: 终点<——a<——b<——起点。\n最快到达的时间是6分钟\n狄克斯特拉算法的局限\n1、该算法只适用于有向无环图！2、该算法将 0 视作最小的权值，也就是说，如果出现负权值的情况，那么该算法将失效！\nreference\n《算法图解》\n\n                ", "mainLikeNum": ["4 "], "mainBookmarkNum": "4"}