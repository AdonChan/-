{"title": "Python中的集合类模块collections详解 - ziwenxie ", "index": "python", "content": "引言\nPython为我们提供了4种基本的数据结构：list, tuple, dict, set，但是在处理数据量较大的情形的时候，这4种数据结构就明显过于单一了，比如list作为数组在某些情形插入的效率会比较低，有时候我们也需要维护一个有序的dict。所以这个时候我们就要用到Python标准库为我们提供的collections包了，它提供了多个有用的集合类，熟练掌握这些集合类，不仅可以让我们让写出的代码更加Pythonic，也可以提高我们程序的运行效率。\ndefaultdict\ndefaultdict(default_factory)在普通的dict之上添加了default_factory，使得key不存在时会自动生成相应类型的value，default_factory参数可以指定成list, set, int等各种合法类型。\n我们现在有下面这样一组list，虽然我们有5组数据，但是仔细观察后发现其实我们只有3种color，但是每一种color对应多个值。现在我们想要将这个list转换成一个dict，这个dict的key对应一种color，dict的value设置为一个list存放color对应的多个值。我们可以使用defaultdict(list)来解决这个问题。\n>>> from collections import defaultdict\n>>> s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]\n>>> d = defaultdict(list)\n>>> for k, v in s:\n...     d[k].append(v)\n...\n>>> sorted(d.items())\n[('blue', [2, 4]), ('red', [1]), ('yellow', [1, 3])]\n以上等价于：\n>>> d = {}\n>>> for k, v in s:\n...     d.setdefault(k, []).append(v)\n...\n>>> sorted(d.items())\n[('blue', [2, 4]), ('red', [1]), ('yellow', [1, 3])]\n如果我们不希望含有重复的元素，可以考虑使用defaultdict(set)。set相比list的不同之处在于set中不允许存在相同的元素。\n>>> from collections import defaultdict\n>>> s = [('red', 1), ('blue', 2), ('red', 3), ('blue', 4), ('red', 1), ('blue', 4)]\n>>> d = defaultdict(set)\n>>> for k, v in s:\n...     d[k].add(v)\n...\n>>> sorted(d.items())\n[('blue', {2, 4}), ('red', {1, 3})]\nOrderedDict\nPython3.6之前的dict是无序的，但是在某些情形我们需要保持dict的有序性，这个时候可以使用OrderedDict，它是dict的一个subclass，但是在dict的基础上保持了dict的有序型，下面我们来看一下使用方法。\n>>> # regular unsorted dictionary\n>>> d = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2}\n\n>>> # dictionary sorted by key\n>>> OrderedDict(sorted(d.items(), key=lambda t: t[0]))\nOrderedDict([('apple', 4), ('banana', 3), ('orange', 2), ('pear', 1)])\n\n>>> # dictionary sorted by value\n>>> OrderedDict(sorted(d.items(), key=lambda t: t[1]))\nOrderedDict([('pear', 1), ('orange', 2), ('banana', 3), ('apple', 4)])\n\n>>> # dictionary sorted by length of the key string\n>>> OrderedDict(sorted(d.items(), key=lambda t: len(t[0])))\nOrderedDict([('pear', 1), ('apple', 4), ('orange', 2), ('banana', 3)])\n使用popitem(last=True)方法可以让我们按照LIFO(先进后出)的顺序删除dict中的key-value，即删除最后一个插入的键值对，如果last=False就按照FIFO(先进先出)删除dict中key-value。\n>>> d = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2}\n\n>>> # dictionary sorted by key\n>>> d = OrderedDict(sorted(d.items(), key=lambda t: t[0]))\n\n>>> d\nOrderedDict([('apple', 4), ('banana', 3), ('orange', 2), ('pear', 1)])\n\n>>> d.popitem()\n('pear', 1)\n\n>>> d.popitem(last=False)\n('apple', 4)\n使用move_to_end(key, last=True)来改变有序的OrderedDict对象的key-value顺序，通过这个方法我们可以将排序好的OrderedDict对象中的任意一个key-value插入到字典的开头或者结尾。\n>>> d = OrderedDict.fromkeys('abcde')\n>>> d\nOrderedDict([('a', None), ('b', None), ('c', None), ('d', None), ('e', None)])\n\n>>> d.move_to_end('b')\n>>> d\nOrderedDict([('a', None), ('c', None), ('d', None), ('e', None), ('b', None)])\n\n>>> ''.join(d.keys())\n'acdeb'\n>>> d.move_to_end('b', last=False)\n>>> ''.join(d.keys())\n'bacde'\ndeque\nlist存储数据的优势在于按索引查找元素会很快，但是插入和删除元素就很慢了，因为list是基于数组实现的。deque是为了高效实现插入和删除操作的双向列表，适合用于队列和栈，而且线程安全。\nlist只提供了append和pop方法来从list的尾部插入/删除元素，deque新增了appendleft/popleft等方法允许我们高效的在元素的开头来插入/删除元素。而且使用deque在队列两端append或pop元素的算法复杂度大约是O(1)，但是对于list对象改变列表长度和数据位置的操作例如 pop(0)和insert(0, v)操作的复杂度高达O(n)。\n>>> from collections import deque\n>>> dq = deque(range(10), maxlen=10)\n>>> dq\ndeque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)\n\n>>> dq.rotate(3)\n>>> dq\ndeque([7, 8, 9, 0, 1, 2, 3, 4, 5, 6], maxlen=10)\n>>> dq.rotate(-4)\n>>> dq\ndeque([1, 2, 3, 4, 5, 6, 7, 8, 9, 0], maxlen=10)\n\n>>> dq.appendleft(-1)\n>>> dq\n\ndeque([-1, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)\n>>> dq.extend([11, 22, 33])\n>>> dq\ndeque([3, 4, 5, 6, 7, 8, 9, 11, 22, 33], maxlen=10)\n\n>>> dq.extendleft([10, 20, 30, 40])\n>>> dq\ndeque([40, 30, 20, 10, 3, 4, 5, 6, 7, 8], maxlen=10)\nCounter\nCount用来统计相关元素的出现次数。\n>>> from collections import Counter\n>>> ct = Counter('abracadabra')\n>>> ct\nCounter({'a': 5, 'r': 2, 'b': 2, 'd': 1, 'c': 1})\n>>> ct.update('aaaaazzz')\n>>> ct\nCounter({'a': 10, 'z': 3, 'r': 2, 'b': 2, 'd': 1, 'c': 1})\n>>> ct.most_common(2)\n[('a', 10), ('z', 3)]\n>>> ct.elements()\n<itertools.chain object at 0x7fbaad4b44e0>\nnamedtuple\n使用namedtuple(typename, field_names)命名tuple中的元素来使程序更具可读性。\n>>> from collections import namedtuple\n>>> City = namedtuple('City', 'name country population coordinates')\n>>> tokyo = City('Tokyo', 'JP', 36.933, (35.689722, 139.691667))\n>>> tokyo\nCity(name='Tokyo', country='JP', population=36.933, coordinates=(35.689722, 139.691667))\n>>> tokyo.population\n36.933\n>>> tokyo.coordinates\n(35.689722, 139.691667)\n>>> tokyo[1]\n'JP'\n>>> City._fields\n('name', 'country', 'population', 'coordinates')\n>>> LatLong = namedtuple('LatLong', 'lat long')\n>>> delhi_data = ('Delhi NCR', 'IN', 21.935, LatLong(28.613889, 77.208889))\n>>> delhi = City._make(delhi_data)\n>>> delhi._asdict()\nOrderedDict([('name', 'Delhi NCR'), ('country', 'IN'), ('population', 21.935),\n            ('coordinates', LatLong(lat=28.613889, long=77.208889))])\n>>> for key, value in delhi._asdict().items():\n        print(key + ':', value)\n\nname: Delhi NCR\ncountry: IN\npopulation: 21.935\ncoordinates: LatLong(lat=28.613889, long=77.208889)\nChainMap\nChainMap可以用来合并多个字典。\n>>> from collections import ChainMap\n>>> d = ChainMap({'zebra': 'black'}, {'elephant': 'blue'}, {'lion': 'yellow'})\n>>> d['lion'] = 'orange'\n>>> d['snake'] = 'red'\n>>> d\nChainMap({'lion': 'orange', 'zebra': 'black', 'snake': 'red'},\n         {'elephant': 'blue'}, {'lion': 'yellow'})\n>>> del d['lion']\n>>> del d['elephant']\nTraceback (most recent call last):\n  File \"/usr/lib/python3.5/collections/__init__.py\", line 929, in __delitem__\n    del self.maps[0][key]\nKeyError: 'elephant'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"/usr/lib/python3.5/collections/__init__.py\", line 931, in __delitem__\n    raise KeyError('Key not found in the first mapping: {!r}'.format(key))\nKeyError: \"Key not found in the first mapping: 'elephant'\"\n从上面del['elephant']的报错信息可以看出来，对于改变键值的操作ChainMap只会在第一个字典self.maps[0][key]进行查找，新增加的键值对也都会加入第一个字典，我们来改进一下ChainMap解决这个问题：\nclass DeepChainMap(ChainMap):\n    'Variant of ChainMap that allows direct updates to inner scopes'\n\n    def __setitem__(self, key, value):\n        for mapping in self.maps:\n            if key in mapping:\n                mapping[key] = value\n                return\n        self.maps[0][key] = value\n\n    def __delitem__(self, key):\n        for mapping in self.maps:\n            if key in mapping:\n                del mapping[key]\n                return\n        raise KeyError(key)\n\n>>> d = DeepChainMap({'zebra': 'black'}, {'elephant': 'blue'}, {'lion': 'yellow'})\n>>> d['lion'] = 'orange'         # update an existing key two levels down\n>>> d['snake'] = 'red'           # new keys get added to the topmost dict\n>>> del d['elephant']            # remove an existing key one level down\nDeepChainMap({'zebra': 'black', 'snake': 'red'}, {}, {'lion': 'orange'})\n\n可以使用new_child来deepcopy一个ChainMap：\n>>> from collections import ChainMap\n>>> a = {'a': 'A', 'c': 'C'}\n>>> b = {'b': 'B', 'c': 'D'}\n\n>>> m = ChainMap({'a': 'A', 'c': 'C'}, {'b': 'B', 'c': 'D'})\n>>> m\nChainMap({'a': 'A', 'c': 'C'}, {'b': 'B', 'c': 'D'})\n>>> m['c']\n'C'\n>>> m.maps\n[{'c': 'C', 'a': 'A'}, {'c': 'D', 'b': 'B'}]\n\n>>> a['c'] = 'E'\n>>> m['c']\n'E'\n>>> m\nChainMap({'c': 'E', 'a': 'A'}, {'c': 'D', 'b': 'B'})\n>>> m2 = m.new_child()\n>>> m2['c'] = 'f'\n>>> m2\nChainMap({'c': 'f'}, {'c': 'E', 'a': 'A'}, {'c': 'D', 'b': 'B'})\n>>> m\nChainMap({'c': 'E', 'a': 'A'}, {'c': 'D', 'b': 'B'})\n>>> m2.parents\nChainMap({'c': 'E', 'a': 'A'}, {'c': 'D', 'b': 'B'})\nUserDict\n下面我们来改进一下字典，查询字典的时候将key转换为str的形式：\nclass StrKeyDict0(dict):\n\n    def __missing__(self, key):\n        if isinstance(key, str):\n            raise KeyError(key)\n        return self[str(key)]\n\n    def get(self, key, default=None):\n        try:\n            return self[key]\n        except KeyError:\n            return default\n\n    def __contains__(self, key):\n        return key in self.keys() or str(key) in self.keys()\n解释一下上面这段程序：\n\n在__missing__中isinstance(key, str)是必须要的，请思考一下为什么？ 因为假设一个key不存在的话，这会造成infinite recursion，self[str(key)]会再次调用__getitem__。\n__contains__也是必须实现的，因为k in d的时候会进行调用，但是注意即使查找失败它也不会调用__missing__。关于__contains__还有一个细节就是：我们并没有使用k in my_dict，因为str(key) in self的形式，因为这会造成递归调用__contains__。\n\n这里还强调一点，在Python2.x中dict.keys()会返回一个list，这意味着k in my_list必须遍历list。在Python3.x中针对dict.keys()做了优化，性能更高，它会返回一个view如同set一样，详情参考官方文档。\n上面这个例子可以用UserDict改写，并且将所有的key都以str的形式存储，而且这种写法更加常用简洁：\nimport collections\n\n\nclass StrKeyDict(collections.UserDict):\n\n    def __missing__(self, key):\n        if isinstance(key, str):\n            raise KeyError(key)\n        return self[str(key)]\n\n    def __contains__(self, key):\n        return str(key) in self.data\n\n    def __setitem__(self, key, item):\n        self.data[str(key)] = item\nUserDict是MutableMapping和Mapping的子类，它继承了MutableMapping.update和Mapping.get两个重要的方法，所以上面我们并没有重写get方法，可以在源码中看到它的实现和我们上面的实现是差不多的。\nReferences\nDOCUMENTATION-COLLECTIONSFLUENT-PYTHON\nContact\nGitHub: https://github.com/ziwenxieBlog: https://www.ziwenxie.site\n本文为作者原创，转载请于开头明显处声明博客出处:)\n\n                ", "mainLikeNum": ["5 "], "mainBookmarkNum": "16"}