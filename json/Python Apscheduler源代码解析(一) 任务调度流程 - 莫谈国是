{"title": "Python Apscheduler源代码解析(一) 任务调度流程 - 莫谈国是 ", "index": "python", "content": "最近公司有项目需要使用到定时任务，其定时逻辑类似于linux的Cron，就使用了Apscheduler这个类库。基于公司的业务，需要修改Apshceduler，故而研究了一下Apscheduler的代码。\nApscheduler的调度逻辑非常简单，越简单的东西往往也越有效。\n调度器会开辟一个线程，这个线程会循环的从job_store中找到任务，计算任务的执行时间，并与当前时间做比较。如果任务的执行事件<=当前时间，就将任务的firetime放到一个列表中(runtimes)\n    def _get_run_times(self, now):\n        run_times = []\n        next_run_time = self.next_run_time\n        while next_run_time and next_run_time <= now:\n            run_times.append(next_run_time)\n            next_run_time = self.trigger.get_next_fire_time(next_run_time, now)\n\n        return run_times\n如果runtimes不为空，就将其放入Executor中，下面代码中的executor不是Python的线程池类，是Apscheduler的一个类，当然了，最终的结果是将任务放到线程池当中\n                if run_times:\n                    try:\n                        executor.submit_job(job, run_times)\n在BaseExecutor类中，有一个abstract method,负责将任务放到线程池当中，在其子类BasePoolExecutor中，继承了这个方法\n    def _do_submit_job(self, job, run_times):\n        def callback(f):\n            exc, tb = (f.exception_info() if hasattr(f, 'exception_info') else\n                       (f.exception(), getattr(f.exception(), '__traceback__', None)))\n            if exc:\n                self._run_job_error(job.id, exc, tb)\n            else:\n                self._run_job_success(job.id, f.result())\n\n        f = self._pool.submit(run_job, job, job._jobstore_alias, run_times, self._logger.name)\n        f.add_done_callback(callback)\n代码中的self._pool可以是线程池，也可以是进程池，在concurrent.futures包中，已经是python3的标准类库了。\n关于调度器的事件循环，如果让他一直循环不断的从job_store中取任务，然后判断，这样会十分浪费资源。Apscheduler在一次循环结束之前会计算任务下次执行事件与当前时间之差，然后让调度线程挂起直到那个时间到来。\n    def _main_loop(self):\n        wait_seconds = TIMEOUT_MAX\n        while self.state != STATE_STOPPED:\n            self._event.wait(wait_seconds)\n            self._event.clear()\n            wait_seconds = self._process_jobs()\nself._process_jobs()的返回值就是上面说的那个时间，self._event.wait(wait_seconds)就是让当前线程等待这么长的一段时间\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}