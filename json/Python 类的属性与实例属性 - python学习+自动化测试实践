{"title": "Python 类的属性与实例属性 - python学习+自动化测试实践 ", "index": "python,属性", "content": "放假归来 ~~~\n\n一、概念\n\n类对象：类名\n实例对象：通过类创建的对象\n类属性：类对象所拥有的属性。归类所有，被类对象和实例对象所共有。  类的公有属性可以在类外被访问。\n实例属性：实例对象所特有的属性，类对象不能拥有，即不能通过类对象调用。  实例属性可以放在构造方法__init__()中，也可以在创建实例对象后，进行绑定。\n\n二、举例说明\n我们通过创建一个学生类来进行说明。\nclass Student1(object):\n    version = 1.0                        # 类的公有数据属性\n    __v = 66                            # 类的私有数据属性\n    \n    # 构造方法里的实例属性，在类创建实例时自动被调用\n    def __init__(self ,name,score):        \n        self.name = name \n        self.score = score \n    \n    # 类的方法属性，通过类实例化对象访问\n    def updateScore(self,new_score):    \n        self.score = new_score\n\nthen，尝试通过类对象和实例对象来访问类的公有数据属性。对于实例没有而类有的属性，会继续查找类的属性。\n>>> b = Student1('xlp','100')   \n>>> Student1.version            # 通过类来访问类的数据属性\n1.0\n>>> b.version                    # 通过类实例访问类的数据属性，打印version属性 \n1.0                    # 因为实例并没有该属性，所以会继续查找class的version属性 \n\nbut，当类属性和实例属性相同且混用的时候，会出现点问题。我们先通过类来修改类的数据属性。修改后，类和实例对象均可访问。\n>>>Student1.version += 0.1    \n>>>Student1.version         # 或者b.version\n1.1\n再通过类实例对象来修改类属性：\n>>>b.version += 0.1            # 试图通过类对象来修改类属性\n>>>b.version                # 效果等同于b.version = Student.version + 0.1\n1.2                 # 由于实例属性优先级高于类属性，因此会屏蔽掉类的version属性 1.1\n>>>Student1.version \n1.1                 # 此时Student.version仍为1.1\n\n其实，在上面实例对象修改类数据属性时，创建了一个名为version的新实例属性，覆盖了类属性的引用。但是类本身的数据属性没有受到影响，仍存在类域中，可以通过类属性访问。如果将b.version属性进行删除del，之后b.version就可以重新访问类数据属性了。\n>>>del b.version            # 删除实例属性\n>>>b.version             # 由于实例的version属性没有找到，类的属性就显示出来了\n1.1\n所以，实例属性和类属性不要使用相同的名字。因为相同名称的实例属性将屏蔽掉类属性。\n可以通过实例绑定、访问实例的属性，举例说明：\n>>> b.name                    \n'xlp'\n>>>b.updateSocore(100)        # 通过实例访问类方法属性\n>>>b.score\n100\n但是，但是，但是，当类数据属性为可变对象时，比如dict类型，情况又会有点不一样了。例如：\n\n当类属性为可变对象时，通过实例对象来修改类属性时，会修改类属性，且在删除实例属性时会报错。所以，使用类对象来修改类属性，不要使用实例对象来修改类属性。\n\n❤ thanks for watching, keep on updating...点个赞再走吧\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}