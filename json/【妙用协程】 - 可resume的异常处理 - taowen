{"title": "【妙用协程】 - 可resume的异常处理 - taowen ", "index": "python,协程,coroutine", "content": "标准的异常处理是这样的\n\ntry:\n    print('hello')\n    raise Exception()\n    print('!!!')\nexcept:\n    print('world')\n    print('???')\n\n\n这段代码会打印出???而不会打印出!!!，因为异常会中断当前流程，跳转到except部分去继续执行。但是有的时候我们希望的这样的行为：\n\ntry:\n    print('hello')\n    print(Scheduler.interrupt())\n    print('!!!')\nexcept ProcessInterrupt as pi:\n    pi.resume('world')\n    print('???')\n\n\n这段代码打印出!!!而不是???，因为resume的时候把执行重新跳转回interrupt的地方了。这种行为类似vba里的on error resume next（https://msdn.microsoft.com/en-us/library/5hsw66as.aspx）。\n\n如何实现的？其实原理上很简单。interrupt的时候把当前协程的状态保存起来（pickle.dumps），如果决定要resume，就把协程interrupt的时刻的状态重新恢复（pickle.loads）然后从那个点继续执行。\n\n完整的代码（需要pypy或者stackless python）：\n\nimport greenlet\nimport cPickle as pickle\nimport traceback\nimport threading\nimport functools\n\n\nclass ProcessInterrupt(Exception):\n    def __init__(self, interruption_point, pi_args):\n        self.interruption_point = interruption_point\n        self.stacktrace = traceback.extract_stack()\n        self.pi_args = pi_args\n\n    def resume(self, resume_with=None):\n        Scheduler.resume(self.interruption_point, resume_with)\n\n    def __repr__(self):\n        return '>>>ProcessInterrupt>>>%s' % repr(self.stacktrace)\n\n    def __str__(self):\n        return repr(self)\n\n    def __unicode__(self):\n        return repr(self)\n\n\nclass Scheduler(object):\n    current = threading.local()\n\n    def __init__(self):\n\n        if getattr(self.current, 'instance', None):\n            raise Exception('can not have two scheduler in one thread')\n        self.scheduler_greenlet = greenlet.getcurrent()\n        self.current.instance = self\n\n    def __call__(self, action, action_args):\n        next = action, action_args\n        while next:\n            action, action_args = next\n            if 'init' == action:\n                next = action_args['init_greenlet'].switch()\n            elif 'interrupt' == action:\n                interruption_point = pickle.dumps(action_args['switched_from'])\n                should_resume, resume_with = False, None\n                next = action_args['switched_from'].switch(\n                    should_resume, resume_with, interruption_point)\n            elif 'resume' == action:\n                should_resume, resume_with, interruption_point = True, action_args['resume_with'], action_args[\n                    'interruption_point']\n                next = pickle.loads(action_args['interruption_point']).switch(\n                    should_resume, resume_with, interruption_point)\n            else:\n                raise NotImplementedError('unknown action: %s' % action)\n\n    @classmethod\n    def start(cls, init_func, *args, **kwargs):\n        scheduler = Scheduler()\n        init_greenlet = greenlet.greenlet(functools.partial(init_func, *args, **kwargs))\n        scheduler('init', {\n            'init_greenlet': init_greenlet,\n        })\n\n    @classmethod\n    def interrupt(cls, pi_args=None):\n        should_resume, resume_with, interruption_point = cls.switch_to_scheduler('interrupt', {\n            'switched_from': greenlet.getcurrent()\n        })\n        if should_resume:\n            return resume_with\n        else:\n            pi = ProcessInterrupt(interruption_point, pi_args)\n            raise pi\n\n    @classmethod\n    def resume(cls, interruption_point, resume_with=None):\n        cls.switch_to_scheduler('resume', {\n            'interruption_point': interruption_point,\n            'resume_with': resume_with\n        })\n\n    @classmethod\n    def switch_to_scheduler(cls, *args, **kwargs):\n        return cls.current.instance.scheduler_greenlet.switch(*args, **kwargs)\n\n\nif '__main__' == __name__:\n    def init():\n        try:\n            print('hello')\n            print(Scheduler.interrupt())\n            print('!!!')\n        except ProcessInterrupt as pi:\n            pi.resume('world')\n            print('???')\n\n        try:\n            print('hello')\n            raise Exception()\n            print('!!!')\n        except:\n            print('world')\n            print('???')\n\n    Scheduler.start(init)\n\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "6"}