{"title": "python学习笔记-魔术方法，让自定义类更像内置类型 - helloword ", "index": "python", "content": "Python的魔术方法是Python中那些预定义的像__XXX__类型的函数。使用Python的魔术方法的最大优势在于python提供了简单的方法让对象可以表现得像内置类型一样。\n__str__函数\n__str__函数用于处理打印实例本身的时候的输出内容。如果没有覆写该函数，则默认输出一个对象名称和内存地址。例如：\n>>> class Student(object):\n...     def __init__(self,name):\n...             self._name = name\n...\n>>> print Student()\n输出：<__main__.Student object at 0x0000000002A929E8>.那么我们如何让输出的结果可读性更高一点呢？我们可以覆写__str__函数。例如\n>>> class Student(object):\n...     def __init__(self, name):\n...             self._name = name\n...     def __str__(self):\n...             return  \"I'm a student, named %s\" % self._name\n...\n>>> print Student(\"Charlie\")\n输出结果就是：I'm a student, named Charlie.我们将str()函数作用于该对象的时候，其实是调用了该对象的__str__函数。\n_repr_ 函数\n__repr__也是将对象序列化，但是__repr__更多的是给python编译器看的。__str__更多的是可读性(readable)。我们将repr()函数作用于摸某一个对象的时候，调用的其实就是该函数的__repr__函数。\n与repr()成对的是eval()函数。eval()函数是将序列化后的对象重新转为对象。前提是该对象实现了__repr__函数。\n上面这一段话基于自己的理解，不知道对错。\n>>> item = [1,2,3]\n>>> repr(item)\n'[1, 2, 3]'\n>>> other_item = eval(repr(item))\n>>> other_item[1]\n2\n__iter__函数\n我们经常对list或者tuple使用for...in...来迭代。那是list继承自Iterable。Iterable实现了__iter__函数。\n要想将一个自定义的对象变成一个可迭代的对象，那么必须要实现两个方法：__iter__和next.\n__iter__函数返回一个对象。迭代的时候则会不断地调用next函数拿到下一个值，直到捕获到StopIteration停止。廖雪峰老师教程里写的是__next__方法，不知道为啥。\nclass Fib(object):\n    def __init__(self):\n        self.a, self.b = 0, 1\n\n    def __iter__(self):\n        return self\n\n    def next(self):\n        self.a, self.b = self.b, self.a + self.b\n        if self.a > 10000:\n            raise StopIteration\n        return self.a\n\n\nfor i in Fib():\n    print i\n__getitem__函数\n上面通过实现__iter__函数实现对象的迭代。那么如何实现对象按下标取出元素呢。这是通过实现对象的__getitem__方法。我们来举一个?子。我们新建了一个类MyList，我们要办它实现普通list的一些功能，比如（1）根据下标获取值；（2）正数顺序单步长切片 （3）任意步长切片\nclass MyList(object):\n    def __init__(self, *args):\n        self.numbers = args\n\n    def __getitem__(self, item):\n        return self.numbers[item]\n\n\nmy_list = MyList(1, 2, 3, 4, 6, 5, 3)\nprint my_list[2]\n当然，上面实现了根据下标获取值。但是这还不够。我们还需要实现切片功能。例如my_list[1:3].我们对对象进行切片操作的时候，调用的气势也是__getitem__函数。此时，该函数获取到的并不是int对象，而是slice对象。例如下面的代码\nclass MyList(object):\n    def __init__(self, *args):\n        self.numbers = args\n\n    def __getitem__(self, item):\n        if isinstance(item, int):\n            return self.numbers[item]\n        elif isinstance(item, slice):\n            # 写习惯了其他语言，差点忘记了三元运算符的格式了，吼吼吼。\n            # 下面句三元运算符的意思是，若为空，则为切片从0开始。\n            start = item.start if item.start is not None else 0\n            # 下面句三元运算符的意思是，若为空，则为切片到最末端结束。\n            stop = item.stop if item.stop is not None else len(self.numbers)\n            return self.numbers[start:stop]\n\n\nmy_list = MyList(1, 2, 3, 4, 6, 5, 3)\nprint my_list[2:5]\n上面的代码终于实现了切片功能，但是还没考虑负数呢。那么我们加一把劲再来改一下。代码如下：\nclass MyList(object):\n    def __init__(self, *args):\n        self.numbers = args\n\n    def __getitem__(self, item):\n        if isinstance(item, int):\n            return self.numbers[item]\n        elif isinstance(item, slice):\n            start = item.start if item.start is not None else 0\n            stop = item.stop if item.stop is not None else len(self.numbers)\n\n            length = len(self.numbers)\n            start = length + start + 1 if start < 0 else start\n            stop = length + stop + 1 if stop < 0 else stop\n            return self.numbers[start:stop]\n\nmy_list = MyList(1, 2, 3, 4, 6, 5, 3)\nprint my_list[1:-1]\n哇塞，写完了，棒棒棒\n_getattar_\n\n在调用某一个对象不存在的属性或者方法的时候，会抛出一个一个AttributeError错误。但是如果我们实现了类中的魔术方法__getattar__，那么在调用不存在的属性或者方法的时候，就会调用该魔术方法。\nclass Apple(object):\n    def __getattr__(self, item):\n        if item == \"attar1\":\n            return \"print\"\n        if item == \"method1\":\n            return lambda x: \"hello %s\" % x\n\n\napple = Apple()\nprint apple.attar1\nprint apple.method1\n__getattar__函数一个重要的适用场景就是实现链式调用。例如我们在调用某一个api的时候：\nGET users/articles/index\n那么我们就希望我们的代码可以实现`Api.users.articles.index这么调用。思考一下，要实现链式调用，最重要的就是每一个调用都是返回一个实例～～。\n# coding=utf-8\nclass Api(object):\n    def __init__(self, path=''):\n        self._path = path\n\n    def __getattr__(self, name):\n        return Api(\"%s/%s\" % (self._path, name))\n\n    # 定义一个Post方法来发送请求\n    def post(self):\n        print self._path\n\n\napi = Api()\napi.user.articles.index.post()\n廖雪峰在他的教程中给我们出了一个题目：例如调用github的api：users/:user/repos一样，中间的user名需要动态替换。我们希望能api.users(\"charlie\").repos这么调用。那么代码该如何实现呢？这可能需要用到另一个方法__call__\n_call_ 函数\n一个对象既有属性，又有方法。我们在调用一个实例的方法的时候，我们可以使用instance.method()的形式调用。其实也可以将实例本身看成一个函数用来调用，我们需要做的就是实现__call__函数本身。\nclass Apple(object):\n    def __call__(self, *args, **kwargs):\n        return args\n\n\napple = Apple()\nprint apple(\"yes\", \"no\")\n此时我们再来看一下上面提到的实现api.users(\"charlie\").repos链式调用的方法。\n# coding=utf-8\nclass Api(object):\n    def __init__(self, path=''):\n        self._path = path\n\n    def __getattr__(self, name):\n        return Api(\"%s/%s\" % (self._path, name))\n\n    def __call__(self, args):\n        self._path = \"%s/%s\" % (self._path, args)\n        return Api(self._path)\n\n    # 定义一个Post方法来发送请求\n    def post(self):\n        print self._path\n\n\napi = Api()\napi.users(\"Charlie\").index.post()\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}