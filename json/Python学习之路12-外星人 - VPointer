{"title": "Python学习之路12-外星人 - VPointer ", "index": "python,pygame", "content": "《Python编程：从入门到实践》笔记。本章主要是对上一篇的继续，添加“外星人”，“外星人”与飞船的交互。\n1. 回顾项目\n开发较大的项目时，进入每个开发阶段前回顾一下开发计划，搞清楚接下来要通过代码实现哪些功能至关重要。本篇将设计一下内容：\n\n研究即有代码，确定实现新功能前是否需要重构代码\n在屏幕左上角添加一个外星人，并指定合适的边距\n根据第一个外星人的边距和屏幕尺寸计算屏幕上可容纳多少个外星人。编写一个循环来填满屏幕的上半部分\n让外星舰队向两边和下方移动，直到外星人被全部击落，或有外星人撞到飞船，或有外星人抵达屏幕底部。如果所有外星人都被击落，再创建一批外星人。如果有外星人撞到飞船或到达屏幕底部，则销毁飞船并再创建一群外星人。\n限制玩家可用的飞机数，消耗完则游戏结束\n\n希望各位上一篇的代码没有删掉。在开始新的代码前，我们先在前面的check_keydown_events()函数中添加“通过快捷键Q结束游戏”的代码:\ndef check_keydown_event(event, ship, ai_settings, screen, bullets):\n    -- snip --\n    elif event.key == pygame.K_q:\n        sys.exit()\n2. 创建外星人\n首先我们需要编写一个外星人Alien类。新建alien.py模块，在其中加入如下代码：\nimport pygame\nfrom pygame.sprite import Sprite\n\nclass Alien(Sprite):\n    \"\"\"表示单个外星人的类\"\"\"\n    def __init__(self, ai_settings, screen):\n        \"\"\"初始化外星人并设置其起始位置\"\"\"\n        super(Alien, self).__init__()\n        self.screen = screen\n        self.ai_settings = ai_settings\n\n        # 加载外星人图像，并设置其rect属性\n        self.image = pygame.image.load(\"images/alien.bmp\")\n        self.rect = self.image.get_rect()\n\n        # 每个外星人最初都在屏幕左上角附近\n        self.rect.x = self.rect.width\n        self.rect.y = self.rect.height\n\n        # 存储外星人的准确位置\n        self.x = float(self.rect.x)\n\n    def blitme(self):\n        \"\"\"在指定位置绘制外星人\"\"\"\n        self.screen.blit(self.image, self.rect)\n它和Bullet类一样继承自Sprite类。现在开始创建多行外星人。\n2.1 修改game_functions.py模块\n首先在game_functions.py模块中添加create_fleet()函数用于创建外星舰队：\ndef create_fleet(ai_settings, screen, ship, aliens):\n    \"\"\"创建外星舰队\"\"\"\n    alien = Alien(ai_settings, screen)\n    # 计算每行能放多少个\n    number_aliens_x = get_number_aliens_x(ai_settings, alien.rect.width)\n    # 计算能放多少行\n    number_rows = get_number_rows(ai_settings, ship.rect.height,\n                                  alien.rect.height)\n\n    # 嵌套循环创建外星舰队\n    for row_number in range(number_rows):\n        for alien_number in range(number_aliens_x):\n            # 创建外星人并将其加入舰队\n            create_alien(ai_settings, screen, aliens, alien_number, row_number)\n然后我们依次补充下面三个函数（注意各个函数的参数），这三个函数也位于game_functions.py中：\nget_number_aliens_x(): 计算一行能放多少个外星人\ndef get_number_aliens_x(ai_settings, alien_width):\n    \"\"\"计算每行可容纳多少个外星人\"\"\"\n    # 左右两侧留出一个外星人的宽度\n    available_space_x = ai_settings.screen_width - 2 * alien_width\n    # 列间距为一个外星人宽度\n    number_aliens_x = int(available_space_x / (2 * alien_width))\n    return number_aliens_x\nget_number_rows(): 计算能放多少行外星人\ndef get_number_rows(ai_settings, ship_height, alien_height):\n    \"\"\"计算屏幕可容纳多少行外星人\"\"\"\n    # 可用高度 = 窗口高度 - 上方一个外星人高度 - 下方一个飞船高度 - 两个外星人高度作为缓冲空间\n    available_space_y = (ai_settings.screen_height - 3 * alien_height - ship_height)\n    # 行距为一个外星人高度\n    number_rows = int(available_space_y / (2 * alien_height))\n    return number_rows\ncreate_alien(): 创建外星人\ndef create_alien(ai_settings, screen, aliens, alien_number, row_number):\n    \"\"\"创建一个外星人并将其放在当前行\"\"\"\n    alien = Alien(ai_settings, screen)\n    # 下面就是根据上面的公式计算每一个外星人在窗口中的位置（这是左上角的坐标）\n    alien.x = alien.rect.width * (1 + 2 * alien_number)\n    alien.rect.x = alien.x\n    alien.rect.y = alien.rect.height * (1 + 2 * row_number)\n    aliens.add(alien)\n现在我们还需要修改update_screen()函数：\ndef update_screen(ai_settings, screen, ship, bullets, aliens):\n    -- snip --\n    # 绘制外星人，放在绘制子弹的代码后面，让外星人的图像覆盖掉子弹的图像\n    aliens.draw(screen)\n    -- snip --\n注意，该函数增加了一个参数aliens，这是个Group对象，所以代码中的draw()方法也跟前一篇中的bullets.update()方法一样，一行代码更新所有对象。\n2.2 修改alien_invasion.py模块\n在主程序中添加创建外星人的代码：\ndef run_game():\n    -- snip --\n    gf.create_fleet(ai_settings, screen, ship, aliens)\n\n    while True:\n        -- snip --\n        # 比之前代码多传入了一个aliens参数\n        gf.update_screen(ai_settings, screen, ship, bullets, aliens)\n        \n-- snip --\n现在我们执行程序将会得到如下结果：\n\n3. 让外星舰队动起来\n我们将让外星舰队在窗体中向右移动，撞到屏幕边缘后下以一定距离下降，再沿反方向移动，直到外星人被消灭，或外星人撞上飞船，或有外星人到达窗体底部。\n3.1 补充settings.py模块\nclass Settings:\n    def __init__(self):\n        -- snip --\n        self.fleet_drop_speed = 10\n        # 外星舰队方向标志：1向右，-1向左\n        # 也可以用如left, right之类的标志，但这样会很麻烦\n        self.fleet_direction = 1\n3.2 修改alien.py模块\n我们需要在Alien类中添加两个方法，一个用于检测窗体边缘，一个用于更新Alien对象：\nclass Alien(Sprite):\n    -- snip --\n    def check_edges(self):\n        \"\"\"如果外星人位于屏幕边缘则返回True\"\"\"\n        screen_rect = self.screen.get_rect()\n        return self.rect.right >= screen_rect.right or self.rect.left <= 0\n\n    def update(self):\n        \"\"\"向右移动外星人\"\"\"\n        # 以后这样的方式会用的很多\n        self.x += self.ai_settings.alien_speed_factor * self.ai_settings.fleet_direction\n        self.rect.x = self.x\n如果使用文本值来控制方向，那就需要添加if-else语句来检测舰队移动方向。鉴于只有两个可能的方向，这里使用-1和1来表示，这样更容易改变外星人对象的坐标。\n3.3 修改game_functions.py模块\n首先，我们在该模块中添加一个更新外星舰队的函数update_aliens()：\ndef update_aliens(ai_settings, aliens):\n    \"\"\"检查是否有外星人位于屏幕边缘，并更新外星舰队中所有外星人的位置\"\"\"\n    check_fleet_edges(ai_settings, aliens)\n    aliens.update()  # “一键更新”\ncheck_fleet_edges()函数用于检测舰队是否碰到了窗体边缘，代码如下：\ndef check_fleet_edges(ai_settings, aliens):\n    \"\"\"有外星人到达边缘时采取相应的措施\"\"\"\n    # 检测舰队中每一个外星人是否碰到了窗体边缘\n    for alien in aliens.sprites():\n        if alien.check_edges():\n            change_fleet_direction(ai_settings, aliens)\n            break\nchange_fleet_direction()函数用于改变舰队的移动方向，以及让舰队向下移动，代码如下：\ndef change_fleet_direction(ai_settings, aliens):\n    \"\"\"将外星舰队下移，并改变它们的方向\"\"\"\n    for alien in aliens.sprites():\n        alien.rect.y += ai_settings.fleet_drop_speed\n    ai_settings.fleet_direction *= -1\n上面三个函数就是在game_functions.py中的所有变动。\n3.4 修改alien_invasion.py模块\n在该模块中我们只需要在while循环中添加一行代码：\n# 开始游戏的主循环\n    while True:\n        gf.check_events(ai_settings, screen, ship, bullets)\n        ship.update()\n        gf.update_bullets(bullets)\n        # 添加对外星舰队的修改\n        gf.update_aliens(ai_settings, aliens)\n        gf.update_screen(ai_settings, screen, ship, bullets, aliens)\n最后运行主程序，得到如下效果：\n\n截了一张静态图，实际是动态的。\n4. 击杀外星人\n对于当前的程序，如果发射子弹，子弹将穿过外星人，而不是击杀，下面我们继续完善该项目，使其能击杀外星人。而要实现这一点，关键就是要检测到子弹图像与外星人图像是否重叠，重叠了则表示击中。\n4.1 修改game_functions.py\n为何检测子弹与卫星人的碰撞，我们需要修改update_bullets()函数，这里我们增加了update_bullets()的参数，还调用了一个新函数：\ndef update_bullets(bullets, aliens, ship, screen, ai_settings):\n    -- snip --\n    check_bullet_alien_collisions(ai_settings, screen, ship, aliens, bullets)\n函数check_bullet_alien_collisions()用于检测子弹与外星人的碰撞，当外星人被消灭光时，清空现有子弹，并生成新的外星舰队，它的代码如下：\ndef check_bullet_alien_collisions(ai_settings, screen, ship, aliens, bullets):\n    \"\"\"检测是否有子弹击中了外星人，如果有，就删除相应的子弹和外星人\"\"\"\n    # 下一篇中我们将用该变量实现分数统计\n    collisions = pygame.sprite.groupcollide(bullets, aliens, True, True)\n    \n    #如果外星人被消灭光，则生成新的外星人舰队\n    if len(aliens) == 0:\n        # 删除现有的子弹并创建新的舰队\n        bullets.empty()\n        create_fleet(ai_settings, screen, ship, aliens)\nsprite.groupcollide()方法用于检测对象之间的碰撞，它将bullets中的每个子弹的rect与aliens中的每个外星人的rect进行比较，并返回一个字典。该字典以第一个参数中的对象为键，以第二个参数中的键为值，在这里，以bullets中发生了碰撞的bullet为键，它的值为与之碰撞的alien（不是aliens）！第三个参数表示是否删除第一个参数中发生了碰撞的对象，而四个参数表示是否删除第二个参数中发生了碰撞的对象。\n4.2 修改alien_invasion.py\n只需要修改调用update_bullets()函数的那行代码即可，增加几个参数：\ngf.update_bullets(bullets, aliens, ship, screen, ai_settings)\n基础功能基本完成。\n4.3 测试技巧补充\n对于上述代码，我们可能需要测试当消灭完外星人后，新的舰队是否能被正确创建等，如果我们以现在游戏的设定，即子弹速度为1，子弹宽度为3，那测试起来将会很痛苦。此时，我们可以修改修改游戏的参数，比如将子弹宽度修改为300，子弹速度修改为3，这样就相当于对游戏进行了快进，此时代码的运行效果如下：\n\n不过最后记得将参数修改回去。\n5. 结束游戏\n接下来我们实现外星人碰到飞船，外星人抵达窗体底部，飞船数用光导致游戏结束的代码。\n5.1 创建GameStats类\n首先我们创建一个用于存储游戏信息的GameStats类，存放在game_stats.py文件中：\nclass GameStats:\n    \"\"\"跟踪游戏的统计信息\"\"\"\n    def __init__(self, ai_settings):\n        \"\"\"初始化统计信息\"\"\"\n        # 用于控制游戏启动与否\n        self.game_active = True\n        self.ai_settings = ai_settings\n        self.reset_stats()\n\n    def reset_stats(self):\n        \"\"\"初始化在游戏运行期间可能变化的统计信息\"\"\"\n        # 重置飞船数\n        self.ships_left = self.ai_settings.ship_limit\n5.2 修改settings.py\n从上述代码可以看出，我们需要在settings.py中添加一项表示“飞船数”的信息：\nclass Settings:\n    def __init__(self):\n        \"\"\"初始化游戏的设置\"\"\"\n        # 屏幕设置\n        -- snip --\n        # 设置飞船数量限制\n        self.ship_limit = 3\n        -- snip --\n5.3 响应飞船与外星人的碰撞，修改game_functions.py\n我们在更新每个外星人的位置后立即检测外星人和飞船之间的碰撞，随后再检查外星人是否到达了窗体底部。修改update_aliens()函数，使用sprite中的spritecollideany()方法来检测碰撞：将第二参数中的每一个元素与第一个参数比较，检测是否碰撞，返回第二个参数中第一个发生碰撞的对象，如果没有发生碰撞则返回None:\n# 增加了参数和碰撞检测\ndef update_aliens(ai_settings, aliens, ship, screen, bullets, stats):\n    -- snip --\n    # 检测外星人和飞船之间的碰撞\n    if pygame.sprite.spritecollideany(ship, aliens):\n        ship_hit(ai_settings, stats, screen, ship, aliens, bullets)\n\n    check_aliens_bottom(ai_settings, stats, screen, ship, aliens, bullets)\n为此我们需要增加两个函数：\nship_hit():当外星人与飞船发生碰撞时，调用次函数\n-- snip --\nfrom time import sleep\n\ndef ship_hit(ai_settings, stats, screen, ship, aliens, bullets):\n    \"\"\"响应被外星人撞到的飞船\"\"\"\n    # 将ship_left减1\n    if stats.ships_left > 0:\n        stats.ships_left -= 1\n\n        # 清空外星人列表和子弹列表\n        aliens.empty()\n        bullets.empty()\n\n        # 创建一群新的外星人，并将飞船恢复到初始位置\n        create_fleet(ai_settings, screen, ship, aliens)\n        ship.center_ship()\n\n        # 暂停\n        sleep(0.5)\n    else:\n        stats.game_active = False\n从上面的代码还可以看出，我们还需要在Ship类中添加一个center_ship()方法：\ndef center_ship(self):\n    \"\"\"让飞船在屏幕上居中\"\"\"\n    self.center = self.screen_rect.centerx\ncheck_aliens_bottom(): 当飞船到达窗体底部时调用次函数\ndef check_aliens_bottom(ai_settings, stats, screen, ship, aliens, bullets):\n    \"\"\"检测是否有外星人到达了屏幕底部\"\"\"\n    screen_rect = screen.get_rect()\n    for alien in aliens.sprites():\n        if alien.rect.bottom >= screen_rect.bottom:\n            # 和飞船被碰撞是的代码没啥区别，故调用同一个函数\n            ship_hit(ai_settings, stats, screen, ship, aliens, bullets)\n            break\n5.4 修改主程序alien_invasion.py\n修改游戏的循环部分：\n# 开始游戏的主循环\nwhile True:\n    gf.check_events(ai_settings, screen, ship, bullets)\n    \n    # 决定程序运行时该执行的部分\n    if stats.game_active:\n        ship.update()\n        gf.update_bullets(bullets, aliens, ship, screen, ai_settings)\n        gf.update_aliens(ai_settings, aliens, ship, screen, bullets, stats)\n\n    gf.update_screen(ai_settings, screen, ship, bullets, aliens)\n在主循环中，任何情况下都需要调用check_events()，即使游戏处于非活动状态；还需要不断更新屏幕，以便在等待玩家是否选择重新开始游戏时能够修改屏幕；其他函数仅在游戏处于活动状态时太需要调用。\n6. 小结\n本篇讲述了：\n\n如何在游戏中添加大量相同的元素；\n如何用嵌套循环来创建元素网格；\n如何控制对象在屏幕上移动的方向以及响应事件；\n如何检测和响应元素碰撞；\n如何在游戏中跟踪统计信息；\n如何使用标志game_active来判断游戏是否结束。\n\n下一篇中，同时也是本项目的最后一篇，我们将：\n\n添加一个Play按钮让玩家能够开始游戏，以及游戏结束后再开始；\n每当玩家消灭一群外星人后，加快游戏节奏；\n添加一个分数系统。\n\n\n迎大家关注我的微信公众号\"代码港\" & 个人网站 www.vpointer.net ~\n\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "1"}