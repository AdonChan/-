{"title": "Essential SQLAlchemy2th学习笔记之ORM模块 - 倚楼听风雨 ", "index": "sqlalchemy,python", "content": "定义模式Defining Schema\n定义ORM类的4个步骤：\n\n继承declarative_base()函数返回的类\n定义__tablename__属性来指定表名\n定义列属性\n定义至少一个主键\n\nfrom sqlalchemy import Table, Column, Integer, Numeric, String\nfrom sqlalchemy.ext.declarative import declarative_base\n\nBase = declarative_base()\n\nclass Cookie(Base):\n    __tablename__ = 'cookies'\n    \n    cookie_id = Column(Integer(), primary_key=True)\n    cookie_name = Column(String(50), index=True)\n    cookie_recipe_url = Column(String(255))\n    cookie_sku = Column(String(55))\n    quantity = Column(Integer())\n    unit_cost = Column(Numeric(12, 2))\n\n你可以查看Cookie类的__table__属性：如下\n>>> Cookie.__table__\nTable('cookies', MetaData(bind=None),\n    Column('cookie_id', Integer(), table=<cookies>, primary_key=True,\n        nullable=False),\n    Column('cookie_name', String(length=50), table=<cookies>),\n    Column('cookie_recipe_url', String(length=255), table=<cookies>),\n    Column('cookie_sku', String(length=15), table=<cookies>),\n    Column('quantity', Integer(), table=<cookies>),\n    Column('unit_cost', Numeric(precision=12, scale=2),\n        table=<cookies>), schema=None)\nKeys, Constraints, and Indexes\nclass SomeDataClass(Base):\n__tablename__ = 'somedatatable'\n__table_args__ = (ForeignKeyConstraint(['id'], ['other_table.id']),\n                  CheckConstraint(unit_cost >= 0.00',\n                                  name='unit_cost_positive'))\n\nRelationships\nfrom sqlalchemy import ForeignKey, Boolean\nfrom sqlalchemy.orm import relationship, backref\n\nclass Order(Base):\n    __tablename__ = 'orders'\n    order_id = Column(Integer(), primary_key=True)\n    #定义外键\n    user_id = Column(Integer(), ForeignKey('users.user_id'))\n    shipped = Column(Boolean(), default=False)\n    #定义one-to-many关系\n    user = relationship(\"User\", backref=backref('orders', order_by=order_id))\n\nclass LineItem(Base):\n    __tablename__ = 'line_items'\n    line_item_id = Column(Integer(), primary_key=True)\n    order_id = Column(Integer(), ForeignKey('orders.order_id'))\n    cookie_id = Column(Integer(), ForeignKey('cookies.cookie_id'))\n    quantity = Column(Integer())\n    extended_cost = Column(Numeric(12, 2))\n    order = relationship(\"Order\", backref=backref('line_items',\n                                                  order_by=line_item_id))\n    #定义one-to-one关系，uselist=False\n    cookie = relationship(\"Cookie\", uselist=False)\n\nPersisting the Schema\nfrom sqlalchemy import create_engine\nengine = create_engine('sqlite:///:memory:')\nBase.metadata.create_all(engine) #这个Base是前面的Base = declarative_base()\nWorking with Data via SQLAlchemy ORM\nSession\nsession对象负责与数据库交互，封装了来自engine的connection，transaction.session中的事物会一直打开，除非调用session的commit()或rollback()方法，或close(),remove()方法。你应该使用sessionmaker工厂类来创建Session类，因为这确保了配置参数的正确性。一个应用应该只调用sessionmaker一次。\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\nengine = create_engine('sqlite:///:memory:')\nSession = sessionmaker(bind=engine)\nsession = Session()\nsession对象包含创建数据库连接所需的一切信息，它不会立即创建连接对象，而是会在我们进行具体操作时创建。\n插入数据\ncc_cookie = Cookie(cookie_name='chocolate chip',\ncookie_recipe_url='http://some.aweso.me/cookie/recipe.html',\ncookie_sku='CC01',\nquantity=12,\nunit_cost=0.50)\nsession.add(cc_cookie)\nsession.commit()\n当我们调用add()的时候，它不会在数据库执行insert操作，而当我们调用commit()的时候，将会发生如下步骤：\n#start a transaction.\nINFO:sqlalchemy.engine.base.Engine:BEGIN (implicit)\n#Insert the record into the database\nINFO:sqlalchemy.engine.base.Engine:INSERT INTO cookies (cookie_name,\ncookie_recipe_url, cookie_sku, quantity, unit_cost) VALUES (?, ?, ?, ?, ?)\n\n#The values for the insert.\nINFO:sqlalchemy.engine.base.Engine:('chocolate chip',\n'http://some.aweso.me/cookie/recipe.html', 'CC01', 12, 0.5) \n#Commit the transaction.\nINFO:sqlalchemy.engine.base.Engine:COMMIT\n如果你想打印这些细节信息，你可以传递echo=True到create_engine函数中。注意生产环境不要使用这个选项。\n批量插入\n文档地址Session.bulk_save_objects()，Session.bulk_update_mappings()\nc1 = Cookie(cookie_name='peanut butter',\n            cookie_recipe_url='http://some.aweso.me/cookie/peanut.html',\n            cookie_sku='PB01',\n            quantity=24,\n            unit_cost=0.25)\nc2 = Cookie(cookie_name='oatmeal raisin',\n            cookie_recipe_url='http://some.okay.me/cookie/raisin.html',\n            cookie_sku='EWW01',\n            quantity=100,\n            unit_cost=1.00)\nsession.bulk_save_objects([c1, c2])\nsession.commit()\nprint(c1.cookie_id)\n\n除了bulk_save_objects，还有Session.bulk_update_mappings(), 如下：它允许我们通过字典列表来进行插入\ns.bulk_insert_mappings(User,\n  [dict(name=\"u1\"), dict(name=\"u2\"), dict(name=\"u3\")]\n)\n对于批量更新，还有个Session.bulk_update_mappings()\n查询\ncookies = session.query(Cookie).all()\nprint(cookies)\n\n#使用迭代方式\nfor cookie in session.query(Cookie):\n    print(cookie)\n其余方法：\n\nall()\nfirst()\none():如果有多条结果，会抛出异常。\nscalar()\n\n关于选择的最佳实践：1、使用迭代方式获取所有值，而不是all()。内存友好2、使用first()获取单条数据，而不是one(),scalar()3、尽量不要使用scalar()\n控制查询的列数目\nprint(session.query(Cookie.cookie_name, Cookie.quantity).first())\n排序\nfor cookie in session.query(Cookie).order_by(Cookie.quantity):\n    print('{:3} - {}'.format(cookie.quantity, cookie.cookie_name))\n    \nfrom sqlalchemy import desc\nfor cookie in session.query(Cookie).order_by(desc(Cookie.quantity)):\n    print('{:3} - {}'.format(cookie.quantity, cookie.cookie_name))\nlimiting限制返回的结果数\nquery = session.query(Cookie).order_by(Cookie.quantity).limit(2)\nprint([result.cookie_name for result in query])\n内置SQL函数与别名\nfrom sqlalchemy import func\ninv_count = session.query(func.sum(Cookie.quantity)).scalar()\nprint(inv_count)\n\nrec_count = session.query(func.count(Cookie.cookie_name)).first()\nprint(rec_count) #(5,) 得到的是一个元组，而不是像scalar()那样得到单个值\n\n#别名\nrec_count = session.query(func.count(Cookie.cookie_name) \\\n.label('inventory_count')).first()\nprint(rec_count.keys())\nprint(rec_count.inventory_count)\n过滤\nrecord = session.query(Cookie).filter(Cookie.cookie_name == 'chocolate chip').first()\nprint(record)\nrecord = session.query(Cookie).filter_by(cookie_name='chocolate chip').first()\nprint(record)\n注意：filter与filter_by的区别\nquery = session.query(Cookie).filter(Cookie.cookie_name.like('%chocolate%'))\nfor record in query:\n    print(record.cookie_name)\n操作符\n\n+，-，*,/,%\n==,!=,<,>,<=,>=\nAND,OR,NOT,由于python关键字的原因，使用and_(),or_(),not_()来代替\n\n+号还可以用于字符串拼接：\nresults = session.query(Cookie.cookie_name, 'SKU-' + Cookie.cookie_sku).all()\nfor row in results:\n    print(row)\n    \nfrom sqlalchemy import and_, or_, not_\nquery = session.query(Cookie).filter(or_(\n    Cookie.quantity.between(10, 50),\n    Cookie.cookie_name.contains('chip')\n    )\n)\nfor result in query:\n    print(result.cookie_name)\n更新Updating Data\nquery = session.query(Cookie)\ncc_cookie = query.filter(Cookie.cookie_name == \"chocolate chip\").first()\ncc_cookie.quantity = cc_cookie.quantity + 120\nsession.commit()\nprint(cc_cookie.quantity)\n\n\n#通过字典方式更新\nquery = session.query(Cookie)\nquery = query.filter(Cookie.cookie_name == \"chocolate chip\")\nquery.update({Cookie.quantity: Cookie.quantity - 20})\ncc_cookie = query.first()\nprint(cc_cookie.quantity)\n删除Deleting Data\nquery = session.query(Cookie)\nquery = query.filter(Cookie.cookie_name == \"dark chocolate chip\")\ndcc_cookie = query.one()\nsession.delete(dcc_cookie)\nsession.commit()\ndcc_cookie = query.first()\nprint(dcc_cookie)\n\n#或者这样\nquery = session.query(Cookie)\nquery = query.filter(Cookie.cookie_name == \"molasses\")\nquery.delete()\n添加关联对象\no1 = Order()\no1.user = cookiemon\nsession.add(o1)\ncc = session.query(Cookie).filter(Cookie.cookie_name ==\n                                  \"chocolate chip\").one()\nline1 = LineItem(cookie=cc, quantity=2, extended_cost=1.00)\npb = session.query(Cookie).filter(Cookie.cookie_name ==\n                                  \"peanut butter\").one()\nline2 = LineItem(quantity=12, extended_cost=3.00)\nline2.cookie = pb\nline2.order = o1\no1.line_items.append(line1)\no1.line_items.append(line2)\nsession.commit()\n\nJoins\nquery = session.query(Order.order_id, User.username, User.phone,\n                      Cookie.cookie_name, LineItem.quantity,\n                      LineItem.extended_cost)\nquery = query.join(User).join(LineItem).join(Cookie)\nresults = query.filter(User.username == 'cookiemon').all()\nprint(results)\n\n\nquery = session.query(User.username, func.count(Order.order_id))\nquery = query.outerjoin(Order).group_by(User.username)\nfor row in query:\n    print(row)\n自关联表的定义\nclass Employee(Base):\n    __tablename__ = 'employees'\n    id = Column(Integer(), primary_key=True)\n    manager_id = Column(Integer(), ForeignKey('employees.id'))\n    name = Column(String(255), nullable=False)\n    manager = relationship(\"Employee\", backref=backref('reports'),\n                           remote_side=[id])\nBase.metadata.create_all(engine)\n\n注：使用remote_side来定义自关联的多对一关系\nmarsha = Employee(name='Marsha')\nfred = Employee(name='Fred')\nmarsha.reports.append(fred)\nsession.add(marsha)\nsession.commit()\n\nfor report in marsha.reports:\n    print(report.name)\n分组\nquery = session.query(User.username, func.count(Order.order_id))\nquery = query.outerjoin(Order).group_by(User.username)\nfor row in query:\n    print(row)\nChaining\ndef get_orders_by_customer(cust_name):\n    query = session.query(Order.order_id, User.username, User.phone,\n                          Cookie.cookie_name, LineItem.quantity,\n                          LineItem.extended_cost)\n    query = query.join(User).join(LineItem).join(Cookie)\n    results = query.filter(User.username == cust_name).all()\n    return results\nget_orders_by_customer('cakeeater')\n\n元素SQL查询\nsession.execute('select * from User')\nsession.execute(\"insert into User(name, age) values('bomo', 13)\")\nsession.execute(\"insert into User(name, age) values(:name, :age)\", {'name': 'bomo', 'age':12})\n建议使用text()来执行部分SQL查询\nfrom sqlalchemy import text\nquery = session.query(User).filter(text(\"username='cookiemon'\"))\nprint(query.all())\n\n[User(username='cookiemon', email_address='mon@cookie.com',\n      phone='111-111-1111', password='password')]\n\nSession与异常处理\nSession状态：\n\nTransient：实例不在session和数据库中。\nPending：对象通过add()方法被添加到session当中，但是并没有flushed或者committed\nPersistent:对象处于session中，同时在数据库中有对应的记录\nDetached:实例不在session中，但是数据库中有相关记录\n\n那么如何查看实例状态呢？可以通过SQLAlchemy的inspect()方法来查看,\ncc_cookie = Cookie('chocolate chip',\n                   'http://some.aweso.me/cookie/recipe.html',\n                   'CC01', 12, 0.50)\nfrom sqlalchemy import inspect\ninsp = inspect(cc_cookie)\nfor state in ['transient', 'pending', 'persistent', 'detached']:\n    print('{:>10}: {}'.format(state, getattr(insp, state)))\n\n输出：transient: Truepending: Falsepersistent: Falsedetached: False实际上，你应该使用insp.transient, insp.pending, insp.persistent, and insp.detached来获取某一个状态。\n如果要将一个实例变为detached状态，可以调用session的expunge()方法\nsession.expunge(cc_cookie)\n查看改变历史\nfor attr, attr_state in insp.attrs.items():\n    if attr_state.history.has_changes():\n        print('{}: {}'.format(attr, attr_state.value))\n        print('History: {}\\n'.format(attr_state.history))\n\n异常\n文档我们关系的主要有两个MultipleResultsFound，DetachedInstanceError.\nfrom sqlalchemy.orm.exc import MultipleResultsFound\ntry:\n    results = session.query(Cookie).one()\nexcept MultipleResultsFound as error:\n    print('We found too many cookies... is that even possible?')\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "3"}