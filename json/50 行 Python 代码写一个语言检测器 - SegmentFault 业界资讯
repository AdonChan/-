{"title": "50 行 Python 代码写一个语言检测器 - SegmentFault 业界资讯 ", "index": "语言检测,python", "content": "你有没有曾经好奇过 Chrome 浏览器是如何知道一个网页的语言，并对外国文字的网页提供翻译服务的？或者，Facebook 是如何翻译你朋友用写在你主页上的外国文字？检测一种语言实际上非常简单，改进了用户体验，而且不需要用户做任何的事情。\n\n我无意中发现的 ActiveState recipe for a language detector in Python这是非常不错的一段程序，但是我决定做点小小的改进。提供一些背景知识给那些不熟悉自然语言处理或者是程序语言学的人。\n\n如果你是有经验的程序员，你也许可以直接跳到这段文字最下端的程序部分。出奇的简单。\n\n你需要熟悉Python语法。如果你从来没有用过python， 我建议你读一下 Zed Shaw 的《Learn Python the Hard Way》。\n\n确定你下载并安装了python，而且可以正常运行程序。这段文字中的python不算很长，所以你可以用任何文本编辑器从而省去安装任何软件的麻烦。\n\n第一部分，什么检测到了一种语言？\n\n在你写区分语言的程序之前，你需要回答一个问题：什么区别了两种语言？\n\n有趣的是，这个问题的答案会根据不同的比较语言而有所不同。比如：\n\n女性が牛乳を飲んだ。 (译者注： 日语：女性喝牛奶。)\n\n你是怎么知道这句话不是英文的？你也许不熟悉日文，但是你肯定知道这些字符不是英文，你甚至不需要知道具体哪个字符不存在于英文字母中。\n\nLa femme boit du lait.   (译者注： 法语：女性喝牛奶。)\n\n你怎么知道这句话不是英文的？有一点麻烦。每个字母都在英文中。甚至每一个字母和句型结构都和英文的同一个意思的那句话很相似—— “The woman drank milk.” (译者注： 英语：女性喝牛奶。) 。 你的大脑用了另一个特性去判断这个：尽管字母很相似，这两句话发音没有任何相似之处。\n\n还有很多更复杂的方式去检测两种不同的语言（例如，语法、句法等等）上面提到的两个特性似乎足够用来区分很多的书写文字。\n\n提问：你可以想到一个相反的例子嘛？ 两种不能用字符或者发音而区分的语言？（译者注：这是我想到的，和编者没有任何关系。Hindi 和Nepali 的区分度极低，印度的一种语言和尼泊尔的官方语言的区别度非常低，字符区别很低而发音更高达50％的相似度。当然，他们两个是同一语系的语种。）\n\n第二部分，如何用计算机检测到这些特性？\n\n第一个特性已经存在于任何一台现代化的机器里 ——character encodings 字符解码允许任何一台计算机去通过二进制码而呈现每一个字符。我们要用unicode 在Python 的程序中。\n\n第二个特征更有意思。如何能让一台电脑检测到字符串的发音呢？答案比想象的简单点：字符串顺序是按照声音解码的！他们有直接的稳定的对应关系－ 语言改变的非常缓慢。\n\n因此，你可以用下面的两个特性去检测一行文本语言：\n\n单个字符的重复性\n字符串的重复性\n实际上，这两个特性浓缩到了一个特性中：字符串的顺序。单个字符的重复性只是字符串的重复性。\n\n快速知识补充：在计算机语言学中，字符串的长度 n 被定义为 n-gram。 “a” 是一个gram, 1-gram. “bc”是两个gram,2-gram or bigram。 “def” 是三个gram, 3-gram 或者trigram，以此类推。\n\n第三部分，用python 实现吧！\n\n首先，我们需要计算某个字符串在特定文本中出现的次数。为了封装结果，我们将建立一个NGram 类。\n\nclass NGram(object):\n    def __init__(self, text, n=3):\n        self.length = None\n        self.n = n\n        self.table = {}\n        self.parse_text(text)\n\n    def parse_text(self, text):\n        chars = ' ' * self.n # initial sequence of spaces with length n\n\n        for letter in (\" \".join(text.split()) + \" \"):\n            chars = chars[1:] + letter # append letter to sequence of length n\n            self.table[chars] = self.table.get(chars, 0) + 1 # increment count\n\n\n代码实际上很短，定义了一个NGram类去接受一个unicode的文本输入作为一个参数。它还定义了一个选择性的参数n作为定义字符序列的长度。这段程序读取了输入文本的每个字符然后建立了一个python 的词典（dictionary），该词典包含了所有小于n长度的字符序列以及相对应的出现频率。比如，输入:”Snail Mail.” 将得到3－gram 的词典：\n\n{\n  '  S': 1,\n  ' Sn': 1,\n  'Sna': 1,\n  'nai': 1,\n  'ail': 2,\n  'il ': 1,\n  'l M': 1,\n  ' Ma': 1,\n  'Mai': 1,\n  'il.': 1\n}\n\n\n第四部分：如何比较两个NGrams?\n\n即使上面介绍的NGram类可以用来计算字母序列出现的频率，我们始终不知道如何比较NGrams.我们想要在不同的语言中找到最接近匹配去代表那种语言。我们想要在一组给予的不同语言的Ngram 对象中，能找到最接近的匹配对象。为了协调匹配NGram 去找到最佳的匹配，我们引进了两个新的函数: calculate_length() 和 sub() 去允许Python 实现两个NGram对象之间的减法。\n\n这样的减法应用于多纬NGrams向量。每个独立的n 字符序列代表着向量的一个维度。Calculate_length()函数用来计算向量的长度（分散范围）。找到NGram向量间的角度就是找到向量间的相似性。这个技术被称做基于向量的查询 (这篇是基于perl 的文章，基本上用Perl 实现了这篇作者上面阐述的所有观点)。\n\n实现代码：\n\nclass NGram(object):\n    def __init__(self, text, n=3):\n        self.length = None\n        self.n = n\n        self.table = {}\n        self.parse_text(text)\n        self.calculate_length()\n\n    def parse_text(self, text):\n        chars = ' ' * self.n # initial sequence of spaces with length n\n\n        for letter in (\" \".join(text.split()) + \" \"):\n            chars = chars[1:] + letter # append letter to sequence of length n\n            self.table[chars] = self.table.get(chars, 0) + 1 # increment count\n\n    def calculate_length(self):\n        \"\"\" Treat the N-Gram table as a vector and return its scalar magnitude\n        to be used for performing a vector-based search.\n        \"\"\"\n        self.length = sum([x * x for x in self.table.values()]) ** 0.5\n        return self.length\n\n    def __sub__(self, other):\n        \"\"\" Find the difference between two NGram objects by finding the cosine\n        of the angle between the two vector representations of the table of\n        N-Grams. Return a float value between 0 and 1 where 0 indicates that\n        the two NGrams are exactly the same.\n        \"\"\"\n        if not isinstance(other, NGram):\n            raise TypeError(\"Can't compare NGram with non-NGram object.\")\n\n        if self.n != other.n:\n            raise TypeError(\"Can't compare NGram objects of different size.\")\n\n        total = 0\n        for k in self.table:\n            total += self.table[k] * other.table.get(k, 0)\n\n        return 1.0 - (float(total) / (float(self.length) * float(other.length))\n\n    def find_match(self, languages):\n        \"\"\" Out of a list of NGrams that represent individual languages, return\n        the best match.\n        \"\"\"\n        return min(languages, lambda n: self - n)\n\n\n第五部分：如何比较NGram?\n\n选择合适的NGram 模型相当的简单。你只需要将unicode的文本改成任何一种你想要选择的语言。\n\nenglish = NGram(training_text, n=3) #trigram\n\n\n如果你想比较两个NGram 模型。你可以用两个模型做减法来寻找两个模型的相似性（sub()是用来实现这个功能的）。\n\nsimilarity = english - NGram(text, n=3)\n\n\n如果你想用 Python list 或者iterator实现一个简单的基于向量的搜索， 你可以用NGram 类中的find_match(language)方式。搜索将在参数languages上实现对NGram对象的叠代。\n\nlanguages = [english, spanish, french]\nNGram(text, n=3).best_match(languages)\n\n\n正如你所见，真正的生产实现中的问题，在于寻找正确的数据去实现NGram 模型。如果你想建立一个很好的语言检测器，你需要找到一些很有代表性的文本例子去代表你想测试的语言。维基百科上有很多很好的例子可以作为你的数据来源。\n\n除了文本检测，你还可以用NGram 去做其他有意思的事情。Google 的浏览显示 就是一个很好的例子。它用了刚才创建的Python代码去实现了相似的统计应用。Google 还公开了做这个统计实验用的数据。\n\n第六部分： 现在该干些什么了呢？\n\n很多事情可以去做！我们从一个文本检测器开始，同样的方法可以在很多其他领域应用。比如说，你可以修改你的代码，让这个文本检测器不再只检测字母字符，而是直接进行词语匹配。理论上来说，这些词法顺序（用词的方式根据个人习惯而有所不同）可以用来鉴定一作者的写作。\n\nN-Grams的概念可以在不同的领域应用。比如：\n\n语法拼写建议（建议改正非正确语法词汇）\n鉴定DNA序列\n提高压缩算法的有效性\n改进搜索引擎\n改进语音识别系统和特征，通过某个特定词语会出现在另一个词语后面的概率\n尽管每种应用都会有所不同，但是本质上都是相似的，需要比较单独个体的相似性。当你需要使用序列时，不妨考虑NGram。\n\n原文：HOW TO WRITE A LANGUAGE DETECTOR IN 50 LINES OF PYTHON\n转载自：伯乐在线 - 人见人爱的土豆\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "7"}