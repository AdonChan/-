{"title": "Python 装饰器执行顺序迷思 - Python提高班 ", "index": "python", "content": "探究多个装饰器执行顺序\n\n装饰器是Python用于封装函数或代码的工具，网上可以搜到很多文章可以学习，我在这里要讨论的是多个装饰器执行顺序的一个迷思。\n疑问\n\n大部分涉及多个装饰器装饰的函数调用顺序时都会说明它们是自上而下的，比如下面这个例子:\ndef decorator_a(func):\n    print 'Get in decorator_a'\n    def inner_a(*args, **kwargs):\n        print 'Get in inner_a'\n        return func(*args, **kwargs)\n    return inner_a\n\ndef decorator_b(func):\n    print 'Get in decorator_b'\n    def inner_b(*args, **kwargs):\n        print 'Get in inner_b'\n        return func(*args, **kwargs)\n    return inner_b\n\n@decorator_b\n@decorator_a\ndef f(x):\n    print 'Get in f'\n    return x * 2\n\nf(1)\n\n上面代码先定义里两个函数: decotator_a, decotator_b, 这两个函数实现的功能是，接收一个函数作为参数然后返回创建的另一个函数，在这个创建的函数里调用接收的函数(文字比代码绕人)。最后定义的函数 f 采用上面定义的 decotator_a, decotator_b 作为装饰函数。在当我们以1为参数调用装饰后的函数 f 后， decotator_a, decotator_b 的顺序是什么呢（这里为了表示函数执行的先后顺序，采用打印输出的方式来查看函数的执行顺序）？\n如果不假思索根据自下而上的原则来判断地话，先执行 decorator_a 再执行 decorator_b , 那么会先输出 Get in decotator_a, Get in inner_a 再输出 Get in decotator_b , Get in inner_b 。然而事实并非如此。\n实际上运行的结果如下:\nGet in decorator_a\nGet in decorator_b\nGet in inner_b\nGet in inner_a\nGet in f\n\n函数和函数调用的区别\n\n为什么是先执行 inner_b 再执行 inner_a 呢？为了彻底看清上面的问题，得先分清两个概念:函数和函数调用。上面的例子中 f 称之为函数， f(1) 称之为函数调用，后者是对前者传入参数进行求值的结果。在Python中函数也是一个对象，所以 f 是指代一个函数对象，它的值是函数本身， f(1) 是对函数的调用，它的值是调用的结果，这里的定义下 f(1) 的值2。同样地，拿上面的 decorator_a 函数来说，它返回的是个函数对象 inner_a ，这个函数对象是它内部定义的。在 inner_a 里调用了函数 func ，将 func 的调用结果作为值返回。\n装饰器函数在被装饰函数定义好后立即执行\n\n其次得理清的一个问题是，当装饰器装饰一个函数时，究竟发生了什么。现在简化我们的例子，假设是下面这样的:\ndef decorator_a(func):\n    print 'Get in decorator_a'\n    def inner_a(*args, **kwargs):\n        print 'Get in inner_a'\n        return func(*args, **kwargs)\n    return inner_a\n\n@decorator_a\ndef f(x):\n    print 'Get in f'\n    return x * 2\n\n正如很多介绍装饰器的文章里所说:\n@decorator_a\ndef f(x):\n    print 'Get in f'\n    return x * 2\n\n# 相当于\ndef f(x):\n    print 'Get in f'\n    return x * 2\n\nf = decorator_a(f)\n\n所以，当解释器执行这段代码时， decorator_a 已经调用了，它以函数 f 作为参数， 返回它内部生成的一个函数，所以此后 f 指代的是 decorater_a 里面返回的 inner_a 。所以当以后调用 f 时，实际上相当于调用 inner_a ,传给 f 的参数会传给 inner_a , 在调用 inner_a 时会把接收到的参数传给 inner_a 里的 func 即 f ,最后返回的是 f 调用的值，所以在最外面看起来就像直接再调用 f 一样。\n疑问的解释\n\n当理清上面两方面概念时，就可以清楚地看清最原始的例子中发生了什么。当解释器执行下面这段代码时，实际上按照从下到上的顺序已经依次调用了 decorator_a 和 decorator_b ，这是会输出对应的 Get in decorator_a  和 Get in decorator_b 。  这时候 f 已经相当于 decorator_b 里的 inner_b 。但因为 f 并没有被调用，所以 inner_b 并没有调用，依次类推 inner_b 内部的 inner_a 也没有调用，所以 Get in inner_a 和 Get in inner_b 也不会被输出。\n@decorator_b\n@decorator_a\ndef f(x):\n    print 'Get in f'\n    return x * 2\n\n然后最后一行当我们对 f 传入参数1进行调用时， inner_b 被调用了，它会先打印 Get in inner_b ，然后在 inner_b 内部调用了 inner_a 所以会再打印 Get in inner_a, 然后再 inner_a 内部调用的原来的 f, 并且将结果作为最终的返回。这时候你该知道为什么输出结果会是那样，以及对装饰器执行顺序实际发生了什么有一定了解了吧。\n当我们在上面的例子最后一行 f 的调用去掉，放到repl里演示，也能很自然地看出顺序问题:\n➜  test git:(master) ✗ python\nPython 2.7.11 (default, Jan 22 2016, 08:29:18)\n[GCC 4.2.1 Compatible Apple LLVM 7.0.2 (clang-700.1.81)] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> import test13\nGet in decorator_a\nGet in decorator_b\n>>> test13.f(1)\nGet in inner_b\nGet in inner_a\nGet in f\n2\n>>> test13.f(2)\nGet in inner_b\nGet in inner_a\nGet in f\n4\n>>>\n\n在实际应用的场景中，当我们采用上面的方式写了两个装饰方法比如先验证有没有登录 @login_required ， 再验证权限够不够时 @permision_allowed 时，我们采用下面的顺序来装饰函数:\n@login_required\n@permision_allowed\ndef f()\n  # Do something\n  return\n\n参考资料\n\n我的大脑和好奇心\n\n                ", "mainLikeNum": ["5 "], "mainBookmarkNum": "9"}