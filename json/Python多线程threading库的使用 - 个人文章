{"title": "Python多线程threading库的使用 - 个人文章 ", "index": "python", "content": "添加线程Thread\n导入模块\n只要导入threading库就可以用多线程了\n>>> import threading\n获取已激活的线程数\n>>> threading.active_count()\n查看线程信息\n>>> threading.enumerate()\n查看正在运行的线程\n>>> threading.current_thread()\n添加线程\n需要在threading.Thread()中加入参数target来代表参数需要进行的任务\n#python3\nimport threading\n\ndef task():\n    print('start')\n\ndef main():\n    th1 = threading.Thread(target=task,args=(i,))  #定义线程，传入参数i\n    th1.start()   # 让线程开始工作\n\nif __name__=='__main__':\n    main()\nThread里的target参数代表了要执行的任务，而args参数是一个数组变量参数，如果target方法需要参数传入，就需要args参数来传递进去。args参数传入时候一定要是一个数组，所以逗号必不可少\n实现线程的另一种方法\n我们可以写一个类来完成线程的运行。一个例子：\nimport threading\nimport time\n\nclass MyThread(threading.Thread):\n    def run(self):\n        for i in range(3):\n            time.sleep(1)\n            print(self.name)  # name属性中保存的是当前线程的名字\n\nif __name__ == '__main__':\n    t = MyThread()\n    t.start\njoin功能\n基本概念\njoin()方法是表示等这个线程运行完毕，程序再往下运行。\n实例\n#python3\nimport threading\n\ndef task():\n    print('start')\n\ndef main():\n    th1 = threading.Thread(target=task)  #定义线程\n    th1.start()\n    th1.join()\n    print('fi')\n\nif __name__=='__main__':\n    main()\n上面的代码就是th1运行结束之后，在去打印'fi'。\n任务队列--queue\n简介\nQueue用于建立和操作队列，常和threading类一起用来建立一个简单的线程队列。\n引入queue\n>>> import queue\n>>> q= queue.Queue(2)  # 允许队列的最大长度\nput方法\n>>> q.qut(a)  # 向队列传入a元素\n>>> q.put(b)  \n>>> q.put(c,block=False) # 默认block参数为True，设置block为false后，如果再次传入值会报错\n>>> q.put(d,timeout=2)  # 设置阻塞时间最多等待2秒，等待结束值还无法进入队列则报错\nget方法\n踢出put进来的元素\n>>> q.get()\n>>> q.get(block=False) # 设置block为False，获取不到值的时候不阻塞，报错\n>>> q.get(timeout=1)  # 设置获取队列时间为1秒，超时则报错\nempty方法\n>>> q.empty()  # 判断队列是否为空，为空则为真\n队列元素长度\n>>> q.qsize()  # 显示处队列中拥有值的个数\ntask_done方法\n一般要配合join方法使用\n>>> q.task_done()  # 告诉队列，值被取完了\njoin方法\n>>> q.join()  # 当队列里还有值是会报错，队列里为空的时候则成功执行\n四种队列\n# python 四种队列\n# queue.Queue              先进先出队列\n# queue.LifoQueue        后进先出队列\n# queue.PriorityQueue   优先级队列\n# queue.deque               双向队列 \n具体使用百度\n线程锁--Lock\n简介\n不同线程对同一个资源进行修改或利用时会出现混乱，所以需要线程锁。具体解题可以看：https://www.liaoxuefeng.com/w...\n初始化锁对象\n>>> lock = threading.Lock()\n锁定\n>>> lock.acquire(blocking)\nblocking参数设定为True,则当前线程会堵塞,直到获取这个锁为止(如妹没有指定.那么默认为True)。如果设定blocking为False,则当前线程不会堵塞。\n释放\n>>> lock.release()\n例子\nfrom threading import Thread,Lock\n\ng_num = 0 \n\ndef test1():\n    global g_num\n    lock.acquire()\n    for i in range(10000000):\n        g_num += 1\n    lock.release()\n    print(f'test1-----{g_num}')\n\ndef test2():\n    global g_num\n    lock.acquire()\n    for i in range(10000000):\n        g_num += 1\n    lock.release()\n    print(f'test2-----{g_num}')\n\n\nlock = Lock()\n\np1 = Thread(target=test1)\np1.start()\n\np2 = Thread(target=test2)\np2.start()\n\nprint(f\"main-----{g_num}\")\n更强大的锁--Condition\n等以后用到的时候再来填坑吧。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}