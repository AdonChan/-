{"title": "5.ORM与SQLAlchemy （1） - 建立第一个模型 - 后端开发——Flask初体验 ", "index": "python,flask", "content": "后端一个重要的点就是与数据库联系，例如网页的注册、登录，内容的更新等都需要与数据库建立关系。以MySQL数据库为例，平时我们会用mysqldb(python 2)或者pymysql(python 3)去操作MySQL数据库，但这种方法也是需要自己编写SQL语句的。现在我们有了ORM模型，简单来说，ORM是把数据库中的表抽象成模型，表的列名对应模型的属性，这样我们可以调用类的属性或方法去获得数据库中的数据。例如假设MySQL数据库中有一张表名为table1，使用SELECT * FROM table1 WHERE id=1获取id为1的数据，如果将表table1映射成ORM模型Table，那么可以直接使用Table.query.filter(id=1)，这样操作简单了很多，也很利于理解。\n\nSQLAlchemy就是一个这样的ORM，我们可以直接安装flask_sqlalchemy来使用。在这之前我们先在MySQL中手动建立一个数据库harp，在建立的时候把charset设置为utf8，避免存入中文时变成乱码，然后在配置文件config.py中填写好数据库的连接信息：\nHOST = \"127.0.0.1\"\nPORT = \"3306\"\nDB = \"harp\"\nUSER = \"root\"\nPASS = \"Your Password\"\nCHARSET = \"utf8\"\nDB_URI = \"mysql+pymysql://{}:{}@{}:{}/{}?charset={}\".format(USER, PASS, HOST, PORT, DB, CHARSET)\nSQLALCHEMY_DATABASE_URI = DB_URI\n\nSQLAlchemy依赖mysqldb或者pymysql去连接数据库和执行SQL语句，因为我们用的是python 3，所以需要在配置信息中指明使用pymysql，如果是python 2可以省略，默认是使用mysqldb。\n\n建立好了数据库，我们开始建表，首先建立一张用户表，我们设想它应该有id（作为主键）、用户名、密码、注册时间这些基本的字段，有了ORM，我们就不用再写SQL去建表了，在项目的主py文件中添加以下代码：\nfrom flask_sqlalchemy import SQLAlchemy\nfrom datetime import datetime\n\nimport config\n\napp = Flask(__name__)\napp.config.from_object(config)\n\ndb = SQLAlchemy(app)\n\n\nclass Users(db.Model):\n    __tablename__ = 'users_info'\n    id = db.Column(db.Integer, primary_key=True, autoincrement=True)\n    username = db.Column(db.String(32), nullable=False)\n    password = db.Column(db.String(100), nullable=False)\n    register_time = db.Column(db.DateTime, nullable=False, default=datetime.now())\n\n\ndb.create_all()\n解读一下这段代码，导入SQLAlchemy和含有数据库连接信息的config，实例化一个SQLAlchemy对象名为db，其传入的参数为Flask实例app。接下来定义了一个User类，这个类就是ORM中的模型，也就是数据库中的表映射的模型，它需要继承自db.Model，__tablename__这个属性就是建表后，数据库生成的表名；然后使用db.Column来实例化id/username/password/register_time这几个列，db.Column的参数描述列的类型、主键等信息，如db.Integer/db.String(32)/db.DateTime分别代表整形、字符串（最大长度）、时间，primary_key=True说明该字段为主键，autoincrement=True代表自增长，nullable决定是否可为空，default代表默认值。最后用db.create_all()来实现创建。我们暂时不用理解为何SQLAlchemy需要传入Flask实例作为参数，为何模型要继承自db.Model，重要的是可以先把想要的表建立起来。\n\n进入数据库，输入desc user_info;，我们发现表已经建立好了，其结构图如下：\n\n但它现在还是空的，我们来试着插入一条语句，将视图函数修改为：\n@app.route('/')\ndef index():\n    user = Users(username='Harp', password='123456')\n    db.session.add(user)\n    db.session.commit()\n    return render_template('home.html')\n代码实例化一个Users的对象user，传入username和password，使用db.session.add(user)将其加入到数据库的session（可以理解为事务）中，然后使用db.session.commit()提交。我们运行程序，然后用浏览器访问，浏览器正常显示了结果，这时再看一眼数据库，发现这条数据已经写入到了数据库：\n\n查询、修改数据也同样很简单：\n@app.route('/')\ndef index():\n    user = Users.query.filter(Users.id == 1).first()    #查找\n    print(user.username)\n    user.username = 'Harp1207'    #修改\n    db.session.commit()    #修改后需提交\n    print(user.username)\n    return render_template('home.html')\n\n思考问题：1.为何要把模型的操作语句放在视图函数中？（搜索上下文这个概念）2.数据查找，我们用的是Model.query，其实还可以用db.session.query，两者有何区别？filter和filter_by又有何区别？\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}