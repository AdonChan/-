{"title": "欧拉函数(Euler' totient function ) - 个人文章 ", "index": "python,机器学习", "content": "欧拉函数(Euler' totient function )\n\nAuthor: Jasper Yang\nSchool: Bupt\n\n前言\ngamma函数的求导会出现所谓的欧拉函数（phi），在一篇论文中我需要对好几个欧拉函数求值，结果不能理解，立即去google，发现了一个开源的python库可以用来计算欧拉函数\nclass eulerlib.numtheory.Divisors(maxnum=1000)\n    Implements methods related to prime factors and divisors.\n\n    Parameters:    maxnum – Upper limit for the list of primes. (default = 1000)\n    divisors(num)\n        Returns a list of ALL divisors of num (including 1 and num).\n        \n        Parameters:    num – An integer for which divisors are needed.\n        Returns:    A list [d1,d2,...dn] of divisors of num\n    \n    phi(num)\n        Returns the number of totatives of num\n\n        Parameters:    num – Integer for which number of totatives are needed.\n        Returns:    Number of totatives of num\nNote A totative of an integer num is any integer i such that, 0 < i < n and GCD(i,num) == 1.Uses Euler’s totient function.\n这个函数到这里并不能看懂用法和意义，下面我通过介绍两个概念来让大家慢慢理解这个过程。\nTotative(不知道怎么翻译)\nfrom wiki\n在数论中，一个给定的n的totative是一个符合大于0并且小于等于n的k,并且这个k和n是互质数（什么是互质数呢）。\n互质数为数学中的一种概念，即两个或多个整数的公因数只有1的非零自然数。公因数只有1的两个非零自然数，叫做互质数。\n\n欧拉方程 $$ \\phi(x) $$ 就是在计算n的totative个数。在n的乘法模下的totatives形成了模n乘法群( Multiplicative group of integers modulo n )。 --->后面这句涉及的群的知识我去维基上了解下后没看懂，放弃了，未来有机会看看中文资料理解一下再添加进来吧。 wiki传送门\nEuler's totient function\n这个就是主角欧拉函数。\nfrom wiki\n在数论中，对正整数n，欧拉函数 $$  \\varphi (n) $$ 是小于或等于n的正整数中与n互质的数的数目。此函数以其首名研究者欧拉命名，它又称为φ函数（由高斯所命名）或是欧拉总计函数[1]（totient function，由西尔维斯特所命名）。例如 $$  \\varphi (8)=4 $$，因为1,3,5,7均和8互质。欧拉函数实际上是模n的同余类所构成的乘法群（即环 $$ {\\mathbb  {Z}}/n{\\mathbb  {Z}} $$ 的所有单位元组成的乘法群）的阶。这个性质与拉格朗日定理一起构成了欧拉定理的证明。\n若n是质数p的k次幂， $$  \\varphi (n)=\\varphi (p^{k})=p^{k}-p^{{k-1}}=(p-1)p^{{k-1}} $$ ，因为除了p的倍数外，其他数都跟n互质。\n若 $$ n=p_{1}^{k_{1}}p_{2}^{k_{2}}\\cdots p_{r}^{k_{r}} $$\n则 $$ \\varphi (n)=\\prod _{{i=1}}^{r}p_{i}^{{k_{i}-1}}(p_{i}-1)=\\prod _{{p\\mid n}}p^{{\\alpha _{p}-1}}(p-1)=n\\prod _{{p|n}}\\left(1-{\\frac  {1}{p}}\\right) $$其中 $$  \\alpha _{p} $$ 是使得 $$  p^{{\\alpha }} $$ 整除n的最大整数 $ alpha $（这里 $$ \\alpha _{p_{i}}=k_{i} $$ )。\n例如 $$ \\varphi (72)=\\varphi (2^{3}\\times 3^{2})=2^{{3-1}}(2-1)\\times 3^{{2-1}}(3-1)=2^{2}\\times 1\\times 3\\times 2=24 $$\n我的理解\n为什么会有两个法则，一个是基本的计算而另一个是连乘，其实就是因为认为所有的数都可以拆解成两个素数的k次幂的形式。\n我需要的知识以上就足够了，如果需要更多的理解，看下面的链接\n\n欧拉函数wiki\nPHI\n\nEulerlib\n这是个开源的python语言的实现库我们主要使用里面的\neulerlib.numtheory.Divisors(maxnum=1000)下的\n\nphi函数\n\n使用过程，\ne = eulerlib.numtheory.Divisors(10000) # 这里的10000是最大值，默认是1000\ne.phi(100) # 求phi(100)\n使用十分简单。\n这个函数的实现源码如下： 源码传送门\n    def phi(self,num):\n        \"\"\"Returns the number of `totatives \n        <http://en.wikipedia.org/wiki/Totative>`_ of *num*\n        \n        :param num: Integer for which number of totatives are needed.\n        :returns: Number of totatives of *num*\n        \n        .. note::\n        \n            A totative of an integer *num* is any integer *i* such that,\n            0 < i < n and *GCD(i,num) == 1*.\n        \n        Uses `Euler's totient function \n        <http://en.wikipedia.org/wiki/Euler%27s_totient_function>`_.\n        \"\"\"\n        if(num < 1):\n            return 0\n        if(num == 1):\n            return 1\n        if(num in self.primes_table):    # 这个素数的table一开始就有了，从别的包导来的，去看定义就是maxnum以内的所有素数\n            return num-1\n        pfs = self.prime_factors_only(num) # 这个步骤就是找出p了\n        prod = num\n        for pfi in pfs:\n            prod = prod*(pfi-1)/pfi\n        return prod\n\n\n\n    \n    def prime_factors_only(self,num):\n        \"\"\"Returns the `prime factors \n        <http://en.wikipedia.org/wiki/Prime_factor>`_ *pf* :sub:`i` of *num*.\n        \n        :param num: An integer for which prime factors are needed\n        :returns: A list [pf1,pf2,...pfi] of prime factors of *num*\n        \"\"\"\n        if num in self.pfactonly_table:\n            return self.pfactonly_table[num]\n        elif ((num < 2) or (num > self.limit)):\n            return []\n        elif num in self.primes_table:\n            self.pfactonly_table[num] = [num]\n            return [num]\n        else:\n            result = []\n            tnum = num\n            for prime in self.primes_table:\n                if(tnum%prime==0):\n                    result.append(prime)\n                    pdiv = prime*prime\n                    while(tnum%pdiv == 0):\n                        pdiv *= prime\n                    pdiv //= prime        # 这个//= 和 /=似乎没有区别\n                    tnum //= pdiv\n                    if(tnum in self.primes_table):\n                        result.append(tnum)\n                        break\n                    elif(tnum == 1):\n                        break\n            self.pfactonly_table[num] = result\n            return result\n源码看起来也十分的简洁易懂，就是为了找出p1和p2然后就可以分别求phi值再相乘了。\npaper done : 2017/4/19\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}