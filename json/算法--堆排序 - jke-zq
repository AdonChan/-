{"title": "算法--堆排序 - jke-zq ", "index": "python,算法,堆排序", "content": "原理：堆分为最大堆和最小堆。采用数组存放，其左右子树分别是I2,I2+1,不断调整父节点比左右子节点最大（小）关系,直至到数组末尾。每次调整完整个数组，则数组index=1的值为最大（小），将其与数组最后一位swap。然后重新调整除最后一位的剩余的数使之成为最大（小）堆，然后再次和倒数第二位交换，依次进行。\n\npython 代码：\n\n# -*- coding: utf-8 -*-\nfrom random import randint\n\n#generate a unsorted list\norigin = []\n\ndef randomList():\n    for i in xrange(0,10,1):\n        origin.append(randint(-10,10))\n    #最大连续子序列的和\n    print origin\n    return origin\n\n#without the recursion\ndef head_adjust_while(origin, i, size):\n    maxIndex = i\n    while maxIndex * 2 < size:\n        left = maxIndex * 2\n        right = maxIndex * 2 + 1\n        oldMaxIndex = maxIndex\n        if origin[left] > origin[maxIndex]:\n            maxIndex = left\n        if right < size and origin[right] > origin[maxIndex]:\n            maxIndex = right\n        if maxIndex != oldMaxIndex:\n            origin[maxIndex] = origin[maxIndex] + origin[oldMaxIndex]\n            origin[oldMaxIndex] = origin[maxIndex] - origin[oldMaxIndex]\n            origin[maxIndex] = origin[maxIndex] - origin[oldMaxIndex]\n        else:\n            break\n\n\ndef head_adjust_recursion(origin, i, size):\n    maxIndex = i\n    leftIndex = 2*i\n    rightIndex = 2*i + 1\n    if leftIndex < size and origin[leftIndex] > origin[maxIndex]:\n        maxIndex = leftIndex\n    if rightIndex < size and origin[rightIndex] > origin[maxIndex]:\n        maxIndex = rightIndex\n    if maxIndex != i:\n        origin[i] = origin[maxIndex] + origin[i]\n        origin[maxIndex] = origin[i] - origin[maxIndex]\n        origin[i] = origin[i] - origin[maxIndex]\n        head_adjust_recursion(origin, maxIndex, size)\n\ndef build_heap(origin):\n    size = len(origin)\n    for i in xrange(size/2,0,-1):\n        # head_adjust_recursion(origin,i,size)\n        head_adjust_while(origin, i, size)\n\ndef heap_sortion():\n    origin = randomList()\n    build_heap(origin)\n    size = len(origin)\n    for i in xrange(1,size-1):\n        origin[1] = origin[1] + origin[size-i]\n        origin[size-i] = origin[1] - origin[size-i]\n        origin[1] = origin[1] - origin[size-i]\n        # head_adjust_recursion(origin, 1, size-i)\n        head_adjust_while(origin, 1, size - i)\n    print origin\n\nif __name__ == \"__main__\":\n    heap_sortion()\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}