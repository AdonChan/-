{"title": "【Python3】Python模块与包的导入 - 知识分享 ", "index": "python,import,python3.x", "content": "【Python3】Python模块与包的导入\n一、模块导入\n1. 定义\nPython 模块(Module)，是一个 Python 文件，以 .py 结尾，包含了 Python 对象定义和Python语句。\n模块让你能够有逻辑地组织你的 Python 代码段。\n把相关的代码分配到一个模块里能让你的代码更好用，更易懂。 \n模块能定义函数，类和变量，模块里也能包含可执行的代码。\n包括：内置模块，自定义模块，第三方模块；\n2. 作用\n最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Python内置的模块和来自第三方的模块。\n使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。但是也要注意，尽量不要与内置函数名字冲突。\n3. import\n模块定义好后，我们可以使用 import 语句来引入模块，语法如下：\nimport module1[, module2[,... moduleN]\n例：\n#spam.py\nprint('from the spam.py')\n\nmoney=1000\n\ndef read1():\n    print('spam->read1->money',money)\n\ndef read2():\n    print('spam->read2 calling read')\n    read1()\n\ndef change():\n    global money\n    money=0\n导入模块\nimport spam #只在第一次导入时才执行spam.py内代码,此处的显式效果是只打印一次'from the spam.py',当然其他的顶级代码也都被执行了,只不过没有显示效果.\n执行结果：\n from the spam.py\n注：模块可以包含可执行的语句和函数的定义，这些语句的目的是初始化模块，它们只在模块名第一次遇到导入import语句时才执行（import语句是可以在程序中的任意位置使用的,且针对同一个模块很import多次,为了防止你重复导入，python的优化手段是：第一次导入后就将模块名加载到内存了，后续的import语句仅是对已经加载大内存中的模块对象增加了一次引用，不会重新执行模块内的语句）\nimport导入模块干的事：1.产生新的名称空间2.以新建的名称空间为全局名称空间，执行文件的代码3.拿到一个模块名spam，指向spam.py产生的名称空间\n测试一:money与spam.money不冲突\n#测试一:money与spam.money不冲突\n#test.py\nimport spam \nmoney=10\nprint(spam.money)\n\n'''\n执行结果：\nfrom the spam.py\n1000\n'''\n测试二：read1与spam.read1不冲突\n#测试二：read1与spam.read1不冲突\n#test.py\nimport spam\ndef read1():\n    print('========')\nspam.read1()\n\n'''\n执行结果:\nfrom the spam.py\nspam->read1->money 1000\n'''\n测试三：执行spam.change()操作的全局变量money仍然是spam中的money\n#测试三：执行spam.change()操作的全局变量money仍然是spam中的\n#test.py\nimport spam\nmoney=1\nspam.change()\nprint(money)\n\n'''\n执行结果：\nfrom the spam.py\n1\n'''\nas，为模块名起别名\n import spam as sm  #sm为spam的别名\n print(sm.money)\n例：\n为已经导入的模块起别名的方式对编写可扩展的代码很有用，假设有两个模块xmlreader.py和csvreader.py，它们都定义了函数read_data(filename):用来从文件中读取一些数据，但采用不同的输入格式。可以编写代码来选择性地挑选读取模块，例如\nif file_format == 'xml':\n     import xmlreader as reader\nelif file_format == 'csv':\n    import csvreader as reader\ndata=reader.read_date(filename)\n在一行导入多个模块\nimport sys,os,re\n4. From…import\nfrom modname import name1[, name2[, ... nameN]]\n要导入模块 fib 的 fibonacci 函数，使用如下语句：\nfrom fib import fibonacci\n这个声明不会把整个 fib 模块导入到当前的命名空间中，它只会将 fib 里的 fibonacci 单个引入到执行这个声明的模块的全局符号表。\nfrom... import..导入模块干的事：\n1.产生新的名称空间2.以新建的名称空间为全局名称空间，执行文件的代码3.直接拿到就是spam.py产生的名称空间中名字\n#测试一：导入的函数read1，执行时仍然回到spam.py中寻找全局变量money\n#test.py\nfrom spam import read1\nmoney=1000\nread1()\n'''\n执行结果:\nfrom the spam.py\nspam->read1->money 1000\n'''\n\n#测试二:导入的函数read2，执行时需要调用read1(),仍然回到spam.py中找read1()\n#test.py\nfrom spam import read2\ndef read1():\n    print('==========')\nread2()\n\n'''\n执行结果:\nfrom the spam.py\nspam->read2 calling read\nspam->read1->money 1000\n'''\n但如果当前有重名read1或者read2，那么会有覆盖效果。\n#测试三:导入的函数read1，被当前位置定义的read1覆盖掉了\n#test.py\nfrom spam import read1\ndef read1():\n    print('==========')\nread1()\n'''\n执行结果:\nfrom the spam.py\n==========\n'''\n需要特别强调的一点是：python中的变量赋值不是一种存储操作，而只是一种绑定关系，如下：\nfrom spam import money,read1\nmoney=100 #将当前位置的名字money绑定到了100\nprint(money) #打印当前的名字\nread1() #读取spam.py中的名字money,仍然为1000\n\n'''\nfrom the spam.py\n100\nspam->read1->money 1000\n'''\nfrom ... import ...优点:方便，不用加前缀缺点：容易跟当前文件的名称空间冲突\nfrom ... import...也支持as和导入多模块\nfrom spam import read1 as read\n\nfrom spam import (read1,\n                  read2,\n                  money)\nfrom spam import *把spam中所有的不是以下划线(_)开头的名字都导入到当前位置，大部分情况下我们的python程序不应该使用这种导入方式，因为*你不知道你导入什么名字，很有可能会覆盖掉你之前已经定义的名字。而且可读性极其的差，在交互式环境中导入时没有问题。\nfrom spam import * #将模块spam中所有的名字都导入到当前名称空间\nprint(money)\nprint(read1)\nprint(read2)\nprint(change)\n\n'''\n执行结果:\nfrom the spam.py\n1000\n<function read1 at 0x1012e8158>\n<function read2 at 0x1012e81e0>\n<function change at 0x1012e8268>\n'''\n__all__来控制*（用来发布新版本）在spam.py中新增一行\n__all__=['money','read1'] #这样在另外一个文件中用from spam import *就这能导入列表中规定的两个名字\nnamespam.py当做脚本执行，__name__='__main__'\nspam.py当做模块导入，__name__=模块名\n作用：用来控制.py文件在不同的应用场景下执行不同的逻辑\n#fib.py\n\ndef fib(n):    # write Fibonacci series up to n\n    a, b = 0, 1\n    while b < n:\n        print(b, end=' ')\n        a, b = b, a+b\n    print()\n\ndef fib2(n):   # return Fibonacci series up to n\n    result = []\n    a, b = 0, 1\n    while b < n:\n        result.append(b)\n        a, b = b, a+b\n    return result\n\nif __name__ == \"__main__\":\n    import sys\n    fib(int(sys.argv[1]))\n执行\n#python fib.py <arguments>\npython fib.py 50 #在命令行 \n5.模块的搜索路径\n模块的查找顺序是：内存中已经加载的模块->内置模块->sys.path路径中包含的模块\npython解释器在启动时会自动加载一些模块，可以使用sys.modules查看，在第一次导入某个模块时（比如spam），会先检查该模块是否已经被加载到内存中（当前执行文件的名称空间对应的内存），如果有则直接引用\n如果没有，解释器则会查找同名的内建模块，如果还没有找到就从sys.path给出的目录列表中依次寻找spam.py文件。\n特别注意的是：自定义的模块名不应该与系统内置模块重名。\n在初始化后，python程序可以修改sys.path,路径放到前面的优先于标准库被加载。\n注意：搜索时按照sys.path中从左到右的顺序查找，位于前的优先被查找，sys.path中还可能包含.zip归档文件和.egg文件，python会把.zip归档文件当成一个目录去处理，\n#首先制作归档文件：zip module.zip foo.py bar.py\n\nimport sys\nsys.path.append('module.zip')\nimport foo,bar\n\n#也可以使用zip中目录结构的具体位置\nsys.path.append('module.zip/lib/python')\n注意：windows下的路径不加r开头，会语法错误\nwindows下的路径不加r开头，会语法错误\nsys.path.insert(0,r'C:\\Users\\Administrator\\PycharmProjects\\a')\n二、包的导入\n1. 定义\n包是一种通过使用‘.模块名’来组织python模块名称空间的方式。\n无论是import形式还是from...import形式，凡是在导入语句中（而不是在使用时）遇到带点的，都要第一时间提高警觉：这是关于包才有的导入语法。.的左边必须是包；\n包是一个分层次的文件目录结构，它定义了一个由模块及子包，和子包下的子包等组成的 Python 的应用环境。简单来说，包就是文件夹，但该文件夹下必须存在 __init__.py 文件, 该文件的内容可以为空。__int__.py用于标识当前文件夹是一个包。\n包是由一系列模块组成的集合。模块是处理某一类问题的函数和类的集合。\n例：\nglance/                   #Top-level package\n\n├── __init__.py      #Initialize the glance package\n\n├── api                  #Subpackage for api\n\n│   ├── __init__.py\n\n│   ├── policy.py\n\n│   └── versions.py\n\n├── cmd                #Subpackage for cmd\n\n│   ├── __init__.py\n\n│   └── manage.py\n\n└── db                  #Subpackage for db\n\n    ├── __init__.py\n\n    └── models.py\n文件内容\n#文件内容\n\n#policy.py\ndef get():\n    print('from policy.py')\n\n#versions.py\ndef create_resource(conf):\n    print('from version.py: ',conf)\n\n#manage.py\ndef main():\n    print('from manage.py')\n\n#models.py\ndef register_models(engine):\n    print('from models.py: ',engine)\n2. import\n在使用一个模块中的函数或类之前，首先要导入该模块。模块的导入使用import语句。\n调用模块的函数或类时，需要以模块名作为前缀。\nimport导入文件时，产生名称空间中的名字来源于文件，import 包，产生的名称空间的名字同样来源于文件，即包下的__init__.py，导入包本质就是在导入该文件\n例：在与包glance同级别的文件中测试\nimport glance.db.models\nglance.db.models.register_models('mysql') \n凡是在导入时带点的，点的左边都必须是一个包。\n3.from ... import ...\n如果不想在程序中使用前缀符，可以使用from…import…语句将模块导入。\n需要注意的是from后import导入的模块，必须是明确的一个不能带点，否则会有语法错误，如：from a import b.c是错误语法\n例：\n在与包glance同级别的文件中测试\nfrom glance.db import models\nmodels.register_models('mysql')\n\nfrom glance.db.models import register_models\nregister_models('mysql')\n执行的文件的当前路径就是sys.path\nimport sys\nprint(sys.path)\n注意：\n1.关于包相关的导入语句也分为import和from ... import ...两种，但是无论哪种，无论在什么位置，在导入时都必须遵循一个原则：凡是在导入时带点的，点的左边都必须是一个包，否则非法。可以带有一连串的点，如item.subitem.subsubitem,但都必须遵循这个原则。\n2.对于导入后，在使用时就没有这种限制了，点的左边可以是包,模块，函数，类(它们都可以用点的方式调用自己的属性)。\n3.对比import item 和from item import name的应用场景：如果我们想直接使用name那必须使用后者。\n4. __init__.py文件\n不管是哪种方式，只要是第一次导入包或者是包的任何其他部分，都会依次执行包下的__init__.py文件(我们可以在每个包的文件内都打印一行内容来验证一下)，这个文件可以为空，但是也可以存放一些初始化包的代码。\n5.from glance.api import *\n从包api中导入所有，实际上该语句只会导入包api下__init__.py文件中定义的名字，我们可以在这个文件中定义__all___:\n#在__init__.py中定义\nx=10\n\ndef func():\n    print('from api.__init.py')\n\n__all__=['x','func','policy']\n此时我们在于glance同级的文件中执行from glance.api import *就导入__all__中的内容（versions仍然不能导入）。\n6.绝对导入和相对导入\n最顶级包glance是写给别人用的，然后在glance包内部也会有彼此之间互相导入的需求，这时候就有绝对导入和相对导入两种方式：\n绝对导入：以glance作为起始\n相对导入：用.或者..的方式最为起始（只能在一个包中使用，不能用于不同目录内）\n例：我们在glance/api/version.py中想要导入glance/cmd/manage.py\n在glance/api/version.py\n\n#绝对导入\nfrom glance.cmd import manage\nmanage.main()\n\n#相对导入\nfrom ..cmd import manage\nmanage.main()\n测试结果：注意一定要在于glance同级的文件中测试\nfrom glance.api import versions \n注意：可以用import导入内置或者第三方模块（已经在sys.path中），但是要绝对避免使用import来导入自定义包的子模块(没有在sys.path中)，应该使用from... import ...的绝对或者相对导入,且包的相对导入只能用from的形式。\n7.单独导入包\n单独导入包名称时不会导入包中所有包含的所有子模块，如\n#在与glance同级的test.py中\nimport glance\nglance.cmd.manage.main()\n\n'''\n执行结果：\nAttributeError: module 'glance' has no attribute 'cmd'\n\n'''\n解决方法：\n#glance/__init__.py\nfrom . import cmd\n \n#glance/cmd/__init__.py\nfrom . import manage\n执行：\n#在于glance同级的test.py中\nimport glance\nglance.cmd.manage.main()\n千万别问：__all__不能解决吗，__all__是用于控制from...import *\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "8"}