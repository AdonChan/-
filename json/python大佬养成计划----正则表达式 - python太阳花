{"title": "python大佬养成计划----正则表达式 - python太阳花 ", "index": "python", "content": "正则\nre = regular experssionre 模块使 Python 语言拥有全部的正则表达式功能。 compile 函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象。该对象拥有一系列方法用于正则表达式匹配和替换。 \n作用: 对于字符串进行处理， 会检查这个字符串内容是否与你写的正则表达式匹配\n如果匹配， 拿出匹配的内容;\n如果不匹配， 忽略不匹配内容;\n编写正则的规则\npattern 匹配的正则表达式\nstring 要匹配的字符串\n\n三种查找方法\n1). findall\n\nimport re\n\nstr = 'hello sheen,hello cute.'\n\npattern_1 = r'hello'\npattern_2 = r'sheen'\nprint(re.findall(pattern_1,str))    #['hello', 'hello']\nprint(re.findall(pattern_2,str))    #['sheen']\n\n2).match\nmatch尝试从字符串的起始位置开始匹配,\n\n如果起始位置没有匹配成功， 返回一个None;\n如果起始位置匹配成功， 返回一个对象;\n\nimport re\n\nstr = 'hello sheen,hello cute.'\n\npattern_1 = r'hello'\npattern_2 = r'sheen'\nprint(re.match(pattern_1,str))           #<_sre.SRE_Match object; span=(0, 5), match='hello'>\nprint(re.match(pattern_1,str).group())   #返回match匹配的字符串内容,hello\nprint(re.match(pattern_2,str))           #None\n3).search\nsearch会扫描整个字符串， 只返回第一个匹配成功的内容;\n如果能找到， 返回一个对象， 通过group方法获取对应的字符串;\nimport re\n\nstr = 'hello sheen,hello cute.'\n\npattern_1 = r'hello'\npattern_2 = r'sheen'\nprint(re.search(pattern_1,str))             #<_sre.SRE_Match object; span=(0, 5), match='hello'>\nprint(re.search(pattern_1,str).group())     #hello\nprint(re.search(pattern_2,str))             #<_sre.SRE_Match object; span=(6, 11), match='sheen'>\nprint(re.search(pattern_2,str).group())     #sheen\n特殊字符类\n.: 匹配除了\\n之外的任意字符； [.\\n]\n\\d:  digit--(数字)， 匹配一个数字字符， 等价于[0-9]\n\\D: 匹配一个非数字字符， 等价于[^0-9]\n\\s:  space(广义的空格: 空格, \\t, \\n, \\r), 匹配单个任何的空白字符;\n\\S:  匹配除了单个任何的空白字符;\n\\w:  字母数字或者下划线, [a-zA-Z0-9_]\n\\W: 除了字母数字或者下划线, [^a-zA-Z0-9_]\nimport re\n\n# .\nprint(re.findall(r'.','sheen\\nstar\\n'))     #['s', 'h', 'e', 'e', 'n', 's', 't', 'a', 'r']\n\n#\\d#\\D\nprint(re.findall(r'\\d','当前声望30'))       #['3', '0']\nprint(re.findall(r'\\D','当前声望30'))       #['当', '前', '声', '望']\n\n#\\s#\\S\nprint(re.findall(r'\\s', '\\n当前\\r声望\\t为30'))     #['\\n', '\\r', '\\t']\nprint(re.findall(r'\\S', '\\n当前\\r声望\\t为30'))     #['当', '前', '声', '望', '为', '3', '0']\n\n#\\w#\\W\nprint(re.findall(r'\\w','lucky超可爱!!'))           #['l', 'u', 'c', 'k', 'y', '超', '可', '爱']\nprint(re.findall(r'\\W','lucky超可爱!!'))           #['!', '!']\n\n指定字符出现次数\n匹配字符出现次数:\n*: 代表前一个字符出现0次或者无限次；    d*,  .*\n+: 代表前一个字符出现一次或者无限次;     d+\n?: 代表前一个字符出现1次或者0次；   假设某些字符可省略， 也可以不省略的时候使用\n\n第二种方式:\n{m}: 前一个字符出现m次;\n{m,}: 前一个字符至少出现m次;  * == {0,}; + ==={1,}\n{m,n}: 前一个字符出现m次到n次; ? === {0,1}\n\n\nimport re\n\n#* 代表前一个字符出现0次或者无限次\nprint(re.findall(r's*','sheenstar'))        #['s', '', '', '', '', 's', '', '', '', '']\nprint(re.findall(r's*','hello'))            #['', '', '', '', '', '']\n\n#+ 代表前一个字符出现一次或者无限次\nprint(re.findall(r's+','sheenstar'))        #['s', 's']\nprint(re.findall(r's+','hello'))            #[]\n\n# ？ 代表前一个字符出现1次或者0次\nprint(re.findall(r'188-?', '188 6543'))     #['188']\nprint(re.findall(r'188-?', '188-6543'))     #['188-']\nprint(re.findall(r'188-?', '148-6543'))     #[]\n\n\n# 匹配电话号码\npattern = r'\\d{3}[\\s-]?\\d{4}[\\s-]?\\d{4}'\nprint(re.findall(pattern,'188 0123 4567'))      #['188 0123 4567']\nprint(re.findall(pattern,'188-0123-4567'))      #['188-0123-4567']\nprint(re.findall(pattern,'18801234567'))        #['188-0123-4567']\n练习--匹配IP\n可以从网上搜索正则表达式生成器，使用别人写好的规则，自己测试。\nimport re\n\n# | 表示或者\npattern = r'(25[0-5]|2[0-4]\\d|[0-1]\\d{2}|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|[0-1]\\d{2}|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|[0-1]\\d{2}|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|[0-1]\\d{2}|[1-9]?\\d)$'\n\nprint(re.findall(pattern,'172.25.254.34'))  #[('172', '25', '254', '34')]\n\nmatchObj_1 = re.match(pattern,'172.25.254.34')\nif matchObj_1:\n    print('匹配项：',matchObj_1.group())                     #172.25.254.34\nelse:\n    print('未找到匹配项')\n\nmatchObj_2 = re.match(pattern,'172.25.254.343')\nif matchObj_2:\n    print('匹配项：',matchObj_2.group())                     \nelse:\n    print('未找到匹配项')\n\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}