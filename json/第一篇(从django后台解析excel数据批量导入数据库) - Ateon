{"title": "第一篇(从django后台解析excel数据批量导入数据库) - Ateon ", "index": "django,python", "content": "第一篇(从django后台解析excel数据批量导入数据库)\n文章会在github中持续更新\n\n作者: knthony\n\ngithub\n联系我\n\n\n1.django 如何从后台上传excel中批量解析数据\n要从django后台导入的excel中批量解析数据，举一个例子，我们向后抬批量导入svn历史数据数据格式\n假设excel表中有4列，每列分别是版本号，属性，属性值，仓库地址\n2.第一步，新建一个app，然后在app中新建model\n@python_2_unicode_compatible\nclass KNSVNHistory(models.Model):\n    revision = models.IntegerField(verbose_name=u\"修订版本\", blank=True, null=True)\n    prop = models.CharField(verbose_name=u'SVN属性', choices=constants.YD_SVN_PROP_CHOICE, max_length=60,\n                            default=constants.YD_SVN_PROP_DATE)\n    value = models.TextField(verbose_name=u\"SVN属性值\", blank=False, null=False, default=u\"\")\n    repo = models.CharField(max_length=100, verbose_name=u\"SVN仓库\", blank=False, null=False)\n    editor = models.ForeignKey(User, verbose_name=u\"编辑者\", blank=True, null=True)\n    ctime = models.DateTimeField(verbose_name=u\"创建时间\", auto_now_add=True, )\n    mtime = models.DateTimeField(verbose_name=u\"修改时间\", auto_now=True, )\n\n    class Meta:\n        ordering = ['ctime']\n\n    def __str__(self):\n        return self.value\n如上代码，我自己创建了用来保存数据的model，方便我们从后台导入数据接下来我们创建后台上传文件的接口\n@python_2_unicode_compatible\nclass ImportFile(models.Model):\n\n    file = models.FileField(upload_to='File')\n    name = models.CharField(max_length=50, verbose_name=u'文件名')\n\n    class Meta:\n        ordering = ['name']\n\n    def __str__(self):\n        return self.name\n下面就是我们解析excle的功能部分，在app下新建一个utils.py文件\nfrom openpyxl import Workbook,load_workbook\nfrom openpyxl.utils import get_column_letter\nfrom .models import KNSVNHistory\nfrom openpyxl.compat import range\n\ndef import_user(self, request, obj, change):\n\n    wb = load_workbook(filename=obj.YDUserFile.path)\n    ws = wb.get_sheet_names()\n    ws = wb.get_sheet_by_name(ws[0])\n    headers = ['version', 'attr', 'value', 'addr']\n    lists = []\n    users = request.user\n    for row in range(2, 5):\n        r = {}\n        for col in range(1, len(headers) + 1):\n            key = headers[col - 1]\n            r[key] = ws.cell(row=row, column=col).value\n        lists.append(r)\n    sqllist = []\n    for cell in lists:\n        # for header in headers:\n        revision = cell['version']\n        prop = cell['attr']\n        value = cell['value']\n        repo = cell['addr']\n        sql = KNSVNHistory(revision=revision, prop=prop, value=value, repo=repo, editor=users)\n        sqllist.append(sql)\n    KNSVNHistory.objects.bulk_create(sqllist)\n打开admin.py因为我们要在后台保存，所以我们需要重写ModelAdmin的save_mode\nfrom .utils import import_user\nclass KNImportFileAdmin(admin.ModelAdmin):\n\n    list_display = ('file','name',)\n    list_filter = ['name',]\n\n    def save_model(self, request, obj, form, change):\n\n        re = super(YDImportFileAdmin,self).save_model(request, obj, form, change)\n        import_user(self, request, obj, change)\n        return re\n在上面的代码中使用了第三方库openpyxl来解析excel关键点在于获取文件对象的时候，我们是通过传过来的obj对象来获取fileobj，其实通俗来讲就是在我们点击上传的时候，重写的save_mode方法拦截了整个对象，我们在这里拿出我们要解析的excel文件对象进行解析，后面的解析过程也比较简单，我们将每行数据解析之后通过字典来保存，然后再用key访问取到进行数据库操作，在数据库操作的时候我们使用KNSVNHistory.objects.bulk_create 来提高效率。\n总结,整个过程的难点在于获取文件对象，从数据中取值然后在按key取出，这样我们就可以从后台上传excel文件，然后进行批量导入数据库，其他数据格式只需要改utils和model中的数据字段就可以\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "6"}