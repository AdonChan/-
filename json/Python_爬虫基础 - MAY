{"title": "Python_爬虫基础 - MAY ", "index": "python,python爬虫", "content": "爬虫概念\n数据获取的方式：\n\n企业生产的用户数据：大型互联网公司有海量用户，所以他们积累数据有天然优势。有数据意识的中小型企业，也开始积累的数据。\n数据管理咨询公司\n政府/机构提供的公开数据\n第三方数据平台购买数据\n爬虫爬取数据\n\n什么是爬虫\n抓去网页数据的程序\n网页三大特征：\n\n每个网页都有自己的URL\n\n网页都使用HTML标记语言来描述页面信息\n网页都使用HTTP/HTTPS协议来传输HTML数据\n\n爬虫的设计思路\n\n确定需要爬取的网页URL地址\n通过HTTP/HTTPS协议来获取对应的HTML页面\n提取HTML页面中的数据如果是需要的数据，就保存起来如果页面是其它URL，那就继续爬取\n\n如何抓取HTML页面HTTP协议请求的处理，urllib, urllib2, requests，处理后的请求可以模拟浏览器发送请求，获取服务器响应的文件\n解析服务器响应的内容re, xpath(常用), BeautifulSoup4(bs4), jsonpath, pyquery等使用某种描述性一样来给需要提取的数据定义一个匹配规则，符合这个规则的数据就会被匹配。\n如何采集动态HTML，验证码的处理Selenium(自动化测试工具) + PhantomJS(无界面浏览器)验证码处理通过Tesseract: 机器图像识别系统(图片中的文本识别)\nScrapy框架(Scrapy, Pyspider)\n\n高性能高定制型（异步网络框架twisted）,所以数据下载速度快\n提供了数据存储，数据下载，提取规则等组件\n\n分布式策略\n\n是否有那么多的机器去做分布式?\n获取的数据是否值得搭建分布式系统?\n\n使用scrapy-redis来搭建,在Scrapy的基础上添加了一套 Redis数据库为核心的一套组件，让Scrapy框架支持分布式的功能。主要在Redis中做请求指纹去重，请求分配，数据临时存储\n爬虫 - 反爬虫 - 反反爬虫\n反爬虫： User-Agent, IP, 代理, 验证码, 动态数据加载, 加密数据数据的价值，是否值得去费劲去做反爬虫，一般做到代理阶段或封IP。机器成本 + 人力成本 > 数据价值\n爬虫和反爬虫之间的斗争，最后一定是爬虫获胜。只要是真实用户可以浏览的网页数据，爬虫就一定能爬下来。（爬虫模拟浏览器获取数据）\n爬虫集合awesome-spider\n通用爬虫\n搜索引擎使用的爬虫系统\n目标：尽可能把互联网上所有的网页下载下来，放到本地服务器里形成备份，再对这些网页做相关处理（提取关键字，去掉广告），最后提供一个用户检索接口\n抓取流程：\n\n首先选取一部分已有的URL，把这些URL放到待爬取队列。\n从队列里去取出这些URL，然后解析DNS得到主机IP,然后去这个IP对应的服务器下载HTML页面，保存到搜索引擎的本地服务器里，之后把这个已经爬过的URL放入到已经爬取队列中\n分析网页内容，找出网页中的其它URL内容，继续爬取。\n\n搜索引擎如何获取一个新网站的URL:\n\n主动向搜索引擎提交网址： 百度搜索资源平台\n\n在其它网站设置外链\n搜索引擎会和DNS服务商进行合作,可以快速收录新的网站\n\n通用爬虫并不是万物皆可爬，它也需要遵守规则：Robots协议，协议会指明通用爬虫可以爬取网页的权限。Robots.txt并不是所有爬虫都遵守，一般只有大型搜索引擎爬虫才会遵守。\n通用爬虫工作流程：爬取网页 -> 存储数据 -> 内容处理 -> 提供检索/排名服务\n搜索引擎排名：\n\n\nPageRank值：根据网站的流量（pv），流量越高，排名约靠前\n竞价排名\n\n通用爬虫的缺点：\n\n只能提供和文本相关的内容（HTML，Word，PDF）等，但是不能提供多媒体（音乐，视频，图片）和二进制文件。\n提供的结果千篇一律，不能针对不同领域的人提供不同的搜索结果。\n不能理解人类语义上的检索。\n\nDNS: 把域名解析成IP\n聚焦爬虫\n爬虫程序员写的针对某种内容爬虫。（针对通用爬虫的缺点）\n面向主题爬虫，面向需求爬虫，会针对某种特定的内容去爬取信息，而且会保证内容信息和需求尽可能相关。\nHTTP&HTTPS\nHTTP协议（HyperText Transfer Protocol，超文本传输协议）：是一种发布和接收HTML页面的方法。\nHTTPS（Hypertext Transfer Protocol over Secure Socket Layer）简单讲是HTTP的安全版，在HTTP下加入SSL层。 \nSSL（Secure Sockets Layer 安全套接层）主要用于Web的安全传输协议，在传输层对网络连接进行加密，保障在Internet上数据传输的安全。\n\nHTTP的端口号为80\nHTTPS的端口号为443\n\nHTTP工作原理\n网络爬虫抓取过程可以理解为模拟浏览器操作的过程。\n浏览器的主要功能是向服务器发出请求，在浏览器窗口中展示您选择的网络资源，HTTP是一套计算机通过网络进行通信的规则。\n常用的请求报头:\n\n\nHost (主机和端口号): 对应网址URL中的Web名称和端口号，用于指定被请求资源的Internet主机和端口号，通常属于URL的一部分。\n\nConnection (链接类型): 表示客户端与服务连接类型\n\nClient 发起一个包含 Connection:keep-alive 的请求，HTTP/1.1使用 keep-alive 为默认值。\nServer收到请求后：如果 Server 支持 keep-alive，回复一个包含 Connection:keep-alive 的响应，不关闭连接； 如果 Server 不支持keep-alive，回复一个包含 Connection:close 的响应，关闭连接。\n如果client收到包含 Connection:keep-alive 的响应，向同一个连接发送下一个请求，直到一方主动关闭连接。\n\nkeep-alive在很多情况下能够重用连接，减少资源消耗，缩短响应时间，比如当浏览器需要多个文件时(比如一个HTML文件和相关的图形文件)，不需要每次都去请求建立连接。\n\n\n\nUpgrade-Insecure-Requests (升级为HTTPS请求): 升级不安全的请求，意思是会在加载 http 资源时自动替换成 https 请求，让浏览器不再显示https页面中的http请求警报。(HTTPS 是以安全为目标的 HTTP 通道，所以在 HTTPS 承载的页面上不允许出现 HTTP 请求，一旦出现就是提示或报错。)\n\nUser-Agent (浏览器名称): 是客户浏览器的名称\n\nAccept (传输文件类型): 指浏览器或其他客户端可以接受的MIME（Multipurpose Internet Mail Extensions（多用途互联网邮件扩展））文件类型，服务器可以根据它判断并返回适当的文件格式。\n\n\nAccept: */*：表示什么都可以接收。\n\nAccept：image/gif：表明客户端希望接受GIF图像格式的资源；\n\nAccept：text/html：表明客户端希望接受html文本。\n\nAccept: text/html, application/xhtml+xml;q=0.9, image/*;q=0.8：表示浏览器支持的 MIME 类型分别是 html文本、xhtml和xml文档、所有的图像格式资源。html中文件类型的accept属性有哪些\n\n\n\n\nReferer (页面跳转处): 表明产生请求的网页来自于哪个URL，用户是从该 Referer页面访问到当前请求的页面。这个属性可以用来跟踪Web请求来自哪个页面，是从什么网站来的等。有时候遇到下载某网站图片，需要对应的referer，否则无法下载图片，那是因为人家做了防盗链，原理就是根据referer去判断是否是本网站的地址，如果不是，则拒绝，如果是，就可以下载；\n\nAccept-Encoding（文件编解码格式）: 指出浏览器可以接受的编码方式。编码方式不同于文件格式，它是为了压缩文件并加速文件传递速度。浏览器在接收到Web响应之后先解码，然后再检查文件格式，许多情形下这可以减少大量的下载时间。例如：Accept-Encoding:gzip;q=1.0, identity; q=0.5, *;q=0\n\n\nAccept-Language（语言种类）: 指出浏览器可以接受的语言种类，如en或en-us指英语，zh或者zh-cn指中文，当服务器能够提供一种以上的语言版本时要用到。\n\nAccept-Charset（字符编码）： 指出浏览器可以接受的字符编码。例如：Accept-Charset:iso-8859-1,gb2312,utf-8\n\n\n Cookie （Cookie）： 浏览器用这个属性向服务器发送Cookie。Cookie是在浏览器中寄存的小型数据体，它可以记载和服务器相关的用户信息，也可以用来实现会话功能\n\nContent-Type (POST数据类型)： POST请求里用来表示的内容类型。例如：Content-Type = Text/XML; charset=gb2312：\n\n\n常用的响应报头（了解）：\n\n\n Cache-Control：must-revalidate, no-cache, private： 告诉客户端，服务端不希望客户端缓存资源，在下次请求资源时，必须要从新请求服务器，不能从缓存副本中获取资源。\n\nConnection：keep-alive: 客户端服务器的tcp连接也是一个长连接，客户端可以继续使用这个tcp连接发送http请求\n\nContent-Encoding:gzip： 告诉客户端，服务端发送的资源是采用gzip编码的，客户端看到这个信息后，应该采用gzip对资源进行解码。\n\nContent-Type：text/html;charset=UTF-8： 告诉客户端，资源文件的类型，还有字符编码，客户端通过utf-8对资源进行解码，然后对资源进行html解析。\n\nDate：Sun, 21 Sep 2016 06:18:21 GMT： 服务端发送资源时的服务器时间，GMT是格林尼治所在地的标准时间。http协议中发送的时间都是GMT的，这主要是解决在互联网上，不同时区在相互请求资源的时候，时间混乱问题。\n\n Expires:Sun, 1 Jan 2000 01:00:00 GMT: 这个响应头也是跟缓存有关的，告诉客户端在这个时间前，可以直接访问缓存副本，很显然这个值会存在问题，因为客户端和服务器的时间不一定会都是相同的，如果时间不同就会导致问题。所以这个响应头是没有Cache-Control：max-age=*这个响应头准确的，因为max-age=date中的date是个相对时间.\n\nPragma:no-cache: 这个含义与Cache-Control等同。\n\nServer：Tengine/1.4.6： 这个是服务器和相对应的版本，只是告诉客户端服务器的信息。\n\nTransfer-Encoding：chunked： 这个响应头告诉客户端，服务器发送的资源的方式是分块发送的。\n\n响应状态码：\n\n\n100~199：表示服务器成功接收部分请求，要求客户端继续提交其余请求才能完成整个处理过程。\n\n200~299：表示服务器成功接收请求并已完成整个处理过程。常用200（OK 请求成功）。\n\n300~399：为完成请求，客户需进一步细化请求。例如：请求的资源已经移动一个新地址、常用302（所请求的页面已经临时转移至新的url）、307和304（使用缓存资源）。\n\n400~499：客户端的请求有错误，常用404（服务器无法找到被请求的页面）、403（服务器拒绝访问，权限不够）。\n\n500~599：服务器端出现错误，常用500（请求未完成。服务器遇到不可预知的情况）。\n\nCookie 和 Session:因为服务器和客户端的交互仅限于请求/响应过程，结束之后便断开，在下一次请求时，服务器会认为新的客户端。为了维护他们之间的链接，让服务器知道这是前一个用户发送的请求，必须在一个地方保存客户端的信息\nCookie：通过在客户端 记录的信息确定用户的身份。Session：通过在服务器端 记录的信息确定用户的身份。\nurllib\nurllib.request\nlinux中的py源码文件位置：python自带：vim /usr/lib/python2.7/urllib2.pypip安装：vim /usr/local/lib/python3.6/site-packages/django/http/cookie.py\nurllib2.urlopen\n# -*- coding:utf-8 -*-\n\nimport urllib.request as urllib2\n\n# 返回类文件对象\nresponse = urllib2.urlopen('http://www.baidu.com/')\n# urlopen不支持构造\n\n# 服务器返回类文件对象支持python文件对象的操作方法\n# read()方法就是读取文件里面的全部内容，返回字符串\nhtml = response.read()\n\nprint(html)\nRequest\n# -*- coding:utf-8 -*-\n\nimport urllib.request as urllib2\n\n\nua_headres = {\n    'User_Agent': 'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Mobile Safari/537.36'\n}\n\n# urllib2.Request(url, data, headres)\n# 通过urllib2.Request()方法构造一个请求对象\nrequset = urllib2.Request('http://www.baidu.com', headers=ua_headres)\n\n\n# 返回类文件对象, urlopen不支持构造\nresponse = urllib2.urlopen(requset)\n\n# 服务器返回类文件对象支持python文件对象的操作方法\n# read()方法就是读取文件里面的全部内容，返回字符串\nhtml = response.read()\n\nprint(html)\nUser_Agent,是发送请求必须带的请求头\nResponse响应\nresponse是服务器响应的类文件，除了支持文件操作的方法外，常用的方法也有：respnse.getcode(), response.geturl(), response.info()\n#condig=utf-8\n\nimport urllib.request as urllib2\n\n# print(dir(urllib2))\n\nua_headres = {\n    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.104 Safari/537.36 Core/1.53.4620.400 QQBrowser/9.7.13014.400'        \n}\n\nrequest = urllib2.Request('http://www.baidu.com/', headers=ua_headres)\n\nresponse = urllib2.urlopen(request)\n\nhtml = response.read()\n\n# 返回HTTP的响应码，成功返回200\n# 4 服务器页面出错， 5 服务器问题\nprint(response.getcode())\n\n# 返回实际数据的url，防止重定向问题\nprint(response.geturl())\n\n# 返回服务器响应报头信息\nprint(response.info())\n\n# print(dir(response))\nUser-Agent历史\n如果用一个合法的身份去请求别人网站，就是欢迎的，所以就应该给这个代码加上一个身份，就是所谓的User-Agent头。\nurllib2默认的User-Agent头为：Python-urllib/x.y（x和y是Python主版本和次版本号,例如 Python-urllib/2.7\nMosaic世界上第一个浏览器：美国国家计算机应用中心Netscape，网景：Netscape（支持框架）Microsoft微软：Internet Explorer\n第一次浏览器大战：网景公司失败\nMozilla 基金组织：Firefox 火狐 内核（Gecko内核）(浏览器支持内核开始，User-Agent开始逐渐使用)\nUser-Agent 决定用户的浏览器，为了获取更好的HTML页面效果\nIE就给自己披着了个Mozilla的外皮\n内核：\n\nMozilla: Firefox (Gecko)\nIE： Trident\nOpera: Presto\nLinux: KHTML (like Gecko)\nApple: Webkit (like KTML)\nGoogle: Chrome (like webkit)\n\nadd_header() & get_header()\nadd_header(): 添加/修改 一个HTTP报头 get_header(): 获取一个已有的HTTP报头值，只能第一个字母大写，其它的必须小写\n# -*- coding:utf-8 -*-\n\nimport urllib.request as urllib2\nimport random\n\nurl = 'http://www.baidu.com/'\n\n# 可以是User-Agent列表，也可以是代理列表。 作用：反反爬虫\nua_list = [\n    'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:34.0) Gecko/20100101 Firefox/34.0',\n    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.57.2 (KHTML, like Gecko) Version/5.1.7 Safari/534.57.2',\n    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36',\n    'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; en) Opera 9.50'\n]\n\n# 在User-Agent列表里随机选择一个User-Agent\nuser_agent = random.choice(ua_list)\n\n# 构造一个请求\nrequest = urllib2.Request(url)\n\n# add_header()方法，添加/修改 一个HTTP报头\nrequest.add_header('User-Agent', user_agent)\n\n# get_header() 获取一个已有的HTTP报头值，只能第一个字母大写，其它的必须小写\nrequest.get_header('User-agent')\n\nresponse = urllib2.urlopen(request)\n\nhtml = response.read()\nprint(html)\nurllib.urlencode\n编码：urlencode位置：urllib.parse.urlencode(values)。 其中values所需要编码的数据，参数只能为字典解码：unquote: urllib.parse.unquote(values)\n#conding=utf-8\n\nimport urllib.parse\n\ntest = {\n    'test': '我的'\n}\n\n# 通过urllib.urlencode()方法，将字典键值对按URL编码转换，从而能被web服务器接受。\nenCodeTest = urllib.parse.urlencode(test)\n\n# 冒号解析为等号\nprint(enCodeTest) # test=%E6%88%91%E7%9A%84\n\n# 通过urllib.unquote()方法，把 URL编码字符串，转换回原先字符串。\nprint(urllib.parse.unquote(enCodeTest)) # test=我的\n爬取百度贴吧起始页到结束页的案例\n#conding=utf-8\n\nimport urllib.request\nimport urllib.parse\n\ndef loadPage(url, filename):\n    '''\n        作用: 根据url发送请求，获取服务器响应文件\n        url: 需要爬取的url地址\n        filename: 处理的文件名\n    '''\n    print('正在下载' + filename)\n    headers = {\n        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36'\n    }\n    request = urllib.request.Request(url, headers=headers)\n    return urllib.request.urlopen(request).read()\n    \n\ndef writePage(html, filenmae):\n    '''\n        作用：将html内容写入到本地\n        html: 服务器响应文件内容\n    '''\n    print('正在保存' + filenmae)\n    # 文件写入\n    with open(filenmae, 'w') as f: #  with 之后，不需要做文件关闭还有其它上下文处理的操作 等同于 open(), write(), close()\n        f.write(html.decode('utf-8'))\n    print('-' * 30)    \n    print('thanks')\n\n\ndef tiebaSpider(url, beginPage, endPage):\n    '''\n        作用: 贴吧爬虫调度器，负责组合处理\n        url: 贴吧url的前部分\n        beginPage: 起始页\n        endPage: 结束页\n    '''\n    for page in range(beginPage, endPage+1):\n        pn = (page - 1) * 50\n        filename = '第' + str(page) + '页.html'\n        fullurl = url + '&pn=' + str(pn)\n        # print(fullurl)\n        html = loadPage(fullurl, filename)\n        writePage(html, filename)\n        # print(html)\n\nif __name__ == '__main__':\n    kw = input('请输入需要爬取的贴吧名：')\n    beginPage = int(input('请输入起始页：'))\n    endPage = int(input('请输入结束页：'))\n    \n    # https://tieba.baidu.com/f?ie=utf-8&kw=javascirpt&fr=search\n    url = 'https://tieba.baidu.com/f?'\n    key = urllib.parse.urlencode({'kw': kw})\n    fullurl = url + key\n\n    tiebaSpider(fullurl, beginPage, endPage)\n\nPOST请求的模拟\nGet和Post请求的区别：\n\n\nGet请求：查询参数在QueryString里保存\n\nPost请求：查询参数在FormData中保存\n\nPost请求：\n# -*- coding:utf-8 -*-\n\nimport urllib.request\nimport urllib.parse\n\nurl = 'http://fanyi.youdao.com/translate_o?smartresult=dict&smartresult=rule'\n\nkey = input('请输入查询翻译的文字：')\n\n# 发送到服务器的表单数据，如果是中文需要转码\nfromdata = {\n    'i': key,\n    'from': 'AUTO',\n    'to': 'AUTO',\n    'smartresult': 'dict',\n    'client': 'fanyideskweb',\n    'salt': '1528127663128',\n    'sign': 'c060b56b628f82259225f751c12da59a',\n    'doctype': 'json',\n    'version': '2.1',\n    'keyfrom': 'fanyi.web',\n    'action': 'FY_BY_REALTIME',\n    'typoResult': 'false'\n}\n\ndata = urllib.parse.urlencode(fromdata).encode('utf-8')\n\nheaders = {\n    'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36'\n}\n\nrequest = urllib.request.Request(url, data=data, headers=headers)\n\nhtml = urllib.request.urlopen(request).read().decode()\n\nprint(html)\n获取AJAX加载的内容\nAJAX一般返回的是JSON,直接对AJAX地址进行post或get,就返回JSON数据了。\n“作为一名爬虫工程师，最需要关注的是数据的来源”\n# -*- coding:utf-8 -*-\n\nimport urllib.request\nimport urllib.parse\n\n\nurl = 'https://movie.douban.com/j/search_subjects?'\nheaders = {\n    'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36'\n}\nformdata = {\n    'type': 'movie',\n    'tag': '热门',\n    'sort': 'recommend',\n    'page_limit': 20,\n    'page_start': 40\n}\n\ndata = urllib.parse.urlencode(formdata).encode('utf-8')\nrequest = urllib.request.Request(url, data=data, headers=headers)\nhtml = urllib.request.urlopen(request).read().decode()\n\nprint(html)\n处理HTTPS请求 SSL证书验证\n网站的SSL证书是经过CA认证的，则能够正常访问单独处理SSL证书，让程序忽略SSL证书验证错误\n# -*- coding:utf-8 -*-\n\nimport urllib.request\nimport ssl\n\n# 表示忽略未经核实的SSL证书认证\ncontext = ssl._create_unverified_context()\n\nurl = \"https://www.12306.cn/mormhweb/\"\n\nheaders = {\n    \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36\"\n}\n\nrequest = urllib.request.Request(url, headers = headers)\n\n# 在urlopen()方法里 指明添加 context 参数\nresponse = urllib.request.urlopen(request, context = context)\n\nprint(response.read())\nCA: 数字证书认证中心的简称，是指发放、管理、废除数字证书的受信任的第三方机构(类似与身份证)CA的作用: 检查证书持有者身份的合法性，并签发证书，以防证书被伪造或篡改，以及对证书和密钥进行管理\n一般正常的网站都会主动出示自己的数字证书，来确保客户端和网站服务器之间的通信数据是加密安全的.\nHandler和Opener的使用\n自定义Handler\n# -*- coding:utf-8 -*-\n\nimport urllib.request\n\n# 构建一个HTTPHandler处理器对象，支持处理HTTP的请求\n# http_hander = urllib.request.HTTPHandler()\nhttp_hander = urllib.request.HTTPHandler(debuglevel=1)\n\n# 调用build_opener()方法构建一个自定义的opener对象，参数是构建的处理器对象\nopener = urllib.request.build_opener(http_hander)\n\nreq = urllib.request.Request('http://www.baidu.com')\n\nres = opener.open(req)\n\nprint(res.read().decode())\n\n开放代理和私密代理\n高匿：无法拿到真正的物理ip，只能获取代理服务器ip透明：能看到代理服务器ip，也可以看到物理ip地址快代理西刺免费代理\n使用代理IP，这是爬虫/反爬虫的第二大招，通常也是最好用的。很多网站会检测某一段时间某个IP的访问次数(通过流量统计，系统日志等)，如果访问次数多的不像正常人，它会禁止这个IP的访问。可以设置一些代理服务器，每隔一段时间换一个代理，就算IP被禁止，依然可以换个IP继续爬取。\n# -*- coding:utf-8 -*-\n\nimport urllib.request\n\n\n# 代理开关，是否启用代理\nproxyswitch = True\n\n# 公开代理\nproxy_ip = {\n  'http': '123.57.217.208:3128'\n}\n\n# 私密代理 授权的账号密码\n# proxy_ip_auth = {\n#   'http': 'user:passwd@ip:prot'\n# }\n\n# 构建一个handler对象，参数是一个字典类型，包括代理类型和代理服务器ip+prot\nhttp_proxy_handler = urllib.request.ProxyHandler(proxy_ip)\n\n# 构建一个没有代理对象的处理器对象\nnull_proxy_headler = urllib.request.ProxyHandler({})\n\n\nif proxyswitch:\n  opener = urllib.request.build_opener(http_proxy_handler)\nelse:\n  opener = urllib.request.build_opener(null_proxy_headler)\n\n# 构建一个全局的opener,之后的所有请求都可以用urlopen()方式发送，也附带Handler功能\nurllib.request.install_opener(opener)\nrequest = urllib.request.Request('http://www.baidu.com/')\nresponse = urllib.request.urlopen(request)\n\n# response = opener.open(request)\n\nprint(response.read().decode())\nProxyBasicAuthHandler(代理授权验证):\n#conding=utf-8\n\nimport urllib.request\n\n\nuser = ''\npasswd = ''\nproxyserver = ''\n\n# 构建一个密码管理对象，用来保存需要处理的用户名和密码\npasswdmgr = urllib.request.HTTPPasswordMgrWithDefaultRealm()\n\n# 添加账户信息，第一个参数realm是与远程服务器相关的域信息，一般都是写None，后面三个参数分别是 代理服务器、用户名、密码\npasswdmgr.add_password(None, proxyserver, user, passwd)\n\n# 构建一个代理基础用户名/密码验证的ProxyBasicAuthHandler处理器对象，参数是创建的密码管理对象\nproxy_auth_handler = urllib.request.ProxyDigestAuthHandler(passwdmgr)\n\n# 通过 build_opener()方法使用这些代理Handler对象，创建自定义opener对象，参数包括构建的 proxy_handler 和 proxyauth_handler\nopener = urllib.request.build_opener(proxy_auth_handler)\n\nrequest = urllib.request.Request('http://www.baidu.com/')\nresponse = opener.open(request)\n\nprint(response.read().decode())\nCookie\nCookie 是指某些网站服务器为了辨别用户身份和进行Session跟踪，而储存在用户浏览器上的文本文件，Cookie可以保持登录信息到用户下次与服务器的会话。\nHTTP是无状态的面向连接的协议, 为了保持连接状态, 引入了Cookie机制 Cookie是http消息头中的一种属性\nCookie名字（Name）\nCookie的值（Value）\nCookie的过期时间（Expires/Max-Age）\nCookie作用路径（Path）\nCookie所在域名（Domain），\n使用Cookie进行安全连接（Secure）。\n\n前两个参数是Cookie应用的必要条件，另外，还包括Cookie大小（Size，不同浏览器对Cookie个数及大小限制是有差异的）。\nCookie由变量名和值组成，根据 Netscape公司的规定，Cookie格式如下：\nSet－Cookie: NAME=VALUE；Expires=DATE；Path=PATH；Domain=DOMAIN_NAME；SECURE\n在Python处理Cookie，一般是通过cookielib模块和urllib2模块的HTTPCookieProcessor处理器类一起使用。\ncookielib模块：主要作用是提供用于存储cookie的对象\nHTTPCookieProcessor处理器：主要作用是处理这些cookie对象，并构建handler对象。\ncookielib 库\n该模块主要的对象有CookieJar、FileCookieJar、MozillaCookieJar、LWPCookieJar\n一般情况下，只用CookieJar(),如果需要和本地文件交互，就需要使用MozillaCookjar()和LWPCookieJar()\n获取Cookie，并保存到CookieJar()对象中:\n#!/usr/local/bin/python\n\nimport urllib.request\nimport http.cookiejar\n\ncookiejar = http.cookiejar.CookieJar()\n\nhttp_handler = urllib.request.HTTPCookieProcessor(cookiejar)\n\nopener = urllib.request.build_opener(http_handler)\n\nopener.open('http://www.baidu.com')\n\ncook_str = ''\nfor item in cookiejar:\n    cook_str = cook_str + item.name + '=' + item.value + ';'\n\nprint(cook_str[:-1])\n\n# BAIDUID=5DB0FC0C0DC9692BB8EE6EDC93A2EDEA:FG=1;BIDUPSID=5DB0FC0C0DC9692BB8EE6EDC93A2EDEA;H_PS_PSSID=1468_26259_21099_26350_26580;PSTM=1528615563;BDSVRTM=0;BD_HOME=0\n访问网站获得cookie，并把获得的cookie保存在cookie文件中：\n#!/usr/local/bin/python\n\nimport http.cookiejar\nimport urllib.request\n\nfilename = 'cookie.txt'\n\n# 声明一个MozillaCookieJar(有save实现)对象实例来保存cookie，之后写入文件\ncookiejar = http.cookiejar.MozillaCookieJar(filename)\n\nhandler = urllib.request.HTTPCookieProcessor(cookiejar)\nopener = urllib.request.build_opener(handler)\nreq = opener.open('http://www.baidu.com')\n\n# 保存cookie到本地文件\ncookiejar.save()\n\nprint(1)\n非结构化数据和结构化数据\n实际上爬虫一共就四个主要步骤：\n\n明确目标 (要知道准备在哪个范围或者网站去搜索)\n爬 (将所有的网站的内容全部爬下来)\n取 (去掉对没用处的数据)\n处理数据（按照想要的方式存储和使用）\n\nre模块\npattern = re.compile(regExp)\n\npattern.match(): 从起始位置开始查找，返回第一个符合规则的，只匹配一次。\npattern.search(): 从任意位置开始查找，返回第一个符合规则的，只匹配一次。\npattern.findall(): 所有的全部匹配，返回列表\npattern.split(): 分割字符串，返回列表\npattern.sub(): 替换\nrs.I 忽略大小写\nre.S 全文匹配\n\nmatch(str, begin, end):\n>>> pattern = re.compile(r'([a-z]+) ([a-z]+)', re.I)\n>>> m = pattern.match('hello world hello python')\n>>> m.group()\n'hello world'\n>>> m.group(1)\n'hello'\n>>> m.group(2)\n'world'\n\nfindall(str, begin, end):\n>>> pattern = re.compile(r'\\d+')\n>>> pattern.findall('hello world 123 456 789')\n['123', '456', '789']\n>>> \nsplit(str, count):\n>>> pattern = re.compile(r'[\\s\\d\\;]+')\n>>> pattern.split('a b\\a;m; a  ')\n['a', 'b\\x07', 'm', 'a', '']\n>>> \n>>> pattern = re.compile('[\\s\\d\\;]+')\n>>> pattern.split(r'a b\\a;m; a  ')\n['a', 'b\\\\a', 'm', 'a', '']\n>>> \nsub():\n>>> pattern = re.compile(r'(\\w+)(\\w+)')\n>>> strs = 'hello 123, world 456'\n>>> pattern.sub('hello world', strs)\n'hello world hello world, hello world hello world'\n>>>\nxpath\nchrome插件：XPath HelperXPath (XML Path Language) 是一门在 XML 文档中查找信息的语言，可用来在XML文档中对元素和属性进行遍历。\nlxml库：lxml是 一个HTML/XML的解析器，主要的功能是如何解析和提取HTML/XML数据。\n获取属性：@src, @title, @class获取内容: /text()模糊查询: contains(@id, '模糊字符串')\nxpath匹配规则:\n//div[@class=\"pic imgcover\"]/img/@src\nxpath模糊匹配：\n//div[contains(@id, 'qiushi_tag')]\n获取某个网站的图片：\n#conding=utf-8\n\nimport urllib.request\nimport urllib.parse\nfrom lxml import etree # 我乃河北，姓氏颜良\n\nclass getQdailyImg:\n    def __init__(self, url):\n        self.url = url\n\n    def loadPage(self):\n        print('正在下载...')\n        headres = {\n            'User-Agent': 'ie 的user-Agent'\n        }\n        req = urllib.request.Request(self.url, headers=headres)\n        html = urllib.request.urlopen(req).read().decode()\n        xmlDom = etree.HTML(html)\n        linkList = xmlDom.xpath('//div[@class=\"pic imgcover\"]/img/@src')\n        print(linkList)\n        self.writePage(linkList)\n\n    def writePage(self, data):\n        for item in data:\n            with open('img.txt', 'w') as f:\n                f.write(item)\n\nif __name__ == '__main__':\n    qdI = getQdailyImg('http://www.qdaily.com/')\n    qdI.loadPage()\n\n# -*- coding:utf-8 -*-\n\nimport urllib.request\nimport json\nfrom lxml import etree\n\nurl = 'http://www.qiushibaike.com/8hr/page/1'\nheaders = {\n    'user-agent': 'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; GTB7.0)'\n}\n\nreq = urllib.request.Request(url, headers=headers)\nhtml = urllib.request.urlopen(req).read()\ntext = etree.HTML(html)\n\n# 作为根目录节点\nnode_list = text.xpath('//div[contains(@id, \"qiushi_tag\")]')\n\nitems = {}\nfor node in node_list:\n    username = node.xpath('./div[@class=\"author clearfix\"]//h2/text()')[0]\n\n    image = node.xpath('.//div[@class=\"thumb\"]//@src')\n\n    content = node.xpath('.//div[@class=\"content\"]/span')[0].text\n\n    zan = node.xpath('.//i')[0].text\n\n    comment = node.xpath('.//i')[1].text\n\n    items = {\n        'username': username,\n        'image': image,\n        'content': content,\n        'zan': zan,\n        'comment': comment\n    }\n\n    with open('qiushi.json', 'a') as f:\n        f.write(json.dumps(items, ensure_ascii=False) + '\\n')\n\nprint('ok')\nBeautifulSoup\nBeautiful Soup也是一个HTML/XML的解析器，主要的功能也是如何解析和提取 HTML/XML数据。\nBeautifulSoup用来解析HTML比较简单，API非常人性化，支持CSS选择器、Python标准库中的HTML解析器，也支持lxml的 XML解析器。\npip install bs4beautifulsoup4文档\n\ntag: BeautifulSoup(html).div\n\nattrs: BeautifulSoup(html).div.name，BeautifulSoup(html).div.attres\n\ncontent: BeautifulSoup(html).span.string\n\n\n#conding=utf-8\n\nfrom bs4 import BeautifulSoup\nimport requests\nimport time\n\ndef captchaMethod(captcha_data):\n    with open('captcha.jpg', 'wb') as f:\n        f.write(captcha_data)\n    return input('请输入验证码：')     \n\ndef getLoginZhihu():\n    # 构建Session对象，保存cookie值\n    sess = requests.Session()\n\n    headers = {\n        'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.101 Safari/537.36 QQBrowser/4.3.4986.400'\n    }\n\n    html = sess.post('https://www.zhihu.com/#sigin', headers=headers).text\n    bs = BeautifulSoup(html, 'lxml')\n    _xsrf = bs.find('input', attrs={'name': '_xsrf'}).get('value')\n\n    captcha_url = 'https://www.zhihu.com/captcha.gif?r=%d&type=login' % (time.time() * 1000)\n    captcha = sess.get(captcha_url, headers=headers).content\n\n    # 获取验证码文字\n    text = captchaMethod(captcha)\n\n    data = {\n        '_xsrf': _xsrf,\n        'email': '123636374@qq.com',\n        'password': 'ALARMCHIME',\n        'captcha': text\n    }\n    # 登录 获取cookie\n    res = sess.post('https://www.zhihu.com/login/email', data=data, headers=headers).text\n\n    res = sess.get('https://www.zhihu.com/people/', headers)\n\nif __name__ == '__main__':\n    getLoginZhihu()\n    \nJSON和JSONPATH\nJson和JsonPath应用\n\n\njson.loads(): 把Json格式字符串解码转换成Python对象\n\njson.dumps(): 实现python类型转化为json字符串，返回一个str对象 把一个Python对象编码转换成Json字符串\n\njson.dump(): 将Python内置类型序列化为json对象后写入文件\n\njson.load(): 读取文件中json形式的字符串元素 转化成python类型\n\ndictStr = {\"city\": \"北京\", \"name\": \"大猫\"}\nprint(json.dumps(dictStr, ensure_ascii=False))\n# {\"city\": \"北京\", \"name\": \"大刘\"}\n\nlistStr = [{\"city\": \"北京\"}, {\"name\": \"大刘\"}]\njson.dump(listStr, open(\"listStr.json\",\"w\"), ensure_ascii=False)\n\nstrDict = json.load(open(\"dictStr.json\"))\nprint(strDict)\n# {u'city': u'\\u5317\\u4eac', u'name': u'\\u5927\\u5218'}\n\n# -*- coding:utf-8 -*-\n\nimport json\nimport urllib.request\nimport jsonpath\n\nheaders = {\n    'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.101 Safari/537.36 QQBrowser/4.3.4986.400'\n}\nurl = 'https://www.lagou.com/lbs/getAllCitySearchLabels.json'\n\nrequest = urllib.request.Request(url, headers=headers)\n\nresponse = urllib.request.urlopen(request)\nhtml = response.read().decode()\n\nunicodeStr = json.loads(html)\ncontent = jsonpath.jsonpath(unicodeStr, '$..name')\nprint(content)\narray = json.dumps(content, ensure_ascii=False)\n\nwith open('lagoucontent.json', 'w') as f:\n    f.write(array)\n多线程爬虫\n一个进程可能包括多个线程，线程之间执行任务，必须通过加锁方式控制它们（阻塞）父线程和子线程都关系，只要父线程执行完，不管子线程如何，都一并结束\n\n计算机的核心是CPU，CPU承担了所有的计算任务\n一个CPU核心一次只能执行一个任务多个CPU核心同时可以执行多个任务\n一个CPU一次只能执行一个进程，其它进程处于非运行\n进程里包含的执行单元叫线程一个进程 可以包含 多个线程\n一个进程的内存空间是共享的，每个进程里的线程都可以使用这个共享空间一个线程在使用这个共享空间的时候，其它线程必须等待它结束\n通过“锁”实现，作用就是防止多个线程使用当前内存空间。先使用的线程会加锁，锁上该空间，其它线程就在等待。\n\n进程：表示程序的一次执行线程：CPU运算的基本调度单位\nGIL： Python里的执行通行证，而且只有唯一个。拿到通行证的线程才会执行\nPython 的多线程适用于：大量密集的I/O处理 （单独都任务，一个进程，只能执行一个任务）Python 的多进程适用于：大量的密集并行计算\n#conding=utf-8\n\nimport json\nimport threading\nfrom queue import Queue\n\nimport requests\nfrom lxml import etree\n\nCREAWL_EXIT = False\nPARSE_EXIT = False\n\n'''\n    采集线程\n'''\nclass ThreadCrawl(threading.Thread):\n    def __init__(self, threadName, pageQueue, dataQueue):\n        # threading.Thread.__init__(self)\n        super(ThreadCrawl, self).__init__() # 多个父类，多重继承\n        self.threadName = threadName\n        self.pageQueue = pageQueue\n        self.dataQueue = dataQueue\n        self.headers = {\n            'user-agent': 'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; GTB7.0)'\n        }\n\n    def run(self):\n        print('start' + self.threadName)\n        while not CREAWL_EXIT:\n            try:\n                page = self.pageQueue.get(False)\n                url = 'https://www.qiushibaike.com/8hr/page/' + str(page) + '/'\n                res = requests.get(url, headers=self.headers).text\n                self.dataQueue.put(res)\n            except:\n                pass\n        print('end' + self.threadName)      \n\n'''\n    解析线程\n'''\nclass ThreadParse(threading.Thread):\n    def __init__(self, threadingName, dataQueue, filename):\n        super(ThreadParse, self).__init__()\n        self.threadingName = threadingName\n        self.dataQueue = dataQueue\n        self.filename = filename\n\n    def run(self):\n        print('start' + self.threadingName)\n        while not PARSE_EXIT:\n            try:\n                html = self.dataQueue.get(False)\n                self.parse(html)\n            except:\n                pass\n        print('end' + self.threadingName)\n\n\n    def parse(self, html):\n        text = etree.HTML(html)\n        node_list = text.xpath('//div[contains(@id, \"qiushi_tag\")]')\n        items = {}\n        for node in node_list:\n            username = node.xpath('./div[@class=\"author clearfix\"]//h2/text()')[0]\n            image = node.xpath('.//div[@class=\"thumb\"]//@src')\n            content = node.xpath('.//div[@class=\"content\"]/span')[0].text\n            zan = node.xpath('.//i')[0].text\n            comment = node.xpath('.//i')[1].text\n            items = {\n                'username': username,\n                'image': image,\n                'content': content,\n                'zan': zan,\n                'comment': comment\n            }\n            self.filename.write(json.dumps(items, ensure_ascii=False) + '\\n')\n\n\ndef main():\n    # 页码\n    pageQueue = Queue(10)\n    # 放入1～10的数字\n    for i in range(1, 10+1):\n        pageQueue.put(i)\n\n    # 采集结果（每页的HTML源码）\n    dataQueue = Queue()\n\n    filename = open('duanzi.json', 'a')\n\n    crawlList = ['采集线程1', '采集线程2', '采集线程3']\n\n    threadcrawl = []\n    for threadName in crawlList:\n        thread = ThreadCrawl(threadName, pageQueue, dataQueue)\n        thread.start()\n        threadcrawl.append(thread)\n    \n    parseList = ['解析线程1', '解析线程2', '解析线程3']\n    threadparse = []\n    for threadName in parseList:\n        thread = ThreadParse(threadName, dataQueue, filename)\n        thread.start()\n        threadparse.append(thread)\n    \n    # 等待pageQueue队列为空， 或者 数据队列为空，也就是等待之前执行的操作执行完毕\n    while not pageQueue.empty() or not dataQueue.empty():\n        pass\n\n    global CREAWL_EXIT\n    CREAWL_EXIT = True\n    print('queue队列为空')\n\n    global PARSE_EXIT\n    PARSE_EXIT = True\n    print('data队列为空')\n\n    for threadItem in crawlList:\n        threadItem.join('')\n        print('1')\n\nif __name__ == '__main__':\n    main()\n自动化测试unittest模块使用和模拟用户点击抓取数据（拿去ajax分页数据）\n# -*- coding:utf-8 -*-\n\nimport unittest\nfrom selenium import webdriver\nfrom bs4 import BeautifulSoup as bs\n\nclass Douyu(unittest.TestCase):\n    def setUp(self):\n        self.driver = webdriver.PhantomJS()\n\n    # unittest测试方法必须有`test`字样开头\n    def testDouyu(self):\n        self.driver.get('https://www.douyu.com/directory/all')\n        while True:\n            soup = bs(self.driver.page_source, 'lxml')\n            names = soup.find_all('h3', {'class': 'ellipsis'})\n            viewNums = soup.find_all('span', {'class': 'dy-num fr'})\n            \n            for name, viewNum in zip(names, viewNums):\n                print('房间名' + name.get_text() + '; ' + '观众人数' + viewNum.get_text())\n\n            # 在页面源码中找到\"下一页\"未隐藏的标签，就退出循环\n            if self.driver.page_source.find('shark-pager-disable-next') != -1:\n                break\n\n            # 一直点击下一页\n            self.driver.find_element_by_class_name('shark-pager-next').click()    \n\n    # 测试结束执行的方法\n    def tearDown(self):\n        self.driver.quit()\n\nif __name__ == '__main__':\n    unittest.main()\n执行javascript语句：execute_script\n#conding=utf-8\n\nfrom selenium import webdriver\nimport time\n\ndriver = webdriver.PhantomJS('/Users/linxingzhang/Library/Python/3.6/lib/python/site-packages/selenium/webdriver/phantomjs')\ndriver.get(\"https://movie.douban.com/typerank?type_name=剧情&type=11&interval_id=100:90&action=\")\n\ntime.sleep(3)\n# 向下滚动10000像素\njs = \"document.body.scrollTop=10000\"\n# js=\"var q=document.documentElement.scrollTop=10000\"\n\n# 查看页面快照\ndriver.save_screenshot(\"douban.png\")\n\n# 执行JS语句\ndriver.execute_script(js)\ntime.sleep(10)\n\n# 查看页面快照\ndriver.save_screenshot(\"newdouban.png\")\n\ndriver.quit()\n投票\nimport datetime\nimport sys\nimport threading\nimport time\nfrom random import choice  # choice() 方法返回一个列表，元组或字符串的随机项\n\nimport requests\nfrom lxml import etree\n\nfrom fake_useragent import UserAgent  # 引入随机的UA\n\n# 设置user-agent列表,每次请求时，随机挑选一个user-agent\nua_list = UserAgent()\n\n\ndef get_ip():\n    '''\n        获取代理ip\n    '''\n    url = 'http://www.xicidaili.com/nn'\n    headers = {\n        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',\n        'Host': 'www.xicidaili.com',\n        'Referer': 'http: // www.xicidaili.com/nn',\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.26 Safari/537.36 Core/1.63.6726.400 QQBrowser/10.2.2265.400'\n    }\n    ret = requests.get(url, headers=headers)\n    xmlDom = etree.HTML(ret.text)\n\n    data = xmlDom.xpath('//table[@id=\"ip_list\"]//tr')\n    z = []\n    for tr in data:\n        if tr.xpath('td'):\n            ip = tr.xpath('td')[1].text  # 获取所有IP\n            port = tr.xpath('td')[2].text  # 获取所有端口\n            z.append(ip + ':' + port)\n    return z\n\n\ndef get_url(url, code=0, ips=[]):\n    '''\n        投票\n        如果因为代理IP已失效造成投票失败，则会自动换一个代理IP后继续投票\n    '''\n    try:\n        ip = choice(ips)\n        print(ip, 'ip' * 5)\n    except:\n        return False\n    else:\n        proxies = {\n            'http': ip\n        }\n        headers = {\n            'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',\n            'Host': 'best.zhaopin.com',\n            'Origin': 'https: // best.zhaopin.com',\n            'Referer': 'https//best.zhaopin.com/?sid=121128100&site=sou',\n            'User-Agent': ua_list.random\n        }\n        print(ua_list.random, 'ua_list' * 5)\n\n    try:\n        data = {'bestid': '3713', 'score': '5,5,5,5,5,5', 'source': 'best'}\n        # 跳过证书的验证 verify=False\n        result = requests.post(url, data=data, headers=headers, proxies=proxies)\n        print(result, 'result' * 5)\n    except requests.exceptions.ConnectionError:\n        print('ConnectionError')\n        if not ips:\n            print('ip 失效')\n            sys.exit()\n\n        # 删除不可用的代理IP\n        if ip in ips:\n            ips.remove(ip)\n        # 重新请求url\n        get_url(url, code=0, ips=[])\n    else:\n        date = datetime.datetime.now().strftime('%H:%M:%S')\n        # result.text() 投票成功显示1  失败显示0\n        print('第%s次 [%s] [%s]：投票%s (剩余可用代理IP数：%s)' %\n              (code, date, ip, result.text, len(ips)))\n\n\ndef main():\n    url = 'https://best.zhaopin.com/API/ScoreCompany.ashx'  # 投票的请求\n    ips = []\n    for i in range(6000):\n        if i % 1000 == 0:\n            ips.extend(get_ip())\n            # print('-' * 100)\n            # print(ips)\n        t = threading.Thread(target=get_url, args=(url, i, ips))\n        t.start()\n        time.sleep(1)\n\n\nif __name__ == '__main__':\n    main()\n\nTesseract\n机器识别中的文字识别\npip install pytesseract\n识别图片中的文字：\n#conding=utf-8\n\nimport pytesseract\nfrom PIL import Image\n\nimage = Image.open('./mayday.jpg')\n\ntext = pytesseract.image_to_string(image)\n\nprint(text)\nasyncio & aiohttp\n通过异步库aiohttp,asyncio爬取图片\n# -*- coding:utf-8 -*-\nimport asyncio\nimport os\nimport time\n\nimport aiohttp\nimport requests\n\n\nclass Spider(object):\n    def __init__(self):\n        self.num = 1\n        if 'load-img' not in os.listdir('.'):\n            os.mkdir('load-img')\n        self.path = os.path.join(os.path.abspath('.'), 'load-img')\n        os.chdir(self.path)  # 进入文件下载路径\n\n    def run(self):\n        start = time.time()\n        for x in range(1, 101): # 爬取100张图片，更改数值，爬取更多图片\n            links = self.__get_img_links(x)\n            tasks = [asyncio.ensure_future(self.__download_img(\n                (link['id'], link['links']['download'])\n            )) for link in links]\n            loop = asyncio.get_event_loop()\n            loop.run_until_complete(asyncio.wait(tasks))\n            # if self.num >= 10:\n            #     break\n        end = time.time()\n        print('run %s s' % (end - start))\n\n    def __get_img_links(self, page):\n        url = 'https://unsplash.com/napi/photos'\n        data = {\n            'page': page,\n            'per_page': 12,\n            'order_by': 'latest'\n        }\n        response = requests.get(url, params=data)\n        if response.status_code == 200:\n            return response.json()\n        else:\n            print('request %s' % response.status_code)\n\n    async def __download_img(self, img):\n        content = await self.__get_content(img[1])\n        with open(img[0] + '.jpg', 'wb') as f:\n            f.write(content)\n        print('load %s page success' % self.num)\n        self.num += 1\n\n    async def __get_content(self, link):\n        async with aiohttp.ClientSession() as session:\n            response = await session.get(link)\n            content = await response.read()\n            return content\n\n\ndef main():\n    spider = Spider()\n    spider.run()\n\n\nif __name__ == '__main__':\n    main()\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "3"}