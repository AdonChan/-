{"title": "Python基础之使用期物处理并发 - 个人文章 ", "index": "python", "content": "导语：本文章记录了本人在学习Python基础之控制流程篇的重点知识及个人心得，打算入门Python的朋友们可以来一起学习并交流。\n本文重点：\n1、掌握异步编程的相关概念；2、了解期物future的概念、意义和使用方法；3、了解Python中的阻塞型I/O函数释放GIL的特点。\n一、异步编程相关概念\n阻塞：程序未得到所需计算资源时被挂起的状态。换句话说，程序在等待某个操作完成期间，自身无法继续干别的事情，则称该程序在该操作上是阻塞的。并发：描述的是程序的组织结构。指程序要被设计成多个可独立执行的子任务。并发以利用有限的计算机资源使多个任务可以被实时或近实时执行为目的。并行：指的是多任务同时执行的程序状态，以利用多核CPU加速完成多任务为目的。异步：为完成某个任务，不同程序单元之间过程中无需通信协调，也能完成任务的方式。不相关的程序单元之间可以是异步的。简言之，异步意味着无序。异步编程：以进程、线程、协程、函数/方法作为执行任务的基本单位，结合回调，事件循环、信号量等机制，以提高整体执行效率和并发能力的编程方式。\n二、期物\n就下载国旗为目标实现的三个客户端中，两个HTTP并发客户端比依序下载的脚本性能高很多。由此说明使用并发可以高效处理网络I/O。\n期物(future)指一种对象，表示异步执行的操作。期物对象：concurrent.futures.Future或asyncio.Future类的实例。三大方法：\n\nExecutor.submit()：创建期物。\nconcurrent.futures.as_completed()：迭代运行结束的期物，返回一个迭代器。\nExecutor.map(): 处理参数不同的同一个可调用对象。\n\n小结：Executor.submit()加futures.as_completed()的组合比Executor.map()更灵活，因为submit()能处理不同的可调用对象和参数。\nconcurrent.futures模块的主要特色是ThreadPoolExecutor和ProcessPoolExecutor类，这两个类实现的接口能分别在不同的线程或进程中执行可调用的对象。注意：通常情况下自己不应该创建期物，而只能由并发框架(concurrent.futures或asyncio)实例化。\n实例：concurrent.futures模块应用\nfrom concurrent import futures\n\nfrom flags import save_flag, get_flag, show, main \n\nMAX_WORKERS = 20\n\ndef download_one(cc): \n    image = get_flag(cc)\n    show(cc)\n    save_flag(image, cc.lower() + '.gif')\n    return cc\n\ndef download_many(cc_list):\n    workers = min(MAX_WORKERS, len(cc_list))  \n    with futures.ThreadPoolExecutor(workers) as executor: \n        res = executor.map(download_one, sorted(cc_list))  \n\n    return len(list(res))\n\nif __name__ == '__main__':\n    main(download_many)  \n三、阻塞性I/O与GIL\nPython标准库中所有阻塞型I/O函数都会释放全局解释器锁（GIL），允许其他线程运行。因此尽管有GIL，Python线程仍然适合在I/O密集型系统使用。\n四、线程和多进程的替代方案\n\n对CPU密集型工作来说，要启动多个进程，规避GIL。\n创建多进程最简单的方式是使用futures.ProcessPoolExecutor类。\nthreading和multiprocessing模块：是Python中多线程和多进程并发的低层实现。\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}