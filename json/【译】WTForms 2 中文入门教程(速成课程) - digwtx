{"title": "【译】WTForms 2 中文入门教程(速成课程) - digwtx ", "index": "django,python,flask,wtforms", "content": "你打了个响指, 然后开始致力于你想写的棒极了的 Python 网络应用程序. 你写完一些页面, 最后你需要着手处理令人讨厌的任务：处理和验证表单输入. 进入（开始）WTForms.\n\n\n\n但是, 为什么我需要另一个框架呢？好吧, 一些网络应用程序框架采用数据库模型和表单处理相结合的方法. 同时这对很基本的创建/更新视图函数是很方便的, 可能性是不是每个你需要的表单都能直接映射到一个数据库模型. 也许你已经使用通用的表单处理框架, 只是你想要定制这些表单域的 HTML 代码生成, 并且定义属于你的验证器.\n\n使用 WTForms, 你能生成属于你的表单域的 HTML 代码, 此外我们允许你在模板中定制它. 这允许你维持独立的代码和展现, 并把这些凌乱的参数保留在 Python 代码之外. 因为我们争取松耦合, 同样的, 你应该可以在你喜欢的任意的模板引擎中这么做.\n\n\n  备注: 本人未过四级, 翻译水平有限, 欢迎指正.\n\n\n下载和安装\n\n安装 WTForms 最简单的方式是使用 easy_install 和 pip:\n\nbasheasy_install WTForms\n# or\npip install WTForms\n\n\n你可以从 PyPI 手动 下载 WTForms 然后运行 python setup.py install .\n\n如果你是那种喜欢这一切风险的人, 就运行来自 Git 的最新版本, 你能够获取最新变更集的 打包版本, 或者前往 项目主页 克隆代码仓库.\n\n主要概念\n\n\nForms 类是 WTForms 的核心容器. 表单(Forms)表示域(Fields)的集合, 域能通过表单的字典形式或者属性形式访问.\nFields(域)做最繁重的工作. 每个域(field)代表一个数据类型, 并且域操作强制表单输入为那个数据类型. 例如,  InputRequired 和 StringField 表示两种不同的数据类型. 域除了包含的数据（data）之外, 还包含大量有用的属性, 例如标签、描述、验证错误的列表.\n每个域(field)拥有一个Widget(部件)实例. Widget 的工作是渲染域(field)的HTML表示. 每个域可以指定Widget实例, 但每个域默认拥有一个合理的widget. 有些域是简单方便的, 比如 TextAreaField 就仅仅是默认部件(widget) 为 TextArea 的StringField.\n为了指定验证规则, 域包含验证器(Validators)列表.\n\n开始\n\n让我们直接进入正题并定义我们的第一个表单::\n\npythonfrom wtforms import Form, BooleanField, StringField, validators\n\nclass RegistrationForm(Form):\n    username     = StringField('Username', [validators.Length(min=4, max=25)])\n    email        = StringField('Email Address', [validators.Length(min=6, max=35)])\n    accept_rules = BooleanField('I accept the site rules', [validators.InputRequired()])\n\n\n当你创建一个表单(form), 你定义域(field)的方法类似于很多ORM定义它们的列(columns)：通过定义类变量, 即域的实例.\n\n因为表单是常规的 Python 类, 你可以很容易地把它们扩展成为你期望的::\n\npythonclass ProfileForm(Form):\n    birthday  = DateTimeField('Your Birthday', format='%m/%d/%y')\n    signature = TextAreaField('Forum Signature')\n\nclass AdminProfileForm(ProfileForm):\n    username = StringField('Username', [validators.Length(max=40)])\n    level    = IntegerField('User Level', [validators.NumberRange(min=0, max=10)])\n\n\n通过子类,  AdminProfileForm 类获得了已经定义的 ProfileForm 类的所有域. 这允许你轻易地在不同表单之间共享域的共同子集, 例如上面的例子, 我们增加 admin-only 的域到 ProfileForm.\n\n使用表单\n\n使用表单和实例化它一样简单. 想想下面这个django风格的视图函数, 它使用之前定义的 RegistrationForm 类::\n\npythondef register(request):\n    form = RegistrationForm(request.POST)\n    if request.method == 'POST' and form.validate():\n        user = User()\n        user.username = form.username.data\n        user.email = form.email.data\n        user.save()\n        redirect('register')\n    return render_response('register.html', form=form)\n\n\n首先, 我们实例化表单, 给它提供一些 request.POST 中可用的数据. 然后我们检查请求(request)是不是使用 POST 方式, 如果它是, 我们就验证表单, 并检查用户遵守这些规则. 如果成功了, 我们创建新的 User 模型, 并从已验证的表单分派数据给它, 最后保存它.\n\n编辑现存对象\n\n我们之前的注册例子展示了如何为新条目接收输入并验证, 只是如果我们想要编辑现有对象怎么办？很简单::\n\npythondef edit_profile(request):\n    user = request.current_user\n    form = ProfileForm(request.POST, user)\n    if request.method == 'POST' and form.validate():\n        form.populate_obj(user)\n        user.save()\n        redirect('edit_profile')\n    return render_response('edit_profile.html', form=form)\n\n\n这里, 我们通过给表单同时提供 request.POST 和用户(user)对象来实例化表单. 通过这样做, 表单会从 user 对象得到在未在提交数据中出现的任何数据.\n\n我们也使用表单的populate_obj方法来重新填充用户对象, 用已验证表单的内容. 这个方法提供便利, 用于当域(field)名称和你提供数据的对象的名称匹配时. 通常的, 你会想要手动分配值, 但对于这个简单例子, 它是最好的. 它也可以用于CURD和管理(admin)表单.\n\n在控制台中探索\n\nWTForms 表单是非常简单的容器对象, 也许找出表单中什么对你有用的最简单的方法就是在控制台中玩弄表单:\n\npython>>> from wtforms import Form, StringField, validators\n>>> class UsernameForm(Form):\n...     username = StringField('Username', [validators.Length(min=5)], default=u'test')\n...\n>>> form = UsernameForm()\n>>> form['username']\n<wtforms.fields.StringField object at 0x827eccc>\n>>> form.username.data\nu'test'\n>>> form.validate()\nFalse\n>>> form.errors\n{'username': [u'Field must be at least 5 characters long.']}\n\n\n我们看到的是当你实例化一个表单的时候, 表单包含所有域的实例, 访问域可以通过字典形式或者属性形式. 这些域拥有它们自己的属性, 就和封闭的表单一样.\n\n当我们验证表单, 它返回逻辑假, 意味着至少一个验证规则不满足. form.errors 会给你一个所有错误的概要.\n\npython>>> form2 = UsernameForm(username=u'Robert')\n>>> form2.data\n{'username': u'Robert'}\n>>> form2.validate()\nTrue\n\n\n这次, 我们实例化 UserForm 时给 username 传送一个新值, 验证表单是足够了.\n\n表单如何获取数据\n\n除了使用前两个参数(formdata和obj)提供数据之外, 你可以传送关键词参数来填充表单. 请注意一些参数名是被保留的: formdata, obj, prefix.\n\nformdata比obj优先级高, obj比关键词参数优先级高. 例如:\n\npythondef change_username(request):\n    user = request.current_user\n    form = ChangeUsernameForm(request.POST, user, username='silly')\n    if request.method == 'POST' and form.validate():\n        user.username = form.username.data\n        user.save()\n        return redirect('change_username')\n    return render_response('change_username.html', form=form)\n\n\n虽然你在实践中几乎从未一起使用所有3种方式, 举例说明WTForms是如何查找 username 域:\n\n\n如果表单被提交(request.POST非空), 则处理表单输入. 实践中, 即使这个域没有   表单输入, 而如果存在任何种类的表单输入, 那么我们会处理表单输入.\n\n如果没有表单输入, 则按下面的顺序尝试:\n\n\n检查 user 是否有一个名为 username 的属性.\n检查是否提供一个名为 username 的关键词参数.\n最后, 如果都失败了, 使用域的默认值, 如果有的话.\n\n\n\n验证器\n\nWTForms中的验证器(Validators)为域(field)提供一套验证器, 当包含域的表单进行验证时运行. 你提供验证器可通过域构造函数的第二个参数validators:\n\npythonclass ChangeEmailForm(Form):\n    email = StringField('Email', [validators.Length(min=6, max=120), validators.Email()])\n\n\n你可以为一个域提供任意数量的验证器. 通常, 你会想要提供一个定制的错误消息:\n\npythonclass ChangeEmailForm(Form):\n    email = StringField('Email', [\n        validators.Length(min=6, message=_(u'Little short for an email address?')),\n        validators.Email(message=_(u'That\\'s not a valid email address.'))\n    ])\n\n\n这通常更好地提供你自己的消息, 作为必要的默认消息是通用的. 这也是提供本地化错误消息的方法.\n\n对于内置的验证器的列表, 查阅 Validators.\n\n渲染域\n\n渲染域和强制它为字符串一样简单:\n\npython>>> from wtforms import Form, StringField\n>>> class SimpleForm(Form):\n...   content = StringField('content')\n...\n>>> form = SimpleForm(content='foobar')\n>>> str(form.content)\n'<input id=\"content\" name=\"content\" type=\"text\" value=\"foobar\" />'\n>>> unicode(form.content)\nu'<input id=\"content\" name=\"content\" type=\"text\" value=\"foobar\" />'\n\n\n然而, 渲染域的真正力量来自于它的 __call__() 方法. 调用(calling)域, 你可以提供关键词参数, 它们会在输出中作为HTML属性注入.\n\npython>>> form.content(style=\"width: 200px;\", class_=\"bar\")\nu'<input class=\"bar\" id=\"content\" name=\"content\" style=\"width: 200px;\" type=\"text\" value=\"foobar\" />'\n\n\n现在, 让我们应用这个力量在 Jinja 模板中渲染表单. 首先, 我们的表单:\n\npythonclass LoginForm(Form):\n    username = StringField('Username')\n    password = PasswordField('Password')\n\nform = LoginForm()\n\n\n然后是模板文件:\n\njinja<form method=\"POST\" action=\"/login\">\n    <div>{{ form.username.label }}: {{ form.username(class=\"css_class\") }}</div>\n    <div>{{ form.password.label }}: {{ form.password() }}</div>\n</form>\n\n\n相同的, 如果你使用 Django 模板, 当你想要传送关键词参数时, 你可以使用我们在Django扩展中提供的模板标签form_field:\n\ndjango{% load wtforms %}\n<form method=\"POST\" action=\"/login\">\n    <div>\n        {{ form.username.label }}:\n        {% form_field form.username class=\"css_class\" %}\n    </div>\n    <div>\n        {{ form.password.label }}:\n        {{ form.password }}\n    </div>\n</form>\n\n\n这两个将会输出:\n\nhtml<form method=\"POST\" action=\"/login\">\n    <div>\n        <label for=\"username\">Username</label>:\n        <input class=\"css_class\" id=\"username\" name=\"username\" type=\"text\" value=\"\" />\n    </div>\n    <div>\n        <label for=\"password\">Password</label>:\n        <input id=\"password\" name=\"password\" type=\"password\" value=\"\" />\n    </div>\n</form>\n\n\nWTForms是模板引擎不可知的, 同时会和任何允许属性存取、字符串强制(string coercion)、函数调用的引擎共事. 在 Django 模板中, 当你不能传送参数时, 模板标签 form_field 提供便利.\n\n显示错误消息\n\n现在我们的表单拥有一个模板, 让我们增加错误消息::\n\njinja<form method=\"POST\" action=\"/login\">\n    <div>{{ form.username.label }}: {{ form.username(class=\"css_class\") }}</div>\n    {% if form.username.errors %}\n        <ul class=\"errors\">{% for error in form.username.errors %}<li>{{ error }}</li>{% endfor %}</ul>\n    {% endif %}\n\n    <div>{{ form.password.label }}: {{ form.password() }}</div>\n    {% if form.password.errors %}\n        <ul class=\"errors\">{% for error in form.password.errors %}<li>{{ error }}</li>{% endfor %}</ul>\n    {% endif %}\n</form>\n\n\n\n\n如果你喜欢在顶部显示大串的错误消息, 也很简单:\n\njinja{% if form.errors %}\n    <ul class=\"errors\">\n        {% for field_name, field_errors in form.errors|dictsort if field_errors %}\n            {% for error in field_errors %}\n                <li>{{ form[field_name].label }}: {{ error }}</li>\n            {% endfor %}\n        {% endfor %}\n    </ul>\n{% endif %}\n\n\n由于错误处理会变成相当冗长的事情, 在你的模板中使用 Jinja 宏(macros, 或者相同意义的) 来减少引用是更好的. (例子)\n\n定制验证器\n\n这有两种方式定制的验证器. 通过定义一个定制的验证器并在域中使用它:\n\npythonfrom wtforms.validators import ValidationError\n\ndef is_42(form, field):\n    if field.data != 42:\n        raise ValidationError('Must be 42')\n\nclass FourtyTwoForm(Form):\n    num = IntegerField('Number', [is_42])\n\n\n或者通过提供一个在表单内的特定域(in-form field-specific)的验证器:\n\npythonclass FourtyTwoForm(Form):\n    num = IntegerField('Number')\n\n    def validate_num(form, field):\n        if field.data != 42:\n            raise ValidationError(u'Must be 42')\n\n\n对于更多带参数的复杂验证器, 查阅 Custom validators部分.\n\n下一步\n\n速成课程只是粗略地讲述如何在你的应用程序中开始使用WTForms处理表单输入和验证. 对于更多的信息, 你要查阅下面的:\n\n\n\nWTForms 文档 拥有整个库的API文档.\n\n解决特定问题 能帮助你处理WTForms和其它框架的特定的整合问题.\n\n邮件列表是你获得帮助, 讨论WTForms bugs, 建议新特性的地方.\n\n\n\n英文原文：http://pythonhosted.org//WTForms/crash_course.html\n译文原文：http://flask123.sinaapp.com/article/60/\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "28"}