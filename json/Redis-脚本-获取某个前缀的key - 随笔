{"title": "Redis-脚本-获取某个前缀的key - 随笔 ", "index": "python,redis", "content": "1.背景\n在平时的维护中，经常会遇到要统计某个前缀的key有多少，在请求比较多的redis中，keys * 会直接导致阻塞。可以采用scan的方式进行增量迭代，查询使用pipeline减少交互，提高效率。\n2.scan命令的优缺点\n优点：提供键空间的遍历操作，支持游标，复杂度O(1), 整体遍历一遍只需要O(N)；提供结果模式匹配；支持一次返回的数据条数设置，但仅仅是个hints，有时候返回的会多；弱状态，所有状态只需要客户端需要维护一个游标；缺点：无法提供完整的快照遍历，也就是中间如果有数据修改，可能有些涉及改动的数据遍历不到；每次返回的数据条数不一定，极度依赖内部实现；返回的数据可能有重复，应用层必须能够处理重入逻辑；\n3. python脚本的实现\npython中有一个封装的函数scan_iter--查看所有元素--迭代器脚本内容：\n#!/usr/bin/env python\n# -*- coding: UTF-8 -*-  \n#作用：统计某个前缀key的个数，并将其输入到文件\n#使用方法：python scan_redis.py apus* 100\n__author__ = \"lcl\"  \nimport sys\nimport redis \nimport os \n  \npool=redis.ConnectionPool(host='192.168.225.128',port=6379,db=0)  \nr = redis.StrictRedis(connection_pool=pool)  \n#扫描匹配值，通过sys.argv传参\nmatch = sys.argv[1]\n#每次匹配数量\ncount = sys.argv[2]\n#print match\n#print count\n#总数量\ntotal = 0\n#扫描到的key输出到文件\npath = os.getcwd()\n#扫描到的key输出的文件\ntxt = path+\"/keys.txt\"\n\nf = open(txt,\"w\")\nfor key in r.scan_iter(match = match,count = count):\n#   f.write(\"%s %s\" % (key,\"\\n\"))\n   f.write(key+\"\\n\")\n   total = total+1\nf.close\n\nprint \"匹配: %s 的数量为:%d \" % (match,total)\n\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "1"}