{"title": "用python写通用restful api service（二） - zhoutk ", "index": "mysql,flask,rest-api,python", "content": "今天项目已经能够做一个简单的后端服务了，在mysql中新建一个表，就能自动提供restful api的CURD服务了。\n关键点\n\n根据REST的四种动词形式，动态调用相应的CURD方法；\n编写REST与基础数据库访问类之间的中间层（baseDao），实现从REST到数据访问接口之间能用业务逻辑处理；\n编写基础数据库访问类（dehelper），实现从字典形式的参数向SQL语句的转换；\n\n实现的rest-api\n实现了如下形式的rest-api\n[GET]/rs/users/{id}\n[GET]/rs/users/key1/value1/key2/value2/.../keyn/valuen         \n[POST]/rs/users     \n[PUT]/rs/users/{id}\n[DELETE]/rs/users/{id}\n基础数据库访问类\n该类实现与pymysql库的对接，提供标准CURD接口。\n准备数据库表\n在数据库对应建立users表，脚本如下：\nCREATE TABLE `users` (\n  `_id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(32) CHARACTER SET utf8mb4 DEFAULT '' COMMENT '标题名称',\n  `phone` varchar(1024) DEFAULT '',\n  `address` varchar(1024) DEFAULT NULL,\n  `status` tinyint(4) DEFAULT '1' COMMENT '状态：0-禁；1-有效；9删除',\n  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n  PRIMARY KEY (`_id`),\n  UNIQUE KEY `uuid` (`_id`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT='表';\n新建数据库配置文件（configs.json）\n数据连接配置，不入版本库。\n{\n  \"db_config\": {\n    \"db_host\": \"ip\",\n    \"db_port\": 1234,\n    \"db_username\": \"root\",\n    \"db_password\": \"******\",\n    \"db_database\": \"name\",\n    \"db_charset\": \"utf8mb4\"\n  }\n}\n对接pymysql接口\n用函数exec_sql封装pymysql，提供统一访问mysql的接口。is_query函数用来区分是查询（R）还是执行（CUD）操作。出错处理折腾了好久，插入异常返回的错误形式与其它的竟然不一样！返回参数是一个三元组（执行是否成功，查询结果或错误对象，查询结果数或受影响的行数）\nwith open(\"./configs.json\", 'r', encoding='utf-8') as json_file:\n    dbconf = json.load(json_file)['db_config']\n\n\ndef exec_sql(sql, values, is_query=False):\n    try:\n        flag = False       #是否有异常\n        error = {}         #若异常，保存错误信息\n        conn = pymysql.connect(host=dbconf['db_host'], port=dbconf['db_port'], user=dbconf['db_username'],\n                               passwd=dbconf['db_password'], db=dbconf['db_database'], charset=dbconf['db_charset'])\n        with conn.cursor(pymysql.cursors.DictCursor) as cursor:\n            num = cursor.execute(sql, values)       #查询结果集数量或执行影响行数\n        if is_query:                                #查询取所有结果\n            result = cursor.fetchall()\n        else:                                       #执行提交\n            conn.commit()\n        print('Sql: ', sql, ' Values: ', values)\n    except Exception as err:\n        flag = True\n        error = err\n        print('Error: ', err)\n    finally:\n        conn.close()\n        if flag:\n            return False, error, num if 'num' in dir() else 0\n    return True, result if 'result' in dir() else '', num\n查询接口\npymysql的查询接口，可以接受数组，元组和字典，本查询接口使用数组形式来调用。现在此接口只支持与条件组合参数。\ndef select(tablename, params={}, fields=[]):\n    sql = \"select %s from %s \" % ('*' if len(fields) == 0 else ','.join(fields), tablename)\n    ks = params.keys()\n    where = \"\"\n    ps = []\n    pvs = []\n    if len(ks) > 0:                    #存在查询条件时，以与方式组合\n        for al in ks:\n            ps.append(al + \" =%s \")\n            pvs.append(params[al])\n        where += ' where ' + ' and '.join(ps)\n\n    rs = exec_sql(sql+where, pvs, True)\n    print('Result: ', rs)\n    if rs[0]:\n        return {\"code\": 200, \"rows\": rs[1], \"total\": rs[2]}\n    else:\n        return {\"code\": rs[1].args[0], \"error\": rs[1].args[1], \"total\": rs[2]}\n插入接口\n以数组形式提供参数，错误信息解析与其它接口不同。\ndef insert(tablename, params={}):\n    sql = \"insert into %s \" % tablename\n    ks = params.keys()\n    sql += \"(`\" + \"`,`\".join(ks) + \"`)\"               #字段组合\n    vs = list(params.values())                        #值组合，由元组转换为数组\n    sql += \" values (%s)\" % ','.join(['%s']*len(vs))  #配置相应的占位符\n    rs = exec_sql(sql, vs)\n    if rs[0]:\n        return {\"code\": 200, \"info\": \"create success.\", \"total\": rs[2]}\n    else:\n        return {\"code\": 204, \"error\": rs[1].args[0], \"total\": rs[2]}\n修改接口\n以字典形式提供参数，占位符的形式为：%（keyname）s，只支持按主键进行修改。\ndef update(tablename, params={}):\n    sql = \"update %s set \" % tablename\n    ks = params.keys()\n    for al in ks:                                    #字段与占位符拼接\n        sql += \"`\" + al + \"` = %(\" + al + \")s,\"\n    sql = sql[:-1]                                   #去掉最后一个逗号\n    sql += \" where _id = %(_id)s \"                   #只支持按主键进行修改\n    rs = exec_sql(sql, params)                       #提供字典参数\n    if rs[0]:\n        return {\"code\": 200, \"info\": \"update success.\", \"total\": rs[2]}\n    else:\n        return {\"code\": rs[1].args[0], \"error\": rs[1].args[1], \"total\": rs[2]}\n删除接口\n以字典形式提供参数，占位符的形式为：%（keyname）s，只支持按主键进行删除。\ndef delete(tablename, params={}):\n    sql = \"delete from %s \" % tablename\n    sql += \" where _id = %(_id)s \"\n    rs = exec_sql(sql, params)\n    if rs[0]:\n        return {\"code\": 200, \"info\": \"delete success.\", \"total\": rs[2]}\n    else:\n        return {\"code\": rs[1].args[0], \"error\": rs[1].args[1], \"total\": rs[2]}\n中间层（baseDao）\n提供默认的操作数据库接口，实现基础的业务逻辑，单表的CURD有它就足够了。有复杂业务逻辑时，继承它，进行扩展就可以了。\nimport dbhelper\n\n\nclass BaseDao(object):\n\n    def __init__(self, table):\n        self.table = table\n\n    def retrieve(self, params={}, fields=[], session={}):\n        return dbhelper.select(self.table, params)\n\n    def create(self, params={}, fields=[], session={}):\n        if '_id' in params and len(params) < 2 or '_id' not in params and len(params) < 1:      #检测参数是否合法\n            return {\"code\": 301, \"err\": \"The params is error.\"}\n        return dbhelper.insert(self.table, params)\n\n    def update(self, params={}, fields=[], session={}):\n        if '_id' not in params or len(params) < 2:          #_id必须提供且至少有一修改项\n            return {\"code\": 301, \"err\": \"The params is error.\"}\n        return dbhelper.update(self.table, params)\n\n    def delete(self, params={}, fields=[], session={}):\n        if '_id' not in params:  #_id必须提供\n            return {\"code\": 301, \"err\": \"The params is error.\"}\n        return dbhelper.delete(self.table, params)\n\n动态调用CURD\n根据客户调用的rest方式不同，动态调用baseDao的相应方法，这个很关键，实现了它才能自动分配方法调用，才能只需要建立一个数据表，就自动提供CURD基本访问功能。还好，动态语言能很方便的实现这种功能，感慨一下，node.js更方便且符合习惯^_^\n    method = {\n        \"GET\": \"retrieve\",\n        \"POST\": \"create\",\n        \"PUT\": \"update\",\n        \"DELETE\": \"delete\"\n    }\n    \ngetattr(BaseDao(table), method[request.method])(params, [], {})\n说明：\n\ntable是前一章中解析出来的数据表名，这块就是users；\nmethod应该是定义一个常量对象，对应rest的动词，因为对ypthon不熟，定义了一个变量先用着，查了下常量说明，看着好复杂；\nrequest.method 客户请求的实际rest动词；\nparams是前一章中解析出来的参数对象；\n\n完整代码\ngit clone https://github.com/zhoutk/pyrest.git\ncd pyrest\nexport FLASK_APP=index.py\nflask run\n小结\n至此，我们已经实现了基本的框架功能，以后就是丰富它的羽翼。比如：session、文件上传、跨域、路由改进（支持无缝切换操作数据库的基类与子类）、参数验证、基础查询功能增强（分页、排序、模糊匹配等）。感慨一下，好怀念在node.js中json对象的写法，不用在key外加引号。\n补丁\n刚把基础数据库访问类中的insert方法的参数形式改成了字典，结果异常信息也正常了，文章不再改动，有兴趣者请自行查阅源代码。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "7"}