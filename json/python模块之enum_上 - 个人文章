{"title": "python模块之enum_上 - 个人文章 ", "index": "enum,python", "content": "enum模块定义了：\n\n4种枚举类：Enum, IntEnum, Flag, IntFlag\n装饰器：unique()\n助手：auto\n\nFlag, IntFlag, auto在python3.6中加入\n创建枚举\nfrom enum import Enum\nclass Color(Enum):\n    RED = 2\n    GREEN = 4\n    BLUE = 6\n注意点：1. 枚举值可以是任何类型，如果值不重要可以使用auto()自动选择。但在有其他已定义的值的情况下，谨慎与auto混用2. Color是枚举类，Color.RED等是枚举成员，枚举成员拥有name和value属性3. 虽然使用class关键字创建，但枚举并不是常规意义上的python类\n枚举成员的展现形式：\n>>>print(Color.RED)\nColor.RED\n\n>>>print(repr(Color.RED))\n<Color.RED: 2>\n枚举成员的type类型是其所属的枚举类：\n>>>type(Color.RED)\n<enum 'Color'>\n>>>isinstance(Color.RED, Color)\nTrue\n枚举支持按照定义时的顺序进行迭代：\n>>>for color in Color:\n...    print(color)\n...\nColor.RED\nColor.GREEN\nColor.BLUE    \n枚举成员是可哈希的，因此可以在字典和集合中使用：\n>>> apples = {}\n>>> apples[Color.RED] = 'red delicious'\n>>> apples[Color.GREEN] = 'granny smith'\n>>> apples == {Color.RED: 'red delicious', Color.GREEN: 'granny smith'}\nTrue\n对枚举成员及其属性的程序化访问\n通过值访问枚举成员：\n>>>Color(2)\n<Color.RED: 2>\n通过名称访问枚举成员：\n>>>Color[\"RED\"]\n<Color.RED: 2>\n获取枚举成员的名称和值：\n>>>member = Color.RED\n>>>member.name\n\"RED\"\n>>>member.value\n2\n枚举成员及其值的重复性问题\n拥有两个相同名称的枚举成员是不允许的：\n>>> class Shape(Enum):\n...     SQUARE = 2\n...     SQUARE = 3\n...\nTraceback (most recent call last):\n...\nTypeError: Attempted to reuse key: 'SQUARE'\n不过不同的枚举成员允许拥有相同的值。后定义的成员是先定义的成员的别名，通过值或名称访问时都将返回先定义的成员：\n>>> class Shape(Enum):\n...     SQUARE = 2\n...     DIAMOND = 1\n...     CIRCLE = 3\n...     ALIAS_FOR_SQUARE = 2\n...\n>>> Shape.SQUARE\n<Shape.SQUARE: 2>\n>>> Shape.ALIAS_FOR_SQUARE\n<Shape.SQUARE: 2>\n>>> Shape(2)\n<Shape.SQUARE: 2>\n注意点：任意两个枚举属性(包括成员、方法等)不允许存在相同的名称\n枚举值唯一约束\n默认情况下，允许多个成员拥有相同的值。使用unique装饰器可以对枚举值进行唯一约束\n@enum.unique: 枚举专用的类装饰器。它在枚举的__members__属性中只要查找到成员别名就抛出ValueError异常\n>>> from enum import Enum, unique\n>>> @unique\n... class Mistake(Enum):\n...     ONE = 1\n...     TWO = 2\n...     THREE = 3\n...     FOUR = 3\n...\nTraceback (most recent call last):\n...\nValueError: duplicate values found in <enum 'Mistake'>: FOUR -> THREE\n自动生成枚举值\n对于不重要的枚举值，可以使用auto自动生成：\n>>> from enum import Enum, auto\n>>> class Color(Enum):\n...     RED = auto()\n...     BLUE = auto()\n...     GREEN = auto()\n...\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\nauto生成什么值取决于_generate_next_value_()方法，可重写：\n>>> class AutoName(Enum):\n...     def _generate_next_value_(name, start, count, last_values):\n...         return name\n...\n>>> class Ordinal(AutoName):\n...     NORTH = auto()\n...     SOUTH = auto()\n...     EAST = auto()\n...     WEST = auto()\n...\n>>> list(Ordinal)\n[<Ordinal.NORTH: 'NORTH'>, <Ordinal.SOUTH: 'SOUTH'>, <Ordinal.EAST: 'EAST'>, <Ordinal.WEST: 'WEST'>]\n迭代\n对枚举成员的迭代，并不会包含成员别名：\n>>> list(Shape)\n[<Shape.SQUARE: 2>, <Shape.DIAMOND: 1>, <Shape.CIRCLE: 3>]\n__members__属性是一个映射了枚举成员及其名称的有序字典，包括成员别名：\n>>> for name, member in Shape.__members__.items():\n...     name, member\n...\n('SQUARE', <Shape.SQUARE: 2>)\n('DIAMOND', <Shape.DIAMOND: 1>)\n('CIRCLE', <Shape.CIRCLE: 3>)\n('ALIAS_FOR_SQUARE', <Shape.SQUARE: 2>)\n\n>>> [name for name, member in Shape.__members__.items() if member.name != name]\n['ALIAS_FOR_SQUARE']\n枚举比较(后两种不适用于IntEnum)\n>>> Color.RED is Color.RED\nTrue\n\n>>> Color.RED == Color.BLUE\nFalse\n\n>>> Color.RED < Color.BLUE\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: '<' not supported between instances of 'Color' and 'Color'\n\n>>> Color.BLUE == 6 # 与非枚举的值进行等值比较总是返回False\nFalse\n允许的枚举成员与属性\n枚举是python类，也可以拥有普通方法和特殊方法：\nclass Mood(Enum):\n    FUNKY = 1\n    HAPPY = 3\n\n    def describe(self):\n        # self is the member here\n        return self.name, self.value\n\n    def __str__(self):\n        return 'my custom str! {0}'.format(self.value)\n\n    @classmethod\n    def favorite_mood(cls):\n        # cls here is the enumeration\n        return cls.HAPPY\n注意点：如果枚举中定义了__new()__或者__init__()方法，赋值给枚举成员的值将被传递到__new()__或者__init__()中\n枚举的继承限制\n自定义枚举类必须继承自一个枚举基类，至多一个具体的数据类型以及0至多个混合类。继承顺序如下：\nclass EnumName([mix-in, ...,] [data-type,] base-enum):\n    pass\n基类枚举如果已经定义了成员，则不能被任何子类继承，如下第一种是不允许的，但第二种可以：\n>>> class MoreColor(Color):\n...     PINK = 17\n...\nTraceback (most recent call last):\n...\nTypeError: Cannot extend enumerations\n>>> class Foo(Enum):\n...     def some_behavior(self):\n...         pass\n...\n>>> class Bar(Foo):\n...     HAPPY = 1\n...     SAD = 2\n...\n不能这么做的原因是可能破坏某些重要的不允许改变的值(原话是would lead to a violation of some important invariants of bytes and instances)。\n序列化\n>>> from a.b import Color\n>>> from pickle import dumps, loads\n>>> Color.RED is loads(dumps(Color.RED))\nTrue\n一般要求序列化的枚举要定义在模块顶层，因为反序列化要求枚举能够从模块导入。不过在第4版的pickle协议中，已经可以序列化嵌套在类中的枚举\n通过在枚举中定义__reduce_ex__()方法，可以修改枚举成员的序列化/反序列化行为\nFunctional API\n枚举类是可调用的：\n>>> Animal = Enum(\"Pet\", \"Tortoise CAT DOG\")\n完整的API如下：Enum(value='NewEnumName', names=<...>, *, module='...', qualname='...', type=<mixed-in class>, start=1)\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}