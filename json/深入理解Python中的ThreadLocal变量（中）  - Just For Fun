{"title": "深入理解Python中的ThreadLocal变量（中）  - Just For Fun ", "index": "thread,python", "content": "在 深入理解Python中的ThreadLocal变量（上） 中我们看到 ThreadLocal 的引入，使得可以很方便地在多线程环境中使用局部变量。如此美妙的功能到底是怎样实现的？如果你对它的实现原理没有好奇心或一探究竟的冲动，那么接下来的内容估计会让你后悔自己的浅尝辄止了。\n简单来说，Python 中 ThreadLocal 就是通过下图中的方法，将全局变量伪装成线程局部变量，相信读完本篇文章你会理解图中内容的。（对这张图不眼熟的话，可以回顾下上篇)）。\n\n在哪里找到源码？\n好了，终于要来分析 ThreadLocal 是如何实现的啦，不过，等等，怎么找到它的源码呢？上一篇中我们只是用过它（from threading import local），从这里只能看出它是在 threading 模块实现的，那么如何找到 threading 模块的源码呢。\n如果你在使用 PyCharm，恭喜你，你可以用 View source（OS X 快捷键是 ⌘↓）找到 local 定义的地方。现在许多 IDE 都有这个功能，可以查看 IDE 的帮助来找到该功能。接着我们就会发现 local 是这样子的（这里以 python 2.7 为例）：\n# get thread-local implementation, either from the thread\n# module, or from the python fallback\ntry:\n    from thread import _local as local\nexcept ImportError:\n    from _threading_local import local\n嗯，自带解释，非常好。我们要做的是继续往下深挖具体实现，用同样的方法（⌘↓）找 _local 的实现，好像不太妙，没有找到纯 python 实现：\nclass _local(object):\n    \"\"\" Thread-local data \"\"\"\n    def __delattr__(self, name): # real signature unknown; restored from __doc__\n        \"\"\" x.__delattr__('name') <==> del x.name \"\"\"\n        pass\n    ...\n没关系，继续来看下_threading_local吧，这下子终于找到了local的纯 python 实现。开始就是很长的一段注释文档，告诉我们这个模块是什么，如何用。这个文档的质量非常高，值得我们去学习。所以，再次后悔自己的浅尝辄止了吧，差点错过了这么优秀的文档范文！\n将源码私有化\n在具体动手分析这个模块之前，我们先把它拷出来放在一个单独的文件 thread_local.py 中，这样可以方便我们随意肢解它（比如在适当的地方加上log），并用修改后的实现验证我们的一些想法。此外，如果你真的理解了_threading_local.py最开始的一段，你就会发现这样做是多么的有必要。因为python的threading.local不一定是用的_threading_local（还记得class _local(object) 吗？）。\n所以如果你用 threading.local 来验证自己对_threading_local.py的理解，你很可能会一头雾水的。不幸的是，我开始就这样干的，所以被下面的代码坑了好久：\nfrom threading import local, current_thread\ndata = local()\nkey = object.__getattribute__(data, '_local__key') \nprint current_thread().__dict__.get(key)\n# AttributeError: 'thread._local' object has no attribute '_local__key'\n当然，你可能不理解这里是什么意思，没关系，我只是想强调在 threading.local 没有用到_threading_local.py，你必须要创建一个模块（我将它命名为 thread_local.py）来保存_threading_local里面的内容，然后像下面这样验证自己的想法：\nfrom threading import current_thread\nfrom thread_local import local\n\ndata = local()\nkey = object.__getattribute__(data, '_local__key')\nprint current_thread().__dict__.get(key)\n如何去理解源码\n现在可以静下心来读读这不到两百行的代码了，不过，等等，好像有许多奇怪的内容（黑魔法）：\n\n__slots__\n__new__\n__getattribute__／__setattr__／__delattr__\nRlock\n\n这些是什么？如果你不知道，没关系，千万不要被这些纸老虎吓到，我们有丰富的文档，查文档就对了（这里不建议直接去网上搜相关关键字，最好是先读文档，读完了有疑问再去搜）。\npython 黑魔法\n下面是我对上面提到的内容的一点总结，如果觉得读的明白，那么可以继续往下分析源码了。如果还有不理解的，再读几遍文档（或者我错了，欢迎指出来）。\n\n简单来说，python 中创建一个新式类的实例时，首先会调用__new__(cls[, ...])创建实例，如果它成功返回cls类型的对象，然后才会调用__init__来对对象进行初始化。\n新式类中我们可以用__slots__指定该类可以拥有的属性名称，这样每个对象就不会再创建__dict__，从而节省对象占用的空间。特别需要注意的是，基类的__slots__并不会屏蔽派生类中__dict__的创建。\n可以通过重载__setattr__，__delattr__和__getattribute__这些方法，来控制自定义类的属性访问（x.name），它们分别对应属性的赋值，删除，读取。\n锁是操作系统中为了保证操作原子性而引入的概念，python 中 RLock是一种可重入锁（reentrant lock，也可以叫作递归锁），Rlock.acquire()可以不被阻塞地多次进入同一个线程。\n__dict__用来保存对象的（可写）属性，可以是一个字典，或者其他映射对象。\n\n源码剖析\n对这些相关的知识有了大概的了解后，再读源码就亲切了很多。为了彻底理解，我们首先回想下平时是如何使用local对象的，然后分析源码在背后的调用流程。这里从定义一个最简单的thread-local对象开始，也就是说当我们写下下面这句时，发生了什么？\ndata = local()\n上面这句会调用 _localbase.__new__ 来为data对象设置一些属性（还不知道有些属性是做什么的，不要怕，后面遇见再说），然后将data的属性字典(__dict__)作为当前线程的一个属性值（这个属性的 key 是根据 id(data) 生成的身份识别码）。\n这里很值得玩味：在创建ThreadLocal对象时，同时在线程（也是一个对象，没错万物皆对象）的属性字典__dict__里面保存了ThreadLocal对象的属性字典。还记得文章开始的图片吗，红色虚线就表示这个操作。\n接着我们考虑在线程 Thread-1 中对ThreadLocal变量进行一些常用的操作，比如下面的一个操作序列：\ndata.name = \"Thread 1(main)\" # 调用 __setattr__\nprint data.name     # 调用 __getattribute__\ndel data.name       # 调用 __delattr__\nprint data.__dict__\n# Thread 1(main)\n# {}\n那么背后又是如何操作的呢？上面的操作包括了给属性赋值，读属性值，删除属性。这里我们以__getattribute__的实现为例（读取值）进行分析，属性的__setattr__和__delattr__和前者差不多，区别在于禁止了对__dict__属性的更改以及删除操作。\ndef __getattribute__(self, name):\n    lock = object.__getattribute__(self, '_local__lock')\n    lock.acquire()\n    try:\n        _patch(self)\n        return object.__getattribute__(self, name)\n    finally:\n        lock.release()\n函数中首先获得了ThreadLocal变量的_local__lock属性值（知道这个变量从哪里来的吗，回顾下_localbase吧），然后用它来保证 _patch(self) 操作的原子性，还用 try-finally 保证即使抛出了异常也会释放锁资源，避免了线程意外情况下永久持有锁而导致死锁。现在问题是_patch究竟做了什么？答案还是在源码中：\ndef _patch(self):\n    key = object.__getattribute__(self, '_local__key')  # ThreadLocal变量 的标识符\n    d = current_thread().__dict__.get(key)  # ThreadLocal变量在该线程下的数据\n    if d is None:\n        d = {}\n        current_thread().__dict__[key] = d\n        object.__setattr__(self, '__dict__', d)\n\n        # we have a new instance dict, so call out __init__ if we have one\n        cls = type(self)\n        if cls.__init__ is not object.__init__:\n            args, kw = object.__getattribute__(self, '_local__args')\n            cls.__init__(self, *args, **kw)\n    else:\n        object.__setattr__(self, '__dict__', d)\n_patch做的正是整个ThreadLocal实现中最核心的部分，从当前正在执行的线程对象那里拿到该线程的私有数据，然后将其交给ThreadLocal变量，就是本文开始图片中的虚线2。这里需要补充说明以下几点：\n\n这里说的线程的私有数据，其实就是指通过x.name可以拿到的数据（其中 x 为ThreadLocal变量）\n主线程中在创建ThreadLocal对象后，就有了对应的数据（还记得红色虚线的意义吗？）\n对于那些第一次访问ThreadLocal变量的线程来说，需要创建一个空的字典来保存私有数据，然后还要调用该变量的初始化函数。\n还记得_localbase基类里__new__函数设置的属性   _local__args 吗？在这里被用来进行初始化。\n\n到此，整个源码核心部分已经理解的差不多了，只剩下local.__del__用来执行清除工作。因为每次创建一个ThreadLocal 变量，都会在进程对象的__dict__中添加相应的数据，当该变量被回收时，我们需要在相应的线程中删除保存的对应数据。\n从源码中学到了什么？\n经过一番努力，终于揭开了 ThreadLocal 的神秘面纱，整个过程可以说是收获颇丰，下面一一说来。\n不得不承认，计算机基础知识很重要。你得知道进程、线程是什么，CPU 的工作机制，什么是操作的原子性，锁是什么，为什么锁使用不当会导致死锁等等。\n其次就是语言层面的知识也必不可少，就ThreadLocal的实现来说，如果对__new__，__slots__等不了解，根本不知道如何去做。所以，学语言还是要有深度，不然下面的代码都看不懂：\nclass dict_test:\n    pass\n\nd = dict_test()\nprint d.__dict__\nd.__dict__ = {'name': 'Jack', 'value': 12}\nprint d.name\n还有就是高质量的功能实现需要考虑各方各面的因素，以ThreadLocal 为例，在基类_localbase中用__slots__节省空间，用try_finally保证异常环境也能正常释放锁，最后还用__del__来及时的清除无效的信息。\n最后不得不说，好的文档和注释简直就是画龙点睛，不过写文档和注释是门技术活，绝对需要不断学习的。\n更多阅读\nPython's use of __new__ and __init__?  Understanding __new__ and __init__  Usage of __slots__?  weakref – Garbage-collectable references to objects  How do I find the source code of a function in Python?  How do I find the location of Python module sources?  Is self.__dict__.update(**kwargs) good or poor style?  Doc: weakref — Weak references  python class 全面分析\n我是如何阅读开源项目的源代码的  高效阅读源代码指南  如何阅读程序源代码？  如何看懂源代码--(分析源代码方法)\n本文由selfboot 发表于个人博客，采用署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议。非商业转载请注明作者及出处。商业转载请联系作者本人本文标题为：深入理解Python中的ThreadLocal变量（中）本文链接为：http://selfboot.cn/2016/08/26...\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "6"}