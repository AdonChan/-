{"title": "PyTips 0x17-Python 中的枚举类型 - PyTips ", "index": "pytips,python3.5,python", "content": "Python 中的枚举类型\n枚举类型可以看作是一种标签或是一系列常量的集合，通常用于表示某些特定的有限集合，例如星期、月份、状态等。Python 的原生类型（Built-in types）里并没有专门的枚举类型，但是我们可以通过很多方法来实现它，例如字典、类等：\nWEEKDAY = {\n    'MON': 1,\n    'TUS': 2,\n    'WEN': 3,\n    'THU': 4,\n    'FRI': 5\n}\nclass Color:\n    RED   = 0\n    GREEN = 1\n    BLUE  = 2\n上面两种方法可以看做是简单的枚举类型的实现，如果只在局部范围内用到了这样的枚举变量是没有问题的，但问题在于它们都是可变的（mutable），也就是说可以在其它地方被修改从而影响其正常使用：\nWEEKDAY['MON'] = WEEKDAY['FRI']\nprint(WEEKDAY)\n{'FRI': 5, 'TUS': 2, 'MON': 5, 'WEN': 3, 'THU': 4}\n\n通过类定义的枚举甚至可以实例化，变得不伦不类：\nc = Color()\nprint(c.RED)\nColor.RED = 2\nprint(c.RED)\n0\n2\n\n当然也可以使用不可变类型（immutable），例如元组，但是这样就失去了枚举类型的本意，将标签退化为无意义的变量：\nCOLOR = ('R', 'G', 'B')\nprint(COLOR[0], COLOR[1], COLOR[2])\nR G B\n\n为了提供更好的解决方案，Python 通过 PEP 435 在 3.4 版本中添加了 enum 标准库，3.4 之前的版本也可以通过 pip install enum 下载兼容支持的库。enum 提供了 Enum/IntEnum/unique 三个工具，用法也非常简单，可以通过继承 Enum/IntEnum 定义枚举类型，其中 IntEnum 限定枚举成员必须为（或可以转化为）整数类型，而 unique 方法可以作为修饰器限定枚举成员的值不可重复：\nfrom enum import Enum, IntEnum, unique\n\ntry:\n    @unique\n    class WEEKDAY(Enum):\n        MON = 1\n        TUS = 2\n        WEN = 3\n        THU = 4\n        FRI = 1\nexcept ValueError as e:\n    print(e)\nduplicate values found in <enum 'WEEKDAY'>: FRI -> MON\n\ntry:\n    class Color(IntEnum):\n        RED   = 0\n        GREEN = 1\n        BLUE  = 'b'\nexcept ValueError as e:\n    print(e)\ninvalid literal for int() with base 10: 'b'\n\n更有趣的是 Enum 的成员均为单例（Singleton），并且不可实例化，不可更改：\nclass Color(Enum):\n    R = 0\n    G = 1\n    B = 2\ntry:\n    Color.R = 2\nexcept AttributeError as e:\n    print(e)\nCannot reassign members.\n\n虽然不可实例化，但可以将枚举成员赋值给变量：\nred = Color(0)\ngreen = Color(1)\nblue = Color(2)\nprint(red, green, blue)\nColor.R Color.G Color.B\n\n也可以进行比较判断：\nprint(red is Color.R)\nprint(red == Color.R)\nprint(red is blue)\nprint(green != Color.B)\nprint(red == 0) # 不等于任何非本枚举类的值\nTrue\nTrue\nFalse\nTrue\nFalse\n\n最后一点，由于枚举成员本身也是枚举类型，因此也可以通过枚举成员找到其它成员：\nprint(red.B)\nprint(red.B.G.R)\nColor.B\nColor.R\n\n但是要谨慎使用这一特性，因为可能与成员原有的命名空间中的名称相冲突：\nprint(red.name, ':', red.value)\n\nclass Attr(Enum):\n    name  = 'NAME'\n    value = 'VALUE'\nprint(Attr.name.value, Attr.value.name)\nR : 0\nNAME value\n\n总结\nenum 模块的用法很简单，功能也很明确，但是其实现方式却非常值得学习。如果你想更深入了解更多 Python 中关于 Class 和 Metaclass 的黑魔法，又不知道如何入手，那么不妨阅读一下 enum 的源码，或者关注接下来后面几篇的内容！\n\n欢迎关注公众号 PyHub 每日推送\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "3"}