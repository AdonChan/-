{"title": "python学习笔记    序列 - 个人文章 ", "index": "python,python3.x", "content": "内置序列\n容器序列\nlist, tuple, collections.deque等这些序列能存放不同类型的数据\n扁平序列\nstr, byte, bytearray, memoryview, array.array, 这些序列只能容纳一种类型数据\n以上，容器序列存放的是他们所含任意类型对象的引用，而扁平序列存放的是值而不是引用\n列表（list）是最基础也是最重要的序列类型\n列表推导\n>>> symbols = '中华人民共和国'\n>>> codes = [ord(symbol) for symbol in symbols]\n>>> codes\n[20013, 21326, 20154, 27665, 20849, 21644, 22269]\n列表推导由for循环变换而来，增强可读性的同时，也使得代码更加简洁\npython会忽略代码里[]/()/{}中的换行，在其中可以省略续行符 \"\\\" \n生成器表达式\n生成器的语法和列表推导差不多，只是把方括号换成圆括号\n>>> symbols = '中华人民共和国'\n>>> tuple(ord(symbol) for symbol in symbols)\n(20013, 21326, 20154, 27665, 20849, 21644, 22269)\n>>> import array\n>>> array.array('I', (ord(symbol) for symbol in symbols))\narray('I', [20013, 21326, 20154, 27665, 20849, 21644, 22269])\n(1) 如果生成器表达式是一个函数唯一的参数，那么这个参数不需要额外的括号(2) array的构造方法需要两个参数，所以生成器表达式需要被括号围起来\nlist.sort方法和内置函数sorted\n\nlist.sort 方法的功能是将序列就地排序，即不会重新创建一个数组，将原数组复制过来\n与list.sort不同的是，序列的内置函数sorted的功能虽然也是排序，但是会重新创建一个数组，不会对原数组做任何改动\n\n>>> fruits = ['grape', 'respberry', 'apple', 'banana']\n>>> sorted(fruits)\n['apple', 'banana', 'grape', 'respberry']\n>>> fruits\n['grape', 'respberry', 'apple', 'banana']\n>>> sorted(fruits, key=len)\n['grape', 'apple', 'banana', 'respberry']\n>>> sorted(fruits, key=len, reverse=True)\n['respberry', 'banana', 'grape', 'apple']\n>>> fruits\n['grape', 'respberry', 'apple', 'banana']\n>>> fruits.sort()\n>>> fruits\n['apple', 'banana', 'grape', 'respberry']\n由以上的例子可以看出两者的差别，而sorted函数还接受key, reverse两个参数其中，参数key表示比较的标准，而reverse表示是否要逆序（True）\n利用bisect管理有序序列\n利用bisect进行搜索\n函数bisect(haystack, needle)可实现在haystack（干草堆，一个有序序列）中找到needle（针）的位置，该位置满足的条件是，把needle插入该函数所搜索到的位置后，整个haystack依然保持有序\nimport bisect\nimport sys\nimport random\n\n\nhaystack = [1, 4, 5, 6, 8, 12, 15, 20, 21, 23, 23, 26, 29, 30]\nneedles = [0, 1, 2, 5, 8, 10, 22, 23, 29, 30, 31]\nrow_fmt = '{0:2d} @ {1:2d}    {2}{0:<2d}'\n\n\ndef demo(bisect_fn):\n    for needle in reversed(needles):\n        position = bisect_fn(haystack, needle)\n        offset = position * ' |'\n        print(row_fmt.format(needle, position, offset))\n\n\nif __name__ == '__main__':\n\n    if sys.argv[-1] == 'left':\n        bisect_fn = bisect.bisect_left\n    else:\n        bisect_fn = bisect.bisect_right\n\n    print('Demo: ', bisect_fn.__name__)\n    print('haystack ->', ''.join('%2d' % n for n in haystack))\n    demo(bisect_fn)\n\n\n\n    print(\"\\n\\n#################insort###############\")\n    size = 7\n    # random.seed(1729)\n    my_list = []\n    for i in range(7):\n        new_item = random.randrange(size * 2)\n        bisect.insort(my_list, new_item)\n        print('%2d ->' % new_item, my_list)\n        \n    #############运行结果################\nDemo:  bisect_right\nhaystack ->  1 4 5 6 8121520212323262930\n31 @ 14     | | | | | | | | | | | | | |31\n30 @ 14     | | | | | | | | | | | | | |30\n29 @ 13     | | | | | | | | | | | | |29\n23 @ 11     | | | | | | | | | | |23\n22 @  9     | | | | | | | | |22\n10 @  5     | | | | |10\n 8 @  5     | | | | |8\n 5 @  3     | | |5\n 2 @  1     |2\n 1 @  1     |1\n 0 @  0    0\n\n\n#################insort###############\n 9 -> [9]\n 7 -> [7, 9]\n 1 -> [1, 7, 9]\n 4 -> [1, 4, 7, 9]\n 5 -> [1, 4, 5, 7, 9]\n12 -> [1, 4, 5, 7, 9, 12]\n 5 -> [1, 4, 5, 5, 7, 9, 12]\n*bisect其实是bisect_rihght函数的缩写，其返回的插入位置是原始序列与被插入元素相等元素位置的  右边  ，该函数还有一个姊妹函数bisect_left，其返回的插入位置是原始序列与被插入元素相等元素位置的  左边  \n书中还有推荐一个网站 Python Tutor ， 是一个对python运行原理进行可视化分析的工具。\n  注：   以上内容主体均来自于《流畅的python》书中第2章 序列构成的数组\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}