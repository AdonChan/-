{"title": "使用Python写一个小小的项目监控 - defshine ", "index": "monitor,python", "content": "在公司里做的一个接口系统，主要是对接第三方的系统接口，所以，这个系统里会和很多其他公司的项目交互。随之而来一个很蛋疼的问题，这么多公司的接口，不同公司接口的稳定性差别很大，访问量大的时候，有的不怎么行的接口就各种出错了。\n这个接口系统刚刚开发不久，整个系统中，处于比较边缘的位置，不像其他项目，有日志库，还有短信告警，一旦出问题，很多情况下都是用户反馈回来，所以，我的想法是，拿起python，为这个项目写一个监控。如果在调用某个第三方接口的过程中，大量出错了，说明这个接口有有问题了，就可以更快的采取措施。\n项目的也是有日志库的，所有的info，error日志都是每隔一分钟扫描入库，日志库是用的mysql，表里有几个特别重要的字段：\n\n\n  level  日志级别\n  message 日志内容\n  file_name Java代码文件\n  log_time  日志时间\n\n\n有日志库，就不用自己去线上环境扫日志分析了，直接从日志库入手。由于日志库在线上时每隔1分钟扫，那我就去日志库每隔2分钟扫一次，如果扫到有一定数量的error日志就报警，如果只有一两条错误就可以无视了，也就是短时间爆发大量错误日志，就可以断定系统有问题了。报警方式就用发送邮件，所以，需要做下面几件事情：\n1. 操作MySql。\n2. 发送邮件。\n3. 定时任务。\n4. 日志。\n5. 运行脚本。\n\n明确了以上几件事情，就可以动手了。\n\n操作数据库\n\n使用MySQLdb这个驱动，直接操作数据库，主要就是查询操作。\n获取数据库的连接：\n\npythondef get_con():\n    host = \"127.0.0.1\"\n    port = 3306\n    logsdb = \"logsdb\"\n    user = \"root\"\n    password = \"never tell you\"\n    con = MySQLdb.connect(host=host, user=user, passwd=password, db=logsdb, port=port, charset=\"utf8\")\n    return con\n\n\n从日志库里获取数据，获取当前时间之前2分钟的数据，首先，根据当前时间进行计算一下时间。之前，计算有问题，现在已经修改，谢谢一楼wade305朋友指正～\n\npythondef calculate_time():\n\n    now = time.mktime(datetime.now().timetuple())-60*2\n    result = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(now))\n    return result\n\n\n\n然后，根据时间和日志级别去日志库查询数据\n\npythondef get_data():\n    select_time = calculate_time()\n    logger.info(\"select time:\"+select_time)\n    sql = \"select file_name,message from logsdb.app_logs_record \" \\\n          \"where log_time >\"+\"'\"+select_time+\"'\" \\\n          \"and level=\"+\"'ERROR'\" \\\n          \"order by log_time desc\"\n    conn = get_con()\n\n    cursor = conn.cursor()\n    cursor.execute(sql)\n    results = cursor.fetchall()\n\n    cursor.close()\n    conn.close()\n\n    return results\n\n\n发送邮件\n\n使用python发送邮件比较简单，使用标准库smtplib就可以\n这里使用163邮箱进行发送，你可以使用其他邮箱或者企业邮箱都行，不过host和port要设置正确。\n\npythondef send_email(content):\n\n    sender = \"sender_monitor@163.com\"\n    receiver = [\"rec01@163.com\", \"rec02@163.com\"]\n    host = 'smtp.163.com'\n    port = 465\n    msg = MIMEText(content)\n    msg['From'] = \"sender_monitor@163.com\"\n    msg['To'] = \"rec01@163.com,rec02@163.com\"\n    msg['Subject'] = \"system error warning\"\n\n    try:\n        smtp = smtplib.SMTP_SSL(host, port)\n        smtp.login(sender, '123456')\n        smtp.sendmail(sender, receiver, msg.as_string())\n        logger.info(\"send email success\")\n    except Exception, e:\n        logger.error(e)\n\n\n定时任务\n\n使用一个单独的线程，每2分钟扫描一次，如果ERROR级别的日志条数超过5条，就发邮件通知。\n\npythondef task():\n    while True:\n        logger.info(\"monitor running\")\n\n        results = get_data()\n        if results is not None and len(results) > 5:\n            content = \"recharge error：\"\n            logger.info(\"a lot of error,so send mail\")\n            for r in results:\n                content += r[1]+'\\n'\n            send_email(content)\n        sleep(2*60)\n\n\n日志\n\n为这个小小的脚本配置一下日志log.py，让日志可以输出到文件和控制台中。\n\npython# coding=utf-8\nimport logging\n\nlogger = logging.getLogger('mylogger')\nlogger.setLevel(logging.DEBUG)\n\nfh = logging.FileHandler('monitor.log')\nfh.setLevel(logging.INFO)\n\nch = logging.StreamHandler()\nch.setLevel(logging.INFO)\n\nformatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nfh.setFormatter(formatter)\nch.setFormatter(formatter)\n\nlogger.addHandler(fh)\nlogger.addHandler(ch)\n\n\n所以，最后，这个监控小程序就是这样的app_monitor.py\n\npython# coding=utf-8\nimport threading\nimport MySQLdb\nfrom datetime import datetime\nimport time\nimport smtplib\nfrom email.mime.text import MIMEText\nfrom log import logger\n\n\ndef get_con():\n    host = \"127.0.0.1\"\n    port = 3306\n    logsdb = \"logsdb\"\n    user = \"root\"\n    password = \"never tell you\"\n    con = MySQLdb.connect(host=host, user=user, passwd=password, db=logsdb, port=port, charset=\"utf8\")\n    return con\n\n\ndef calculate_time():\n\n    now = time.mktime(datetime.now().timetuple())-60*2\n    result = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(now))\n    return result\n\n\ndef get_data():\n    select_time = calculate_time()\n    logger.info(\"select time:\"+select_time)\n    sql = \"select file_name,message from logsdb.app_logs_record \" \\\n          \"where log_time >\"+\"'\"+select_time+\"'\" \\\n          \"and level=\"+\"'ERROR'\" \\\n          \"order by log_time desc\"\n    conn = get_con()\n\n    cursor = conn.cursor()\n    cursor.execute(sql)\n    results = cursor.fetchall()\n\n    cursor.close()\n    conn.close()\n\n    return results\n\n\ndef send_email(content):\n\n    sender = \"sender_monitor@163.com\"\n    receiver = [\"rec01@163.com\", \"rec02@163.com\"]\n    host = 'smtp.163.com'\n    port = 465\n    msg = MIMEText(content)\n    msg['From'] = \"sender_monitor@163.com\"\n    msg['To'] = \"rec01@163.com,rec02@163.com\"\n    msg['Subject'] = \"system error warning\"\n\n    try:\n        smtp = smtplib.SMTP_SSL(host, port)\n        smtp.login(sender, '123456')\n        smtp.sendmail(sender, receiver, msg.as_string())\n        logger.info(\"send email success\")\n    except Exception, e:\n        logger.error(e)\n\n\ndef task():\n    while True:\n        logger.info(\"monitor running\")\n        results = get_data()\n        if results is not None and len(results) > 5:\n            content = \"recharge error：\"\n            logger.info(\"a lot of error,so send mail\")\n            for r in results:\n                content += r[1]+'\\n'\n            send_email(content)\n        time.sleep(2*60)\n\n\ndef run_monitor():\n    monitor = threading.Thread(target=task)\n    monitor.start()\n\n\nif __name__ == \"__main__\":\n    run_monitor()\n\n\n运行脚本\n\n脚本在服务器上运行，使用supervisor进行管理。\n在服务器（centos6）上安装supervisor，然后在/etc/supervisor.conf中加入一下配置\n\nbash[program:app-monitor]\ncommand = python /root/monitor/app_monitor.py\ndirectory = /root/monitor\nuser = root\n\n\n然后在终端中运行supervisord启动supervisor。\n在终端中运行supervisorctl，进入shell，运行status查看脚本的运行状态。\n\n总结\n\n这个小监控思路很清晰，还可以继续修改，比如：监控特定的接口，发送短信通知等等。\n因为有日志库，就少了去线上正式环境扫描日志的麻烦，所以，如果没有日志库，就要自己上线上环境扫描，在正式线上环境一定要小心哇～\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "20"}