{"title": "量化交易之股票买卖因子——单均线突破 - Python量化交易 ", "index": "python", "content": "前言\n量化系统一般分为回测模块和实盘模块，回测模块即是交易者先编写一个交易策略，基于一段历史股票数据进行模拟买入卖出，验证交易策略的可行性。实盘模块即是将回测通过的策略应用于每天的实时交易中，进行真实的买入卖出操作。本文通过JoinQuant聚宽平台上的一个基础策略案例以自有方式再次实现，来介绍下一般量化交易系统实现的原理和流程。\n\n聚宽策略回测\n聚宽平台基础的交易策略为：若昨日收盘价高出过去20日平均价今天开盘买入股票；若昨日收盘价低于过去20日平均价今天开盘卖出股票。将该策略应用在高鸿股份从17年1月至今的历史数据上进行回测，初始资金设置为100000，回测频率为每天，执行的回测效果如下。红色基准收益曲线为该策略应用在指数上回测的收益曲线，那么从对比上来看该策略并不满足盈利能力，仍然需要继续改进。产生区别的根本原因即是高鸿股份今年跑输了指数，才导致同样的策略下股票收益低于基准收益，可见选股作为量化交易的一部分也十分重要。\n\n策略自实现\n聚宽平台实现的代码中导入了jqdata库，该库是聚宽在Python基础库和部分第三方库的基础上进行了高级的API封装，但该库依赖于聚宽平台，因此下面通过Python开源库来进行策略的再实现。（1）创建两幅子图分别用于显示操作情况和收益情况，并且调整子图的边框位置。\nplt.figure(figsize=(25,12), dpi=80, facecolor=\"white\")\np1 = plt.subplot(2,1,1)\np1 = plt.subplot(2,1,2)      \nplt.subplots_adjust(left=None, bottom=None, right=None, top=None, wspace=0, hspace=0.25)\n\n（2）计算二十日移动平均线价格，以及买卖位置，即收盘价高于M20移动平均线买入，反之卖出。\nstock_df['Ma20'] = pd.rolling_mean(stock_df.Close,window=20)#增加M20移动平均线       \nlist_diff = np.sign(stock_df.Close-stock_df.Ma20)\nstock_df['signal'] = np.sign(list_diff-list_diff.shift(1))\n\n（3）计算收益曲线，此处初始资金为10万元，买点出现时全部资金以收盘价买入，卖点出现时仓位全部以收盘价抛出，暂不考虑滑点。买入股票后资金转为市值，卖出股票后市值转为资金，总体收益为两者之一的序列。\nself.cash_hold = 100000#初始资金\nself.posit_num = 0#持股数目\nself.market_total = 0#持股市值 \nfor kl_index,today in stock_df.iterrows():\n    if today.signal > 0:# 买入    \n        start = stock_df.index.get_loc(kl_index)\n        self.skip_days = -1\n        self.posit_num = int(self.cash_hold/today.Close)\n        self.cash_hold = 0 \n    elif today.signal < 0:# 卖出 \n        if self.skip_days == -1:#避免未买先卖\n            end = stock_df.index.get_loc(kl_index)\n            self.skip_days = 0\n            self.cash_hold = int(self.posit_num*today.Close)\n            self.market_total = 0\n            if stock_df.Close[end] < stock_df.Close[start]:#赔钱显示绿色\n                plt.fill_between(stock_df.index[start:end],0,stock_df.Close[start:end],color='green',alpha=0.38)\n            else:#赚钱显示绿色                 \n                plt.fill_between(stock_df.index[start:end],0,stock_df.Close[start:end],color='red',alpha=0.38)\n    if self.skip_days == -1:\n        self.market_total = int(self.posit_num*today.Close)\n        self.profit_curve.append(self.market_total)\n    else:\n        self.profit_curve.append(self.cash_hold)\n\n注：迭代DataFrame.iterrows()时返回DataFrame每行的index和Series序列，不能保留值的类型（需要保留每个元素类型是可使用itertuples()替代）\n（4）显示效果如下。从收益曲线上可以看出应用该策略的话今年是严重亏损的，那么我们需要再调整下策略。（5）将指示短线操作的20日均线更换成指示中长线操作的生命线M60日均线作为策略因子进行回测。显示效果如下，从收益曲线上可以看出目前应用该策略是获利的，但是并不能证明该策略在其他股票上就能获利，因此我们仍然需要不断的去优化策略。\n更多python量化交易内容互动请加微信公众号：PythonQT-YuanXiao\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "4"}