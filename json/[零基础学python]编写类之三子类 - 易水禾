{"title": "[零基础学python]编写类之三子类 - 易水禾 ", "index": "零基础,python", "content": "关于类，看官想必已经有了感觉，看下面的代码，请仔细阅读，并看看是否能够发现点什么问题呢？\n\n#!/usr/bin/env python\n#coding:utf-8\n\nclass Person:\n    def __init__(self, name, lang, email):\n        self.name = name\n        self.lang = lang\n        self.email = email\n\n    def author(self):\n        return self.name\n\nclass Programmer:\n    def __init__(self, name, lang, email, system, website):\n        self.name = name\n        self.lang = lang\n        self.email = email\n        self.system = system\n        self.website = website\n\n    def pythoner(self):\n        pythoner_list = [ self.name, self.lang, self.email, self.system, self.website ]\n        return pythoner_list\n\nif __name__==\"__main__\":\n    writer = Person(\"qiwsir\",\"Chinese\",\"qiwsir@gmail.com\")\n    python = Programmer(\"qiwsir\",\"Python\",\"qiwsir@gmail.com\",\"Ubutun\",\"qiwsir.github.io\")\n    print \"My name is:%s\"%writer.author()\n    print \"I write program by:%s\"%python.pythoner()[1]\n\n\n上面这段代码，运行起来没有什么问题，但是，仔细看，发现有两个类，一个名字叫做Person，另外一个叫做Programmer，这还不是问题所在，问题所在是这两个类的构造函数中，存在这相同的地方：self.name=name,self.lang=lang,self.email=email，这对于追求代码质量的程序员，一般是不允许的。最好不要有重复代码或者冗余代码。可是，在两个类中都要有这些参数，应该怎么办呢？\n\n子类、父类和继承\n\n看下面的代码，里面有两个类A，B。这段程序能够正确运行，每个类的功能是仅仅打印指定的内容。\n\n#!/usr/bin/env python\n#coding:utf-8\n\nclass A:\n    def __init__(self):\n        print \"aaa\"\n\nclass B:\n    def __init__(self):\n        print \"bbb\"\n\nif __name__==\"__main__\":\n    a = A()\n    b = B()\n\n#运行结果\naaa\nbbb\n\n\n上面的两个类彼此之间没有所谓的父子关系。现在稍加改变，将类B改写，注意观察与上面的差异。\n\n#!/usr/bin/env python\n#coding:utf-8\n\nclass A:\n    def __init__(self):\n        print \"aaa\"\n\nclass B(A):         #这里和上面程序不同。B继承了A\n    def __init__(self):\n        print \"bbb\"\n\nif __name__==\"__main__\":\n    a = A()\n    b = B()\n\n#运行结果\naaa\nbbb\n\n\n这段程序中，类B跟前面的那段有一点不同，class B(A):,这样写就表明了B相对A的关系：B是A的子类，B从A继承A的所有东西（子承父业）。\n\n但是，看官发现了没有，运行结果一样。是的，那是以为在B中尽管继承了A，但是没有调用任何A的东西，就好比儿子从老爸那里继承了财富，但是儿子一个子也没动，外界看到的和没有继承一样。\n\n#!/usr/bin/env python\n#coding:utf-8\n\nclass A:\n    def __init__(self):\n        print \"aaa\"\n\nclass B(A):\n    def __init__(self):\n        #print \"bbb\"\n        A.__init__(self)    #运行继承的父类\n\nif __name__==\"__main__\":\n    a = A()\n    b = B()\n\n#运行结果\naaa\naaa\n\n\n这回运行结果有了变化，本来b=B()是运行类B，但是B继承了A，并且在初始化的构造函数中，引入A的构造函数，所以，就运行A的结果相应结果了。\n\n下面把最开头的那端程序用子类继承的方式重写，可以是这样的：\n\n#!/usr/bin/env python\n#coding:utf-8\n\nclass Person:\n    def __init__(self, name, lang, email):\n        self.name = name\n        self.lang = lang\n        self.email = email\n\n    def author(self):\n        return self.name\n\"\"\"\nclass Programmer:\n    def __init__(self, name, lang, email, system, website):\n        self.name = name\n        self.lang = lang\n        self.email = email\n        self.system = system\n        self.website = website\n\n    def pythoner(self):\n        pythoner_list = [ self.name, self.lang, self.email, self.system, self.website ]\n        return pythoner_list\n\"\"\"\n\nclass Programmer(Person):       #继承父类Person\n    def __init__(self, name, lang, email, system, website):\n        Person.__init__(self,name,lang,email)   #将Person.__init__()的功能继承到这里\n        #self.name = name                       #这三句是Person中已经搞定的，就不用重复\n        #self.lang = lang                       #通过继承已经实现了这三句的功能\n        #self.email = email\n        self.system = system                    #子类中不同于Person父类部分\n        self.website = website\n\n    def pythoner(self):\n        pythoner_list = [ self.name, self.lang, self.email, self.system, self.website ]\n        return pythoner_list\n\nif __name__==\"__main__\":\n    writer = Person(\"qiwsir\",\"Chinese\",\"qiwsir@gmail.com\")\n    python = Programmer(\"qiwsir\",\"Python\",\"qiwsir@gmail.com\",\"Ubutun\",\"qiwsir.github.io\")\n    print \"My name is:%s\"%writer.author()\n    print \"I write program by:%s\"%python.pythoner()[1]\n\n\n代码运行结果与前面一样。\n\n列位是否理解了子类和父类、继承的特点。如果你有一个老爹，是一个高官或者富豪，那么你就官二代或者富二代了，你就从他们那里继承了很多财富，所以生活就不用太劳累了。这就是继承的作用。在代码中，也类似，继承能够让写代码的少劳累一些。\n\n对于为什么要用继承，好友@令狐虫 大侠给了以非常精彩的解释：\n\n\n  从技术上说，OOP里，继承最主要的用途是实现多 态。对于多态而言，重要的是接口继承性，属性和行为是否存在继承性，这是不一定的。事实上，大量工程实践表明，重度的行为继承会导致系统过度复杂和臃肿， 反而会降低灵活性。因此现在比较提倡的是基于接口的轻度继承理念。这种模型里因为父类（接口类）完全没有代码，因此根本谈不上什么代码复用了。\n\n\n\n  在Python里，因为存在Duck Type，接口定义的重要性大大的降低，继承的作用也进一步的被削弱了。\n\n\n\n  另外，从逻辑上说，继承的目的也不是为了复用代码，而是为了理顺关系。\n\n\n我表示完全赞同上述解释。不过看官如果不理解，也没有关系，上述解释中的精神，的确需要在编程实践中感悟才能领会到的。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "5"}