{"title": "python迭代器资料整理 - 愚钝的我 ", "index": "函数式编程,python", "content": "什么是迭代器\n相关概念定义\n迭代器（Iterator）：\n满足迭代协议的对象就是迭代器  iterator就是实现了Iteration Protocol的对象，这类对象都支持循环遍历的操作（for／while／支持迭代的函数list() sum()...）。\n迭代协议（Iteration Protocol）：\n内建函数iter()接收一个可迭代对象，并返回一个可迭代对象.  每次将这个可迭代对象传递给next()函数，都会返回它所包含的下一个元素，当迭代完最后一个元素时，就会触发StopIteration异常。\n>>> x = iter([1, 2, 3])\n>>> x\n<listiterator object at 0x1004ca850>\n>>> next(x)\n1\n>>> next(x)\n2\n>>> next(x)\n3\n>>> next(x)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nStopIteration\n满足以上要求的对象，就是迭代器。\n迭代隐含的操作\n在每次的迭代语句中，python都会按照迭代协议去对迭代器进行迭代。其实，在实际执行中，python会进行一些其他的操作：\n\n将需要迭代的对象作为参数传递给iter函数\niter返回一个迭代器对象\n每次循环则将返回的迭代器对象传递给next函数\n循环至最后一个元素，触发StopIteration\n\n以for语句为例：  当我们在Python中执行循环语句for i in foo的时候，其背后的操作是：\n\nfoo = iter(foo)\nnext(foo)\n\nnext(foo)在python3中执行的是：foo.__next__()，在python2中则是：foo.next()\n迭代器的实现\n迭代器是用class来实现的。其中必需实现的有两个方法：__iter__、next(python2)/__next__(python3)。其中，__iter__必需返回一个迭代器对象，next则负责迭代逻辑并在迭代完毕时触发异常。  \n如下：\ndef Iter(object)\n    def __init__(self):\n        pass\n    def __iter__(self):\n        pass\n    def __next__(self):    # python3\n        pass\n    def next(self):        # python2\n        pass\n\n迭代器的特殊情况\n迭代器的__iter__返回self\n\n迭代器的__iter__方法需要返回的是一个具有next方法的可迭代对象。如果当__iter__返回的是self的话，就会产生其他意想不到的效果。\nclass yrange:\n    def __init__(self, n):\n        self.i = 0\n        self.n = n\n\n    def __iter__(self):\n        return self\n\n    def next(self):\n        if self.i < self.n:\n            i = self.i\n            self.i += 1\n            return i\n        else:\n            raise StopIteration()\n            \nclass zrange:\n    def __init__(self, n):\n        self.i = 0\n        self.n = n\n\n    def __iter__(self):\n        return zrange(self.n)\n        \n    def next(self):\n        if self.i < self.n:\n            i = self.i\n            self.i += 1\n            return i\n        else:\n            raise StopIteration()\n执行结果：\n>>> y = yrange(5)\n>>> list(y)\n[0, 1, 2, 3, 4]\n>>> list(y)\n[]\n>>> z = zrange(5)\n>>> list(z)\n[0, 1, 2, 3, 4]\n>>> list(z)\n[0, 1, 2, 3, 4]\n在yrange中，iter返回的是self，在执行list(y)时iter返回的都是同一个self，所以再次调用list(y)时只会触发结束迭代异常，列表中并无内容。  而在zrange中，每次执行list(z)时，iter都是返回一个新的迭代器zrange(self.n)，所以每次执行list(z)都得到完整的元素。\n生成器的迭代\n通常，对于数据量特别大的序列，我们会用生成器generator来代替容器对象container，这样可以利用lazy evaluable来节省内存开销。值得注意的是，生成器也是一个只能迭代一次的迭代器。\ndef grange(n):\n    i = 0\n    while i < n:\n        yield i\n        i += 1\n执行结果：\n>>> glist = grange(10)\n>>> list(glist)\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n>>> list(glist)\n[]\n如果是利用便捷的生成器表达式也是一样：\n>>> alist = (i for i in range(10))\n>>> list(alist)\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n>>> list(alist)\n[]\n要解决这个问题，可以将迭代器和生成器组合使用：\nclass Grange(object):\n    def __init__(self, n):\n        self.n = n\n    \n    def __iter__(self):\n        for i in range(self.n):\n            yield i\n结果：\n>>> glist = Grange(10)\n>>> list(glist)\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n>>> list(glist)\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n值得注意的是，平常我们利用到生成器的地方都是数据量特别大的情况，这个时候，其实应该尽量避免多次迭代生成器。我想这应该也是python没有支持对生成器多次迭代的特性的原因。\n编程建议\n在实际的编程中，往往需要在函数中多次迭代一个序列，如果这个序列是调用API得到的，而你又不能保证它是没有陷阱的迭代器时。可以在遍历迭代器的时候，加入一个判断语句，避免无法多次迭代的情况发生：\ndef iterator_checker(iterator):\n    assert iter(iterator) is not iter(iterator), \"iter() return self\"\n参考资料\n\npython官网迭代器文档\npython practice book\n&lt;&lt;Effective Python&gt;&gt;\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "5"}