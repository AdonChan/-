{"title": "python模块之shutil - 个人文章 ", "index": "python", "content": "shutil模块提供了一些针对文件和目录的高级操作，主要是拷贝、移动。对于单个文件的操作，还可参考os模块\nWarning：即使是高级别的拷贝函数(shutil.copy(),shutil.copy2())也不能拷贝所有的文件元数据。意思是：在POSIX系统中，文件所有者、属组以及ACL信息会丢失。在Windows平台上，文件所有者，ACL以及ADS(供选数据流)不会被复制。On Mac OS, the resource fork and other metadata are not used. This means that resources will be lost and file type and creator codes will not be correct.\n目录及文件操作\nshutil.copyfileobj(fsrc, fdst[, length])\n复制file-like对象fsrc的内容到fdst，如果fdst不存在则自动创建。length表示缓冲大小，如果是负数表示直接复制，不循环遍历块中的源数据。数据默认按块读取(16 * 1024)避免不可控的内存消耗。\nimport shutil\n\nshutil.copyfileobj(open(\"fsrc.txt\", \"rb\"), open(\"fdst.txt\", \"wb\"))\nshutil.copyfile(src, dst, *, follow_symlinks=True)\n复制文件src的内容到dst并返回dst，如果dst不存在则自动创建。src和dst是字符串类型的路径名，如果src和dst指向同一个文件，抛出SameFileError异常。\n目标位置必须是可写的，否则将抛出OSError异常(实际抛出的是PermissionError)。如果dst已经存在，则直接覆盖。特殊文件比如块设备、字符设备、管道不能使用此函数复制。\n如果follow_symlinks为False且src是软链接，将创建一个新的软链接替代拷贝行为\nshutil.copyfile(\"src.txt\", \"dst.txt\")\nshutil.copymode(src, dst, *, follow_symlinks=True)\n复制文件src的权限位(permission bits)到dst，src和dst是字符串类型的路径名。如果follow_symlinks为False且src和dst都是软链接，将修改dst软链接文件而非源文件的权限。\n此函数并非所有平台可用，如果它不能修改本地平台的软链接但又执行了相关操作，将不做任何操作直接返回None\n# 修改前\n-rw-r--r--. 1 root  root    96 10月 11 12:26 aa.txt\n-rw-------. 1 root  root  1362 9月   6 22:07 anaconda-ks.cfg\n-rw-------. 1 admin admin    0 10月 11 12:53 bb.txt\nlrwxrwxrwx. 1 root  root    21 10月 11 12:58 cc.txt -> /root/anaconda-ks.cfg\n\n>>> shutil.copymode(\"aa.txt\", \"bb.txt\")\n>>> shutil.copymode(\"aa.txt\", \"cc.txt\")\n\n# 修改后\n-rw-r--r--. 1 root  root    96 10月 11 12:26 aa.txt\n-rw-r--r--. 1 root  root  1362 9月   6 22:07 anaconda-ks.cfg\n-rw-r--r--. 1 admin admin    0 10月 11 12:53 bb.txt\nlrwxrwxrwx. 1 root  root    21 10月 11 12:58 cc.txt -> /root/anaconda-ks.cfg\nshutil.copystat(src, dst, *, follow_symlinks=True)\n复制src的权限位、最后访问时间、最后修改时间以及标志(flag)到dst，src和dst是字符串类型的路径名，可以是文件或目录。在Linux平台上还会复制扩展属性。\n如果follow_symlinks为False，且src和dst都是软链接，此函数直接操作软链接而非源文件(目录)。\nNote：并非所有平台都能检查和修改软链接，python能告诉用户本地平台可使用哪些功能。\n\n如果os.chmod in os.supports_follow_symlinks为True，copystat()可以修改软链接的权限位\n如果os.utime in os.supports_follow_symlinks为True，copystat()可以修改软链接的最后访问时间和最后修改时间\n如果os.chflags in os.supports_follow_symlinks为True，copystat()可以修改软链接的flag\n\ncopystat()总是能成功执行，即使是在某些它的部分或全部功能不可用的平台上修改软链接，它将最大限度地拷贝它能拷贝的所有信息。\nshutil.copy(src, dst, *, follow_symlinks=True)\n复制文件src的内容和权限位到dst，dst可以是文件或目录，如果是文件，函数的返回值就是dst，如果是目录，函数的返回值就是src的文件名与dst的路径拼接。src和dst都是字符串类型，如果dst指向一个目录，则创建与src同名(basename)的新文件。\n如果follow_symlinks为False，且src是软链接，dst将作为软链接创建；如果follow_symlinks为True，src为软链接，则实际拷贝的是src指向的源文件。\ncopy()使用copymode()拷贝权限位，使用copyfile()拷贝文件内容\n>>> shutil.copy(\"src.txt\", \"dst.txt\")\n'dst.txt'\n>>> shutil.copy(\"src.txt\", \"/tmp/\")\n'/tmp/src.txt'\n>>> shutil.copy(\"src.txt\", \"/Dota2/\")     # 传入一个不存在的目录\nTraceback (most recent call last):\n  ...\nIsADirectoryError: [Errno 21] Is a directory: '/Dota2/'\nshutil.copy2(src, dst, *, follow_symlinks=True)\n除了还会保留src的所有元数据(如创建时间、修改时间等)，其他与copy()相同。\n当follow_symlinks为False且src为软链接时，dst将作为软链接被创建并拷贝src的所有元数据到dst。\ncopy2()使用copystat()拷贝元数据，使用copyfile()拷贝文件内容\nshutil.ignore_patterns(*patterns)\n创建并返回一个函数，可传递到copytree()中作为ignore参数的值，忽略满足匹配模式的文件和目录\nshutil.copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2, ignore_dangling_symlinks=False)\n递归复制以src为根目录的整个目录树，返回目标目录dst。dst必须是不存在的目录，它和它不存在的父目录都将被创建。使用copystat()复制目录元数据，使用copy2()复制文件内容和元数据\n\nsymlinks：如果值为True，拷贝src目录树中的软链接和软链接的元数据到dst目录树；如果值为False，拷贝src目录树中软链接指向的源文件(目录)的内容和元数据到dst目录树(需要注意的是，拷贝后的文件或目录的名称使用的是软链接的名称而非源文件或目录的名称)，倘若源文件不存在将导致异常，异常信息保存在最终抛出的Error异常中。\nignore_dangling_symlinks：如果值为True，可以忽略symlinks参数为False时由于源文件不存在产生的异常。对于不支持os.symlink()的平台，此参数无任何影响\nignore：必须是一个可调用对象，接收src目录树下的目录和使用os.listdir()返回的该目录下的文件、目录列表。由于copytree()是递归调用的，因此src目录树下每个被复制的目录都会调用一次ignore。\ncopy_function：必须是一个可调用对象，用于复制文件\n\n原始目录结构：\n[root@localhost Shutil]# pwd\n/root/Shutil\n[root@localhost Shutil]# ll -R\n.:\n总用量 0\ndrwxr-xr-x. 3 root root 70 10月 12 10:48 src\ndrwxr-xr-x. 3 root root 33 10月 12 10:47 symlink\n\n./src:\n总用量 0\n-rw-r--r--. 1 root root  0 10月 12 10:39 aa.txt\ndrwxr-xr-x. 2 root root  6 10月 12 10:40 dddir\nlrwxrwxrwx. 1 root root 27 10月 12 10:48 ssdir_link -> /root/Shutil/symlink/ssdir/\nlrwxrwxrwx. 1 root root 27 10月 12 10:48 ss_link.txt -> /root/Shutil/symlink/ss.txt\n\n./src/dddir:\n总用量 0\n\n./symlink:\n总用量 0\ndrwxr-xr-x. 2 root root 6 10月 12 10:57 ssdir\n-rw-r--r--. 1 root root 0 10月 12 10:46 ss.txt\n\n./symlink/ssdir:\n总用量 0\nshutil.copytree(\"/root/Shutil/src/\", \"/root/Shutil/dst/\", symlinks=False)的执行结果：\n[root@localhost Shutil]# ll dst/\n总用量 0\n-rw-r--r--. 1 root root 0 10月 12 10:39 aa.txt\ndrwxr-xr-x. 2 root root 6 10月 12 10:40 dddir\ndrwxr-xr-x. 2 root root 6 10月 12 10:57 ssdir_link\n-rw-r--r--. 1 root root 0 10月 12 10:46 ss_link.txt\nshutil.copytree(\"/root/Shutil/src/\", \"/root/Shutil/dst/\", symlinks=True)的执行结果：\n[root@localhost Shutil]# ll dst/\n总用量 0\n-rw-r--r--. 1 root root  0 10月 12 10:39 aa.txt\ndrwxr-xr-x. 2 root root  6 10月 12 10:40 dddir\nlrwxrwxrwx. 1 root root 27 10月 12 10:48 ssdir_link -> /root/Shutil/symlink/ssdir/\nlrwxrwxrwx. 1 root root 27 10月 12 10:48 ss_link.txt -> /root/Shutil/symlink/ss.txt\nshutil.rmtree(path, ignore_errors=False, onerror=None)\n删除目录。path必须指代一个目录(但不能是目录的软链接)。\n\nignore_errors：如果为True，忽略目录删除失败导致的异常，否则该异常将由onerror参数指定的函数处理。如果onerror为None，该异常被抛出\nonerror：必须是一个接收三个参数(function, path, excinfo)的可调用对象。\n\nNote：在支持基于文件描述符的目录访问函数的平台上，默认使用抗软链接攻击(symlink attack resistant)的rmtree()版本；其他平台上的rmtree()的实现易遭受软链接攻击。可以用rmtree.avoids_symlink_attacks查看当前平台的rmtree()方法能否抵抗软链接攻击\nshutil.move(src, dst, copy_function=copy2)\n移动文件或目录到目标位置。\n如果目标位置dst是一个存在的[软链接]目录，将src(文件或目录)移动到dst路径下\n# before\n[root@localhost shutil_move]# pwd\n/root/shutil_move\n[root@localhost shutil_move]# ll\n总用量 0\ndrwxr-xr-x. 2 root root  6 10月 12 14:41 dst_dir\ndrwxr-xr-x. 2 root root 20 10月 12 14:39 src\n\n>>> shutil.move(\"/root/shutil_move/src/\", \"/root/shutil_move/dst_dir/\")\n'/root/shutil_move/dst_dir/src'\n\n# after\n[root@localhost shutil_move]# ll -R\n.:\n总用量 0\ndrwxr-xr-x. 3 root root 17 10月 12 14:43 dst_dir\n\n./dst_dir:\n总用量 0\ndrwxr-xr-x. 2 root root 6 10月 12 14:45 src\n\n./dst_dir/src:\n总用量 0\n如果目标位置dst是一个不存在的目录，创建dst及其不存在的父级目录，将src(文件)移动到dst路径下或将src(目录)移动并重命名为dst\n# before\n[root@localhost shutil_move]# pwd\n/root/shutil_move\n[root@localhost shutil_move]# ll\n总用量 0\ndrwxr-xr-x. 2 root root 6 10月 12 14:55 src\n[root@localhost shutil_move]# ll /tmp/\n总用量 0\n\n>>> shutil.move(\"/root/shutil_move/src/\", \"/tmp/a/b/dst/\")\n'/tmp/a/b/dst/'\n\n# after\n[root@localhost shutil_move]# ll\n总用量 0\n[root@localhost shutil_move]# ll -R /tmp/\n/tmp/:\n总用量 0\ndrwxr-xr-x. 3 root root 15 10月 12 14:57 a\n\n/tmp/a:\n总用量 0\ndrwxr-xr-x. 3 root root 17 10月 12 14:57 b\n\n/tmp/a/b:\n总用量 0\ndrwxr-xr-x. 2 root root 6 10月 12 14:55 dst\n\n/tmp/a/b/dst:\n总用量 0\n\n如果dst非目录，且dst存在或其上级目录存在\n\nsrc是普通文件，dst是普通文件或软链接文件，移动src并重命名为dst。原始dst如果存在则被直接覆盖\nsrc是软链接文件，dst是普通文件或软链接文件，移动src并重命名为dst，指向的真实文件为src之前指向的源文件。原始dst如果存在则被直接覆盖\n\n\nshutil.disk_usage(path)\n以命名元组的方式(total, used, free)返回指定path的磁盘使用数据，单位为byte。在Windows平台，path必须指代目录；在Unix平台path可以是目录或文件\nshutil.chown(path, user=None, group=None)\n改变指定path的所有者和属组。\nuser和group参数，可以是系统上的用户名/组名或uid/gid。至少需要传递其中一个参数\nshutil.which(cmd, mode=os.F_OK | os.X_OK, path=None)\n返回cmd调用的可执行文件路径，没有返回None。\n\nmode：传递给os.access()的权限掩码(permission mask)，默认值为os.F_OK | os.X_OK，用于判断文件是否存在或可执行。\npath：cmd的查找路径。如果未指定，在os.environ的\"PATH\"key指代的路径查找，如果\"PATH\"不存在，使用os.defpath作为默认路径。\n\n在Windows平台，不管使用默认path还是自定义的path，查找路径都将包含当前工作目录且处于最高优先级。此外，在查找cmd时，还会检查环境变量PATHEXT。\n>>> shutil.which(\"python3\")\n'D:\\\\Program Files\\\\Python36\\\\python3.EXE'\ncopytree示例\n使用ignore_patterns()忽略拷贝后缀为.pyc的文件和tmp打头的文件或文件夹：\nfrom shutil import copytree, ignore_patterns\n\ncopytree(source, destination, ignore=ignore_patterns('*.pyc', 'tmp*'))\n使用ignore参数记录日志：\nfrom shutil import copytree\nimport logging\n\ndef _logpath(path, names):\n    logging.info('Working in %s', path)\n    return []   # nothing will be ignored\n\ncopytree(source, destination, ignore=_logpath)\nrmtree示例\nimport os, stat\nimport shutil\n\ndef remove_readonly(func, path, _):\n    \"Clear the readonly bit and reattempt the removal\"\n    os.chmod(path, stat.S_IWRITE)\n    func(path)\n\nshutil.rmtree(directory, onerror=remove_readonly)\n归档操作\n基于zipfile和tarfile模块提供创建和读取归档文件的功能。\nshutil.make_archive(base_name, format[, root_dir[, base_dir[, verbose[, dry_run[, owner[, group[, logger]]]]]]])\n创建归档文件，并返回归档文件的名称。\n\nbase_name：要创建的归档文件的名称(不包含扩展名)，可以包含路径表示归档文件的目标位置\nformat：归档文件的格式(zip, tar, gztar, bztar, xztar)\nroot_dir：归档文件的根目录(默认当前目录)\nbase_dir：归档文件中所有文件和目录的前缀路径(默认当前目录)\ndry_run：如果为True，不创建归档文件，但是将执行的操作记录在logger中\nowner/group：归档文件中所有文件和目录的所属用户和组。如果format为\"zip\"，owner和group的配置不生效\nlogger：通常使用logging.Logger对象\nverbose：已弃用\n\n# /root/demo/ 归档该目录下的文件和文件夹\n# /tmp/shutil/ 生成的归档文件中的所有内容的前缀路径\n>>> shutil.make_archive(\"/root/demo_zip/zipfile\", \"zip\", \"/root/demo/\", \"/tmp/shutil/\")\n'/root/demo_zip/zipfile.zip'\n[root@localhost demo_zip]# unzip -l zipfile.zip \nArchive:  zipfile.zip\n  Length      Date    Time    Name\n---------  ---------- -----   ----\n        0  10-15-2018 11:03   tmp/shutil/\n        0  10-15-2018 11:03   tmp/shutil/aa.txt\n        0  10-15-2018 11:03   tmp/shutil/bb.txt\n        0  10-15-2018 11:03   tmp/shutil/cc.txt\n---------                     -------\n        0                     4 files\nshutil.get_archive_formats()\n返回支持的归档格式列表，列表中的每个元素是(name, description)形式的元组。默认支持的格式如下：\n\nzip：需要zlib模块支持\ntar\ngztar：需要zlib模块支持\nbztar：需要bz2模块支持\nxztar：需要lzma模块支持\n\n用户可以通过register_archive_format()注册新的格式或者自定义已存在格式的归档行为\nshutil.register_archive_format(name, function[, extra_args[, description]])\n注册格式为name的归档器\nshutil.unregister_archive_format(name)\n从支持的归档格式中移除name\nshutil.unpack_archive(filename[, extract_dir[, format]])\n解压归档文件。\n\nfilename：归档文件名称\nextract_dir：归档文件解压的目标位置。默认使用当前目录\nformat：使用指定格式的解压器解压归档文件，默认使用filename参数的扩展名。如果不存在对应的解压器，抛出ValueError异常\n\nshutil.register_unpack_format(name, extensions, function[, extra_args[, description]])\n注册格式为name的解压器\nshutil.unregister_unpack_format(name)\n从支持的解压格式中移除name\nshutil.get_unpack_formats()\n返回支持的解压格式列表，列表中的每个元素是(name, extensions, description)形式的元组。\n查询终端大小\nshutil.get_terminal_size(fallback=(columns, lines))\n获取终端窗口的大小。\n如果环境变量中定义了正整数的COLUMNS和LINES，返回该大小。\n如果COLUMNS和LINES未定义(多数情况都是如此)，返回调用os.get_terminal_size()查询连接到sys.__stdout__的终端的大小。\n如果终端大小不能被查询(系统不支持或者未连接到终端)，使用fallback参数提供的大小作为后备值，默认是(80, 24)\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}