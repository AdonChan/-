{"title": "Python之retrying - HeHa37 ", "index": "python", "content": "retrying是一个很好用的关于重试的Python包，可以用来自动重试一些可能会运行失败的程序段。\n为什么选择retrying\n\n我们在写一些程序的时候，会去调用一些外部资源、组件，这些外部程序对我们来说是不可控的，所以它们不可用、运行失败都是正常的事情，尤其是在网络上多个服务交互的时候，在写程序的时候一定要考虑调用外部程序会失败的情况。\nretrying\nretrying就是一个可以用来应对上述问题的工具，可以在PyPi上获得。retrying提供一个装饰器函数retry，被装饰的函数就会在运行失败的条件下重新执行，默认只要一直报错就会不断重试，看一下下面的例子：\nimport random\nfrom retrying import retry\n\n@retry\ndef have_a_try():\n    if random.randint(0, 10) != 5:\n        raise Exception('It's not 5!')\n    print 'It's 5!'\n如果我们运行have_a_try函数，那么直到random.randint返回5，它才会执行结束，否则会一直重新执行。retry还可以接受一些参数，这个从源码中Retrying类的初始化函数可以看到可选的参数：\n    def __init__(self,\n                 stop=None, wait=None,\n                 stop_max_attempt_number=None,\n                 stop_max_delay=None,\n                 wait_fixed=None,\n                 wait_random_min=None, wait_random_max=None,\n                 wait_incrementing_start=None, wait_incrementing_increment=None,\n                 wait_exponential_multiplier=None, wait_exponential_max=None,\n                 retry_on_exception=None,\n                 retry_on_result=None,\n                 wrap_exception=False,\n                 stop_func=None,\n                 wait_func=None,\n                 wait_jitter_max=None)\n\nstop_max_attempt_number：用来设定最大的尝试次数，超过该次数就停止重试\nstop_max_delay：比如设置成10000，那么从被装饰的函数开始执行的时间点开始，到函数成功运行结束或者失败报错中止的时间点，只要这段时间超过10秒，函数就不会再执行了\nwait_fixed：设置在两次retrying之间的停留时间\nwait_random_min和wait_random_max：用随机的方式产生两次retrying之间的停留时间\nwait_exponential_multiplier和wait_exponential_max：以指数的形式产生两次retrying之间的停留时间，产生的值为2^previous_attempt_number * wait_exponential_multiplier，previous_attempt_number是前面已经retry的次数，如果产生的这个值超过了wait_exponential_max的大小，那么之后两个retrying之间的停留值都为wait_exponential_max。这个设计迎合了exponential backoff算法，可以减轻阻塞的情况。\n我们可以指定要在出现哪些异常的时候再去retry，这个要用retry_on_exception传入一个函数对象:\n\ndef retry_if_io_error(exception):\n    return isinstance(exception, IOError)\n\n@retry(retry_on_exception=retry_if_io_error)\ndef read_a_file():\n    with open(\"file\", \"r\") as f:\n        return f.read()\n在执行read_a_file函数的过程中，如果报出异常，那么这个异常会以形参exception传入retry_if_io_error函数中，如果exception是IOError那么就进行retry，如果不是就停止运行并抛出异常。\n我们还可以指定要在得到哪些结果的时候去retry，这个要用retry_on_result传入一个函数对象：\ndef retry_if_result_none(result):\n    return result is None\n\n@retry(retry_on_result=retry_if_result_none)\ndef get_result():\n    return None\n在执行get_result成功后，会将函数的返回值通过形参result的形式传入retry_if_result_none函数中，如果返回值是None那么就进行retry，否则就结束并返回函数值。\n参考资料\n\nGet back up and try again: retrying in Python\nretrying\n\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "15"}