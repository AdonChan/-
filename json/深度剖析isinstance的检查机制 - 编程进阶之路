{"title": "深度剖析isinstance的检查机制 - 编程进阶之路 ", "index": "python", "content": "起步\n通过内建方法 isinstance(object, classinfo) 可以判断一个对象是否是某个类的实例。但你是否想过关于鸭子协议的对象是如何进行判断的呢？ 比如 list 类的父类是继 object 类的，但通过 isinstance([], typing.Iterable) 返回的却是真，难道 list 是可迭代的子类？学过Python的面向对象应该知道，list的基类是object的。\n根据 PEP 3119 的描述中得知实例的检查是允许重载的：\nThe primary mechanism proposed here is to allow overloading the built-in functions isinstance() and issubclass(). The overloading works as follows: The call isinstance(x, C) first checks whether C.__instancecheck__ exists, and if so, calls C.__instancecheck__(x) instead of its normal implementation.\n这段话的意思是，当调用 isinstance(x, C) 进行检测时，会优先检查是否存在 C.__instancecheck__ ，如果存在则调用 C.__instancecheck__(x) ，返回的结果便是实例检测的结果，默认的判断方式就没有了。\n这种方式有助于我们来检查鸭子类型，我用代码测了一下。\nclass Sizeable(object):\n    def __instancecheck__(cls, instance):\n        print(\"__instancecheck__ call\")\n        return hasattr(instance, \"__len__\")\n\nclass B(object):\n    pass\n\nb = B()\nprint(isinstance(b, Sizeable)) # output:False\n只打印了 False，并且 __instancecheck__ 没有调用。 这是怎么回事。可见文档描述并不清楚。打破砂锅问到底的原则我从源码中观察 isinstance 的检测过程。\n从源码来看 isinstance 的检测过程\n这部分的内容可能比较难，如果读者觉得阅读有难度可以跳过，直接看结论。isinstance 的源码在 abstract.c 文件中：\n[abstract.c]\nint\nPyObject_IsInstance(PyObject *inst, PyObject *cls)\n{\n    _Py_IDENTIFIER(__instancecheck__);\n    PyObject *checker;\n\n    /* Quick test for an exact match */\n    if (Py_TYPE(inst) == (PyTypeObject *)cls)\n        return 1;\n    ....\n}\nPy_TYPE(inst) == (PyTypeObject *)cls 这是一种快速匹配的方式，等价于 type(inst) is cls ，这种快速的方式仅当 inst = cls() 匹配成功，并不会去优先检查 __instancecheck__ ，所以文档中有误。继续向下看源码：\n    /* We know what type's __instancecheck__ does. */\n    if (PyType_CheckExact(cls)) {\n        return recursive_isinstance(inst, cls);\n    }\n展开宏 PyType_CheckExact :\n[object.h]\n#define PyType_CheckExact(op) (Py_TYPE(op) == &PyType_Type)\n也就是说 cls 是由 type 直接构造出来的类，则判断语言成立。除了类声明里指定 metaclass 外基本都是由 type 直接构造的。从测试代码中得知判断成立，进入 recursive_isinstance。但是这个函数里面我却没找到有关 __instancecheck__ 的代码，recursive_isinstance 的判断逻辑大致是:\ndef recursive_isinstance(inst, cls):\n    return pyType_IsSubtype(inst, cls)\n\ndef pyType_IsSubtype(a, b):\n    for mro in a.__class__.__mro__:\n        if mro is b:\n            return True\n    return False\n是从 __mro__ 继承顺序来判断的，__mro__ 是一个元组，它表示类的继承顺序，这个元组的中类的顺序也决定了属性查找顺序。回到 PyObject_IsInstance 函数往下看：\nif (PyTuple_Check(cls)) {\n    ...\n}\n这是当 instance(x, C) 第二个参数是元组的情况，里面的处理方式是递归调用 PyObject_IsInstance(inst, item) 。继续往下看：\nchecker = _PyObject_LookupSpecial(cls, &PyId___instancecheck__);\nif (checker != NULL) {\n    res = PyObject_CallFunctionObjArgs(checker, inst, NULL);\n    ok = PyObject_IsTrue(res);\n    return ok;\n}\n显然，这边才是获得 __instancecheck__ 的地方，为了让检查流程走到这里，定义的类要指明 metaclass 。剩下就是跟踪下 _PyObject_LookupSpecial 就可以了：\n[typeobject.c]\nPyObject *\n_PyObject_LookupSpecial(PyObject *self, _Py_Identifier *attrid)\n{\n    PyObject *res;\n\n    res = _PyType_LookupId(Py_TYPE(self), attrid);\n    // 有回调的话处理回调\n    // ...\n    return res;\n}\n取的是 Py_TYPE(self) ，也就是说指定的 metaclass 里面需要定义 __instancecheck__ ，获得该属性后，通过 PyObject_CallFunctionObjArgs 调用，调用的内容才是用户自定义的重载方法。\n检查机制总结\n至此，isinstance 的检测过程基本清晰了，为了便于理解，也得益于python很强的自解释能力，我用python代码来简化 isinstance 的过程:\ndef _isinstance(x, C):\n    # 快速匹配\n    if type(x) is C:\n        return True\n\n    # 如果是由元类 type 直接构造的类\n    if type(C) is type:\n        return C in x.__class__.__mro__\n\n    # 如果第二个参数是元组, 则递归调用\n    if type(C) is tuple:\n        for item in C:\n            r = _isinstance(x, item)\n            if r:\n                return r\n\n    # 用户自定义检测规则\n    if hasattr(C, \"__instancecheck__\"):\n        return C.__instancecheck__(x)\n\n    # 默认行为\n    return C in x.__class__.__mro__\n判断的过程中有5个步骤，而用户自定义的 __instancecheck__ 则比较靠后，这个检测过程主要还是以默认的行为来进行的，用户行为并不优先。\n重载 isinstance(x, C)\n\n因此，要想重载 isinstance(x, C) ，让用户能自定义判断结果，就需要满足以下条件：\n\nx 对象不能是由 C 直接实例化；\nC 类指定 metaclass ；\n指定的 metaclass 类中定义了 __instancecheck__ 。\n\n满足这些条件后，比如对鸭子协议如何判断就比较清楚了：\nclass MetaSizeable(type):\n    def __instancecheck__(cls, instance):\n        print(\"__instancecheck__ call\")\n        return hasattr(instance, \"__len__\")\n\nclass Sizeable(metaclass=MetaSizeable):\n    pass\n\nclass B(object):\n    pass\n\nb = B()\nprint(isinstance(b, Sizeable))  # output: False\nprint(isinstance([], Sizeable)) # output: True\n参考阅读\ncustomizing-instance-and-subclass-checks\nclass.__mro__\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}