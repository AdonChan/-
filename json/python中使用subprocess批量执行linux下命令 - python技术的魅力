{"title": "python中使用subprocess批量执行linux下命令 - python技术的魅力 ", "index": "python,subprocess", "content": "可以执行shell命令的相关模块和函数有：\n\n\nos.system\nos.spawn\nos.popen    --废弃\npopen       --废弃\ncommands    --废弃，3.x中被移除\n\n以上执行shell命令的相关的模块和函数的功能均在 subprocess 模块中实现，并提供了更丰富的功能。\n\nsubprocess\ncall\n执行命令，返回状态码\n>>> import subprocess\n>>> ret = subprocess.call([\"ls\", \"-l\"], shell=False)\ntotal 4684\n-rw-r--r-- 1 root root     454 May  5 12:20 aa.py\n-rw-r--r-- 1 root root       0 May  8 16:51 aa.txt\n-rw-r--r-- 1 root root 4783286 Apr 11 16:39 DockerToolbox.exe\n-rw-r--r-- 1 root root     422 May  5 12:20 ip_info.txt\n-rw-r--r-- 1 root root     718 Apr 19 10:52 my.cnf\n>>> ret = subprocess.call(\"ls -l\", shell=True)\ntotal 4684\n-rw-r--r-- 1 root root     454 May  5 12:20 aa.py\n-rw-r--r-- 1 root root       0 May  8 16:51 aa.txt\n-rw-r--r-- 1 root root 4783286 Apr 11 16:39 DockerToolbox.exe\n-rw-r--r-- 1 root root     422 May  5 12:20 ip_info.txt\n-rw-r--r-- 1 root root     718 Apr 19 10:52 my.cnf\n>>> print(ret)\n0\ncheck_call\n执行命令，如果执行状态码是 0 ，则返回0，否则抛异常\n>>> subprocess.check_call([\"ls\", \"-l\"])\ntotal 4684\n-rw-r--r-- 1 root root     454 May  5 12:20 aa.py\n-rw-r--r-- 1 root root       0 May  8 16:51 aa.txt\n-rw-r--r-- 1 root root 4783286 Apr 11 16:39 DockerToolbox.exe\n-rw-r--r-- 1 root root     422 May  5 12:20 ip_info.txt\n-rw-r--r-- 1 root root     718 Apr 19 10:52 my.cnf\n0\n>>> subprocess.check_call(\"exit 1\", shell=True)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"/usr/local/python3.5/lib/python3.5/subprocess.py\", line 581, in check_call\n    raise CalledProcessError(retcode, cmd)\nsubprocess.CalledProcessError: Command 'exit 1' returned non-zero exit status 1\ncheck_output\n执行命令，如果状态码是 0 ，则返回执行结果，否则抛异常\n>>> subprocess.check_output([\"echo\", \"Hello World!\"])\nb'Hello World!\\n'\n>>> subprocess.check_output(\"exit 1\", shell=True)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"/usr/local/python3.5/lib/python3.5/subprocess.py\", line 626, in check_output\n    **kwargs).stdout\n  File \"/usr/local/python3.5/lib/python3.5/subprocess.py\", line 708, in run\n    output=stdout, stderr=stderr)\nsubprocess.CalledProcessError: Command 'exit 1' returned non-zero exit status 1\nsubprocess.Popen(...)\n用于执行复杂的系统命令参数：\nargs：shell命令，可以是字符串或者序列类型（如：list，元组）bufsize：指定缓冲。0 无缓冲,1 行缓冲,其他 缓冲区大小,负值 系统缓冲stdin, stdout, stderr：分别表示程序的标准输入、输出、错误句柄preexec_fn：只在Unix平台下有效，用于指定一个可执行对象（callable object），它将在子进程运行之前被调用close_sfs：在windows平台下，如果close_fds被设置为True，则新创建的子进程将不会继承父进程的输入、输出、错误管道。所以不能将close_fds设置为True同时重定向子进程的标准输入、输出与错误(stdin, stdout, stderr)。shell：同上cwd：用于设置子进程的当前目录env：用于指定子进程的环境变量。如果env = None，子进程的环境变量将从父进程中继承。universal_newlines：不同系统的换行符不同，True -> 同意使用 nstartupinfo与createionflags只在windows下有效将被传递给底层的CreateProcess()函数，用于设置子进程的一些属性，如：主窗口的外观，进程的优先级等等\n执行普通命令\n>>> import subprocess\n>>> ret1 = subprocess.Popen([\"mkdir\",\"t1\"])\n>>> ret2 = subprocess.Popen(\"mkdir t2\", shell=True)\n>>> print(ret1)\n<subprocess.Popen object at 0x7f4d7609dd30>\n>>> print(ret2)\n<subprocess.Popen object at 0x7f4d7609dc18>\n终端输入的命令分为两种：\n\n输入即可得到输出，如：ifconfig\n输入进行某环境，依赖再输入，如：python\n\n>>> import subprocess\n>>> obj = subprocess.Popen(\"mkdir t3\", shell=True, cwd='/tmp/',)\n>>> import subprocess\n>>> obj = subprocess.Popen([\"python\"], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)\n>>> obj.stdin.write(\"print(1)\\n\")\n9\n>>> obj.stdin.write(\"print(2)\")\n8\n>>> obj.stdin.close()\n>>> cmd_out = obj.stdout.read()\n>>> obj.stdout.close()\n>>> cmd_error = obj.stderr.read()\n>>> obj.stderr.close()\n>>> print(cmd_out)\n1\n2\n>>> print(cmd_error)\n>>> import subprocess\n>>> \n>>> obj = subprocess.Popen([\"python\"], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)\n>>> obj.stdin.write(\"print(1)\\n\")\n9\n>>> obj.stdin.write(\"print(2)\")\n8\n>>> \n>>> out_error_list = obj.communicate()\n>>> print(out_error_list)\n('1\\n2\\n', '')\n>>> obj = subprocess.Popen([\"python\"], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)\n>>> out_error_list = obj.communicate('print(\"hello\")')\n>>> print(out_error_list)\n('hello\\n', '')\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "1"}