{"title": "探索大型神经网络智能调参（一）：构建大规模BPNN - machine learning ", "index": "python,tensorflow", "content": "我们正在研究如何用更廉价、更高效、鲁棒性更好的方法对大宽度、大深度的神经网路进行调参（hidden layer的层数，每层layer的节点，epochs，batch_size）。无论如何，先构建一个规模较大的神经网络，要保证训练的时间（即使使用GPU计算）。此神经网络有9个隐含层，每层400个节点，1450401个trainable parameters,是一个预测类的后向反馈神经网络，建立feval值（用以量化某声学设备设计方案的好坏）和15个设计尺寸的函数关系。\n1.导入依赖库\npandas用以处理矩阵数据，matplotlib用以可视化，keras用以训练后向反馈神经网络。\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom keras.models import Sequential\nfrom keras.layers.core import Dense,Dropout, Activation\nfrom keras.utils.vis_utils import plot_model\n2.导入EXCEL文件中的数据\n定义输入文件、输出文件、模型参数保存文件的目录；读取excel数据，定义15个feature和1个Label；截取前40000个example作为训练数据集。\ninputfile = 'Dataset.xlsx'\noutputfile = 'output.xls'\nmodelfile = 'modelweight.model'\ndata = pd.read_excel(inputfile,index='index',sheetname=0)\nfeature = ['l1','l2','l3','l4','l5',\n           'p1','p2','p3','p4','p5',\n           'h1','h2','h3','h4','h5']\nlabel = ['feval']\ndata_train = data.loc[range(0,40000)].copy()\n3.将数据归一化，提高训练效率计算各个特征和标签的平均值和标准差，用来做线性变换将数据归一化，并转化为矩阵格式。\ndata_mean = data_train.mean()\ndata_std = data_train.std()\ndata_train = (data_train - data_mean)/data_std\nx_train = data_train[feature].as_matrix()\ny_train = data_train[label].as_matrix()\n4.建立深度学习模型Sequential类的模型，输入层接受15个输入，输出到第一个隐藏层的400个神经元中，其后9个隐藏层都接受400个输入并产生400个输出。输入层和隐藏层都采用ReLu作为激活函数，Dropout概率都为1%。采用均方根误差（mse）值作为loss value，优化器使用adam。打印summary，并将结构图保存为png文件。\nmodel = Sequential()\nmodel.add(Dense(400,input_dim=15,kernel_initializer=\"uniform\"))\nmodel.add(Activation('relu'))\nmodel.add(Dropout(0.01))\nmodel.add(Dense(400,input_dim=400,kernel_initializer=\"uniform\"))\nmodel.add(Activation('relu'))\nmodel.add(Dropout(0.01))\nmodel.add(Dense(400,input_dim=400,kernel_initializer='uniform'))\nmodel.add(Activation('relu'))\nmodel.add(Dropout(0.01))\nmodel.add(Dense(400,input_dim=400,kernel_initializer='uniform'))\nmodel.add(Activation('relu'))\nmodel.add(Dropout(0.01))\nmodel.add(Dense(400,input_dim=400,kernel_initializer='uniform'))\nmodel.add(Activation('relu'))\nmodel.add(Dropout(0.01))\nmodel.add(Dense(400,input_dim=400,kernel_initializer='uniform'))\nmodel.add(Activation('relu'))\nmodel.add(Dropout(0.01))\nmodel.add(Dense(400,input_dim=400,kernel_initializer='uniform'))\nmodel.add(Activation('relu'))\nmodel.add(Dropout(0.01))\nmodel.add(Dense(400,input_dim=400,kernel_initializer='uniform'))\nmodel.add(Activation('relu'))\nmodel.add(Dropout(0.01))\nmodel.add(Dense(400,input_dim=400,kernel_initializer='uniform'))\nmodel.add(Activation('relu'))\nmodel.add(Dropout(0.01))\nmodel.add(Dense(400,input_dim=400,kernel_initializer='uniform'))\nmodel.add(Activation('relu'))\nmodel.add(Dropout(0.01))\nmodel.add(Dense(1,input_dim=400))\nmodel.compile(loss='mean_squared_error', optimizer='adam')\nprint(model.summary())\nplot_model(model, to_file='bpnn_predict_model.png',show_shapes=True)\n\n5.训练模型迭代200次，每一次批量梯度下降使用256个样本。\nmodel.fit(x_train, y_train, epochs = 200, batch_size = 256)\n最终loss值稳定在0.0035左右\n6.测试模型将data数据归一化后使用训练的模型预测tl值，并保存到excel文件中。\nx = ((data[feature] - data_mean[feature])/data_std[feature]).as_matrix()\ndata[u'feval_pred'] = model.predict(x) * data_std['feval'] + data_mean['feval']\ndata.to_excel(outputfile)\n打印预测值（除去训练集样本）并与真实值进行对比。\nplt.xlim(6000, 16000)\nplt.ylim(6000, 16000)\nplt.gca().set_aspect(1)\nplt.scatter(data['feval_pred'][40000:],data['feval'][40000:],s=1, c='b', marker='.')\nplt.show()\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "4"}