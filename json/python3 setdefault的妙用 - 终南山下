{"title": "python3 setdefault的妙用 - 终南山下 ", "index": "python", "content": "当字典 d[k]找不到正确的键时,Python会抛出异常,有没有一种优雅的方法来避免这种情况呢?答案是肯定的.\n\nindex0.py 从索引中获取单词出现的频率信息,并写入列表  --没有使用dict.setdefault\n#!/usr/bin/env python\n# coding=utf-8\nimport sys, re\n\nWORD_RE = re.compile(r'\\w+')\n\nindex = {}\nwith open(sys.argv[1], encoding='utf-8') as fp:\n    for line_no, line in enumerate(fp, 1):\n        for match in WORD_RE.finditer(line):\n            word = match.group()\n            column_no = match.start()+1\n            location = (line_no, column_no)\n            occurrences = index.get(word, [])\n            occurrences.append(location)\n            index[word] = occurrences\n\nfor word in sorted(index, key=str.upper):\n    print(word, index[word])\nzen.txt\nThe Zen of Python, by Tim Peters\n\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those!\n执行 python3 index0.py zen.txt\n\na [(19, 48), (20, 53)]\nAlthough [(11, 1), (16, 1), (18, 1)]\nambiguity [(14, 16)]\nand [(15, 23)]\nare [(21, 12)]\naren [(10, 15)]\nat [(16, 38)]\nbad [(19, 50)]\nbe [(15, 14), (16, 27), (20, 50)]\nbeats [(11, 23)]\nBeautiful [(3, 1)]\nbetter [(3, 14), (4, 13), (5, 11), (6, 12), (7, 9), (8, 11), (17, 8), (18, 25)]\nbreak [(10, 40)]\nby [(1, 20)]\ncases [(10, 9)]\n...\nindex.py 使用了dict.setdefault 只用了一行就解决了获取和更新单词的出现情况列表\n#!/usr/bin/env python\n# coding=utf-8\nimport sys, re\n\nWORD_RE = re.compile(r'\\w+')\n\nindex = {}\nwith open(sys.argv[1], encoding='utf-8') as fp:\n    for line_no, line in enumerate(fp, 1):\n        for match in WORD_RE.finditer(line):\n            word = match.group()\n            column_no = match.start()+1\n            location = (line_no, column_no)\n            index.setdefault(word, []).append(location)\n\nfor word in sorted(index, key=str.upper):\n    print(word, index[word])\n也就是说:\nmy_dict.setdefault(key, []).append(new_value)\n等价于\nif key not in my_dict:\n    my_dict[key] = []\nmy_dict[key].append(new_value)\n二者效果相同,只是setdefault只需一次就完成整个操作,而后者需要进行两次查询\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "0"}