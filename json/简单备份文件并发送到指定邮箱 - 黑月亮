{"title": "简单备份文件并发送到指定邮箱 - 黑月亮 ", "index": "python,python2.7", "content": "背景\n一哥们发了个诉求，总觉得自己的服务器不安全，想搞个定时备份文件并发送到自己的邮箱\n1 实现代码如下\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import, unicode_literals\n\nimport os\nimport datetime\nimport logging\nimport logging.config\n\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.text import MIMEText\nfrom email.header import Header\nfrom email.mime.application import MIMEApplication\nimport smtplib\n\nname = datetime.datetime.now().strftime(\"%Y%m%d%H%M%S\")\nbase_path = '/root/xxxx/temp'\nzip_path = '/root/xxxx/backup/{}.tar.bz2'.format(name)\n\n\ndef set_logging():\n    \"\"\"\"\"\"\n\n    log_dir, log_file = '/root/xxxx/logs', '/root/xxxx/logs/backup.log'\n\n    if not os.path.exists(log_dir):\n        os.mkdir(log_dir)\n\n    if not os.path.exists(log_file):\n        open(log_file, 'w')\n\n    DEFAULT_LOGGING = {\n        'version': 1,\n        'disable_existing_loggers': False,\n        'formatters': {\n            'formatone': {\n                'format': '[%(asctime)s] %(levelname)s : %(message)s',\n            }\n        },\n        'handlers': {\n            'file': {\n                'level': 'DEBUG',\n                'filename': '/root/xxxx/logs/backup.log',\n                'formatter': 'formatone',\n                'class': 'logging.handlers.RotatingFileHandler',\n                'maxBytes': 100 * 1024 * 1024,\n                'backupCount': 10,\n            },\n        },\n        'loggers': {\n            'backup': {\n                'handlers': ['file'],\n                'level': 'INFO',\n            },\n        }\n    }\n\n    logging.config.dictConfig(DEFAULT_LOGGING)\n\n\ndef zip_files():\n    \"\"\"zip files\"\"\"\n    os.system('tar -cjf {} -C {} data'.format(zip_path, base_path))\n\n\ndef sendmail():\n    \"\"\"send mail\"\"\"\n    set_logging()\n    zip_files()\n\n    logger = logging.getLogger('backup')\n\n    mail_from, password = 'xxxxxxx@aliyun.com', 'xxxxxxx'\n    mail_to = 'xxxxx@qq.com'\n    smtp_server = 'smtp.aliyun.com'\n\n    msgRoot = MIMEMultipart('related')\n    msgRoot['Subject'] = 'send backup files {}'.format(name)\n    msgRoot['From'] = '{}<{}>'.format(Header('backup', 'utf-8'), mail_from)\n    msgRoot['To'] = mail_to\n\n    msgText = MIMEText('backup files', 'plain', 'utf-8')\n    msgRoot.attach(msgText)\n\n    zip_con = MIMEApplication(open(zip_path,'rb').read())\n    zip_con.add_header('Content-Disposition', 'attachment',\n                       filename='{}.tar.bz2'.format(name))\n    msgRoot.attach(zip_con)\n\n    try:\n        server = smtplib.SMTP_SSL(smtp_server)\n        server.login(mail_from, password)\n        server.sendmail(mail_from, mail_to, msgRoot.as_string())\n        server.quit()\n        logger.info('send {} backup files success'.format(name))\n    except Exception, e:\n        logger.error('send {} failed {}'.format(name, e))\n        sendmail()\n\n\nif __name__ == '__main__':\n    sendmail()\n2 简单说明\n2.1 打包文件\n这个实现比较初级，直接用 shell 命令进行打包\ndef zip_files():\n    \"\"\"zip files\"\"\"\n    os.system('tar -cjf {} -C {} data'.format(zip_path, base_path))\n2.2 发送邮件\n这个就不说了，现成的模块直接拿来用\n2.3 日志记录\n加上日志，可以很清楚的让我知道发送情况如下，示例如下：\n[2017-04-14 00:00:03,251] INFO : send 20170414000001 backup files success\n[2017-04-14 03:00:02,620] INFO : send 20170414030001 backup files success\n[2017-04-14 06:00:02,406] INFO : send 20170414060001 backup files success\n[2017-04-14 09:00:02,349] INFO : send 20170414090001 backup files success\n[2017-04-14 12:00:02,299] INFO : send 20170414120001 backup files success\n[2017-04-14 15:01:04,696] ERROR : send 20170414150001 failed [Errno 110] Connection timed out\n[2017-04-14 15:01:05,401] INFO : send 20170414150001 backup files success\n\n2.4 定时处理\n定时这个处理，直接使用  crontab 命令，创建个 backup_cron 文件，写入\n0 */3 * * *  python /root/xxxxx/backup.py\n3 简单小结\n业务比较简单，实现也比较简单，没啥可说的\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}