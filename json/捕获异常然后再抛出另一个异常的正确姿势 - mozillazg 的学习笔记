{"title": "捕获异常然后再抛出另一个异常的正确姿势 - mozillazg 的学习笔记 ", "index": "python", "content": "一般实现捕获异常然后再抛出另一个异常的方法类似下面这样:\ndef div():\n    2 / 0\n\ntry:\n    div()\nexcept ZeroDivisionError as e:\n    raise ValueError(e)\n不知道大家有没有注意到这样抛出异常的方式有一个很严重的问题，那就是 在重新抛出另一个异常的时候，捕获的上一个异常的 traceback 信息丢失了(python2): :\n$ cat a.py\ndef div():\n    2 / 0\ntry:\n    div()\nexcept ZeroDivisionError as e:\n    raise ValueError(e)\n\n$ python2 a.py\nTraceback (most recent call last):\n  File \"a.py\", line 6, in <module>\n    raise ValueError(e)\nValueError: integer division or modulo by zero\n\n这样的话非常不利于查找问题: 比如上面的例子中实际出错的代码是第二行，但是 当我们捕获了第一个异常然后再抛出一个自定义异常的时候， 实际出错位置的信息就丢失了。\nPython 2\n那么在 Python 2 下如果我们不想丢失捕获的异常的 traceback 信息的话，应该 怎样重新抛出异常呢？\n有两种办法, 还是用上面的例子举例:\n一种办法是直接 raise: :\n$ cat a.py\ndef div():\n    2 / 0\ntry:\n    div()\nexcept ZeroDivisionError as e:\n    raise\n\n$ python2 a.py\nTraceback (most recent call last):\n  File \"a.py\", line 4, in <module>\n    div()\n  File \"a.py\", line 2, in div\n    2 / 0\nZeroDivisionError: integer division or modulo by zero\n\n另一种办法就是 raise 另一个异常时指定上一个异常的 traceback 信息 (通过 sys.exc_info() 获取当前捕获的异常信息): :\n$ cat a.py\nimport sys\n\ndef div():\n    2 / 0\ntry:\n    div()\nexcept ZeroDivisionError as e:\n    raise ValueError(e), None, sys.exc_info()[2]\n\n$ python2 a.py\nTraceback (most recent call last):\n  File \"a.py\", line 6, in <module>\n    div()\n  File \"a.py\", line 4, in div\n    2 / 0\nValueError: integer division or modulo by zero\n\n这个是 raise 的高级用法:\nraise exception, value, traceback\n\nexception: 异常类实例/异常类\nvalue: 初始化异常类的参数值/异常类实例（使用这个实例作为 raise 的异常实例）/元组/None\ntraceback: traceback 对象/None\n\n下面我们来看看上面的方法是否可以应对多层异常捕获然后再抛出的情况: :\n$ cat a.py\nimport sys\n\ndef div():\n    2 / 0\n\ndef foo():\n    try:\n        div()\n    except ZeroDivisionError as e:\n        raise ValueError(e), None, sys.exc_info()[2]\n\ndef bar():\n    try:\n        foo()\n    except ValueError as e:\n        raise TypeError(e), None, sys.exc_info()[2]\n\ndef foobar():\n    try:\n        bar()\n    except TypeError as e:\n        raise\nfoobar()\n\n$ python2 a.py\nTraceback (most recent call last):\n  File \"a.py\", line 23, in <module>\n    foobar()\n  File \"a.py\", line 20, in foobar\n    bar()\n  File \"a.py\", line 14, in bar\n    foo()\n  File \"a.py\", line 8, in foo\n    div()\n  File \"a.py\", line 4, in div\n    2 / 0\nTypeError: integer division or modulo by zero\n\n从上面的结果可以看到这两种方法是支持多层异常 traceback 信息传递的。\n那么在 Python 3 下又怎么解决这个问题呢？\nPython 3\n在 Python 3 下默认会附加上捕获的上个异常的 trackback 信息（保存在异常实例的 __traceback__ 属性中）: :\n$ cat a.py\ndef div():\n    2 / 0\ntry:\n    div()\nexcept ZeroDivisionError as e:\n    raise ValueError(e)\n\n$ python3 a.py\nTraceback (most recent call last):\n  File \"a.py\", line 4, in <module>\n    div()\n  File \"a.py\", line 2, in div\n    2 / 0\nZeroDivisionError: division by zero\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"a.py\", line 6, in <module>\n    raise ValueError(e)\nValueError: division by zero\n\n也支持指定使用哪个异常实例的 traceback 信息: raise ... from ... :\n$ cat a.py\ndef div():\n    2 / 0\n\ntry:\n    div()\nexcept ZeroDivisionError as e:\n    raise ValueError(e) from e\n\n$ python a.py\nTraceback (most recent call last):\n  File \"a.py\", line 5, in <module>\n    div()\n  File \"a.py\", line 2, in div\n    2 / 0\nZeroDivisionError: division by zero\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"a.py\", line 7, in <module>\n    raise ValueError(e) from e\nValueError: division by zero\n\n也可以指定使用的 traceback 对象: raise exception.with_traceback(traceback) :\n$ cat a.py\nimport sys\n\ndef div():\n    2 / 0\n\ntry:\n    div()\nexcept ZeroDivisionError as e:\n    raise ValueError(e).with_traceback(sys.exc_info()[2])\n\n$ python a.py\nTraceback (most recent call last):\n  File \"a.py\", line 7, in <module>\n    div()\n  File \"a.py\", line 4, in div\n    2 / 0\nZeroDivisionError: division by zero\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"a.py\", line 9, in <module>\n    raise ValueError(e).with_traceback(sys.exc_info()[2])\n  File \"a.py\", line 7, in <module>\n    div()\n  File \"a.py\", line 4, in div\n    2 / 0\nValueError: division by zero\n\n兼容 Python 2 和 Python 3 的写法\n上面介绍了在 Python 2 和 Python 3 下的不同解决办法，那么如何写一个兼容 Python 2 和 Python 3 的 reraise 函数呢？\n下面将介绍一种方法:\nPY3 = sys.version_info[0] == 3\nif PY3:\n    def reraise(tp, value, tb=None):\n        if value.__traceback__ is not tb:\n            raise value.with_traceback(tb)\n        else:\n            raise value\nelse:\n    exec('''def reraise(tp, value, tb=None):\n           raise tp, value, tb\n    ''')\n这里的 reraise 函数我们约定了 vlaue 参数的值是一个异常类的实例。 上面 else 中之所以用 exec 去定义 reraise 函数是因为 raise tp, value, tb 在 Python 3 下会报语法错误，所以用 exec 来 绕过 Python 3 下的语法错误检查。\n下面我们来看一下效果: :\n$ cat a.py\n\nef div():\n    2 / 0\n\ndef foo():\n    try:\n        div()\n    except ZeroDivisionError as e:\n        reraise(ValueError, ValueError(e), sys.exc_info()[2])\n\ndef bar():\n    try:\n        foo()\n    except ValueError as e:\n        reraise(TypeError, TypeError(e), sys.exc_info()[2])\n\ndef foobar():\n    try:\n        bar()\n    except TypeError:\n        raise\nfoobar()\n\nPython 2: :\n$ python2 a.py\nTraceback (most recent call last):\n  File \"a.py\", line 34, in <module>\n    foobar()\n  File \"a.py\", line 31, in foobar\n    bar()\n  File \"a.py\", line 27, in bar\n    reraise(TypeError, TypeError(e), sys.exc_info()[2])\n  File \"a.py\", line 25, in bar\n    foo()\n  File \"a.py\", line 21, in foo\n    reraise(ValueError, ValueError(e), sys.exc_info()[2])\n  File \"a.py\", line 19, in foo\n    div()\n  File \"a.py\", line 15, in div\n    2 / 0\nTypeError: integer division or modulo by zero\n\nPython 3: :\n$ python3 a.py\nTraceback (most recent call last):\n  File \"a.py\", line 19, in foo\n    div()\n  File \"a.py\", line 15, in div\n    2 / 0\nZeroDivisionError: division by zero\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"a.py\", line 25, in bar\n    foo()\n  File \"a.py\", line 21, in foo\n    reraise(ValueError, ValueError(e), sys.exc_info()[2])\n  File \"a.py\", line 6, in reraise\n    raise value.with_traceback(tb)\n  File \"a.py\", line 19, in foo\n    div()\n  File \"a.py\", line 15, in div\n    2 / 0\nValueError: division by zero\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"a.py\", line 34, in <module>\n    foobar()\n  File \"a.py\", line 31, in foobar\n    bar()\n  File \"a.py\", line 27, in bar\n    reraise(TypeError, TypeError(e), sys.exc_info()[2])\n  File \"a.py\", line 6, in reraise\n    raise value.with_traceback(tb)\n  File \"a.py\", line 25, in bar\n    foo()\n  File \"a.py\", line 21, in foo\n    reraise(ValueError, ValueError(e), sys.exc_info()[2])\n  File \"a.py\", line 6, in reraise\n    raise value.with_traceback(tb)\n  File \"a.py\", line 19, in foo\n    div()\n  File \"a.py\", line 15, in div\n    2 / 0\nTypeError: division by zero\n\n下次需要捕获一个异常然后再抛出另一个异常的时候大家可以试试本文的方法。\n参考资料\n\n6. Simple statements — Python 2.7.12 documentation\n6. Built-in Exceptions — Python 2.7.12 documentation\n7. Simple statements — Python 3.5.2 documentation\n5. Built-in Exceptions — Python 3.5.2 documentation\nPEP 3109 -- Raising Exceptions in Python 3000 | Python.org\nbottle/bottle.py at cafc15419cbb4a6cb748e6ecdccf92893bb25ce5 · bottlepy/bottle\nflask/_compat.py at 6e46d0cd3969f6c13ff61c95c81a975192232fed · pallets/flask\n\n原文地址: https://mozillazg.com/2016/08...\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "6"}