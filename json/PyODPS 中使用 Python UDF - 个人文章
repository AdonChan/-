{"title": " PyODPS 中使用 Python UDF - 个人文章 ", "index": "sql,python", "content": "摘要： PyODPS 中使用 Python UDF 包含两方面，一个是直接使用，也就是在 MaxCompute SQL 中使用；一个是间接的方式，也就是 PyODPS DataFrame，这种方式你不需要直接写 Python UDF，而是写普通的 Python 函数或者类。\n点此查看原文：http://click.aliyun.com/m/41092/\nPyODPS 中使用 Python UDF 包含两方面，一个是直接使用，也就是在 MaxCompute SQL 中使用；一个是间接的方式，也就是 PyODPS DataFrame，这种方式你不需要直接写 Python UDF，而是写普通的 Python 函数或者类。下面我们分开说明。\n作为准备工作，我们需要 ODPS 入口，可以通过直接初始化，或者使用 room 机制 加载。\nfrom odps import ODPS\n\no = ODPS('your-access-id', 'your-access-key', 'your-project')\nMaxCompute SQL 中使用 Python UDF\n首先，我们需要写一个 Python 文件，假设我们就是把某一列按 csv 格式放的一列转成 json 格式。\nimport json\n\nfrom odps.udf import annotate\n\n@annotate('string->string')\nclass Transform(object):\n    def evaluate(self, x):\n        columns = list('abc')\n        d = dict(zip(columns, x.split(',')))\n        return json.dumps(d)\n假设这个文件叫 my.py，接下来我们就需要创建 py 资源。\nr = o.create_resource('csv_to_json.py', 'py', fileobj=open('my.py'))\nfileobj 参数也可以是 str 类型，就是表示文件的内容\n接着我们就可以创建 Python UDF 了。\no.create_function('csv_to_json', class_type='csv_to_json.Transform', resources=[r])\n这里我们指定了函数名叫 csv_to_json，主类使我们上传的 csv_to_json.py 文件里的 Transform 类。\n现在我们就可以在 MaxCompute SQL 中调用这个 UDF 了。\no.execute_sql('select csv_to_json(raw) from pyodps_test_udf')\n这样我们就完成了在 PyODPS 中使用 MaxCompute SQL + Python UDF 的整个过程。\nPyODPS DataFrame\n对于 PyODPS DataFrame 来说，用户只需要写普通的 Python 函数或者类，在函数或者类里，甚至可以读取全局变量，这样给开发带来了极大的方便。\n和上面的例子目标相同，我们定义一个 transform 函数即可。然后我们对于 DataFrame 的一列调用 map 方法来应用这个函数。\npassed_columns = list('abc')  # 可以从数据库中读取或者写死\n\ndef transform(x):\n    import json\n    d = dict(zip(passed_columns, x.split(',')))\n    return json.dumps(d)\n\ndf.raw.map(transform)\nIn [30]: df\n     raw\n0  1,2,3\n1  4,5,6\n2  7,8,9\n\nIn [31]: df.raw.map(transform)\n                              raw\n0  {\"a\": \"1\", \"c\": \"3\", \"b\": \"2\"}\n1  {\"a\": \"4\", \"c\": \"6\", \"b\": \"5\"}\n2  {\"a\": \"7\", \"c\": \"9\", \"b\": \"8\"}\n实际上，PyODPS DataFrame 在用 MaxCompute 执行的时候，也会创建 Python UDF 来实现这个功能，但用户不需要去创建文件、资源和函数这些过程，一切都是 Python 原生函数和类，整个过程相当顺畅。\n另外可以看到，在上面的 my.py 里，我们也是定义了一个 columns 参数的，而如果这个参数是通过变量传进去的话，在 Python UDF 里非常麻烦，可能常常需要用一些 tricky 的方法，比如写到某个文件资源，然后在 UDF 里读取之类的。而对于 DataFrame 来说，完全没有这个问题，我们可以自由读取全局变量。\n不过要注意的是，这个全局变量是被序列化到各个机器上的，所以你修改它不会全局生效。\n好了，还有什么问题可以随时和我们取得联系。\n文档：http://pyodps.readthedocs.io/...代码：https://github.com/aliyun/ali... ，欢迎提 issue 和 merge request\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}