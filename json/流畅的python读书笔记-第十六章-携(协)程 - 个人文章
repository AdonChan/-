{"title": "流畅的python读书笔记-第十六章-携(协)程 - 个人文章 ", "index": "python", "content": "协程\n协程可以身处四个状态中的一个。\n当前状态可以使用inspect.getgeneratorstate(...) 函数确定，该函数会返回下述字符串中的一个。\n'GEN_CREATED'　　等待开始执行。\n'GEN_RUNNING'　　解释器正在执行。\n'GEN_SUSPENDED'　　在 yield 表达式处暂停。\n'GEN_CLOSED'　　执行结束。\ndef simple_coro2(a):\n    print('-> Started: a =', a)\n\n\n    b = yield a  #等着赋值b 把a甩出去\n    print('-> Received: b =', b)\n    c = yield a + b\n    print('-> Received: c =', c)\n\n\nmy_coro_2 = simple_coro2(14)\n\nfrom inspect import getgeneratorstate\n\nprint(getgeneratorstate(my_coro_2))\n\nprint(next(my_coro_2))\ngetgeneratorstate(my_coro_2)\n\n\nprint(my_coro_2.send(28))\n\n# 没有yield 出来 所以没有返回值\nprint(my_coro_2.send(99))\n\ngetgeneratorstate(my_coro_2)\ngetgeneratorstate 函数指明，处于 GEN_SUSPENDED 状态（即协程在 yield 表达式处暂停）。\n❺ 把数字 99 发给暂停的协程；计算 yield 表达式，得到 99，然后把那个数绑定给 c。 打印 -> Received: c = 99 消息，然后协程终止，导致生成器对象抛出StopIteration 异常。\n\n另一个案例\ndef averager():\n    total = 0.0\n    count = 0\n    average = None\n    while True:\n        term = yield average\n        total += term\n        count += 1\n        average = total / count\n\n\ncoro_avg = averager()\n\nprint(next(coro_avg))\n\nprint(coro_avg.send(10))\n\nprint(coro_avg.send(15))\n\nprint(coro_avg.send(20))\n\n调用 next 函数，预激协程。➊ 这个无限循环表明，只要调用方不断把值发给这个协程，它就会一直接收值，然后生成结果。仅当调用方在协程上调用 .close() 方法，或者没有对协程的引用而被垃圾回收程序回收时，这个协程才会终止。➋ 这里的 yield 表达式用于暂停执行协程，把结果发给调用方；还用于接收调用方后面发给协程的值，恢复无限循环。\n终止协程和异常处理\n发送某个哨符值，让协程退出。内置的 None 和Ellipsis 等常量经常用作哨符值。\nEllipsis 的优点是，数据流中不太常有这个值。\nthrow\ngenerator.throw(exc_type[, exc_value[, traceback]])\n致使生成器在暂停的 yield 表达式处抛出指定的异常。\n如果生成器处理了抛出的异常，代码会向前执行到下一个 yield 表达式，而产出的值会成为调用 generator.throw方法得到的返回值。\ngenerator.close()\n致使生成器在暂停的 yield 表达式处抛出 GeneratorExit 异常。\n如果生成器没有处理这个异常，或者抛出了 StopIteration 异常（通常是指运行到结尾），调用方不会报错。\n如果收到 GeneratorExit 异常，生成器一定不能产出值，否则解释器会抛出RuntimeError 异常。\n两种停止方式\nexc_coro.throw(ZeroDivisionError)exc_coro.close()\n让协程返回值\nfrom collections import namedtuple\n\nResult = namedtuple('Result', 'count average')\n\n\ndef averager():\n    total = 0.0\n    count = 0\n    average = None\n    while True:\n        term = yield\n        if term is None:\n            break\n        total += term\n        count += 1\n        average = total / count\n    return Result(count, average)\n\n\ncoro_avg = averager()\nnext(coro_avg)\n\ncoro_avg.send(30)\ncoro_avg.send(6.5)\n\ntry:\n    coro_avg.send(None)\nexcept StopIteration as exc:\n    result = exc.value\n    print(result)\n\n捕获 StopIteration 异常，获取 averager 返回的值\nyield from 结构会在内部自动捕获 StopIteration 异常。这种处理方式与 for 循环处理 StopIteration 异常的方式一样：循环机制使用用户易于理解的方式处理异常。对 yield from 结构来说，解释器不仅会捕获 StopIteration 异常，还会把value 属性的值变成 yield from 表达式的值。\n使用yield from\nyield from 结构唯一的作用是替代产出值的嵌套 for 循环, 这句话不对\nyield from 的主要功能是打开双向通道，把最外层的调用方与最内层的子生成器连接起来，\n这样二者可以直接发送和产出值，还可以直接传入异常，\n而不用在位于中间的协程中添加大量处理异常的样板代码。\n有了这个结构，协程可以通过以前不可能的方式委托职责。\n案例\n委派生成器　　包含 yield from <iterable> 表达式的生成器函数。\n子生成器　　从 yield from 表达式中 <iterable> 部分获取的生成器。这就是 PEP 380 的标题（“Syntax for Delegating to a Subgenerator”）中所说的“子生成器”（subgenerator）。\n调用方　　PEP 380 使用“调用方”这个术语指代调用委派生成器的客户端代码。在不同的语境中，我会使用“客户端”代替“调用方”，以此与委派生成器（也是调用方，因为它调用了子生成器）区分开。\n\n不使用yield from\nfrom collections import namedtuple\n\nResult = namedtuple('Result', 'count average')\n\n\n# 子生成器\ndef averager():  # ➊\n    total = 0.0\n    count = 0\n    average = None\n    while True:\n        term = yield  # ➋\n        if term is None:  # ➌\n            break\n        total += term\n        count += 1\n        average = total / count\n    return Result(count, average)  # ➍\n\n\n\ndata = {\n    'girls;kg':\n        [40.9, 38.5, 44.3, 42.2, 45.2, 41.7, 44.5, 38.0, 40.6, 44.5],\n    'girls;m':\n        [1.6, 1.51, 1.4, 1.3, 1.41, 1.39, 1.33, 1.46, 1.45, 1.43],\n    'boys;kg':\n        [39.0, 40.8, 43.2, 40.8, 43.1, 38.6, 41.4, 40.6, 36.3],\n    'boys;m':\n        [1.38, 1.5, 1.32, 1.25, 1.37, 1.48, 1.25, 1.49, 1.46],\n}\n\n\n\n\ndef main(data):\n    result = {}\n\n    for key, values in data.items():\n        coro_avg = averager()\n        next(coro_avg)\n        for value in values:\n            coro_avg.send(value)\n\n        try:\n            coro_avg.send(None)\n        except StopIteration as exc:\n            result[key] = exc.value\n\n    print(result)\n\n\n\nif __name__ == '__main__':\n    main(data)\n这里的try: catch stop异常要一直存在\n用yiled from 及委派生成器作用\nfrom collections import namedtuple\n\nResult = namedtuple('Result', 'count average')\n\n\n# 子生成器\ndef averager():  # ➊\n    total = 0.0\n    count = 0\n    average = None\n    while True:\n        term = yield  # ➋\n        if term is None:  # ➌\n            break\n        total += term\n        count += 1\n        average = total / count\n    return Result(count, average)  # ➍\n\n\n\ndata = {\n    'girls;kg':\n        [40.9, 38.5, 44.3, 42.2, 45.2, 41.7, 44.5, 38.0, 40.6, 44.5],\n    'girls;m':\n        [1.6, 1.51, 1.4, 1.3, 1.41, 1.39, 1.33, 1.46, 1.45, 1.43],\n    'boys;kg':\n        [39.0, 40.8, 43.2, 40.8, 43.1, 38.6, 41.4, 40.6, 36.3],\n    'boys;m':\n        [1.38, 1.5, 1.32, 1.25, 1.37, 1.48, 1.25, 1.49, 1.46],\n}\n\n\ndef grouper(results):\n    while True:\n        res_obj = yield from averager()\n        results.append(res_obj)\n\n\n\n\ndef main(data):\n    results = []\n    for key, values in data.items():\n\n        coro_avg = grouper(results)\n        next(coro_avg)\n\n        for value in values:\n            coro_avg.send(value)\n\n        # 这个None是停止返回 哨兵\n        coro_avg.send(None)\n\n\n    print(results)\n\n    # report(result)\n\n\n# 输出报告\ndef report(results):\n    for key, result in sorted(results.items()):\n        group, unit = key.split(';')\n        print('{:2} {:5} averaging {:.2f}{}'.format(\n            result.count, group, result.average, unit))\n\n\nif __name__ == '__main__':\n    main(data)\n    \n    \n   \n官方的案例\nfrom collections import namedtuple\n\nResult = namedtuple('Result', 'count average')\n\n\n# 子生成器\ndef averager():  # ➊\n    total = 0.0\n    count = 0\n    average = None\n    while True:\n        term = yield  # ➋\n        if term is None:  # ➌\n            break\n        total += term\n        count += 1\n        average = total / count\n    return Result(count, average)  # ➍\n\n\n# 委派生成器\ndef grouper(results, key):  # ➎\n    while True:  # ➏\n        results[key] = yield from averager()  # ➐\n\n\n\n\n# 客户端代码，即调用方\ndef main(data):  # ➑\n    results = {}\n    for key, values in data.items():\n        group = grouper(results, key)  # ➒\n        next(group)  # ➓\n        for value in values:\n            group.send(value)  # ⓫\n        group.send(None)  # 重要！ #⓬\n\n    print(results)  # 如果要调试，去掉注释\n\n    # report(results)\n\n\n# 输出报告\ndef report(results):\n    for key, result in sorted(results.items()):\n        group, unit = key.split(';')\n        print('{:2} {:5} averaging {:.2f}{}'.format(\n            result.count, group, result.average, unit))\n\n\ndata = {\n    'girls;kg':\n        [40.9, 38.5, 44.3, 42.2, 45.2, 41.7, 44.5, 38.0, 40.6, 44.5],\n    'girls;m':\n        [1.6, 1.51, 1.4, 1.3, 1.41, 1.39, 1.33, 1.46, 1.45, 1.43],\n    'boys;kg':\n        [39.0, 40.8, 43.2, 40.8, 43.1, 38.6, 41.4, 40.6, 36.3],\n    'boys;m':\n        [1.38, 1.5, 1.32, 1.25, 1.37, 1.48, 1.25, 1.49, 1.46],\n}\n\nif __name__ == '__main__':\n    main(data)\n\n❸ 至关重要的终止条件。如果不这么做，使用 yield from 调用这个协程的生成器会永远阻塞。❹ 返回的 Result 会成为 grouper 函数中 yield from 表达式的值\n❻ 这个循环每次迭代时会新建一个 averager 实例；每个实例都是作为协程使用的生成器对象。❼ grouper 发送的每个值都会经由 yield from 处理，通过管道传给 averager 实例。grouper 会在 yield from 表达式处暂停，等待 averager 实例处理客户端发来的值。averager 实例运行完毕后，返回的值绑定到 results[key] 上。while 循环会不断创建 averager 实例，处理更多的值。\nyield from 结构会在内部自动捕获 StopIteration 异常。这种处理方式与 for 循环处理 StopIteration 异常的方式一样：循环机制使用用户易于理解的方式处理异常。对 yield from 结构来说，解释器不仅会捕获 StopIteration 异常，还会把value 属性的值变成 yield from 表达式的值。\n总结\n这里先不总结 带我把协程 程序加进去\n如何使用协程在单个线程中管理并发活动。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}