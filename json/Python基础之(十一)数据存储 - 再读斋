{"title": "Python基础之(十一)数据存储 - 再读斋 ", "index": "python", "content": "pickle\npickle是标准库中的一个模块，在Python 2中还有一个cpickle，两者的区别就是后者更快。所以，下面操作中，不管是用import pickle，还是用import cpickle as pickle，在功能上都是一样的。\n而在Python 3中，你只需要import pickle即可，因为它已经在Python 3中具备了Python 2中的cpickle同样的性能。\npickle.dump(obj,file[,protocol])\n\nobj：序列化对象，在上面的例子中是一个列表，它是基本类型，也可以序列化自己定义的对象。\nfile：要写入的文件。可以更广泛地可以理解为为拥有write()方法的对象，并且能接受字符串为为参数，所以，它还可以是一个StringIO对象，或者其它自定义满足条件的对象。\nprotocol：可选项。默认为False（或者说0），是以ASCII格式保存对象；如果设置为1或者True，则以压缩的二进制格式保存对象。\n\n序列化对象\n    >>> import pickle\n    >>> d = {}\n    >>> integers = range(9999)\n    >>> d[\"i\"] = integers        #下面将这个字典类型的对象存入文件\n    \n    >>> f = open(\"22902.dat\", \"wb\")\n    >>> pickle.dump(d, f)           #文件中以ascii格式保存数据\n    >>> f.close()\n\n    >>> f = open(\"22903.dat\", \"wb\")\n    >>> pickle.dump(d, f, True)     #文件中以二进制格式保存数据,文件较小，推荐方式\n    >>> f.close()\n\n    >>> import os\n    >>> s1 = os.stat(\"22902.dat\").st_size    #得到两个文件的大小\n    >>> s2 = os.stat(\"22903.dat\").st_size\n    \n    >>> print \"%d, %d, %.2f%%\" % (s1, s2, (s2+0.0)/s1*100)    #Python 3: print(\"{0:d}, {1:d}, {2:.2f}\".format (s1, s2, (s2+0.0)/s1*100))\n    68903, 29774, 43.21%\n反序列化对象\n将数据保存入文件，还有另外一个目标，就是要读出来，也称之为反序列化。\n\n    >>> integers = pickle.load(open(\"22901.dat\", \"rb\"))\n    >>> print integers    #Python 3: print(integers)\n    [1, 2, 3, 4, 5]\n\n再看看以二进制存入的那个文件：\n\n    >>> f = open(\"22903.dat\", \"rb\")\n    >>> d = pickle.load(f)\n    >>> print d\n    {'i': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, ....   #省略后面的数字}\n    >>> f.close()\n读取自定义对象\n    >>> import cPickle as pickle        #这是Python 2的引入方式，如果是Python 3，直接使用import pickle\n    >>> import StringIO                 #标准库中的一个模块，跟file功能类似，只不过是在内存中操作“文件”\n    \n    >>> class Book(object):             #自定义一种类型\n    ...     def __init__(self,name):\n    ...         self.name = name\n    ...     def my_book(self):\n    ...         print \"my book is: \", self.name        #Python 3: print(\"my book is: \", self.name)\n    ... \n    \n# 存数据\n\n>>> file = StringIO.StringIO()\n>>> pickle.dump(pybook, file, 1)\n    \n# 取数据\n\n>>> file.seek(0)       #找到对应类型  \n>>> pybook2 = pickle.load(file)\n>>> pybook2.my_book()\nmy book is:  <from beginner to master>\n>>> file.close()\nshelve\n由于数据的复杂性，pickle只能完成一部分工作，在另外更复杂的情况下，它就稍显麻烦了。于是，又有了shelve。\n\n# 写操作\n\n>>> import shelve\n>>> s = shelve.open(\"22901.db\")\n>>> s[\"name\"] = \"www.itdiffer.com\"\n>>> s[\"lang\"] = \"python\"\n>>> s[\"pages\"] = 1000\n>>> s[\"contents\"] = {\"first\":\"base knowledge\",\"second\":\"day day up\"}\n>>> s.close()\n  \n# 读操作\n    \n>>> s = shelve.open(\"22901.db\")\n>>> name = s[\"name\"]\n>>> print name        #Python 3: print(name)\nwww.itdiffer.com\n>>> contents = s[\"contents\"]\n>>> print contents        #Python 3: print(contents)\n{'second': 'day day up', 'first': 'base knowledge'}\n\n# for循环读\n\n>>> for k in s:\n...     print k, s[k]\n... \ncontents {'second': 'day day up', 'first': 'base knowledge'}\nlang python\npages 1000\nname www.itdiffer.com\n所建立的对象被变量s所引用，就如同字典一样，可称之为类字典对象。所以，可以如同操作字典那样来操作它。\n但是，要小心坑：\n    >>> f = shelve.open(\"22901.db\")\n    >>> f[\"author\"]\n    ['qiwsir']\n    >>> f[\"author\"].append(\"Hetz\")    #试图增加一个\n    >>> f[\"author\"]                   #坑就在这里\n    ['qiwsir']\n    >>> f.close()\n\n当试图修改一个已有键的值时没有报错，但是并没有修改成功。要填平这个坑，需要这样做：\n    \n    >>> f = shelve.open(\"22901.db\", writeback=True)    #多一个参数True\n    >>> f[\"author\"].append(\"Hetz\")\n    >>> f[\"author\"]                   #没有坑了\n    ['qiwsir', 'Hetz']\n    >>> f.close()\n\n还用`for`循环一下：\n\n    >>> f = shelve.open(\"22901.db\")\n    >>> for k,v in f.items():\n    ...     print k,\": \",v        #Python 3: print(k,\": \",v)\n    ... \n    contents :  {'second': 'day day up', 'first': 'base knowledge'}\n    lang :  python\n    pages :  1000\n    author :  ['qiwsir', 'Hetz']\n    name :  www.itdiffer.com\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "5"}