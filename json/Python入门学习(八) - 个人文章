{"title": "Python入门学习(八) - 个人文章 ", "index": "python", "content": "面向对象OOP\n\n类(Class)\n对象(Object)\n实例(Instance)\n\n\n类:  是一个抽象的存在实例:  是真实存在的类\n对象:  是类的实例\n\n好比说 门 就是一个类, 我的 屋门 就是门的一个实例. 我的屋门是白颜色的, 而且打开和关闭时会发出声响. \n不管是 颜色, 还是打开和关闭 都是类赋予的属性和行为. 至于白颜色和打开和关闭时发出的声响是这个实例的具体表现. \n对象: 包括了 类的属性和行为, 还有实例所都有的具体表现形式(比如: 白颜色, 打开和关闭时发出声响)\n\n在面向对象的程序设计中,  首先要抽离出实体, 以及这个实体所拥有的属性和行为(方法).\n面向对象的三大特点: 封装, 继承, 多态\n封装\nclass Animal(object):\n    def __init__(self, args):\n        super(Animal, self).__init__()\n        self.__name = args.get(\"name\")\n        self.age = args.get(\"age\")\n\n    def call(self):\n        print(\"Animal(name:{0}, age:{1}) Call....\".format(self.__name, self.age));\n\n    def setAnimalInfo(self, *, name, age):\n        self.__name = name\n        self.age = age\n\n    def getAnimalInfo(self):\n        return {\"name\": self.__name, \"age\": self.age}\n\n    def __str__(self):  # 重写父类方法\n        return \"Animal(name:{0}, age:{1})\".format(self.__name, self.age)\n\n\npig = Animal({})\npig.setAnimalInfo(name=\"tom\", age=2)\npig.call()\npig.age = 3\nprint(pig.age)\nprint(pig._Animal__name)  # 不建议这样访问\n# print(pig.__name) # AttributeError: 'Animal' object has no attribute '__name'\npig.__name = \"jack\"  # 这么写是错误的, 虽然Python没有限制\nprint(pig.__name)  # 实际上就是给 pig 绑了一个新的属性\npig.call()\n所谓封装, 就是将类的属性设为私有, 然后开放属性的get, set方法. 这样会提高程序的健壮性(比如set时, 验证实参是否合法)\n因为构造方法(__init__(self, args))中, 存在必选参数, 所以在初始化实例时 pig = Animal({})\n\n实际上私有属性, 在实例化对象时, 就已经改了变量名, 所以才有的 AttributeError: 'Animal' object has no attribute '__name' 的错误信息\n\npig.__name = \"jack\" 就像当于给pig实例, 重新绑定了新的属性(这样写虽然语法没有错, 但不建议这样写. 就像某件事, 没有触犯法律, 但受到道德的谴责.)\n继承\nclass Animal(object) Animal 继承自 object,\nclass Dog(Animal):\n    def __init__(self, args):\n        super(Dog, self).__init__(args)\n\n    def call(self):\n        # print(\"Dog(name:{0}, age:{1}) wang....\".format(super().__name, super.age));\n        print(\"Dog(name:{0}, age:{1}) wang....\".format(super(Dog, self).getAnimalInfo().get(\"name\"),\n                                                       super(Dog, self).getAnimalInfo().get(\"age\")));\n\n    def __str__(self):  # 重写父类方法\n        # return \"Dog(name:{0}, age:{1})\".format(super().__name, super.age)\n        return \"Dog(name:{0}, age:{1})\".format(super(Dog, self).getAnimalInfo().get(\"name\"),\n                                               super(Dog, self).getAnimalInfo().get(\"age\"))\n\n\nclass Cat(Animal):\n    def __init__(self, args):\n        super(Cat, self).__init__(args)\n\n    def call(self):\n        # print(\"Cat(name:{0}, age:{1}) miao....\".format(self.__name, self.age));\n        print(\"Cat(name:{0}, age:{1}) miao....\".format(super(Cat, self).getAnimalInfo().get(\"name\"),\n                                                       super(Cat, self).getAnimalInfo().get(\"age\")));\n\n    def __str__(self):  # 重写父类方法\n        # return \"Cat(name:{0}, age:{1})\".format(self.__name, self.age)\n        return \"Cat(name:{0}, age:{1})\".format(super(Cat, self).getAnimalInfo().get(\"name\"),\n                                               super(Cat, self).getAnimalInfo().get(\"age\"))\n\n\ndog = Dog({\"name\": \"lucy\", \"age\": 2})\ncat = Cat({\"name\":\"lola\", \"age\":1})\n\ndog.call()\ncat.call()\n\nprint(\"pig is Animal\", isinstance(pig, Animal))\nprint(\"dog is Dog\", isinstance(dog, Dog))\nprint(\"cat is Cat\", isinstance(cat, Cat))\nprint(\"dog is Animal\", isinstance(dog, Animal))\nprint(\"cat is Animal\", isinstance(cat, Animal))\n在子类中, 获取父类的引用 super(Dog, self). 而在子类中要想拿到父类的属性, 只能通过父类中提供的开放接口, 来实现了.\n多态\n从上面的程序中可以看出, Animal重写了他的父类的__str__方法, Cat和Dog也重写了这个方法. 有继承和方法重写, 自然就有多态了.\n\ndef getAnimal(animal):\n    print(animal)\n\ngetAnimal(pig)\ngetAnimal(dog)\ngetAnimal(cat)\n\n# Animal(name:tom, age:3)\n# Dog(name:lucy, age:2)\n# Cat(name:lola, age:1)\n虽传入的都是 Animal类, 但执行的却有着不同的行为. 这就是多态(^_^)\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}