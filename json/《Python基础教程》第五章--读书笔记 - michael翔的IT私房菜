{"title": "《Python基础教程》第五章--读书笔记 - michael翔的IT私房菜 ", "index": "读书笔记,python", "content": "第五章：条件、循环和其他语句\n这一章会看到列表推导式（list comprehension）如何扮演循环和条件语句的角色——尽管它本身是表达式。最后介绍pass,del,exec语句的用法。\nprint和import的更多信息、\n可以打印多个表达式，只要将它们用逗号隔开。\n>>>print 'age',24\nage 24\n可以看到，每个参数之间都插入了一个空格符。python3中print不再是语句——而是函数。\n赋值魔法\n就算是不起眼的赋值语句也有一些特殊技巧。\n序列解包\n多个赋值操作可以同时进行：\n>>>x,y,z=1,2,3\n>>>print x,y,z\n1 2 3\n很有用吧？用它交换两个（或更多个）变量也是没问题的：\n>>>x,y,z=y,z,x\n>>>print x,y,z\n2 3 1\n事实上这里所做的事情就是叫做序列解包（sequence unpacking）或递归解包——将多个值的序列解开，然后放到变量的序列中。更形象一点的表示就是：\n>>>values=1,2,3\n>>>values\n(1,2,3)\n>>>x,y,z = values\n>>>x\n1\n所有序列解包的序列中的元素数量必须和放在复制符号=左边的变量数量完全一致。\n链式赋值\n链式赋值（chained assignment）是将同一个值赋给多个变量的捷径。\nx = y = somefunction()\n和下面的语句效果是一样的：\ny = somefunction()\nx = y\n注：上面的语句和下面的语句不一定等价：\nx = somefunction()\ny = somefunction()\n有关链式赋值更多信息，参加本章“同一性运算符”\n增量赋值\n将表达式运算符放置在赋值运算符=的左边，写成x+=1。这种写法叫做增量赋值（augmented assignment)，对于*、/、%等标准运算符都适用：\n>>>x=2\n>>>x+=1\n>>>x*=2\n>>>x\n6\n对于其他数据类型的也适用（只要二元运算发本身是用这些数据类型即可）：\n>>>fonrd='foo'\n>>>fonrd+='ba'\n>>>fonrd*=2\n>>>fonrd\n'foobarfoobar'\n语句块：缩排的乐趣\n标准且推荐的方式是只用空格（(⊙o⊙)…我一直喜欢用tab）。\n条件和条件语句\n布尔变量的作用\n真值（也叫作布尔值，这个名字是根据在真值上做过大量研究的George Boole命名的）。\n下面的值作为布尔表达式的时候，会被解释器看作假（False）：\n\nFalse\nNone\n0     包括所有类型的数字0\n\"\"    注意：引号（或者单引号）之间不能有空格，如果有空格，那么就不是False了！\n[]\n{}其他的一切都被解释为真值，包括特殊值True。（可能有待商榷）\n\n明白了吗？也就是说python中的所有值都能被解释为真值\n标准的布尔值为0和1.事实上，True和False只不过是1和0的另一种“华丽”的说法而已。\n>>>True\nTrue\n>>>False\nFalse\n>>>True==1\nTrue\n>>>False==0\nTrue\n>>>False+True+24\n24\n注：False和True是要首字母大写的，false和true只会被解释器认为是变量名！！！\n布尔值True和Flase属于布尔类型，bool函数可以用来（和list、str、tuple一样）转换其他值。\n>>>bool('my name is michael'\nTrue\n>>>bool('')\nFalse\n条件执行和if语句\nnum=int(raw_input('enter a number:'))    #或者num=input('enter a number:') 二者区别，之前的笔记中也写过了。\nif num>0:\n    print 'the number is positive'\nelif num<0:\n    print 'the number is negative'\nelse:\n    print 'the num is 0'\n\n更复杂的条件\n1.比较运算符\n\n\n表达式\n描述\n\n\n\nx==y\nx等于y\n\n\nx<y\nx小于y\n\n\nx !=y\nx不等于y\n\n\nx is y\nx和y是同一个对象\n\n\nx is not y\nx和y不是同一个对象\n\n\nx in y\nx是y容器（例如，序列）的成员\n\n\nx not in y\nx不是y容器（例如，序列）的成员\n\n\n\n注：如果偶然遇见x<>y这样的表达式，它的意思就是x!=y，但是不建议使用<>运算符。\npython中比较运算符和赋值运算一样是可以连接的——几个运算符可以连接在一起使用，比如：0<age<100。\n2. is:同一运算符\n这个运算符比较有趣。它看起来和==一样，事实却不相同（从名字可以看出来，同一，同一，必须对象是同一才行吧）：\n>>>x=y=[1,2,3]\n>>>z=[1,2,3]\n>>>x==y\nTrue\n>>>x==z\nTrue\n>>>x is y\nTrue\n>>>x is z\nFalse\nx和z相等，却不等同。因为is运算符是判定同一性的而不是相等性的。\n总结一下：==运算符是判定两个对象是否相等，is判定两者是否等同（同一个对象）。\n注：避免将is运算符用于比较类似数值和字符串这类不可变值。由于python内部操作这些对象的方式不同，使用is运算符的结果是不可预测的！\n3. 字符串和序列比较\n>>>[1,2]<[2,1]\nTrue\n不是很明白比较结果为何是这样的。\n4. 布尔运算符\n\nand\nor\nnot\n\n5. 断言\n语句中使用的关键字：assert。\n一般说来，捏可以要求某些条件必须为真（例如，在检查函数参数的属性时或者作为初期测试和调试过程的辅助条件）。\n>>>age=10\n>>>assert 0<age<100\n>>>age=-1\n>>>assert 0<age<100,'the age must be positive'    #条件后可以添加字符串，用来解释断言\n---------------------------------------------------------------------------\nAssertionError                            Traceback (most recent call last)\n<ipython-input-12-51358c1c723f> in <module>()\n      1 age=-1\n----> 2 assert 0<age<100,'the age must be positive'\n \nAssertionError: the age must be positive\n循环\nwhile循环\nname=''\nwhile not name:\n    name=raw_input('enter a name:')\nprint 'hello %s'%name\n如果直接输入一个空格的话，那么name就非空了，所以，不会判定为假！\n修改：只需while not name or name.isspace()。\nfor循环\nwhile语句很灵活，它可以用来在任何条件为真的情况下重复执行一个代码块。一般情况下这样就够用了，但是有些时候还得量体裁衣。比如要为一个集合（序列和其他可迭代对象）的每个元素都执行一个代码块：可迭代对象是指可以按次序迭代的对象（也就是用于for循环中的）。\n因为迭代（循环的另外一种说法）某些范围的数字时很常见的，所有有个内建的范围函数共使用：\n>>>range(0,10)    #当要求0为下限时，也可以range(10)\n[0,1,2,3,4,5,6,7,8,9]\n还是左闭右开的范围。\n提示：如果能使用for循环，就尽量不用while循环。\nxrange函数的循环行为类似range函数，区别在于range函数一次创建整个序列，而xrange函数一次只创建一个数。但需要跌在一个巨大的序列时，xrange会更高效！不过一般情下不需要\n循环遍历字典元素\nd={'x':1.'y':2,'z':3}\nfor key in d:\n    print key,'cooreponds to',d[key]\n字典无序，如果顺序很重要的话，可以将键值保存在单独的列表中，例如在迭代前进行排序。\n一些迭代的工具\n在Python中迭代序列（或者其他可迭代对象）时，有一些函数非常好用。有些函数位于itertools模块中，还有一些python的内建函数也非常方便。\n1. 并行迭代-zip函数\n程序可以同时迭代两个序列。比如有下面两个列表：\nnames = ['michael','hh','qq']\nages = [24,23,55]\n#如果想要打印名字和对应的年龄，可以这么做\nfor i in range(len(names)):\n    print names[i],'is',ages[i],'years old'\n而内建的zip函数就可以进行并行迭代，可以把两个序列“压缩”在一起，然后返回一个元祖的列表：\n>>>zip(names,ages)\n[('michael', 24), ('hh', 23), ('qq', 55)]\n现在我可以在循环中解包元祖：\nfor name,age in zip(names,ages):\n    print name,'is',age,'years old'\nzip函数也可以作用于任意多的序列。关于它很重要的一点是zip可以处理不等长的序列，当最短的序列“用完”的时候就会停止：\n>>>zip(range(5),xrange(100000000))\n[(0,0),(1,1,),(2,2,),(3,3,),(4,4,)]\n在此处，就不推荐range代替xrange，因为我们只需要前5个数字，但是range会计算所有的数字，这要花费很长的时间。\n2. 按索引迭代-enumerate函数。\n有些时候想要迭代访问序列中的对象，同时还要获得当前对象的索引。\n例如，在一个字符串列表总替换所有包含'aaa'的子字符串。\nstrings=['aaa','bbb','ccc','aaa']\nfor index,string in enumerate(strings):\n    if 'aaa' in string:\n        strings[index]='xxx'\n>>>strings\n['xxx', 'bbb', 'ccc', 'xxx']\n这个函数可以提供索引的地方迭代索引-值对。\n3. 翻转和排序迭代。\n让我们看看两个有用的函数：reversed和sorted。它们同列表的reverse和sort（sorted和sort使用同样的参数）方法类似。但作用于任何序列或可迭代对象上，不是原地修改对象，而是返回翻转或者排序后的版本：\n>>>a=[2,1,4,3]\n>>>sorted(a)\n[1,2,3,4]\n>>>a\n[2,1,4,3]\n看见了吧，sorted不是原地修改对象！！！它是又返回值的，返回排序或者翻转后的版本！\n跳出循环\n\nbreak\ncontinue    跳出剩余的循环体，但不结束循环尽管continue语句非常有用，它却不是最本质的。应该习惯使用break语句，因为在while True语句中会经常用到它。\n\nwhile Ture/break习语\n哑值（dummy value）就是工作没有尽善尽美的标志。\n循环中的else语句\n当在循环内使用break语句时，通常是因为“找到”了某物或者因为某事“发生了”。\n在循环中增加一个else子句--它仅在没有调用break时执行。\nfrom math import sqrt\nfor n in range(99,0,-1):\n    root=sqrt(n)\n    if root ==int(root):\n        print n\n        break\nelse:\n    print \"Didn't find it\"\n列表推导式--轻量级循环\n列表推导式（list comprehension）是利用其它列表创建新列表的一种方法。它的工作方式类似于for循环，也很简单。\n>>>[x*x for x in range(10)]\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n可以通过增加if部分添加到列表推导式中，找出能被3整除的数：\n>>>[x*x for x in range(10) if x%3==0]\n[0,9,36,81]\n也可以增加更多for语句的部分：\n>>>[(x,y) for x in range(2) for y in range(3)]\n[(0,0),(0,1),(0,2),(1,0),(1,1),(1,2)]\n三人行\n作为本章的结束，让我们走马观花地看一下另外3个语句：pass、del、exec。\n什么都没发生\n有的时候，程序什么事情都不用做。这时候就该让pass出场了：\nif name =='michael':\n    print hello name\nelif name =='qq':\n    pass    #测试的时候，如果这里还没想好写什么可以用pass作占位符！因为python中空代码块是非法的，这里缺少一个语句块是不行的。\nelif name == 'bill':\n    print 'success'\n使用del删除\npython会删除那些不再使用的对象。\n>>>x1={'name':'michael','age':24}\n>>>x2=x1\n>>>x1=None\n>>>x2\n{'name':'michael','age':24}\n>>>x2=None\n当x1和x2同时设置为None时，字典就“漂”在内存里边了（我觉得书中的这个描述特别形象啊！），没有任何名字绑定到它上面。没有办法获取和使用它，所以，python解释器（以其无穷的智慧）直接删除了那个字典（这称为垃圾收集）。注意，也可以使用None之外的其他值。字典同样会“消失不见”。\n另外一个方法就是使用del语句（我们在第二章和第四章里边用来删除序列和字典元素的语句），它不仅会移除一个对象的引用，也会移除那个名字本身！！！\n什么叫移除名字本身？\n栗子1：\n>>>x = 1\n>>>del x\n>>>x\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\n<ipython-input-55-401b30e3b8b5> in <module>()\n----> 1 x\n \nNameError: name 'x' is not defined\n栗子2：\n>>>x=1\n>>>x=None\n>>>x\n栗子1和栗子2的结果可以发现，栗子2中再输入x时没有报错，说明名字本身没有被删除。而栗子1名字本身被删除了，也就是x删除了。\n但是，del也是没有把和名字绑定的值从内存中删除的！在python中是没有办法彻底删除值的（不需要过多考虑删除值的问题，因为在某个值不再使用的时候，python解释器会负责内存的回收）。\n使用exec和eval执行和求值字符串\n有些时候需要动态地创建python代码，然后将其作为语句执行或作为表达式计算，这可能近似于“黑暗魔法”——在此之前，一定要慎之又慎，仔细考虑。\n在此节中会学到如何执行存储在字符串中的python代码。这样做会有很严重的潜在安全漏洞。（p85）\nexec\n执行一个字符串的语句是exec:\n>>>exec 'print \"hello michael\"'\nhello michael\n注：在python3中，exec是一个函数而不是一个语句。\n但是，使用简单形式的exec语句绝不是好事。很多情况可以给它提供命名空间——可以放置变量的地方。你想这样做，从而使代码不会干扰命名空间。\neval\neval(用于“求值”）是类似于exec的内建函数。eval会计算python表达式（以字符串形式书写），并且返回结果值。（exec语句并不返回任何对象，因为它本身就是语句）。\n>>>eval(raw_input(\"enter an expression:\"))\nenter an expression:1+2\n3\neval也可以使用命名空间。\n本章小结\n总体来说，这章的内容算是复习吧，感想就是：\n一定要关注函数、方法它们的返回值！\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "13"}