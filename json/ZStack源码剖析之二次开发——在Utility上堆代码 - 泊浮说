{"title": "ZStack源码剖析之二次开发——在Utility上堆代码 - 泊浮说 ", "index": "zstack,python", "content": "本文首发于泊浮目的专栏：https://segmentfault.com/blog...\n\n背景\n在上篇文章中（ZStack源码剖析之二次开发——可扩展框架），我们简单的了解了一下ZStack核心引擎的二次开发技巧。在这篇文章中，我们将一起来了解ZStack-Utility（即ZStack的Agent端）的二开姿势。\n例子\n我们以ZStack管理节点调用startVm这个api为例子，一起来看一下在agent上的执行逻辑。\n    def start(self):\n        http_server = kvmagent.get_http_server()\n\n        http_server.register_async_uri(self.KVM_START_VM_PATH, self.start_vm)\n首先，得注册一个http path用来接受reqeust。\n    @kvmagent.replyerror\n    def start_vm(self, req):\n        cmd = jsonobject.loads(req[http.REQUEST_BODY])\n        rsp = StartVmResponse()\n        try:\n            self._record_operation(cmd.vmInstanceUuid, self.VM_OP_START)\n\n            self._start_vm(cmd)\n            logger.debug('successfully started vm[uuid:%s, name:%s]' % (cmd.vmInstanceUuid, cmd.vmName))\n        except kvmagent.KvmError as e:\n            e_str = linux.get_exception_stacktrace()\n            logger.warn(e_str)\n            if \"burst\" in e_str and \"Illegal\" in e_str and \"rate\" in e_str:\n                rsp.error = \"QoS exceed max limit, please check and reset it in zstack\"\n            elif \"cannot set up guest memory\" in e_str:\n                logger.warn('unable to start vm[uuid:%s], %s' % (cmd.vmInstanceUuid, e_str))\n                rsp.error = \"No enough physical memory for guest\"\n            else:\n                rsp.error = e_str\n            err = self.handle_vfio_irq_conflict(cmd.vmInstanceUuid)\n            if err != \"\":\n                rsp.error = \"%s, details: %s\" % (err, rsp.error)\n            rsp.success = False\n        return jsonobject.dumps(rsp)\n直接进入主干逻辑，self._start_vm(cmd)。\n    @lock.lock('libvirt-startvm')\n    def _start_vm(self, cmd):\n        try:\n            vm = get_vm_by_uuid_no_retry(cmd.vmInstanceUuid, False)\n\n            if vm:\n                if vm.state == Vm.VM_STATE_RUNNING:\n                    raise kvmagent.KvmError(\n                        'vm[uuid:%s, name:%s] is already running' % (cmd.vmInstanceUuid, vm.get_name()))\n                else:\n                    vm.destroy()\n\n            vm = Vm.from_StartVmCmd(cmd)\n            vm.start(cmd.timeout)\n        except libvirt.libvirtError as e:\n            logger.warn(linux.get_exception_stacktrace())\n            if \"Device or resource busy\" in str(e.message):\n                raise kvmagent.KvmError(\n                    'unable to start vm[uuid:%s, name:%s], libvirt error: %s' % (\n                    cmd.vmInstanceUuid, cmd.vmName, str(e)))\n\n            try:\n                vm = get_vm_by_uuid(cmd.vmInstanceUuid)\n                if vm and vm.state != Vm.VM_STATE_RUNNING:\n                    raise kvmagent.KvmError(\n                       'vm[uuid:%s, name:%s, state:%s] is not in running state, libvirt error: %s' % (\n                        cmd.vmInstanceUuid, cmd.vmName, vm.state, str(e)))\n\n            except kvmagent.KvmError:\n                raise kvmagent.KvmError(\n                    'unable to start vm[uuid:%s, name:%s], libvirt error: %s' % (cmd.vmInstanceUuid, cmd.vmName, str(e)))\n关键逻辑：\n            vm = Vm.from_StartVmCmd(cmd)\n            vm.start(cmd.timeout)\n先看from_StartVmCmd\n    @staticmethod\n    def from_StartVmCmd(cmd):\n        use_virtio = cmd.useVirtio\n        use_numa = cmd.useNuma\n\n        elements = {}\n\n        def make_root():\n            root = etree.Element('domain')\n            root.set('type', 'kvm')\n            # self._root.set('type', 'qemu')\n            root.set('xmlns:qemu', 'http://libvirt.org/schemas/domain/qemu/1.0')\n            elements['root'] = root\n\n        def make_cpu():\n            if use_numa:\n                root = elements['root']\n                e(root, 'vcpu', '128', {'placement': 'static', 'current': str(cmd.cpuNum)})\n                # e(root,'vcpu',str(cmd.cpuNum),{'placement':'static'})\n                tune = e(root, 'cputune')\n                e(tune, 'shares', str(cmd.cpuSpeed * cmd.cpuNum))\n                # enable nested virtualization\n                if cmd.nestedVirtualization == 'host-model':\n                    cpu = e(root, 'cpu', attrib={'mode': 'host-model'})\n                    e(cpu, 'model', attrib={'fallback': 'allow'})\n                elif cmd.nestedVirtualization == 'host-passthrough':\n                    cpu = e(root, 'cpu', attrib={'mode': 'host-passthrough'})\n                    e(cpu, 'model', attrib={'fallback': 'allow'})\n                elif IS_AARCH64:\n                    cpu = e(root, 'cpu', attrib={'mode': 'host-passthrough'})\n                    e(cpu, 'model', attrib={'fallback': 'allow'})\n                else:\n                    cpu = e(root, 'cpu')\n                    # e(cpu, 'topology', attrib={'sockets': str(cmd.socketNum), 'cores': str(cmd.cpuOnSocket), 'threads': '1'})\n                mem = cmd.memory / 1024\n                e(cpu, 'topology', attrib={'sockets': str(32), 'cores': str(4), 'threads': '1'})\n                numa = e(cpu, 'numa')\n                e(numa, 'cell', attrib={'id': '0', 'cpus': '0-127', 'memory': str(mem), 'unit': 'KiB'})\n            else:\n                root = elements['root']\n                # e(root, 'vcpu', '128', {'placement': 'static', 'current': str(cmd.cpuNum)})\n                e(root, 'vcpu', str(cmd.cpuNum), {'placement': 'static'})\n                tune = e(root, 'cputune')\n                e(tune, 'shares', str(cmd.cpuSpeed * cmd.cpuNum))\n                # enable nested virtualization\n                if cmd.nestedVirtualization == 'host-model':\n                    cpu = e(root, 'cpu', attrib={'mode': 'host-model'})\n                    e(cpu, 'model', attrib={'fallback': 'allow'})\n                elif cmd.nestedVirtualization == 'host-passthrough':\n                    cpu = e(root, 'cpu', attrib={'mode': 'host-passthrough'})\n                    e(cpu, 'model', attrib={'fallback': 'allow'})\n                elif IS_AARCH64:\n                    cpu = e(root, 'cpu', attrib={'mode': 'host-passthrough'})\n                    e(cpu, 'model', attrib={'fallback': 'allow'})\n                else:\n                    cpu = e(root, 'cpu')\n                e(cpu, 'topology', attrib={'sockets': str(cmd.socketNum), 'cores': str(cmd.cpuOnSocket), 'threads': '1'})\n\n        def make_memory():\n            root = elements['root']\n            mem = cmd.memory / 1024\n            if use_numa:\n                e(root, 'maxMemory', str(68719476736), {'slots': str(16), 'unit': 'KiB'})\n                # e(root,'memory',str(mem),{'unit':'k'})\n                e(root, 'currentMemory', str(mem), {'unit': 'k'})\n            else:\n                e(root, 'memory', str(mem), {'unit': 'k'})\n                e(root, 'currentMemory', str(mem), {'unit': 'k'})\n\n        def make_os():\n            root = elements['root']\n            os = e(root, 'os')\n            if IS_AARCH64:\n                e(os, 'type', 'hvm', attrib={'arch': 'aarch64'})\n                e(os, 'loader', '/usr/share/edk2.git/aarch64/QEMU_EFI-pflash.raw', attrib={'readonly': 'yes', 'type': 'pflash'})\n            else:\n                e(os, 'type', 'hvm', attrib={'machine': 'pc'})\n            # if not booting from cdrom, don't add any boot element in os section\n            if cmd.bootDev[0] == \"cdrom\":\n                for boot_dev in cmd.bootDev:\n                    e(os, 'boot', None, {'dev': boot_dev})\n\n            if cmd.useBootMenu:\n                e(os, 'bootmenu', attrib={'enable': 'yes'})\n\n        def make_features():\n            root = elements['root']\n            features = e(root, 'features')\n            for f in ['acpi', 'apic', 'pae']:\n                e(features, f)\n            if cmd.kvmHiddenState == True:\n                kvm = e(features, \"kvm\")\n                e(kvm, 'hidden', None, {'state': 'on'})\n\n        def make_devices():\n            root = elements['root']\n            devices = e(root, 'devices')\n            if cmd.addons and cmd.addons['qemuPath']:\n                e(devices, 'emulator', cmd.addons['qemuPath'])\n            else:\n                e(devices, 'emulator', kvmagent.get_qemu_path())\n            tablet = e(devices, 'input', None, {'type': 'tablet', 'bus': 'usb'})\n            e(tablet, 'address', None, {'type':'usb', 'bus':'0', 'port':'1'})\n            if IS_AARCH64:\n                keyboard = e(devices, 'input', None, {'type': 'keyboard', 'bus': 'usb'})\n            elements['devices'] = devices\n\n        def make_cdrom():\n            devices = elements['devices']\n\n            MAX_CDROM_NUM = len(Vm.ISO_DEVICE_LETTERS)\n            EMPTY_CDROM_CONFIGS = None\n\n            if IS_AARCH64:\n                # AArch64 Does not support the attachment of multiple iso\n                EMPTY_CDROM_CONFIGS = [\n                    EmptyCdromConfig(None, None, None)\n                ]\n            else:\n                # bus 0 unit 0 already use by root volume\n                EMPTY_CDROM_CONFIGS = [\n                    EmptyCdromConfig('hd%s' % Vm.ISO_DEVICE_LETTERS[0], '0', '1'),\n                    EmptyCdromConfig('hd%s' % Vm.ISO_DEVICE_LETTERS[1], '1', '0'),\n                    EmptyCdromConfig('hd%s' % Vm.ISO_DEVICE_LETTERS[2], '1', '1')\n                ]\n\n            if len(EMPTY_CDROM_CONFIGS) != MAX_CDROM_NUM:\n                logger.error('ISO_DEVICE_LETTERS or EMPTY_CDROM_CONFIGS config error')\n\n            def makeEmptyCdrom(targetDev, bus, unit):\n                cdrom = e(devices, 'disk', None, {'type': 'file', 'device': 'cdrom'})\n                e(cdrom, 'driver', None, {'name': 'qemu', 'type': 'raw'})\n                if IS_AARCH64:\n                    e(cdrom, 'target', None, {'dev': 'sdc', 'bus': 'scsi'})\n                else:\n                    e(cdrom, 'target', None, {'dev': targetDev, 'bus': 'ide'})\n                    e(cdrom, 'address', None,{'type' : 'drive', 'bus' : bus, 'unit' : unit})\n                e(cdrom, 'readonly', None)\n                return cdrom\n\n            if not cmd.bootIso:\n                for config in EMPTY_CDROM_CONFIGS:\n                    makeEmptyCdrom(config.targetDev, config.bus, config.unit)\n                return\n\n            notEmptyCdrom = set([])\n            for iso in cmd.bootIso:\n                notEmptyCdrom.add(iso.deviceId)\n                cdromConfig = EMPTY_CDROM_CONFIGS[iso.deviceId]\n                if iso.path.startswith('ceph'):\n                    ic = IsoCeph()\n                    ic.iso = iso\n                    devices.append(ic.to_xmlobject(cdromConfig.targetDev, cdromConfig.bus , cdromConfig.unit))\n                elif iso.path.startswith('fusionstor'):\n                    ic = IsoFusionstor()\n                    ic.iso = iso\n                    devices.append(ic.to_xmlobject(cdromConfig.targetDev, cdromConfig.bus , cdromConfig.unit))\n                else:\n                    cdrom = makeEmptyCdrom(cdromConfig.targetDev, cdromConfig.bus , cdromConfig.unit)\n                    e(cdrom, 'source', None, {'file': iso.path})\n\n            emptyCdrom = set(range(MAX_CDROM_NUM)).difference(notEmptyCdrom)\n            for i in emptyCdrom:\n                cdromConfig = EMPTY_CDROM_CONFIGS[i]\n                makeEmptyCdrom(cdromConfig.targetDev, cdromConfig.bus, cdromConfig.unit)\n\n        def make_volumes():\n            devices = elements['devices']\n            volumes = [cmd.rootVolume]\n            volumes.extend(cmd.dataVolumes)\n\n            def filebased_volume(_dev_letter, _v):\n                disk = etree.Element('disk', {'type': 'file', 'device': 'disk', 'snapshot': 'external'})\n                e(disk, 'driver', None, {'name': 'qemu', 'type': linux.get_img_fmt(_v.installPath), 'cache': _v.cacheMode})\n                e(disk, 'source', None, {'file': _v.installPath})\n\n                if _v.shareable:\n                    e(disk, 'shareable')\n\n                if _v.useVirtioSCSI:\n                    e(disk, 'target', None, {'dev': 'sd%s' % _dev_letter, 'bus': 'scsi'})\n                    e(disk, 'wwn', _v.wwn)\n                    e(disk, 'address', None, {'type': 'drive', 'controller': '0', 'unit': str(_v.deviceId)})\n                    return disk\n\n                if _v.useVirtio:\n                    e(disk, 'target', None, {'dev': 'vd%s' % _dev_letter, 'bus': 'virtio'})\n                elif IS_AARCH64:\n                    e(disk, 'target', None, {'dev': 'sd%s' % _dev_letter, 'bus': 'scsi'})\n                else:\n                    e(disk, 'target', None, {'dev': 'sd%s' % _dev_letter, 'bus': 'ide'})\n                return disk\n\n            def iscsibased_volume(_dev_letter, _v):\n                def blk_iscsi():\n                    bi = BlkIscsi()\n                    portal, bi.target, bi.lun = _v.installPath.lstrip('iscsi://').split('/')\n                    bi.server_hostname, bi.server_port = portal.split(':')\n                    bi.device_letter = _dev_letter\n                    bi.volume_uuid = _v.volumeUuid\n                    bi.chap_username = _v.chapUsername\n                    bi.chap_password = _v.chapPassword\n\n                    return bi.to_xmlobject()\n\n                def virtio_iscsi():\n                    vi = VirtioIscsi()\n                    portal, vi.target, vi.lun = _v.installPath.lstrip('iscsi://').split('/')\n                    vi.server_hostname, vi.server_port = portal.split(':')\n                    vi.device_letter = _dev_letter\n                    vi.volume_uuid = _v.volumeUuid\n                    vi.chap_username = _v.chapUsername\n                    vi.chap_password = _v.chapPassword\n\n                    return vi.to_xmlobject()\n\n                if _v.useVirtio:\n                    return virtio_iscsi()\n                else:\n                    return blk_iscsi()\n\n            def ceph_volume(_dev_letter, _v):\n                def ceph_virtio():\n                    vc = VirtioCeph()\n                    vc.volume = _v\n                    vc.dev_letter = _dev_letter\n                    return vc.to_xmlobject()\n\n                def ceph_blk():\n                    if not IS_AARCH64:\n                        ic = IdeCeph()\n                    else:\n                        ic = ScsiCeph()\n                    ic.volume = _v\n                    ic.dev_letter = _dev_letter\n                    return ic.to_xmlobject()\n\n                def ceph_virtio_scsi():\n                    vsc = VirtioSCSICeph()\n                    vsc.volume = _v\n                    vsc.dev_letter = _dev_letter\n                    return vsc.to_xmlobject()\n\n                if _v.useVirtioSCSI:\n                    disk = ceph_virtio_scsi()\n                    if _v.shareable:\n                        e(disk, 'shareable')\n                    return disk\n\n                if _v.useVirtio:\n                    return ceph_virtio()\n                else:\n                    return ceph_blk()\n\n            def fusionstor_volume(_dev_letter, _v):\n                def fusionstor_virtio():\n                    vc = VirtioFusionstor()\n                    vc.volume = _v\n                    vc.dev_letter = _dev_letter\n                    return vc.to_xmlobject()\n\n                def fusionstor_blk():\n                    ic = IdeFusionstor()\n                    ic.volume = _v\n                    ic.dev_letter = _dev_letter\n                    return ic.to_xmlobject()\n\n                def fusionstor_virtio_scsi():\n                    vsc = VirtioSCSIFusionstor()\n                    vsc.volume = _v\n                    vsc.dev_letter = _dev_letter\n                    return vsc.to_xmlobject()\n\n                if _v.useVirtioSCSI:\n                    disk = fusionstor_virtio_scsi()\n                    if _v.shareable:\n                        e(disk, 'shareable')\n                    return disk\n\n                if _v.useVirtio:\n                    return fusionstor_virtio()\n                else:\n                    return fusionstor_blk()\n\n            def volume_qos(volume_xml_obj):\n                if not cmd.addons:\n                    return\n\n                vol_qos = cmd.addons['VolumeQos']\n                if not vol_qos:\n                    return\n\n                qos = vol_qos[v.volumeUuid]\n                if not qos:\n                    return\n\n                if not qos.totalBandwidth and not qos.totalIops:\n                    return\n\n                iotune = e(volume_xml_obj, 'iotune')\n                if qos.totalBandwidth:\n                    e(iotune, 'total_bytes_sec', str(qos.totalBandwidth))\n                if qos.totalIops:\n                    # e(iotune, 'total_iops_sec', str(qos.totalIops))\n                    e(iotune, 'read_iops_sec', str(qos.totalIops))\n                    e(iotune, 'write_iops_sec', str(qos.totalIops))\n                    # e(iotune, 'read_iops_sec_max', str(qos.totalIops))\n                    # e(iotune, 'write_iops_sec_max', str(qos.totalIops))\n                    # e(iotune, 'total_iops_sec_max', str(qos.totalIops))\n\n            volumes.sort(key=lambda d: d.deviceId)\n            scsi_device_ids = [v.deviceId for v in volumes if v.useVirtioSCSI]\n            for v in volumes:\n                if v.deviceId >= len(Vm.DEVICE_LETTERS):\n                    err = \"exceeds max disk limit, it's %s but only 26 allowed\" % v.deviceId\n                    logger.warn(err)\n                    raise kvmagent.KvmError(err)\n\n                dev_letter = Vm.DEVICE_LETTERS[v.deviceId]\n                if v.useVirtioSCSI:\n                    dev_letter = Vm.DEVICE_LETTERS[scsi_device_ids.pop()]\n\n                if v.deviceType == 'file':\n                    vol = filebased_volume(dev_letter, v)\n                elif v.deviceType == 'iscsi':\n                    vol = iscsibased_volume(dev_letter, v)\n                elif v.deviceType == 'ceph':\n                    vol = ceph_volume(dev_letter, v)\n                elif v.deviceType == 'fusionstor':\n                    vol = fusionstor_volume(dev_letter, v)\n                else:\n                    raise Exception('unknown volume deviceType: %s' % v.deviceType)\n\n                assert vol is not None, 'vol cannot be None'\n                # set boot order for root volume when boot from hd\n                if v.deviceId == 0 and cmd.bootDev[0] == 'hd' and cmd.useBootMenu:\n                    e(vol, 'boot', None, {'order': '1'})\n                volume_qos(vol)\n                devices.append(vol)\n\n        def make_nics():\n            if not cmd.nics:\n                return\n\n            def nic_qos(nic_xml_object):\n                if not cmd.addons:\n                    return\n\n                nqos = cmd.addons['NicQos']\n                if not nqos:\n                    return\n\n                qos = nqos[nic.uuid]\n                if not qos:\n                    return\n\n                if not qos.outboundBandwidth and not qos.inboundBandwidth:\n                    return\n\n                bandwidth = e(nic_xml_object, 'bandwidth')\n                if qos.outboundBandwidth:\n                    e(bandwidth, 'outbound', None, {'average': str(qos.outboundBandwidth / 1024 / 8)})\n                if qos.inboundBandwidth:\n                    e(bandwidth, 'inbound', None, {'average': str(qos.inboundBandwidth / 1024 / 8)})\n\n            devices = elements['devices']\n            for nic in cmd.nics:\n                interface = e(devices, 'interface', None, {'type': 'bridge'})\n                e(interface, 'mac', None, {'address': nic.mac})\n                if nic.ip is not None and nic.ip != \"\":\n                    filterref = e(interface, 'filterref', None, {'filter':'clean-traffic'})\n                    e(filterref, 'parameter', None, {'name':'IP', 'value': nic.ip})\n                e(interface, 'alias', None, {'name': 'net%s' % nic.nicInternalName.split('.')[1]})\n                e(interface, 'source', None, {'bridge': nic.bridgeName})\n                if use_virtio:\n                    e(interface, 'model', None, {'type': 'virtio'})\n                else:\n                    e(interface, 'model', None, {'type': 'e1000'})\n                e(interface, 'target', None, {'dev': nic.nicInternalName})\n\n                nic_qos(interface)\n\n        def make_meta():\n            root = elements['root']\n\n            e(root, 'name', cmd.vmInstanceUuid)\n            e(root, 'uuid', uuidhelper.to_full_uuid(cmd.vmInstanceUuid))\n            e(root, 'description', cmd.vmName)\n            e(root, 'on_poweroff', 'destroy')\n            e(root, 'on_crash', 'restart')\n            e(root, 'on_reboot', 'restart')\n            meta = e(root, 'metadata')\n            zs = e(meta, 'zstack', usenamesapce=True)\n            e(zs, 'internalId', str(cmd.vmInternalId))\n            e(zs, 'hostManagementIp', str(cmd.hostManagementIp))\n            clock = e(root, 'clock', None, {'offset': cmd.clock})\n            if cmd.clock == 'localtime':\n                e(clock, 'timer', None, {'name': 'rtc', 'tickpolicy': 'catchup'})\n                e(clock, 'timer', None, {'name': 'pit', 'tickpolicy': 'delay'})\n                e(clock, 'timer', None, {'name': 'hpet', 'present': 'no'})\n                e(clock, 'timer', None, {'name': 'hypervclock', 'present': 'yes'})\n\n        def make_vnc():\n            devices = elements['devices']\n            if cmd.consolePassword == None:\n                vnc = e(devices, 'graphics', None, {'type': 'vnc', 'port': '5900', 'autoport': 'yes'})\n            else:\n                vnc = e(devices, 'graphics', None,\n                        {'type': 'vnc', 'port': '5900', 'autoport': 'yes', 'passwd': str(cmd.consolePassword)})\n            e(vnc, \"listen\", None, {'type': 'address', 'address': '0.0.0.0'})\n\n        def make_spice():\n            devices = elements['devices']\n            spice = e(devices, 'graphics', None, {'type': 'spice', 'port': '5900', 'autoport': 'yes'})\n            e(spice, \"listen\", None, {'type': 'address', 'address': '0.0.0.0'})\n            e(spice, \"image\", None, {'compression': 'auto_glz'})\n            e(spice, \"jpeg\", None, {'compression': 'always'})\n            e(spice, \"zlib\", None, {'compression': 'never'})\n            e(spice, \"playback\", None, {'compression': 'off'})\n            e(spice, \"streaming\", None, {'mode': cmd.spiceStreamingMode})\n            e(spice, \"mouse\", None, {'mode': 'client'})\n            e(spice, \"filetransfer\", None, {'enable': 'no'})\n            e(spice, \"clipboard\", None, {'copypaste': 'no'})\n\n        def make_usb_redirect():\n            if cmd.usbRedirect == \"true\":\n                devices = elements['devices']\n                e(devices, 'controller', None, {'type': 'usb', 'model': 'ich9-ehci1'})\n                e(devices, 'controller', None, {'type': 'usb', 'model': 'ich9-uhci1', 'multifunction': 'on'})\n                e(devices, 'controller', None, {'type': 'usb', 'model': 'ich9-uhci2'})\n                e(devices, 'controller', None, {'type': 'usb', 'model': 'ich9-uhci3'})\n\n                chan = e(devices, 'channel', None, {'type': 'spicevmc'})\n                e(chan, 'target', None, {'type': 'virtio', 'name': 'com.redhat.spice.0'})\n                e(chan, 'address', None, {'type': 'virtio-serial'})\n\n                redirdev2 = e(devices, 'redirdev', None, {'type': 'spicevmc', 'bus': 'usb'})\n                e(redirdev2, 'address', None, {'type': 'usb', 'bus': '0', 'port': '2'})\n                redirdev3 = e(devices, 'redirdev', None, {'type': 'spicevmc', 'bus': 'usb'})\n                e(redirdev3, 'address', None, {'type': 'usb', 'bus': '0', 'port': '3'})\n                redirdev4 = e(devices, 'redirdev', None, {'type': 'spicevmc', 'bus': 'usb'})\n                e(redirdev4, 'address', None, {'type': 'usb', 'bus': '0', 'port': '4'})\n                redirdev5 = e(devices, 'redirdev', None, {'type': 'spicevmc', 'bus': 'usb'})\n                e(redirdev5, 'address', None, {'type': 'usb', 'bus': '0', 'port': '6'})\n            else:\n                # make sure there are three default usb controllers, for usb 1.1/2.0/3.0\n                devices = elements['devices']\n                e(devices, 'controller', None, {'type': 'usb', 'index': '0'})\n                if not IS_AARCH64:\n                    e(devices, 'controller', None, {'type': 'usb', 'index': '1', 'model': 'ehci'})\n                    e(devices, 'controller', None, {'type': 'usb', 'index': '2', 'model': 'nec-xhci'})\n\n        def make_video():\n            devices = elements['devices']\n            if IS_AARCH64:\n                video = e(devices, 'video')\n                e(video, 'model', None, {'type': 'virtio'})\n            elif cmd.videoType != \"qxl\":\n                video = e(devices, 'video')\n                e(video, 'model', None, {'type': str(cmd.videoType)})\n            else:\n                for monitor in range(cmd.VDIMonitorNumber):\n                    video = e(devices, 'video')\n                    e(video, 'model', None, {'type': str(cmd.videoType)})\n\n\n        def make_audio_microphone():\n            if cmd.consoleMode == 'spice':\n                devices = elements['devices']\n                e(devices, 'sound',None,{'model':'ich6'})\n            else:\n                return\n\n        def make_graphic_console():\n            if cmd.consoleMode == 'spice':\n                make_spice()\n            else:\n                make_vnc()\n\n        def make_addons():\n            if not cmd.addons:\n                return\n\n            devices = elements['devices']\n            channel = cmd.addons['channel']\n            if channel:\n                basedir = os.path.dirname(channel.socketPath)\n                linux.mkdir(basedir, 0777)\n                chan = e(devices, 'channel', None, {'type': 'unix'})\n                e(chan, 'source', None, {'mode': 'bind', 'path': channel.socketPath})\n                e(chan, 'target', None, {'type': 'virtio', 'name': channel.targetName})\n\n            cephSecretKey = cmd.addons['ceph_secret_key']\n            cephSecretUuid = cmd.addons['ceph_secret_uuid']\n            if cephSecretKey and cephSecretUuid:\n                VmPlugin._create_ceph_secret_key(cephSecretKey, cephSecretUuid)\n\n            pciDevices = cmd.addons['pciDevice']\n            if pciDevices:\n                make_pci_device(pciDevices)\n\n            usbDevices = cmd.addons['usbDevice']\n            if usbDevices:\n                make_usb_device(usbDevices)\n\n        def make_pci_device(addresses):\n            devices = elements['devices']\n            for addr in addresses:\n                if match_pci_device(addr):\n                    hostdev = e(devices, \"hostdev\", None, {'mode': 'subsystem', 'type': 'pci', 'managed': 'yes'})\n                    e(hostdev, \"driver\", None, {'name': 'vfio'})\n                    source = e(hostdev, \"source\")\n                    e(source, \"address\", None, {\n                        \"domain\": hex(0) if len(addr.split(\":\")) == 2 else hex(int(addr.split(\":\")[0], 16)),\n                        \"bus\": hex(int(addr.split(\":\")[-2], 16)),\n                        \"slot\": hex(int(addr.split(\":\")[-1].split(\".\")[0], 16)),\n                        \"function\": hex(int(addr.split(\":\")[-1].split(\".\")[1], 16))\n                    })\n                else:\n                    raise kvmagent.KvmError(\n                       'can not find pci device for address %s' % addr)\n\n        def make_usb_device(usbDevices):\n            next_uhci_port = 2\n            next_ehci_port = 1\n            next_xhci_port = 1\n            devices = elements['devices']\n            for usb in usbDevices:\n                if match_usb_device(usb):\n                    hostdev = e(devices, \"hostdev\", None, {'mode': 'subsystem', 'type': 'usb', 'managed': 'yes'})\n                    source = e(hostdev, \"source\")\n                    e(source, \"address\", None, {\n                        \"bus\": str(int(usb.split(\":\")[0])),\n                        \"device\": str(int(usb.split(\":\")[1]))\n                    })\n                    e(source, \"vendor\", None, {\n                        \"id\": hex(int(usb.split(\":\")[2], 16))\n                    })\n                    e(source, \"product\", None, {\n                        \"id\": hex(int(usb.split(\":\")[3], 16))\n                    })\n\n                    # get controller index from usbVersion\n                    # eg. 1.1 -> 0\n                    # eg. 2.0.0 -> 1\n                    # eg. 3 -> 2\n                    bus = int(usb.split(\":\")[4][0]) - 1\n                    if bus == 0:\n                        address = e(hostdev, \"address\", None, {'type': 'usb', 'bus': str(bus), 'port': str(next_uhci_port)})\n                        next_uhci_port += 1\n                    elif bus == 1:\n                        address = e(hostdev, \"address\", None, {'type': 'usb', 'bus': str(bus), 'port': str(next_ehci_port)})\n                        next_ehci_port += 1\n                    elif bus == 2:\n                        address = e(hostdev, \"address\", None, {'type': 'usb', 'bus': str(bus), 'port': str(next_xhci_port)})\n                        next_xhci_port += 1\n                    else:\n                        raise kvmagent.KvmError('unknown usb controller %s', bus)\n                else:\n                    raise kvmagent.KvmError('cannot find usb device %s', usb)\n\n        # TODO(WeiW) Validate here\n        def match_pci_device(addr):\n            return True\n\n        def match_usb_device(addr):\n            if len(addr.split(':')) == 5:\n                return True\n            else:\n                return False\n\n        def make_balloon_memory():\n            devices = elements['devices']\n            b = e(devices, 'memballoon', None, {'model': 'virtio'})\n            e(b, 'stats', None, {'period': '10'})\n\n        def make_console():\n            devices = elements['devices']\n            serial = e(devices, 'serial', None, {'type': 'pty'})\n            e(serial, 'target', None, {'port': '0'})\n            console = e(devices, 'console', None, {'type': 'pty'})\n            e(console, 'target', None, {'type': 'serial', 'port': '0'})\n\n        def make_sec_label():\n            root = elements['root']\n            e(root, 'seclabel', None, {'type': 'none'})\n\n        def make_controllers():\n            devices = elements['devices']\n            e(devices, 'controller', None, {'type': 'scsi', 'model': 'virtio-scsi'})\n\n        make_root()\n        make_meta()\n        make_cpu()\n        make_memory()\n        make_os()\n        make_features()\n        make_devices()\n        make_video()\n        make_audio_microphone()\n        make_nics()\n        make_volumes()\n        make_cdrom()\n        make_graphic_console()\n        make_usb_redirect()\n        make_addons()\n        make_balloon_memory()\n        make_console()\n        make_sec_label()\n        make_controllers()\n\n        root = elements['root']\n        xml = etree.tostring(root)\n\n        vm = Vm()\n        vm.uuid = cmd.vmInstanceUuid\n        vm.domain_xml = xml\n        vm.domain_xmlobject = xmlobject.loads(xml)\n        return vm\n显然，上述逻辑是在组装一份xml，便于之后的libvirt使用。\n然后是\n vm.start(cmd.timeout)\n可以看到，这里是直接调用了libvirt的sdk。\n这仅仅是一个调用流程。而在很多地方，来自MN的请求会直接调用linux的shell命令，详情见linux.py。（获取云盘大小、主存储容量等）。\n问题\n在基于扩展ZStack的Agent时，如果是一个全新的功能模块，可能并不会造成和原有代码的深度耦合。但如果在原有功能上的增强， 对原有代码进行修改可能会导致我们的业务逻辑和Utility的上游代码耦合。而在没有足够人力来维护、开发ZStack时，我们会将目标定为能够及时跟上发布版本。 因此，我们要尽量减少冲突。\n举个例子：我们要对启动vm的逻辑进行增强，添加一个自己的配置写入xml。这段代码如果写进了vm_plugin.py，那么就是一个耦合。耦合多了以后，跟上发布版本就会很困难。\n解决方案\n这是一个参考方案：\n如果是引入一个全新的功能模块，建议重写一个项目。无论是代码规范还是自动化测试，都可以有一个很好的实践。\n如果是基于Utility的扩展，比如对于扩展的api——APIStartVmInstanceExMsg。由上游发送http request时，将指定v2版本的agent。比如原有start vm会发送至path：AGENT_IP:7070/vm/start；而如果我们增强了这部分逻辑，将这段代码copy至vm_plugin_ex.py，并注册一个path，ex/vm/start。当然port也要重新注册一个，就像这样：：AGENT_IP:7071/ex/vm/start。\n同样的，对linux.py扩展时，复制一个linux2.py来存放属于我们自己的扩展逻辑。\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "2"}