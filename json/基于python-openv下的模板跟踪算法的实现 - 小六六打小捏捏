{"title": "基于python-openv下的模板跟踪算法的实现 - 小六六打小捏捏 ", "index": "windows-server,python", "content": "前几周搞了一个基于模板跟踪的算法实现。即在视频中跟踪出模板目标闲话不多说，直接程序给出：\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Thu Jun 30 09:13:24 2016\n\n@author: liu\n\"\"\"  \nimport cv2\nimport numpy as np\n\nfrom matplotlib import pyplot as plt\n#img = cv2.imread('xucaise.jpg',0)\n\n#template = cv2.imread('xuxu.jpg',0)\ntemplate = cv2.imread('ppp.png',0)\nw, h = template.shape[::-1]\n\n#s1=cv2.imread('xupanmu.jpg',cv2.IMREAD_GRAYSCALE)\n#s1 = cv2.imread(ph1)\n#s2 = cv2.imread(ph2)\nmethods = ['cv2.TM_SQDIFF_NORMED']\n#methods = ['cv2.TM_CCOEFF_NORMED']#平方差匹配法，最好的匹配为0，值越大匹配越差；\n       \ncap = cv2.VideoCapture('double.mov')\n\nret,frame = cap.read()\nc=0\ntime=10\na=1\nwhile ret:\n    \n    ret ,frame = cap.read()\n    c=c+1\n    if ret == True:\n        \n    \n        if (c%time==0):\n            for meth in methods:\n                \n                 method = cv2.TM_SQDIFF_NORMED#eval(meth)\n                 cv2.imwrite('xuphoto'+str(c)+'.png',frame)\n                 s2=cv2.imread('xuphoto'+str(c)+'.png',0)\n                 #s2=frame\n                 #img = cv2.imread('xucaise.jpg',0)\n                 res = cv2.matchTemplate(s2,template,method)\n                 #cv2.imwrite('pp'+str(c)+'.jpg',res)\n               \n                 min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)\n                 if method in [cv2.TM_SQDIFF, cv2.TM_SQDIFF_NORMED]:\n                     top_left = min_loc\n                 else:\n                     top_left = max_loc\n                 #top_left = max_loc\n                 bottom_right = (top_left[0] + w +100, top_left[1] + h +100 )\n                 cv2.rectangle(s2,top_left, bottom_right, 255, 2)\n                 #cv2.imshow('img2',s2)\n                 cv2.imwrite('iphone'+str(c)+'.png',s2)\n                 \n                 plt.subplot(121),plt.imshow(res,cmap = 'gray')\n                 plt.title('Matching Result'), plt.xticks([]), plt.yticks([])\n                # cv2.imwrite('ccc'+str(c)+'.jpg',res)\n                 plt.subplot(122),plt.imshow(s2,cmap = 'gray')\n                 plt.title('Detected Point'), plt.xticks([]), plt.yticks([])\n                 \n                 \n                 \n                 plt.suptitle('cv2.TM_SQDIFF_NORMED')\n                 #plt.suptitle('cv2.TM_CCOEFF_NORMED')\n                 \n                 plt.show()\n                 \n                 \n                 #k = cv2.waitKey(60) & 0xff\n                 #if k == 27:\n                  #   break\n                #pic_sub(emptyimg,s1,s2)  \n                \n                \n                 if c>200:\n                \n                     c=0\n    \ncv2.destroyAllWindows()\ncap.release()\n\n\n\n\n\n程序目前是这些，如有看不懂的地方可以和我交流：liushengkai008@163.com这个实现的结果就是能够跟踪我们选取的模板目标。但是对于模板的选取我们也需要小心点，要不然会跟踪丢失。这个你们用了之后会发现其中的小奥秘。后期我会使用kinnect传感器来进行对于视觉的处理，请大家耐心等待哦\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}