{"title": "python设计模式-单例模式 - 古寺比的寺 ", "index": "单例模式,python,设计模式", "content": "问题：现代化的巧克力工厂具备计算机控制的巧克力锅炉。锅炉做的事情就是把巧克力和牛奶融在一起，然后送到下一个阶段，以制成巧克力棒。下边是一个巧克力公司锅炉控制器的代码，仔细观察一下，这段代码有什么问题？\nclass ChocolateBoiler(object):\n\n    def __init__(self):\n        self.empty = True\n        self.boiled = False\n\n    def fill(self):\n        # 向锅炉填充巧克力和牛奶混合物\n        # 在锅炉内填充原料时，锅炉必须是空的。\n        # 一旦填入原料，就要把empty 和 boiled 标志设置好\n        if self.empty:\n            self.empty = False\n            self.boiled = False\n\n    def drain(self):\n        # 排出煮沸的巧克力和牛奶\n        # 锅炉排出时，必须是满的且煮沸的。\n        # 排出完毕empty 设置为 true\n        if not self.empty and self.boiled:\n            self.empty = True\n\n    def boil(self):\n        # 将颅内物煮沸\n        # 煮混合物时，锅炉内必须是满的且没有煮沸过\n        # 一旦煮沸，就把 boiled 设置为 true\n        if not self.empty and not self.boiled:\n            self.boiled = True\n从代码可以看出，他们加入了多种判断，以防止不好的事情发生。如果同时存在两个ChocolateBoiler实例，那这么多判断岂不是失去作用了。那我们改如何实现这个需求呢？这个问题的核心是，我们要先判断实例是不是已经存在，如果存在就不再创建。\n_chocolate_boiler_instance = None  # 声明实例\n\ndef chocolate_boiler():\n    global _chocolate_boiler_instance  # 使用全局变量\n\n    if _chocolate_boiler_instance is not None: # 判断是否存在，如果存在，直接返回\n        return _chocolate_boiler_instance\n    else:\n        # 如果不存在，创建一个新的\n        _chocolate_boiler_instance = ChocolateBoiler()\n        return _chocolate_boiler_instance\n现在我们需要获取 ChocolateBoiler 实例的时候只需要调用 chocolate_boiler 方法获取实例即可保证同时只有一个 ChocolateBoiler实例。\n这种保证 ChocolateBoiler类只有一个实例，并提供一个全局访问点的模式，就是单例模式。\n单例模式\n定义\n单例模式：确保一个类只有一个实例，并提供一个全局访问点。\n\n也就是说，我们使用单例模式要把某个类设计成自己管理的一个单独实例，同时也避免其他类再自行产生实例。并且只允许通过单例类获取单例的实例。\n我们也提供对这个实例的全局访问点：当你需要实例时，像类查询，它会返回单个实例。\n\n实现\npython 实现单例模式有多种方案：\n使用 metaclass\n《python cookbook》提供了非常易用的 Singleton 类，只要继承它，就会成为单例。\n# python 3 代码实现\nclass Singleton(type):\n\n    def __init__(self, *args, **kwargs):\n        self.__instance = None\n        super().__init__(*args, **kwargs)\n\n    def __call__(self, *args, **kwargs):\n        if self.__instance is None:\n            # 如果 __instance 不存在，创建新的实例\n            self.__instance = super().__call__(*args, **kwargs)\n            return self.__instance\n        else:\n            # 如果存在，直接返回\n            return self.__instance\n\n\nclass Spam(metaclass=Singleton):\n\n    def __init__(self):\n        print('Creating Spam')\n\na = Spam()\nb = Spam()\n\nprint(a is b)  # 这里输出为 True\n元类（metaclass）可以控制类的创建过程，它主要做三件事：\n\n拦截类的创建\n修改类的定义\n返回修改后的类\n\n例子中我们构造了一个Singleton元类，并使用__call__方法使其能够模拟函数的行为。构造类 Spam 时，将其元类设为Singleton，那么创建类对象 Spam 时，行为发生如下：\nSpam = Singleton(name,bases,class_dict)，Spam 其实为Singleton类的一个实例。\n创建 Spam 的实例时，Spam()=Singleton(name,bases,class_dict)()=Singleton(name,bases,class_dict).__call__()，这样就将 Spam 的所有实例都指向了 Spam 的属性 __instance上。\n使用 new\n\n我们可以使用 new 来控制实例的创建过程，代码如下:\nclass Singleton(object):\n\n    __instance = None\n\n    def __new__(cls, *args, **kw):\n        if not cls.__instance:\n            cls.__instance = super().__new__(cls, *args, **kw)\n        return cls.__instance\n\nclass Foo(Singleton):\n    a = 1\n\none = Foo()\ntwo = Foo()\nassert one == two\nassert one is two\nassert id(one) == id(two)\n通过 new 方法，将类的实例在创建的时候绑定到类属性 __instance 上。如果cls.__instance 为None，说明类还未实例化，实例化并将实例绑定到cls.__instance 以后每次实例化的时候都返回第一次实例化创建的实例。注意从Singleton派生子类的时候，不要重载__new__。\n使用装饰器\nimport functools\n\ndef singleton(cls):\n    ''' Use class as singleton. '''\n    # 首先将 __new__ 方法赋值给 __new_original__\n    cls.__new_original__ = cls.__new__\n\n    @functools.wraps(cls.__new__)\n    def singleton_new(cls, *args, **kw):\n        # 尝试从 __dict__ 取 __it__\n        it =  cls.__dict__.get('__it__')\n        if it is not None: # 如果有值，说明实例已经创建，返回实例\n            return it\n        # 如果实例不存在，使用 __new_original__ 创建实例，并将实例赋值给 __it__\n        cls.__it__ = it = cls.__new_original__(cls, *args, **kw)\n        it.__init_original__(*args, **kw)\n        return it\n    # class 将原有__new__ 方法用 singleton_new 替换\n    cls.__new__ = singleton_new\n    cls.__init_original__ = cls.__init__\n    cls.__init__ = object.__init__\n\n    return cls\n\n#\n# 使用示例\n#\n@singleton\nclass Foo:\n    def __new__(cls):\n        cls.x = 10\n        return object.__new__(cls)\n\n    def __init__(self):\n        assert self.x == 10\n        self.x = 15\n\n\nassert Foo().x == 15\nFoo().x = 20\nassert Foo().x == 20\n这种方法的内部实现和使用 __new__ 类似：\n\n首先，将 new 方法赋值给 new_original__，原有 new 方法用 singleton_new 替换，定义  init_original 并将 cls.__init 赋值给 init_original\n\n在 singleton_new 方法内部，尝试从 dict 取 __it__（实例）\n如果实例不存在，使用 new_original 创建实例，并将实例赋值给 __it__，然后返回实例\n\n最简单的方式\n将名字singleton绑定到实例上，singleton就是它自己类的唯一对象了。\nclass singleton(object):\n    pass\nsingleton = singleton()\nhttps://github.com/gusibi/Metis/blob/master/apis/v1/schemas.py#L107 使用的就是这种方式，用来获取全局的 request\nPython 的模块就是天然的单例模式，因为模块在第一次导入时，会生成 .pyc 文件，当第二次导入时，就会直接加载 .pyc 文件，而不会再次执行模块代码。因此，我们只需把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了。\n参考链接\n\nCreating a singleton in Python\nPython单例模式\nWhy is __init__() always called after __new__()?\n\n\n最后，感谢女朋友支持。\n\n\n欢迎关注(April_Louisa)\n请我喝芬达\n\n\n\n\n\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "3"}