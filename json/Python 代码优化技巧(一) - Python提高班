{"title": "Python 代码优化技巧(一) - Python提高班 ", "index": "python", "content": "代码优化Part1\n\n分享最近看到的关于代码优化的一些技巧。\nif 判断的短路特性\n\n对于and，应该把满足条件少的放在前面，这样当对于大量判断时， 满足条件少的情况直接回导致其后其他表达式不会计算从而节约时间(因为 False and True 还是 False)\nimport timeit\n\ns1 = \"\"\"\na = range(2000)\n[i for i in a if i % 2 ==0 and i > 1900]\n\"\"\"\n\ns2 = \"\"\"\na = range(2000)\n[i for i in a if  i > 1900 and i % 2 ==0]\n\"\"\"\n\nprint timeit.timeit(stmt=s1, number=1000)\nprint timeit.timeit(stmt=s2, number=1000)\n\n运行结果如下：\n➜  python test6.py\n0.248532056808\n0.195827960968\n\n# 可以看到s2 表达式计算更快， 因为大部分情况都不满足 i>1900, 所以这些情况下, i % 2 == 0 也没有计算，从而节约了时间\n\n同理对于or，把满足条件多的放在前面。\nimport timeit\n\ns1 = \"\"\"\na = range(2000)\n[i for i in a if 10 < i <20 or 1000 < i < 2000]\n\"\"\"\n\ns2 = \"\"\"\na = range(2000)\n[i for i in a if 1000 < i < 2000 or 10 < i <20]\n\"\"\"\n\nprint timeit.timeit(stmt=s1, number=1000)\nprint timeit.timeit(stmt=s2, number=1000)\n\n运行结果:\n0.253124952316\n0.202992200851\n\njoin 合并字符串\n\njoin 合并字符串比循环使用 + 来合并要快。\nimport timeit\n\ns1 = \"\"\"\na = [str(x) for x in range(2000)]\ns = ''\nfor i in a:\n    s += i\n\"\"\"\n\ns2 = \"\"\"\na = [str(x) for x in range(2000)]\ns = ''.join(a)\n\"\"\"\n\nprint timeit.timeit(stmt=s1, number=1000)\nprint timeit.timeit(stmt=s2, number=1000)\n\n运行结果如下：\npython test6.py\n\n0.558945894241\n0.422435998917\n\nwhile 1 和 while True\n\n在python2.x里， True 和 False 不是保留的关键字，是一个全局变量，这意味着你可以这样\n>>> True = 0\n>>> True\n0\n>>> if not True:\n...   print '1'\n...\n1\n\n所以下面这两种情况:\nimport timeit\n\ns1 = \"\"\"\nn = 1000000\nwhile 1:\n    n -= 1\n    if n <= 0: break\n\"\"\"\n\ns2 = \"\"\"\nn = 1000000\nwhile True:\n    n -= 1\n    if n <= 0: break\n\"\"\"\n\nprint timeit.timeit(stmt=s1, number=100)\nprint timeit.timeit(stmt=s2, number=100)\n\n运行结果如下：\n➜  python test6.py\n5.18007302284\n6.84624099731\n\n因为每次判断 while True 的时候， 先要去找到True的值。\n在python3.x里， True 变成了关键字参数，所以上述两种情况就一样了。\ncProfile, cStringIO 和 cPickle\n\n使用C语言的版本写的扩展要比原生的要快。cPickle vs pickle 如下：\nimport timeit\n\ns1 = \"\"\"\nimport cPickle\nimport pickle\nn = range(10000)\ncPickle.dumps(n)\n\"\"\"\n\ns2 = \"\"\"\nimport cPickle\nimport pickle\nn = range(10000)\npickle.dumps(n)\n\"\"\"\n\nprint timeit.timeit(stmt=s1, number=100)\nprint timeit.timeit(stmt=s2, number=100)\n\n运行结果如下：\n➜ python test6.py\n0.182178974152\n1.70917797089\n\n合理使用生成器\n\n区别\n\n使用()得到的是一个generator对象，所需要的内存空间与列表的大小无关，所以效率会高一些。\nimport timeit\n\ns1 = \"\"\"\n[i for i in range (100000)]\n\"\"\"\n\ns2 = \"\"\"\n(i for i in range(100000))\n\"\"\"\n\nprint timeit.timeit(stmt=s1, number=1000)\nprint timeit.timeit(stmt=s2, number=1000)\n\n结果:\n➜  python test6.py\n5.44327497482\n0.923446893692\n\n但是对于需要循环遍历的情况：使用迭代器效率反而不高，如下：\nimport timeit\n\ns1 = \"\"\"\nls = range(1000000)\ndef yield_func(ls):\n    for i in ls:\n        yield i+1\nfor x in yield_func(ls):\n    pass\n\"\"\"\n\ns2 = \"\"\"\nls = range(1000000)\ndef not_yield_func(ls):\n    return [i+1 for i in ls]\nfor x in not_yield_func(ls):\n    pass\n\"\"\"\n\nprint timeit.timeit(stmt=s1, number=10)\nprint timeit.timeit(stmt=s2, number=10)\n\n结果如下：\n➜  python test6.py\n1.03186702728\n1.01472687721\n\n所以使用生成器是一个权衡的结果，对于内存、速度综合考虑的结果。\nxrange\n\n在python2.x里xrange 是纯C实现的生成器，相对于range来说，它不会一次性计算出所有值在内存中。但它的限制是只能和整型一起工作：你不能使用long或者float。\nimport 语句的开销\n\nimport语句有时候为了限制它们的作用范围或者节省初始化时间，被卸载函数内部，虽然python的解释器不会重复import同一个模块不会出错，但重复导入会影响部分性能。有时候为了实现懒加载（即使用的时候再加载一个开销很大的模块），可以这么做：\nemail = None\n\ndef parse_email():\n    global email\n    if email is None:\n        import email\n    ...\n\n# 这样一来email模块仅会被引入一次，在parse_email()被第一次调用的时候。\n\n参考资源:\n\n\nhttps://wiki.python.org/moin/...\nhttp://blog.csdn.net/zhoudaxi...\nhttps://www.ibm.com/developer...\n\nNEXT ctypes\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "4"}