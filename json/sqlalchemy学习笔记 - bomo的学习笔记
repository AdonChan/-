{"title": "sqlalchemy学习笔记 - bomo的学习笔记 ", "index": "python,sqlalchemy,sql", "content": "SQLAlchemy是python的一个数据库ORM工具，提供了强大的对象模型间的转换，可以满足绝大多数数据库操作的需求，并且支持多种数据库引擎（sqlite，mysql，postgres, mongodb等），在这里记录基本用法和学习笔记\n一、安装\n通过pip安装\n$ pip install SQLAlchemy\n二、使用\n首先是连接到数据库，SQLALchemy支持多个数据库引擎，不同的数据库引擎连接字符串不一样，常用的有\nmysql://username:password@hostname/database\npostgresql://username:password@hostname/database\nsqlite:////absolute/path/to/database\nsqlite:///c:/absolute/path/to/database\n更多连接字符串的介绍参见这里\n下面是连接和使用sqlite数据库的例子\n1. connection\n使用传统的connection的方式连接和操作数据库\nfrom sqlalchemy import create_engine\n\n# 数据库连接字符串\nDB_CONNECT_STRING = 'sqlite:///:memory:'\n\n# 创建数据库引擎,echo为True,会打印所有的sql语句\nengine = create_engine(DB_CONNECT_STRING, echo=True)\n\n# 创建一个connection，这里的使用方式与python自带的sqlite的使用方式类似\nwith engine.connect() as con:\n    # 执行sql语句，如果是增删改，则直接生效，不需要commit\n    rs = con.execute('SELECT 5')\n    data = rs.fetchone()[0]\n    print \"Data: %s\" % data\n与python自带的sqlite不同，这里不需要Cursor光标，执行sql语句不需要commit\n2. connection事务\n使用事务可以进行批量提交和回滚\nfrom sqlalchemy import create_engine\n\n# 数据库连接字符串\nDB_CONNECT_STRING = 'sqlite:////Users/zhengxiankai/Desktop/Document/db.sqlite'\nengine = create_engine(DB_CONNECT_STRING, echo=True)\n\nwith engine.connect() as connection:\n    trans = connection.begin()\n    try:\n        r1 = connection.execute(\"select * from User\")\n        r2 = connection.execute(\"insert into User(name, age) values(?, ?)\", 'bomo', 24)\n        trans.commit()\n    except:\n        trans.rollback()\n        raise\n3. session\nconnection是一般使用数据库的方式，sqlalchemy还提供了另一种操作数据库的方式，通过session对象，session可以记录和跟踪数据的改变，在适当的时候提交，并且支持强大的ORM的功能，下面是基本使用\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\n# 数据库连接字符串\nDB_CONNECT_STRING = 'sqlite:////Users/zhengxiankai/Desktop/Document/db.sqlite'\n\n# 创建数据库引擎,echo为True,会打印所有的sql语句\nengine = create_engine(DB_CONNECT_STRING, echo=True)\n\n# 创建会话类\nDB_Session = sessionmaker(bind=engine)\n\n# 创建会话对象\nsession = DB_Session()\n\n# dosomething with session\n\n# 用完记得关闭，也可以用with\nsession.close()\n上面创建了一个session对象，接下来可以操作数据库了，session也支持通过sql语句操作数据库\nsession.execute('select * from User')\nsession.execute(\"insert into User(name, age) values('bomo', 13)\")\nsession.execute(\"insert into User(name, age) values(:name, :age)\", {'name': 'bomo', 'age':12})\n\n# 如果是增删改，需要commit\nsession.commit()\n注意参数使用dict，并在sql语句中使用:key占位\n4. ORM\n上面简单介绍了sql的简单用法，既然是ORM框架，我们先定义两个模型类User和Role，sqlalchemy的模型类继承自一个由declarative_base()方法生成的类，我们先定义一个模块Models.py生成Base类\nfrom sqlalchemy.ext.declarative import declarative_base\n\nBase = declarative_base()\nUser.py\nfrom sqlalchemy import Column, Integer, String\nfrom Models import Base\n\nclass User(Base):\n    __tablename__ = 'User'\n    id = Column('id', Integer, primary_key=True, autoincrement=True)\n    name = Column('name', String(50))\n    age = Column('age', Integer)\nRole.py\nfrom sqlalchemy import Column, Integer, String\nfrom Models import Base\n\nclass Role(Base):\n    __tablename__ = 'Role'\n    id = Column('id', Integer, primary_key=True, autoincrement=True)\n    name = Column('name', String(50))\n从上面很容易看出来，这里的模型对应数据库中的表，模型支持的类型有Integer, String, Boolean, Date, DateTime, Float，更多类型包括类型对应的Python的类型参见：这里\nColumn构造函数相关设置\n\nname：名称\ntype_：列类型\nautoincrement：自增\ndefault：默认值\nindex：索引\nnullable：可空\nprimary_key：外键\n\n更多介绍参见这里\n接下来通过session进行增删改查\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom User import User\nfrom Role import Role\nfrom Models import Base\n\nDB_CONNECT_STRING = 'sqlite:////Users/zhengxiankai/Desktop/Document/db.sqlite'\nengine = create_engine(DB_CONNECT_STRING, echo=True)\nDB_Session = sessionmaker(bind=engine)\nsession = DB_Session()\n\n# 1. 创建表（如果表已经存在，则不会创建）\nBase.metadata.create_all(engine)\n\n# 2. 插入数据\nu = User(name = 'tobi', age = 200)\nr = Role(name = 'user')\n\n# 2.1 使用add，如果已经存在，会报错\nsession.add(u)\nsession.add(r)\nsession.commit()\nprint r.id\n\n# 3 修改数据\n# 3.1 使用merge方法，如果存在则修改，如果不存在则插入（只判断主键，不判断unique列）\nr.name = 'admin'\nsession.merge(r)\n\n# 3.2 也可以通过这种方式修改\nsession.query(Role).filter(Role.id == 1).update({'name': 'admin'})\n\n# 4. 删除数据\nsession.query(Role).filter(Role.id == 1).delete()\n\n# 5. 查询数据\n# 5.1 返回结果集的第二项\nuser = session.query(User).get(2)\n\n# 5.2 返回结果集中的第2-3项\nusers = session.query(User)[1:3]\n\n# 5.3 查询条件\nuser = session.query(User).filter(User.id < 6).first()\n\n# 5.4 排序\nusers = session.query(User).order_by(User.name)\n\n# 5.5 降序（需要导入desc方法）\nfrom sqlalchemy import desc\nusers = session.query(User).order_by(desc(User.name))\n\n# 5.6 只查询部分属性\nusers = session.query(User.name).order_by(desc(User.name))\nfor user in users:\n    print user.name\n\n# 5.7 给结果集的列取别名\nusers = session.query(User.name.label('user_name')).all()\nfor user in users:\n    print user.user_name\n\n# 5.8 去重查询（需要导入distinct方法）\nfrom sqlalchemy import distinct\nusers = session.query(distinct(User.name).label('name')).all()\n\n# 5.9 统计查询\nuser_count = session.query(User.name).order_by(User.name).count()\nage_avg = session.query(func.avg(User.age)).first()\nage_sum = session.query(func.sum(User.age)).first()\n\n# 5.10 分组查询\nusers = session.query(func.count(User.name).label('count'), User.age).group_by(User.age)\nfor user in users:\n    print 'age:{0}, count:{1}'.format(user.age, user.count)\n\n# 6.1 exists查询(不存在则为~exists())\nfrom sqlalchemy.sql import exists\nsession.query(User.name).filter(~exists().where(User.role_id == Role.id))\n# SELECT name AS users_name FROM users WHERE NOT EXISTS (SELECT * FROM roles WHERE users.role_id = roles.id)\n\n# 6.2 除了exists，any也可以表示EXISTS\nsession.query(Role).filter(Role.users.any())\n\n# 7 random\nfrom sqlalchemy.sql.functions import random\nuser = session.query(User).order_by(random()).first()\n\nsession.close()\n参考链接：\nany\n5. 多表关系\n上面的所有操作都是基于单个表的操作，下面是多表以及关系的使用，我们修改上面两个表，添加外键关联（一对多和多对一）\nUser模型\nfrom sqlalchemy import Column, Integer, String\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy.orm import relationship\nfrom Models import Base\n\nclass User(Base):\n    __tablename__ = 'users'\n    id = Column('id', Integer, primary_key=True, autoincrement=True)\n    name = Column('name', String(50))\n    age = Column('age', Integer)\n\n    # 添加角色id外键(关联到Role表的id属性)\n    role_id = Column('role_id', Integer, ForeignKey('roles.id'))\n    # 添加同表外键\n    second_role_id = Column('second_role_id', Integer, ForeignKey('roles.id'))\n\n    # 添加关系属性，关联到role_id外键上\n    role = relationship('Role', foreign_keys='User.role_id', backref='User_role_id')\n    # 添加关系属性，关联到second_role_id外键上\n    second_role = relationship('Role', foreign_keys='User.second_role_id', backref='User_second_role_id')\nRole模型\nfrom sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import relationship\nfrom Models import Base\n\nclass Role(Base):\n    __tablename__ = 'roles'\n    id = Column('id', Integer, primary_key=True, autoincrement=True)\n    name = Column('name', String(50))\n\n    # 添加关系属性，关联到User.role_id属性上\n    users = relationship(\"User\", foreign_keys='User.role_id', backref=\"Role_users\")\n    # 添加关系属性，关联到User.second_role_id属性上\n    second_users = relationship(\"User\", foreign_keys='User.second_role_id', backref=\"Role_second_users\")\n这里有一点需要注意的是，设置外键的时候ForeignKey('roles.id')这里面使用的是表名和表列，在设置关联属性的时候relationship('Role', foreign_keys='User.role_id', backref='User_role_id')，这里的foreign_keys使用的时候类名和属性名\n接下来就可以使用了\nu = User(name='tobi', age=200)\n\nr1 = Role(name='admin')\nr2 = Role(name='user')\n\nu.role = r1\nu.second_role = r2\n\nsession.add(u)\nsession.commit()\n\n# 查询（对于外键关联的关系属性可以直接访问，在需要用到的时候session会到数据库查询）\nroles = session.query(Role).all()\nfor role in roles:\n    print 'role:{0} users'\n    for user in role.users:\n        print '\\t{0}'.format(user.name)\n    print 'role:{0} second_users'\n    for user in role.second_users:\n        print '\\t{0}'.format(user.name)\n上面表示的是一对多（多对一）的关系，还有一对一，多对多，如果要表示一对一的关系，在定义relationship的时候设置uselist为False（默认为True），如在Role中\nclass Role(Base):\n    ...\n    user = relationship(\"User\", uselist=False, foreign_keys='User.role_id', backref=\"Role_user\")\n6. 多表查询\n多表查询通常使用join进行表连接，第一个参数为表名，第二个参数为条件，例如\nusers = db.session.query(User).join(Role, Role.id == User.role_id)\n\nfor u in users:\n    print u.name\njoin为内连接，还有左连接outerjoin，用法与join类似，右连接和全外链接在1.0版本上不支持，通常来说有这两个结合查询的方法基本够用了，1.1版本貌似添加了右连接和全外连接的支持，但是目前只是预览版\n还可以直接查询多个表，如下\nresult = db.session.query(User, Role).filter(User.role_id = Role.id)\n# 这里选择的是两个表，使用元组获取数据\nfor u, r in result:\n      print u.name\n三、数据库迁移\nsqlalchemy的数据库迁移/升级有两个库支持alembic和sqlalchemy-migrate\n由于sqlalchemy-migrate在2011年发布了0.7.2版本后，就已经停止更新了，并且已经不维护了，也积累了很多bug，而alembic是较后来才出现，而且是sqlalchemy的作者开发的，有良好的社区支持，所以在这里只学习alembic这个库\nalembic实现了类似git/svn的版本管理的控制，我们可以通过alembic维护每次升级数据库的版本\n1. 安装\n通过pip安装，pip会自动安装相关的依赖\n$ pip install alembic\n2. 初始化\n安装完成后再项目根目录运行\n$ alembic init YOUR_ALEMBIC_DIR\nalembic会在根目录创建YOUR_ALEMBIC_DIR目录和alembic.ini文件，如下\nyourproject/\n    alembic.ini\n    YOUR_ALEMBIC_DIR/\n        env.py\n        README\n        script.py.mako\n        versions/\n            3512b954651e_add_account.py\n            2b1ae634e5cd_add_order_id.py\n            3adcc9a56557_rename_username_field.py\n其中\n\nalembic.ini 提供了一些基本的配置\nenv.py 每次执行Alembic都会加载这个模块，主要提供项目Sqlalchemy Model 的连接\nscript.py.mako 迁移脚本生成模版\nversions 存放生成的迁移脚本目录\n\n默认情况下创建的是基于单个数据库的，如果需要支持多个数据库或其他，可以通过alembic list_templates查看支持的模板\n$ alembic list_templates\nAvailable templates:\n\ngeneric - Generic single-database configuration.\nmultidb - Rudimentary multi-database configuration.\npylons - Configuration that reads from a Pylons project environment.\n\nTemplates are used via the 'init' command, e.g.:\n\n  alembic init --template generic ./scripts\n3. 配置\n使用之前，需要配置一下链接字符串，打开alembic.ini文件，设置sqlalchemy.url连接字符串，例如\nsqlalchemy.url = sqlite:////Users/zhengxiankai/Desktop/database.db\n其他参数可以参见官网说明：http://alembic.zzzcomputing.com/en/latest/tutorial.html\n4. 创建数据库版本\n接下来我们创建一个数据库版本，并新建两个表\n$ alembic revision -m 'create table'\n创建一个版本（会在yourproject/YOUR_ALEMBIC_DIR/versions/文件夹中创建一个python文件1a8a0d799b33_create_table.py）\n该python模块包含upgrade和downgrade两个方法，在这里添加一些新增表的逻辑\n\"\"\"create table\n\nRevision ID: 4fd533a56b34\nRevises:\nCreate Date: 2016-09-18 17:20:27.667100\n\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision = '4fd533a56b34'\ndown_revision = None\nbranch_labels = None\ndepends_on = None\n\ndef upgrade():\n    # 添加表\n    op.create_table(\n        'account',\n        sa.Column('id', sa.Integer, primary_key=True),\n        sa.Column('name', sa.String(50), nullable=False),\n        sa.Column('description', sa.Unicode(200)),\n    )\n\n    # 添加列\n    # op.add_column('account', sa.Column('last_transaction_date', sa.DateTime))\n\n\n\ndef downgrade():\n    # 删除表\n    op.drop_table('account')\n\n    # 删除列\n    # op.drop_column('account', 'last_transaction_date')\n\n这里使用到了了op对象，关于op对象的更多API使用，参见这里\n这里生成的文件名是依照在alembic.ini文件声明的模板来的，默认为版本号+名字，可以加上一些日期信息，否则不好排序，更多参数参见这里\nfile_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d_%%(minute).2d_%%(rev)s_%%(slug)s\n另外通常我们也改一下生成模板script.py.mako，加上编码信息，否则在升级脚本中如果有中文会报错\n#!/usr/bin/python\n# -*- coding:utf-8 -*-\n5. 升级数据库\n刚刚实现了升级和降级的方法，通过下面命令升级数据库到最新版本\n$ alembic upgrade head\n这时候可以看到数据库多了两个表alembic_version和account，alembic_version存放数据库版本\n关于升级和降级的其他命令还有下面这些\n# 升到最高版本\n$ alembic upgrade head\n\n# 降到最初版本\n$ alembic downgrade base\n\n# 升两级\n$ alembic upgrade +2\n\n# 降一级\n$ alembic downgrade -1\n\n# 升级到制定版本\n$ alembic upgrade e93b8d488143\n\n# 查看当前版本\n$ alembic current\n\n# 查看历史版本详情\n$ alembic history --verbose\n\n# 查看历史版本（-r参数）类似切片\n$ alembic history -r1975ea:ae1027\n$ alembic history -r-3:current\n$ alembic history -r1975ea:\n6. 通过元数据升级数据库\n上面我们是通过API升级和降级，我们也可以直接通过元数据更新数据库，也就是自动生成升级代码，先定义两个Model（User, Role），这里我定义成三个文件\nyourproject/\n    YOUR_ALEMBIC_DIR/\n    tutorial/Db\n        Models.py\n        User.py\n        Role.py\n代码就放在一起了\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy import Column, Integer, String\nBase = declarative_base()\n\nclass User(Base):\n    __tablename__ = 'users'\n\n    id = Column('id', Integer, primary_key=True, autoincrement=True)\n    name = Column('name', String)\n\nclass Role(Base):\n    __tablename__ = 'roles'\n\n    id = Column('id', Integer, primary_key=True, autoincrement=True)\n    name = Column('name', String)\n\n在YOUR_ALEMBIC_DIR/env.py配置元数据\ntarget_metadata = None\n改为\nimport os\nimport sys\n\n# 这里需要添加相对路径到sys.path，否则会引用失败，尝试过使用相对路径，但各种不好使，还是使用这种方法靠谱些\nsys.path.append(os.path.abspath(os.path.join(os.getcwd(), \"../yourproject/tutorial/Db\")))\n\nfrom User import User\nfrom Role import Role\nfrom Models import Base\ntarget_metadata = Base.metadata\nos.path.join(os.getcwd()这个获取到的地址不是env.py的路径，而是根目录\n在创建数据库版本的时候添加--autogenerate参数，就会从Base.metadata元数据中生成脚本\n$ alembic revision --autogenerate -m \"add user table\"\n这时候会在生成升级代码\n\"\"\"add user table\n\nRevision ID: 97de1533584a\nRevises: 8678ab6d48c1\nCreate Date: 2016-09-19 21:58:00.758410\n\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision = '97de1533584a'\ndown_revision = '8678ab6d48c1'\nbranch_labels = None\ndepends_on = None\n\ndef upgrade():\n    ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('roles',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('name', sa.String(), nullable=True),\n    sa.PrimaryKeyConstraint('id')\n    )\n    op.create_table('users',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('name', sa.String(), nullable=True),\n    sa.PrimaryKeyConstraint('id')\n    )\n    op.drop_table('account')\n    ### end Alembic commands ###\n\n\ndef downgrade():\n    ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('account',\n    sa.Column('id', sa.INTEGER(), nullable=False),\n    sa.Column('name', sa.VARCHAR(length=50), nullable=False),\n    sa.Column('description', sa.VARCHAR(length=200), nullable=True),\n    sa.Column('last_transaction_date', sa.DATETIME(), nullable=True),\n    sa.PrimaryKeyConstraint('id')\n    )\n    op.drop_table('users')\n    op.drop_table('roles')\n    ### end Alembic commands ###\n由于我没有定义account模型，会被识别为删除，如果删除了model的列的声明，则会被识别为删除列，自动生成的版本我们也可以自己修改，然后执行升级命令即可升级alembic upgrade head\n需要注意的是\n\nBase.metadata声明的类必须以数据库中的一一对应，如果数据库中有的表，而在元数据中没有，会识别成删除表\nrevision创建版本之前执行之前需要升级到最新版本\n配置Base之前，需要保证所有的Model都已经执行（即导入）过一次了，否则无法读取到，也就是需要把所有Model都import进来\n\n数据库升级有风险，升级前最好先检查一遍upgrade函数，可以的话做好备份哈\n四、常见问题\n1. String长度问题\n如果使用mysql数据库，String类型对应的是VARCHAR类型，需要指定长度，否则会报下面错误，而在sqlite不会出现\n(in table 'user', column 'name'): VARCHAR requires a length on dialect mysql\n如有问题欢迎到我的博客留言\n五、参考链接\n\nAuto Generating Migrations\ntutorial\n\n最后安利一下自己的博客：http://zhengbomo.github.com\n\n                ", "mainLikeNum": ["7 "], "mainBookmarkNum": "24"}