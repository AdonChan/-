{"title": "流畅的python读书笔记-第六章-使用一等函数实现设计模式 - 个人文章 ", "index": "python", "content": "一等函数实现设计模式\n经典的“策略”模式定义\n定义一系列算法，把它们一一封装起来，并且使它们可以相互替换。本模式使得算法可以独立于使用它的客户而变化。\n案例\n假如一个网店制定了下述折扣规则。\n\n有 1000 或以上积分的顾客，每个订单享 5% 折扣。\n同一订单中，单个商品的数量达到 20 个或以上，享 10% 折扣。\n订单中的不同商品达到 10 个或以上，享 7% 折扣。\n\n简单起见，我们假定一个订单一次只能享用一个折扣。\n\n\n具体策略由上下文类的客户选择。\n实例化订单之前，系统会以某种方式选择一种促销折扣策略，\n然后把它传给 Order 构造方法。\n具体怎么选择策略，不在这个模式的职责范围内。\n\n\nfrom abc import ABC, abstractclassmethod\nfrom collections import namedtuple\n\nCustomer = namedtuple('Customer', 'name fidelity')\n\n\n# 类似于购物车\nclass LineItem(object):\n    def __init__(self, product, quantity, price):\n        self.product = product\n        self.quantity = quantity\n        self.price = price\n\n    def total(self):\n        return self.price * self.quantity\n\n\n# 上下文是 Order\nclass Order(object):\n    def __init__(self, customer, cart, promotion=None):\n        self.customer = customer\n        self.cart = list(cart)\n        self.promotion = promotion\n\n    def total(self):  ###4\n        if not hasattr(self, '__total'):\n            self.__total = sum(item.total() for item in self.cart)\n        return self.__total\n\n    def due(self):  ###5\n        if self.promotion is None:\n            discount = 0\n        else:\n            discount = self.promotion.discount(self)  ###6\n        return self.total() - discount\n\n    def __repr__(self):  ###2\n        fmt = '<Order total: {:.2f} due: {:.2f}>'\n        return fmt.format(self.total(), self.due())  ###3\n\n\n# 策略：抽象基类\nclass Promotion(ABC):\n    @abstractclassmethod\n    def discount(self, order):\n        \"\"\"返回折扣金额（正值）\"\"\"\n\n\nclass FidelityPromo(Promotion):  # 第一个具体策略\n\n    \"\"\"为积分为1000或以上的顾客提供5%折扣\"\"\"\n\n    def discount(self, order):  ###7\n        return order.total() * .05 if order.customer.fidelity >= 1000 else 0\n\n\nclass BulkItemPromo(Promotion):  # 第二个具体策略\n\n\n    \"\"\"单个商品为20个或以上时提供10%折扣\"\"\"\n\n    def discount(self, order):\n        discount = 0\n        for item in order.cart:\n            if item.quantity >= 20:\n                discount += item.total() * .1\n        return discount\n\n\nclass LargeOrderPromo(Promotion):  # 第三个具体策略\n    \"\"\"订单中的不同商品达到10个或以上时提供7%折扣\"\"\"\n\n    def discount(self, order):\n        distinct_items = {item.product for item in order.cart}\n\n        if len(distinct_items) >= 10:\n            return order.total() * .07\n        return 0\n\n\nif __name__ == \"__main__\":\n    # 两位顾客 一个积分是0 一个是1100\n    longe = Customer('longe', 0)\n    liang = Customer('Ann Smith', 1100)\n\n    # 购物的商品\n    cart = [LineItem('banana', 4, .5), LineItem('apple', 10, 1.5), LineItem('watermellon', 5, 5.0)]\n    # 这样去调用\n    print(Order(longe, cart, FidelityPromo()))  ###111\n\n    print(Order(liang, cart, FidelityPromo()))\n\n    banana_cart = [LineItem('banana', 30, .5), LineItem('apple', 10, 1.5)]\n\n    print(Order(longe, banana_cart, BulkItemPromo()))\n\n    long_order = [LineItem(str(item_code), 1, 1.0) for item_code in range(10)]\n    \n    print(Order(longe, long_order, LargeOrderPromo()))\n\n使用函数实现“策略”模式\nfrom collections import namedtuple\n\nCustomer = namedtuple('Customer', 'name fidelity')\n\n\nclass LineItem:\n    def __init__(self, product, quantity, price):\n        self.product = product\n        self.quantity = quantity\n        self.price = price\n\n    def total(self):\n        return self.price * self.quantity\n\n\nclass Order:  # 上下文\n    def __init__(self, customer, cart, promotion=None):\n        self.customer = customer\n        self.cart = list(cart)\n        self.promotion = promotion\n\n    def total(self):\n        if not hasattr(self, '__total'):\n            self.__total = sum(item.total() for item in self.cart)\n            return self.__total\n\n    def due(self):\n        if self.promotion is None:\n            discount = 0\n\n        else:\n            discount = self.promotion(self)\n        return self.total() - discount\n\n\n    def __repr__(self):\n        fmt = '<Order total: {:.2f} due: {:.2f}>'\n\n        return fmt.format(self.total(), self.due())\n\n\ndef fidelity_promo(order):\n    \"\"\"为积分为1000或以上的顾客提供5%折扣\"\"\"\n\n    return order.total() * .05 if order.customer.fidelity >= 1000 else 0\n\n\ndef bulk_item_promo(order):\n    \"\"\"单个商品为20个或以上时提供10%折扣\"\"\"\n\n    discount = 0\n    for item in order.cart:\n        if item.quantity >= 20:\n            discount += item.total() * .1\n    return discount\n\n\ndef large_order_promo(order):\n    \"\"\"订单中的不同商品达到10个或以上时提供7%折扣\"\"\"\n    distinct_items = {item.product for item in order.cart}\n    if len(distinct_items) >= 10:\n        return order.total() * .07\n    return 0\n\n\njoe = Customer('John Doe', 0)\nann = Customer('Ann Smith', 1100)\ncart = [LineItem('banana', 4, .5),LineItem('apple', 10, 1.5),LineItem('watermellon', 5, 5.0)]\n\nprint(Order(joe, cart, fidelity_promo))\n\nprint(Order(ann, cart, fidelity_promo))\n\nbanana_cart = [LineItem('banana', 30, .5),LineItem('apple', 10, 1.5)]\nprint(Order(joe, banana_cart, bulk_item_promo))\n\nlong_order = [LineItem(str(item_code), 1, 1.0) for item_code in range(10)]\nprint(Order(joe, long_order, large_order_promo))\n\nprint(Order(joe, cart, large_order_promo))\n策略模式 思想\n\n策略对象通常是很好的享元（flyweight）\n享元是可共享的对象，可以同时在多个上下文中使用。\n共享是推荐的做法，这样不必在每个新的上下文（这里是Order 实例）中使用相同的策略时不断新建具体策略对象，从而减少消耗。\n\n在复杂的情况下，\n\n需要具体策略维护内部状态时，可能需要把“策略”和“享元”模式结合起来。\n但是，具体策略一般没有内部状态，只是处理上下文中的数据。此时，一定要使用普通的函数，别去编写只有一个方法的类，再去实现另一个类声明的单函数接口。\n函数比用户定义的类的实例轻量，而且无需使用“享元”模式，因为各个策略函数在 Python编译模块时只会创建一次。\n普通的函数也是“可共享的对象，可以同时在多个上下文中使用”。\n\n选择最佳策略：简单的方式\n选择折扣最大的策略 (新增策略时会改代码)\nfrom collections import namedtuple\n\nCustomer = namedtuple('Customer', 'name fidelity')\n\n\nclass LineItem:\n    def __init__(self, product, quantity, price):\n        self.product = product\n        self.quantity = quantity\n        self.price = price\n\n    def total(self):\n        return self.price * self.quantity\n\n\nclass Order:  # 上下文\n    def __init__(self, customer, cart, promotion=None):\n        self.customer = customer\n        self.cart = list(cart)\n        self.promotion = promotion\n\n    def total(self):\n        if not hasattr(self, '__total'):\n            self.__total = sum(item.total() for item in self.cart)\n            return self.__total\n\n    def due(self):\n        if self.promotion is None:\n            discount = 0\n\n        else:\n            discount = self.promotion(self)\n        return self.total() - discount\n\n    def __repr__(self):\n        fmt = '<Order total: {:.2f} due: {:.2f}>'\n\n        return fmt.format(self.total(), self.due())\n\n\ndef fidelity_promo(order):\n    \"\"\"为积分为1000或以上的顾客提供5%折扣\"\"\"\n\n    return order.total() * .05 if order.customer.fidelity >= 1000 else 0\n\n\ndef bulk_item_promo(order):\n    \"\"\"单个商品为20个或以上时提供10%折扣\"\"\"\n\n    discount = 0\n    for item in order.cart:\n        if item.quantity >= 20:\n            discount += item.total() * .1\n    return discount\n\n\ndef large_order_promo(order):\n    \"\"\"订单中的不同商品达到10个或以上时提供7%折扣\"\"\"\n    distinct_items = {item.product for item in order.cart}\n    if len(distinct_items) >= 10:\n        return order.total() * .07\n    return 0\n\n\njoe = Customer('John Doe', 0)\nann = Customer('Ann Smith', 1100)\n\ncart = [LineItem('banana', 4, .5), LineItem('apple', 10, 1.5), LineItem('watermellon', 5, 5.0)]\nbanana_cart = [LineItem('banana', 30, .5), LineItem('apple', 10, 1.5)]\nlong_order = [LineItem(str(item_code), 1, 1.0) for item_code in range(10)]\n\n\n## 找出最大的折扣\npromos = [fidelity_promo, bulk_item_promo, large_order_promo]\n\ndef best_promo(order):\n    \"\"\"选择可用的最佳折扣\"\"\"\n    # print([promo(order) for promo in promos])\n    return max(promo(order) for promo in promos)\n\nprint(Order(joe, long_order, best_promo))\n\nprint(Order(joe, banana_cart, best_promo))\n\nprint(Order(ann, cart, best_promo) )\n不想改代码 找出模块中的全部策略\n\n新策略名字结尾必须是_promo\n使用 globals 函数帮助 best_promo 自动找到其他可用的*_promo 函数，过程有点曲折\n内省模块的全局命名空间，构建 promos 列表\n过滤掉 best_promo 自身，防止无限递归。\n\npromos = [globals()[name] for name in globals() if name.endswith('_promo') and name != 'best_promo']\n\nprint(promos)\n\n另一种方法\n另一个可行的方法是将所有的策略函数都存放在一个单独的模块中除了 best_promo，这里我们将 3 个策略函数存放在了 promotions.py 中\n下面的代码中，最大的变化时内省名为 promotions 的独立模块，构建策略函数列表。注意，下面要导入 promotions 模块，以及高阶内省函数的 inspect 模块\nimport  inspect\nimport promotions\npromos = [func for name, func in\n          inspect.getmembers(promotions, inspect.isfunction)]\n\n\ndef best_promo(order):\n    \"\"\"选择可用的最佳折扣 \"\"\"\n    return max(promo(order) for promo in promos)\n\nprint(Order(joe, long_order, best_promo))\n\nprint(Order(joe, banana_cart, best_promo))\n\nprint(Order(ann, cart, best_promo) )\n命令模式\n\n命令模式的目的是解耦调用操作的对象（调用者）和提供实现的对象（接收者）\n在《设计模式：可复用面向对象软件的基础》所举的示例中，调用者是图形应用程序中的菜单项，而接收者是被编辑的文档或应用程序自身。\n\n模式的做法\n\n这个模式的做法是，在二者之间放一个 Command 对象，让它实现只有一个方法（execute）的接口，调用接收者中的方法执行所需的操作。\n这样，调用者无需了解接收者的接口，而且不同的接收者可以适应不同的 Command 子类。\n调用者有一个具体的命令，通过调用 execute 方法执行。\n\nMacroCommand 的各个实例都在内部存储着命令列表\nclass MacroCommand:\n\"\"\"一个执行一组命令的命令\"\"\"\n    def __init__(self, commands):\n        self.commands = list(commands)\n    def __call__(self):\n        for command in self.commands:\n        command()\n小总结\n1.python 对某些设计默认 可以用纯函数来实现, 不用可以去写类2.设计模式得看看了\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "1"}