{"title": "看例子，学 Python（一） - 止于至善 ", "index": "python", "content": "看例子，学 Python（一）\n看例子，学 Python（二）看例子，学 Python（三）\n很难说，这篇代码比文字还多的文章，是否适合初学者。它源于个人笔记，涉及的多是简单核心的概念，也许需要一些编程基础才能快速理解。内容方面，力求循序渐进，避开细枝末节，注重原理和示例的连续性，尽量不罗列特性，点到即止。\n说明：本文仅限于 Python 3。\nHello, Python!\n从 Hello, Python! 开始，通过一系列不同实现，简单介绍字符串、函数等概念。\n第一版\nprint(\"Hello, Python!\")\nprint 是一个内置函数；在 Python 2 里，print 是一个语句（statement）。字符串由引号表示，这一点与其它语言类似。语句末尾不需要结尾符（比如 C 系列语言的分号）。\n第二版\nprint(\"Hello, \" + \"Python!\")\nprint(\"Hello, \" * 3 + \"Python!\")\n字面字符串即为对象。操作符 + 和 * 都对字符串做了重载。\n第三版\nprint('Hello, \"Python\"!')\n字符串可以用双引号，也可以用单引号。顺带也可看出 Python 并没有字符类型（char）。通过单、双引号的恰当使用，可以避免不必要的字符转义（escape）。上例若改用双引号，则里面的 \" 就需要转义了：\nprint(\"Hello, \\\"Python\\\"!\")\n第四版\ndef say_hello():\n    print('Hello, Python!')\n函数定义由 def 关键字指定。函数的命名习惯上为小写下划线（xxx\\_yyy\\_zzz），变量名也是，类名则是驼峰状（XxxYyyZzz）。Python 以【缩进】组织代码块，没有 C 系列语言的花括号，也没有 Ruby 那样的 end 语句。使用缩进的优点是，代码风格比较单一，也就比较统一，没有诸如 { 是否另起一行的争论；缺点是无法自动缩进，不但给编辑器出了难题，也使代码分享变得相对困难，因为缩进一变，程序就不对了。\nPython 概览\n对应于官方教程第三章。简单介绍字符串、列表等概念，为后续内容做准备。\n字符串\n下面由 >>> 打头的代码，表示是在交互模式下的演示。打开命令行，键入 python，即可进入交互模式。\n>>> s = \"Hello!\"\n>>> s\n'Hello!'\n内建函数 len\n字符串并没有方法（size 或 length）返回长度，取而代之的是内建函数 len：\n>>> len(\"Hello!\")\n6\n其它序列类型（sequence type）也是如此。\n遍历\n作为一种序列类型，字符串可以直接用 for 遍历。\n>>> for c in \"Hello!\": print(c)\n...\nH\ne\nl\nl\no\n!\n注意这里的变量 c，虽然表示的是单个字符，其实却是字符串。前面已经说过，Python 没有字符类型。\n类型\n通过几个内建函数，在交互模式下做一些试验。\n函数 type：查看对象类型：\n>>> type(\"Hello!\")\n<type 'str'>\n函数 help：查看类型或函数的帮助信息：\n>>> help(str)\nHelp on class str in module builtins:\n\nclass str(object)\n |  str(object='') -> str\n<省略>\n查看 help 自己的帮助信息：\n>>> help(help)\nHelp on _Helper in module _sitebuiltins object:\n<省略>\n函数 dir：列出类的属性：\n>>> dir(str)\n['__add__', '__class__', '__contains__', <省略>]\n不妨看看 dir 又是什么：\n>>> help(dir)\nHelp on built-in function dir in module builtins:\n<省略>\n类型之间可以比较：\n>>> type(\"hello\") == str\nTrue\n但是一般不这么用，一般用 isinstance，因为后者会考虑到类的继承关系：\n>>> isinstance(\"hello\", str)\nTrue\n不出意外，类型自身也有类型：\n>>> type(str)\n<class 'type'>\n这几个内建函数，非常称手，后面会经常用到。\n不可变性\n尝试像 C/C++ 那样对单个字符赋值：\n>>> s = \"Hello!\"\n>>> s[-1] = '.'  # -1 表示倒数第一个（也即最后一个）字符的下标\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: 'str' object does not support item assignment\n错误信息显示：str 对象不支持元素赋值。\n方法 replace 也一样，不会改变原来的字符串，而是返回一个替换后的新字符串：\n>>> help(str.replace)\n\nreplace(...)\n    S.replace(old, new[, count]) -> string\n\n    Return a copy of string S with all occurrences of substring\n    old replaced by new.  If the optional argument count is\n    given, only the first count occurrences are replaced.\n>>> s = \"Hello!\"\n>>> s.replace('!', '.')\n\"Hello.\"\n>>> s\n\"Hello!\"  # 原对象并没有改变\n列表\n列表（list）是最常用的数据结构，类似于 C++ 的 std::vector。\n定义\n>>> squares = [1, 4, 9, 16, 25]\n>>> squares\n[1, 4, 9, 16, 25]\n>>> type(squares)\n<class 'list'>\n索引\n列表的底层实现并非链表（linked list），所以索引的性能还是不错的。比较特别的地方在于，索引的下标可以为负数，比如前面提到 -1 表示倒数第一个元素。\n>>> squares[0]\n1\n>>> squares[-1]\n25\n切片\n切片（slice）截取列表的一段。\n>>> squares[1:4]\n[4, 9, 16]\n字符串也可以切片。当然，切片返回新序列，原序列保持不变。\n拷贝\n因为 Python 的对象是引用计数的，所以要拷贝一个列表，不能简单的赋值，但是可以用切片间接实现：\n>>> squares[:]\n[1, 4, 9, 16, 25]\n不指定起始和结束下标，就切片整个列表。相当于 squares[0:] 或 squares[0:len(squares)]。\n拼接\n拼接两个列表，直接相加即可。\n>>> squares + [36, 48]\n[1, 4, 9, 16, 25, 36, 48]\n如前所述，Python 有操作符重载的概念，与 C++ 不无相似之处。\n可变性\n与字符串不同，列表是可变的，可以被修改。\n>>> squares[6] = 49\n>>> squares.append(64)\n>>> squares.pop()\n49\n>>> squares\n[1, 4, 9, 16, 25, 36]\n\n编程初步\n以「斐波那契数列」为例，介绍基本的控制语句、函数定义。\n斐波那契数列\n0, 1, 1, 2, 3, 5, 8, ...\na  b\n   a, b\n      a, b\n交互模式下的演示\n打印 100 以内的数列：\n>>> a, b = 0, 1\n>>> while a < 100:\n...     print(a, end='')\n...     a, b = b, a+b\n...\n0 1 1 2 3 5 8 13 21 34 55 89 >>>\n以下几点值得一提：\n\nPython 支持多变量赋值（multiple assignment），比如 a, b = 0, 1，可以简化代码，更让 swap 操作变得异常简单：a, b = b, a。\n\nwhile 语句与其它语言类似。\n\nprint 函数指定 end 参数为空就不再换行了，end 缺省为 '\\n'。\n\n函数定义\n函数由关键字 def 定义。把刚才写在交互模式下代码，封装成 fib 函数，并移到文件 mymath.py 中：\ndef fib(n):\n    \"Print a Fibonacci series up to n.\"\n    \n    a, b = 0, 1\n    while a < n:\n        print(a, end='')\n        a, b = b, a+b\n那么，mymath 就是一个模块（module）。关于模块，Python 是这样定义的：\nA module is a file containing Python definitions and statements.\n函数对象\n对于模块，我们暂时先不做深究，知道通过 import 语句来使用即可，就好像 Java 的 import 或 C++ 的 #include 一样。\n>>> import mymath\n>>> mymath.fib\n<function fib at 0x7fd1d6ec25f0>\n>>> mymath.fib(100)\n0 1 1 2 3 5 8 13 21 34 55 89\n>>> fib = mymath.fib\n>>> fib(100)\n0 1 1 2 3 5 8 13 21 34 55 89\n函数也是对象，可以赋值给变量，作为参数传递。这比 C/C++ 里的函数指针更强大。\n文档字符串 (docstring)\n前面定义 fib 时，函数体前有一个字符串：Print a Fibonacci series up to n，不知道你注意没有？它就是文档字符串，既可以充当注释，又是函数对象的一部分，你可以通过属性 __doc__ 访问：\n>>> fib.__doc__\n'Print a Fibonacci series up to n.'\n文档字符串的功能不言而喻，它为函数 help 提供了萃取信息的通道。\n>>> help(fib)\nHelp on function fib in module mymath:\n\nfib(n)\n    Print a Fibonacci series up to n.\n如果文档字符串有多行，可以使用三重引号的字符串：\ndef fib(n):\n    \"\"\"Print a Fibonacci series up to n.\n    E.g., fib(10) prints:\n        0 1 1 2 3 5 8\n    \"\"\"\n函数返回值\n只要是函数，都有返回值，没有明确指定返回值的，就返回 None。None 是 Python 的空值，相当于 C++ 的 NULL 或 Java 的 null。\n>>> fib(0)\n>>> print(fib(0))\nNone\n让 fib 返回列表\n直接打印结果的函数，并不是一个好的设计，对于 fib 来说，把结果以列表返回要实用得多。\ndef fib(n):\n    result = []\n    a, b = 0, 1\n    while a < n:\n        result.append(a)\n        a, b = b, a+b\n    return result\n另一种实现\n改写 fib 函数，返回数列中的第 N 个数。\ndef fib(n):\n    a, b = 0, 1\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n    while n > 1:\n        a, b = b, a+b\n        n -= 1\n    return b\nPython 的 if else 缩写为 elif。Python 没有 ++ 或 -- 操作符，但是有 += 和 -=。\n递归版\n递归和循环比较，递归易理解，循环更高效。\ndef fib(n):\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n-1) + fib(n-2)\n阶乘（练习）\n各位可以暂停一下，拿阶乘（factorial）练练手，下面先给出轮廓：\ndef fac(n):\n    \"\"\" ...\n    >>> fac(4)\n    24\n    \"\"\"\n    pass\npass 是占位符，用来标记空代码块，纯粹为了通过“编译”。\n参考实现：\ndef fac(n):\n    \"\"\"C-style implementation\"\"\"\n    result = 1\n    while n > 1:\n        result = result * n\n        n -= 1\n    return result\n使用 range 实现阶乘\nrange 表示一段范围，比如 range(2, n) 就表示从 2 一直到 n-1（不包括 n）。\ndef fac(n):\n    result = 1\n    for i in range(2, n+1):\n        result *= i\n    return result\nfor\n回到前面遍历字符串的演示：\n>>> s = \"Hello!\"\n>>> for c in s: print(c)\n如果需要索引，用 enumerate：\n>>> for i, c in enumerate(s):\n...     print(\"s[{}] = {}\".format(i, c))\n...\ns[0] = H\ns[1] = e\ns[2] = l\ns[3] = l\ns[4] = o\ns[5] = !\n用 range 也能达到目的：\n>>> for i in range(len(s)):\n...     print(\"s[{}] = {}\".format(i, s[i]))\nrange\n再看几个 range 的例子：\n>>> range(10)  # 起点默认为 0\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n>>> range(0, 10)\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n>>> range(0, 10, 3)  # 步长为 3 \n[0, 3, 6, 9]\n最后再来看一下 range 的帮助信息：\n>>> help(range)\n\nrange(...)\n    range(stop) -> list of integers\n    range(start, stop[, step]) -> list of integers\n    <省略>\n如前所述，函数 help 是非常称手的。\n看例子，学 Python（二）看例子，学 Python（三）\n\n                ", "mainLikeNum": ["5 "], "mainBookmarkNum": "21"}