{"title": "[译] 属性访问、特性和描述符 1 - young ", "index": "python,python3.x", "content": "注：原书作者 Steven F. Lott，原书名为 Mastering Object-oriented Python\n对象就是一些特性的集合，包括方法和属性。object类的默认行为包括设置、获取和删除属性。我们经常需要修改这些行为来改变一个对象的属性。\n本章将重点关注以下五个层次的字段访问：\n\n内置字段的处理，这是最简单的，但最不精明的选择。\n回顾一下@property装饰器。特性扩展了属性的概念，把处理过程包含到了已定义的方法函数中。\n如何利用低级别的特殊方法去控制属性访问方法：__getattr__()、__setattr__()和__delattr__()。这些特殊的方法允许我们构建更复杂的属性处理。\n了解__getattribute__()方法，它提供了更细粒度的属性控制。这可以让我们写不寻常的属性处理。\n最后，我们将看看描述符。这些都是用来访问一个属性的，但它们涉及到更复杂的设计决策。在Python中大量使用描述符来实现特性、静态方法和类方法。\n\n在这一章，我们将会看到默认处理如何工作的细节。我们需要决定何时何地来覆写默认行为。在某些情况下，我们希望我们的属性不仅仅是实例化变量。在其他情况下，我们可能想要防止属性的添加。我们的属性可能有更复杂的行为。\n同样，在我们探索了解描述符时，我们将更深入的理解Python的内部是怎样工作的。我们不需要经常显式的使用描述符。我们经常隐式的使用它们，因为它们是实现Python一些特性的机制。\n基本属性处理\n默认情况下，我们创建的任何类对属性都将允许以下四个行为：\n\n通过设置值来创建一个新的属性\n给存在的属性设置值\n获取属性的值\n删除属性\n\n我们可以使用像下面代码这样简单的表示。创建一个简单的、通用的类和该类的一个对象：\n>>> class Generic:\n...     pass\n...\n>>> g = Generic()\n前面的代码允许我们创建、获取、设置和删除属性。我们可以轻松地创建和获取一个属性。以下是一些示例：\n>>> g.attribute = \"value\"\n>>> g.attribute\n'value'\n>>> g.unset\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nAttributeError: 'Generic' object has no attribute 'unset'\n>>> del g.attribute\n>>> g.attribute\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nAttributeError: 'Generic' object has no attribute 'attribute'\n我们可以添加、更改和删除属性。如果我们试图获取一个未设置的属性或删除一个不存在的属性时会发生异常。\n稍微更好的方法就是使用types.SimpleNamespace类的一个实例。设置特性是一样的，但是我们不需要创建额外的类定义。我们创建一个SimpleNamespace类对象来代替，如下：\n>>> import types\n>>> n = types.SimpleNamespace()\n在以下代码中，我们可以看到为SimpleNamespace类工作的相同用例：\n>>> n.attribute = \"value\"\n>>> n.attribute\n'value'\n>>> del n.attribute\n>>> n.attribute\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nAttributeError: 'namespace' object has no attribute 'attribute'\n我们可以为这个对象创建属性。任何试图使用未定义的属性都会抛出异常。当我们创建一个object类实例时SimpleNamespace会有不同的行为。一个简单的object类实例不允许创建新的属性；它缺乏内部__dict__结构，Python会保存属性和值到该结构里面。\n1、属性和__init__()方法\n大多数时候，我们使用类的__init__()方法来创建一系列的初始属性。理想情况下，我们为__init__()中所有属性提供默认值。\n不需要提供所有属性到__init__()方法。正因为如此，存在或不在的属性可以作为一个对象状态的一部分。\n一个可选属性可以超越类定义的限制。对于一个类来说，有一组好的属性定义意义甚大。通过创建一个子类或父类，属性通常可以更清晰地被添加（或删除）。\n因此，可选属性意味着一种非正式的子类关系。因此，当我们使用可选属性时会碰到可怜的多态性。\n思考一下21点游戏，只有允许一次分牌。如果一手牌已经分牌，就不能再分牌。有几种方法，我们可以模拟一下：\n\n我们可以由Hand.split()方法创建一个SplitHand子类。在此我们不详细展示。\n我们可以在Hand对象中创建一个状态属性，由Hand.split()方法创建。理想情况下，这是一个布尔值，但是我们可以实现它作为一个可选属性。\n\n下面是通过一个可选属性检测可分离和不可分离的Hand.split()：\ndef split(self, deck):\n    assert self.cards[0].rank == self.cards[1].rank\n    try:\n        self.split_count\n        raise CannotResplit\n    except AttributeError:\n        h0 = Hand(self.dealer_card, self.cards[0], deck.pop())\n        h1 = Hand(self.dealer_card, self.cards[1], deck.pop())\n        h0.split_count = h1.split_count = 1\n    return h0, h1\n实际上，split()方法是检测是否有split_count属性。如果有这个属性，则是已经分牌的手牌且该方法抛出异常。如果split_count属性不存在，允许分牌。\n一个可选属性的优势是使__init__()方法有相对整洁的状态标识。劣势是模糊了对象的状态。使用try:块来确定对象状态可能会变得非常混乱，我们应该避免。\n创建特性\n特性是一个方法函数，它（语法上）看上去像一个简单的属性。我们可以获取、设置和删除特性值就像我们如何获取、设置和和删除属性值一样。这里有一个重要的区别，特性实际上是一个函数且可以处理，而不是简单地保存一个引用到一个对象。\n除了更加尖端之外，特性和属性之间的另一个差别就是我们不能轻易将新特性附加到现有对象上；然而，默认情况下我们可以地轻易给对象添加属性。在这方面特性和简单的属性是不一样的。\n有两种方法创建特性。我们可以使用@property装饰器或者我们可以使用property()函数。纯粹是语法的差异。我们将更多的关注装饰器。\n我们看看特性的两个基本设计模式：\n\n及早计算：在这个设计模式中，当我们通过特性设置一个值时，其他属性也同样计算。\n延迟计算：在这个设计模式中，计算将被推迟直到需要的时候，通过特性。\n\n为了比较前两种特性处理，我们将分割Hand对象的常见的特性到一个抽象父类，如下所示：\nclass Hand:\n\n    def __str__(self):\n        return \", \".join(map(str, self.card))\n\n    def __repr__(self):\n        return \"{__class__.__name__}({dealer_card!r}, {_cards_str})\"\n        .format(__class__=self.__class__, _cards_str=\", \"\n        .join(map(repr, self.card)), **self.__dict__)\n在前面的代码中，我们只是定义了一些字符串表示方法。\n下面是Hand的一个子类，total是一个延迟属性，只有在需要的时候进行计算：\nclass Hand_Lazy(Hand):\n\n    def __init__(self, dealer_card, *cards):\n        self.dealer_card = dealer_card\n        self._cards = list(cards)\n\n    @property\n    def total(self):\n        delta_soft = max(c.soft-c.hard for c in self._cards)\n        hard_total = sum(c.hard for c in self._cards)\n        if hard_total + delta_soft <= 21:\n            return hard_total + delta_soft\n        return hard_total\n\n    @property\n    def card(self):\n        return self._cards\n\n    @card.setter\n    def card(self, aCard):\n        self._cards.append(aCard)\n\n    @card.deleter\n    def card(self):\n        self._cards.pop(-1)\nHand_Lazy类初始化一个带有一组Cards对象的Hand对象。total特性是一个只有在需要的时候计算总和的方法。此外，我们定义了一些其他特性更新手中的牌。Card属性可以获取、设置或删除手中的牌。我们将在setter和deleter属性章节看到这些。\n我们可以创建一个Hand对象，total作为一个简单的属性出现：\n>>> d = Deck()\n>>> h = Hand_Lazy(d.pop(), d.pop(), d.pop())\n>>> h.total\n19\n>>> h.card = d.pop()\n>>> h.total\n29\n在每次需要总和的时候，通过重新扫描手中的牌延迟计算。这可是非常昂贵的开销。\n1、及早计算属性\n以下是Hand的一个子类，total是一个简单的属性，它会在每张牌被添加后立即计算：\nclass Hand_Eager(Hand):\n\n    def __init__(self, dealer_card, *cards):\n        self.dealer_card = dealer_card\n        self.total = 0\n        self._delta_soft = 0\n        self._hard_total = 0\n        self._cards = list()\n        for c in cards:\n            self.card = c\n\n    @property\n    def card(self):\n        return self._cards\n\n    @card.setter\n    def card(self, aCard):\n        self._cards.append(aCard)\n        self._delta_soft = max(aCard.soft - aCard.hard, self._delta_soft)\n        self._hard_total += aCard.hard\n        self._set_total()\n\n    @card.deleter\n    def card(self):\n        removed = self._cards.pop(-1)\n        self._hard_total -= removed.hard\n        # Issue: was this the only ace?\n        self._delta_soft = max(c.soft - c.hard for c in self._cards)\n        self._set_total()\n\n    def _set_total(self):\n        if self._hard_total+self._delta_soft <= 21:\n            self.total = self._hard_total + self._delta_soft\n        else:\n            self.total = self._hard_total\n在这种情况下，每添加一张牌，total属性就会更新。\n其他Card——deleter特性——及早地更新total属性无论牌在何时被删除。我们将在下一节详细查看deleter。\n客户端认为这两个子类之间的语法相同（Hand_Lazy()和Hand_Eager()）\nd = Deck()\nh1 = Hand_Lazy(d.pop(), d.pop(), d.pop())\nprint(h1.total)\nh2 = Hand_Eager(d.pop(), d.pop(), d.pop())\nprint(h2.total)\n在这两种情况下，客户端软件简单的使用total字段。\n使用特性的优势是，当实现改变时语法没有改变。我们可以做一个类似getter/setter简单要求的方法函数。然而，getter/setter方法函数涉及到并没有什么用处的额外语法。以下是两个例子，其中一个是使用setter方法，另一个是使用赋值运算符：\nobj.set_something(value)\nobj.something = value\n赋值运算符（=）的存在意图很简单。许多程序员发现赋值语句比setter方法函数看起来更清晰。\n2、setter和deleter特性\n在前面的例子中，我们定义了Card特性来处理额外的牌到Hand类对象。\n自从setter（和deleter）属性的创建来自getter，我们必须经常定义getter特性使用如下代码：\n@property\ndef card(self):\n    return self._cards\n\n@card.setter\ndef card(self, aCard):\n    self._cards.append(aCard)\n\n@card.deleter\ndef card(self):\n    self._cards.pop(-1)\n这允许我们用一条简单的语句添加一张牌到手中像下面这样：\nh.card = d.pop()\n前面的赋值语句有一个缺点，因为它看起来像一张牌替代了所有的牌。另一方面，它也有一个优势，因为它使用简单赋值来更新一个可变对象的状态。我们可以使用__iadd__()特殊方法，这样做更简洁。但我们会等到第七章《创建数字》引入其他特殊方法。\n我们当前的例子，没有令人信服的理由来使用deleter特性。即使没有一个令人信服的理由，还是有一些deleter用法。无论如何，我们还可以利用它来删除最后一张处理过的牌。这可以用作分牌过程的一部分。\n我们可以思考一下以下版本的split()，如下代码显示：\ndef split(self, deck):\n    \"\"\"Updates this hand and also returns the new hand.\"\"\"\n    assert self._cards[0].rank == self._cards[1].rank\n    c1 = self._cards[-1]\n    del self.card\n    self.card = deck.pop()\n    h_new = self.__class__(self.dealer_card, c1, deck.pop())\n    return h_new\n前面的方法更新给定的手牌并返回新的Hand对象。下面是一个分牌的例子：\n>>> d = Deck()\n>>> c = d.pop()\n>>> h = Hand_Lazy(d.pop(), c, c) # Force splittable hand\n>>> h2 = h.split(d)\n>>> print(h)\n2♠, 10♠\n>>> print(h2)\n2♠, A♠\n一旦我们有两张牌，我们可以使用split()产生第二个手牌。一张牌从最初的手牌中被移除。\n这个版本的split()当然是可行的。然而，似乎有所好转的使用split()方法返回两个新的Hand对象。这样，旧的、预分牌的Hand实例可以用作收集统计数据。\n对属性访问使用特殊方法\n我们来看看这三个规范的访问属性的特殊方法：getattr()、setattr()和delattr()。此外，我们会知道__dir__()方法会显示属性名称。我们推迟到下一节来介绍__getattribute__()。\n第一节默认行为的展示如下：\n\n__setattr__()方法将创建并设置属性。\n__getattr__()方法将做两件事。首先，如果一个属性已经有值，__getattr__()不使用，只是返回属性值。其次，如果属性没有值，那么__getattr__()会有机会返回有意义的值。如果没有属性，它一定会抛出一个AttributeError异常。\n__delattr__()方法删除一个属性。\n__dir__()方法返回属性名称列表。\n\n__getattr__()方法函数在更大的处理过程中只有一个步骤；只有当属性是未知的才会去使用。如果属性是已知的，不使用这种方法。__setattr__()和__delattr__()方法没有内置的处理。这些方法不与额外的处理过程进行交互。\n对于控制属性访问我们有许多设计可选。这根据我们的三个基本设计来选择是扩展、包装或发明。选择如下：\n\n我们可以扩展一个类，通过重写__setattr__()和__delattr__()使它几乎不可变。我们也可以通过__slots__替换内部的__dict__。\n我们可以包装类和委托属性访问到即将包装的对象(或复合对象)。这可能涉及到覆写所有三种方法。\n我们可以在一个类中实现类特性行为。使用这些方法，我们可以确保所有属性集中处理。\n我们可以创建延迟属性值尽管它的值在需要的时候没有（或不能）计算。可能会有一个属性没有值，直到从文件、数据库或网络中读取到。这对于__getattr__()是常用用法。\n我们可以有及早属性，在其他属性中自动设置时创建一个属性值。这是通过覆写__setattr__()做到的。\n\n我们不会看所有这些选择。相反，我们将关注两个最常用的技术：扩展和包装。我们将创建不可变对象，看看其他方法来及早计算特性值。\n1、通过__slots__创建不可变对象\n如果我们不能够设置一个属性或创建一个新的，且对象是不可变的。则以下是我们希望在交互式Python中所能够看到的：\n>>> c = card21(1,'♠')\n>>> c.rank = 12\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"<stdin>\", line 30, in __setattr__\nTypeError: Cannot set rank\n>>> c.hack = 13\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"<stdin>\", line 31, in __setattr__\nAttributeError: 'Ace21Card' has no attribute 'hack'\n前面的代码显示，我们是不允许改变这个对象的属性或添加一个到这个对象种。\n为了让此操作可以顺利工作我们需要变化这个类定义中的两个地方。我们将忽略很多类，只关注三个特性，使一个对象不可变，如下所示：\nclass BlackJackCard:\n    \"\"\"Abstract Superclass\"\"\"\n    __slots__ = ('rank', 'suit', 'hard', 'soft')\n    def __init__(self, rank, suit, hard, soft):\n        super().__setattr__('rank', rank)\n        super().__setattr__('suit', suit)\n        super().__setattr__('hard', hard)\n        super().__setattr__('soft', soft)\n\n    def __str__(self):\n        return \"{0.rank}{0.suit}\".format(self)\n\n    def __setattr__(self, name, value):\n        raise AttributeError(\"'{__class__.__name__}' has no attribute '{name}'\"\n        .format(__class__ = self.__class__, name = name))\n我们做了三个重要的变动：\n\n我们设置__slots__到只被允许的属性。这个将关闭对象内部__dict__的特性且允许限制属性。\n我们定义的__setattr__()会引发一个异常比不做任何事有用的多。\n我们定义__init__()使用的超类版本的__setattr__()这样值就可以正确设置，尽管这个类中缺少了正常工作的__setattr__()方法。\n\n小心一些，如果这样做我们可以绕过不变性特性。\nobject.__setattr__(c, 'bad', 5)\n这给我们带来了一个问题。我们如何防止“邪恶的”程序员绕过不变性特性？这个问题是愚蠢的。我们并不能阻止邪恶的程序员。另一个同样愚蠢的问题是，为什么一些邪恶的程序员写代码来规避不变性？我们并不能阻止邪恶的程序员做邪恶的事情。\n如果这个虚构的程序员不喜欢类中的不变性，他们可以修改类的定义来删除重新定义的__setattr__()。不可变对象的重点是保证__hash__()返回一个一致的值，而不是阻止人们写烂的代码。\n不要滥用__slots__\n__slots__特性的主要目的是通过限制字段的数量来节省内存。\n2、创建不可变对象作为元组的子类\n我们也可以通过给Card属性一个元组子类并覆写__getattr__()来创建一个不可变对象。在这种情况下，我们将翻译__getattr__(name)请求为self[index]请求。在第六章《创建容器和集合》中我们将看到，self[index]是由__getitem__(index)来实现的。\n下面是内置tuple类的一个小扩展：\nclass BlackJackCard2(tuple):\n\n    def __new__(cls, rank, suit, hard, soft):\n        return super().__new__(cls, (rank, suit, hard, soft))\n\n    def __getattr__(self, name):\n        return self[{'rank':0, 'suit':1, 'hard':2 , 'soft':3}[name]]\n\n    def __setattr__(self, name, value):\n        raise AttributeError\n在本例中，我们只是简单的抛出了AttributeError异常而不是提供详细的错误消息。\n当我们使用前面的代码中，我们看到以下交互：\n>>> d = BlackJackCard2('A', '♠', 1, 11)\n>>> d.rank\n'A'\n>>> d.suit\n'♠'\n>>> d.bad = 2\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"<stdin>\", line 7, in __setattr__AttributeError\n我们不能轻易的改变牌值。然而，我们仍然可以调整d.__dict__来引入额外的属性。\n有这必要吗\n也许，简单的工作可以确保对象不是不小心误用。实际上，我们对从异常得到的诊断信息和跟踪，比我们在极其安全的不可变类中更感兴趣。\n3、及早计算属性\n我们可以定义一个对象，它的属性在设置值后尽可能快的及早计算。对象最优访问就是进行一次计算结果多次使用。\n我们能够定义很多的setter特性来做这些。然而，过多的setter特性，每个属性都计算，会使得计算变得冗长复杂。\n我们可以集中式的进行属性处理。在接下来的例子中，我们将对其调整来扩展Python的内部dict类型。扩展dict的优点是，它能够很好地处理字符串的format()方法。同时，我们不必过多担心设置额外的被忽略的属性值。\n我们希望类似下面的代码：\n>>> RateTimeDistance(rate=5.2, time=9.5)\n{'distance': 49.4, 'time': 9.5, 'rate': 5.2}\n>>> RateTimeDistance(distance=48.5, rate=6.1)\n{'distance': 48.5, 'time': 7.950819672131148, 'rate': 6.1}\n我们可以在RateTimeDistance对象中设置值。额外的属性可以很轻松的被计算。我们可以一次性做到这些，如下代码所示：\n>>> rtd = RateTimeDistance()\n>>> rtd.time = 9.5\n>>> rtd\n{'time': 9.5}\n>>> rtd.rate = 6.24\n>>> rtd\n{'distance': 59.28, 'time': 9.5, 'rate': 6.24}\n下面是内置dict类型的扩展。我们扩展了基本dict映射用来实现计算缺失的属性：\nclass RateTimeDistance(dict):\n\n    def __init__(self, *args, **kw):\n        super().__init__(*args, **kw)\n        self._solve()\n\n    def __getattr__(self, name):\n        return self.get(name,None)\n\n    def __setattr__(self, name, value):\n        self[name] = value\n        self._solve()\n\n    def __dir__(self):\n        return list(self.keys())\n\n    def _solve(self):\n        if self.rate is not None and self.time is not None:\n            self['distance'] = self.rate * self.time\n        elif self.rate is not None and self.distance is not None:\n            self['time'] = self.distance / self.rate\n        elif self.time is not None and self.distance is not None:\n            self['rate'] = self.distance / self.time\ndict类型使用__init__()来填充内部字典，然后试图解决当前数据太多的问题。它使用__setattr__()来添加新项目到字典。它也试图在每次设置值的时候解答等式。\n在__getattr__()中，在等式中我们使用None表明值的缺失。这允许我们设置一个字段为None表明它是一个缺失的值，这将迫使为此寻找解决方案。例如，我们可以基于用户输入或者一个网络请求，所有参数被赋予一个值，但一个变量设置为None。\n我们可以如下使用：\n>>> rtd = RateTimeDistance(rate=6.3, time=8.25, distance=None)\n>>> print(\"Rate={rate}, Time={time}, Distance={distance}\".format(**rtd))\nRate=6.3, Time=8.25, Distance=51.975\n请注意，我们不能轻易地在这个类里面设置属性值。\n让我们考虑下面这行代码：\nself.distance = self.rate * self.time\n如果我们要编写之前的代码片段，我们会在__setattr__()和_solve()之间进行无限的递归调用。当我们使用self['distance']到这个例子中，我们避免了递归调用__setattr__()。\n同样重要的是要注意，一旦设置了所有三个值，该对象不能轻易被改变来提供新的解决方案。\n我们不能简单地给rate设置一个新值且计算time新值必须让distance不变。为了调整这个模型，我们需要清除一个变量以及为另一个变量设置一个新值：\n>>> rtd.time = None\n>>> rtd.rate = 6.1\n>>> print(\"Rate={rate}, Time={time}, Distance={distance}\".format(**rtd))\nRate=6.1, Time=8.25, Distance=50.324999999999996\n这里，我们清除time且改变rate得到一个新的解决方案来使用既定的distance值。\n我们可以设计一个模型，跟踪设置变量的顺序；这一模型可以节省我们在设置另一个变量重新计算相关结果之前清除一个变量。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "7"}