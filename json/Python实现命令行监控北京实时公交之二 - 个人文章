{"title": "Python实现命令行监控北京实时公交之二 - 个人文章 ", "index": "python", "content": "链接前文：Python实现命令行监控北京实时公交之一\n\n开头先放上效果展示\n在命令行输入 python bus.py -i，显示app基本信息，如下：\n\n在命令行输入 python bus.py 438，显示北京438路公交车的位置，如下：\n\n红色的B说明在梅园附近有一辆438公交车，并且会不断刷新。\nGitHub地址 - https://github.com/Harpsichor...\n\n命令行显示输出及美化\n前文我们实现了获取公交车位置的函数，现在需要将其美化并输出到命令行中，这里分别使用docopt/prettytable/colorama三个库。\n\nprettytable库和colorama库\n简单来说，prettytable可以将数据以表格的形式打印，colorama可以设置命令行中字体的颜色，直接上代码：\nfrom prettytable import PrettyTable\nfrom colorama import Fore, init\n\n# colorama需要init使用\ninit()\n\n# 函数接受4个参数\n# data0/data1分别是往返站点信息的list，其中的元素也是list，结构是['id', 站名, 是否有公交车]\n# time0/time1是往返线路运营时间\ndef print_direction_and_station(data0, data1, time0, time1):\n    pt = PrettyTable()\n    # 设置表头，为了美观往返之间留一个空列\n    pt.field_names = ['#0', 'UP:' + time0, 'Bus0', '   ', '#1', 'DOWN:' + time1, 'Bus1']\n    # 往返路线的站数可能不一致，取最大值作为行\n    for i in range(max(len(data0), len(data1))):\n        if i >= len(data0):\n            r0 = [' '] * 3\n        else:\n            r0 = data0[i]\n            # 'B'表示该车站附近有公交车\n            if r0[2] == 'B':\n                # 设置文本的颜色为红色\n                r0[1] = Fore.RED + r0[1]\n                # 去除红色，否则后面全是红的\n                r0[2] = r0[2] + Fore.RESET\n        if i >= len(data1):\n            r1 = [' '] * 3\n        else:\n            r1 = data1[i]\n            if r1[2] == 'B':\n                r1[1] = Fore.RED + r1[1]\n                r1[2] = r1[2] + Fore.RESET\n        pt.add_row(r0 + ['   '] + r1)\n    # 打印结果\n    print(pt)\n\ndocopt库\ndocopt可以读取一段字符串（通常是__doc__），并将其解析为命令行参数，例如在bus.py开头输入以下内容：\n\"\"\"\nUsage:\n    bus <bus_code>\n    bus [-ih]\n\nOptions:\n    -h              Show help information\n    -i              Show application information\n\nExample:\n    bus 438         Show stations, directions and positions of bus 438\n\"\"\"\n并使用from docopt import docopt引入模块，结尾代码如下：\nif __name__ == \"__main__\":\n    args = docopt(__doc__)\n    print(args)\n直接使用python bus.py运行，输出的结果是：\n\n从中不难发现，docopt解析了__doc__中Usage的部分，将参数以字典的形式返回，我们改变输入命令的参数，返回的args字典对应的value也将不同。\n\n前文中我们获取的公交车位置信息需要经过一些处理才能传给print_direction_and_station函数，结合命令行参数，代码如下：\nif __name__ == \"__main__\":\n    args = docopt(__doc__)\n    b_code = args['<bus_code>']\n    # 如果输入了<bus_code>参数\n    if b_code:\n        # 获取往返线路id\n        [d0, _], [d1, _] = get_bus_direction(b_code)\n        # 获取往返车站\n        stations0 = get_bus_stations(b_code, d0)\n        stations1 = get_bus_stations(b_code, d1)\n        # 进入循环以刷新\n        while 1:\n            direction0 = []\n            direction1 = []\n            status0 = get_bus_status(b_code, d0, len(d0))\n            status1 = get_bus_status(b_code, d1, len(d1))\n            pos0 = status0['bus_position']\n            # pos0_id/pos1_id 是有公交车的车站id\n            pos0_id = [p['station_id'] for p in pos0]\n            pos1 = status1['bus_position']\n            pos1_id = [p['station_id'] for p in pos1]\n            # 两个for循环构建传给print_direction_and_station参数\n            for i, d in enumerate(stations0):\n                bus = ' '\n                if str(i+1) in pos0_id:\n                    bus = 'B'\n                direction0.append([i+1, d, bus])\n            for i, d in enumerate(stations1):\n                bus = ' '\n                if str(i + 1) in pos1_id:\n                    bus = 'B'\n                direction1.append([i+1, d, bus])\n            print_direction_and_station(direction0, direction1, status0['operation_time'], status1['operation_time'])\n            # 每5s刷新一次\n            sleep(5)\n\n此时输入python bus.py 438，就可以显示上文图中的结果了，python bus.py -i也是同理，自定义一个print信息的函数即可。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}