{"title": "python中的RLock和Lock - Mr布 ", "index": "lock,rlock,锁,多线程,python", "content": "为了保证多线程任务执行时，共享资源的同步，出现了锁这个东西。\nLock是阻塞其他线程对共享资源的访问，且同一线程只能acquire一次，如多于一次就出现了死锁，程序无法继续执行。\n为了保证线程对共享资源的独占，又避免死锁的出现，就有了RLock。RLock允许在同一线程中被多次acquire，线程对共享资源的释放需要把所有锁都release。即n次acquire，需要n次release。\n\nimport threading,time,random\nlock=threading.RLock()\nresult=[]\ndef step1():\n    global result\n    if lock.acquire():\n        result.append('step1')\n        time.sleep(2)\n        lock.release()\ndef step2():\n    global result\n    if lock.acquire():\n        result.append('step2')\n        time.sleep(2)\n        lock.release()\n\ndef showresult():\n    if lock.acquire():\n        step1()\n        step2()\n        lock.release()\n    print result\n\ndef clearresult():\n    global result\n    if lock.acquire():\n        result=None\n        time.sleep(2)\n        lock.release()\n    print result\n\nt1=threading.Thread(target=showresult)\nt2=threading.Thread(target=clearresult)\n\nt1.start()\nt2.start()\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "5"}