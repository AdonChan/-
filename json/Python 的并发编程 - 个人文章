{"title": "Python 的并发编程 - 个人文章 ", "index": "python,并发", "content": "本文最先发布在博客：https://blog.ihypo.net/151628...\n\n这篇文章将讲解 Python 并发编程的基本操作。并发和并行是对孪生兄弟，概念经常混淆。并发是指能够多任务处理，并行则是是能够同时多任务处理。Erlang 之父 Joe Armstrong 有一张非常有趣的图说明这两个概念：\n我个人更喜欢的一种说法是：并发是宏观并行而微观串行。\nGIL\n虽然 Python 自带了很好的类库支持多线程/进程编程，但众所周知，因为 GIL 的存在，Python 很难做好真正的并行。\nGIL 指全局解释器锁，对于 GIL 的介绍：\n\n全局解释器锁（英语：Global Interpreter Lock，缩写GIL），是计算机程序设计语言解释器用于同步线程的一种机制，它使得任何时刻仅有一个线程在执行。\n维基百科\n\n其实与其说 GIL 是 Python 解释器的限制，不如说是 CPython 的限制，因为 Python 为了保障性能，底层大多使用 C 实现的，而 CPython 的内存管理并不是线程安全的，为了保障整体的线程安全，解释器便禁止多线程的并行执行。\n因为 Python 社区认为操作系统的线程调度已经非常成熟了，没有必要自己再实现一遍，因此 Python 的线程切换基本是依赖操作系统，在实际的使用中，对于单核 CPU，GIL 并没有太大的影响，但对于多核 CPU 却引入了线程颠簸（thrashing）问题。\n线程颠簸是指作为单一资源的 GIL 锁，在被多核心竞争强占时资源额外消耗的现象。\n比如下图，线程1 在释放 GIL 锁后，操作系统唤醒了 线程2，并将 线程2 分配给 核心2 执行，但是如果此时 线程2 却没有成功获得 GIL 锁，只能再次被挂起。此时切换线程、切换上下文的资源都将白白浪费。\n\n因此，Python 多线程程序在多核 CPU 机器下的性能不一定比单核高。那么如果是计算密集型的程序，一般还是考虑用 C 重写关键部分，或者使用多进程避开 GIL。\n多线程\n在 Python 中使用多线程，有 thread 和 threading 可供原则，thread 提供了低级别的、原始的线程以及一个简单的锁，因为 thread 过于简陋，线程管理容易出现人为失误，因此官方更建议使用 threading，而 threading 也不过是对 thread 的封装和补充。（Python3 中 thread 被改名为 _thread）。\n在 Python 中创建线程非常简单：\nimport time\nimport threading\n\n\ndef do_task(task_name):\n    print(\"Get task: {}\".format(task_name))\n    time.sleep(1)\n    print(\"Finish task: {}\".format(task_name))\n\n\nif __name__ == \"__main__\":\n    tasks = []\n    for i in range(0, 10):\n        # 创建 task\n        tasks.append(threading.Thread(\n            target=do_task,\n            args=(\"task_{}\".format(i),)))\n    for t in tasks:\n        # 开始执行 task\n        t.start()\n\n    for t in tasks:\n        # 等待 task 执行完毕\n        # 完毕前会阻塞住主线程\n        t.join()\n    print(\"Finish.\")\n直接创建线程简单优雅，如果逻辑复杂，也可以通过继承 Thread 基类完成多线程：\nimport time\nimport threading\n\n\nclass MyTask(threading.Thread):\n    def __init__(self, task_name):\n        super(MyTask, self).__init__()\n        self.task_name = task_name\n\n    def run(self):\n        print(\"Get task: {}\".format(self.task_name))\n        time.sleep(1)\n        print(\"Finish task: {}\".format(self.task_name))\n\n\nif __name__ == \"__main__\":\n    tasks = []\n    for i in range(0, 10):\n        # 创建 task\n        tasks.append(MyTask(\"task_{}\".format(i)))\n    for t in tasks:\n        # 开始执行 task\n        t.start()\n\n    for t in tasks:\n        # 等待 task 执行完毕\n        # 完毕前会阻塞住主线程\n        t.join()\n    print(\"Finish.\")\n多进程\n在 Python 中，可以使用 multiprocessing 库来实现多进程编程，和多线程一样，有两种方法可以使用多进程编程。\n直接创建进程：\nimport time\nimport random\nimport multiprocessing\n\n\ndef do_something(task_name):\n    print(\"Get task: {}\".format(task_name))\n    time.sleep(random.randint(1, 5))\n    print(\"Finish task: {}\".format(task_name))\n\n\nif __name__ == \"__main__\":\n    tasks = []\n    for i in range(0, 10):\n        # 创建 task\n        tasks.append(multiprocessing.Process(\n            target=do_something,\n            args=(\"task_{}\".format(i),)))\n    for t in tasks:\n        # 开始执行 task\n        t.start()\n\n    for t in tasks:\n        # 等待 task 执行完毕\n        # 完毕前会阻塞住主线程\n        t.join()\n    print(\"Finish.\")\n继承进程父类：\nimport time\nimport random\nimport multiprocessing\n\n\nclass MyTask(multiprocessing.Process):\n    def __init__(self, task_name):\n        super(MyTask, self).__init__()\n        self.task_name = task_name\n\n    def run(self):\n        print(\"Get task: {}\".format(self.task_name))\n        time.sleep(random.randint(1, 5))\n        print(\"Finish task: {}\".format(self.task_name))\n\n\nif __name__ == \"__main__\":\n    tasks = []\n    for i in range(0, 10):\n        # 创建 task\n        tasks.append(MyTask(\"task_{}\".format(i)))\n    for t in tasks:\n        # 开始执行 task\n        t.start()\n\n    for t in tasks:\n        # 等待 task 执行完毕\n        # 完毕前会阻塞住主线程\n        t.join()\n    print(\"Finish.\")\nmultiprocessing 除了常用的多进程编程外，我认为它最大的意义在于提供了一套规范，在该库下有一个 dummy 模块，即 multiprocessing.dummy，里面对 threading 进行封装，提供了和 multiprocessing 相同 API 的线程实现，换句话说，class::multiprocessing.Process 提供的是进程任务类，而 class::multiprocessing.dummy.Process，也正是有 multiprocessing.dummy 的存在，可以快速的讲一个多进程程序改为多线程：\nimport time\nimport random\nfrom multiprocessing.dummy import Process\n\n\nclass MyTask(Process):\n    def __init__(self, task_name):\n        super(MyTask, self).__init__()\n        self.task_name = task_name\n\n    def run(self):\n        print(\"Get task: {}\".format(self.task_name))\n        time.sleep(random.randint(1, 5))\n        print(\"Finish task: {}\".format(self.task_name))\n\n\nif __name__ == \"__main__\":\n    tasks = []\n    for i in range(0, 10):\n        # 创建 task\n        tasks.append(MyTask(\"task_{}\".format(i)))\n    for t in tasks:\n        # 开始执行 task\n        t.start()\n\n    for t in tasks:\n        # 等待 task 执行完毕\n        # 完毕前会阻塞住主线程\n        t.join()\n    print(\"Finish.\")\n无论是多线程还是多进程编程，这也是我一般会选择 multiprocessing 的原因。\n除了直接创建进程，还可以用进程池（或者 multiprocessing.dummy 里的进程池）：\nimport time\nimport random\nfrom multiprocessing import Pool\n\n\ndef do_task(task_name):\n    print(\"Get task: {}\".format(task_name))\n    time.sleep(random.randint(1, 5))\n    print(\"Finish task: {}\".format(task_name))\n\n\nif __name__ == \"__main__\":\n    pool = Pool(5)\n    for i in range(0, 10):\n        #     创建 task\n        pool.apply_async(do_task, (\"task_{}\".format(i),))\n    pool.close()\n    pool.join()\n    print(\"Finish.\")\n线程池：\nimport time\nimport random\nfrom multiprocessing.dummy import Pool\n\n\ndef do_task(task_name):\n    print(\"Get task: {}\".format(task_name))\n    time.sleep(random.randint(1, 5))\n    print(\"Finish task: {}\".format(task_name))\n\n\nif __name__ == \"__main__\":\n    pool = Pool(5)\n    for i in range(0, 10):\n        #     创建 task\n        pool.apply_async(do_task, (\"task_{}\".format(i),))\n    pool.close()\n    pool.join()\n    print(\"Finish.\")\n这里示例有个问题，pool 在 join 前需要 close 掉，否则就会抛出异常，不过 Python 之禅的作者 Tim Peters 给出解释：\nAs to Pool.close(), you should call that when - and only when - you're never going to submit more work to the Pool instance. So Pool.close() is typically called when the parallelizable part of your main program is finished. Then the worker processes will terminate when all work already assigned has completed.It's also excellent practice to call Pool.join() to wait for the worker processes to terminate. Among other reasons, there's often no good way to report exceptions in parallelized code (exceptions occur in a context only vaguely related to what your main program is doing), and Pool.join() provides a synchronization point that can report some exceptions that occurred in worker processes that you'd otherwise never see.\n\n同步原语\n在多进程编程中，因为进程间的资源隔离，不需要考虑内存的线程安全问题，而在多线程编程中便需要同步原语来保存线程安全，因为 Python 是一门简单的语言，很多操作都是封装的操作系统 API，因此支持的同步原语蛮全，但这里只写两种常见的同步原语：锁和信号量。\n通过使用锁可以用来保护一段内存空间，而信号量可以被多个线程共享。\n在 threading 中可以看到 Lock 锁和 RLock 重用锁两种锁，区别如名。这两种锁都只能被一个线程拥有，第一种锁只能被获得一次，而重用锁可以被多次获得，但也需要同样次数的释放才能真正的释放。\n当多个线程对同一块内存空间同时进行修改的时候，经常遇到奇怪的问题：\nimport time\nimport random\nfrom threading import Thread, Lock\n\ncount = 0\n\n\ndef do_task():\n    global count\n    time.sleep(random.randint(1, 10) * 0.1)\n    tmp = count\n    tmp += 1\n    time.sleep(random.randint(1, 10) * 0.1)\n    count = tmp\n    print(count)\n\n\nif __name__ == \"__main__\":\n    tasks = []\n    for i in range(0, 10):\n        tasks.append(Thread(target=do_task))\n    for t in tasks:\n        t.start()\n    for t in tasks:\n        t.join()\n    print(\"Finish. Count = {}\".format(count))\n如上就是典型的非线程安全导致 count 没有达到预期的效果。而通过锁便可以控制某一段代码，或者说某段内存空间的访问：\nimport time\nimport random\nfrom threading import Thread, Lock\n\ncount = 0\nlock = Lock()\n\n\ndef do_task():\n    lock.acquire()\n    global count\n    time.sleep(random.randint(1, 10) * 0.1)\n    tmp = count\n    tmp += 1\n    time.sleep(random.randint(1, 10) * 0.1)\n    count = tmp\n    print(count)\n    lock.release()\n\n\nif __name__ == \"__main__\":\n    tasks = []\n    for i in range(0, 10):\n        tasks.append(Thread(target=do_task))\n    for t in tasks:\n        t.start()\n    for t in tasks:\n        t.join()\n    print(\"Finish. Count = {}\".format(count))\n当然，上述例子非常暴力，直接强行把并发改为串行。\n对于信号量常见于有限资源强占的场景，可以定义固定大小的信号量供多个线程获取或者释放，从而控制线程的任务执行，比如下面的例子，控制最多有 5 个任务在执行：\nimport time\nimport random\nfrom threading import Thread, BoundedSemaphore\n\nsep = BoundedSemaphore(5)\n\n\ndef do_task(task_name):\n    sep.acquire()\n    print(\"do Task: {}\".format(task_name))\n    time.sleep(random.randint(1, 10))\n    sep.release()\n\n\nif __name__ == \"__main__\":\n    tasks = []\n    for i in range(0, 10):\n        tasks.append(Thread(target=do_task, args=(\"task_{}\".format(i),)))\n    for t in tasks:\n        t.start()\n    for t in tasks:\n        t.join()\n    print(\"Finish.\")\nQueue 和 Pipe\n因为多进程的内存隔离，不会存在内存竞争的问题。但同时，多个进程间的数据共享成为了新的问题，而进程间通信常见：队列，管道，信号。\n这里只讲解队列和管道。\n队列常见于双进程模型，一般用作生产者-消费者模式，由生产者进程向队列中发布任务，并由消费者从队列首部拿出任务进行执行：\nimport time\nfrom multiprocessing import Process, Queue\n\n\nclass Task1(Process):\n    def __init__(self, queue):\n        super(Task1, self).__init__()\n        self.queue = queue\n\n    def run(self):\n        item = self.queue.get()\n        print(\"get item: [{}]\".format(item))\n\n\nclass Task2(Process):\n    def __init__(self, queue):\n        super(Task2, self).__init__()\n        self.queue = queue\n\n    def run(self):\n        print(\"put item: [Hello]\")\n        time.sleep(1)\n        self.queue.put(\"Hello\")\n\n\nif __name__ == \"__main__\":\n    queue = Queue()\n    t1 = Task1(queue)\n    t2 = Task2(queue)\n    t1.start()\n    t2.start()\n    t1.join()\n    print(\"Finish.\")\n理论上每个进程都可以向队列里的读或者写，可以认为队列是半双工路线。但是往往只有特定的读进程（比如消费者）和写进程（比如生产者），尽管这些进程只是开发者自己定义的。\n而 Pipe 更像一个全工路线：\nimport time\nfrom multiprocessing import Process, Pipe\n\n\nclass Task1(Process):\n    def __init__(self, pipe):\n        super(Task1, self).__init__()\n        self.pipe = pipe\n\n    def run(self):\n        item = self.pipe.recv()\n        print(\"Task1: recv item: [{}]\".format(item))\n        print(\"Task1: send item: [Hi]\")\n        self.pipe.send(\"Hi\")\n\n\nclass Task2(Process):\n    def __init__(self, pipe):\n        super(Task2, self).__init__()\n        self.pipe = pipe\n\n    def run(self):\n        print(\"Task2: send item: [Hello]\")\n        time.sleep(1)\n        self.pipe.send(\"Hello\")\n        time.sleep(1)\n        item = self.pipe.recv()\n        print(\"Task2: recv item: [{}]\".format(item))\n\n\nif __name__ == \"__main__\":\n    pipe = Pipe()\n    t1 = Task1(pipe[0])\n    t2 = Task2(pipe[1])\n    t1.start()\n    t2.start()\n    t1.join()\n    t2.join()\n    print(\"Finish.\")\n库\n除了上面介绍的 threading 和 multiprocessing 两个库外，还有一个好用的令人发指的库 concurrent.futures。和前面两个库不同，这个库是更高等级的抽象，隐藏了很多底层的东西，但也因此非常好用。用官方的例子：\nwith ThreadPoolExecutor(max_workers=1) as executor:\n    future = executor.submit(pow, 323, 1235)\n    print(future.result())\n该库中自带了进程池和线程池，可以通过上下文管理器来管理，而且对于异步任务执行完后，结果的获得也非常简单。再拿一个官方的多进程计算的例子作为结束：\nimport concurrent.futures\nimport math\n\nPRIMES = [\n    112272535095293,\n    112582705942171,\n    112272535095293,\n    115280095190773,\n    115797848077099,\n    1099726899285419]\n\ndef is_prime(n):\n    if n % 2 == 0:\n        return False\n\n    sqrt_n = int(math.floor(math.sqrt(n)))\n    for i in range(3, sqrt_n + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef main():\n    with concurrent.futures.ProcessPoolExecutor() as executor:\n        for number, prime in zip(PRIMES, executor.map(is_prime, PRIMES)):\n            print('%d is prime: %s' % (number, prime))\n\nif __name__ == '__main__':\n    main()\n欢迎关注个人公众号：CS实验室\n\n                ", "mainLikeNum": ["4 "], "mainBookmarkNum": "6"}