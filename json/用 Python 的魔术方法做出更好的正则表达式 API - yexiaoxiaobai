{"title": "用 Python 的魔术方法做出更好的正则表达式 API - yexiaoxiaobai ", "index": "正则表达式,api,python", "content": "\n  注：原文地址为 Playing with Python Magic Methods to make a nicer Regex API\n\n\n我的一个同事提到,他错过了 Ruby 的正则表达式的语法糖。我没有使用过 Ruby 的正则表达式，但是以我对 Python 的足够了解知道 API 是缺少足够的语法糖。\n\n首先，从正则表达式检索捕捉组需要两个步骤。第一步，你需要调用 match() 或是 search()，并将结果分配给一个变量。然后，你需要检查结果是否为 None（表明没有发现匹配）。最后，如果匹配存在，你可以安全的提取捕获组。下面是一个示例：\n\n>>> import re\n>>> match_obj = re.match('([0-9]+)', '123foo')\n>>> match_obj  # What is `match_obj`?\n<_sre.SRE_Match object at 0x7fd1bb000828>\n>>> match_obj.groups()\n('123',)\n\n>>> match_obj = re.match('([0-9]+)', 'abc')\n>>> match_obj\nNone\n\n\n还可以更好，在我看来，类似下面：\n\n>>> re.get_matches('([0-9]+)', '123foo')\n('123',)\n\n>>> re.get_matches('([0-9]+)', 'abc')\nNone\n\n\n我经常遇到的另外一件事情就是 re.sub 的混合参数，它可以执行正则的查找和替换。要求的参数，按照顺序，是 pattern，replacement， search_string。无论出于何种原因，对我来说，更直观的是在替换之前使用 search_string。\n\n不幸的是，改编这些参数会导致“看起来正确”的结果。下面是一个例子，这里的目标是使用单词 bar 替换单词 foo。\n\n>>> re.sub('foo', 'replace foo with bar', 'bar')\n'bar'\n\n>>> re.sub('foo', 'bar', 'replace foo with bar')\n'replace bar with bar'\n\n\n\n  其中关于 re.sub 的用法可以参考这篇文章，很详细 http://www.crifan.com/python_re_sub_detailed_introduction/\n\n\n在第一个例子中，我们可能会假设输入的字符串只是“foo”。\n\n语法糖\n\n为了好玩，我把一个小小的增加了一些语法糖的 Python 正则表达式库的帮助类放在一起。我不建议任何人都使用它，但好玩的是，也许它可以为你提供一些提高其他库的语法的想法。\n\n再我向你展示这个实现之前，这里有我设计的一个 API 的示例。\n\n寻找匹配的单步操作：\n\n>>> def has_lower(s):\n...     return bool(R/'[a-z]+'/s)\n\n>>> has_lower('This contains lower-case')\nTrue\n>>> has_lower('NO LOWER-CASE HERE!')\nFalse\n\n\n检索捕获组也是非常容易的：\n\n>>> list(R/'([0-9]+)'/'extract 12 the 456 numbers')\n['12', '456']\n\n\n最后你可以使用字符串插值来实现替换：\n\n>>> R/'(foo|bar)'/'replace foo and bar' % 'Huey!'\n'replace Huey! and Huey!'\n\n\n你怎么认为？是不是很有趣？\n\n实现\n\n这个实现是非常简单的，依赖于 Python 的魔术方法提供的 API。是否有一个整洁的技巧，本质上，它是使用一个元类来实现类方法的操作符重载。\n\nimport re\n\nclass _R(type):\n    def __div__(self, regex):\n        return R(regex)\n\nclass R(object):\n    __metaclass__ = _R\n\n    def __init__(self, regex):\n        self._regex = re.compile(regex)\n\n    def __div__(self, s):\n        return RegexOperation(self._regex, s)\n\nclass RegexOperation(object):\n    def __init__(self, regex, search):\n        self._regex = regex\n        self._search = search\n\n    def search(self):\n        match =  self._regex.search(self._search)\n        if match is not None:\n            return match.groups()\n\n    def __len__(self):\n        return self._regex.search(self._search) is not None\n\n    def __mod__(self, replacement):\n        return self._regex.sub(replacement, self._search)\n\n    def __iter__(self):\n        return iter(self._regex.findall(self._search))\n\n\n通过一步步的操作，希望它可以阐明幕后的知识。\n\n调用 R / <something> 将调用 _R 类的 __div__ 方法。它是一个创建 R 实例的工厂方法。\n\n>>> R/'foo'\n<rx.R at 0x7f77c00831d0>\n\n\n然后，在最新创建的 R 对象上调用 __div__ 方法，我们会得到一个 RegexOperation 实例，因此 R.__div__ 是另外一个工厂方法。\n\n>>> r_obj = R/'foo'\n>>> r_obj / 'bar'\n<rx.RegexOperation at 0x7f77c00837d0>\n\n\n最后的对象，RegexOperation 实现了一些魔法方法，允许我们检索匹配，执行替换，以及测试匹配是否存在。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "5"}