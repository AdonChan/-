{"title": "简简单单说个闭包 - 个人文章 ", "index": "golang,php,python", "content": "闭包的作用\n一句话，闭包的作用：将方法存于变量。\n至于闭包的原因或者目的，或者说，为什么将方法存于变量，稍后再说。\n闭包的条件\n为了尽量避免用一大段话描述一个概念，我们理性一点地把闭包的条件划分成3个：\n\n外函数中定义了一个内函数\n内函数用了外函数的变量\n外函数返回了内函数的引用，or，外函数中直接调用了内函数\n\nP.S.\n\n其中外函数和内函数是指嵌套函数中外部函数和内部函数\n也正是因为需要嵌套函数，因此不支持的嵌套函数的语言也自然不支持此类闭包\n条件3中分成了两类，更多的情况下是前一类，而后一类（外函数直接调用了内函数）的使用更多的是为了保证代码的简洁，而如此地保持简洁并不一定用闭包。\n\n闭包的例子\n“Talk is cheap, show me your code.”\n我始终觉得，在编程中，过多的人类语言会产生太多的歧义，甚至还可能会因为所说事物过于抽象而导致听众无法将概念理解。\n而解决这个问题最好的方法就是看代码，编程语言相较于人类语言的优点之一是大幅地降低了语言的歧义。同时，通过多个代码实例，人脑会自然而然地将多实例中的共同点提取出来，进而理解抽象的概念。\n结合闭包的三个条件，我们来看看闭包的例子：\ndef outer(b):\n    def inner(a):  # 条件1\n        print(a + b)  # 条件2\n    return inner  # 条件3\n    \n# 调用\no = outer(1)\no(2)\nPython的代码还是挺简单的。\n\n一般情况下，在函数结束后，函数中变量等就应该被销毁，偏偏这个闭包就是个特例 —— o和o2中的1和20都保留着。\no和o2看起来就有那么一丝熟悉的感觉，它们两个就像是两个对象 —— 这两个“对象”都是从同一个“类”出来的，而两个“对象实例”的区别是有一个加数不一样，分别是1和20（当然，这两个变量的引用地址也不同）。\n现在，我们把代码例子中的第三个条件变一下，即将“外函数返回了内函数的引用”变成“外函数中直接调用了内函数”：\ndef outer(a, b):\n    def inner(a):  # 条件1\n        print(a + b)  # 条件2\n    inner(b)  # 条件3\n    \n# 调用\no = outer(100，1)\n\n此时，整个闭包函数调用起来就和一个普通函数一样，传入两个参数，该print的也如期而至。\n只能说，在outer函数内的逻辑过于复杂的时候，inner能把复杂的代码“模块化”，再调用，能增加简洁性。这种情况下，一般是inner函数只被调用一次，而且只在这里调用，放在这里也好管理一些。\n接下来，我们也鉴赏一下别的语言类似的闭包：\nfunc outer(i int) func() int {\n    return func() int {  // 条件1（匿名）+ 条件3\n        i++  // 条件2\n        return i\n    }\n}\n\n// 调用\no := outer(1)\no()\n这个Golang的例子闭包和Python的例子较大的距别是这里还把内函数换成了匿名的，看起来会爽点。而以下的php的就和Python的差不多了。\nfunction outer($str1) {\n    $outerStr = $str1;\n    $inner = function($str2) {  // 条件1\n        echo $str2 . $outerStr;  // 条件2\n    };\n    return $inner;  // 条件3\n}\n\n// 调用\n$o = outer(\"hahaha\");\n$o(\"emmm\");\n闭包的原因\n看过了上面的例子后，新手对闭包的概念也应该有了一定的理解，甚至有点想法了。\n回到最开始的问题，即闭包的原因。\n如果说，“将方法存于变量”是闭包的目的，那么接下来的问题显而易见：为什么要将方法存于变量？直接调用方法（函数）不好吗？\n闭包保存了函数的状态信息\n再举开头的例子：\ndef outer(b):\n    def inner(a):\n        print(a + b)\n    return inner\n    \no = outer(1)\no(2)  # 3\no(100)  # 101\no2 = outer(20)\no2(100)  # 120\no这个变量对应的闭包保存了b=1这个信息，之后无论是调用o(2)还是o(100)，b=1这个信息依然会存在并和后来的参数一起参与运算。同理，o2这个变量对应的闭包保存了b=20这个信息。\n由于退出了函数后，函数并没有并销毁，这个闭包的信息也没销毁，因此后续可以利用这些信息。\n语法糖\n为了代码的简洁性和易理解性，我们经常会使用甚至创造一些语法糖。\n而在Python中，有一个十分好看的例子就是装饰器，举个已经被用烂了的例子，面向切面的登录实现：\n# 先实现一个类似于装饰器的函数\ndef decorator(func): \n    def inner():\n        print 'before function'\n        func()  # function\n        print 'after function'\n    return inner\n\n# 实现一个假装在登录的登录函数\ndef login():  \n    print 'login function complete.'\n\n# 将登录函数“套上”装饰器\nlogin = decorator(login)  \nlogin()   \n整个过程下来与AOP类似，而场景也很常用，如统计函数的运行时常、加入日志、统一的过滤处理等等。\n更有甚者，在特定的场景下使用闭包创造语法糖，以简化代码，参考这个例子，该例子可以替代switch（不过这里这么简单的加减运算这样写就很智障了，要有一定的复杂度就能显得有优越性）：\ndef operator(o):\n    def plus(x, y):\n        print(x + y)\n    def minus(x, y):\n        print(x - y)\n        \n    if o == '+':\n        return plus\n    if o == '-':\n        return minus\n\ndef f(x, o, y):\n    operator(o)(x, y)\n函数式编程\n鼎鼎大名的Lambda，这个可以参考下这个链接。\n总结\n闭包能将方法存于变量，且实现一些美妙的东西。\n它就像是调味剂，并非不可或缺，但是能锦上添花。\n先这样吧\n若有错误之处请指出，更多地关注煎鱼。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "1"}