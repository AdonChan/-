{"title": "《Python基础教程》第二章--读书笔记 - michael翔的IT私房菜 ", "index": "读书笔记,python", "content": "第二章：列表和元祖\npython的列表和元祖一直在用，也不是第一次接触，所以，捡自己认为重点的记一下好了。\n在python中，最基本的数据结构就是序列（包括元祖和列表等）。序列的每个元素被分配一个序号——即元素的位置，也成为索引。第一个索引是0，一次类推。看起来很奇怪，但是，书中的补充让我理解了很多。\n这就意味着我们可以从第一个元素向前或者向后技术了。0是第一个。-1是最后一个\n元祖除了不能更改之外，其他的性质和列表都和列表类似。使用元祖的理由通常是技术性的。\n序列概览\npython包括6种内建的序列：\n\n列表\n元祖\n字符串\nUnicode字符串\nbuffer对象\nxrange对象\n\n通用序列操作\n所有序列类型都可以进行某些特定的操作。这些操作包括：\n\n索引(indexing)\n分片(slicing)\n加(adding)\n乘(multiplying)等等\n\n分片\n分片通过冒号隔开的两个索引来实现。第一个索引是要提取的第1个元素的编号，而最后的索引是分片之后剩余部分的第1个元素的编号。简而言之，用数学角度来说，就是前闭后开的范围[x:y)。\n>>>number=[1,2,3,4,5,6,7,8,9,10]\n通过置空，可以有很多效果。如：\n>>>number[:]\n[1,2,3,4,5,6,7,8,9,10]\n复制了整个列表。\n步长\n>>>number[::4]\n[1,5,9]\n>>>number[8:3:-1]\n[9,8,7,6,5]\n步长可以是负数，此时分片从右到左提取元素。\n当没有明确指定开始点和结束点时，正负数的使用可能会有一些混淆，python会进行正确的操作：\n\n对于正数步长，python会从序列头部向右操作提取元素\n负数步长，从序列尾部向左提取元素\n\n序列相加\n简单讲，只有相同类型的序列才能进行连接操作。\n乘法\n数字x乘以一个序列会生成新的序列。在新的序列中，原来的序列将被重复x次\n成员资格\n使用运算符in检查，返回相应的值：条件为真，返回True;条件为假，返回False。这样的运算符叫做布尔运算符。\n长度、最小值和最大值\n内建函数len,min,max非常有用。min函数和max函数返回序列中最大和最小的元素。\n>>>min(9,3,2)\n2\n这里有些奇怪，max函数和min函数的参数并不是一个序列，而是以多个数字直接作为参数。\n列表：python的“苦力”\n列表是可以改变的——可以改变列表的内容，并且，列表有很多有用的、专门的方法。\n\nlist函数\n因为字符串不能像列表一样被修改，所有有时候根据字符串创建列表会很有用。list函数可以实现这个操作\n>>>list('hello')\n['h','e','l','l','o']\n注：可以用join函数将一个字符组成的列表转换为字符串。\n基本列表操作\n删除元素-del语句\n>>>name=['michael','alice']\n>>>del names[1]\n>>>name\n['michael']\ndel语句除了删除列表中的元素，还能用于删除其他元素。\n分片赋值\n分片是一个非常强大的特性，分片赋值操作则更加显现它的强大。程序可以一次为多个元素赋值，不止是登场赋值，同时，可以使用与原序列不等长的序列将分片替换。\n>>>name = list('Perl')\n>>>name[1:]=list('ython')\n>>>name\n['p','y','t','h','o','n']\n分片赋值语句可以在不需要替换任何原有的元素的情况下插入新的元素。这个程序是指“替换”了一个空的分片，因此实际的操作就是插入了一个序列。\n>>>numbers = [1,3,5]\n>>>numbers[1,1] = list[2,3,4]\n>>>numbers\n[1,2,3,4,3,5]\n\n因为索引相同时，就是空元素\n>>>n[1:1]\n[]\n以此类推，通过分片赋值来删除元素也是可以的。\n>>>numbers = [1,2,3,4,5]\n>>>numbers[1:4]=[]\n>>>numbers\n[1,5]\n列表方法\n方法是一个与函数密切相关的概念，但是，方法是一个与对象有紧密联系的函数。对象可能是列表，数字，也可能是字符串或者其他类型的对象。一般说来，方法可以这样调用：对象.方法（参数）\nappend\nappend方法用于在列表末尾追加新的对象注：append方法和其他一些方法类似，只是在恰当的位置修改原来的列表。这就意味着，它不是简单地返回一个修改过的新列表——而是直接修改原来的列表。\ncount方法\ncount方法统计某个元素在列表中出现的次数。\n>>>x=[[1,2],1,1,[2,1,[1,2]]]\n>>>x.count(1)\n2\n>>>x.count([1,2])\n1\nextend方法\nextend方法可以再列表的末尾一次性追究另一个序列中的多个值。\n>>>a=[1,2,3]\n>>>b=[4,5,6]\n>>>a.extend(b)\n>>>a\n\n[1,2,3,4,5,6]\n注：这个操作看起来显示连接操作（+），但是两者主要区别是：extend方法修改了被扩展的序列（在这个例子中就是a)。而原始的连接操作则不然，他会返回一个全新的列表。\n>>>a=a+b\n这样的操作就比extend方法效率低\nindex方法\nindex方法用于从列表中找出某个值第一个匹配项的索引位置。\ninsert方法\ninsert方法用于将对象插入列表中：\n>>>num=[1,2,3,5,6,7]\n>>>num.insert(3,'four')\n>>>num\n[1,2,3,'four',4,5,6,7]\n可见，这里方法中的数字3，就是索引3。\npop\npop方法会溢出列表中的一个元素（默认是最后一个），并且返回该元素的值。\n>>>x=[1,2,3]\n>>>x.pop(0)\n1\n>>>x\n[2,3]\n注：pop方法是唯一一个既能修改列表，又返回元素值得列表方法。使用pop方法可以实现一种常见的数据结构--栈\nremove\nremove方法用于移除列表中某个值的第一个匹配项：是第一个匹配项，后面的元素不会被删除！同时，他也不会像pop方法一样，remove方法是没有返回值的。\nreverse\nreverse方法将列表中的元素方向存放。\nsort方法\nsort方法用于在原位置对列表进行排序。在“原位置排序“意味着改变原来的列表，从而让其中的元素能按一定的顺序排列，而不是简单地返回一个已排序的列表副本!注：这里sort方法是没有返回值得！没有返回值得！没有返回值得！方法当中，刚刚已经说了，只有pop方法是有返回值的！这里看个栗子说明一下：\n>>>x=[4,3,1,2,5]\n>>>x.sort()\n>>>x\n[1,2,3,4,5]\n如果想要排序，但是不想改变原列表：\n>>>x=[4,3,1,2,5]\n>>>y=x.sort() #大错特错！！！\n>>>print y\nNone\n正确的做法是把x的副本赋值给y，然后对y进行排序。\n>>>x=[4,3,1,2,5]\n>>>y=x[:] #这里千万别用y=x的方式，因为，这样写，y和x都指向同一个列表了，那么y.sort()时，x也会和y同时改变的\n>>>y.sort()\n另外获取已排序的列表副本的方法是，使用sorted()函数：\n>>>x=[4,3,1,2,5]\n>>>y=sorted(x)\n>>>x\n[4,3,1,2,5]\n>>>y\n[1,2,3,4,5]\n高级排序\ncmpart(x,y) 当x>y，返回正数，当x<y，返回负数，当x=y，返回0（根据你的定义）。\n>>>x=[4,3,1,2,5]\n>>>x.sort(cmp)\n>>>x\nsort方法还有另外两个可选的参数——key和reverse。\n>>>x=['abcd','a','ab']\n>>>x.sort(reverse=True)\n>>>x\n['abcd','ab','a']\n注：这里为何不用x.sort().reverse()?是因为，x.sort()返回的是None！！！\n元祖：不可变序列\n元素和列表一样，都是序列。但是，唯一不同的是，元祖不可变（和字符串一样）。创建元祖的语法很简单，用()括号。这里提到了一个之前不知道的技巧，如果用逗号分隔一些值，那么就自动创建了元祖。\n>>>1,2,3\n(1,2,3)\n实现空元祖：\n>>>()\n()\n实现一个值的元祖：\n>>>32,\n(32,)\n元祖没有像列表一样的方法。一个逗号能彻底的该表表达式的值：\n>>>3*(40+2)\n126\n>>>3*(40+2,)\n(42,42,42)\ntuple函数\ntuple函数的功能和list函数基本一样：以一个序列作为参数并把它转换为元祖。补充：tuple并不是真正的函数——而是一种类型。在之前简书list函数的时候，作者也提到了这一点\n>>>tuple([1,2,3])\n(1,2,3)\n>>>tuple('abc')\n('a','b','c')\n元祖基本操作\n元祖操作并不复杂——创建元祖和访问元祖元素之外，也没太多的操作。\n那么，元祖的意义何在\n由于以下两个重要的原因，元祖是不可替代的：\n\n元祖可以在映射（和集合的成员）中当作键使用——而列表不行！\n元祖作为很多内建函数和方法的返回值存在，也就是说你必须对元祖进行处理。只要不尝试修改元祖，读取元素没问题（除非使用一些元祖没有的方法，例如：index和count)\n\n本章小结\n\n明确了字符串也是属于元祖的类型的，不可更改\n知道了元祖存在的必要性，元祖可以在映射中当做键来使用，而列表不行。\n元祖创建，可以很简单的通过逗号分隔建立，例如>>>1,2,3\nin操作符得到的结果是布尔值：True或者False。\n方法，对象.方法。而函数，就是函数。f()。一个对象拥有的函数，成为方法。自己就这样理解吧。\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "2"}