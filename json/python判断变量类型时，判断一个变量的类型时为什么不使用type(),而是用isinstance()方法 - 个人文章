{"title": "python判断变量类型时，判断一个变量的类型时为什么不使用type(),而是用isinstance()方法 - 个人文章 ", "index": "python3.x,python3.5,python2.x,python2.7,python", "content": "注意：本文代码测试均在python2.75环境\npython判断变量数据类型目前有两种方法：\n第一种方法使用type()方法：\nIn [22]: type(111)==int\nOut[22]: False\n\nIn [25]: import types\n\nIn [26]: type(111)==types.IntType\nOut[26]: True\n\n第二种方法使用isinstance()方法：\nIn [27]: isinstance(111,int)\nOut[27]: True\n\n不使用type()代码示例：\n代码示例:\nclass A(object): \n    pass\n  \nclass B(A): \n    pass\n  \nprint type(A()) == A         # True\nprint type(B()) == A         # False\nprint isinstance(A(),A)      # True\nprint isinstance(B(),A)      # True\n\n特殊代码示例：\nfrom collections import Iterator\nclass A(object):\n    def __iter__(self):\n     pass\n    def next(self):\n     pass\n\nisinstance(A(), Iterator)        # True\ntype(A()) == Iterator            # False\n\n一个明显的区别是在判断子类。这个主要是由于python新式类和旧式类区别造成，相关链接:http://www.python.org/doc/new...\ntype()不会认为子类是一种父类类型。\nisinstance()会认为子类是一种父类类型\n正常情况下不应该编写代码检查类型的，而应该直接假设被操作的instance具有你希望的属性，否则抛出异常。即使需要检查类型，也应该用isinstance来判断，这样你期望类型的subclass也能正常被处理（比如，一个函数需要处理Message类型，那么它应该也能处理Message的子类型MyMessage，所以应该使用isinstance(arg,Message)这样来判断而不是type(arg) == Message来判断）。\n参考Duck Typing http://en.wikipedia.org/wiki/...\n代码示例额2：\nimport typesclass UserInt(int):\n    def __init__(self, val=0):\n        self.val = int(val)\n\ni = 1n = UserInt(2)\nprint(type(i) is type(n))    # False\n\n这就说明i和n的类型是不一样的，而实际上UserInt是继承自int的，所以这个判断是存在问题的，当我们对Python内建类型进行扩展的时候，type返回的结果就不够准确了。这就说明i和n的类型是不一样的，而实际上UserInt是继承自int的，所以这个判断是存在问题的，当我们对Python内建类型进行扩展的时候，type返回的结果就不够准确了。\n代码示例3：\nclass A():\n    pass\n    \nclass B():\n    pass\n    \na = A()\nb = B()\n\nprint(type(a) is type(b))    # True\n\ntype比较的结果a和b的类型是一样的，结果明显是不准确的。这种古典类的实例，type返回的结果都是一样的，而这样的结果不是我们想要的。对于内建的基本类型来说，使用tpye来检查是没有问题的，可是当应用到其他场合的时候，type就显得不可靠了。\n结论:\n尽量不要使用type()方法，多使用isinstance()，这样可以减少错误。\n参考：\nhttp://www.chenxm.cc/post/429...\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "1"}