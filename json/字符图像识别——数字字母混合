{"title": "字符图像识别——数字字母混合 ", "index": "验证码,图像识别,pillow,python", "content": "需要识别的验证码图像，其中包含 4 个字符（数字字母）\n\n验证码图片来源：http://my.cnki.net/elibregist...\n思路\n\n灰度化：将图像转为灰度图像，即一个像素只有一种色阶（有 256 种不同灰度），值为 0 表示像素最黑，值为 255 表示像素最白。\n二值化：将图像转为黑白图像，即一个像素只有黑白两种状态，不是黑就是白，没有灰色，值为 0 表示像素最黑，值为 1 表示像素最白.\n图像转字符串：利用工具将图像中的字符串识别出来\n\n前面两步都是对图像进行识别前处理，目的是提高计算机识别的准确度，毕竟计算机本身不能理解图像，一个像素值的微小变化都有可能导致错误识别\n代码\nimport tesserocr\nfrom PIL import Image\n\nimage = Image.open(\"87FW.jpg\")\n# 灰度化\nimage = image.convert(\"L\")\n# 二值化，传入的是数字 1，默认阈值是 127。一般不推荐使用，因为不够灵活\n# image = image.convert(\"1\")\n\n# 另一种二值化。自定义灰度，将灰度值在 115 以上的设置 1（白色），其它设为 0（黑色），相当于将阈值设置成了 115\ntable = [1] * 256\nfor i in range(256):\n    table[i] = 0\n    if i > 115:\n        break\n\nimage = image.point(table, \"1\")\n\nprint(tesserocr.image_to_text(image))\n打印：\n87FW\n所谓的阈（yu）值是指将不同的像素值分开的那个临界值\n上面的代码没有保存图片，为了直观得看到经过不同的处理后图像的区别，下面展示的是两张图像分别是灰度处理和二值化（阈值 115）后的图像\n\n\n下面将每种不同阈值的图像保存至本地，主要代码如下：\n...\nimage = Image.open(\"87FW.jpg\")\nimage = image.convert(\"L\")\ntable = [1] * 256\nfor i in range(256):\n    table[i] = 0\n    image.point(table, \"1\").save(f\"87FW_{i}.jpg\")\n阈值为 0 代表将所有像素处理成白色（没有黑色）；阈值为 255 代表将所有像素处理成黑色。\n\n可以发现阈值设置得越低，白色越多，能看得到的验证码（黑色）就少了，因为大部分灰度都处理成白色；反之，若阈值设置越大，黑色越多，更多的干扰像素处理成和验证码一样的黑色。\n以下是将上面不同阈值的图片制作成的一个 gif 动态图像，可以看到如果阈值设定在 0 至 255 这个过程中，验证码会呈现出不同效果\n\n阈值是一个很难把控的关键，阈值设置大或小都会影响识别的准确性，以下是遍历所有阈值，测试阈值在哪个区间可以识别出正确的验证码。注：由于没有做优化，整个过程会比较慢\n>>> for i in range(256):\n...     if tesserocr.image_to_text(Image.open(f\"87FW_{i}.jpg\")).strip()==\"87FW\":\n...             print(i, end=\" \")\n...\n109 110 112 113 114 115 116 117 118 119 120 122 123 124 169 170 171 172 173\n在 256 个阈值中只有 19 个（不足 7.42%）阈值可以正确识别出验证码，仔细察觉可以发现阈值区间被分成了多个，分别是 109～110、112～120、122～124、169～173，说明阈值区间不一定具有连续性。更糟糕的是，不同的验证码图片，能准确识别出其中验证码的阈值的数量、区间范围、区间数等都很可能不同。当然还有很多问题，比如选择一个“不恰当”的阈值导致图像处理过度，只识别出其中 3 个字符，不要试图随机添加一个字母或数字，因为需要考虑具体是哪个位置的字符没识别出来，这样瞎猜几乎是很难一次就命中的，好点的做法是：当识别出来的字符不足时可以尝试换一个阈值处理图像，所以能识别出验证码是概率事件。毕竟在正常的人机识别中，识别一个验证码通常只有一次机会，识别错了就会出现新的验证码，没有换阈值再重新试一次的机会，不过好在通常阈值的范围都是可以缩小的，比如可以忽略小于 70 和大于 200 的这些图像处理过度的阈值（正常人都很难识别是什么数字、字母），这样能命中的概率就会大大提高。\nimage.convert(\"1\") 的默认阈值是 127，在上面 19 个可以准确识别验证码的阈值中没有 127，这也就是为什么直接使用 image.convert(\"1\") 方法二值化的图像无法被准确识别出其中的验证码\n上面的验证码还算容易处理的，如果干扰像素的灰度值与验证码灰度差别比较大，可用上面的方法；但如果遇到干扰线条的灰度与验证码差不多、验证码重叠等情况，上面对图像仅做简单处理的方法就很难奏效了。这时就需要用到机器学习技术对识别器进行训练，听说识别率几乎 100%！\n参考资料：\n《Python3网络爬虫开发实战》——8.1 图形验证码的识别\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "1"}