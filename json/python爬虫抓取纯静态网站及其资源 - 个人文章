{"title": "python爬虫抓取纯静态网站及其资源 - 个人文章 ", "index": "python", "content": "遇到的需求\n前段时间需要快速做个静态展示页面，要求是响应式和较美观。由于时间较短，自己动手写的话也有点麻烦，所以就打算上网找现成的。\n中途找到了几个页面发现不错，然后就开始思考怎么把页面给下载下来。\n由于之前还没有了解过爬虫，自然也就没有想到可以用爬虫来抓取网页内容。所以我采取的办法是：\n\n打开chrome的控制台，进入Application选项\n找到Frames选项，找到html文件，再右键Save As...\n\n手动创建本地的js/css/images目录\n依次打开Frames选项下的Images/Scripts/Stylesheets，一个文件就要右键Save As...\n\n\n这个办法是我当时能想到的最好办法了。不过这种人为的办法有以下缺点：\n\n手工操作，麻烦费时\n一不小心就忘记保存哪个文件\n难以处理路径之间的关系，比如一张图片a.jpg, 它在html中的引用方式是images/banner/a.jpg，这样我们以后还要手动去解决路径依赖关系\n\n然后刚好前段时间接触了一点python，想到可以写个python爬虫来帮我自动抓取静态网站。于是就马上动手，参考相关资料等等。\n下面跟大家详细分享一下写爬虫抓取静态网站的全过程。\n前置知识储备\n在下面的代码实践中，用到了python知识、正则表达式等等，核心技术是正则表达式。\n我们来一一了解一下。\nPython基础知识\n如果你之前有过其他语言的学习经历，相信你可以很快上手python这门语言。具体学习可以上查看python官方文档或者其他教程。\n爬虫的概念\n爬虫，按照我的理解，其实是一段自动执行的计算机程序，在web领域中，它存在的前提是模拟用户在浏览器中的行为。\n它的原理就是模拟用户访问web网页，获取网页内容，然后分析网页内容，找出我们感兴趣的部分，并且最后处理数据。\n流程图是：\n\n现在流行的爬虫主流实现形式有以下几种：\n\n自己抓取网页内容，然后自己实现分析过程\n用别人写好的爬虫框架，比如Scrapy\n\n\n正则表达式\n概念\n正则表达式是由一系列元字符和普通字符组成的字符串，它的作用是根据一定的规则来匹配文本，最终可以对文本做出一系列的处理。\n元字符是正则表达式中的保留字符，它有特殊的匹配规则，比如*代表匹配0到无穷多次，普通字符就是普通的abcd等等。\n比如在前端中，常见的一个操作就是判断用户的输入是否为空，这时候我们可以先通过正则表达式来进行匹配，先过滤掉用户输入的两边空白值，具体实现如下：\nfunction trim(value) {\n    return value.replace(/^\\s+|\\s+$/g, '')\n}\n\n// 输出 => \"Python爬虫\"\ntrim(' Python爬虫 ');\n下面我们一起来具体了解一下正则表达式中的元字符。\n正则表达式中的元字符\n在上面，我们说过元字符是正则表达式中的保留字符，它有特殊的匹配规则，所以我们首先要了解经常出现的元字符。\n匹配单个字符的元字符\n\n\n.代表匹配一个任意字符，除了\\n(换行符)，比如可以匹配任意的字母数字等等\n\n[...]表示字符组，里面可以有任意字符，它只会匹配当中的任意一个，比如[abc]可以匹配a或b或c，这里值得注意的是，字符组里面的元字符有时候会被当成是普通字符，比如[-*?]等等，它代表的仅仅是-或*或?，而不是-代表区间，*代表0到无穷次匹配，?代表0或1次匹配。\n\n[^...]跟[...]的含义相反，它的意思是匹配一个不属于[...]里面的字符，而不是不匹配[...]里面的字符，这两种说法虽然细微但是有很大差别，前者规定一定要匹配一个字符，这个切记。\n\n例子：[^123]可以匹配4/5/6等等，但是不匹配1/2/3\n提供计数功能的元字符\n\n\n*代表匹配0次到无穷次，可以不匹配任何字符\n\n+代表匹配1次到无穷次，至少匹配1次\n\n?代表匹配0次或1次\n\n\n{min, max}代表匹配min次到max次，如a{3, 5}表示a至少匹配3-5次\n\n提供位置的元字符\n\n\n^代表匹配字符串开头，如^a表示a要出现在字符串开头，bcd则不匹配\n\n$代表匹配字符串结尾, 如A$表示A要出现在字符串结尾，ABAB则不匹配\n\n其他元字符\n\n\n|代表一个范围，可以匹配任意的子表达式，比如abc|def可以匹配abc或者def，不匹配abd\n\n(...)代表分组，它的作用有界定子表达式的范围和与提供功能的元字符相结合，比如(abc|def)+代表可以匹配1次或1次以上的abc或者defdef，如abcabcabc，def\n\n\\i代表反向引用，i可以为1/2/3等整数，它的含义是指向上一个()里面匹配的内容。比如匹配(abc)+(12)*\\1\\2，如果匹配成功的话，\\1的内容是abc，\\2的内容是12或者空。反向引用通常用在匹配\"\"或者''中\n\n环视\n我理解的环视是界定当前匹配子表达式的左边文本和右边文本出现的情况，环视本身不会占据匹配的字符，它是当前子表达式的匹配规则但是本身不算进匹配文本。而我们上面说的元字符都代表一定的规则和占据一定的字符。环视可分为四种：肯定顺序环视、否定顺序环视、肯定逆序环视和否定逆序环视。它们的工作流程如下：\n\n\n肯定顺序环视：先找到环视中的文本在右侧出现的初始位置，然后从匹配到的右侧文本的最左的位置开始匹配字符\n\n否定顺序环视：先找到环视中的文本在右侧没有出现的初始位置，然后从匹配到的右侧文本的最左的位置开始匹配字符\n\n肯定逆序环视：先找到环视中的文本在左侧出现的初始位置，然后从匹配到的左侧文本的最右的位置开始匹配字符\n\n否定逆序环视：先找到环视中的文本在左侧没有出现的初始位置，然后从匹配到的左侧文本的最右的位置开始匹配字符\n\n肯定顺序环视\n肯定顺序环视匹配成功的条件是当前的子表达式能够匹配右侧文本，它的写法是(?=...),...代表要环视的内容。比如正则表达式(?=hello)he的意思是匹配包含hello的文本，它只匹配位置，不匹配具体字符，匹配到位置之后，才真正匹配要占用的字符是he，所以后面可以具体匹配llo等。\n对于(?=hello)he而言，hello world可以匹配成功，而hell world则匹配失败。具体代码如下：\nimport re\n\nreg1 = r'(?=hello)he'\n\nprint(re.search(reg1, 'hello world'))\nprint(re.search(reg1, 'hell world hello'))\nprint(re.search(reg1, 'hell world'))\n\n# 输出结果\n<_sre.SRE_Match object; span=(0, 2), match='he'>\n<_sre.SRE_Match object; span=(11, 13), match='he'>\nNone\n否定顺序环视\n否定顺序环视匹配成功的条件是当前的子表达式不能匹配右侧文本，它的写法是(?!...),...代表要环视的内容，还是上面的例子，比如正则表达式(?!hello)he的意思是匹配不是hello的文本，找到位置，然后匹配he。\n例子如下：\nimport re\n\nreg2 = r'(?!hello)he'\n\nprint(re.search(reg2, 'hello world'))\nprint(re.search(reg2, 'hell world hello'))\nprint(re.search(reg2, 'hell world'))\n\n# 输出结果\nNone\n<_sre.SRE_Match object; span=(0, 2), match='he'>\n<_sre.SRE_Match object; span=(0, 2), match='he'>\n肯定逆序环视\n肯定逆序环视匹配成功的条件是当前的子表达式能够匹配左侧文本，它的写法是(?<=...),...代表要环视的内容，比如正则表达式(?<=hello)-python的意思是匹配包含-python的子表达式，并且它的左侧必须出现hello，hello只匹配位置，不匹配具体字符，真正占用的字符是后面的-python。\n例子如下：\nimport re\n\nreg3 = r'(?<=hello)-python'\nprint(re.search(reg3, 'hello-python'))\nprint(re.search(reg3, 'hell-python hello-python'))\nprint(re.search(reg3, 'hell-python'))\n\n# 输出结果\n<_sre.SRE_Match object; span=(5, 12), match='-python'>\n<_sre.SRE_Match object; span=(17, 24), match='-python'>\nNone\n否定逆序环视\n否定逆序环视匹配成功的条件是当前的子表达式不能匹配左侧文本，它的写法是(?<!...),...代表要环视的内容，比如正则表达式(?<!hello)-python的意思是匹配包含-python的子表达式，并且它的左侧必须不能出现hello。\n例子如下：\nimport re\n\nreg4 = r'(?<!hello)-python'\nprint(re.search(reg4, 'hello-python'))\nprint(re.search(reg4, 'hell-python hello-python'))\nprint(re.search(reg4, 'hell-python'))\n\n# 输出结果\nNone\n<_sre.SRE_Match object; span=(4, 11), match='-python'>\n<_sre.SRE_Match object; span=(4, 11), match='-python'>\n环视在对字符串插入某些字符很有效，你可以利用它来匹配位置，然后插入对应的字符，而不需要对原来的文本进行替换。\n捕获分组\n在正则表达式中，分组可以帮助我们提取出想要的特定信息。\n指明分组很简单，只需要在想捕获的表达式中两端加上()就可以了。在python中，我们可以用re.search(reg, xx).groups()来获取到所有的分组。默认的()中都指明了一个分组，分组序号为i，i从1开始，分别用re.search(reg, xx).group(i)来获取。\n如果不想捕获分组可以使用(?:...)来指明。\n具体例子如下：\nimport re\n\nreg7 = r'hello,([a-zA-Z0-9]+)'\nprint(re.search(reg7, 'hello,world').groups())\nprint(re.search(reg7, 'hello,world').group(1))\nprint(re.search(reg7, 'hello,python').groups())\nprint(re.search(reg7, 'hello,python').group(1))\n\n# 输出结果\n('world',)\nworld\n('python',)\npython\n贪婪匹配\n贪婪匹配是指正则表达式尽可能匹配多的字符，也就是趋于最大长度匹配。\n正则表达式默认是贪婪模式。\n例子如下：\nimport re\n\nreg5 = r'hello.*world'\nprint(re.search(reg5, 'hello world,hello python,hello world,hello javascript'))\n\n# 输出结果\n<_sre.SRE_Match object; span=(0, 36), match='hello world,hello python,hello world'>\n由上可以看到它匹配的是hello world,hello python,hello world而不是刚开始的hello world。那如果我们只是想匹配刚开始的hello world，这时候我们可以利用正则表达式的非贪婪模式。\n非贪婪匹配正好与贪婪匹配相反，它是指尽可能匹配少的字符，只要匹配到了就结束。要使用贪婪模式，仅需要在量词后面加上一个问号(?)就可以。\n还是刚刚那个例子：\nimport re\n\nreg5 = r'hello.*world'\nreg6 = r'hello.*?world'\nprint(re.search(reg5, 'hello world,hello python,hello world,hello javascript'))\nprint(re.search(reg6, 'hello world,hello python,hello world,hello javascript'))\n\n# 输出结果\n<_sre.SRE_Match object; span=(0, 36), match='hello world,hello python,hello world'>\n<_sre.SRE_Match object; span=(0, 11), match='hello world'>\n由上可以看到这是我们刚刚想要匹配的效果。\n进入开发\n有了上面的基础知识，我们就可以进入开发环节了。\n我们想实现的最终效果\n本次我们的最终目的是写一个简单的python爬虫，这个爬虫能够下载一个静态网页，并且在保持网页引用资源的相对路径下下载它的静态资源（如js/css/images）。测试网站为http://www.peersafe.cn/index.html，效果图如下：\n\n开发流程\n我们的总体思路是先获取到网页的内容，然后利用正则表达式来提取我们想要的资源链接，最后就是下载资源。\n获取网页内容\n我们选用python3自带的urllib.http来发出http请求，或者你可以采用第三方请求库requests。\n获取内容的部分代码如下：\nurl = 'http://www.peersafe.cn/index.html'\n\n# 读取网页内容\nwebPage = urllib.request.urlopen(url)\ndata = webPage.read()\ncontent = data.decode('UTF-8')\nprint('> 网站内容抓取完毕，内容长度：', len(content))\n获取到内容之后，我们需要把它保存下来，也就是写到本地磁盘上。我们定义一个SAVE_PATH路径，代表专门放置爬虫下载的文件。\n# python-spider-downloads是我们要放置的目录\n# 这里推荐使用os模块来获取当前的目录或者拼接路径\n# 不推荐直接使用'F://xxx' + '//python-spider-downloads'等方式\n\nSAVE_PATH = os.path.join(os.path.abspath('.'), 'python-spider-downloads')\n接下来就是为这个站点创建一个单独的文件夹了。这个站点文件夹的格式是xxxx-xx-xx-domain，比如2018-08-03-www.peersafe.cn。在此之前，我们需要写一个函数来提取出一个url链接的域名、相对路径、请求文件名和请求参数等等，这个在后续在根据资源文件的引用方式创建相对应的文件夹时也会用到。\n比如输入http://www.peersafe.cn/index.html，那么将会输出:\n{'baseUrl': 'http://www.peersafe.cn', 'fullPath': 'http://www.peersafe.cn/', 'protocol': 'http://', 'domain\n': 'www.peersafe.cn', 'path': '/', 'fileName': 'index.html', 'ext': 'html', 'params': ''}\n部分代码如下：\nREG_URL = r'^(https?://|//)?((?:[a-zA-Z0-9-_]+\\.)+(?:[a-zA-Z0-9-_:]+))((?:/[-_.a-zA-Z0-9]*?)*)((?<=/)[-a-zA-Z0-9]+(?:\\.([a-zA-Z0-9]+))+)?((?:\\?[a-zA-Z0-9%&=]*)*)$'\n\nregUrl = re.compile(REG_URL)\n\n# ...\n\n'''\n解析URL地址\n'''\ndef parseUrl(url):\n    if not url:\n        return\n\n    res = regUrl.search(url)\n    # 在这里，我们把192.168.1.109:8080的形式也解析成域名domain，实际过程中www.baidu.com等才是域名，192.168.1.109只是IP地址\n    # ('http://', '192.168.1.109:8080', '/abc/images/111/', 'index.html', 'html', '?a=1&b=2')\n    if res is not None:\n        path = res.group(3)\n        fullPath = res.group(1) + res.group(2) + res.group(3)\n\n        if not path.endswith('/'):\n            path = path + '/'\n            fullPath = fullPath + '/'\n        return dict(\n            baseUrl=res.group(1) + res.group(2),\n            fullPath=fullPath,\n            protocol=res.group(1),\n            domain=res.group(2),\n            path=path,\n            fileName=res.group(4),\n            ext=res.group(5),\n            params=res.group(6)\n        )\n\n'''\n解析路径\n\neg:\n    basePath => F:\\Programs\\python\\python-spider-downloads\n    resourcePath => /a/b/c/ or a/b/c\n\n    return => F:\\Programs\\python\\python-spider-downloads\\a\\b\\c\n'''\ndef resolvePath(basePath, resourcePath):\n    # 解析资源路径\n    res = resourcePath.split('/')\n    # 去掉空目录 /a/b/c/ => [a, b, c]\n    dirList = list(filter(lambda x: x, res))\n\n    # 目录不为空\n    if dirList:\n        # 拼接出绝对路径\n        resourcePath = reduce(lambda x, y: os.path.join(x, y), dirList)\n        dirStr = os.path.join(basePath, resourcePath)\n    else:\n        dirStr = basePath\n\n    return dirStr\n上面的正则表达式REG_URL有点长，这个正则表达式能解析目前我遇到的各种url形式，如果有不能解析的，你可以自行补充，我测试过的url列表可以去我的github中查看。\n首先一个最复杂的url链接（比如'http://192.168.1.109:8080/abc/images/111/index.html?a=1&b=2'）来说，我们想分别提取出http://, 192.168.1.109:8080, /abc/images/111/, index.html, ?a=1&b=2。提取出/abc/images/111/的目的是为以后创建目录做准备，index.html是写入网页内容的名字。\n有需要的可以深入研究一下REG_URL的写法，如果有更好的或者看不懂的，我们可以一起探讨。\n有了parseUrl函数之后，我们就可以把刚刚获取网页内容和写入文件联系起来了，代码如下：\n# 首先创建这个站点的文件夹\nurlDict = parseUrl(url)\nprint('分析的域名：', urlDict)\ndomain = urlDict['domain']\n\nfilePath = time.strftime('%Y-%m-%d', time.localtime()) + '-' + domain\n# 如果是192.168.1.1:8000等形式，变成192.168.1.1-8000，:不可以出现在文件名中\nfilePath = re.sub(r':', '-', filePath)\nSAVE_PATH = os.path.join(SAVE_PATH, filePath)\n\n# 读取网页内容\nwebPage = urllib.request.urlopen(url)\ndata = webPage.read()\ncontent = data.decode('UTF-8')\nprint('> 网站内容抓取完毕，内容长度：', len(content))\n\n# 把网站的内容写下来\npageName = ''\nif urlDict['fileName'] is None:\n    pageName = 'index.html'\nelse:\n    pageName = urlDict['fileName']\n\npageIndexDir = resolvePath(SAVE_PATH, urlDict['path'])\nif not os.path.exists(pageIndexDir):\n    os.makedirs(pageIndexDir)\n\npageIndexPath = os.path.join(pageIndexDir, pageName)\nprint('主页的地址:', pageIndexPath)\nf = open(pageIndexPath, 'wb')\nf.write(data)\nf.close()\n提取有用的资源链接\n我们想要的资源是图片资源，js文件、css文件和字体文件。如果我们要对网页内容一一进行解析，利用分组，来捕获出我们想要的链接形式，比如images/1.png和scripts/lib/jquery.min.js。\n代码如下：\nREG_RESOURCE_TYPE = r'(?:href|src|data\\-original|data\\-src)=[\"\\'](.+?\\.(?:js|css|jpg|jpeg|png|gif|svg|ico|ttf|woff2))[a-zA-Z0-9\\?\\=\\.]*[\"\\']'\n\n# re.S代表开启多行匹配模式\nregResouce = re.compile(REG_RESOURCE_TYPE, re.S)\n\n# ...\n\n# 解析网页内容，获取有效的链接\n# content是上一步读取到的网页内容\ncontentList = re.split(r'\\s+', content)\nresourceList = []\nfor line in contentList:\n    resList = regResouce.findall(line)\n    if resList is not None:\n        resourceList = resourceList + resList\n下载资源\n在解析出资源链接后，我们要针对每一个资源链接进行检查，把它变成符合http请求的url格式，比如把images/1.png加上http头和刚刚的domain，也就是http://domain/images/1.png。\n下面是对资源链接进行处理的代码：\n# ./static/js/index.js\n# /static/js/index.js\n# static/js/index.js\n# //abc.cc/static/js\n# http://www.baidu/com/static/index.js\nif resourceUrl.startswith('./'):\n    resourceUrl = urlDict['fullPath'] + resourceUrl[1:]\nelif resourceUrl.startswith('//'):\n    resourceUrl = 'https:' + resourceUrl\nelif resourceUrl.startswith('/'):\n    resourceUrl = urlDict['baseUrl'] + resourceUrl\nelif resourceUrl.startswith('http') or resourceUrl.startswith('https'):\n    # 不处理，这是我们想要的url格式\n    pass\nelif not (resourceUrl.startswith('http') or resourceUrl.startswith('https')):\n    # static/js/index.js这种情况\n    resourceUrl = urlDict['fullPath'] + resourceUrl\nelse:\n    print('> 未知resource url: %s' % resourceUrl)\n接着就是对每个规范的资源链接进行解析（parseUrl），提取出它要存放的目录和文件名等等，然后创建对应的目录。\n在这里，我也处理了引用的其他网站的资源。\n# 解析文件，查看文件路径\nresourceUrlDict = parseUrl(resourceUrl)\nif resourceUrlDict is None:\n    print('> 解析文件出错：%s' % resourceUrl)\n    continue\n\nresourceDomain = resourceUrlDict['domain']\nresourcePath = resourceUrlDict['path']\nresourceName = resourceUrlDict['fileName']\n\nif resourceDomain != domain:\n    print('> 该资源不是本网站的，也下载：', resourceDomain)\n    # 如果下载的话，根目录就要变了\n    # 再创建一个目录，用于保存其他地方的资源\n    resourceDomain =  re.sub(r':', '-', resourceDomain)\n    savePath = os.path.join(SAVE_PATH, resourceDomain)\n    if not os.path.exists(SAVE_PATH):\n        print('> 目标目录不存在，创建：', savePath)\n        os.makedirs(savePath)\n    # continue\nelse:\n    savePath = SAVE_PATH\n\n# 解析资源路径\ndirStr = resolvePath(savePath, resourcePath)\n\nif not os.path.exists(dirStr):\n    print('> 目标目录不存在，创建：', dirStr)\n    os.makedirs(dirStr)\n\n# 写入文件\ndownloadFile(resourceUrl, os.path.join(dirStr, resourceName))\n下载的函数downloadFile的代码是：\n'''\n下载文件\n'''\ndef downloadFile(srcPath, distPath):\n    global downloadedList\n\n    if distPath in downloadedList:\n        return\n    try:\n        response = urllib.request.urlopen(srcPath)\n        if response is None or response.status != 200:\n            return print('> 请求异常：', srcPath)\n        data = response.read()\n\n        f = open(distPath, 'wb')\n        f.write(data)\n        f.close()\n\n        downloadedList.append(distPath)\n        # print('>>>: ' + srcPath + '：下载成功')\n\n    except Exception as e:\n        print('报错了：', e)\n以上就是我们的开发全过程。\n知识总结\n本次开发用到的技术\n\n利用urllib.http来发网络请求\n利用正则表达式来解析资源链接\n利用os系统模块来处理文件路径问题\n\n心得体会\n这篇文章也算是我这段时间学习python的一个实践总结，顺便记录下正则表达式的知识。同时我也希望能够帮助到那些想学习正则表达式和爬虫的小伙伴。\n该python爬虫的源代码已经放在我的github上，有兴趣的小伙伴可以上去看看，满意的可以顺便给个Star，感谢支持。\n\n                ", "mainLikeNum": ["12 "], "mainBookmarkNum": "10"}