{"title": "基于 flask-socketio 的 CRUD 操作初探 - 藕丝空间 ", "index": "flask,python", "content": "Flask 作为一个全栈架构，如果你只会 python，而不懂 javascript 的前端知识，似乎是无法支撑起你的 web 梦想的，比如，一个简单的页面 局部刷新 功能，你就需要用到 ajax 的知识，当然，你还可以使用 HTML5 的新特性 —— websocket功能，好在 flask 还提供了一个 flask-socketio 插件，本文我们就探讨一下这个 flask-scoketio插件的用法。\n理解 websocket 协议\n\n\nHTTP 协议只能通过客户端发起请求来与客户端进行通讯 —— 这是一个缺陷。\n通过websocket 协议，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。\n\nwebsocket 协议特性\n\n建立在 TCP 协议之上，服务器端的实现比较容易。\n与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。\n数据格式比较轻量，性能开销小，通信高效。\n可以发送文本，也可以发送二进制数据。\n没有同源限制，客户端可以与任意服务器通信。\n协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。\n\n使用 flask-socketio\n安装插件\npip install flask-socketio\n项目结构\n本文是在 《基于 flask 的 CRUD 操作》 的基础上增加了 webscoket 的功能，使用的是 init_app() 的形式加载 flask-socketio 插件，和网上的大多数教程稍有不同。\nflask-wtf-crud/\n|-- env/\n    |-- <python虚拟环境>\n|-- app/ <项目的模块名称>\n    |-- crud/ <前端蓝图>\n        |-- __init__.py\n        |-- views.py <路由和视图函数文件>\n        |-- forms.py <表单类文件, wtforms插件必须项>\n        |-- templates <HTML模板>\n            |-- static <静态文件夹>\n                |-- js <JavaScript 文件夹>\n                    |-- crud.js # 异步请求的程序主要在此添加\n    |-- XXXXXX/ <其它蓝图>\n    |-- __init__.py\n    |-- models.py <数据库模型文件>\n|-- migrations/ <数据库表关系文件夹,Flask-Migrate迁移数据库时使用>\n|-- config.py <项目的配置文件>\n|-- manage.py <用于启动程序以及其它程序任务>\n将 flask-socketio 引入项目\n修改 manage.py 内容\n# -*- coding:utf-8 -*-\n__author__ = '东方鹗'\n__blog__ = u'http://www.os373.cn'\n\nimport os\nfrom app import create_app, db, socketio\nfrom app.models import User\nfrom flask_script import Manager, Shell\nfrom flask_migrate import Migrate, MigrateCommand\n\n\napp = create_app(os.getenv('FLASK_CONFIG') or 'default')\nmanager = Manager(app=app)\nmigrate = Migrate(app=app, db=db)\n\ndef make_shell_context():\n    return dict(app=app, db=db, User=User)\n\n\nmanager.add_command(\"shell\", Shell(make_context=make_shell_context))\nmanager.add_command('db', MigrateCommand)\nmanager.add_command('run', socketio.run(app=app, host='0.0.0.0', port=5001)) # 新加入的内容\n\n\nif __name__ == '__main__':\n    manager.run()\n\n　修改 app/__init__.py 内容\n# -*- coding:utf-8 -*-\n__author__ = '东方鹗'\n__blog__ = u'http://www.os373.cn'\n\nfrom flask import Flask\nfrom flask_sqlalchemy import SQLAlchemy\nfrom config import config\nfrom flask_socketio import SocketIO # 新加入的内容\ndb = SQLAlchemy()\n\nasync_mode = None\nsocketio = SocketIO()\n\n\ndef create_app(config_name):\n    \"\"\" 使用工厂函数初始化程序实例\"\"\"\n    app = Flask(__name__)\n    app.config.from_object(config[config_name])\n    config[config_name].init_app(app=app)\n\n    db.init_app(app=app)\n\n    socketio.init_app(app=app, async_mode=async_mode) # 新加入的内容\n\n    # 注册蓝本crud\n    from .crud import crud as crud_blueprint\n    app.register_blueprint(crud_blueprint, url_prefix='/crud')\n\n    return app\n当前蓝图的 views.py\n# -*- coding:utf-8 -*-\n__author__ = '东方鹗'\n__blog__ = u'http://www.os373.cn'\n\nfrom flask import render_template, redirect, request, current_app, url_for, flash, json\nfrom . import crud\nfrom ..models import User\nfrom .forms import AddUserForm, DeleteUserForm, EditUserForm\nfrom ..import db\nfrom threading import Lock\nfrom app import socketio # 新加入的内容\nfrom flask_socketio import emit # 新加入的内容\n\n# 新加入的内容-开始\nthread = None\nthread_lock = Lock()\n\ndef background_thread(users_to_json):\n    \"\"\"Example of how to send server generated events to clients.\"\"\"\n    while True:\n        socketio.sleep(5) \\\\ 每五秒发送一次\n\n        socketio.emit('user_response', {'data': users_to_json}, namespace='/websocket/user_refresh')\n# 新加入的内容-结束\n\n@crud.route('/', methods=['GET', 'POST'])\ndef index():\n\n    return render_template('index.html')\n\n\n@crud.route('/websocket', methods=['GET', 'POST'])\ndef websocket():\n    add_user_form = AddUserForm(prefix='add_user')\n    delete_user_form = DeleteUserForm(prefix='delete_user')\n    if add_user_form.validate_on_submit():\n        if add_user_form.role.data == u'True':\n            role = True\n        else:\n            role = False\n        if add_user_form.status.data == u'True':\n            status = True\n        else:\n            status = False\n        u = User(username=add_user_form.username.data.strip(), email=add_user_form.email.data.strip(),\n                 role=role, status=status)\n        db.session.add(u)\n        flash({'success': u'添加用户<%s>成功！' % add_user_form.username.data.strip()})\n    if delete_user_form.validate_on_submit():\n        u = User.query.get_or_404(int(delete_user_form.user_id.data.strip()))\n        db.session.delete(u)\n        flash({'success': u'删除用户<%s>成功！' % u.username})\n\n    users = User.query.all()\n\n    return render_template('websocket.html', users=users, addUserForm=add_user_form, deleteUserForm=delete_user_form)\n\n\n@crud.route('/websocket-edit/<user_id>', methods=['GET', 'POST'])\ndef user_edit(user_id):\n    user = User.query.get_or_404(user_id)\n    edit_user_form = EditUserForm(prefix='edit_user', obj=user)\n    if edit_user_form.validate_on_submit():\n        user.username = edit_user_form.username.data.strip()\n        user.email = edit_user_form.email.data.strip()\n        if edit_user_form.role.data == u'True':\n            user.role = True\n        else:\n            user.role = False\n        if edit_user_form.status.data == u'True':\n            user.status = True\n        else:\n            user.status = False\n        flash({'success': u'用户资料已修改成功！'})\n        return redirect(url_for('.basic'))\n\n    return render_template('edit_websocket.html', editUserForm=edit_user_form, user=user)\n\n# 新加入的内容-开始\n@socketio.on('connect', namespace='/websocket/user_refresh')\ndef connect():\n    \"\"\" 服务端自动发送通信请求 \"\"\"\n    global thread\n    with thread_lock:\n        users = User.query.all()\n        users_to_json = [user.to_json() for user in users]\n\n        if thread is None:\n            thread = socketio.start_background_task(background_thread, (users_to_json, ))\n    emit('server_response', {'data': '试图连接客户端！'})\n\n\n@socketio.on('connect_event', namespace='/websocket/user_refresh')\ndef refresh_message(message):\n    \"\"\" 服务端接受客户端发送的通信请求 \"\"\"\n\n    emit('server_response', {'data': message['data']})\n# 新加入的内容-结束\n---------- 以上内容是后端的内容，以下内容是将是前段的内容 ----------\ncrud.js 内容\n$(document).ready(function () {\n    namespace='/websocket/user_refresh';\n    var socket = io.connect(location.protocol + '//' + document.domain + ':' + location.port + namespace);\n    $(\"#url_show\").text(\"websocket URL: \" + location.protocol + '//' + document.domain + ':' + location.port + namespace);\n\n    socket.on('connect', function() { // 发送到服务器的通信内容\n        socket.emit('connect_event', {data: '我已连接上服务端！'});\n    });\n\n    socket.on('server_response', function(msg) {\n        \\\\ 显示接受到的通信内容，包括服务器端直接发送的内容和反馈给客户端的内容\n        $('#log').append('<br>' + $('<div/>').text('接收 : ' + msg.data).html());\n    });\n    socket.on('user_response', function(msg) {\n        //console.log(eval(msg.data[0]));\n        //$('#users_show').append('<br>' + $('<div/>').text('接收 : ' + msg.data).html());\n        var tbody = \"\";\n        var obj = eval(msg.data[0]);\n        $.each(obj, function (n, value) {\n            var role = \"\";\n            if (value.role===true){\n                role = \"管理员\";\n            }else {\n                role = \"一般用户\";\n            }\n            var status = \"\";\n            if (value.status===true){\n                status = \"正常\";\n            }else {\n                status = \"注销\";\n            }\n            edit_url = \"<a href=\" +  location.protocol + '//' + document.domain + ':' + location.port + \"/crud/websocket-edit/\" + value.id + \"> 修改</a>\";\n            delete_url = \"<a href=\\\"javascript:delete_user_\" + value.id + \"()\\\">删除</a>\";\n            var trs = \"\";\n            trs += \"<tr><th>\" + (n+1) + \"</th><td>\" + value.username + \"</td><td>\" + value.email + \"</td><td>\" + role + \"</td><td>\" + status + \"</td><td>\" + edit_url + \" | \" + delete_url +\"</td></tr>\";\n            tbody += trs;\n        })\n        $('#users_show').empty();\n        $('#users_show').append(tbody);\n    });\n});\n显示结果\n\n每次打开网页，会显示服务端发送的内容——“试图连接客户端！”，其后，客户端返回给服务端——“我已连接上服务端！”，而后又被服务端返回给客户端显示。\n以下的表格内容显示数据局里的内容，每 5 秒局部刷新一次表格内容。\n服务器后端 log 日志内容如下：\n\n总结\n\n由于 flask 架构具有上下文的限制，在数据库里 增加删改 内容的时候，表格的内容没有变化——尽管局部已经进行了刷新。要想显示变化后的数据库内容，必须得重新启动一下 flask 服务。\n就整体的部署来说，在 flask 项目里添加 websocket 协议，显得项目较重，实现一个局部刷新的功能还是用 ajax 比较简单。\n欢迎大侠能够给我的项目提出修改意见，先行感谢！！！\n\n源码下载\n参考\n\n基于 flask 的 CRUD 操作\nWebSocket 教程 —— 阮一峰\n\n\n                ", "mainLikeNum": ["6 "], "mainBookmarkNum": "10"}