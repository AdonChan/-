{"title": "编写符合Python风格的对象 - 个人文章 ", "index": "python", "content": "导语：本文章记录了本人在学习Python基础之面向对象篇的重点知识及个人心得，打算入门Python的朋友们可以来一起学习并交流。\n本文重点：\n1、掌握编写Pythonic code背后常用的特殊方法；2、掌握可扩展的格式化输出方法；3、了解可散列对象的设置以及节省内存的__slots__对象。\n一、自定义具有Python风格的类\n自定义的向量类需要支持基本的输出，迭代，求模。\n1、自定义向量类型\n从自定义向量类型入手写出符合Python风格的对象，这离不开特殊方法的支持。我们期望的自定义向量类型应支持的基本功能：\n\n构造，__init__\n输出，__repr__和__str__\n迭代，__iter__\n求模，__abs__\n转化为字节序列，__bytes__\n\n代码实现如下：\nimport math\nfrom array import array\nclass Vector2d:\n    typecode='d'\n    def __init__(self,x,y):\n        self.x=float(x)\n        self.y=float(y)\n\n    def __str__(self):\n        return str(tuple(self))\n\n    def __iter__(self):\n        return (i for i in (self.x,self.y))\n\n    def __repr__(self):\n        classname=type(self).__name__\n        s=\"{}({},{})\".format(classname,*self)\n        return s\n\n    def __abs__(self):\n        return math.hypot(self.x,self.y)\n\n    def __bytes__(self):\n        return (bytes(self.typecode,encoding='utf-8')+\n                bytes(array(self.typecode,self)))\n2、使用一个类方法实现备选构造方法\n我们能将实例转化为字节序列，那么也应构造一个将实例转化为字节序列的方法。\n    @classmethod\n    def frombytes(cls,seqs):\n        typecode=chr(seqs[0])\n        memv=memoryview(seqs[1:]).cast(typecode)\n        return cls(*memv)\nmemoryview是泛化和去数学化的数组。\n3、classmethod和staticmethod两个装饰器\nclassmethod：定义操作类而不是操作实例的方法，类方法的第一个参数是类本身而不是实例。最常见的用途是定义备选构造方法（返回cls(*)）\nstaticmethod:是普通的函数，只是碰巧在类的定义体中，而不是在模块层定义。\n二、格式化显示\n1、扩展内置的format函数\n通过改写format背后的__format__可以写出可扩展的格式。实例1：实现format对向量类的处理\n     def __format__(self,fmt_spec=''):\n        components=(format(v,fmt_spec)for v in self)\n        return \"({},{})\".format(*components)\n实例2：通过尾部自定义格式代码p实现将直角坐标向量转化为极坐标向量。\n    def __format__(self,fmt_spec=''):\n        if fmt_spec[-1]==\"p\":\n            coord=(abs(self),self.angle())\n            spec=fmt_spec[:-1]\n            components=(format(v,spec)for v in coord)\n            outer=\"<{},{}>\"\n        else:\n            coord=self\n            components = (format(v, fmt_spec) for v in self)\n            outer = \"({},{})\"\n        return outer.format(*components)\n本段代码的重点在于判断格式中是否存在自定义格式符p，并进行对应的格式处理。\n三、将对象变为可散列的\n目前的向量是不可散列的，而可散列对象需要满足：\n(1)支持hash()函数，并且通过hash()得到的散列值是不变的；\n(2)支持通过__eq__()方法来检测相等性；\n(3)若a==b为真，则hash(a)=hash(b)也为真。\n所以我们需要把对象定为不可变，然后自定义__hash__。\n1、将对象定为不可变的\n通过使用两个前导下划线。将属性标记为私有的。\n    @property\n    def x(self):\n        return self.__x\n    @property\n    def y(self):\n        return self.__y\n2、自定义__hash__()\n使用异或运算符实现。\n    def __hash__(self):\n        return hash(self.x)^hash(self.y)\n四、其它\n1、只读属性的设置\n\n私有属性的设置只是避免修改方法意外访问不应更改的值，而无法防止有意的改动。\n通过__dict__属性可以查询Python如何存储向量的属性名，然后只要编写a._Vector2d__x=5这样的代码就会恶意赋值。\n\nPython程序员约定使用一个下划线前缀编写“受保护”的属性即self._x，他们认为应该使用命名约定来避免意外覆盖属性。\n\n2、利用__slots__节省内存\n默认情况下，Python在各个实例中名为__dict__的字典中储存实例属性，相应地会消耗大量内存。通过__slots__类属性，并让解释器把实例属性存储在元组中，可以节省大量内存。\nclass Vector2d:\n    __slots__ = ('__x','__y')\n    typecode='d'\n#其他方法实现省略\n使用__slots__应注意的问题：\n\n__slots__无法从超类继承而来，每个子类都需要定义__slots__属性；\n实例只能拥有__slots__中列出的属性，除非把'__dict__'加入到__slots__中（这样做就失去了节省内存的初衷）\n如果不把'weakref__'加入__slots__，实例就不能作为弱引用的目标。\n\n当处理的实例规模较小时，禁止创建动态属性或不支持弱引用是比较好的选择。\n3、覆盖类属性\n通过创建子类可以把继承自父类的实例属性覆盖掉。\nclass Shortvector2d(Vector2d):\n    typecode = 'f'\n#其它方法实现省略\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}