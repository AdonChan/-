{"title": "[零基础学python]不要红头文件(2) - 易水禾 ", "index": "零基础,python", "content": "在前面学习了基本的打开和建立文件之后，就可以对文件进行多种多样的操作了。请看官要注意，文件，不是什么特别的东西，就是一个对象，如同对待此前学习过的字符串、列表等一样。\n\n文件的属性\n\n所谓属性，就是能够通过一个文件对象得到的东西。\n\n>>> f = open(\"131.txt\",\"a\")\n>>> f.name\n'131.txt'\n>>> f.mode      #显示当前文件打开的模式\n'a'\n>>> f.closed    #文件是否关闭，如果关闭，返回True；如果打开，返回False\nFalse\n>>> f.close()   #关闭文件的内置函数\n>>> f.closed\nTrue\n\n\n文件的有关状态\n\n很多时候，我们需要获取一个文件的有关状态（有时候成为属性，但是这里的文件属性和上面的文件属性是不一样的，可是，我觉得称之为文件状态更好一点），比如创建日期，访问日期，修改日期，大小，等等。在os模块中，有这样一个方法，能够解决此问题：\n\n>>> import os\n>>> file_stat = os.stat(\"131.txt\")      #查看这个文件的状态\n>>> file_stat                           #文件状态是这样的。从下面的内容，有不少从英文单词中可以猜测出来。\nposix.stat_result(st_mode=33204, st_ino=5772566L, st_dev=2049L, st_nlink=1, st_uid=1000, st_gid=1000, st_size=69L, st_atime=1407897031, st_mtime=1407734600, st_ctime=1407734600)\n\n>>> file_stat.st_ctime                  #这个是文件创建时间\n1407734600.0882277                      #换一种方式查看这个时间\n>>> import time                         \n>>> time.localtime(file_stat.st_ctime)  #这回看清楚了。\ntime.struct_time(tm_year=2014, tm_mon=8, tm_mday=11, tm_hour=13, tm_min=23, tm_sec=20, tm_wday=0, tm_yday=223, tm_isdst=0)\n\n\n以上关于文件状态和文件属性的内容，在对文件的某些方面进行判断和操作的时候或许会用到。特别是文件属性。比如在操作文件的时候，我们经常要首先判断这个文件是否已经关闭或者打开，就需要用到file.closed这个属性来判断了。\n\n文件的内置函数\n\n>>> dir(file)\n['__class__', '__delattr__', '__doc__', '__enter__', '__exit__', '__format__', '__getattribute__', '__hash__', '__init__', '__iter__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'close', 'closed', 'encoding', 'errors', 'fileno', 'flush', 'isatty', 'mode', 'name', 'newlines', 'next', 'read', 'readinto', 'readline', 'readlines', 'seek', 'softspace', 'tell', 'truncate', 'write', 'writelines', 'xreadlines']\n>>> \n\n\n这么多内置函数，不会都讲述，只能捡着重点的来实验了。\n\n>>> f = open(\"131.txt\",\"r\")\n>>> f.read()\n'My name is qiwsir.\\nMy website is qiwsir.github.io\\nAha,I like program\\n'\n>>> \n\n\nfile.read()能够将文件中的内容全部读取过来。特别注意，这是返回一个字符串，而且是将文件中的内容全部读到内存中。试想，如果内容太多是不是就有点惨了呢？的确是，千万不要去读大个的文件。\n\n>>> contant = f.read()\n>>> type(contant)\n<type 'str'>\n\n\n如果文件比较大了，就不要一次都读过来，可以转而一行一行地，用readline\n\n>>> f = open(\"131.txt\",\"r\")\n>>> f.readline()        #每次返回一行，然后指针向下移动\n'My name is qiwsir.\\n'\n>>> f.readline()        #再读，再返回一行\n'My website is qiwsir.github.io\\n'\n>>> f.readline()\n'Aha,I like program\\n'\n>>> f.readline()        #已经到最后一行了，再读，不报错，返回空\n''\n\n\n这个方法，看官是不是觉得太慢了呢？有没有痛快点的呢？有，请挥刀自宫，不用自宫，也能用readlines。注意区别，这个是复数，言外之意就是多行啦。\n\n>>> f = open(\"131.txt\",\"r\")\n>>> cont = f.readlines()\n>>> cont\n['My name is qiwsir.\\n', 'My website is qiwsir.github.io\\n', 'Aha,I like program\\n']\n>>> type(cont)\n<type 'list'>\n>>> for line in cont:\n...     print line\n... \nMy name is qiwsir.\n\nMy website is qiwsir.github.io\n\nAha,I like program\n\n\n从实验中我们可以看到，readlines和read有一样之处，都是将文件内容一次性读出来，存放在内存，但是两者也有区别，read返回的是str类型，readlines返回的是list，而且一行一个元素，因此，就可以通过for逐行打印出来了。\n\n在print line中，注意观察list里面的每个元素，最后都是一个\\n结尾，所以打印的结果会有空行。其原因前面已经介绍过了，忘了的朋友请回滚到上一讲\n\n不过，还是要提醒列位，太大的文件不用都读到内存中。对付大点的文件，还是推荐这么做：\n\n>>> f = open(\"131.txt\",\"r\")\n>>> f\n<open file '131.txt', mode 'r' at 0xb757c230>\n>>> type(f)\n<type 'file'>\n>>> for line in f:\n...     print line\n... \nMy name is qiwsir.\n\nMy website is qiwsir.github.io\n\nAha,I like program\n\n\n以上都是读文件的内置函数和方法。除了读，就是要写。所谓写，就是将内容存入到文件中。用到的内置函数是write。但是，要写入文件，还要注意打开文件的模式，可以是w，也可以是a，看具体情况而定。\n\n>>> f = open(\"131.txt\",\"a\")     #因为这个文件已经存在，我又不想清空，用追加的模式\n>>> f.write(\"There is a baby.\") #这句话应该放到文件最后\n>>> f.close()                   #请看官注意，写了之后，一定要及时关闭文件。才能代表真正写入\n\n\n看看写的效果：\n\n>>> f = open(\"131.txt\",\"r\")\n>>> for line in f.readlines():\n...     print line\n... \nMy name is qiwsir.\n\nMy website is qiwsir.github.io\n\nAha,I like program\n\nThere is a baby.        #果然增加了这一行\n\n\n以上是关于文件的基本操作。其实对文件远远不知这些，有兴趣的看官可以google一下pickle这个模块，是一个很好用的东西。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}