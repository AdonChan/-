{"title": "WebSocket 通信过程与实现 - Geek情怀 ", "index": "python,websocket,网络编程", "content": "什么是 WebSocket ？\nWebSocket 是一种标准协议，用于在客户端和服务端之间进行双向数据传输。但它跟 HTTP 没什么关系，它是基于 TCP 的一种独立实现。\n以前客户端想知道服务端的处理进度，要不停地使用 Ajax 进行轮询，让浏览器隔个几秒就向服务器发一次请求，这对服务器压力较大。另外一种轮询就是采用 long poll 的方式，这就跟打电话差不多，没收到消息就一直不挂电话，也就是说，客户端发起连接后，如果没消息，就一直不返回 Response 给客户端，连接阶段一直是阻塞的。\n而 WebSocket 解决了 HTTP 的这几个难题。当服务器完成协议升级后（ HTTP -> WebSocket ），服务端可以主动推送信息给客户端，解决了轮询造成的同步延迟问题。由于 WebSocket 只需要一次 HTTP 握手，服务端就能一直与客户端保持通信，直到关闭连接，这样就解决了服务器需要反复解析 HTTP 协议，减少了资源的开销。\n\n随着新标准的推进，WebSocket 已经比较成熟了，并且各个主流浏览器对 WebSocket 的支持情况比较好（不兼容低版本 IE，IE 10 以下），有空可以看看。\n\n使用 WebSocket 的时候，前端使用是比较规范的，js 支持 ws 协议，感觉类似于一个轻度封装的 Socket 协议，只是以前需要自己维护 Socket 的连接，现在能够以比较标准的方法来进行。\n\n下面我们就结合上图具体来聊一下 WebSocket 的通信过程。\n建立连接\n客户端请求报文 Header\n客户端请求报文：\nGET / HTTP/1.1\nUpgrade: websocket\nConnection: Upgrade\nHost: example.com\nOrigin: http://example.com\nSec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ==\nSec-WebSocket-Version: 13\n与传统 HTTP 报文不同的地方：\nUpgrade: websocket\nConnection: Upgrade\n这两行表示发起的是 WebSocket 协议。\nSec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ==\nSec-WebSocket-Version: 13\nSec-WebSocket-Key 是由浏览器随机生成的，提供基本的防护，防止恶意或者无意的连接。\nSec-WebSocket-Version 表示 WebSocket 的版本，最初 WebSocket 协议太多，不同厂商都有自己的协议版本，不过现在已经定下来了。如果服务端不支持该版本，需要返回一个 Sec-WebSocket-Versionheader，里面包含服务端支持的版本号。\n创建 WebSocket 对象：\nvar ws = new websocket(\"ws://127.0.0.1:8001\");\nws 表示使用 WebSocket 协议，后面接地址及端口\n完整的客户端代码：\n<script type=\"text/javascript\">\n    var ws;\n    var box = document.getElementById('box');\n\n    function startWS() {\n        ws = new WebSocket('ws://127.0.0.1:8001');\n        ws.onopen = function (msg) {\n            console.log('WebSocket opened!');\n        };\n        ws.onmessage = function (message) {\n            console.log('receive message: ' + message.data);\n            box.insertAdjacentHTML('beforeend', '<p>' + message.data + '</p>');\n        };\n        ws.onerror = function (error) {\n            console.log('Error: ' + error.name + error.number);\n        };\n        ws.onclose = function () {\n            console.log('WebSocket closed!');\n        };\n    }\n\n    function sendMessage() {\n        console.log('Sending a message...');\n        var text = document.getElementById('text');\n        ws.send(text.value);\n    }\n\n    window.onbeforeunload = function () {\n        ws.onclose = function () {};  // 首先关闭 WebSocket\n        ws.close()\n    };\n</script>\n服务端响应报文 Header\n首先我们来看看服务端的响应报文：\nHTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=\nSec-WebSocket-Protocol: chat\n我们一行行来解释\n\n首先，101 状态码表示服务器已经理解了客户端的请求，并将通过 Upgrade 消息头通知客户端采用不同的协议来完成这个请求；\n然后，Sec-WebSocket-Accept 这个则是经过服务器确认，并且加密过后的 Sec-WebSocket-Key；\n最后，Sec-WebSocket-Protocol 则是表示最终使用的协议。\n\nSec-WebSocket-Accept 的计算方法：\n\n将 Sec-WebSocket-Key 跟 258EAFA5-E914-47DA-95CA-C5AB0DC85B11 拼接；\n通过 SHA1 计算出摘要，并转成 base64 字符串。\n\n注意：Sec-WebSocket-Key/Sec-WebSocket-Accept 的换算，只能带来基本的保障，但连接是否安全、数据是否安全、客户端 / 服务端是否合法的 ws 客户端、ws 服务端，其实并没有实际性的保证。\n创建主线程，用于实现接受 WebSocket 建立请求：\ndef create_socket():\n    # 启动 Socket 并监听连接\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    try:\n        sock.bind(('127.0.0.1', 8001))\n\n        # 操作系统会在服务器 Socket 被关闭或服务器进程终止后马上释放该服务器的端口，否则操作系统会保留几分钟该端口。\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        sock.listen(5)\n    except Exception as e:\n        logging.error(e)\n        return\n    else:\n        logging.info('Server running...')\n\n    # 等待访问\n    while True:\n        conn, addr = sock.accept()  # 此时会进入 waiting 状态\n\n        data = str(conn.recv(1024))\n        logging.debug(data)\n\n        header_dict = {}\n        header, _ = data.split(r'\\r\\n\\r\\n', 1)\n        for line in header.split(r'\\r\\n')[1:]:\n            key, val = line.split(': ', 1)\n            header_dict[key] = val\n\n        if 'Sec-WebSocket-Key' not in header_dict:\n            logging.error('This socket is not websocket, client close.')\n            conn.close()\n            return\n\n        magic_key = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'\n        sec_key = header_dict['Sec-WebSocket-Key'] + magic_key\n        key = base64.b64encode(hashlib.sha1(bytes(sec_key, encoding='utf-8')).digest())\n        key_str = str(key)[2:30]\n        logging.debug(key_str)\n\n        response = 'HTTP/1.1 101 Switching Protocols\\r\\n' \\\n                   'Connection: Upgrade\\r\\n' \\\n                   'Upgrade: websocket\\r\\n' \\\n                   'Sec-WebSocket-Accept: {0}\\r\\n' \\\n                   'WebSocket-Protocol: chat\\r\\n\\r\\n'.format(key_str)\n        conn.send(bytes(response, encoding='utf-8'))\n\n        logging.debug('Send the handshake data')\n\n        WebSocketThread(conn).start()\n进行通信\n服务端解析 WebSocket 报文\nServer 端接收到 Client 发来的报文需要进行解析\nClient 包格式\n\n\n\nFIN: 占 1bit\n0：不是消息的最后一个分片1：是消息的最后一个分片\n\n\nRSV1, RSV2, RSV3：各占 1bit\n一般情况下全为 0。当客户端、服务端协商采用 WebSocket 扩展时，这三个标志位可以非0，且值的含义由扩展进行定义。如果出现非零的值，且并没有采用 WebSocket 扩展，连接出错。\n\n\nOpcode: 4bit\n%x0：表示一个延续帧。当 Opcode 为 0 时，表示本次数据传输采用了数据分片，当前收到的数据帧为其中一个数据分片；%x1：表示这是一个文本帧（text frame）；%x2：表示这是一个二进制帧（binary frame）；%x3-7：保留的操作代码，用于后续定义的非控制帧；%x8：表示连接断开；%x9：表示这是一个心跳请求（ping）；%xA：表示这是一个心跳响应（pong）；%xB-F：保留的操作代码，用于后续定义的控制帧。\n\n\nMask: 1bit\n表示是否要对数据载荷进行掩码异或操作。0：否1：是\n\n\nPayload length: 7bit or (7 + 16)bit or (7 + 64)bit\n表示数据载荷的长度0~126：数据的长度等于该值；126：后续 2 个字节代表一个 16 位的无符号整数，该无符号整数的值为数据的长度；127：后续 8 个字节代表一个 64 位的无符号整数（最高位为 0），该无符号整数的值为数据的长度。\n\n\nMasking-key: 0 or 4bytes\n当 Mask 为 1，则携带了 4 字节的 Masking-key；当 Mask 为 0，则没有 Masking-key。掩码算法：按位做循环异或运算，先对该位的索引取模来获得 Masking-key 中对应的值 x，然后对该位与 x 做异或，从而得到真实的 byte 数据。注意：掩码的作用并不是为了防止数据泄密，而是为了防止早期版本的协议中存在的代理缓存污染攻击（proxy cache poisoning attacks）等问题。\n\nPayload Data: 载荷数据\n\n解析 WebSocket 报文代码如下：\ndef read_msg(data):\n    logging.debug(data)\n\n    msg_len = data[1] & 127  # 数据载荷的长度\n    if msg_len == 126:\n        mask = data[4:8]  # Mask 掩码\n        content = data[8:]  # 消息内容\n    elif msg_len == 127:\n        mask = data[10:14]\n        content = data[14:]\n    else:\n        mask = data[2:6]\n        content = data[6:]\n\n    raw_str = ''  # 解码后的内容\n    for i, d in enumerate(content):\n        raw_str += chr(d ^ mask[i % 4])\n    return raw_str\n服务端发送 WebSocket 报文\n返回时不携带掩码，所以 Mask 位为 0，再按载荷数据的大小写入长度，最后写入载荷数据。\nstruct 模块解析\nstruct.pack(fmt, v1, v2, ...)\n按照给定的格式 fmt，把数据封装成字符串 ( 实际上是类似于 C 结构体的字节流 )\nstruct 中支持的格式如下表：\n\n\nFormat\nC Type\nPython type\nStandard size\n\n\n\nx\npad byte\nno value\n \n\n\nc\nchar\nbytes of length 1\n1\n\n\nb\nsigned char\ninteger\n1\n\n\nB\nunsigned char\ninteger\n1\n\n\n?\n_Bool\nbool\n1\n\n\nh\nshort\ninteger\n2\n\n\nH\nunsigned short\ninteger\n2\n\n\ni\nint\ninteger\n4\n\n\nI\nunsigned int\ninteger\n4\n\n\nl\nlong\ninteger\n4\n\n\nL\nunsigned long\ninteger\n4\n\n\nq\nlong long\ninteger\n8\n\n\nQ\nunsigned long long\ninteger\n8\n\n\nn\nssize_t\ninteger\n \n\n\nN\nsize_t\ninteger\n \n\n\ne\n-7\nfloat\n2\n\n\nf\nfloat\nfloat\n4\n\n\nd\ndouble\nfloat\n8\n\n\ns\nchar[]\nbytes\n \n\n\np\nchar[]\nbytes\n \n\n\nP\nvoid *\ninteger\n \n\n\n\n为了同 C 语言中的结构体交换数据，还要考虑有的 C 或 C++ 编译器使用了字节对齐，通常是以 4 个字节为单位的 32 位系统，故而 struct 根据本地机器字节顺序转换。可以用格式中的第一个字符来改变对齐方式，定义如下：\n\n\nCharacter\nByte order\nSize\nAlignment\n\n\n\n@\nnative\nnative\nnative\n\n\n=\nnative\nstandard\nnone\n\n\n<\nlittle-endian\nstandard\nnone\n\n\n>\nbig-endian\nstandard\nnone\n\n\n!\nnetwork (= big-endian)\nstandard\nnone\n\n\n\n发送 WebSocket 报文代码如下：\ndef write_msg(message):\n    data = struct.pack('B', 129)  # 写入第一个字节，10000001\n\n    # 写入包长度\n    msg_len = len(message)\n    if msg_len <= 125:\n        data += struct.pack('B', msg_len)\n    elif msg_len <= (2 ** 16 - 1):\n        data += struct.pack('!BH', 126, msg_len)\n    elif msg_len <= (2 ** 64 - 1):\n        data += struct.pack('!BQ', 127, msg_len)\n    else:\n        logging.error('Message is too long!')\n        return\n\n    data += bytes(message, encoding='utf-8')  # 写入消息内容\n    logging.debug(data)\n    return data\n总结\n没有其他能像 WebSocket 一样实现全双工传输的技术了，迄今为止，大部分开发者还是使用 Ajax 轮询来实现，但这是个不太优雅的解决办法，WebSocket 虽然用的人不多，可能是因为协议刚出来的时候有安全性的问题以及兼容的浏览器比较少，但现在都有解决。如果你有这些需求可以考虑使用 WebSocket：\n\n多个用户之间进行交互；\n需要频繁地向服务端请求更新数据。\n\n比如弹幕、消息订阅、多玩家游戏、协同编辑、股票基金实时报价、视频会议、在线教育等需要高实时的场景。\n参考文章\n\nhttps://www.zhihu.com/questio...http://fullstackpython.atjian...\nhttp://www.52im.net/thread-13...\n\n\n                ", "mainLikeNum": ["59 "], "mainBookmarkNum": "168"}