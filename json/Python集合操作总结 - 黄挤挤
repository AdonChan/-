{"title": "Python集合操作总结 - 黄挤挤 ", "index": "python", "content": "Google's Python Course\nList\nList变量是可变的（mutable）官方文档\n1. 操作\nsquares = [1, 4, 9, 16, 25]\nsquares[-1]   # 25\nsquares[-3:]  # returns a new list [9, 16, 25]\nsquares[1:3]  # returns a new list [4, 9]\nsquares[:]    # returns a new (shallow) copy [1, 4, 9, 16, 25]\nsquares + [36, 49, 64, 81, 100]  # concatenation, return a new list\nsquares[0] = 0     # replaces the value\nsquares[len(squares):] = [36]  # appends a '36'\nsquares[1:3] = []  # removes [4, 9]\nsquares[:] = []    # clears the list -> del squares[:]\nsquares *= 2       # 元素重复2次，[1, 4, 9, 16, 25, 1, 4, 9, 16, 25]\n判断list是否为空：不要用len(seq) 参看PEP8\nif not seq:\nif seq:\n2.方法\n操作在原数组上进行，不像concatenation一样返回新数组\nsum([1,2,3,4])  # 10\nmax([1,2,3,4])  # 4\nlist.append(x)  # equivalent to a[len(a):] = [x], x是元素\nlist.extend(iterable)  # equivalent to a[len(a):] = iterable, iterable是数组\nlist.remove(x)  # x是元素\nlist.pop([i])  # 默认删除最后一个元素, i表示index, []表示可选\nlist.clear()\nlist.index(x[, start[, end]])  # 返回元素x的index\nlist.count(x)  # 返回元素x个数\nlist.sort(key=None, reverse=False)\n'''\n\"key=\" specifying a \"key\" function that transforms each element before comparison. \nThe key function takes in 1 value and returns 1 value, \nand the returned \"proxy\" value is used for the comparisons within the sort.\n'''\nlist.sort(key=len)   # 先得到每个元素的len，然后根据len排序\nlist.reverse()\nlist.copy()  # Return a shallow copy of the list. Equivalent to a[:]\nYou might have noticed that methods like insert, remove or sort that only modify the list have no return value printed – they return the default None. This is a design principle for all mutable data structures in Python.\n3.数据结构\n# 队列\nfrom collections import deque\nqueue = deque([\"Eric\", \"John\", \"Michael\"])\nqueue.append(\"Terry\")           # Terry arrives\nqueue.popleft()                 # The first to arrive now leaves\n4.列表推导 List Comprehensions\n[x**2 for x in range(10)]\n\n[(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]\n# 注意for、if的顺序\ncombs = []\nfor x in [1,2,3]:\n    for y in [3,1,4]:\n        if x != y:\n            combs.append((x, y))\n>>>combs\n# flatten a list\nvec = [[1,2,3], [4,5,6], [7,8,9]]\n[num for elem in vec for num in elem]\nflatten = []\nfor elem in vec:\n    for num in elem:\n        flatten.append(num)\n>>>flatten\n# 矩阵倒置\n# 但是最好使用list(zip(*matrix))\nmatrix = [\n            [1, 2, 3, 4],\n            [5, 6, 7, 8],\n            [9, 10, 11, 12],\n         ]\n[[row[i] for row in matrix] for i in range(4)]\n\n# !!! 变量使用之前要像这样声明一遍\ntransposed = []\nfor i in range(4):\n    transposed.append([row[i] for row in matrix])\n>>> transposed\n\ntransposed = []\nfor i in range(4):\n    # the following 3 lines implement the nested listcomp\n    transposed_row = []\n        for row in matrix:\n            transposed_row.append(row[i])\n    transposed.append(transposed_row)\n>>> transposed\nString\nString变量是不可变的（immutable）\n'doesn\\'t'  # 等价 \"doesn't\"\nprint('C:\\some\\name')   # C:\\some            ame\nprint(r'C:\\some\\name')  # r表示raw, C:\\some\\name\n\n# print多行\nprint(\"\"\"\\\nUsage: thingy [OPTIONS]\n     -h                        Display this usage message\n     -H hostname               Hostname to connect to\n\"\"\")\n\n3 * 'un' + 'ium'  # 'unununium'\n'Py' 'thon'  # 'Python', 非常有用，用于分解多行\ntext = ('Put several strings within parentheses '\n        'to have them joined together.')\n# 以上方法，不能用于变量（或表达式） 与 字符串的连接。需要使用+\nString 与 bytes 区别：\\o12 八进制，\\x0a十六进制。但，像单独一个'a'，既可以是十六进制，也可以是八进制，无须转义一般情况，我们无须关注底层一个字符花费多少byte。只有在需要将string编码(encode)成byte的时候，比如：通过网络传输数据；或者需要将byte解码(decode)成string的时候，我们才会关注string和byte的区别。\na = '€20'.encode('utf-8')\nb = b'\\xe2\\x82\\xac20'.decode('utf-8')\n1.方法\ns = 'abc'\ns.center(10, '@')   # @@@abc@@@@\ns.count('a')        # 1\ns.encode('utf-8')   # b'abc'\ns.endswith('b')     # False\ns.startswith(('a','A'))   # 传入tuple，用于查询\n'1,2,3,4'.split(',', 2)   # ['1', '2', '3,4']\n'abc\\tabc'.expandtabs()      # len = 8 + 3,\\t补足八位\ns.find('b')         # retuen the lowest index. 注意：总是用'b' in s来判断是否是子串\ns.rfind('b')         # retuen the highest index.\n\"The jack is {1}\".format(1, 2, 3)\n\"The jack is {1}\".format(*[1, 2, 3])\n\"The jack is {jack}\".format(jack=4098, sape=4139)\n\"The jack is {jack}\".format(**{'jack': 4098, 'sape': 4139})\ns.index('d')   # 等同于find；raise ValueError\ns.join('de')        # return a new sttring 'abcde'\ns.ljust(5, '@')      # abc@@ 补充右侧\ns.rjust(5, '@')      # @@abc 补充左侧\ns.strip('ab')\ns.lstrip('123a')          # specifying the set of characters to be removed; If none para, removing whitespace\ns.rstrip('123c')          # 'ab'\ns.partition('b')          # return a tuple ('a', 'b', 'c'),第一个出现的b\ns.rpartition('b')         # return a tuple ('a', 'b', 'c'),最后一个出现的b\ns.replace('a','A')        # replace(old, new[, count]) 替代第count个old字符串替换为new，count从1开始\n'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines()  # ['ab c', '', 'de fg', 'kl']\n'www.example.com'.strip('cmowz.')     # The outermost leading and trailing chars argument values are stripped from the string\n2.format方法\nMostly used to combine Number with String, e.g. 'Key1'Format strings contain “replacement fields” surrounded by curly braces {}. If you need to include a brace character in the literal text, it can be escaped by doubling: {{ and }}.\nclass a:\n\n    def __init__(self):\n        self._x = 10\n        self._y = 45\n\na = a()\n'y is {0._y}, x is {0._x}'.format(a)   # y is 45, x is 10\nb = [45, 10]\n'y is {0[0]}, x is {0[1]}'.format(b)\n'y is {arg[0]}, x is {arg[1]}'.format(arg = b)\n'array is {0!r}'.format(b)    # array is [45, 10]\n# Three conversion flags : '!s' which calls str() on the value, \n#'!r' which calls repr() and '!a' which calls ascii().\n'int: {0:d};  hex: {0:#x};  oct: {0:#o};  bin: {0:#b}'.format(42)  \n# 只接受数字\n# 'int: 42;  hex: 0x2a;  oct: 0o52;  bin: 0b101010'\n\npoints = 19\ntotal = 22\n'Correct answers: {:.2%}'.format(points/total)  # 86.36%\n\nimport datetime\nd = datetime.datetime(2010, 7, 4, 12, 15, 58)\n'{:%Y-%m-%d %H:%M:%S}'.format(d)\n3.Template strings\nfrom string import Template\n\nt = Template('$who likes $whom')\n\nt.substitute(who='Jam', whom='Mo')  # Jam likes Mo\nd = dict(who='Jam', whom='Mo')\nt.substitute(d)\n\nt.safe_substitute(who='Jam')   # Jam likes $whom\nnumbers.Number\nThe numbers module (PEP 3141) defines a hierarchy of numeric abstract base classes.\nNumber :> Complex :> Real :> Rational :> Integral, where A :> B means \"A is a supertype of B\".\nPython supports arbitrarily large integers.\nBytes，Bytearray\nbyte对象是不可变的（immutable） bytes objects actually behave like immutable sequences of integers, with each value in the sequence restricted such that 0 <= x < 256\nSince 2 hexadecimal digits correspond precisely to a single byte, hexadecimal numbers are a commonly used format for describing binary data\nbytearray objects are a mutable counterpart to bytes objects\nb = b'€20'   # SyntaxError\nbytes.fromhex('30')   # b'0', fromhex()类方法class method\n\nbytes.fromhex('303132')  # b'012'，十六进制\nbytes([50,51,52])        # b'234',十进制。避免使用此法实例bytes，用b''\nTuple\nTuples are immutable\nt = (12345, 54321, 'hello!')\nt[0]  # 12345\nSet\nA set is an unordered collection with no duplicate elements\nbasket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}\n'orange' in basket\n\na = set('abracadabra')\nb = set('alacazam')\na-b   # letters in a but not in b\na|b   # letters in a or b or both\na&b   # letters in both a and b\na^b   # letters in a or b but not both\n\n{x for x in 'abracadabra' if x not in 'abc'}\nDictionary\ntel = {'jack': 4098, 'sape': 4139}\ntel.keys()\ntel.values()\ntel['guido'] = 4127\n'guido' in tel    # True\n'guido' in tel.keys() # 不建议，keys方法会创建返回key数组，降低效率\n\n{x: x**2 for x in (2, 4, 6)}\n\nd = dict(sape=4139, guido=4127, jack=4098)\nfor k, v in d.items():\n    print(k, v)\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}