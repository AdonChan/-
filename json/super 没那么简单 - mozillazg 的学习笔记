{"title": "super 没那么简单 - mozillazg 的学习笔记 ", "index": "python", "content": "说到 super， 大家可能觉得很简单呀，不就是用来调用父类方法的嘛。如果真的这么简单的话也就不会有这篇文章了，且听我细细道来。?\n约定\n在开始之前我们来约定一下本文所使用的 Python 版本。默认用的是 Python 3，也就是说：本文所定义的类都是新式类。如果你用到是 Python 2 的话，记得继承 object:\n# 默认， Python 3\nclass A:\n    pass\n\n# Python 2\nclass A(object):\n    pass\nPython 3 和 Python 2 的另一个区别是: Python 3 可以使用直接使用 super().xxx 代替 super(Class, self).xxx :\n# 默认，Python 3\nclass B(A):\n    def add(self, x):\n        super().add(x)\n\n# Python 2\nclass B(A):\n    def add(self, x):\n        super(B, self).add(x)\n所以，你如果用的是 Python 2 的话，记得将本文的 super() 替换为 suepr(Class, self) 。\n如果还有其他不兼容 Python 2 的情况，我会在文中注明的。\n单继承\n在单继承中 super 就像大家所想的那样，主要是用来调用父类的方法的。\nclass A:\n    def __init__(self):\n        self.n = 2\n\n    def add(self, m):\n        print('self is {0} @A.add'.format(self))\n        self.n += m\n\n\nclass B(A):\n    def __init__(self):\n        self.n = 3\n\n    def add(self, m):\n        print('self is {0} @B.add'.format(self))\n        super().add(m)\n        self.n += 3\n你觉得执行下面代码后， b.n 的值是多少呢？\nb = B()\nb.add(2)\nprint(b.n)\n执行结果如下:\nself is <__main__.B object at 0x106c49b38> @B.add\nself is <__main__.B object at 0x106c49b38> @A.add\n8\n这个结果说明了两个问题:\n\nsuper().add(m) 确实调用了父类 A 的 add 方法。\nsuper().add(m) 调用父类方法 def add(self, m) 时, 此时父类中 self 并不是父类的实例而是子类的实例, 所以 b.add(2) 之后的结果是 5 而不是 4 。\n\n不知道这个结果是否和你想到一样呢？下面我们来看一个多继承的例子。\n多继承\n这次我们再定义一个 class C，一个 class D:\nclass C(A):\n    def __init__(self):\n        self.n = 4\n\n    def add(self, m):\n        print('self is {0} @C.add'.format(self))\n        super().add(m)\n        self.n += 4\n\n\nclass D(B, C):\n    def __init__(self):\n        self.n = 5\n\n    def add(self, m):\n        print('self is {0} @D.add'.format(self))\n        super().add(m)\n        self.n += 5\n下面的代码又输出啥呢？\nd = D()\nd.add(2)\nprint(d.n)\n这次的输出如下:\nself is <__main__.D object at 0x10ce10e48> @D.add\nself is <__main__.D object at 0x10ce10e48> @B.add\nself is <__main__.D object at 0x10ce10e48> @C.add\nself is <__main__.D object at 0x10ce10e48> @A.add\n19\n你说对了吗？你可能会认为上面代码的输出类似: :\nself is <__main__.D object at 0x10ce10e48> @D.add\nself is <__main__.D object at 0x10ce10e48> @B.add\nself is <__main__.D object at 0x10ce10e48> @A.add\n15\n\n为什么会跟预期的不一样呢？下面我们将一起来看看 super 的奥秘。\nsuper 是个类\n当我们调用 super() 的时候，实际上是实例化了一个 super 类。你没看错， super 是个类，既不是关键字也不是函数等其他数据结构:\n>>> class A: pass\n...\n>>> s = super(A)\n>>> type(s)\n<class 'super'>\n>>>\n在大多数情况下， super 包含了两个非常重要的信息: 一个 MRO 以及 MRO 中的一个类。当以如下方式调用 super 时: :\nsuper(a_type, obj)\n\nMRO 指的是 type(obj) 的 MRO, MRO 中的那个类就是 a_type , 同时 isinstance(obj, a_type) == True 。\n当这样调用时: :\nsuper(type1, type2)\n\nMRO 指的是 type2 的 MRO, MRO 中的那个类就是 type1 ，同时 issubclass(type2, type1) == True 。\n那么， super() 实际上做了啥呢？简单来说就是：提供一个 MRO 以及一个 MRO 中的类 C ， super() 将返回一个从 MRO 中 C 之后的类中查找方法的对象。\n也就是说，查找方式时不是像常规方法一样从所有的 MRO 类中查找，而是从 MRO 的 tail 中查找。\n举个栗子, 有个 MRO: :\n[A, B, C, D, E, object]\n\n下面的调用: :\nsuper(C, A).foo()\n\nsuper 只会从 C 之后查找，即: 只会在 D 或 E 或 object 中查找 foo 方法。\n多继承中 super 的工作方式\n再回到前面的\nd = D()\nd.add(2)\nprint(d.n)\n现在你可能已经有点眉目，为什么输出会是 :\nself is <__main__.D object at 0x10ce10e48> @D.add\nself is <__main__.D object at 0x10ce10e48> @B.add\nself is <__main__.D object at 0x10ce10e48> @C.add\nself is <__main__.D object at 0x10ce10e48> @A.add\n19\n\n了吧 ;)\n下面我们来具体分析一下:\n\nD 的 MRO 是: [D, B, C, A, object] 。 备注: 可以通过 D.mro() (Python 2 使用 D.__mro__ ) 来查看 D 的 MRO 信息）\n详细的代码分析如下:\n\nclass A:\n    def __init__(self):\n        self.n = 2\n\n    def add(self, m):\n        # 第四步\n        # 来自 D.add 中的 super\n        # self == d, self.n == d.n == 5\n        print('self is {0} @A.add'.format(self))\n        self.n += m\n        # d.n == 7\n\n\nclass B(A):\n    def __init__(self):\n        self.n = 3\n\n    def add(self, m):\n        # 第二步\n        # 来自 D.add 中的 super\n        # self == d, self.n == d.n == 5\n        print('self is {0} @B.add'.format(self))\n        # 等价于 suepr(B, self).add(m)\n        # self 的 MRO 是 [D, B, C, A, object]\n        # 从 B 之后的 [C, A, object] 中查找 add 方法\n        super().add(m)\n\n        # 第六步\n        # d.n = 11\n        self.n += 3\n        # d.n = 14\n\nclass C(A):\n    def __init__(self):\n        self.n = 4\n\n    def add(self, m):\n        # 第三步\n        # 来自 B.add 中的 super\n        # self == d, self.n == d.n == 5\n        print('self is {0} @C.add'.format(self))\n        # 等价于 suepr(C, self).add(m)\n        # self 的 MRO 是 [D, B, C, A, object]\n        # 从 C 之后的 [A, object] 中查找 add 方法\n        super().add(m)\n\n        # 第五步\n        # d.n = 7\n        self.n += 4\n        # d.n = 11\n\n\nclass D(B, C):\n    def __init__(self):\n        self.n = 5\n\n    def add(self, m):\n        # 第一步\n        print('self is {0} @D.add'.format(self))\n        # 等价于 super(D, self).add(m)\n        # self 的 MRO 是 [D, B, C, A, object]\n        # 从 D 之后的 [B, C, A, object] 中查找 add 方法\n        super().add(m)\n\n        # 第七步\n        # d.n = 14\n        self.n += 5\n        # self.n = 19\n\nd = D()\nd.add(2)\nprint(d.n)\n调用过程图如下:\nD.mro() == [D, B, C, A, object]\nd = D()\nd.n == 5\nd.add(2)\n\nclass D(B, C):          class B(A):            class C(A):             class A:\n    def add(self, m):       def add(self, m):      def add(self, m):       def add(self, m):\n        super().add(m)  1.--->  super().add(m) 2.--->  super().add(m)  3.--->  self.n += m\n        self.n += 5   <------6. self.n += 3    <----5. self.n += 4     <----4. <--|\n        (14+5=19)               (11+3=14)              (7+4=11)                (5+2=7)\n现在你知道为什么 d.add(2) 后 d.n 的值是 19 了吧 ;)\nThat's all! 希望这篇文章能对你有所帮助 ;)\n参考资料\n\nPython's super() Explained\n2. Built-in Functions — Python 3.5.2 documentation\nPython's Super Considered Harmful\n\n原文地址： https://mozillazg.com/2016/12...\n\n                ", "mainLikeNum": ["4 "], "mainBookmarkNum": "8"}