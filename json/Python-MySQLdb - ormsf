{"title": "Python-MySQLdb - ormsf ", "index": "python,mysql", "content": "准备工作\n首先要新建一个数据库python和一张数据表user\n$ mysql -u root -p \n> create database python;\n\n> use database python;\n\n> create table user(\nusername varchar(32),\npassword varchar(32)\n);\n连接到数据库\nIn [1]: import MySQLdb\n\n# 获取connection\nIn [2]: conn = MySQLdb.connect(\nhost = '127.0.0.1',\nport = 3306,\nuser = 'root',\npasswd ='root',\ndb = 'python',\ncharset = 'utf8'\n)\n\n# 获取到cusor，所有的操作都要通过cursor进行\nIn [3]: cursor = conn.cursor()\n插入操作\nIn [4]: sql = \"insert into user (username, password) values(%s, %s)\"\n\n# 这里我们将要插入的数据存入一个tuple当中\nIn [5]: cursor.execute(sql, ('zxy', '123')\nOut[5]: 1L\n因为这里是要插入数据，所以要commit，但是我不进行commit好像也没有问题。我查阅到的资料的解释是，当curosr.execute()执行成功的时候，执行conn.commit()，但是执行失败的时候，就执行conn.roolback()，跟hibernate一样，应该也是进行事务的回滚。还有一点，有的教程说应该设置conn.autocommit(False)来关闭自动提交事务，这应该也就是我不要commit的原因了吧。insert/update/delete这种更改数据库的方式都要进行commit，但是select这类查询操作就没有必要了，因为select不会更改到数据库。\nIn [6]: conn.commit()\n\n# 我这里省去了commit，好像也行\nIn [7]: cursor.execute(sql, ('yd', '456'))\nOut[7]: 1L\n查询操作\nIn [8]: sql = \"select * from user\"\n\nIn [9]: cursor.execute(sql)\nOut[9]: 2L\n\n# fetchall是得到所有的结果，你以可以使用fetchone()来只查询一条数据，或者fetchmany(size=n)来指定查询的条数\nIn [10]: result = cursor.fetchall()           \n\nIn [11]: cursor.fetchall()\nOut[11]: ((u'zxy', u'123'), (u'yd', u'456'))\n\n# 还可以打印出查询到的条数以用来优雅的遍历\nIn [12]: print(cursor.rowcount)\n2\n\n# 最后记得关闭conn和cursor\nIn [13]: cursor.close()\n\nIn [14]: conn.close()\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}