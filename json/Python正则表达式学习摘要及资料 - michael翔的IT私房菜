{"title": "Python正则表达式学习摘要及资料 - michael翔的IT私房菜 ", "index": "正则表达式,python", "content": "摘要\n\n在正则表达式中，如果直接给出字符，就是精确匹配。\n\n{m,n}?    对于前一个字符重复 m 到 n 次，并且取尽可能少的情况    在字符串'aaaaaa'中，a{2,4} 会匹配 4 个 a，但 a{2,4}? 只匹配 2 个 a。\n\n^表示行的开头，^\\d表示必须以数字开头。\n$表示行的结束，\\d$表示必须以数字结束。\n你可能注意到了，py也可以匹配'python'-->py;但是加上^py$就变成了整行匹配，就只能匹配'py'了,匹配'python'时，就什么也得不到。\n参考表\n正则表达式特殊序列\n\nre模块\nre.compile(pattern[, flags])把正则表达式的模式和标识转化成正则表达式对象，供 match() 和 search() 这两个函数使用。\nre 所定义的 flag 包括：\nre.I 忽略大小写\nre.L 表示特殊字符集 \\w, \\W, \\b, \\B, \\s, \\S 依赖于当前环境\nre.M 多行模式\nre.S 即为’ . ’并且包括换行符在内的任意字符（’ . ’不包括换行符）\nre.U 表示特殊字符集 \\w, \\W, \\b, \\B, \\d, \\D, \\s, \\S 依赖于 Unicode 字符属性数据库\nre.X 为了增加可读性，忽略空格和’ # ’后面的注释\n以下两种用法结果相同：(A)\ncompiled_pattern = re.compile(pattern) \nresult = compiled_pattern.match(string)\n(B)\nresult = re.match(pattern, string)\n由于Python的字符串本身也用转义，所以要特别注意：\ns = 'ABC\\\\-001' # Python的字符串\n #对应的正则表达式字符串变成：\n #'ABC\\-001'\n因此我们强烈建议使用Python的r前缀，就不用考虑转义的问题了\ns = r'ABC\\-001' # Python的字符串\n# 对应的正则表达式字符串不变：\n# 'ABC\\-001'\nsearch\nre.search(pattern, string[, flags])`在字符串中查找匹配正则表达式模式的位置，返回 MatchObject 的实例，如果没有找到匹配的位置，则返回 None。对于已编译的正则表达式对象来说（re.RegexObject），有以下 search 的方法：search (string[, pos[, endpos]])若 regex 是已编译好的正则表达式对象，regex.search(string, 0, 50) 等同于 regex.search(string[:50], 0)。\n >>> pattern = re.compile(\"a\") \n >>> pattern.search(\"abcde\")     # Match at index 0 \n >>> pattern.search(\"abcde\", 1)  # No match;\nmatch\nre.match(pattern, string[, flags])判断 pattern 是否在字符串开头位置匹配。对于 RegexObject，有：match(string[, pos[, endpos]])match() 函数只在字符串的开始位置尝试匹配正则表达式，也就是只报告从位置 0 开始的匹配情况，而 search() 函数是扫描整个字符串来查找匹配。如果想要搜索整个字符串来寻找匹配，应当用 search()。\n>>> pattern.match('bca',2).group()\n'a'\n虽然，match默认是从开头匹配，但是，如果指定位置，仍然能成功；但是！match也是从指定位置开始匹配，不匹配仍然会失败，这一点就和search有区别啦。\nmatch()方法判断是否匹配，如果匹配成功，返回一个Match对象，否则返回None。\ntest = '用户输入的字符串'\nif re.match(r'正则表达式', test):\n    print('ok')\nelse:\n    print('failed')\nsplit\nre.split(pattern, string[, maxsplit=0, flags=0])此功能很常用，可以将将字符串匹配正则表达式的部分割开并返回一个列表。对 RegexObject，有函数：split(string[, maxsplit=0])\n对于一个找不到匹配的字符串而言，split 不会对其作出分割\n>>> 'a b   c'.split(' ')\n['a', 'b', '', '', 'c']\n\n这里用字符串自带的split方法就很不灵活。\n>>> re.split(r'\\s+', 'a b   c')\n['a', 'b', 'c']\n看出差别了吧，很强大！再来一个终极的：\n>>> re.split(r'[\\s\\,\\;]+', 'a,b;; c  d')\n['a', 'b', 'c', 'd']\nr'[\\s\\,\\;]+'的正则表达式意思为：空格或者,或者;`出现1次或1次以上都是满足条件的分割符号！所以，最后结果还是很干净。\nfindall\nre.findall(pattern, string[, flags])\n在字符串中找到正则表达式所匹配的所有子串，并组成一个列表返回。同样 RegexObject 有：findall(string[, pos[, endpos]])\n #get all content enclosed with [], and return a list \n>>> pattern=re.compile(r'hh')\n>>> pattern.findall('hhmichaelhh')\n['hh', 'hh']\nfinditer\nre.finditer(pattern, string[, flags])和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并组成一个迭代器返回。同样 RegexObject 有：finditer(string[, pos[, endpos]])\nsub\nre.sub(pattern, repl, string[, count, flags])在字符串 string 中找到匹配正则表达式pattern 的所有子串，用另一个字符串 repl 进行替换。如果没有找到匹配 pattern 的串，则返回未被修改的 string。Repl 既可以是字符串也可以是一个函数。\n返回值是替换后的新字符串。\n对于 RegexObject 有：sub(repl, string[, count=0])\n>>> pattern=re.compile(r'\\d')\n>>> pattern.sub('no','12hh34hh')\n'nonohhnonohh'\n>>> pattern.sub('no','12hh34hh',0)\n'nonohhnonohh'\n>>> pattern.sub('no','12hh34hh',count=0)\n'nonohhnonohh'\n>>> pattern.sub('no','12hh34hh',1)\n'no2hh34hh'\n通过上面的例子，可以看出,count是可以缺省的，同时，默认值是0，表示全部替换；否则，就是指定替换几个。\nsubn\nre.subn(pattern, repl, string[, count, flags])该函数的功能和 sub() 相同，但它还返回新的字符串以及替换的次数。同样 RegexObject 有：subn(repl, string[, count=0])\n>>> pattern.subn('no','12hh34hh',count=0)\n('nonohhnonohh', 4)\n分组\n除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group）。比如：\n^(\\d{3})-(\\d{3,8})$分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：\n>>> m = re.match(r'^(\\d{3})-(\\d{3,8})$', '010-12345')\n>>> m\n<_sre.SRE_Match object; span=(0, 9), match='010-12345'>\n>>> m.group(0)\n'010-12345'\n>>> m.group(1)\n'010'\n>>> m.group(2)\n'12345'\n>>> m.groups()\n('010', '12345')\n通过实验，如果不用括号，得到的Match对象课可以使用例如a.group(0)或者a.group()但是，使用a.group(1)就会报错的。\n贪婪匹配\n正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0：\n>>> re.match(r'^(\\d+)(0*)$', '102300').groups()\n('102300', '')\n由于\\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。\n必须让\\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\\d+采用非贪婪匹配：\n>>> re.match(r'^(\\d+?)(0*)$', '102300').groups()\n('1023', '00')\nSF-正则表达式的贪婪非贪婪模式怎么理解？\nPython正则表达式学习资源\n\n\n廖雪峰-正则表达式\nIBM-使用 Python 模块 re 实现解析小工具\n\ndeerchao-则表达式30分钟入门教程\ndeerchao-正则表达式30分钟入门教程\n\n静觅-爬虫入门七之正则表达式\nPython中re的match、search、findall、finditer区别\nPython正则表达式与re模块\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "10"}