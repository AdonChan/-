{"title": "Numpy 小结 - 个人文章 ", "index": "numpy,python3.x,python", "content": "Python 真火来学习一下，先来看一个库 NumPy。NumPy是Python语言的一个扩充程序库。支持高级大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。\n1. 读取文件\nnumpy.genfromtxt() 用于读取 txt 文件，其中传入的参数依次为：\n\n需要读取的 txt 文件位置，此处文件与程序位于同一目录下\n分割的标记\n转换类型，如果文件中既有文本类型也有数字类型，就先转成文本类型\n\nhelp(numpy.genfromtxt)用于查看帮助文档：如果不想看 API 可以启动一个程序用 help 查看指令的详细用法\nimport numpy\n\nworld_alcohol = numpy.genfromtxt(\"world_alcohol.txt\", delimiter=\",\",dtype=str)\nprint(type(world_alcohol))\nprint(world_alcohol)\nprint(help(numpy.genfromtxt))\n2. 构造 ndarray\nnumpy.array()构造 ndarray\nnumpy.array()中传入数组参数，可以是一维的也可以是二维三维的。numpy 会将其转变成 ndarray 的结构。\nvector = numpy.array([1,2,3,4])\nmatrix = numpy.array([[1,2,3],[4,5,6]])\n传入的参数必须是同一结构,不是同一结构将发生转换。\nvector = numpy.array([1,2,3,4])\n\narray([1, 2, 3, 4])\n均为 int 类型\nvector = numpy.array([1,2,3,4.0])\n\narray([ 1.,  2.,  3.,  4.])\n转为浮点数类型\nvector = numpy.array([1,2,'3',4])\n\narray(['1', '2', '3', '4'],dtype='<U21')\n转为字符类型\n利用 .shape 查看结构\n能够了解 array 的结构，debug 时通过查看结构能够更好地了解程序运行的过程。\nprint(vector.shape)\nprint(matrix.shape)\n(4,)\n(2, 3)\n利用 dtype 查看类型\nvector = numpy.array([1,2,3,4])\nvector.dtype\n\ndtype('int64')\nndim 查看维度\n一维\nvector = numpy.array([1,2,3,4])\nvector.ndim\n\n1\n二维\nmatrix = numpy.array([[1,2,3],\n                      [4,5,6],\n                     [7,8,9]])\nmatrix.ndim\n\n2\nsize 查看元素数量\nmatrix.size\n9\n3. 获取与计算\nnumpy 能使用切片获取数据\nmatrix = numpy.array([[1,2,3],\n                      [4,5,6],\n                     [7,8,9]])\n根据条件获取\nnumpy 能够依次比较 vector 和元素之间是否相同\nvector = numpy.array([5, 10, 15, 20])\nvector == 10\n\narray([False,  True, False, False], dtype=bool)\n根据返回值获取元素\nvector = numpy.array([5, 10, 15, 20])\nequal_to_ten = (vector == 10)\nprint(equal_to_ten)\nprint(vector[equal_to_ten])\n\n[False  True False False]\n[10]\n进行运算之后获取\nvector = numpy.array([5, 10, 15, 20])\nequal_to_ten_and_five = (vector == 10) & (vector == 5)\nvector = numpy.array([5, 10, 15, 20])\nequal_to_ten_or_five = (vector == 10) | (vector == 5)\n类型转换\n将整体类型进行转换\nvector = numpy.array([5, 10, 15, 20])\nprint(vector.dtype)\nvector = vector.astype(str)\nprint(vector.dtype)\n\nint64\n<U21\n求和\nsum() 能够对 ndarray 进行各种求和操作，比如分别按行按列进行求和\nmatrix = numpy.array([[1,2,3],\n                      [4,5,6],\n                     [7,8,9]])\nprint(matrix.sum())\nprint(matrix.sum(1))\nprint(matrix.sum(0))\n\n45\n[ 6 15 24]\n[12 15 18]\nsum(1) 是 sum(axis=1)) 的缩写，1表示按照 x轴方向求和，0表示按照y轴方向求和\n4. 常用函数\nreshape\n生成从 0-14 的 15 个数字，使用 reshape(3,5) 将其构造成一个三行五列的 array。\nimport numpy as np\narr = np.arange(15).reshape(3, 5)\narr\n\narray([[ 0,  1,  2,  3,  4],\n       [ 5,  6,  7,  8,  9],\n       [10, 11, 12, 13, 14]])\nzeros\n生成指定结构的默认为 0. 的 array\nnp.zeros ((3,4))\n\narray([[ 0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.]])\nones\n生成一个三维的 array,通过 dtype 指定类型\nnp.ones( (2,3,4), dtype=np.int32 )\n\narray([[[1, 1, 1, 1],\n        [1, 1, 1, 1],\n        [1, 1, 1, 1]],\n\n       [[1, 1, 1, 1],\n        [1, 1, 1, 1],\n        [1, 1, 1, 1]]])\nrange\n指定范围和数值间的间隔生成 array，注意范围包左不包右\nnp.arange(0,10,2)\n\narray([0, 2, 4, 6, 8])\nrandom 随机数\n生成指定结构的随机数，可以用于生成随机权重\nnp.random.random((2,3))\n\narray([[ 0.86166627,  0.37756207,  0.94265883],\n       [ 0.9768257 ,  0.96915312,  0.33495431]])\n5. ndarray 运算\n元素之间依次相减相减\na = np.array([10,20,30,40])\nb = np.array(4)\n\na - b\narray([ 6, 16, 26, 36])\n乘方\na**2\narray([ 100,  400,  900, 1600])\n开根号\nnp.sqrt(B)\n\narray([[ 1.41421356,  0.        ],\n       [ 1.73205081,  2.        ]])\ne 求方\nnp.exp(B)\n\narray([[  7.3890561 ,   1.        ],\n       [ 20.08553692,  54.59815003]])\n向下取整\na = np.floor(10*np.random.random((2,2)))\na\n\narray([[ 0.,  0.],\n       [ 3.,  6.]])\n行列变换\na.T\n\narray([[ 0.,  3.],\n       [ 0.,  6.]])\n变换结构\na.resize(1,4)\na\n\narray([[ 0.,  0.,  3.,  6.]])\n6. 矩阵运算\n矩阵之间的运算\nA = np.array( [[1,1],\n               [0,1]] )\nB = np.array( [[2,0],\n               [3,4]] )\n对应位置一次相乘\nA*B\n\narray([[2, 0],\n       [0, 4]])\n矩阵乘法\nprint (A.dot(B))\nprint(np.dot(A,B))\n\n[[5 4]\n [3 4]]\n横向相加\na = np.floor(10*np.random.random((2,2)))\nb = np.floor(10*np.random.random((2,2)))\n\nprint(a)\nprint(b)\nprint(np.hstack((a,b)))\n\n[[ 2.  3.]\n [ 9.  3.]]\n[[ 8.  1.]\n [ 0.  0.]]\n[[ 2.  3.  8.  1.]\n [ 9.  3.  0.  0.]]\n纵向相加\nprint(np.vstack((a,b)))\n\n[[ 2.  3.]\n [ 9.  3.]\n [ 8.  1.]\n [ 0.  0.]]\n矩阵分割\n#横向分割\nprint( np.hsplit(a,3))\n#纵向风格\nprint(np.vsplit(a,3))\n7. 复制的区别\n地址复制\n通过 b = a 复制 a 的值，b 与 a 指向同一地址，改变 b 同时也改变 a。\na = np.arange(12)\nb = a\nprint(a is b)\n\nprint(a.shape)\nprint(b.shape)\nb.shape = (3,4)\nprint(a.shape)\nprint(b.shape)\n\nTrue\n(12,)\n(12,)\n(3, 4)\n(3, 4)\n复制值\n通过 a.view() 仅复制值，当对 c 值进行改变会改变 a 的对应的值，而改变 c 的 shape 不改变 a 的 shape\na = np.arange(12)\nc = a.view()\nprint(c is a)\n\nc.shape = 2,6\nc[0,0] = 9999\n\nprint(a)\nprint(c)\n\nFalse\n[9999    1    2    3    4    5    6    7    8    9   10   11]\n[[9999    1    2    3    4    5]\n [   6    7    8    9   10   11]]\n完整拷贝\na.copy() 进行的完整的拷贝，产生一份完全相同的独立的复制\na = np.arange(12)\nc = a.copy()\nprint(c is a)\n\nc.shape = 2,6\nc[0,0] = 9999\n\nprint(a)\nprint(c)\n\nFalse\n[ 0  1  2  3  4  5  6  7  8  9 10 11]\n[[9999    1    2    3    4    5]\n [   6    7    8    9   10   11]]\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "6"}