{"title": "【Python】使用装饰器为Python实现运行时类型检查 - 追不上乌龟的兔子 ", "index": "python", "content": "背景\n闲来无事想熟悉一下Python的装饰器写法，就写了一个简单的类型检查装饰器。\n思路\n利用带参数的装饰器直接传入变量的预期类型，然后使用isinstance检查类型。\n代码\ndef typeLimits(*types, **typesdict):\n    def desc(func):\n        def f(*args, **kwargs):\n            for i, v in enumerate(types):\n                if not isinstance(args[i], v):\n                    raise Exception(\"Need a {} where {} is not.\".format(v.__name__, args[i]))\n            for parm in typesdict:\n                if kwargs.get(parm, None) is None:\n                    raise Exception(\"Need parameter {}.\".format(parm))\n                if not isinstance(kwargs[parm],typesdict[parm]):\n                    raise Exception('Need a {} for {} where {} is not.'.format(typesdict[parm].__name__, parm, kwargs[parm]))\n            return func(*args, **kwargs)\n        return f\n    return desc\n\n@typeLimits(int, str)\ndef printOneIntAndOneString(n, s):\n    print(n ** 2, s.upper())\n\n@typeLimits(int, name = str)\ndef printOneIntAndName(n, name):\n    print(n + n, name.upper())\n\nprintOneIntAndOneString(1,'abc') # 正确执行\n\n# printOneIntAndOneString(1 + 2,3 + 4) 报错\n\nprintOneIntAndName(1, name = \"aaa\") 正确执行\n\n# printOneIntAndName(1) 报错\n\n# printOneIntAndName(1, name = 2.0) 报错\n感想\n这只是一个游戏之作，检查类型会耗费一些性能，真正部署运行的项目是不需要类型检查的，但可以在测试的时候使用类型检查来避免一些无谓的错误。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "2"}