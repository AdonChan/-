{"title": "python装饰器详解 - Just For Fun ", "index": "python", "content": "原文地址\n之前用python简单写了一下斐波那契数列的递归实现（如下），发现运行速度很慢。\ndef fib_direct(n):\n    assert n > 0, 'invalid n'\n    if n < 3:\n        return 1\n    else:\n        return fib_direct(n - 1) + fib_direct(n - 2)\n然后大致分析了一下fib_direct(5)的递归调用过程，如下图：\n\n可以看到多次重复调用，因此效率十分低。进一步，可以算出递归算法的时间复杂度。T(n) = T(n-1) + T(n-2)，用常系数线性齐次递推方程的解法，解出递推方程的特征根，特征根里最大的n次方就是它的时间复杂度O(1.618^n)，指数级增长。\n为了避免重复调用，可以适当地做缓存，python的装饰器可以完美的完成这一任务。\n<!-- more -->\n装饰器：基础\npython中一切都是对象，这里需要强调函数是对象。为了更好地理解函数也是对象，下面结合代码片段来说明这一点。\n\ndef shout(word=\"yes\"):\n    return word.capitalize() + \"!\"\n\nprint shout()\n# outputs: Yes!\n\n\"\"\"\nAs an object, you can assign the function to a variable like any other object.\nNotice we don't use parentheses: we are not calling the function,\nwe are putting the function \"shout\" into the variable \"scream\".\n\"\"\"\nscream = shout\n\nprint scream()\n# outputs: Yes!\n\n\"\"\"\nMore than that, it means you can remove the old name 'shout',\nand the function will still be accessible from 'scream'.\n\"\"\"\ndel shout\ntry:\n    print shout()\nexcept NameError, e:\n    print e\n    # outputs: name 'shout' is not defined\n\nprint scream()\n# outputs: 'Yes!'\n\n因为函数是对象，所以python中函数还有一个有趣的特性：函数可以被定义在另一个函数中。下面来看一个简单的例子。\ndef talk():\n\n    # You can define a function on the fly in \"talk\"\n    def whisper(word=\"yes\"):\n        return word.lower()+\"...\"\n    print whisper()\n\n\"\"\"\nYou call \"talk\", that defines \"whisper\" EVERY TIME you call it,\nthen \"whisper\" is called in \"talk\".\n\"\"\"\ntalk()\n# outputs: yes...\n\n# But \"whisper\" DOES NOT EXIST outside \"talk\".\ntry:\n    print whisper()\nexcept NameError, e:\n    print e\n    # outputs : name 'whisper' is not defined\n\n函数引用\n前面已经知道函数是对象。那么：\n\n可以被赋给另一个变量\n可以被定义在另一个函数里\n\n这也意味着，一个函数可以返回另一个函数，下面看一个简单的例子。\ndef get_talk(kind=\"shout\"):\n\n    def whisper(word=\"yes\"):\n        return word.lower() + \"...\"\n\n    def shout(word=\"yes\"):\n        return word.capitalize() + \"!\"\n\n    return whisper if kind == \"whisper\" else shout\n\n# Get the function and assign it to a variable\ntalk = get_talk()\n\n# You can see that \"talk\" is here a function object:\nprint talk\n# outputs : <function shout at 0x107ae9578>\n\nprint talk()\n# outputs : Yes!\n\n# And you can even use it directly if you feel wild:\nprint get_talk(\"whisper\")()\n# outputs : yes...\n\n我们来进一步挖掘一下函数的特性，既然可以返回函数，那么我们也可以把函数作为参数传递。\ndef whisper(word=\"yes\"):\n    return word.lower() + \"...\"\n\n\ndef do_something_before(func):\n    print \"I do something before.\"\n    print \"Now the function you gave me:\\n\", func()\n\ndo_something_before(whisper)\n\"\"\"outputs\nI do something before.\nNow the function you gave me:\nyes...\n\"\"\"\n\n现在，了解装饰器所需要的所有要点我们已经掌握了，通过上面的例子，我们还可以看出，装饰器其实就是封装器，可以让我们在不修改原函数的基础上，在执行原函数的前后执行别的代码。\n手工装饰器\n下面我们手工实现一个简单的装饰器。\ndef my_shiny_new_decorator(a_function_to_decorate):\n\n    \"\"\"\n    Inside, the decorator defines a function on the fly: the wrapper.\n    This function is going to be wrapped around the original function\n    so it can execute code before and after it.\n    \"\"\"\n    def the_wrapper_around_the_original_function():\n\n        \"\"\"\n        Put here the code you want to be executed BEFORE the original\n        function is called\n        \"\"\"\n        print \"Before the function runs\"\n\n        # Call the function here (using parentheses)\n        a_function_to_decorate()\n\n        \"\"\"\n        Put here the code you want to be executed AFTER the original\n        function is called\n        \"\"\"\n        print \"After the function runs\"\n\n    \"\"\"\n    At this point, \"a_function_to_decorate\" HAS NEVER BEEN EXECUTED.\n    We return the wrapper function we have just created.\n    The wrapper contains the function and the code to execute before\n    and after. It’s ready to use!\n    \"\"\"\n    return the_wrapper_around_the_original_function\n\n\n# Now imagine you create a function you don't want to ever touch again.\ndef a_stand_alone_function():\n    print \"I am a stand alone function, don't you dare modify me\"\n\na_stand_alone_function()\n# outputs: I am a stand alone function, don't you dare modify me\n\n\"\"\"\nWell, you can decorate it to extend its behavior.\nJust pass it to the decorator, it will wrap it dynamically in\nany code you want and return you a new function ready to be used:\n\"\"\"\n\na_stand_alone_function_decorated = my_shiny_new_decorator(a_stand_alone_function)\na_stand_alone_function_decorated()\n\"\"\"outputs:\nBefore the function runs\nI am a stand alone function, don't you dare modify me\nAfter the function runs\n\"\"\"\n\n现在，如果我们想每次调用a_stand_alone_function的时候，实际上调用的是封装后的函数a_stand_alone_function_decorated，那么只需要用a_stand_alone_function去覆盖my_shiny_new_decorator返回的函数即可。也就是：\na_stand_alone_function = my_shiny_new_decorator(a_stand_alone_function)\n装饰器阐述\n对于前面的例子，如果用装饰器语法，可以添加如下：\n@my_shiny_new_decorator\ndef another_stand_alone_function():\n    print \"Leave me alone\"\n\nanother_stand_alone_function()\n\"\"\"outputs:\nBefore the function runs\nLeave me alone\nAfter the function runs\n\"\"\"\n\n对了，这就是装饰器语法，这里的@my_shiny_new_decorator是another_stand_alone_function = my_shiny_new_decorator(another_stand_alone_function)的简写。\n装饰器只是装饰器设计模式的python实现，python还存在其他几个经典的设计模式，以方便开发，例如迭代器iterators。\n当然了，我们也可以嵌套装饰器。\ndef bread(func):\n    def wrapper():\n        print \"</''''''\\>\"\n        func()\n        print \"<\\______/>\"\n\n    return wrapper\n\n\ndef ingredients(func):\n    def wrapper():\n        print \"#tomatoes#\"\n        func()\n        print \"~salad~\"\n\n    return wrapper\n\n\ndef sandwich(food=\"--ham--\"):\n    print food\n\nsandwich()\n# outputs: --ham--\nsandwich = bread(ingredients(sandwich))\nsandwich()\n\"\"\"outputs:\n</''''''\\>\n #tomatoes#\n --ham--\n ~salad~\n<\\______/>\n\"\"\"\n\n用python的装饰器语法，如下：\n@bread\n@ingredients\ndef sandwich_2(food=\"--ham_2--\"):\n    print food\n\nsandwich_2()\n\n放置装饰器的位置很关键。\n@ingredients\n@bread\ndef strange_sandwich(food=\"--ham--\"):\n    print food\n\nstrange_sandwich()\n\"\"\"outputs:\n#tomatoes#\n</''''''\\>\n --ham--\n<\\______/>\n ~salad~\n\"\"\"\n\n装饰器高级用法\n给装饰器函数传递参数\n当我们调用装饰器返回的函数时，其实是在调用封装函数，给封装函数传递参数也就同样的给被装饰函数传递了参数。\ndef a_decorator_passing_arguments(function_to_decorate):\n    def a_wrapper_accepting_arguments(arg1, arg2):\n        print \"I got args! Look:\", arg1, arg2\n        function_to_decorate(arg1, arg2)\n    return a_wrapper_accepting_arguments\n\n\"\"\"\nSince when you are calling the function returned by the decorator, you are\ncalling the wrapper, passing arguments to the wrapper will let it pass them to\nthe decorated function\n\"\"\"\n\n\n@a_decorator_passing_arguments\ndef print_full_name(first_name, last_name):\n    print \"My name is\", first_name, last_name\n\n\nprint_full_name(\"Peter\", \"Venkman\")\n\"\"\"outputs:\nI got args! Look: Peter Venkman\nMy name is Peter Venkman\n\"\"\"\n\n装饰方法\npython中函数和方法几乎一样，除了方法中第一个参数是指向当前对象的引用(self)。这意味着我们可以为方法创建装饰器，只是要记得考虑self。\ndef method_friendly_decorator(method_to_decorate):\n    def wrapper(self, lie):\n        lie = lie - 3\n        return method_to_decorate(self, lie)\n    return wrapper\n\n\nclass Lucy(object):\n\n    def __init__(self):\n        self.age = 32\n\n    @method_friendly_decorator\n    def sayYourAge(self, lie):\n        print \"I am %s, what did you think?\" % (self.age + lie)\n\nl = Lucy()\nl.sayYourAge(-3)\n# outputs: I am 26, what did you think?\n\n我们还可以创建一个通用的装饰器，可以用于所有的方法或者函数，而且不用考虑它的参数情况。这时候，我们要用到*args, **kwargs。\ndef a_decorator_passing_arbitrary_arguments(function_to_decorate):\n    # The wrapper accepts any arguments\n    def a_wrapper_accepting_arbitrary_arguments(*args, **kwargs):\n        print \"Do I have args?:\"\n        print args\n        print kwargs\n        # Then you unpack the arguments, here *args, **kwargs\n        # If you are not familiar with unpacking, check:\n        # http://www.saltycrane.com/blog/2008/01/how-to-use-args-and-kwargs-in-python/\n        function_to_decorate(*args, **kwargs)\n    return a_wrapper_accepting_arbitrary_arguments\n\n另外还有一些高级用法，这里不做详细说明，可以在How can I make a chain of function decorators in Python?进一步深入了解装饰器。\nfunctools.wraps\n装饰器封装了函数，这使得调试函数变得困难。不过在python 2.5引入了functools模块，它包含了functools.wraps()函数，这个函数可以将被封装函数的名称、模块、文档拷贝给封装函数。有趣的是，functools.wraps是一个装饰器。为了更好地理解，看以下代码：\n# For debugging, the stacktrace prints you the function __name__\ndef foo():\n    print \"foo\"\n\nprint foo.__name__\n# outputs: foo\n\n\ndef bar(func):\n    def wrapper():\n        print \"bar\"\n        return func()\n    return wrapper\n\n\n@bar\ndef foo():\n    print \"foo\"\n\nprint foo.__name__\n# outputs: wrapper\n\n\nimport functools\n\n\ndef bar(func):\n    # We say that \"wrapper\", is wrapping \"func\"\n    # and the magic begins\n    @functools.wraps(func)\n    def wrapper():\n        print \"bar\"\n        return func()\n    return wrapper\n\n\n@bar\ndef foo():\n    print \"foo\"\n\nprint foo.__name__\n# outputs: foo\n\n为何装饰器那么有用\n让我们回到本篇文章开始的问题上，重复调用导致递归的效率低下，因此考虑使用缓存机制，空间换时间。这里，就可以使用装饰器做缓存，看下面代码：\nfrom functools import wraps\n\ndef cache(func):\n    caches = {}\n\n    @wraps(func)\n    def wrap(*args):\n        if args not in caches:\n            caches[args] = func(*args)\n\n        return caches[args]\n    return wrap\n\n\n@cache\ndef fib_cache(n):\n    assert n > 0, 'invalid n'\n    if n < 3:\n        return 1\n    else:\n        return fib_cache(n - 1) + fib_cache(n - 2)\n\n这样递归中就不会重复调用，效率也会提高很多。具体可以看这里，从执行时间很容易看出做了缓存之后速度有了很大的提升。装饰器还可以用来扩展外部接口函数(通常你不能修改它)的功能，或者用来调试函数。其实，装饰器可以用于各种各样的场合！\npython本身提供了一些装饰器：property,staticmethod，等等。另外，Django使用装饰器去管理缓存和权限。\n参考\n计算斐波纳契数，分析算法复杂度  How can I make a chain of function decorators in Python?  Python装饰器与面向切面编程  how to use args and kwargs in python?  Fibonacci, recursion and decorators\n\n                ", "mainLikeNum": ["5 "], "mainBookmarkNum": "49"}