{"title": "leetcode-120-Triangle-等腰三角形 - 个人文章 ", "index": "python", "content": "题目：\nGiven a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.\n\n示例：\n[\n     [2],\n    [3,4],\n   [6,5,7],\n  [4,1,8,3]\n]\n\nThe minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).\nNote:\nBonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.\n\n题目解析：\n1.此题是等腰三角形，上下之间的关系简化为上下相邻的三个数，index相邻，大小关系是在下方二选一+上方的数值，必然正确。 根据此思路，可以top-bottom,或者bottom-top，由于可以简化，所以动态规划方法。   \n2. 采用bottom-top方法，最后简化为1个值，所以左侧值放置两值中的小值。\n代码：\n\n普通代码，较慢：\nclass Solution_:\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        all_paths=[]\n        cur_path=[triangle[0][0]]\n        # cur_path=[]\n        cur_index=[0,0]\n        self.bfs(all_paths,cur_path,cur_index,triangle)\n        print(all_paths)\n        sums=[sum(elem) for elem in all_paths]\n        return min(sums)\n    def bfs(self,all_paths,cur_path,cur_index,triangle):\n        x_cur=cur_index[0]\n        # cur_row=triangle[x_cur]\n        x_threshold=len(triangle)\n        y_cur=cur_index[1]\n        x_next=x_cur+1\n        y_next=[]\n        if x_next<x_threshold:\n            next_row = triangle[x_cur + 1]\n            y_threshold = len(next_row)\n            # y_next.append(y_cur)\n            # if y_cur-1>=0:\n            y_next.append(y_cur)\n            if y_cur+1<y_threshold:\n                y_next.append(y_cur+1)\n            for elem in y_next:\n                cur_path_pre=cur_path+[triangle[x_next][elem]]\n                self.bfs(all_paths,cur_path_pre,[x_next,elem],triangle)\n        else:\n            all_paths.append(cur_path)\n动态规划，简练：\nclass Solution(object):\n    def minimumTotal(self, triangle):\n        dp=triangle[-1][:]\n        # print(dp)\n        for i in  range(len(triangle)-2,-1,-1):\n            for j in range(i+1):\n                # print(i,j)\n                dp[j]=min(dp[j],dp[j+1])+triangle[i][j]\n                # dp=dp[:i+1]\n        return dp[0]\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}