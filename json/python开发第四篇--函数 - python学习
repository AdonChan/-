{"title": "python开发第四篇--函数 - python学习 ", "index": "python", "content": "名称空间与作用域\n1.变量储存在一个内存空间中  2.当程序运行的时候代码从上到下依次执行，它会将变量与值的关系存储在一个空间中，这个空间叫名称空间,命名空间，全局名称空间  3.当程序遇到函数时，它会将函数名存在内存中，函数体漠不关心  4.当程序执行的时候，内存会临时开辟一个空间，存放函数体里的代码(变量,代码等）  5.函数外面访问不到临时空间的内容，随着函数执行完毕，临时名称空间会被释放掉,向这个临时开辟的空间也叫临时名称空间，也叫局部名称空间\n\npython名称空间分为三种：  1.内置名称空间  2.全局名称空间  3.局部名称空间\n\n按照作用域分为两种：\n\n\n全局作用域\n1.内置名称空间\n2.全局名称空间\n\n\n局部作用域\n1.局部名称空间\n\n\n\n加载顺序  内置名称空间---全局名称空间(当程序执行时)---局部名称空间(函数调用时)\n\n取值顺序  局部名称空间(函数调用时)---全局名称空间(当程序执行时)---内置名称空间  注:取值顺序是单向不可逆的\n  1.取值又叫引用，局部名称空间可以临时像全局名称空间引用，但是无法修改\n  2.取值是从小到大取值LEGB\n      - L=最里层的局部作用域\n      - E=父亲级别的局部作用域\n      - G=全局作用域中的全局名称空间\n      - B=全局作用域中的内置名称空间\n\n\n内置函数globals和locals的方法：\n\n\nglobles\n   globales返回一个字典，字典里的内容是全局名称空间的内容\n\n\nlocals\n   locals返回一个字典，当前位置的所有变量（看locals的位置是否在函数体里还是在全局里）\n\n\n\n\n\n#1.\nprint(globals())\nprint(locals())\n#打印结果：\n{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <_frozen_importlib_external.SourceFileLoader object at 0x004DB4B0>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>, '__file__': 'E:/python/day04/1.py', '__cached__': None}\n{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <_frozen_importlib_external.SourceFileLoader object at 0x004DB4B0>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>, '__file__': 'E:/python/day04/1.py', '__cached__': None}\n\n#2.\ndef func():\n    a = 12\n    b = 20\n    print(locals())\n    print(globals())\nfunc()\n#打印结果：\n{'b': 20, 'a': 12}\n{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <_frozen_importlib_external.SourceFileLoader object at 0x0044B4B0>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>, '__file__': 'E:/python/day04/1.py', '__cached__': None, 'func': <function func at 0x0040B660>}\n\n关键字global和nonlocal的方法：\n\nglobal 1.global可以引用全局变量，并且改变全局变量 2.在局部作用域声明一个全局变量\nnonlocal1.不能操作全局变量2.在局部作用域中，对父级作用域（或者更外层作用域非全局作用域）的变量进行引用和修改，并且引用的哪层，从那层及以下此变量全部发生改变。\n\n\n注:对于可变的数据类型list，dict，set，不用引用global,nonlocal 注：如果默认参数是一个可变的数据类型，那么他在内存中永远是一个。\n#1.第一种情况:\ndef extendList(val,list=[]):\n    list.append(val)\n    return list\nlist1 = extendList(10)\nprint('list1=%s'%list1)  # [10,]\nlist2 = extendList(123,[])\nprint('list2=%s'%list2)  # [123,]\nlist3 = extendList('a')\nprint('list3=%s'%list3)  #[10,'a']\n打印结果为：\nlist1=[10]\nlist2=[123]\nlist3=[10, 'a']\n#2.第二种：\ndef extendList(val,list=[]):\n    list.append(val)\n    return list\nlist1 = extendList(10)\nlist2 = extendList(123,[])\nlist3 = extendList('a')\nprint('list1=%s'%list1)\nprint('list2=%s'%list2)\nprint('list3=%s'%list3)\n打印结果为：\nlist1=[10, 'a']\nlist2=[123]\nlist3=[10, 'a']\n因为：如果默认参数是一个可变的数据类型，那么他在内存中永远是一个。\n1.global实例：\ndef func():\n    global a\n    a = 3\nfunc()\nprint(a)\n#打印结果为：3\ncount = 1\ndef search():\n    global count\n    count = 2\nsearch()\nprint(count)\n#打印结果为2\n2.nonloacl实例：\ndef add_b():\n    b = 42\n    def do_global():\n        b = 10\n        print(b)\n        def dd_nonlocal():\n            nonlocal b\n            b = b + 20\n            print(b)\n        dd_nonlocal()  #30\n        print(b) #30\n    do_global()   #10\n    print(b)\nadd_b()\n#打印结果为：\n10\n30\n30\n42\n函数\n函数的嵌套与调用：\n#函数的嵌套\ndef max2(x,y):\n    m  = x if x>y else y\n    return m\ndef max4(a,b,c,d):\n    res1 = max2(a,b)\n    res2 = max2(res1,c)\n    res3 = max2(res2,d)\n    return res3\n#函数的调用\nmax4(1,2,3,4)\n函数名的本质1.打印函数名\ndef func():\n    print('in func')\nf = func\nprint(f)\n#打印结果为：<function func at 0x0020B660>\n为一块内存地址\n2.函数名可以作为容器类数据的元素\ndef func1():\n    print(111)\ndef func2():\n    print(222)\ndef func3():\n    print(333)\nl1 = [func1, func2, func3]\nfor i in l1:\n    i()\n#打印结果为：\n111\n222\n333\n3.函数名可以作为函数的参数\ndef func1():\n    print(111)\ndef func2(x):\n    print(x)\n    x()\n    print(222)\nfunc2(func1)\n#打印结果为：\n<function func1 at 0x0021B660>\n111\n222\n4.函数名可以作为函数的返回值\ndef func1():\n    return 111\ndef func2(x):  # x = func1\n    print(222)\n    return x\nret = func2(func1)  # func1\nprint(ret())\nprint(ret)\n#打印结果为：\n222\n111\n<function func1 at 0x002BB660>\n\n\n总结：函数名的应用,第一类对象\n  - 函数名打印的出来的是个内存地址，加()号就可以运行\n  - 函数名可以作为容器类型内的元素\n  - 函数名可以作为传递的参数\n  - 函数名可以作为函数的返回值，return把值给函数的执行者\n\n\n闭包函数\n  - 内层函数对外层函数非全局变量的引用，就叫做闭包\n  - 判断是否是闭包：__closure__\n  - 如果python解释器遇到了闭包，他有个机制，这个闭包不会随着函数的结束而释放\n  - 装饰器@语法糖，装饰器放在需要装饰的函数的上边，利用的就是闭包函数\n\n\n装饰器：\n#测试func1函数的执行时间\ndef timmer(f):\n    def inner(*args,**kwargs):\n        start_time = time.time()\n        ret = f(*args,**kwargs)\n        end_time = time.time()\n        print('此函数的执行效率%s' % (end_time - start_time))\n        return ret\n    return inner\n@timmer\ndef func1():\n    time.sleep(0.3)\n    print('非常复杂......')\nfunc1()\n#格式为：\ndef wrapper(f):\n    def inner(*args,**kwargs):\n        \"\"\"被装饰函数执行之前的操作\"\"\"\n        ret = f(*args,**kwargs)\n        \"\"\"被装饰函数执行之后的操作\"\"\"\n        return ret\n    return inner\n# 装饰器 本质就是闭包\n# 装饰器根本作用：在不影响原函数执行的基础上，增加一些额外的功能登录认证，打印日志等等。\n内裤可以用来遮羞，但是到了冬天它没法为我们防风御寒，聪明的人们发明了长裤，有了长裤后宝宝再也不冷了，装饰器就像我们这里说的长裤，在不影响内裤作用的前提下，给我们的身子提供了保暖的功效。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "0"}