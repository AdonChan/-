{"title": "使用 Python 一步步搭建自己的区块链 - 个人文章 ", "index": "python,区块链", "content": "\n你是否会和我一样，对加密数字货币底层的区块链技术非常感兴趣，特别想了解他们的运行机制。\n但是学习区块链技术并非一帆风顺，我看多了大量的视频教程还有各种课程，最终的感觉就是真正可用的实战课程太少。\n我喜欢在实践中学习，尤其喜欢一代码为基础去了解整个工作机制。如果你我一样喜欢这种学习方式，当你学完本教程时，你将会知道区块链技术是如何工作的。\n写在开始之前\n记住，区块链是一个 不可变的、有序的 被称为块的记录链。它们可以包含交易、文件或任何您喜欢的数据。但重要的是，他们用哈希 一起被链接在一起。\n如果你不熟悉哈希, 这里是一个解释.\n该指南的目的是什么? 你可以舒服地阅读和编写基础的Python，因为我们将通过HTTP与区块链进行讨论，所以你也要了解HTTP的工作原理。\n我需要准备什么?  确定安装了 Python 3.6+ (还有 pip) ，你还需要安装 Flask、 Requests 库:\n`pip install Flask==0.12.2 requests==2.18.4`\n\n对了, 你还需要一个支持HTTP的客户端, 比如 Postman 或者 cURL，其他也可以。源码在哪儿?   可以点击这里\nStep 1: 创建一个区块链\n打开你最喜欢的文本编辑器或者IDE, 我个人比较喜欢 PyCharm. 新建一个名为blockchain.py的文件。 我们将只用这一个文件就可以。但是如果你还是不太清楚, 你也可以参考 源码.\n描述区块链\n我们要创建一个 Blockchain 类 ，他的构造函数创建了一个初始化的空列表（要存储我们的区块链），并且另一个存储交易。下面是我们这个类的实例:\nblockchain.py\nclass Blockchain(object):\n    def __init__(self):\n        self.chain = []\n        self.current_transactions = []\n        \n    def new_block(self):\n        # Creates a new Block and adds it to the chain\n        pass\n    \n    def new_transaction(self):\n        # Adds a new transaction to the list of transactions\n        pass\n    \n    @staticmethod\n    def hash(block):\n        # Hashes a Block\n        pass\n\n    @property\n    def last_block(self):\n        # Returns the last Block in the chain\n        pass\n我们的 Blockchain 类负责管理链式数据，它会存储交易并且还有添加新的区块到链式数据的Method。让我们开始扩充更多Method\n块是什么样的 ?\n每个块都有一个  索引，一个 时间戳（Unix时间戳），一个事务列表， 一个 校验(稍后详述) 和 前一个块的散列 。\n下面是一个Block的例子 ：\nblockchain.py\nblock = {\n    'index': 1,\n    'timestamp': 1506057125.900785,\n    'transactions': [\n        {\n            'sender': \"8527147fe1f5426f9dd545de4b27ee00\",\n            'recipient': \"a77f5cdfa2934df3954a5c7c7da5df1f\",\n            'amount': 5,\n        }\n    ],\n    'proof': 324984774000,\n    'previous_hash': \"2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\"\n}\n在这一点上，一个 区块链 的概念应该是明显的 - 每个新块都包含在其内的前一个块的 散列 。 这是至关重要的，因为这是 区块链 不可改变的原因：如果攻击者损坏 区块链 中较早的块，则所有后续块将包含不正确的哈希值。\n这有道理吗？ 如果你还没有想通，花点时间仔细思考一下 - 这是区块链背后的核心理念\n添加交易到区块\n我们将需要一个添加交易到区块的方式。我们的 new_transaction()方法的责任就是这个， 并且它非常的简单:\nblockchain.py\nclass Blockchain(object):\n    ...\n    \n    def new_transaction(self, sender, recipient, amount):\n        \"\"\"\n        Creates a new transaction to go into the next mined Block\n        :param sender: <str> Address of the Sender\n        :param recipient: <str> Address of the Recipient\n        :param amount: <int> Amount\n        :return: <int> The index of the Block that will hold this transaction\n        \"\"\"\n\n        self.current_transactions.append({\n            'sender': sender,\n            'recipient': recipient,\n            'amount': amount,\n        })\n\n        return self.last_block['index'] + 1\n new_transaction() 方法添加了交易到列表，它返回了交易将被添加到的区块的索引---讲开采下一个这对稍后对提交交易的用户有用。\n创建新的区块\n当我们的  Blockchain  被实例化后，我们需要将 创世 区块（一个没有前导区块的区块）添加进去进去。我们还需要向我们的起源块添加一个 证明，这是挖矿的结果(或工作证明)。 我们稍后会详细讨论挖矿。\n除了在构造函数中创建 创世 区块外，我们还会补全  new_block() 、  new_transaction()  和 hash() 函数：\nblockchain.py\nimport hashlib\nimport json\nfrom time import time\n\n\nclass Blockchain(object):\n    def __init__(self):\n        self.current_transactions = []\n        self.chain = []\n\n        # 创建创世区块\n        self.new_block(previous_hash=1, proof=100)\n\n    def new_block(self, proof, previous_hash=None):\n        \"\"\"\n        创建一个新的区块到区块链中\n        :param proof: <int> 由工作证明算法生成的证明\n        :param previous_hash: (Optional) <str> 前一个区块的 hash 值\n        :return: <dict> 新区块\n        \"\"\"\n\n        block = {\n            'index': len(self.chain) + 1,\n            'timestamp': time(),\n            'transactions': self.current_transactions,\n            'proof': proof,\n            'previous_hash': previous_hash or self.hash(self.chain[-1]),\n        }\n\n        # 重置当前交易记录\n        self.current_transactions = []\n\n        self.chain.append(block)\n        return block\n\n    def new_transaction(self, sender, recipient, amount):\n        \"\"\"\n        创建一笔新的交易到下一个被挖掘的区块中\n        :param sender: <str> 发送人的地址\n        :param recipient: <str> 接收人的地址\n        :param amount: <int> 金额\n        :return: <int> 持有本次交易的区块索引\n        \"\"\"\n        self.current_transactions.append({\n            'sender': sender,\n            'recipient': recipient,\n            'amount': amount,\n        })\n\n        return self.last_block['index'] + 1\n\n    @property\n    def last_block(self):\n        return self.chain[-1]\n\n    @staticmethod\n    def hash(block):\n        \"\"\"\n        给一个区块生成 SHA-256 值\n        :param block: <dict> Block\n        :return: <str>\n        \"\"\"\n\n        # 我们必须确保这个字典（区块）是经过排序的，否则我们将会得到不一致的散列\n        block_string = json.dumps(block, sort_keys=True).encode()\n        return hashlib.sha256(block_string).hexdigest()\n上面的代码应该是直白的 --- 为了让代码清晰，我添加了一些注释和文档说明。 我们差不多完成了我们的区块链。 但在这个时候你一定很疑惑新的块是怎么被创建、锻造或挖掘的。\n工作量证明算法\n使用工作量证明（PoW）算法，来证明是如何在区块链上创建或挖掘新的区块。PoW 的目标是计算出一个符合特定条件的数字，这个数字对于所有人而言必须在计算上非常困难，但易于验证。这是工作证明背后的核心思想。\n我们将看到一个简单的例子帮助你理解：\n假设一个整数 x 乘以另一个整数 y 的积的 Hash 值必须以 0 结尾，即 hash(x * y) = ac23dc...0。设 x = 5，求 y ？用 Python 实现：\nfrom hashlib import sha256\nx = 5\ny = 0  # We don't know what y should be yet...\nwhile sha256(f'{x*y}'.encode()).hexdigest()[-1] != \"0\":\n    y += 1\nprint(f'The solution is y = {y}')\n结果是： y = 21。因为，生成的 Hash 值结尾必须为 0。\nhash(5 * 21) = 1253e9373e...5e3600155e860\n在比特币中，工作量证明算法被称为 Hashcash ，它和上面的问题很相似，只不过计算难度非常大。这就是矿工们为了争夺创建区块的权利而争相计算的问题。 通常，计算难度与目标字符串需要满足的特定字符的数量成正比，矿工算出结果后，就会获得一定数量的比特币奖励（通过交易）。\n验证结果，当然非常容易。\n实现工作量证明\n让我们来实现一个相似 PoW 算法。规则类似上面的例子：\n找到一个数字 P ，使得它与前一个区块的 proof 拼接成的字符串的 Hash 值以 4 个零开头。\nblockchain.py\nimport hashlib\nimport json\n\nfrom time import time\nfrom uuid import uuid4\n\n\nclass Blockchain(object):\n    ...\n        \n    def proof_of_work(self, last_proof):\n        \"\"\"\n        Simple Proof of Work Algorithm:\n         - Find a number p' such that hash(pp') contains leading 4 zeroes, where p is the previous p'\n         - p is the previous proof, and p' is the new proof\n        :param last_proof: <int>\n        :return: <int>\n        \"\"\"\n\n        proof = 0\n        while self.valid_proof(last_proof, proof) is False:\n            proof += 1\n\n        return proof\n\n    @staticmethod\n    def valid_proof(last_proof, proof):\n        \"\"\"\n        Validates the Proof: Does hash(last_proof, proof) contain 4 leading zeroes?\n        :param last_proof: <int> Previous Proof\n        :param proof: <int> Current Proof\n        :return: <bool> True if correct, False if not.\n        \"\"\"\n\n        guess = f'{last_proof}{proof}'.encode()\n        guess_hash = hashlib.sha256(guess).hexdigest()\n        return guess_hash[:4] == \"0000\"\n衡量算法复杂度的办法是修改零开头的个数。使用 4 个来用于演示，你会发现多一个零都会大大增加计算出结果所需的时间。\n现在 Blockchain 类基本已经完成了，接下来使用 HTTP requests 来进行交互。\nStep 2: Blockchain 作为 API 接口\n我们将使用 Python Flask 框架，这是一个轻量 Web 应用框架，它方便将网络请求映射到 Python 函数，现在我们来让 Blockchain 运行在基于 Flask web 上。\n我们将创建三个接口：\n\n\n/transactions/new 创建一个交易并添加到区块\n\n/mine 告诉服务器去挖掘新的区块\n\n/chain 返回整个区块链\n\n创建节点\n我们的“Flask 服务器”将扮演区块链网络中的一个节点。我们先添加一些框架代码：\nblockchain.py\nimport hashlib\nimport json\nfrom textwrap import dedent\nfrom time import time\nfrom uuid import uuid4\n\nfrom flask import Flask\n\n\nclass Blockchain(object):\n    ...\n\n\n# Instantiate our Node\napp = Flask(__name__)\n\n# Generate a globally unique address for this node\nnode_identifier = str(uuid4()).replace('-', '')\n\n# Instantiate the Blockchain\nblockchain = Blockchain()\n\n\n@app.route('/mine', methods=['GET'])\ndef mine():\n    return \"We'll mine a new Block\"\n  \n@app.route('/transactions/new', methods=['POST'])\ndef new_transaction():\n    return \"We'll add a new transaction\"\n\n@app.route('/chain', methods=['GET'])\ndef full_chain():\n    response = {\n        'chain': blockchain.chain,\n        'length': len(blockchain.chain),\n    }\n    return jsonify(response), 200\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000)\n简单的说明一下以上代码：\n\n第 15 行：实例化节点。阅读更多关于 Flask 内容。\n第 18 行：为节点创建一个随机的名称。.\n第 21 行：实例化 Blockchain 类。\n第 24--26 行：创建 /mine 接口，GET 方式请求。 \n第 28--30 行：创建 /transactions/new 接口，POST 方式请求，可以给接口发送交易数据。\n第 32--38 行：创建 /chain 接口，返回整个区块链。\n第 40--41 行：服务器运行端口 5000 。\n\n发送交易\n发送到节点的交易数据结构如下：\n{\n \"sender\": \"my address\",\n \"recipient\": \"someone else's address\",\n \"amount\": 5\n}\n因为我们已经有了添加交易的方法，所以基于接口来添加交易就很简单了。让我们为添加事务写函数:\nblockchain.py\nimport hashlib\nimport json\nfrom textwrap import dedent\nfrom time import time\nfrom uuid import uuid4\n\nfrom flask import Flask, jsonify, request\n\n...\n\n@app.route('/transactions/new', methods=['POST'])\ndef new_transaction():\n    values = request.get_json()\n\n    # Check that the required fields are in the POST'ed data\n    required = ['sender', 'recipient', 'amount']\n    if not all(k in values for k in required):\n        return 'Missing values', 400\n\n    # Create a new Transaction\n    index = blockchain.new_transaction(values['sender'], values['recipient'], values['amount'])\n\n    response = {'message': f'Transaction will be added to Block {index}'}\n    return jsonify(response), 201\n挖矿\n挖矿正是神奇所在，它很简单，做了一下三件事：\n\n计算工作量证明 PoW\n通过新增一个交易授予矿工（自己）一个币\n构造新区块并将其添加到链中\n\nblockchain.py\nimport hashlib\nimport json\n\nfrom time import time\nfrom uuid import uuid4\n\nfrom flask import Flask, jsonify, request\n\n...\n\n@app.route('/mine', methods=['GET'])\ndef mine():\n    # We run the proof of work algorithm to get the next proof...\n    last_block = blockchain.last_block\n    last_proof = last_block['proof']\n    proof = blockchain.proof_of_work(last_proof)\n\n    # We must receive a reward for finding the proof.\n    # The sender is \"0\" to signify that this node has mined a new coin.\n    blockchain.new_transaction(\n        sender=\"0\",\n        recipient=node_identifier,\n        amount=1,\n    )\n\n    # Forge the new Block by adding it to the chain\n    previous_hash = blockchain.hash(last_block)\n    block = blockchain.new_block(proof, previous_hash)\n\n    response = {\n        'message': \"New Block Forged\",\n        'index': block['index'],\n        'transactions': block['transactions'],\n        'proof': block['proof'],\n        'previous_hash': block['previous_hash'],\n    }\n    return jsonify(response), 200\n注意交易的接收者是我们自己的服务器节点，我们做的大部分工作都只是围绕 Blockchain 类方法进行交互。到此，我们的区块链就算完成了，我们来实际运行下.\nStep 3: 运行区块链\n你可以使用 cURL 或 Postman 去和 API 进行交互\n启动 Server：\n$ python blockchain.py\n* Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)\n让我们通过请求 http://localhost:5000/mine （ GET ）来进行挖矿：\n\n用 Postman 发起一个 GET 请求.\n创建一个交易请求，请求 http://localhost:5000/transactions/new （POST）,如图\n\n如果不是使用 Postman，则用一下的 cURL 语句也是一样的：\n$ curl -X POST -H \"Content-Type: application/json\" -d '{\n \"sender\": \"d4ee26eee15148ee92c6cd394edd974e\",\n \"recipient\": \"someone-other-address\",\n \"amount\": 5\n}' \"http://localhost:5000/transactions/new\"\n在挖了两次矿之后，就有 3 个块了，通过请求 http://localhost:5000/chain 可以得到所有的块信息\n{\n  \"chain\": [\n    {\n      \"index\": 1,\n      \"previous_hash\": 1,\n      \"proof\": 100,\n      \"timestamp\": 1506280650.770839,\n      \"transactions\": []\n    },\n    {\n      \"index\": 2,\n      \"previous_hash\": \"c099bc...bfb7\",\n      \"proof\": 35293,\n      \"timestamp\": 1506280664.717925,\n      \"transactions\": [\n        {\n          \"amount\": 1,\n          \"recipient\": \"8bbcb347e0634905b0cac7955bae152b\",\n          \"sender\": \"0\"\n        }\n      ]\n    },\n    {\n      \"index\": 3,\n      \"previous_hash\": \"eff91a...10f2\",\n      \"proof\": 35089,\n      \"timestamp\": 1506280666.1086972,\n      \"transactions\": [\n        {\n          \"amount\": 1,\n          \"recipient\": \"8bbcb347e0634905b0cac7955bae152b\",\n          \"sender\": \"0\"\n        }\n      ]\n    }\n  ],\n  \"length\": 3\n}\nStep 4: 一致性（共识）\n我们已经有了一个基本的区块链可以接受交易和挖矿。但是区块链系统应该是分布式的。既然是分布式的，那么我们究竟拿什么保证所有节点有同样的链呢？这就是一致性问题，我们要想在网络上有多个节点，就必须实现一个一致性的算法\n注册节点\n在实现一致性算法之前，我们需要找到一种方式让一个节点知道它相邻的节点。每个节点都需要保存一份包含网络中其它节点的记录。因此让我们新增几个接口：\n\n\n/nodes/register 接收 URL 形式的新节点列表.\n\n/nodes/resolve 执行一致性算法，解决任何冲突，确保节点拥有正确的链.\n\n我们修改下 Blockchain 的 init 函数并提供一个注册节点方法：\nblockchain.py\n...\nfrom urllib.parse import urlparse\n...\n\n\nclass Blockchain(object):\n    def __init__(self):\n        ...\n        self.nodes = set()\n        ...\n\n    def register_node(self, address):\n        \"\"\"\n        Add a new node to the list of nodes\n        :param address: <str> Address of node. Eg. 'http://192.168.0.5:5000'\n        :return: None\n        \"\"\"\n\n        parsed_url = urlparse(address)\n        self.nodes.add(parsed_url.netloc)\n我们用 set 来储存节点，这是一种避免重复添加节点的简单方法.\n实现共识算法\n就像先前讲的那样，当一个节点与另一个节点有不同的链时，就会产生冲突。 为了解决这个问题，我们将制定最长的有效链条是最权威的规则。换句话说就是：在这个网络里最长的链就是最权威的。 我们将使用这个算法，在网络中的节点之间达成共识。\nblockchain.py\n...\nimport requests\n\n\nclass Blockchain(object)\n    ...\n    \n    def valid_chain(self, chain):\n        \"\"\"\n        Determine if a given blockchain is valid\n        :param chain: <list> A blockchain\n        :return: <bool> True if valid, False if not\n        \"\"\"\n\n        last_block = chain[0]\n        current_index = 1\n\n        while current_index < len(chain):\n            block = chain[current_index]\n            print(f'{last_block}')\n            print(f'{block}')\n            print(\"\\n-----------\\n\")\n            # Check that the hash of the block is correct\n            if block['previous_hash'] != self.hash(last_block):\n                return False\n\n            # Check that the Proof of Work is correct\n            if not self.valid_proof(last_block['proof'], block['proof']):\n                return False\n\n            last_block = block\n            current_index += 1\n\n        return True\n\n    def resolve_conflicts(self):\n        \"\"\"\n        This is our Consensus Algorithm, it resolves conflicts\n        by replacing our chain with the longest one in the network.\n        :return: <bool> True if our chain was replaced, False if not\n        \"\"\"\n\n        neighbours = self.nodes\n        new_chain = None\n\n        # We're only looking for chains longer than ours\n        max_length = len(self.chain)\n\n        # Grab and verify the chains from all the nodes in our network\n        for node in neighbours:\n            response = requests.get(f'http://{node}/chain')\n\n            if response.status_code == 200:\n                length = response.json()['length']\n                chain = response.json()['chain']\n\n                # Check if the length is longer and the chain is valid\n                if length > max_length and self.valid_chain(chain):\n                    max_length = length\n                    new_chain = chain\n\n        # Replace our chain if we discovered a new, valid chain longer than ours\n        if new_chain:\n            self.chain = new_chain\n            return True\n\n        return False\n第一个方法 valid_chain() 负责检查一个链是否有效，方法是遍历每个块并验证散列和证明。\nresolve_conflicts() 是一个遍历我们所有邻居节点的方法，下载它们的链并使用上面的方法验证它们。 如果找到一个长度大于我们的有效链条，我们就取代我们的链条。\n我们将两个端点注册到我们的API中，一个用于添加相邻节点，另一个用于解决冲突：\nblockchain.py\n@app.route('/nodes/register', methods=['POST'])\ndef register_nodes():\n    values = request.get_json()\n\n    nodes = values.get('nodes')\n    if nodes is None:\n        return \"Error: Please supply a valid list of nodes\", 400\n\n    for node in nodes:\n        blockchain.register_node(node)\n\n    response = {\n        'message': 'New nodes have been added',\n        'total_nodes': list(blockchain.nodes),\n    }\n    return jsonify(response), 201\n\n\n@app.route('/nodes/resolve', methods=['GET'])\ndef consensus():\n    replaced = blockchain.resolve_conflicts()\n\n    if replaced:\n        response = {\n            'message': 'Our chain was replaced',\n            'new_chain': blockchain.chain\n        }\n    else:\n        response = {\n            'message': 'Our chain is authoritative',\n            'chain': blockchain.chain\n        }\n\n    return jsonify(response), 200\n在这一点上，如果你喜欢，你可以使用一台不同的机器，并在你的网络上启动不同的节点。 或者使用同一台机器上的不同端口启动进程。 我在我的机器上，不同的端口上创建了另一个节点，并将其注册到当前节点。 因此，我有两个节点：http://localhost:5000 和 http://localhost:5001。 注册一个新节点：\n\n然后我在节点 2 上挖掘了一些新的块，以确保链条更长。 之后，我在节点1上调用 GET /nodes/resolve，其中链由一致性算法取代：\n\n这是一个包，去找一些朋友一起，以帮助测试你的区块链。\n我希望本文能激励你创造更多新东西。我之所以对数字货币入迷，是因为我相信区块链会很快改变我们看待事物的方式，包括经济、政府、档案管理等。\n更新：我计划在接下来的第2部分中继续讨论区块链交易验证机制，并讨论一些可以让区块链进行生产的方法。\nPythonCaff 争做高品质的 Python 知识社区 https://pythoncaff.com/topics/82\n\n\n                ", "mainLikeNum": ["34 "], "mainBookmarkNum": "61"}