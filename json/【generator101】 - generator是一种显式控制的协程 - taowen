{"title": "【generator101】 - generator是一种显式控制的协程 - taowen ", "index": "coroutine,python", "content": "Python官方的实现里，协程只有generator这一招。协程其实就是一个可中途中断，由外部来控制执行进程的函数。除了官方的generator，还有很多第三方的实现可以选择。常见的第三方选择有：\n\n\nGreenlet，基于Python的常规版本（CPython）的C扩展实现\nStackless Python，是一个修改版本的Python解释器，支持tasklet api\nPypy，是一个修改版本的Python解释器，支持continulet api。它还基于此实现了模拟Greenlet和Stackless的上层api。\n\n这些第三方的选择的共同特点是协程的都是隐式的。比如，使用基于Greenlet的gevent，调用http api的时候，可能代码写起来是这样的\n\nurllib2.urlopen('http://www.google.com')\n\n\n表面上看上去就是一个普通的函数调用，但是内部可能是\n\nurlopen => http call => tcp socket open => create socket, register fd on event loop\n\n\n最终在最内层，把当前的协程的控制权交出去了，让event loop去回调当前的协程。也就是说urlopen这个函数调用可能导致当前执行的协程发生变化，而作为调用方可能根本不知情，除非你了解urlopen内层的所有实现，这就叫隐式的。\n反观generator，只要当前的语句没有关键字“yield”，你就可以非常放心的认为当前这句话不会跳出当前协程，而会连续地执行下去。这个是一个优点，可以让代码变得更好理解，更不容易出因为执行顺序不同修改共享状态造成bug。但也是一个缺点，传统的没有yield的代码是无法“自动”地“魔法般”地享受一些一步框架可能带来的好处。比如说：\n\ndef process():\n    for i in sub_process():\n        yield i\n\ndef sub_process():\n    yield 1\n    yield 2\n    yield 3\n\nprint(list(process()))\n\n\nprocess不会因为调用了sub_process()，而sub_process()内又有yield就会自动交出当前协程的执行权，不会的。process如果想要交出执行权，必须自己再次yield。这就是显示控制和隐式控制的区别。本文讨论的协程就是generator这一种，后面会逐渐展开到如何利用这种显示控制的协程来解决I/O阻塞和流程阻塞的logic locality问题。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}