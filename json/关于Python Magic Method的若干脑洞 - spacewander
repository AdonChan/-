{"title": "关于Python Magic Method的若干脑洞 - spacewander ", "index": "python", "content": "有一天闲着无聊的时候，脑子里突然冒出一个Magic Method的有趣用法，可以用__getattr__来实现Python版的method_missing。顺着这个脑洞想下去，我发现Python的Magic Method确实有很多妙用之处。故在此记下几种有趣（也可能有用的）Magic Method技巧，希望可以抛砖引玉，打开诸位读者的脑洞，想出更加奇妙的用法。\n如果对Magic Method的了解仅仅停留在知道这个术语和若干个常用方法上（如__lt__，__str__，__len__），可以阅读下这份教程，看看Magic Method可以用来做些什么。\nPython method_missing\n先从最初的脑洞开始吧。曾几何时，Ruby社区的人总是夸耀Ruby的强大的元编程能力，其中method_missing更是不可或缺的特性。通过调用BaseObject上的method_missing，Ruby可以实现在调用不存在的属性时进行拦截，并动态生成对应的属性。\nRuby例子\n# 来自于Ruby文档: http://ruby-doc.org/core-2.2.0/BasicObject.html#method-i-method_missing\nclass Roman\n  def roman_to_int(str)\n    # ...\n  end\n  def method_missing(methId)\n    str = methId.id2name\n    roman_to_int(str)\n  end\nend\n\nr = Roman.new\nr.iv      #=> 4\nr.xxiii   #=> 23\nr.mm      #=> 2000\nmethod_missing的应用是如此地广泛，以至于只要是成规模的Ruby库，多多少少都会用到它。像是ActiveRecord就是靠这一特性去动态生成关联属性。\n其实Python一早就内置了这一功能。Python有一个Magic Method叫__getattr__，它会在找不到属性的时候调用，正好跟Ruby的method_missing是一样的。我们可以这样动态添加方法：\nclass MyClass(object):\n    def __getattr__(self, name):\n        \"\"\"called only method missing\"\"\"\n        if name == 'missed_method':\n            setattr(self, name, lambda : True)\n            return lambda : True\n\nmyClass = MyClass()\nprint(dir(myClass))\nprint(myClass.missed_method())\nprint(dir(myClass))\n于是乎，前面的Ruby例子可以改写成下面的Python版本：\nclass Roman(object):\n    roman_int_map = {\n            \"i\": 1, \"v\": 5, \"x\": 10, \"l\": 50,\n            \"c\":100, \"d\": 500, \"m\": 1000\n    }\n\n    def roman_to_int(self, s):\n        decimal = 0\n        for i in range(len(s), 0, -1):\n            if (i == len(s) or\n                    self.roman_int_map[s[i-1]] >= self.roman_int_map[s[i]]):\n                decimal += self.roman_int_map[s[i-1]]\n            else:\n                decimal -= self.roman_int_map[s[i-1]]\n        return decimal\n\n    def __getattr__(self, s):\n        return self.roman_to_int(s)\n\nr = Roman()\nprint(r.iv)\nr.iv #=> 4\nr.xxiii #=> 23\nr.mm #=> 2000\n很有可能你会觉得这个例子没有什么意义，你是对的！其实它就是把方法名当做一个罗马数字字符串，传入roman_to_int而已。不过正如递归不仅仅能用来计算斐波那契数列，__getattr__的这一特技实际上还是挺有用的。你可以用它来进行延时计算，或者方法分派，抑或像基于Ruby的DSL一样动态地合成方法。这里有个用__getattr__实现延时加载的例子。\n函数对象\n在C++里面，你可以重载掉operator ()，这样就可以像调用函数一样去调用一个类的实例。这样做的目的在于，把调用过程中的状态存储起来，借此实现带状态的调用。这种实例我们称之为函数对象。\n在Python里面也有同样的机制。如果想要存储的状态只有一种，你需要的是一个生成器。通过send来设置存储的状态，通过next来获取调用的结果。不过如果你需要存储多个不同的状态，生成器就不够用了，非得定义一个函数对象不可。\nPython里面可以重载__call__来实现operator ()的功能。下面的例子里面，就是一个存储有两个状态value和called_times的函数对象：\nclass CallableCounter(object):\n    def __init__(self, initial_value=0, start_times=0):\n        self.value = initial_value\n        self.called_times = start_times\n\n    def __call__(self):\n        print(\"Call the object and do something with value %d\" % self.value)\n        self.value += 1\n        self.called_times += 1\n\n    def reset(self):\n        self.called_times = 0\n\n\ncc = CallableCounter(initial_value=5)\nfor i in range(10):\n    cc()\nprint(cc.called_times)\ncc.reset()\n伪造一个Dict\n最后请允许我奉上一个大脑洞，伪造一个Dict类。（这个可就没有什么实用价值了）\n首先确定下把数据存在哪里。我打算把数据存储在类的__dict__属性中。由于__dict__属性的值就是一个Dict实例，我只需把调用在FakeDict上的方法直接转发给对应的__dict__的方法。代价是只能接受字符串类型的键。\nclass FakeDict:\n    def __init__(self, iterable=None, **kwarg):\n        if iterable is not None:\n            if isinstance(iterable, dict):\n                self.__dict__ = iterable\n            else:\n                for i in iterable:\n                    self[i] = None\n        self.__dict__.update(kwarg)\n\n    def __len__(self):\n        \"\"\"len(self)\"\"\"\n        return len(self.__dict__)\n\n    def __str__(self):\n        \"\"\"it looks like a dict\"\"\"\n        return self.__dict__.__str__()\n    __repr__ = __str__\n接下来开始做点实事。Dict最基本的功能是给一个键设置值和返回一个键对应的值。通过定义__setitem__和__getitem__方法，我们可以重载掉[]=和[]。\n    def __setitem__(self, k, v):\n        \"\"\"self[k] = v\"\"\"\n        self.__dict__[k] = v\n\n    def __getitem__(self, k):\n        \"\"\"self[k]\"\"\"\n        return self.__dict__[k]\n别忘了del方法：\n    def __delitem__(self, k):\n        \"\"\"del self[k]\"\"\"\n        del self.__dict__[k]\nDict的一个常用用途是允许我们迭代里面所有的键。这个可以通过定义__iter__实现。\n    def __iter__(self):\n        \"\"\"it iterates like a dict\"\"\"\n        return iter(self.__dict__)\nDict的另一个常用用途是允许我们查找一个键是否存在。其实只要定义了__iter__，Python就能判断if x in y，不过这个过程中会遍历对象的所有值。对于真正的Dict而言，肯定不会用这种O(n)的判断方式。定义了__contains__之后，Python会优先使用它来判断if x in y。\n    def __contains__(self, k):\n        \"\"\"key in self\"\"\"\n        return k in self.__dict__\n接下要实现==的重载，不但要让FakeDict和FakeDict之间可以进行比较，而且要让FakeDict和正牌的Dict也能进行比较。\n    def __eq__(self, other):\n        \"\"\"\n        implement self == other FakeDict,\n        also implement self == other dict\n        \"\"\"\n        if isinstance(other, dict):\n            return self.__dict__ == other\n        return self.__dict__ == other.__dict__\n要是继续实现了__subclass__和__class__，那么我们的伪Dict就更完备了。这个就交给感兴趣的读者自己动手了。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "10"}