{"title": "Sanic教程：配置 - Sanic-For-Pythoneer ", "index": "python", "content": "配置\n对于一个项目来说，配置是一个很严肃的问题，比如说：在开发环境和生产环境中，配置是不同的，那么一个项目该如何自由地在不同的配置环境中进行切换呢，思考下，然后带着答案或者疑问往下阅读。\n单一配置\n撸起袖子，开始吧，新建文件夹 demo2 ，内部建立这样的文件结构：\ndemo02\n├── config\n│   ├── __init__.py\n│   └── config.py\n└── run.py\n其中 run.py 内容如下：\n#!/usr/bin/env python\nfrom sanic import Sanic\nfrom sanic.response import text\n\napp = Sanic()\n\n\n@app.route(\"/\")\nasync def test(request):\n    return text('Hello World!')\n\n\nif __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=8000, debug=True)\n代码示例中开启了 debug 模式，假设我们需要通过 config.py 配置文件来实现控制服务的 debug 模式开启与否，那该怎么实现呢。\n在 config.py 中添加一行：DEBUG=True ，然后 run.py 内容改为：\n#!/usr/bin/env python\nfrom sanic import Sanic\nfrom sanic.response import text\nfrom config import DEBUG\n\napp = Sanic()\n\n\n@app.route(\"/\")\nasync def test(request):\n    return text('Hello World!')\n\n\nif __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=8000, debug=DEBUG)\n表面上看，功能确实实现了，但这实际上却不是很好的做法，若部署在生产环境中，难道还要特地再将 debug 改为 False 么，这显然很浪费时间，如果需要改变的参数有很多，那就很难维护了。\n多配置\n那么，正确的做法应该是怎么样的呢？\n我们应当依据不同的环境来编写各自对应的环境，举个例子，比如生产环境就对应pro_config，开发环境就对应dev_config.py等等\n具体该怎么实施？首先在文件夹 demo2 ，内部建立这样的文件结构：\ndemo02\n├── config\n│   ├── __init__.py\n│   ├── config.py\n│   ├── dev_config.py\n│   └── pro_config.py\n└── run.py\n\n然后使用类继承的方式使这三个配置文件联系起来，比如在 config.py 中就只放公有配置，如：\n#!/usr/bin/env python\nimport os\n\n\nclass Config():\n    \"\"\"\n    Basic config for demo02\n    \"\"\"\n    # Application config\n    TIMEZONE = 'Asia/Shanghai'\n    BASE_DIR = os.path.dirname(os.path.dirname(__file__))\n而在 pro_config.py或dev_config.py 中就可以自由地编写不同的配置了：\n# dev_config\n#!/usr/bin/env python\nfrom .config import Config\n\n\nclass DevConfig(Config):\n    \"\"\"\n    Dev config for demo02\n    \"\"\"\n\n    # Application config\n    DEBUG = True\n\n# pro_config\n#!/usr/bin/env python\nfrom .config import Config\n\n\nclass ProConfig(Config):\n    \"\"\"\n    Pro config for demo02\n    \"\"\"\n\n    # Application config\n    DEBUG = False\n配置文件还需要根据系统环境变量的设置进行不同配置环境的切换，比如设置 MODE 系统环境变量，这里从系统环境变量得到配置也是个不错的方法，一般说利用gunicorn配置worker数目之类的，都可以使用这种方案。\n然后可以根据其不同的值切换到不同的配置文件，因此在 __init__.py 中需要这么写：\n#!/usr/bin/env python\nimport os\n\n\ndef load_config():\n    \"\"\"\n    Load a config class\n    \"\"\"\n\n    mode = os.environ.get('MODE', 'DEV')\n    try:\n        if mode == 'PRO':\n            from .pro_config import ProConfig\n            return ProConfig\n        elif mode == 'DEV':\n            from .dev_config import DevConfig\n            return DevConfig\n        else:\n            from .dev_config import DevConfig\n            return DevConfig\n    except ImportError:\n        from .config import Config\n        return Config\n\n\nCONFIG = load_config()\n默认 MODE 设置为 DEV，在 run.py 文件中就可以这么调用：\n#!/usr/bin/env python\nfrom sanic import Sanic\nfrom sanic.response import text\nfrom config import CONFIG\n\napp = Sanic()\napp.config.from_object(CONFIG)\n\n@app.route(\"/\")\nasync def test(request):\n    return text('Hello World!')\n\n\nif __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=8000, debug=app.config['DEBUG'])\n而在生产环境的服务器上，直接通过设置系统变量就可以达到配置修改的目的了，如下：\n# 通过设置MODE的值进行配置文件的选择\nexport MODE=PRO \n若是利用 supervisor 来启动服务，可通过添加environment = MODE=\"PRO\" 来设置环境变量，是不是很方便呢。\n说明\n其实我编写这种微服务，配置更新是很正常且很频繁的需求，这样的话我就必须要求我的代码可以实现热更新，也就是可以迅速的修改配置，且迅速的生效，目前我使用的是ZooKeeper来实现这个需求，有兴趣的朋友可以详细了解，或许你也是用这个方案呢？\n如果你有更好的方案，不妨告知一二。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}