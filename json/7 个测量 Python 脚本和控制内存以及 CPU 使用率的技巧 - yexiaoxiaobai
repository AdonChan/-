{"title": "7 个测量 Python 脚本和控制内存以及 CPU 使用率的技巧 - yexiaoxiaobai ", "index": "memory_profiler,line_profiler,cProfile,timeit,python", "content": "\n  本文的作者是 Marina Mele，原文地址是 7 tips to Time Python scripts and control Memory & CPU usage\n\n\n当运行一个复杂的 Python 程序，它需要很长时间来执行。你或许想提升它的执行时间。但如何做？\n\n首先，你需要工具来查明你代码的瓶颈，比如，那部分执行花费的时间长。用这个方法，你可以首先专注于提升这部分的速度。\n\n而且，你也应该控制内存和 CPU 使用率，因为它可以为你指出的代码可以改进的新的部分。\n\n所以，在本文中，我将对 7 个不同的 Python 工具发表意见，给你一些关于你函数执行时间和内存以及 CPU 使用率的见解。\n\n1. 使用一个装饰器来测量你的函数\n\n测量一个函数最简单的方式就是定义一个装饰器来测量运行该函数的运行时间，并打印该结果：\n\nimport time\nfrom functools import wraps\n\n\ndef fn_timer(function):\n    @wraps(function)\n    def function_timer(*args, **kwargs):\n        t0 = time.time()\n        result = function(*args, **kwargs)\n        t1 = time.time()\n        print (\"Total time running %s: %s seconds\" %\n               (function.func_name, str(t1-t0))\n               )\n        return result\n    return function_timer\n\n\n这时，你已经在你想测量的函数之前添加了装饰器，像：\n\n@fn_timer\ndef myfunction(...):\n    ...\n\n\n例如，让我们测量下排序一个 2000000 个随机数的数组会花费多长时间：\n\n@fn_timer\ndef random_sort(n):\n    return sorted([random.random() for i in range(n)])\n\n\nif __name__ == \"__main__\":\n random_sort(2000000)\n\n\n如果你运行你的脚本，你将看到：\n\nTotal time running random_sort: 1.41124916077 seconds\n\n\n2. 使用 timeit 模块\n\n另外一个选项是使用 timeit 模块，它给你测量一个平均时间。\n\n为了运行它，在你的终端执行以下命令：\n\n$ python -m timeit -n 4 -r 5 -s \"import timing_functions\" \"timing_functions.random_sort(2000000)\"\n\n\ntiming_functions 是你脚本的名字。\n\n在输出的最后，你会看到一些像这样的东西：\n\n4 loops, best of 5: 2.08 sec per loop\n\n\n表明了运行这个测试 4 次（-n 4），并在每个测试中重复平均 5 次（-r 5），最佳的结果是 2.08 秒。\n\n如果你没有指定测试或者重复，它默认是 10 次循环和 5 次重复。\n\n3. 使用 Uinx 的  time 命令\n\n尽管如此，装饰器和 timeit 模块都是基于 Python 的。这就是为什么 unix time 工具或许有用，因为它是一个外部的 Python 测量。\n\n为了运行 time 工具类型：\n\n$ time -p python timing_functions.py\n\n\n将给出如下输出：\n\nTotal time running random_sort: 1.3931210041 seconds\nreal         1.49\nuser         1.40\nsys          0.08\n\n\n第一行来自于我们定义的装饰器，其他三行是：\n\n\nreal 表明了执行脚本花费的总时间\nUser 表明了执行脚本花费在的 CPU 时间\nSys 表明了执行脚本花费在内核函数的时间\n\n因此， real time 和 user+sys 相加的不同或许表明了时间花费在等待 I/O 或者是系统在忙于执行其他任务。\n\n4. 使用 cProfile 模块\n\n如果你想知道花费在每个函数和方法上的时间，以及它们被调用了多少次，你可以使用 cProfile 模块。\n\n$ python -m cProfile -s cumulative timing_functions.py\n\n\n现在你将看到你的代码中每个函数被调用多少次的详细描述，并且它将通过累积花费在每个函数上面的时间来排序（感谢 -s cumulative 选项）\n\n\n\n你将看到花费在运行你的脚本的总时间是比以前高的。这是我们测量每个函数执行时间的损失。\n\n5. 使用 line_profiler 模块\n\nline_profiler 给出了在你代码每一行花费的 CPU 时间。\n\n这个模块首先应该被安装，使用命令：\n\n$ pip install line_profiler\n\n\n下一步，你需要指定你想使用装饰器 @profile 评估哪个函数（你不需要把它 import 到你的文件中）。\n\n@profile\ndef random_sort2(n):\n    l = [random.random() for i in range(n)]\n    l.sort()\n    return l\n\nif __name__ == \"__main__\":\n    random_sort2(2000000)\n\n\n最后，你可以通过键入以下命令取得 random_sort2 函数逐行的描述：\n\n$ kernprof -l -v timing_functions.py\n\n\n-l 标识表明了逐行和 -v 标识表明详细输出。使用这个方法，我们看到了数组结构花费了 44% 的计算时间，sort() 方法花费了剩余的  56%。\n\n\n\n你也将看到，由于时间测量，这个脚本执行花费的或许更长。\n\n6. 使用 memory_profiler 模块\n\nmemory_profiler 模块被用于在逐行的基础上，测量你代码的内存使用率。尽管如此，它可能使得你的代码运行的更慢。\n\n安装：\n\n$ pip install memory_profiler\n\n\n也建议安装 psutil 包，使得 memory_profile 模块运行的更快：\n\n$ pip install psutil\n\n\n类似 line_profiler 的方式，使用装饰器 @profile 来标记哪个函数被跟踪。下一步，键入：\n\n$ python -m memory_profiler timing_functions.py\n\n\n是的，前面的脚本比之前的 1 或 2 秒需要更长的时间。并且，如果你不安装 psutil 模块，你将一直等待结果。\n\n\n\n看上面的输出，注意内存使用率的单位是 MiB，这代表的是兆字节（1MiB = 1.05MB）。\n\n7. 使用 guppy 包\n\n最后，使用这个包，你可以跟踪每个类型在你代码中每个阶段（字符， 元组， 字典 等等）有多少对象被创建了。\n\n安装：\n\n$ pip install guppy\n\n\n下一步，像这样添加到你的代码中：\n\nfrom guppy import hpy\n\n\ndef random_sort3(n):\n    hp = hpy()\n    print \"Heap at the beginning of the function\\n\", hp.heap()\n    l = [random.random() for i in range(n)]\n    l.sort()\n    print \"Heap at the end of the function\\n\", hp.heap()\n    return l\n\n\nif __name__ == \"__main__\":\n    random_sort3(2000000)\n\n\n并且这样运行你的代码：\n\n$ python timing_functions.py\n\n\n你将看到一些像下面的输出：\n\n\n\n通过配置 heap 在你的代码的不同地方，你可以在脚本中学到对象的创建和销毁。\n\n如果你想学习更多提升你 Python 代码的知识，我建议你看看 2014 年 11 月出版的 High Performance Python: Practical Performant Programming for Humans 这本书。\n\n                ", "mainLikeNum": ["5 "], "mainBookmarkNum": "29"}