{"title": "python学习笔记 - 文件读写 - helloword ", "index": "python", "content": "现代的操作系统其实都不允许程序直接读写系统中的文件，而是程序通过请求系统打开一个文件对象，然后再对文件对象进行读写。\nimport logging\n\ntry:\n    f = open('getAttar.py', 'r')\n    content = f.read()\n    print content\nexcept IOError, e:\n    logging.error(e)\nfinally:\n    if f:\n        f.close()\npython在申请打开文件对象的时候，可能会存在文件不存在的情况，则会抛出IOError需要我们捕获处理。文件对象一旦打开，就需要我们去关闭它。否则其会占用系统资源。文件打开的方式有多种。\nopen(name[, mode[, buffering]])\nmode：\n'r': 读取模式'w': 写入模式。如果文件已经存在，则会先清空。若文件不存在，则会创建文件。'a': append，添加。在unix系统，在，a模式意味着将内容写入到文件末端而不管当前的指针在哪里。'r+': 兼具读写功能。但是文件必须已经存在。而且只会覆盖写入的区域，而保留未被覆盖的区域。例如文件中有“111111”六个1，用该模式写入“000”后就变成“000111”了。'w+':兼具读写功能。但是会清空文件。\n模式文件的读写是文本模式，这就意味着会把\\n转换成平台相关的换行符。如果需要操作二进制文件，则需要添加模式'b'。\nbuffering参数\n0： 不缓存1： 缓存一行其他正整数：代表相应的bytes被缓存了。负整数：系统默认\nwith open(filename) as f\n我们可以使用with ... as ...这种语句替代try...finally..with语句用于对资源进行控制的场合。例如：\nwith open('world.txt', 'r') as f:\n    for line in f:\n        print line\n\n需要了解更多，可以阅读：http://www.ibm.com/developerw...\nfile-like object\nopen()打开的一个文件后返回是file-like object.除了文件file以外，还可以是内存中的字节流，网络流，自定义流等等。StringIO创建的就是file-like object，常用做临时缓冲。\n二进制文件\nPython中默认读取文件是以text模式读取。读取图片、视频、音频等二进制文件的时候，可以添加模式b代表以二进制模式读取。\n字符编码\nassci码给英语世界常用的字符和英文字母变了个号。但是未考虑其他国家的符号。unicode 给世界上几乎所有的符号都编了个号码。utf-8是unicode的一种实现形式。在python中，我们可以将读取的字符解码(decode)成unicode，然后将unicode编码成制定的编码形式。例如\nf = open('demo.txt', 'r')\nprint f.read().decode('gbk')\nf.close()\n上述代码中将读取到的文本按gbk编码方式解码成unicode。但是总是这么手工解码比较麻烦，python为我们提供了codecs模块。例如：\nimport codecs\n\nwith codecs.open('world.txt', 'rb', encoding='gbk') as f:\n    for line in f:\n        print line\n除了上述按特定编码格式解码文件，然后按unicode格式存储在内存中。我们也可以将内存中的unicode以特定格式写入文本。\n# coding=utf-8\nimport codecs\n\nwith codecs.open('world.txt', 'rb', encoding='utf-8') as rf, \\\n        codecs.open('world2.txt', 'wb', encoding='gbk') as wf:\n    wf.write(rf.read())\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}