{"title": "Django的数据验证(validating objects) - 愚钝的我 ", "index": "validation,web,python,django", "content": "在Django中，对数据进行校验有两种方式：一种是通过Form中校验，一种是通过Model校验。在次，我对Model中的校验方法做下记录。\n所有内容都是基于Django1.10的官网文档整理而来\nvalidating objects\n数据校验的触发：\nModel中的校验是通过调用Model.full_clean()方法来执行的。包括在Form中也会对objects进行校验，也是通过调用Model.full_clean()的方式来进行的。但是，通常的情况下我们并不需要自己调用Model.full_clean()方法。\n什么时候需要调用full_clean()\n\n当你使用ModelForm的时候，Model.full_clean()将会在你调用is_valid()方法的时候对ModelForm中所有的field进行校验。只有当你想要自己特别的处理校验的报错信息，或者是想要校验在ModelForm中没有包含的field时才需要来自己调用full_clean()这个方法。\nModel.full_clean说明\nModel.full_clean(exclude=None, validate_unique=True) 在Model.full_clean()内部其实是会通过3个方法来进行不同层次的校验，对于这3个方法在后面会讲到。\n参数：\n可选参数exclude可以用来指定不需要执行校验的field。ModelForm也利用这个参数来将field排除。参数validate_unique用来指定是否需要执行Model.validate_unique()。\n如何检查校验结果：\nfull_clean将会按序执行3个方法，这3个方法如果校验失败的话，会将相关信息写到异常的message_dict属性中，并且抛出ValidationError异常。\nsave()执行的时候是不会自动调用full_clean()来进行校验的。\n手动校验model的合法性：\nfrom django.core.exceptions import ValidationError\ntry:\n    article.full_clean()\nexcept ValidationError as e:\n    # Do something based on the errors contained in e.message_dict.\n    # Display them to a user, or handle them programmatically.\n    pass\n3个校验方法：\n\n校验model fields - Model.clean_fields()\n校验整个model - Model.clean()\n校验field的唯一性 - Model.validate_unique()\n\n这几个步骤将会在调用model的full_clean()方法时执行，流程如下：\nst=>start: Model.full_clean\ne=>end: return\nio=>inputoutput: rais ValidationError\nsub1=>subroutine: Model.clean_fields\ncond1=>condition: valid\nsub2=>subroutine: Model.clean\ncond2=>condition: valid\nsub3=>subroutine: Model.validate_unique\ncond3=>condition: valid\n\nst->sub1->cond1(yes)->sub2->cond2(yes)->sub3->cond3(yes)->e\nst->sub1->cond1(no)->io\nst->sub1->cond1(yes)->sub2->cond2(no)->io\nst->sub1->cond1(yes)->sub2->cond2(yes)->sub3->cond3(no)->io\nModel.clean_fields\nModel.clean_fields(exclude=None)这个方法将会校验排除exclude中指定的，model中的所有field。当它校验失败的时候，会抛出ValidationError异常。\nModel.clean\n如果你想要自定义model的校验，或者想要修改model的属性的话，就override这个方法。例如，你可以使用它来为field自动提供一个值：\nimport datetime\nfrom django.core.exceptions import ValidationError\nfrom django.db import models\nfrom django.utils.translation import ugettext_lazy as _\n\nclass Article(models.Model):\n    ...\n    def clean(self):\n        # Don't allow draft entries to have a pub_date.\n        if self.status == 'draft' and self.pub_date is not None:\n            raise ValidationError(_('Draft entries may not have a publication date.'))\n        # Set the pub_date for published items if it hasn't been set already.\n        if self.status == 'published' and self.pub_date is None:\n            self.pub_date = datetime.date.today()\n当调用model的save()方法的时候，是不会调用Model.clean来进行校验的\n校验中的错误处理\n在上面的例子中，我们使用了ValidationError来在Model.clean中抛出错误，这个错误信息将会存储在以NON_FIELD_ERRORS为key的字典中。这个key是用来存储对于整个model中的错误信息的。\n如何获取校验的错误信息：\nfrom django.core.exceptions import ValidationError, NON_FIELD_ERRORS\ntry:\n    article.full_clean()\nexcept ValidationError as e:\n    non_field_errors = e.message_dict[NON_FIELD_ERRORS]\n如何指定对于某个特定的field的校验错误信息：\nclass Article(models.Model):\n    ...\n    def clean(self):\n        # Don't allow draft entries to have a pub_date.\n        if self.status == 'draft' and self.pub_date is not None:\n            raise ValidationError({'pub_date': _('Draft entries may not have a publication date.')})\n        ...\n如何指定多个field的校验错误信息：\nraise ValidationError({\n    'title': ValidationError(_('Missing title.'), code='required'),\n    'pub_date': ValidationError(_('Invalid date.'), code='invalid'),\n})\nModel.validate_unique说明\nModel.validate_unique(exclude=None)最后，full_clean()将会检查model中的unique的限制。它在校验失败的时候会抛出ValidationError异常。\n注意\n值得注意的是：上面多次提到，在执行save()方法的时候，是不会进行数据校验的。校验应该在save()执行之前完成，你可以先在form进行校验，也可以在model中进行校验。但是，你必须确保通过这两个校验之后的数据是绝对没有问题的“干净”数据，然后再调用save()方法将数据存储入库。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "3"}