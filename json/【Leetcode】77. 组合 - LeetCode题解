{"title": "【Leetcode】77. 组合 - LeetCode题解 ", "index": "面试,算法-数据结构,数据结构,java,python", "content": "题目\n给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。示例:\n输入: n = 4, k = 2\n输出:\n[\n  [2,4],\n  [3,4],\n  [2,3],\n  [1,2],\n  [1,3],\n  [1,4],\n]\n题解\n这道题目我就不做解析了，就是全排列的变种，全排列用backtrack的方法，我们之前已经解析过好几期了，都是一套解题模板，直接记住这种backtrack题目的模板即可快速A掉。\njava版本\nclass Solution {\n    public List<List<Integer>> combine(int n, int k) {\n        List<List<Integer>> res = new ArrayList<>();\n        backtrack(res, n, 1, k, new ArrayList<>());\n        return res;\n    }\n\n    public void backtrack(List<List<Integer>> res, int n, int num, int k, List<Integer> list) {\n        if (list.size() == k) {\n            res.add(new ArrayList<>(list));\n        } else {\n            for (int i = num; i <= n; i++) {\n                list.add(i);\n                backtrack(res, n, i + 1, k, list);\n                list.remove(list.size() - 1);\n            }\n        }\n    }\n}\npython版本\nclass Solution:\n    def backtrack(self, res, n, nums, k, current):\n        if len(current) == k:\n            res.append(current.copy())\n        else:\n            for i in range(nums, n + 1):\n                current.append(i)\n                self.backtrack(res, n, i + 1, k, current)\n                current.pop()\n\n    def combine(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        self.backtrack(res, n, 1, k, [])\n        return res\n回溯题目\n\n【Leetcode】60. 第k个排列\n【Leetcode】47. 全排列 II\n【Leetcode】46.全排列\n\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}