{"title": "99%的人都不知道的pandas骚操作（一） - Python数据科学 ", "index": "人工智能,数据分析,python,pandas", "content": "作者：xiaoyu\n微信公众号：Python数据科学\n知乎：python数据分析师\n\npandas有一种功能非常强大的方法，它就是accessor，可以将它理解为一种属性接口，通过它可以获得额外的方法。其实这样说还是很笼统，下面我们通过代码和实例来理解一下。\n>>> pd.Series._accessors\n{'cat', 'str', 'dt'}\n对于Series数据结构使用_accessors方法，我们得到了3个对象：cat，str，dt。\n\n.cat：用于分类数据（Categorical data）\n.str：用于字符数据（String Object data）\n.dt：用于时间数据（datetime-like data）\n\n下面我们依次看一下这三个对象是如何使用的。\nstr对象的使用\nSeries数据类型：str字符串\n# 定义一个Series序列\n>>> addr = pd.Series([\n...     'Washington, D.C. 20003',\n...     'Brooklyn, NY 11211-1755',\n...     'Omaha, NE 68154',\n...     'Pittsburgh, PA 15211'\n... ]) \n\n>>> addr.str.upper()\n0     WASHINGTON, D.C. 20003\n1    BROOKLYN, NY 11211-1755\n2            OMAHA, NE 68154\n3       PITTSBURGH, PA 15211\ndtype: object\n\n>>> addr.str.count(r'\\d') \n0    5\n1    9\n2    5\n3    5\ndtype: int64\n关于以上str对象的2个方法说明：\n\nSeries.str.upper：将Series中所有字符串变为大写；\nSeries.str.count：对Series中所有字符串的个数进行计数；\n\n其实不难发现，该用法的使用与Python中字符串的操作很相似。没错，在pandas中你一样可以这样简单的操作，而不同的是你操作的是一整列的字符串数据。仍然基于以上数据集，再看它的另一个操作：\n>>> regex = (r'(?P<city>[A-Za-z ]+), '      # 一个或更多字母\n...          r'(?P<state>[A-Z]{2}) '        # 两个大写字母\n...          r'(?P<zip>\\d{5}(?:-\\d{4})?)')  # 可选的4个延伸数字\n...\n>>> addr.str.replace('.', '').str.extract(regex)\n         city state         zip\n0  Washington    DC       20003\n1    Brooklyn    NY  11211-1755\n2       Omaha    NE       68154\n3  Pittsburgh    PA       15211\n关于以上str对象的2个方法说明：\n\nSeries.str.replace：将Series中指定字符串替换；\nSeries.str.extract：通过正则表达式提取字符串中的数据信息；\n\n这个用法就有点复杂了，因为很明显看到，这是一个链式的用法。通过replace将 \" . \" 替换为\"\"，即为空，紧接着又使用了3个正则表达式（分别对应city，state，zip）通过extract对数据进行了提取，并由原来的Series数据结构变为了DataFrame数据结构。\n当然，除了以上用法外，常用的属性和方法还有rstrip，.contains，split等，我们通过下面代码查看一下str属性的完整列表：\n>>> [i for i in dir(pd.Series.str) if not i.startswith('_')]\n['capitalize',\n 'cat',\n 'center',\n 'contains',\n 'count',\n 'decode',\n 'encode',\n 'endswith',\n 'extract',\n 'extractall',\n 'find',\n 'findall',\n 'get',\n 'get_dummies',\n 'index',\n 'isalnum',\n 'isalpha',\n 'isdecimal',\n 'isdigit',\n 'islower',\n 'isnumeric',\n 'isspace',\n 'istitle',\n 'isupper',\n 'join',\n 'len',\n 'ljust',\n 'lower',\n 'lstrip',\n 'match',\n 'normalize',\n 'pad',\n 'partition',\n 'repeat',\n 'replace',\n 'rfind',\n 'rindex',\n 'rjust',\n 'rpartition',\n 'rsplit',\n 'rstrip',\n 'slice',\n 'slice_replace',\n 'split',\n 'startswith',\n 'strip',\n 'swapcase',\n 'title',\n 'translate',\n 'upper',\n 'wrap',\n 'zfill']\n属性有很多，对于具体的用法，如果感兴趣可以自己进行摸索练习。\ndt对象的使用\nSeries数据类型：datetime\n因为数据需要datetime类型，所以下面使用pandas的date_range()生成了一组日期datetime演示如何进行dt对象操作。\n>>> daterng = pd.Series(pd.date_range('2017', periods=9, freq='Q'))\n>>> daterng\n0   2017-03-31\n1   2017-06-30\n2   2017-09-30\n3   2017-12-31\n4   2018-03-31\n5   2018-06-30\n6   2018-09-30\n7   2018-12-31\n8   2019-03-31\ndtype: datetime64[ns]\n\n>>>  daterng.dt.day_name()\n0      Friday\n1      Friday\n2    Saturday\n3      Sunday\n4    Saturday\n5    Saturday\n6      Sunday\n7      Monday\n8      Sunday\ndtype: object\n\n>>> # 查看下半年\n>>> daterng[daterng.dt.quarter > 2]\n2   2017-09-30\n3   2017-12-31\n6   2018-09-30\n7   2018-12-31\ndtype: datetime64[ns]\n\n>>> daterng[daterng.dt.is_year_end]\n3   2017-12-31\n7   2018-12-31\ndtype: datetime64[ns]\n以上关于dt的3种方法说明：\n\nSeries.dt.day_name()：从日期判断出所处星期数；\nSeries.dt.quarter：从日期判断所处季节；\nSeries.dt.is_year_end：从日期判断是否处在年底；\n\n其它方法也都是基于datetime的一些变换，并通过变换来查看具体微观或者宏观日期。\ncat对象的使用\nSeries数据类型：Category\n在说cat对象的使用前，先说一下Category这个数据类型，它的作用很强大。虽然我们没有经常性的在内存中运行上g的数据，但是我们也总会遇到执行几行代码会等待很久的情况。使用Category数据的一个好处就是：可以很好的节省在时间和空间的消耗。下面我们通过几个实例来学习一下。\n>>> colors = pd.Series([\n...     'periwinkle',\n...     'mint green',\n...     'burnt orange',\n...     'periwinkle',\n...     'burnt orange',\n...     'rose',\n...     'rose',\n...     'mint green',\n...     'rose',\n...     'navy'\n... ])\n...\n>>> import sys\n>>> colors.apply(sys.getsizeof)\n0    59\n1    59\n2    61\n3    59\n4    61\n5    53\n6    53\n7    59\n8    53\n9    53\ndtype: int64\n上面我们通过使用sys.getsizeof来显示内存占用的情况，数字代表字节数。还有另一种计算内容占用的方法：memory_usage()，后面会使用。\n现在我们将上面colors的不重复值映射为一组整数，然后再看一下占用的内存。\n>>> mapper = {v: k for k, v in enumerate(colors.unique())}\n>>> mapper\n{'periwinkle': 0, 'mint green': 1, 'burnt orange': 2, 'rose': 3, 'navy': 4}\n\n>>> as_int = colors.map(mapper)\n>>> as_int\n0    0\n1    1\n2    2\n3    0\n4    2\n5    3\n6    3\n7    1\n8    3\n9    4\ndtype: int64\n\n>>> as_int.apply(sys.getsizeof)\n0    24\n1    28\n2    28\n3    24\n4    28\n5    28\n6    28\n7    28\n8    28\n9    28\ndtype: int64\n注：对于以上的整数值映射也可以使用更简单的pd.factorize()方法代替。\n我们发现上面所占用的内存是使用object类型时的一半。其实，这种情况就类似于Category data类型内部的原理。\n内存占用区别：Categorical所占用的内存与Categorical分类的数量和数据的长度成正比，相反，object所占用的内存则是一个常数乘以数据的长度。\n下面是object内存使用和category内存使用的情况对比。\n>>> colors.memory_usage(index=False, deep=True)\n650\n>>> colors.astype('category').memory_usage(index=False, deep=True)\n495\n上面结果是使用object和Category两种情况下内存的占用情况。我们发现效果并没有我们想象中的那么好。但是注意Category内存是成比例的，如果数据集的数据量很大，但不重复分类（unique）值很少的情况下，那么Category的内存占用可以节省达到10倍以上，比如下面数据量增大的情况：\n>>> manycolors = colors.repeat(10)\n>>> len(manycolors) / manycolors.nunique() \n20.0\n\n>>> manycolors.memory_usage(index=False, deep=True)\n6500\n>>> manycolors.astype('category').memory_usage(index=False, deep=True)\n585\n可以看到，在数据量增加10倍以后，使用Category所占内容节省了10倍以上。\n除了占用内存节省外，另一个额外的好处是计算效率有了很大的提升。因为对于Category类型的Series，str字符的操作发生在.cat.categories的非重复值上，而并非原Series上的所有元素上。也就是说对于每个非重复值都只做一次操作，然后再向与非重复值同类的值映射过去。\n对于Category的数据类型，可以使用accessor的cat对象，以及相应的属性和方法来操作Category数据。\n>>> ccolors = colors.astype('category')\n>>> ccolors.cat.categories\nIndex(['burnt orange', 'mint green', 'navy', 'periwinkle', 'rose'], dtype='object')\n实际上，对于开始的整数类型映射，我们可以先通过reorder_categories进行重新排序，然后再使用cat.codes来实现对整数的映射，来达到同样的效果。\n>>> ccolors.cat.reorder_categories(mapper).cat.codes\n0    0\n1    1\n2    2\n3    0\n4    2\n5    3\n6    3\n7    1\n8    3\n9    4\ndtype: int8\ndtype类型是Numpy的int8（-127~128）。可以看出以上只需要一个单字节就可以在内存中包含所有的值。我们开始的做法默认使用了int64类型，然而通过pandas的使用可以很智能的将Category数据类型变为最小的类型。\n让我们来看一下cat还有什么其它的属性和方法可以使用。下面cat的这些属性基本都是关于查看和操作Category数据类型的。\n>>> [i for i in dir(ccolors.cat) if not i.startswith('_')]\n['add_categories',\n 'as_ordered',\n 'as_unordered',\n 'categories',\n 'codes',\n 'ordered',\n 'remove_categories',\n 'remove_unused_categories',\n 'rename_categories',\n 'reorder_categories',\n 'set_categories']\n但是Category数据的使用不是很灵活。例如，插入一个之前没有的值，首先需要将这个值添加到.categories的容器中，然后再添加值。\n>>> ccolors.iloc[5] = 'a new color'\n# ...\nValueError: Cannot setitem on a Categorical with a new category,\nset the categories first\n\n>>> ccolors = ccolors.cat.add_categories(['a new color'])\n>>> ccolors.iloc[5] = 'a new color'  \n如果你想设置值或重塑数据，而非进行新的运算操作，那么Category类型不是那么有用。\n以上就是本次骚操作的介绍，你get到了没有？\n\n关注微信公众号：Python数据科学，发现更多精彩内容。\n\n                ", "mainLikeNum": ["15 "], "mainBookmarkNum": "12"}