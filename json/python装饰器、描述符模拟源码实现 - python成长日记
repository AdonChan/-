{"title": "python装饰器、描述符模拟源码实现 - python成长日记 ", "index": "property,装饰器,python", "content": "概要\n本人python理论知识远达不到传授级别，写文章主要目的是自我总结，并不能照顾所有人，请见谅，文章结尾贴有相关链接可以作为补充\n全文分为三个部分装饰器理论知识、装饰器应用、装饰器延申\n\n装饰理基础：无参装饰器、有参装饰器、functiontools、装饰器链\n装饰器进阶：property、staticmethod、classmethod源码分析（python代码实现）\n\n\n装饰器基础\n无参装饰器\n'''\n假定有一个需求是：打印程序函数运行顺序\n此案例打印的结果为：\n    foo1 function is starting\n    foo2 function is starting\n'''\nfrom functools import wraps\n\n\ndef NoParamDec(func):\n    #函数在被装饰器装时后，其函数属性也会改变，wraps作用就是保证被装饰函数属性不变\n    @wraps(func)\n    def warpper(*args, **kwargs):\n        print('{} function is starting'.format(func.__name__))\n        return func(*args, **kwargs)\n    \n    return warpper\n\n\n#python黑魔法省略了NoParamDec=NoParamDec(foo1)\n@NoParamDec\ndef foo1():\n    foo2()\n\n@NoParamDec\ndef foo2():\n    pass\n\n\nif __name__ == \"__main__\":\n\n    foo1()\n\n有参装饰器\n'''\n假定有一个需求是：检查函数参数的类型，只允许匹配正确的函数通过程序\n此案例打印结果为：\n('a', 'b', 'c')\n-----------------------分割线------------------------\nERROS!!!!b must be <class 'str'> \nERROS!!!!c must be <class 'str'> \n('a', 2, ['b', 'd'])\n\n    \n'''\nfrom functools import wraps\nfrom  inspect import signature\n\n\ndef typeAssert(*args, **kwargs):\n    deco_args = args\n    deco_kwargs = kwargs\n    \n    def factor(func):\n        #python标准模块类，可以用来检查函数参数类型，只允许特定类型通过\n        sig = signature(func)\n        #将函数形式参数和规定类型进行绑定\n        check_bind_args = sig.bind_partial(*deco_args, **deco_kwargs).arguments\n        \n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            #将实际参数值和形式参数进行绑定\n            wrapper_bind_args = sig.bind(*args, **kwargs).arguments.items()\n            for name, obj in wrapper_bind_args:\n                #遍历判断是否实际参数值是规定参数的实例\n                if not isinstance(obj, check_bind_args[name]):\n                    try:\n                        raise TypeError('ERROS!!!!{arg} must be {obj} '.format(**{'arg': name, 'obj': check_bind_args[name]}))\n                    except Exception as e:\n                        print(e)\n            return func(*args, **kwargs)\n        \n        return wrapper\n    \n    return factor\n\n\n@typeAssert(str, str, str)\ndef inspect_type(a, b, c):\n    return (a, b, c)\n\n\nif __name__ == \"__main__\":\n    print(inspect_type('a', 'b', 'c'))\n    print('{:-^50}'.format('分割线'))\n    print(inspect_type('a', 2, ['b', 'd']))\n\n\n装饰器链\n'''\n假定有一个需求是：\n输入类似代码：\n@makebold\n@makeitalic\ndef say():\n   return \"Hello\"\n\n输出：\n<b><i>Hello</i></b>\n'''\nfrom functools import wraps\n\n\ndef html_deco(tag):\n    def decorator(fn):\n        @wraps(fn)\n        def wrapped(*args, **kwargs):\n            return '<{tag}>{fn_result}<{tag}>'.format(**{'tag': tag, 'fn_result': fn(*args, **kwargs)})\n        \n        return wrapped\n    \n    return decorator\n\n\n@html_deco('b')\n@html_deco('i')\ndef greet(whom=''):\n    # 等价于 geet=html_deco('b')(html_deco('i)(geet))\n    return 'Hello' + (' ' + whom) if whom else ''\n\n\nif __name__ == \"__main__\":\n    print(greet('world'))  # -> <b><i>Hello world</i></b>\n\n\n 装饰器进阶\nproperty 原理\n通常，描述符是具有“绑定行为”的对象属性，其属性访问已经被描述符协议中的方法覆盖。这些方法是__get__()、__set__()和__delete__()。如果一个对象定义这些方法中的任何一个，它被称为一个描述符。如果对象定义__get__()和__set__()，则它被认为是数据描述符。仅定义__get__()的描述器称为非数据描述符（它们通常用于方法，但是其他用途也是可能的）。\n属性查找优先级为：\n\n类属性\n数据描述符\n实例属性\n非数据描述符\n默认为__getattr__()\n\nclass Property(object):\n    '''\n    内部property是用c实现的，这里用python模拟实现property功能\n    代码参考官方doc文档\n    '''\n\n    def __init__(self, fget=None, fset=None, fdel=None, doc=None):\n        self.fget = fget\n        self.fset = fset\n        self.fdel = fdel\n        self.__doc__ = doc\n\n    def __get__(self, obj, objtype=None):\n        if obj is None:\n            return self\n        if self.fget is None:\n            raise (AttributeError, \"unreadable attribute\")\n        print('self={},obj={},objtype={}'.format(self,obj,objtype))\n        return self.fget(obj)\n\n    def __set__(self, obj, value):\n        if self.fset is None:\n            raise (AttributeError, \"can't set attribute\")\n        self.fset(obj, value)\n\n    def __delete__(self, obj):\n        if self.fdel is None:\n            raise (AttributeError, \"can't delete attribute\")\n        self.fdel(obj)\n\n    def getter(self, fget):\n        return type(self)(fget, self.fset, self.fdel, self.__doc__)\n\n    def setter(self, fset):\n        return type(self)(self.fget, fset, self.fdel, self.__doc__)\n\n    def deleter(self, fdel):\n        return type(self)(self.fget, self.fset, fdel, self.__doc__)\n\n\nclass Student( object ):\n    @Property\n    def score( self ):\n        return self._score\n    @score.setter\n    def score( self, val ):\n        if not isinstance( val, int ):\n            raise ValueError( 'score must be an integer!' )\n        if val > 100 or val < 0:\n            raise ValueError( 'score must between 0 ~ 100!' )\n        self._score = val\n\n\nif __name__ == \"__main__\":\n    s = Student()\n    s.score = 60   \n    s.score         \nstaticmethod 原理\n@staticmethod means: when this method is called, we don't pass an instance of the class to it (as we normally do with methods). This means you can put a function inside a class but you can't access the instance of that class (this is useful when your method does not use the instance).\nclass StaticMethod(object):\n    \"python代码实现staticmethod原理\"\n    \n    def __init__(self, f):\n        self.f = f\n    \n    def __get__(self, obj, objtype=None):\n        return self.f\n\n\nclass E(object):\n    #StaticMethod=StaticMethod(f)\n    @StaticMethod\n    def f( x):\n        return x\n\nif __name__ == \"__main__\":\n    print(E.f('staticMethod Test'))\n\nclassmethod\n@staticmethod means: when this method is called, we don't pass an instance of the class to it (as we normally do with methods). This means you can put a function inside a class but you can't access the instance of that class (this is useful when your method does not use the instance).\nclass ClassMethod(object):\n    \"python代码实现classmethod原理\"\n    \n    def __init__(self, f):\n        self.f = f\n    \n    def __get__(self, obj, klass=None):\n        if klass is None:\n            klass = type(obj)\n        \n        def newfunc(*args):\n            return self.f(klass, *args)\n        \n        return newfunc\n    \nclass E(object):\n    #ClassMethod=ClassMethod(f)\n    @ClassMethod\n    def f(cls,x):\n        return x\n    \nif __name__ == \"__main__\":\n    print(E().f('classMethod Test'))\n\n参考资料\n1, statckoverflow: how to make a chain of decorators\n2, python doc:how to descriptor\n3，知乎：如何理解装饰器\n4, difference-between-staticmethod-and-classmethod-in-python\n5，meaning-of-classmethod-and-staticmethod-for-beginner\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}