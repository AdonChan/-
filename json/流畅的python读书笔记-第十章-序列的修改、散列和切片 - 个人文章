{"title": "流畅的python读书笔记-第十章-序列的修改、散列和切片 - 个人文章 ", "index": "python", "content": "序列的修改、散列和切片\n接着造Vector2d类\n要达到的要求\n为了编写Vector(3, 4) 和 Vector(3, 4, 5) 这样的代码，我们可以让 init 法接受任意个参数（通过 *args）\n如果 Vector 实例的分量超过 6 个，repr() 生成的字符串就会使用 ... 省略一部分，使用 reprlib 模块可以生成长度有限的表示形式\nfrom array import array\nimport reprlib\nimport math\n\n\nclass Vector:\n    typecode = 'd'\n\n    def __init__(self, components):\n        self._components = array(self.typecode, components)\n\n    def __iter__(self):\n        return iter(self._components)\n        \n    # 这里是重点\n    def __repr__(self):\n        components = reprlib.repr(self._components)\n        components = components[components.find('['):-1]\n        return 'Vector({})'.format(components)\n        \nprint(Vector([3.1, 4.2]))\nprint(Vector((3, 4, 5)))\nprint(Vector(range(10)))\n❸ 使用 reprlib.repr() 函数获取 self._components 的有限长度表示形式（如array('d', [0.0, 1.0, 2.0, 3.0, 4.0, ...])）。❹ 把字符串插入 Vector 的构造方法调用之前，去掉前面的 array('d' 和后面的 )。\n协议和鸭子类型\n在面向对象编程中，\n\n协议是非正式的接口，只在文档中定义，在代码中不定义。\n例如，Python 的序列协议只需要 len 和 getitem 两个方法。\n任何类（如 Spam），只要使用标准的签名和语义实现了这两个方法，就能用在任何期待序列的地方。\n\n第一章的代码再次给出\nimport collections\n\nCard = collections.namedtuple('Card', ['rank', 'suit'])\n\n\nclass FrenchDeck:\n    ranks = [str(n) for n in range(2, 11)] + list('JQKA')\n    suits = 'spades diamonds clubs hearts'.split()\n\n    def __init__(self):\n        self._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks]\n\n    def __len__(self):\n        return len(self._cards)\n\n    def __getitem__(self, position):\n        return self._cards[position]\n\nVector类第2版：可切片的序列\nfrom array import array\nimport reprlib\nimport math\n\n\nclass Vector(object):\n    typecode = 'd'\n\n    def __init__(self, components):\n        self._components = array(self.typecode, components)\n\n    def __iter__(self):\n        return iter(self._components)\n\n    def __repr__(self):\n        components = reprlib.repr(self._components)\n        components = components[components.find('['):-1]\n        return 'Vector({})'.format(components)\n\n    def __str__(self):\n        return str(tuple(self))\n\n    def __bytes__(self):\n        return (bytes([ord(self.typecode)]) +\n                bytes(self._components))\n\n    def __eq__(self, other):\n        return tuple(self) == tuple(other)\n\n    def __abs__(self):\n        return math.sqrt(sum(x * x for x in self))\n\n    def __bool__(self):\n        return bool(abs(self))\n\n    @classmethod\n    def frombytes(cls, octets):\n        typecode = chr(octets[0])\n        memv = memoryview(octets[1:]).cast(typecode)\n        return cls(memv)\n\n    def __len__(self):\n        return len(self._components)\n\n    def __getitem__(self, index):\n        return self._components[index]\n\n\nv1 = Vector([3, 4, 5])\nprint(len(v1))\n\nprint(v1[0], v1[-1])\n\nv7 = Vector(range(7))\nprint(v7[1:4])\n\n现在连切片都支持了，不过尚不完美。如果 Vector 实例的切片也是 Vector实例，而不是数组，那就更好了。\n把 Vector 实例的切片也变成 Vector 实例，我们不能简单地委托给数组切片。我们要分析传给 getitem 方法的参数，做适当的处理。\n切片原理\nclass MySeq:\n    def __getitem__(self, index):\n        return index\n\n\ns = MySeq()\nprint(s[1])\n\nprint(s[1:4])\n\nprint(s[1:4:2])\n\nprint(s[1:4:2, 9])\n\nprint(s[1:4:2, 7:9])\n\n❸ 1:4 表示法变成了 slice(1, 4, None)。❹ slice(1, 4, 2) 的意思是从 1 开始，到 4 结束，步幅为 2。❺ 神奇的事发生了：如果 [] 中有逗号，那么 getitem 收到的是元组。❻ 元组中甚至可以有多个切片对象。\n查看 slice 类的属性\nprint(slice)\nprint(dir(slice))\n\n['__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'indices', 'start', 'step', 'stop']\n通过审查 slice，发现它有 start、stop 和 step 数据属性，以及 indices 方法。\nindices 方法开放了内置序列实现的棘手逻辑，用于优雅地处理缺失索引和负数索引，以及长度超过目标序列的切片。这个方法会“整顿”元组，把 start、stop 和stride 都变成非负数，而且都落在指定长度序列的边界内。一句话 把负数索引和超出长度的索引调整成 正常的索引\n\n\n\n\naa = 'ABCDE'\n\nprint(slice(None, 10, 2).indices(5))\nprint(slice(-3, None, None).indices(5))\n\nprint('='*40)\nprint(slice(None, 10, 2).indices(len(aa)))\nprint(slice(-3, None, None).indices(len(aa)))\n\n\nprint(aa[-3:])\n能处理切片的__getitem__方法\nfrom array import array\nimport reprlib\nimport math\nimport numbers\n\nclass Vector(object):\n    typecode = 'd'\n\n    def __init__(self, components):\n        self._components = array(self.typecode, components)\n\n    def __iter__(self):\n        return iter(self._components)\n\n    def __repr__(self):\n        components = reprlib.repr(self._components)\n        components = components[components.find('['):-1]\n        return 'Vector({})'.format(components)\n\n\n\n    def __len__(self):\n        return len(self._components)\n\n    ##[1:4] 返回一个向量对象\n    def __getitem__(self, index):\n        cls = type(self)\n        if isinstance(index, slice):\n            return cls(self._components[index])\n        elif isinstance(index, numbers.Integral):\n            return self._components[index]\n        else:\n            msg = '{cls.__name__} indices must be integers'\n            raise TypeError(msg.format(cls=cls))\n\n\nv7 = Vector(range(7))\nprint(v7[-1])\n\nprint(v7[1:4])\n\nprint(v7[-1:])\n\n\nVector类第3版：动态存取属性\n我们可以在 Vector 中编写四个特性，但这样太麻烦。特殊方法 getattr 提供了更好的方式。\n属性查找失败后，解释器会调用 getattr 方法。简单来说，对 my_obj.x 表达式，\nPython 会检查 my_obj 实例有没有名为 x 的属性；如果没有，到类（my_obj.__class__）中查找；如果还没有，顺着继承树继续查找。 如果依旧找不到，调用 my_obj 所属类中定义的 getattr 方法，传入 self 和属性名称的字符串形式（如 'x'）。\nfrom array import array\nimport reprlib\nimport math\nimport numbers\n\n\nclass Vector(object):\n    typecode = 'd'\n\n    def __init__(self, components):\n        self._components = array(self.typecode, components)\n\n    def __iter__(self):\n        return iter(self._components)\n\n    def __repr__(self):\n        components = reprlib.repr(self._components)\n        components = components[components.find('['):-1]\n        return 'Vector({})'.format(components)\n\n    shortcut_names = 'xyzt'\n\n    def __getattr__(self, name):\n        cls = type(self)\n        if len(name) == 1:\n            pos = cls.shortcut_names.find(name)\n        if 0 <= pos < len(self._components):\n            return self._components[pos]\n        msg = '{.__name__!r} object has no attribute {!r}'\n        raise AttributeError(msg.format(cls, name))\n\n    def __setattr__(self, name, value):\n        cls = type(self)\n        if len(name) == 1:\n\n            # 如果 name 是 xyzt 中的一个，设置特殊的错误消息。\n            if name in cls.shortcut_names:\n                error = 'readonly attribute {attr_name!r}'\n\n            # 如果 name 是小写字母，为所有小写字母设置一个错误消息。\n            elif name.islower():\n                error = \"can't set attributes 'a' to 'z' in {cls_name!r}\"\n\n            #否则，把错误消息设为空字符串。\n            else:\n                error = ''\n\n            #如果有错误消息，抛出AttributeError。\n            if error:\n                msg = error.format(cls_name=cls.__name__, attr_name=name)\n            raise AttributeError(msg)\n\n        # 默认情况：在超类上调用 __setattr__ 方法，提供标准行为。\n        super().__setattr__(name, value)\n\n\nv = Vector(range(5))\nprint(v)\n\n# 这个设置法 没用\nv.p = 10\nprint(v.x)\n\nprint(v)\n\nsuper() 函数用于动态访问超类的方法，对 Python 这样支持多重继承的动态语言来说，必须能这么做。程序员经常使用这个函数把子类方法的某些任务委托给超类中适当的方法\n注意，我们没有禁止为全部属性赋值，只是禁止为单个小写字母属性赋值，以防与只读属性 x、y、z 和 t 混淆。\nVector类第4版：散列和快速等值测试\nfunctools.reduce() 可以替换成 sum()\n这里的原理\n\n它的关键思想是，把一系列值归约成单个值。\nreduce() 函数的第一个参数是接受两个参数的函数，第二个参数是一个可迭代的对象。 假如有个接受两个参数的 fn 函数和一个 lst  列表。\n调用 reduce(fn, lst) 时，fn 会应用到第一对元素上，即 fn(lst[0],lst[1])，生成第一个结果r1。然后，fn 会应用到 r1 和下一个元素上，即 fn(r1,lst[2])，生成第二个结果 r2。\n接着，调用 fn(r2, lst[3])，生成 r3……直到最后一个元素，返回最后得到的结果 rN。\n\n如:\n>>> import functools\n>>> functools.reduce(lambda a,b: a*b, range(1, 6))\n120\nreduce接着用\nimport functools\n\naa = functools.reduce(lambda a, b: a ^ b, range(1,6))\nprint(aa)\n\n# operator--操作符函数\n# https://blog.csdn.net/shengmingqijiquan/article/details/53005129\nimport operator\nbb = functools.reduce(operator.xor, range(6))\nprint(bb)\n使用我喜欢的方式编写 Vector.__hash__ 方法，我们要导入 functools 和\noperator 模块。(任性的作者)\n\nimport functools  # ➊\nimport operator  # ➋\n\n\nclass Vector:\n    typecode = 'd'\n\n    # 排版需要，省略了很多行...\n    def __eq__(self, other):  # ➌\n        return tuple(self) == tuple(other)\n\n    def __hash__(self):\n        hashes = (hash(x) for x in self._components)  # ➍\n        return functools.reduce(operator.xor, hashes, 0)  # ➎\n\n    # 排版需要，省略了很多行...\n\n    \n❹ 创建一个生成器表达式，惰性计算各个分量的散列值。❺ 把 hashes 提供给 reduce 函数，使用 xor 函数计算聚合的散列值；第三个参数，0 是初始值（参见下面的警告框）。\n\neq 方法更有效率\ndef __eq__(self, other):\n    if len(self) != len(other):  # ➊\n        return False\n    for a, b in zip(self, other):  # ➋\n        if a != b:  # ➌\n            return False\n    return True  # ➍\n\n❷ zip 函数生成一个由元组构成的生成器，元组中的元素来自参数传入的各个可迭代对象。如果不熟悉 zip 函数，请阅读“出色的 zip 函数”附注栏。前面比较长度的测试是有必要的，因为一旦有一个输入耗尽，zip 函数会立即停止生成值，而且不发出警告。\n使用 zip 和 all 函数实现 Vector.__eq__ 方法\ndef __eq__(self, other):\n return len(self) == len(other) and all(a == b for a, b in zip(self, other))\nzip 内置函数的使用示例\n>>> zip(range(3), 'ABC') # ➊\n<zip object at 0x10063ae48>\n>>> list(zip(range(3), 'ABC')) # ➋\n[(0, 'A'), (1, 'B'), (2, 'C')]\n>>> list(zip(range(3), 'ABC', [0.0, 1.1, 2.2, 3.3])) # ➌\n[(0, 'A', 0.0), (1, 'B', 1.1), (2, 'C', 2.2)]\n>>> from itertools import zip_longest # ➍\n>>> list(zip_longest(range(3), 'ABC', [0.0, 1.1, 2.2, 3.3], fillvalue=-1))\n[(0, 'A', 0.0), (1, 'B', 1.1), (2, 'C', 2.2), (-1, -1, 3.3)]\n❸ zip 有个奇怪的特性：当一个可迭代对象耗尽后，它不发出警告就停止。❹ itertools.zip_longest 函数的行为有所不同：使用可选的 fillvalue（默认值为 None）填充缺失的值，因此可以继续产出，直到最长的可迭代对象耗尽。\nVector类第5版：格式化\n__format__提供格式化方法,详情和具体代码 page 348\n小总结\nrepr 如果信息展示过长. 用reprlib 模块可以缩短\n2.切片原理slice(None, 10, 2).indices(5)   负责转换成可用的索引len 和 _getitem 实现切片的重要方法\n属性查找失败后，解释器会调用 getattr 方法。利用这个特性,可以搞一些事情\n4.reduce 的使用方法\n5.zip函数 简单理解矩阵对应\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "2"}