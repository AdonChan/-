{"title": "特征组合&特征交叉 (Feature Crosses) - 个人文章 ", "index": "python,tensorflow", "content": "写在前面：之前收藏了一个网友些的谷歌机器学习总结教程（感恩），可是突然断更了，只能自己补完后面的笔记了。\n特征组合也叫特征交叉特征组合也叫特征交叉特征组合也叫特征交叉（说三遍）\n合成特征 (synthetic feature)和特征组合(Feature Crosses)不太一样，特征交叉是特征组合的一个子集。\n合成特征 (synthetic feature)\n一种特征，不在输入特征之列，而是从一个或多个输入特征衍生而来。通过标准化或缩放单独创建的特征不属于合成特征。合成特征包括以下类型：\n\n将一个特征与其本身或其他特征相乘（称为特征组合）。\n两个特征相除。\n对连续特征进行分桶，以分为多个区间分箱。\n\n特征组合 (feature cross)：对非线性规律进行编码\n通过将单独的特征进行组合（相乘或求笛卡尔积）而形成的合成特征。特征组合有助于表示非线性关系。\n对于下面的非线性问题。线性学习器画的任何一条线都不能很好地预测树的健康状况。\n\n要解决上图所示的非线性问题，可以创建一个特征组合。特征组合是指通过将两个或多个输入特征相乘来对特征空间中的非线性规律进行编码的合成特征。“cross”（组合）这一术语来自 cross product（向量积）。我们通过将  与  组合来创建一个名为x3的特征组合：x3 = x1x2\n我们像处理任何其他特征一样来处理这个新建的x3特征组合。线性公式变为：y = b + w1x1 + w2x2 + w3x3\n虽然w3表示非线性信息，但您不需要改变线性模型的训练方式来确定w3的值。\n特征组合的种类\n通过采用随机梯度下降法，可以有效地训练线性模型。因此，在使用扩展的线性模型时辅以特征组合一直都是训练大规模数据集的有效方法。我们可以创建很多不同种类的特征组合。例如：\n\n[A X B]：将两个特征的值相乘形成的特征组合。\n[A x B x C x D x E]：将五个特征的值相乘形成的特征组合。\n[A x A]：对单个特征的值求平方形成的特征组合。\n\n特征组合 (Feature Crosses)：组合独热矢量\n在实践中，机器学习模型很少会组合连续特征。不过，机器学习模型却经常组合独热特征矢量，将独热特征矢量的特征组合视为逻辑连接.例如，假设我们具有以下两个特征：国家/地区和语言。对每个特征进行独热编码会生成具有二元特征的矢量，这些二元特征可解读为 country=USA, country=France 或language=English,language=Spanish。然后，如果您对这些独热编码进行特征组合，则会得到可解读为逻辑连接的二元特征，如下所示：\ncountry:usa AND language:spanish\n再举一个例子，假设您对纬度和经度进行分箱，获得单独的独热 5 元素特征矢量。例如，指定的纬度和经度可以表示如下：\nbinned_latitude = [0, 0, 0, 1, 0]\nbinned_longitude = [0, 1, 0, 0, 0]\n假设您对这两个特征矢量创建了特征组合：\n binned_latitude X binned_longitude\n此特征组合是一个 25 元素独热矢量（24 个 0 和 1 个 1）。该组合中的单个 1 表示纬度与经度的特定连接。然后，您的模型就可以了解到有关这种连接的特定关联性。\n假设我们更粗略地对纬度和经度进行分箱，如下所示：\nbinned_latitude(lat) = [\n  0  < lat <= 10\n  10 < lat <= 20\n  20 < lat <= 30\n]\n\nbinned_longitude(lon) = [\n  0  < lon <= 15\n  15 < lon <= 30\n]\n针对这些粗略分箱创建特征组合会生成具有以下含义的合成特征：\nbinned_latitude_X_longitude(lat, lon) = [\n  0  < lat <= 10 AND 0  < lon <= 15\n  0  < lat <= 10 AND 15 < lon <= 30\n  10 < lat <= 20 AND 0  < lon <= 15\n  10 < lat <= 20 AND 15 < lon <= 30\n  20 < lat <= 30 AND 0  < lon <= 15\n  20 < lat <= 30 AND 15 < lon <= 30\n]\n现在，假设我们的模型需要根据以下两个特征来预测狗主人对狗狗的满意程度：\n\n行为类型（吠叫、叫、偎依等）\n时段\n\n如果我们根据这两个特征构建以下特征组合：\n[behavior type X time of day]\n我们最终获得的预测能力将远远超过任一特征单独的预测能力。例如，如果狗狗在下午 5 点主人下班回来时（快乐地）叫喊，可能表示对主人满意度的正面预测结果。如果狗狗在凌晨 3 点主人熟睡时（也许痛苦地）哀叫，可能表示对主人满意度的强烈负面预测结果。\n线性学习器可以很好地扩展到大量数据。对大规模数据集使用特征组合是学习高度复杂模型的一种有效策略。神经网络可提供另一种策略。特征组合 (Feature Crosses)：Playground 练习\n代码部分练习 学习目标：\n\n通过添加其他合成特征来改进线性回归模型（这是前一个练习的延续）\n使用输入函数将 Pandas DataFrame 对象转换为 Tensors，并在 fit() 和 predict() 中调用输入函数\n使用 FTRL 优化算法进行模型训练\n通过独热编码、分箱和特征组合创建新的合成特征\n\n代码部分还是原来的部分，不做任何改变。需要的改变的是将原来的SGD梯度下降训练学习器换成了TFRL训练学习器。FTRL算法融合了RDA算法能产生稀疏模型的特性和SGD算法能产生更有效模型的特性，也就是说能学习出有效的且稀疏的模型。理解FTRL\nmy_optimizer = tf.train.GradientDescentOptimizer(learning_rate=learning_rate)\n换为\nmy_optimizer = tf.train.FtrlOptimizer(learning_rate=learning_rate)\n使用分桶特征列训练模型\n分桶（分箱）特征分桶也称为分箱。\n例如，我们可以将 population 分为以下 3 个分桶：\nbucket_0 (< 5000)：对应于人口分布较少的街区bucket_1 (5000 - 25000)：对应于人口分布适中的街区bucket_2 (> 25000)：对应于人口分布较多的街区根据前面的分桶定义，以下 population 矢量：\n[[10001], [42004], [2500], [18000]]将变成以下经过分桶的特征矢量：\n[[1], [2], [0], [1]]这些特征值现在是分桶索引。请注意，这些索引被视为离散特征。通常情况下，这些特征将被进一步转换为独热编码表示，但这是以透明方式实现的。\n要为分桶特征定义特征列，我们可以使用 bucketized_column（而不是使用 numeric_column），该列将数字列作为输入，并使用 boundardies 参数中指定的分桶边界将其转换为分桶特征。以下代码为 households 和 longitude 定义了分桶特征列；get_quantile_based_boundaries 函数会根据分位数计算边界，以便每个分桶包含相同数量的元素。\ndef get_quantile_based_boundaries(feature_values, num_buckets):\n  boundaries = np.arange(1.0, num_buckets) / num_buckets\n  quantiles = feature_values.quantile(boundaries)\n  return [quantiles[q] for q in quantiles.keys()]\n\n# Divide households into 7 buckets.\nhouseholds = tf.feature_column.numeric_column(\"households\")\nbucketized_households = tf.feature_column.bucketized_column(\n  households, boundaries=get_quantile_based_boundaries(\n    california_housing_dataframe[\"households\"], 7))\n\n# Divide longitude into 10 buckets.\nlongitude = tf.feature_column.numeric_column(\"longitude\")\nbucketized_longitude = tf.feature_column.bucketized_column(\n  longitude, boundaries=get_quantile_based_boundaries(\n    california_housing_dataframe[\"longitude\"], 10))\n在前面的代码块中，两个实值列（即 households 和 longitude）已被转换为分桶特征列。剩下的任务是对其余的列进行分桶，然后运行代码来训练模型。您可以采用各种启发法来确定分桶的范围。本练习使用了分位数技巧，通过这种方式选择分桶边界后，每个分桶将包含相同数量的样本。\ndef construct_feature_columns():\n  \"\"\"Construct the TensorFlow Feature Columns.\n\n  Returns:\n    A set of feature columns\n  \"\"\" \n  households = tf.feature_column.numeric_column(\"households\")\n  longitude = tf.feature_column.numeric_column(\"longitude\")\n  latitude = tf.feature_column.numeric_column(\"latitude\")\n  housing_median_age = tf.feature_column.numeric_column(\"housing_median_age\")\n  median_income = tf.feature_column.numeric_column(\"median_income\")\n  rooms_per_person = tf.feature_column.numeric_column(\"rooms_per_person\")\n  \n  # Divide households into 7 buckets.\n  bucketized_households = tf.feature_column.bucketized_column(\n    households, boundaries=get_quantile_based_boundaries(\n      training_examples[\"households\"], 7))\n\n  # Divide longitude into 10 buckets.\n  bucketized_longitude = tf.feature_column.bucketized_column(\n    longitude, boundaries=get_quantile_based_boundaries(\n      training_examples[\"longitude\"], 10))\n  \n  # Divide latitude into 10 buckets.\n  bucketized_latitude = tf.feature_column.bucketized_column(\n    latitude, boundaries=get_quantile_based_boundaries(\n      training_examples[\"latitude\"], 10))\n\n  # Divide housing_median_age into 7 buckets.\n  bucketized_housing_median_age = tf.feature_column.bucketized_column(\n    housing_median_age, boundaries=get_quantile_based_boundaries(\n      training_examples[\"housing_median_age\"], 7))\n  \n  # Divide median_income into 7 buckets.\n  bucketized_median_income = tf.feature_column.bucketized_column(\n    median_income, boundaries=get_quantile_based_boundaries(\n      training_examples[\"median_income\"], 7))\n  \n  # Divide rooms_per_person into 7 buckets.\n  bucketized_rooms_per_person = tf.feature_column.bucketized_column(\n    rooms_per_person, boundaries=get_quantile_based_boundaries(\n      training_examples[\"rooms_per_person\"], 7))\n  \n  feature_columns = set([\n    bucketized_longitude,\n    bucketized_latitude,\n    bucketized_housing_median_age,\n    bucketized_households,\n    bucketized_median_income,\n    bucketized_rooms_per_person])\n  \n  return feature_columns\n分桶后运行结果：\n_ = train_model(\n    learning_rate=1.0,\n    steps=500,\n    batch_size=100,\n    feature_columns=construct_feature_columns(),\n    training_examples=training_examples,\n    training_targets=training_targets,\n    validation_examples=validation_examples,\n    validation_targets=validation_targets)\n特征组合\n组合两个（或更多个）特征是使用线性模型来学习非线性关系的一种聪明做法。在我们的问题中，如果我们只使用 latitude 特征进行学习，那么该模型可能会发现特定纬度（或特定纬度范围内，因为我们已经将其分桶）的城市街区更可能比其他街区住房成本高昂。longitude 特征的情况与此类似。但是，如果我们将 longitude 与 latitude 组合，产生的组合特征则代表一个明确的城市街区。如果模型发现某些城市街区（位于特定纬度和经度范围内）更可能比其他街区住房成本高昂，那么这将是比单独考虑两个特征更强烈的信号。\n目前，特征列 API 仅支持组合离散特征。要组合两个连续的值（比如 latitude 或 longitude），我们可以对其进行分桶。\n如果我们组合 latitude 和 longitude 特征（例如，假设 longitude 被分到 2 个分桶中，而 latitude 有 3 个分桶），我们实际上会得到 6 个组合的二元特征。当我们训练模型时，每个特征都会分别获得自己的权重。\n使用特征组合训练模型\n在模型中添加 longitude 与 latitude 的特征组合，训练模型，然后确定结果是否有所改善。可参阅有关 crossed_column() 的 TensorFlow API 文档，了解如何为您的组合构建特征列。hash_bucket_size 可以设为 1000。\ndef construct_feature_columns():\n  \"\"\"Construct the TensorFlow Feature Columns.\n\n  Returns:\n    A set of feature columns\n  \"\"\" \n  households = tf.feature_column.numeric_column(\"households\")\n  longitude = tf.feature_column.numeric_column(\"longitude\")\n  latitude = tf.feature_column.numeric_column(\"latitude\")\n  housing_median_age = tf.feature_column.numeric_column(\"housing_median_age\")\n  median_income = tf.feature_column.numeric_column(\"median_income\")\n  rooms_per_person = tf.feature_column.numeric_column(\"rooms_per_person\")\n  \n  # Divide households into 7 buckets.\n  bucketized_households = tf.feature_column.bucketized_column(\n    households, boundaries=get_quantile_based_boundaries(\n      training_examples[\"households\"], 7))\n\n  # Divide longitude into 10 buckets.\n  bucketized_longitude = tf.feature_column.bucketized_column(\n    longitude, boundaries=get_quantile_based_boundaries(\n      training_examples[\"longitude\"], 10))\n  \n  # Divide latitude into 10 buckets.\n  bucketized_latitude = tf.feature_column.bucketized_column(\n    latitude, boundaries=get_quantile_based_boundaries(\n      training_examples[\"latitude\"], 10))\n\n  # Divide housing_median_age into 7 buckets.\n  bucketized_housing_median_age = tf.feature_column.bucketized_column(\n    housing_median_age, boundaries=get_quantile_based_boundaries(\n      training_examples[\"housing_median_age\"], 7))\n  \n  # Divide median_income into 7 buckets.\n  bucketized_median_income = tf.feature_column.bucketized_column(\n    median_income, boundaries=get_quantile_based_boundaries(\n      training_examples[\"median_income\"], 7))\n  \n  # Divide rooms_per_person into 7 buckets.\n  bucketized_rooms_per_person = tf.feature_column.bucketized_column(\n    rooms_per_person, boundaries=get_quantile_based_boundaries(\n      training_examples[\"rooms_per_person\"], 7))\n  \n  # YOUR CODE HERE: Make a feature column for the long_x_lat feature cross\n  long_x_lat = tf.feature_column.crossed_column(\n  set([bucketized_longitude, bucketized_latitude]), hash_bucket_size=1000) \n  \n  feature_columns = set([\n    bucketized_longitude,\n    bucketized_latitude,\n    bucketized_housing_median_age,\n    bucketized_households,\n    bucketized_median_income,\n    bucketized_rooms_per_person,\n    long_x_lat])\n  \n  return feature_columns\n程序运行：\n_ = train_model(\n    learning_rate=1.0,\n    steps=500,\n    batch_size=100,\n    feature_columns=construct_feature_columns(),\n    training_examples=training_examples,\n    training_targets=training_targets,\n    validation_examples=validation_examples,\n    validation_targets=validation_targets)\n\n                ", "mainLikeNum": ["4 "], "mainBookmarkNum": "3"}