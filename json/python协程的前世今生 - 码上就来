{"title": "python协程的前世今生 - 码上就来 ", "index": "协程,python", "content": "在上一篇对python并发编程的理解 中，我简单提到了协程的概念，有一个错误需要指出的是，asyncio不全是对协程的实现，只是用到了协程。\n协程的历史说来话长，要从生成器开始讲起。\n如果你看过我之前的文章python奇遇记：迭代器和生成器 ，对生成器的概念应该很了解。生成器节省内存，用的时候才生成结果。\n# 生成器表达式\na = (x*x for x in range(10))\n\n# next生成值\nnext(a()) # 输出0\nnext(a()) # 输出1\nnext(a()) # 输出4\n与生成器产出数据不同的是，协程在产出数据的同时还可以接收数据，具体来说就是把yield 放在了表达式的右边。我们可以使用.send() 把数据发送给协程函数。\n def writer():\n    print('-> coroutine started')\n    for i in range(8):\n        w = yield\n        print(i+w)\n\nw = writer()\n# 本质还是生成器\n>>> w\n<generator object writer at 0x000002595BC57468>\n# 首先要用next()把协程激活\n>>> next(w)\n-> coroutine started\n# 发送数据\n>>> w.send(1)\n1\n# send到第八次之后会抛出异常\n# 因为协程已经结束了\n---------------------------------------------------------------------------\nStopIteration                             Traceback (most recent call last)\n第一步必须使用next() 激活协程函数，这样才能在下一步使用.send() 发送数据。\n可以看到，在第8次接收完数据之后，会产生结束的异常，因为程序流程结束了，这是正常现象。加个异常处理即可。如果需要在两个协程间传递数据呢？\ndef writer():\n    while True:\n        w = yield\n        print('>>', w)\n\ndef writer_wrapper(coro):\n    # 激活\n    next(coro)\n    while True:\n        # 异常处理\n        try:\n            x = yield\n            # 发送数据给writer\n            coro.send(x)\n        except StopIteration:\n            pass\nw = writer()\nwrap = writer_wrapper(w)\n# 激活\nnext(wrap)\nfor i in range(4):\n    wrap.send(i)\n# 输出\n>> 0\n>> 1\n>> 2\n>> 3\n上面的代码中，数据首先传递到writer_wrapper，之后再传递到writer 。\ndata——>writer_wrapper——>writer\n可以这么写，不过，又要预先激活，又要加异常，看起来有点麻烦啊。yield from 的出现可以解决这个问题，同样是传递数据：\ndef writer():\n    while True:\n        w = yield\n        print('>>', w)\n        \ndef writer_wrapper2(coro):\n    yield from coro\n一行代码解决问题。\n总之，yield from相当于提供了一个通道，使得数据可以在协程之间流转 。writer_wrapper2 中使用yield from coro时，coro此时获得控制权，在我们.send() 数据时，writer_wrapper2 被阻塞，直到writer 打印出结果。 \n在这个阶段，协程本质上还是由生成器构成的。\nbut，\n即使我们使用yield from 简化了流程，协程和生成器的知识理解起来还是有点懵逼，而且yield from 用在异步编程中有诸多不顺（asyncio以前就是用yield from），于是在3.5版本的python中，弃用了yield from ，新加入了两个关键字async 和await ，同时协程不再是生成器类型，而是原生的协程类型。\n现在我们定义一个协程要像下面这样：\nasync def func():\n    await 'some code'\n不用于异步的协程该怎么用，我还不知道。所以，协程的介绍到这里就结束啦。\n\n本人才疏学浅，上文中难免有些错误，还请各位品评指正。如果觉得写的还行，欢迎关注我的公众号MLGroup，讲解python和机器学习方面的知识。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "4"}