{"title": "给出一组非负整数，重新排列他们的顺序把他们组成一个最大的整数。 - hooyes 的专栏 ", "index": "python", "content": "文章为原创首发地址：https://hooyes.net/p/python-l...\n\n\n描述\n给出一组非负整数，重新排列他们的顺序把他们组成一个最大的整数。\n例\n给出 [1, 20, 23, 4, 8]，返回组合最大的整数应为 8423201\n给出 [1, 201, 20, 9, 8]，返回组合最大的整数应为 98202011\n给出 [1, 203, 20, 9, 8]，返回组合最大的整数应为 98203201\n\n算法\n我给简单好理解的两个排序算法：\n算法1：\n先把对比的数字转成字符，拼接后再转成整数进行大小对比，即 int(a+b) 与 int(b+a) 进行降序排列。代码1。\n算法2：\n每个元素逐个字符进行对比。代码2。\n代码1\n# Python2\n\nclass Solution:\n    def largestNumber(self, nums):\n        scmp = lambda a,b: int(b+a)-int(a+b)\n        res = ''.join(sorted(map(str, nums), cmp=scmp)).lstrip('0')\n        return res or '0'\n# Python3 \n\nfrom functools import cmp_to_key\nclass Solution:\n    def largestNumber(self, nums):\n        key = cmp_to_key(lambda a,b: int(b+a)-int(a+b))\n        res = ''.join(sorted(map(str, nums), key=key)).lstrip('0')\n        return res or '0'\n代码2\n\n# Python2 \n\nclass Solution:\n    def largestNumber(self,nums):\n        def cxx(x,y):\n            i = 0 \n            sx= str(x)\n            sy= str(y)\n            while i< len(str(min(x,y))):\n                if sx[i] > sy[i]:\n                    return 1\n                elif sx[i] < sy[i]:\n                    return -1\n                elif x == y:\n                    return 0\n                i+=1\n            if i == len(sx):\n                return -1 if sy[i]>sy[0] else 1\n            if i == len(sy):\n                return 1 if sx[i]>sx[0] else -1\n        nx = sorted(nums,cmp=lambda x,y:cxx(x,y),reverse=True)        \n        res = ''.join(map(str, nx)).lstrip('0')\n        return res or '0'     \n\n测试\nt = Solution()\nprint(t.largestNumber([1, 20, 23, 4, 8]))\n// 8423201\n以上代码已放到Hooyes的Github上开源，欢迎Fork或提建议。\nlargest-number.py\n运行 python largest-number.py 即可以测试。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}