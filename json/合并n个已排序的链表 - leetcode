{"title": "合并n个已排序的链表 - leetcode ", "index": "leetcode,算法,python", "content": "合并n个已排序的链表\nMerge k Sorted Lists\n\n合并n个已排序的链表，新链表中的每个节点必须是来自输入的原链表的节点（即不能构造新的节点），返回新链表的头部。\nMerge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.\n\nexample 1\ninput:\n[\n  3->5->8,\n  2->11>12,\n  4->8,\n]\noutput:\n2->3->4->5->8->8->11->12\n\n思路\n参照本人之前已发表的《合并两个已排序的链表》，只需要将此算法应用n-1次即可得到新链表。\n代码\n# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n    def __cmp__(self, other):\n        return self.val <= other\n\n\n\n\nclass Solution(object):\n\n    def mergeKLists_new(self, links):\n        \"\"\"\n        :type links: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        head = None\n        for i in links:\n            head = self.mergeTwoLists(head, i)\n        return head\n\n\n    # 为了方便阅读，给出之前的代码\n    # from mergeTwoLists，《合并两个已排序链表》的代码\n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if None in (l1, l2):\n            return l1 or l2\n        head = tail = l1 if l1.val <= l2.val else l2\n        a = l1 if l1.val > l2.val else l1.next\n        b = l2 if l1.val <= l2.val else l2.next\n        while a and b:\n            if a.val <= b.val:\n                tail.next = a\n                tail, a = tail.next, a.next\n            else:\n                tail.next = b\n                tail, b = tail.next, b.next\n        tail.next = a or b\n        return head\n本题以及其它leetcode题目代码github地址: github地址\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}