{"title": "【译】技能测试解决方案：Python中的数据科学（一） - 概率论与数理统计 ", "index": "python", "content": "本文是译文，可以转载，但需注明出处，点击这里可以获取原文，有删减。  本系列博文包含四篇文章：  【译】技能测试解决方案：Python中的数据科学（一）——Q1-Q15【译】技能测试解决方案：Python中的数据科学（二）——Q16-Q30【译】技能测试解决方案：Python中的数据科学（三）——Q31-Q45【译】技能测试解决方案：Python中的数据科学（四）——A1-A45及其解释  简介：  Python在数据科学界正在迅速发展。 我们越来越倾向于使用这样的生态系统——数据科学家对多种工具感到舒适，并根据特殊情况和堆栈使用正确的工具。  如果你打算把Python作为数据科学的首选工具，或正在学习它，那这是检查你技能的绝好机会。技能测试问题Q1\n上述数据集包含分类型和连续型变量，每个数据科学家都应该明白处理两者的方法不大一样。下列代码中，哪一项能计算出数据集中分类型变量的个数？\nA - (train.dtype == 'object').sum()\nB - (train.dtypes == object).sum()\nC - (train.dtypes == object).count()\nD – 以上选项都不能\nQ2\n上述数据集中有多个分类型变量，每一个分类型变量都有多个分类值。如，“Married” 变量就有两个分类值———— “Yes” and “No”。下列代码中，哪一项能计算出“Education”变量的不同分类值？\nA - train.Education.individuals()\nB - train.Education.distinct()\nC - train.Education.unique()\nD – 以上选项都不能\nQ3\n我们发现，上述数据集中，“LoanAmount”变量有许多缺失值。下列代码中，哪一项能统计出“LoanAmount”变量的缺失值数量？\nA - train.count().maximum() - train.LoanAmount.count()\nB - (train.LoanAmount == NaN).sum()\nC - (train.isnull().sum()).LoanAmount\nD – 以上选项都能\nQ4\n上述数据集中，“Credit_History”变量也有很多缺失值，我们首先需要分析“Credit_History”变量非空的用户群。我们创建一个叫 “new_dataframe”的数据框，该数据框包含“train”数据框中“Credit_History”变量非空的样本。下列哪行代码可以实现这个需求：\nA - new_dataframe = train[~train.Credit_History.isnull()]\nB - new_dataframe = train[train.Credit_History.isna()]\nC - new_dataframe = train[train.Credit_History.is_na()]\nD – 以上选项都不能\nQ5\n在上述数据集中，我们发现 Loan_id = LP001005的样本含有较少的信息（如：大多数变量都为空）。建模过程中，这类样本会产生较大的噪音，因此，建议过滤掉这类样本。如果一个样本中5个变量值为空，我们决定剔除它们，并把剩余的数据集存放在一个叫“temp”的数据框中。下列哪行代码可以实现这个需求：\nA - temp = train.dropna(axis=0, how='any', thresh=5)\nB - temp = train.dropna(axis=0, how='all', thresh=5)\nC - temp = train.dropna(axis=0, how='any', thresh=train.shape[1] - 5)\nD – 以上选项都不能\nQ6\n接下来，我们进行数据切片操作。第一个合理的操作是使数据满足建模需求。在上述数据中，我们发现， “Property_Area” 变量含有较少的“Semiurban”值。因此，我们决定把 “Semiurban” 和 “Urban”合并成一个新的类，并把这个类命名为“City”类，除此之外，我们还把“Rural” 重命名为 “Village”。下列哪行代码可以实现这个需求：\nA - >>> turn_dict = ['Urban': 'City', 'Semiurban': 'City', 'Rural': 'Village']\n    >>> train.loc[:, 'Property_Area'] = train.Property_Area.replace(turn_dict)\nB - >>> turn_dict = {'Urban': 'City', 'Semiurban': 'City', 'Rural': 'Village'}\n    >>> train.loc[:, 'Property_Area'] = train.Property_Area.replace(turn_dict)\nC - >>> turn_dict = {'Urban, Semiurban': 'City', 'Rural': 'Village'}\n    >>> train.iloc[:, 'Property_Area'] = train.Property_Area.update(turn_dict)\nD – 以上选项都不能 \nQ7\n到目前为止，你离建立第一个模型又进了一步。也许你会发现一些比较有趣的事情：“Gender”变量取值为“Male”且“Married”变量取值为“Yes”的用户占比较高。下列哪行代码可以检验这个假设？\nA - (train.loc[(train.Gender == 'male') && (train.Married == 'yes')].shape[1] / float(train.shape[0]))*100\nB - (train.loc[(train.Gender == 'Male') & (train.Married == 'Yes')].shape[1] / float(train.shape[0]))*100\nC - (train.loc[(train.Gender == 'male') and (train.Married == 'yes')].shape[0] / float(train.shape[0]))*100\nD – 以上选项都不能 \nQ8\n上述数据是训练集和测试集，注意到两个集合的变量并不匹配，如：训练集中有些字段并不在测试集中，反之亦然。假设两个集合均已“数据框”的形式入库，下列哪行代码可以找出测试集存在但是训练集不存在的变量：\nA - set(test.columns).difference(set(train.columns))\nB - set(test.columns.tolist()) - set(train.columns.tolist())\nC - set(train.columns.tolist()).difference(set(test.columns.tolist()))\nD – 以上选项都不能 \nQ9\n或许你会注意到，Python中绝大多数机器学习库及相应的算法都要求数据以数字的方式呈现。因此，我们需要对“Gender”变量进行转换，如：M转换成1，F转换成0。下列哪行代码可以实现这个需求？\nA - train.ix[:, 'Gender'] = train.Gender.applymap({'M':1,'F':0}).astype(int)\nB - train.ix[:, 'Gender'] = train.Gender.map({'M':1,'F':0}).astype(int)\nC - train.ix[:, 'Gender'] = train.Gender.apply({'M':1,'F':0}).astype(int)\nD – 以上选项都不能 \nQ10在上述数据集中，“Product_ID”一栏数据包含已售产品的唯一标识。可能出现这种情况：一些产品出现在测试集但是不出现在训练集中，这给建模造成一定的难度，因为对于新产品而言，没有它的“历史”信息。下列哪行代码可以验证测试集中的“Product_ID”是训练集的子集？\nA - train.Product_ID.unique().contains(test.Product_ID.unique())\nB - set(test.Product_ID.unique()).issubset(set(train.Product_ID.unique()))\nC - train.Product_ID.unique() = test.Product_ID.unique()\nD – 以上选项都不能 \nQ11\n上述数据中，“Age” 变量是一个分类型变量，把它转换成一个数值型变量或许更有意义。下列哪行代码可以实现把“Age” 变量的组平均值代替原始值。如：以8.5和21代替0-17和17-25？\nA - train['Age'] = train.Age.apply(lambda x: (np.array(x.split('-'), dtype=int).sum()) / x.shape)\nB - train['Age'] = train.Age.apply(lambda x: np.array(x.split('-'), dtype=int).mean())\nC – A和B都可以\nD – 以上选项都不能 \nQ12\n实际数据中，有一种情景是，数值型变量的值隐藏在某一个字符型变量中，建模前，我们必须清洗此类变量。例如：上述数据集中，“Ticket”变量包含一个或者两个模块，现假设我们所需数值始终存在该变量的最后一个模块中。下列哪行代码可以实现这个需求？\nA - train.Ticket.str.split(' ').str[0]\nB - train.Ticket.str.split(' ').str[-1]\nC - train.Ticket.str.split(' ')\nD – 以上选项都不能 \nQ13\n或许你已注意到，上述数据集是著名的泰坦尼克号数据集。该数据有很多缺失值，处理缺失值的一种方法是用“已知值”填充。我们决定对 “Age”变量进行如下填充：用同性别的“Age”的平均值填充，下列哪行代码可以实现这个需求？\nA - train = train.groupby('Sex').transform(lambda x: x.fillna(x.sum()))\nB - train['Age'] = train.groupby('Sex').transform(lambda x: x.fillna(x.mean())).Age\nC - train['Age'] = train.groupby('Sex').replace(lambda x: x.fillna(x.mean())).Age\nD – 以上选项都不能 \nQ14\n接下来，我们想知道乘客的位置是怎样影响乘客的生存概率的，一个假设是，“S” (S=SouthHampton)的乘客，尤其是女性乘客，在这次事故中生存概率会非常高。问题是，怎样计算来自“S”的女性乘客数量？\nA - train.loc[(train.Embarked == 'S') and (train.Sex == 'female')].shape[0]\nB - train.loc[(train.Embarked == 'S') & (train.Sex == 'female')].shape[0]\nC - train.loc[(train.Embarked == 'S') && (train.Sex == 'female')].shape[0]\nD – 以上选项都不能 \nQ15仔细观察“Name”变量，貌似每个“Name”都含有一个头衔，例如：“Braund, Mr. Owen Harris”含有“Mr.”头衔。下列哪行代码可以统计出乘客姓名中含有“Mr.”头衔的数量？\nA - (train.Name.str.find('Mr.')==False).sum()\nB - (train.Name.str.find('Mr.')>0).sum()\nC - (train.Name.str.find('Mr.')=0).sum()\nD – 以上选项都不能 \n友情链接：【译】技能测试解决方案：Python中的数据科学（二）——Q16-Q30【译】技能测试解决方案：Python中的数据科学（三）——Q31-Q45【译】技能测试解决方案：Python中的数据科学（四）——A1-A45及其解释\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "2"}