{"title": "Python学习之路13-记分 - VPointer ", "index": "python,pygame", "content": "《Python编程：从入门到实践》笔记。本篇是Python小游戏《外星人入侵》的最后一篇。\n1. 前言\n本篇我们将结束Pygame小游戏《外星人入侵》的开发。在本篇中，我们将添加如下内容：\n\n添加一个Play按钮，用于根据需要启动游戏以及在游戏结束后重启游戏；\n使玩家能提高等级，并在提高等级时加快节奏；\n添加一个记分系统\n\n2. 添加Play按钮\n首先为了通过点击Play按钮来开始游戏，需要在GameStats类的构造函数中将self.game_active设置为False。\n2.1 Button类\n为了添加Play按钮，我们需要先添加一个Button类。将这个类放在button.py模块中：\nimport pygame\n\nclass Button:\n    def __init__(self, ai_settings, screen, msg):\n        \"\"\"初始化按钮属性\"\"\"\n        self.screen = screen\n        self.screen_rect = screen.get_rect()\n\n        # 设置按钮尺寸和其他属性\n        self.width, self.height = 200, 50   # 解包，平行赋值\n        self.button_color = (0, 255, 0)\n        self.text_color = (255, 255, 255)\n        self.font = pygame.font.SysFont(None, 48)\n\n        # 创建按钮的rect对象，并使其居中\n        self.rect = pygame.Rect(0, 0, self.width, self.height)\n        self.rect.center = self.screen_rect.center\n\n        # 按钮的标签只需创建一次\n        self.prep_msg(msg)\n\n    def prep_msg(self, msg):\n        \"\"\"将msg渲染为图像，并使其在按钮上居中\"\"\"\n        self.msg_image = self.font.render(msg, True, self.text_color, self.button_color)\n        self.msg_image_rect = self.msg_image.get_rect()\n        self.msg_image_rect.center = self.rect.center\n\n    def draw_button(self):\n        # 绘制一个用颜色填充的按钮，再绘制文本\n        self.screen.fill(self.button_color, self.rect)\n        self.screen.blit(self.msg_image, self.msg_image_rect)\n\npygame将字符串渲染为图像来处理文本，通过pygame.font的render()方法来渲染文字，它的第一个参数是要渲染的字符串，第二个是抗锯齿设定（打游戏的老铁应该对这个词很熟悉~~），第三个是字体颜色，第四个是背景颜色，第四个参数如果不设定，将以透明背景的方式渲染文本。最后通过draw_button()方法在窗体中绘制Play按钮。\n2.2 修改alien_invasion.py\n在主程序中实例化一个Play按钮，并添加它的响应事件，以及将其画出。\n-- snip --\nfrom button import Button\n-- snip --\n\ndef run_game():\n    -- snip --\n    pygame.display.set_caption(\"Alien Invasion\")\n\n    # 创建Play按钮\n    play_button = Button(ai_settings, screen, \"Play\")\n    \n    -- snip --\n    # 开始游戏的主循环\n    while True:\n        # 增加了参数，为按钮添加响应事件\n        gf.check_events(ai_settings, screen, ship, bullets, stats, play_button, aliens)\n        -- snip --\n        # 增加了参数，在窗体中画出按钮\n        gf.update_screen(ai_settings, screen, ship, bullets, aliens, stats, play_button)\n\nrun_game()\n注意，不光新增了实例化按钮的代码，还修改了update_screen()和check_events()函数。\n2.3 修改game_functions.py\n修改update_screen()函数：在窗体中画出Play按钮\n# 增加了参数，记得修改主程序\ndef update_screen(ai_settings, screen, ship, bullets, aliens, stats, play_button):\n    -- snip --\n    # 如果游戏没启动，则显示Play按钮\n    if not stats.game_active:\n        play_button.draw_button()\n\n    # 让最近绘制的屏幕可见\n    pygame.display.flip()\n修改check_events()函数：为Play按钮添加响应事件\n# 增加了参数，记得修改主程序\ndef check_events(ai_settings, screen, ship, bullets, stats, play_button, aliens):\n    for event in pygame.event.get():\n        -- snip --\n        elif event.type == pygame.MOUSEBUTTONDOWN:\n            mouse_x, mouse_y = pygame.mouse.get_pos()\n            check_play_button(stats, play_button, mouse_x, mouse_y, ai_settings,\n                              screen, ship, aliens, bullets)\npygame.MOUSEBUTTONDOWN表示鼠标按下事件；通过pygame.mouse的get_pos()来获得鼠标点击处的坐标；最后，通过check_play_button()函数来响应鼠标点击事件，该函数的内容如下：\n新增check_play_button()函数：处理鼠标点击事件\ndef check_play_button(stats, play_button, mouse_x, mouse_y, ai_settings, screen,\n                      ship, aliens, bullets):\n    \"\"\"在玩家单机Play按钮时开始新游戏\"\"\"\n    if play_button.rect.collidepoint(mouse_x, mouse_y) and not stats.game_active:\n        # 隐藏光标\n        pygame.mouse.set_visible(False)\n        # 重置游戏统计信息\n        stats.reset_stats()\n        stats.game_active = True\n\n        # 清空外星人列表和子弹列表\n        aliens.empty()\n        bullets.empty()\n\n        # 创建一群新的外星人，并让飞船居中\n        create_fleet(ai_settings, screen, ship, aliens)\n        ship.center_ship()\n通过play_button.rect的collidepoint()方法来确定鼠标是否点击到了button，如果点击到了，并且当前游戏是“非启动”状态，则启动或者重置游戏；\n如果不对stats.game_active进行确认，则在游戏中，即使Play按钮消失了，鼠标点击它原来所在的地方，也会重置游戏。\n在游戏中，为了避免光标的影响，游戏时我们通过pygame.mouse的set_visible()方法将其隐藏；游戏结束时，重新显示光标，为此，需要修改ship_hit()函数：\ndef ship_hit(ai_settings, stats, screen, ship, aliens, bullets):\n    -- snip --\n    else:\n        -- snip --\n        pygame.mouse.set_visible(True)\n最后，程序的效果如下：\n\n3. 游戏提速\n每当消灭一批舰队后，我们就为游戏里的元素提个速，为此，需要修改settings.py和game_functions.py模块。\n3.1 修改settings.py\n添加一个提速倍率参数，并增加两个方法：\nclass Settings:\n    def __init__(self):\n        -- snip --\n        # 以什么样的速度提节奏\n        self.speedup_scale = 1.1\n        # 前面有四个属性放到了该方法中\n        self.initialize_dynamic_settings()\n\n    def initialize_dynamic_settings(self):\n        \"\"\"初始化随游戏进行而变化的设置\"\"\"\n        self.ship_speed_factor = 1.5\n        self.bullet_speed_factor = 3\n        self.alien_speed_factor = 1\n\n        # 外星舰队方向标志：1向右，-1向左\n        self.fleet_direction = 1\n\n    def increase_speed(self):\n        \"\"\"提高速度\"\"\"\n        self.ship_speed_factor *= self.speedup_scale\n        self.bullet_speed_factor *= self.speedup_scale\n        self.alien_speed_factor *= self.speedup_scale\n我们将需要修改的四个参数放到了initialize_dynamic_settings()方法中，increase_speed()方法用于动态改变游戏参数。\n3.2 修改game_functions.py\n每消灭一批外星舰队，就对游戏提速，需要修改check_bullet_alien_collisions()函数：\ndef check_bullet_alien_collisions(ai_settings, screen, ship, aliens, bullets):\n    -- snip --\n    if len(aliens) == 0:\n        -- snip --\n        ai_settings.increase_speed()\n        -- snip --\n当重新开始游戏时，需要将这些被修改了的参数改回默认值，为此，需要修改check_play_button()函数：\ndef check_play_button(stats, play_button, mouse_x, mouse_y, ai_settings, screen,\n                      ship, aliens, bullets):\n    if play_button.rect.collidepoint(mouse_x,\n                                     mouse_y) and not stats.game_active:\n        # 重置游戏设置\n        ai_settings.initialize_dynamic_settings()\n        -- snip --\n4. 记分板\n下面我们将实现一个记分系统，实时跟踪玩家的得分，并显示最高得分，当前等级和余下的飞船数。首先，我们需要创建一个Scoreboard类。\n4.1 新增scoreboard.py\n新增一个Scoreboard类，用作屏幕中的记分板，它的屏幕正中央上方部分是最高分数，屏幕右边是当前分数和等级，左上角是剩余的飞船数量，飞船数量用图片表示，因此，我们还要将Ship类更改为从Sprite继承。\nimport pygame\nfrom pygame.sprite import Group\nfrom ship import Ship\n\nclass Scoreboard:\n    \"\"\"显示得分信息的类\"\"\"\n    def __init__(self, ai_settings, screen, stats):\n        \"\"\"初始化显示得分涉及的属性\"\"\"\n        self.screen = screen\n        self.screen_rect = screen.get_rect()\n        self.ai_settings = ai_settings\n        self.stats = stats\n\n        # 显示得分信息时使用的字体设置\n        self.text_color = (30, 30, 30)\n        self.font = pygame.font.SysFont(None, 48)\n\n        # 生成当前得分、最高得分、当前等级和当前剩余的飞船数\n        self.prep_score()\n        self.prep_high_score()\n        self.prep_level()\n        self.prep_ships()\n\n    def prep_score(self):\n        \"\"\"将得分转换为图片\"\"\"\n        rounded_score = round(self.stats.score, -1)\n        # 在得分中插入逗号\n        score_str = \"{:,}\".format(rounded_score)\n        self.score_image = self.font.render(score_str, True, self.text_color,\n                                            self.ai_settings.bg_color)\n\n        # 将得分放在屏幕右上角\n        self.score_rect = self.score_image.get_rect()\n        self.score_rect.right = self.screen_rect.right - 20\n        self.score_rect.top = 20\n\n    def prep_high_score(self):\n        \"\"\"将最高得分转化为图像\"\"\"\n        high_score = round(self.stats.high_score, -1)\n        high_score_str = \"{:,}\".format(high_score)\n        self.high_score_image = self.font.render(high_score_str, True, self.text_color,\n                                                 self.ai_settings.bg_color)\n\n        # 将最高得分放在屏幕顶部中央\n        self.high_score_rect = self.high_score_image.get_rect()\n        self.high_score_rect.centerx = self.screen_rect.centerx\n        self.high_score_rect.top = self.score_rect.top\n\n    def prep_level(self):\n        \"\"\"将等级转化为图像\"\"\"\n        self.level_image = self.font.render(str(self.stats.level), True, self.text_color,\n                                            self.ai_settings.bg_color)\n\n        # 将等级放在得分下方\n        self.level_rect = self.level_image.get_rect()\n        self.level_rect.right = self.score_rect.right\n        self.level_rect.top = self.score_rect.bottom + 10\n\n    def prep_ships(self):\n        \"\"\"显示还余下多少艘飞船\"\"\"\n        self.ships = Group()\n        for ship_number in range(self.stats.ships_left):\n            ship = Ship(self.ai_settings, self.screen)\n            ship.rect.x = 10 + ship_number * ship.rect.width\n            ship.rect.y = 10\n            self.ships.add(ship)\n\n    def show_score(self):\n        \"\"\"在屏幕上显示得分板\"\"\"\n        self.screen.blit(self.score_image, self.score_rect)\n        self.screen.blit(self.high_score_image, self.high_score_rect)\n        self.screen.blit(self.level_image, self.level_rect)\n        # 绘制飞船\n        self.ships.draw(self.screen)\n4.2 修改settings.py\n设置外星人的分数，外星人分数增长的速度：\nclass Settings:\n    def __init__(self):\n        -- snip --\n        # 外星人点数的提高速度\n        self.score_scale = 1.5\n\n        self.initialize_dynamic_settings()\n\n    def initialize_dynamic_settings(self):\n        -- snip --\n        # 记分, 每一个外星人的分数\n        self.alien_points = 50\n\n    def increase_speed(self):\n        -- snip --\n        # 动态增加每个外星人的分数\n        self.alien_points = int(self.alien_points * self.score_scale)\n4.3 修改game_stats.py\n在GameStats中设置一个用于记录最高分的属性，也正因此，应该将它放在构造函数中，它只会变大，在没有重新运行游戏前，它不会被重置为0；在reset_stats()方法中，初始化score和level两个属性，这两个属性每点一次Play按钮都会被重置。对于level这个属性，每消灭一批舰队，level就加1.\nclass GameStats:\n    def __init__(self, ai_settings):\n        -- snip --\n        # 在任何情况下都不应重置最高得分\n        self.high_score = 0\n\n    def reset_stats(self):\n        -- snip --\n        self.score = 0\n        self.level = 1\n4.4 修改主程序alien_invasion.py\n-- snip --\nfrom scoreboard import Scoreboard\n\ndef run_game():\n    -- snip --\n    # 创建计分板\n    score = Scoreboard(ai_settings, screen, stats)\n\n    # 开始游戏的主循环\n    while True:\n        # 添加score参数\n        gf.check_events(ai_settings, screen, ship, bullets, stats, play_button,\n                        aliens, score)\n\n        if stats.game_active:\n            ship.update()\n            # 添加score参数\n            gf.update_bullets(bullets, aliens, ship, screen, ai_settings, stats, score)\n            # 添加score参数\n            gf.update_aliens(ai_settings, aliens, ship, screen, bullets, stats, score)\n        # 添加score参数\n        gf.update_screen(ai_settings, screen, ship, bullets, aliens, stats,\n                         play_button, score)\n从上面的注释可以看出，我们生成了一个计分板的实例score；game_functions.py中的四个函数都要添加score参数，换句话说，这四个函数都要修改，下面我们逐一修改这四个函数。\n4.5 修改game_functions.py\n4.5.1 修改参数\n有几个函数只需要在参数列表中增加score参数：\n# 增加score参数\ndef check_events(ai_settings, screen, ship, bullets, stats, play_button, aliens, score):\n    for event in pygame.event.get():\n        -- snip --\n        elif event.type == pygame.MOUSEBUTTONDOWN:\n            mouse_x, mouse_y = pygame.mouse.get_pos()\n            # 增加score参数, 该函数有所改动\n            check_play_button(stats, play_button, mouse_x, mouse_y, ai_settings,\n                              screen, ship, aliens, bullets, score)\n\n# 增加score参数\ndef update_bullets(bullets, aliens, ship, screen, ai_settings, stats, score):\n    -- snip --\n    # 增加score参数，该函数有所改动\n    check_bullet_alien_collisions(ai_settings, screen, ship, aliens, bullets, stats, score)\n\n# 增加score参数\ndef update_aliens(ai_settings, aliens, ship, screen, bullets, stats, score):\n    -- snip --\n    if pygame.sprite.spritecollideany(ship, aliens):\n        # 增加score参数，该函数有所改动\n        ship_hit(ai_settings, stats, screen, ship, aliens, bullets, score)\n    # 增加score参数，该函数有所改动\n    check_aliens_bottom(ai_settings, stats, screen, ship, aliens, bullets, score)\n\n# 增加score参数，该函数有所改动\ndef update_screen(ai_settings, screen, ship, bullets, aliens, stats, play_button, score):\n    -- snip --\n    aliens.draw(screen)\n    # 在if语句前面添加绘制计分板的代码\n    # 显示得分\n    score.show_score()\n\n    if not stats.game_active:\n        play_button.draw_button()\n    -- snip --\n接下来是改动较多的函数。\n4.5.2 修改check_play_button()函数\n# 添加了score参数\ndef check_play_button(stats, play_button, mouse_x, mouse_y, ai_settings, screen,\n                      ship, aliens, bullets, score):\n    \"\"\"在玩家单机Play按钮时开始新游戏\"\"\"\n    if play_button.rect.collidepoint(mouse_x,\n                                     mouse_y) and not stats.game_active:\n        -- snip --\n        stats.game_active = True  # 这一句不是新增的\n        \n        # 以下四行是新增的\n        score.prep_score()\n        score.prep_high_score()\n        score.prep_level()\n        score.prep_ships()\n\n        # 清空外星人列表和子弹列表\n        -- snip --\n首先参数列表添加了score参数，if判断中还添加了四行生成计分板的代码。之所以这里要添加这四行代码，其实是为了当你重新开始（也就是第二次及以后点击Play按钮）游戏时，计分板能正确显示。\n当第一运行游戏时，没有这四行也能正确显示计分板。但是从第二次点击Play开始，如果没有这四行，游戏的各个参数虽然更新了（通过check_play_button()中的各种重置函数得到了更新），可这些更新还没有让记分板中这四个参数的图像得到重新绘制，即属性的更新没有自动触发score的这四个函数。所以显示会不正确，因此必须在这里添加这四行代码。\n4.5.3 修改update_screen()函数\n# 增加了score参数\ndef update_screen(ai_settings, screen, ship, bullets, aliens, stats, play_button, score):\n    -- snip --\n    # 增加显示得分的代码\n    score.show_score()\n\n    if not stats.game_active:\n        -- snip --\n4.5.4 修改update_bullets()和update_aliens()函数\n这俩函数只是增加参数而已。\n# 增加了score参数\ndef update_bullets(bullets, aliens, ship, screen, ai_settings, stats, score):\n    -- snip --\n    # 增加了score参数, 函数有改动\n    check_bullet_alien_collisions(ai_settings, screen, ship, aliens, bullets, stats, score)\n\n# 增加了score参数\ndef update_aliens(ai_settings, aliens, ship, screen, bullets, stats, score):\n    -- snip --\n    # 检测外星人和飞船之间的碰撞\n    if pygame.sprite.spritecollideany(ship, aliens):\n        # 增加了score参数, 函数有改动\n        ship_hit(ai_settings, stats, screen, ship, aliens, bullets, score)\n    # 增加了score参数\n    check_aliens_bottom(ai_settings, stats, screen, ship, aliens, bullets, score)\ncheck_aliens_bottom()内也变化也不大，该函数的变化不再以代码的形式单独列出：\n该函数增加了一个score参数，它内部调用了ship_hit()函数，为这个调用也增加score参数。这就是全部变化。\n4.5.5 修改check_bullet_alien_collisions()函数\n# 增加了score参数\ndef check_bullet_alien_collisions(ai_settings, screen, ship, aliens, bullets, stats, score):\n    collisions = pygame.sprite.groupcollide(bullets, aliens, True, True)\n\n    if collisions:\n        for aliens in collisions.values():\n            stats.score += ai_settings.alien_points * len(aliens)\n            # 其实这里可以将其放到for循环之外，应为并不能立刻就呈现分数变化\n            # 要等到主程序中的update_screen()中才能呈现\n            score.prep_score()\n        # 该函数是新增的\n        check_high_score(stats, score)\n\n    if len(aliens) == 0:\n        # 删除现有的子弹并创建新的舰队\n        bullets.empty()\n        ai_settings.increase_speed()\n\n        # 提高等级\n        stats.level += 1\n        score.prep_level()\n\n        create_fleet(ai_settings, screen, ship, aliens)\n首先我们增加了一个判断语句，用于根据消灭的外星人来增加分数，由于有可能一颗子弹打到多个外星人但只算了一个外星人的分数，所有用循环来确保消灭掉的每一个外星人都得到了统计。collisions是一个字典，这里子弹是键，该子弹消灭的外星人对象为值（是个列表）。\n我们还新增了一个更新最高积分的函数check_high_score()，它的代码如下：\ndef check_high_score(stats, score):\n    \"\"\"检查是否诞生了新的最高得分\"\"\"\n    if stats.score > stats.high_score:\n        stats.high_score = stats.score\n        score.prep_high_score()\n第二个if中，添加了增加等级的语句，紧跟着的是重新在计分板中绘制等级图像。\n4.5.6 修改ship_hit()和check_aliens_bottom()函数\n# 增加了score参数\ndef ship_hit(ai_settings, stats, screen, ship, aliens, bullets, score):\n    if stats.ships_left > 0:\n        stats.ships_left -= 1\n\n        # 更新记分牌\n        score.prep_ships()\n        # 清空外星人列表和子弹列表\n        -- snip --\n4.6 最后运行效果\n至此所有的添加都已经结束，下图是游戏的最终效果：\n\n5. 小结\nPython小游戏告一段落，一共三篇文章。本文中讲述了：\n\n如何创建用于开始新游戏的Play按钮；\n如何检测鼠标点击事件；\n如何在游戏处于活动状态时隐藏光标；\n如何随游戏的进行调整节奏；\n如何实现记分系统；\n以及如何以文本和非文本方式显示信息。\n\n后三篇文章将是使用Python来进行数据统计分析、绘图等内容。\n\n迎大家关注我的微信公众号\"代码港\" & 个人网站 www.vpointer.net ~\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}