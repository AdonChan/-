{"title": "Python - 装饰器decorator - python学习+自动化测试实践 ", "index": "python,decorator", "content": "\n【题外话】心塞塞  \\ 心情down down down \\ 有段时间没用装饰器了，然后然后问着就跪了~~~回来翻了翻资料和代码......\n\n一、什么是装饰器\n装饰器，decorator，本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。\n装饰器通过不修改核心代码而增强核心代码部分的功能。例如在函数前插入日志、权限校验、事务处理等场景。而且可以抽离出大量与函数功能无关的雷同代码并重用。\n二、早期实现：不是装饰器的装饰器\nPython中函数也可以看做是一个对象，可以赋值给变量，并通过变量调用该函数。\n例如：\ndef foo():\n   print(\"2017-06-08\")\nf = foo    # 将函数赋值给变量，f为函数对象\nf()\n# 返回结果：\n2017-06-08\n三、语法糖@ 实现简单装饰器\n假设现在要增强foo()的功能，例如，在函数调用前打印日志。但是又不希望修改foo()函数的定义。在这种代码运行期间动态增加功能的方式，称之为“装饰器”。如下：\ndef testfunc(func):\n    print('testfunc')\n    def wrapper():\n        print(\"%s %s() called\" %(time.ctime(),func.__name__))\n        return func()\n    return wrapper\n@testfunc \ndef foo():\n    print('foo1()')\n\nfoo()  # 相当于执行testfunc(foo) ->wrapper(foo) -> foo()\n执行结果：\ntestfunc\nWed Sep 12 15:01:13 2018 foo() called\nfoo1()\n说明：执行foo()前，先执行testfunc(foo)，再执行wrapper()，返回时调用foo()本身。\n四、接收特定类型参数的装饰器\n装饰器可以接收参数，当调用装饰器返回的函数时，也就调用了包裹函数，把参数传入包裹函数，它将参数传递给被装饰的函数。\n如下：\ndef testfunc_with_args(func):\n    def wrapper_argus(arg1, arg2):\n        print(\"I got args! Look:\", arg1, arg2)\n        func(arg1, arg2)\n    return wrapper_argus\n@testfunc_with_args\ndef full_name(first_name, last_name):  # 带参数，将参数传给被装饰的函数\n    print(\"My name is\", first_name, last_name)\n\nfull_name(\"Peter\", \"Venkman\")  # 调用\n执行结果：\nI got args! Look: Peter Venkman\nMy name is Peter Venkman\n五、带不定参数的装饰器\n当有多个函数需要调用装饰器，但是函数的参数各不同时，该如何实现呢？总不能一个函数对应一个装饰器吧。这时候就可以用带不定参数的装饰器进行实现。如下：\ndef log(func):\n    def wrapper(*args,**kwargs):        # 可接受各种参数\n        print('call %s():'% func.__name__)\n        return func(*args,**kwargs)     # 返回一个函数\n    return wrapper                      # 装饰器返回一个函数，进入到wrapper()\n\n@log      # @log放到now()的定义处，相当于执行语句：now = log(now)\ndef now_1(a,b):\n    print('now()1:a+b = ',a+b)\n@log\ndef now_2(a,b,c):\n    print('now_2():a+b+c = ',a+b+c)\n\nnow_1(1,2)\nnow_2(1,2,3)\n运行一下哦~\n六、多个装饰器\n当一个函数想要加入多项功能时，可以考虑使用多层装饰器，就是要注意一下装饰器的执行顺序。举个栗子：\n# 注意代码的执行顺序\ndef deco_1(func):\n    print('------111111------')\n    def wrapper(*args,**kwargs):    # 包裹函数，参数与原函数的参数一致\n        print('start: this is deco_1.')\n        func(*args,**kwargs)\n        print('end: deco_1.')\n    return wrapper  # 返回值是一个包裹函数\ndef deco_2(func):\n    print('------222222------')\n    def wrapper(*args,**kwargs):\n        print('start: this is deco_2.')\n        func(*args,**kwargs)\n        print('end: deco_2.')\n    return wrapper\n\n@deco_1\n@deco_2\ndef now_1(a,b):\n    print('now()1:a+b = ',a+b)\n\nnow_1(1,2)\n运行结果：\n# 结果，注意执行顺序：\n------222222------\n------111111------\nstart: this is deco_1.\nstart: this is deco_2.\nnow()1:a+b =  3\nend: deco_2.\nend: deco_1.\n七、装饰器本身带参数\n除了给被装饰的函数带参数，装饰器本身也可以带参数。\ndef logging(level):\n    def wrapper(func):\n        def inner_wrapper(*args, **kwargs):\n            print(\"[{level}]: enter function {func}()\".format(level=level, func=func.__name__))\n            return func(*args, **kwargs)\n        return inner_wrapper\n    return wrapper\n    \n@logging(level='INFO')\ndef say(something):\n    print(\"say {}!\".format(something))\n\n@logging(level='DEBUG')\ndef do(something):\n    print(\"do {}...\".format(something))\n\nsay('hello')\ndo(\"my work\")\n执行结果：\n# 执行结果：\n[INFO]: enter function say()\nsay hello!\n[DEBUG]: enter function do()\ndo my work...\n\n❤ thanks for watching, keep on updating...\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}