{"title": "Django前后端分离实践 - 个人文章 ", "index": "mysql,python,django", "content": "2018.9.6更新：尝试了一下REST framework实现前后端分离，新的文章如下Django前后端分离之REST framework初试2018.8.27更新：可另外用 restful API 实现前后端分离，这篇文章可能局限性太大，只是个人的入门实践\n刚刚学习前端快一年，后台方面了解甚少，于是决定踩踩坑，学习一下。于是就选了django这个框架（刚刚好顺便学了python）不想使用框架的提供的模板功能，于是看看前后端分离 + MySQL数据库如何实现之间也踩了很多坑，从MySQL配置的版本问题，到本地测试的跨域问题等等啊，废话少说，看目录\n目录：\n一、创建项目二、配置MySQL三、创建应用四、结语\n过程比较详细记录了前后端分离的每一步，算是小白实践吧哈哈\n一、创建项目\n到想要创建项目的文件夹下运行命令\n$ django-admin startproject dj_experiment    //后面就是项目名字咯\n创建完后生成目录，具体什么意思请看官网文档（https://docs.djangoproject.co...）\ndj_experiment/\n    manage.py\n    dj_experiment/\n        __init__.py\n        settings.py\n        urls.py\n        wsgi.py\n二、配置MySQL\n这里我们默认安装好MySQL了，并且为这个小实验创建一个数据库叫做'dj_experiment_db'Django的配置文件中将SQLite作为默认数据库。同时Django支持sqlite3，MySQL等数据库，在settings.py中修改配置就好，而且因为有丰富的API，所以如果改动数据库，也不需要修改models.py中的代码以下分为几个步骤：\n1.安装pymysql数据库驱动：\npip install pymysql\npython3不支持MySQLdb，所以用pymysql代替\n2.配置Django中的DATABASE\n在settings.py中找到DATABASE\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.mysql',    #数据库引擎\n        'NAME': 'dj_experiment_db',  #数据库名\n        'USER': 'root',   #账户名\n        'PASSWORD': 'password', #密码\n        'HOST': 'localhost', #主机\n        'PORT': '3306', #端口\n    }\n\n}\n接着在_init_.py添加如下代码\nimport pymysql\npymysql.install_as_MySQLdb()\n然后设置TIME_ZONE为自己的时区\nTIME_ZONE = 'Asia/Shanghai'\n最后执行数据库迁移命令\npython manage.py makemigrations\npython manage.py migrate\n然后我们登录数据库，连接数据库dj_experiment_db，输入show tables；就可以看到django创建的框架应用的表了\n三、创建应用，编写views\n到dj_experiment目录下运行命令，这里我们创建一个注册的应用，然后在页面里面循环渐进实现做以下前后端分离，开发后台接口的两个小实验：1.ajax与get的后端接口2.ajax与post提交两个简单的小实验，但过程中有些问题：本地测试的跨域问题，CSRF问题。我们在实践过程中再逐一解决\n1.ajax与get的后台接口\n现在先创建应用register（先在这个应用实现get，再实现post）：\n$ python manage.py startapp register\n创建完后目录如下：\nregister/\n    __init__.py\n    admin.py\n    apps.py\n    migrations/\n        __init__.py\n    models.py\n    tests.py\n    views.py\n在views.py下创建接口，我们先举个简单的例子——hello接口代码如下\nfrom django.shortcuts import render\nfrom django.http import JsonResponse\n\ndef hello(request):\n    return JsonResponse({'result': 200, 'msg': '连接成功'})\n然后将一个URL映射给此接口在register目录中新建一个urls.py文件，输入以下代码\nfrom django.urls import path\nfrom . import views\nurlpatterns = {\n    path(\"helloApi\", views.hello, name='hello')#第一个参数表示路径\n}\n接着在dj_experiment/urls.py中指定我们创建的register.urls模块\nfrom django.contrib import admin\nfrom django.urls import path, include\nurlpatterns = [\n    path(\"register/\", include(\"register.urls\")),\n    path('admin/', admin.site.urls),\n]\n最后打开django的开发服务器，测试一下接口\n$ python manage.py runserver\n浏览器访问：http://localhost:8000/register/helloApi可以看到如下显示因为没有进行utf-8编码，所以显示的是Unicode编码这里推荐用火狐浏览器进行接口测试，看起来更加详细ok，接口开发完毕了，我们怎么进行前后端分离呢在根目录创建一个html文件夹，并在里面创建register.html,，如图我们先进行get后台接口的访问先编写一个ajax的封装函数ajaxResponse(xhr, 连接成功时执行的函数，连接失败时执行的函数)便于我们调用，代码如下\n    function ajaxResponse(xhr,successFunction,falseFunction) {\n    xhr.onreadystatechange = function () {\n        if (xhr.readyState === 4) {\n            console.log(xhr.status);\n            if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304) {\n                alert(\"成功\");\n                successFunction();\n            } else {\n                alert(\"失败\" + xhr.status);\n                falseFunction();\n            }\n        }\n    }\n}\n接下来编辑register.html如下：\n<div id=\"getHelloApiDiv\" style=\"background: aqua;height: 100px;width: 100px\"></div>\n<script>\n    let getApiDiv = document.querySelector('#getHelloApiDiv');\n    let xhr = new XMLHttpRequest();\n    getApiDiv.onclick = function(){\n        ajaxResponse(\n        xhr,\n        function () {\n            let helloText = JSON.parse(xhr.responseText);\n            getApiDiv.innerText = helloText.msg;\n        },function () {\n        }\n    );\n    xhr.open('get','http://localhost:8000/register/helloApi'); //接口写在这里\n    xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded;charset=utf-8');\n    xhr.send(null);\n    };\n</script>\n然后我们来解决本地测试时的跨域问题在register/views.py中编写一个返回html的接口，代码如下，注意import了render_to_response方法\nfrom django.shortcuts import render, render_to_response\nfrom django.http import JsonResponse\n\n# Create your views here.\ndef registerPage(request):\n    return render_to_response(\"register.html\")\n接着同理在register/urls.py中加入接口路径，最后是这样子的代码\nfrom django.urls import path\nfrom . import views\nurlpatterns = {\n    path(\"helloApi\", views.hello, name='hello'),\n    path(\"registerPage\", views.registerPage, name='registerPage')\n}\n最后浏览器访问http://localhost:8000/register/registerPage并且点击方块，接受msg成功   （疑问：放在服务器端的话是否需要这样？）\n2.ajax与post的后台接口—注册用户\n现在我们将创建真正的应用，与MySQL进行交互django通过模型与数据库进行交互\n第一步：定义模型\n我们叫这个模型为UserInfo，字段有username和password，所以代码如下（__str__方法是为了方便命令行显示与管理页面显示）\nfrom django.db import models\n\n# Create your models here.\nclass UserInfo(models.Model):\n    username = models.CharField(max_length=16)\n    password = models.CharField(max_length=20)\n    def __str__(self):\n        return self.username\n第二步：激活模型\n创建模型后，django可以为应用创建数据库schema和与username，password对象进行交互的python数据库API。现在我们要做的是激活模型\n首先在settings.py的INSTALLED_APPS中添加设置\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'register.apps.RegisterConfig',#这里\n]\n接着运行命令，检测模型文件的修改，并把修改的部分储存为一次迁移（注意这里还没有修改）\n$ python manage.py makemigrations register\n然后可以运行命令看看等会的迁移命令会执行哪些SQL语句（这一步可干可不干）\n$ python manage.py sqlmigrate register 0001\n最后就执行迁移命令\n$ python manage.py migrate\n显示如下（WARNINGS是对MySQL Strict Mode 的提示）：\n之后可以在MySQL下看见django创建的表\n（这里可以用命令行尝试django提供的api或者配置并打开管理员页面，可以去官网看看怎么做https://docs.djangoproject.co...）\n第三步编写view注册视图：\ndjango自带CSRF防护机制，所以我们这里加个@csrf_exempt屏蔽装饰器\n#新的引入文件\nfrom django.views.decorators.csrf import csrf_exempt\nimport json\nfrom .models import UserInfo\n\n@csrf_exempt #屏蔽装饰器器\ndef registerApi(request):\n    if request.method == 'POST':\n        req = json.loads(request.body) #取得数据\n        userID = req['userID']\n        pwd = req['pwd']\n        searchArray = UserInfo.objects.get_or_create(username=userID) #尝试创建用户\n        print(searchArray)\n        if searchArray[1] == True:\n            return JsonResponse({'result': 200, 'msg':'注册成功'})\n        else:\n            return JsonResponse({'result': 200, 'msg':'已有重复用户名'})\n同样urls中记得改配置：\nurlpatterns = [\n    path(\"helloApi\", views.hello, name='hello'),\n    path(\"registerPage\", views.registerPage, name='registerPage'),\n    path(\"registerApi\", views.registerApi, name='registerApi')\n]\n接着编写html页面\n<p>账号：</p><input type=\"text\" id=\"userID\">\n<p>密码：</p><input type=\"password\" id=\"pwd\">\n<button id=\"submit\">注册</button>\n还有js\n    let subBt = document.getElementById('submit');\n    subBt.onclick = function () {\n        let userID = document.getElementById('userID').value;\n        let pwd = document.getElementById('pwd').value;\n        let xhrRegister = new XMLHttpRequest();\n        ajaxResponse(xhrRegister,\n        function () {\n            let respones = JSON.parse(xhrRegister.responseText);\n            alert(respones.msg);\n        },function () {\n            });\n        let user = {\n            userID:userID,\n            pwd:pwd\n        };\n        xhrRegister.open('post', 'http://127.0.0.1:8000/register/registerApi');\n        xhrRegister.setRequestHeader('Content-type', 'application/x-www-form-urlencoded;charset=utf-8');\n        xhrRegister.send(JSON.stringify(user));\n};\n注册成功\n还有注册失败\n四、结语\n简单的实践目前就到此为止啦，做这次实践的主要目的是了解后台的框架，之中还有很多没有去学习，比如如何在服务器上部署Django，Token验证，数据库操作等等有什么问题或者哪里不对大家提出来讨论下吧\n参考资料：MySQL驱动：https://blog.csdn.net/liuweiy...django数据库：https://code.ziqiangxuetang.c...配置MySQL：https://www.cnblogs.com/wcwni...屏蔽装饰器：https://blog.csdn.net/lw_zhao...django加载静态网页：https://blog.csdn.net/github_...\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "1"}