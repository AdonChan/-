{"title": "flask源码阅读系列一config模块 - 倚楼听风雨 ", "index": "flask,python", "content": "import_string\n先来分析一下这个动态导入函数：werkzeug.utils.import_string\ndef import_string(import_name, silent=False):\n    \"\"\"基于字符串动态导入对象。字符串有两种形式写法用点来分割对象名(``xml.sax.saxutils.escape``)和用冒号来分割对象名\n(``xml.sax.saxutils:escape``).\nsilent决定发生异常时是返回None还是抛出一些异常（安静，挺形象的。）\n    \"\"\"\n\n    import_name = str(import_name).replace(':', '.')\n    try:\n        try:\n            #首先假设import_name是一个包名或者模块名(非对象名)。\n            __import__(import_name)\n        except ImportError: \n            if '.' not in import_name: #没有点说明即使我们假设错误，也没法继续尝试。故而立即抛出异常\n                raise\n        else:\n        #如果导入正确，那么可以从sys.modules字典里面获取已经导入的模块或包.\n        #为什么要通过sys.modules[import_name]返回而不是直接return  __import__(import_name)呢？因为__import__在没有提供fromlist参数时，返回值策略为返回第一个点之前的顶级包对象，比如'os.path'返回的是os而不是os.path.\n            return sys.modules[import_name]\n        #如果import_name不是包名或模块名，而是具体的对象、函数名。\n        module_name, obj_name = import_name.rsplit('.', 1)\n        try:\n        #相当于from module_name import obj_name\n            module = __import__(module_name, None, None, [obj_name])\n        except ImportError:\n            #如果支持的模块没有被父模块设置好的情形中会导入失败，这时需要先导入父模块(或包)。典型的例子就是logging与logging.config。\n            module = import_string(module_name)\n\n        try:\n        #通过getarr从模块中返回具体对象\n            return getattr(module, obj_name)\n        except AttributeError as e:\n            raise ImportError(e)\n\n    except ImportError as e:\n        if not silent:\n            reraise(\n                ImportStringError,\n                ImportStringError(import_name, e),\n                sys.exc_info()[2]) \nflask.config模块\nimport os\nimport types\nimport errno\n\nfrom werkzeug.utils import import_string\nfrom ._compat import string_types, iteritems\nfrom . import json\n\nclass Config(dict):\n    \"\"\"config类除了正常的dict职责外，还具有从py文件(模块)、对象或字典填充值的能力。\n        from_envvar会调用from_pyfile会调用from_object，另还有from_json会调用from_mapping\n       还有一个便利的get_namespace方法。\n    \"\"\"\n\n    def __init__(self, root_path, defaults=None): # root_path查找py文件的基路径。\n        dict.__init__(self, defaults or {})\n        self.root_path = root_path\n    def from_envvar(self, variable_name, silent=False):\n        \"\"\"variable_name是一个环境变量名，指向一个py文件。返回bool值，是否加载填充成功。\n        \"\"\"\n        rv = os.environ.get(variable_name)\n        #...省略部分校验逻辑...\n        #这里调用from_pyfile\n        return self.from_pyfile(rv, silent=silent)\n\n    def from_pyfile(self, filename, silent=False):\n        filename = os.path.join(self.root_path, filename)\n        #利用标准库types来动态创建一个模块对象，名为config,文件属性(__file__)指向设置为前面的filename\n        d = types.ModuleType('config')\n        d.__file__ = filename\n        try:\n            with open(filename) as config_file:\n                #exec,compile都是内置函数。\n                #exec(object[, globals[, locals]]) 参数object可以为str或者字节码对象，返回None。这里可以理解为解释字节码，并将字节码执行过程中的全局变量存入d.__dict__字典中。\n                #compile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1)\n                #compile用于动态编译文件为字节码对象，其中'exec'为编译模式，代表整个文件(多行)编译，其余模式还有'eval'单行语句编译，'single'单行交互式语句编译。\n                exec(compile(config_file.read(), filename, 'exec'), d.__dict__)\n        except IOError as e:\n            ...略pass...\n        #这里调用from_object,from_object才是关键。\n        self.from_object(d)\n        return True\n\n    def from_object(self, obj):\n        \"\"\"参数obj可以是str(需要被导入的对象)或者一个对象。它只允许模块或对象中的大写属性填充进来，小写的忽略。\n        你可以这样来使用本方法\n            app.config.from_object('yourapplication.default_config')或者\n            from yourapplication import default_config\n            app.config.from_object(default_config)\n        \"\"\"\n        if isinstance(obj, string_types):\n            obj = import_string(obj)\n        for key in dir(obj):\n            if key.isupper(): #只允许模块或对象中的大写属性填充进来，小写的忽略。\n                self[key] = getattr(obj, key)\n\n    def from_json(self, filename, silent=False):\n        \"\"\"filename是json文件名。这是flask0.11添加的方法。\n        \"\"\"\n        filename = os.path.join(self.root_path, filename)\n        try:\n            with open(filename) as json_file:\n                obj = json.loads(json_file.read()) #注意，如果不知道json.loads的type参数，那么默认加载为字典。即obj是一个字典\n        except IOError as e:\n            ...略pass...\n        return self.from_mapping(obj) #这里调用from_mapping\n\n    def from_mapping(self, *mapping, **kwargs):\n        \"\"\"行为类似于dict的update方法，只不过忽略小写属性.flask0.11添加的方法\n        \"\"\"\n        mappings = []\n        if len(mapping) == 1:\n            if hasattr(mapping[0], 'items'):\n                mappings.append(mapping[0].items())\n            else:\n                mappings.append(mapping[0])\n        elif len(mapping) > 1:\n            raise TypeError(\n                'expected at most 1 positional argument, got %d' % len(mapping)\n            )\n        mappings.append(kwargs.items())\n        for mapping in mappings:\n            for (key, value) in mapping:\n                if key.isupper():\n                    self[key] = value\n        return True\n\n    def get_namespace(self, namespace, lowercase=True, trim_namespace=True):\n        \"\"\"返回一个字典，这个字典包含该命名空间的items。这个命名空间是以_作为分隔标识的.比如\n            app.config['IMAGE_STORE_TYPE'] = 'fs'\n            app.config['IMAGE_STORE_PATH'] = '/var/app/images'\n            app.config['IMAGE_STORE_BASE_URL'] = 'http://img.website.com'\n            image_store_config = app.config.get_namespace('IMAGE_STORE_')\n        结果 `image_store_config` 会是这样::\n\n            {\n                'type': 'fs',\n                'path': '/var/app/images',\n                'base_url': 'http://img.website.com'\n            }\n        当需要利用这个进行传参时是比较方便的。\n        trim_namespace参数为True时，行为就是上面所述，为False时返回的key会包含namespace前缀。\n        \"\"\"\n        rv = {}\n        for k, v in iteritems(self):\n            if not k.startswith(namespace):\n                continue\n            if trim_namespace:\n                key = k[len(namespace):]\n            else:\n                key = k\n            if lowercase:\n                key = key.lower()\n            rv[key] = v\n        return rv\n\n    def __repr__(self):\n        return '<%s %s>' % (self.__class__.__name__, dict.__repr__(self))\n        \nconfig模块阅读配置到此结束，下一篇主题待定。\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "5"}