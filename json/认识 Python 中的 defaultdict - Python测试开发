{"title": "认识 Python 中的 defaultdict - Python测试开发 ", "index": "python", "content": "今天我们的主角是defaultdict，同时也会介绍一下魔法方法__missing__()，本文主要来源于网友博客，分享给有需要的人。\n默认值可以很方便\n众所周知，在Python中如果访问字典中不存在的键，会引发KeyError异常。但是有时候，字典中的每个键都存在默认值是非常方便的。例如下面的例子：\nstrings = ('puppy', 'kitten', 'puppy', 'puppy',\n           'weasel', 'puppy', 'kitten', 'puppy')\ncounts = {}\n\nfor kw in strings:\n    counts[kw] += 1\n该例子统计strings中某个单词出现的次数，并在counts字典中作记录。单词每出现一次，在counts相对应的键所存的值数字加1。但是事实上，运行这段代码会抛出KeyError异常，出现的时机是每个单词第一次统计的时候，因为Python的dict中不存在默认值的说法，可以在Python命令行中验证：\n>>> counts = dict()\n>>> counts\n{}\n>>> counts['puppy'] += 1\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nKeyError: 'puppy'\n使用判断语句检查\n既然如此，首先可能想到的方法是在单词第一次统计的时候，在counts中相应的键存下默认值1。这需要在处理的时候添加一个判断语句：\nstrings = ('puppy', 'kitten', 'puppy', 'puppy',\n           'weasel', 'puppy', 'kitten', 'puppy')\ncounts = {}\n\nfor kw in strings:\n    if kw not in counts:\n        counts[kw] = 1\n    else:\n        counts[kw] += 1\n\n# counts:\n# {'puppy': 5, 'weasel': 1, 'kitten': 2}\n使用dict.setdefault()方法\n也可以通过dict.setdefault()方法来设置默认值：\nstrings = ('puppy', 'kitten', 'puppy', 'puppy',\n           'weasel', 'puppy', 'kitten', 'puppy')\ncounts = {}\n\nfor kw in strings:\n    counts.setdefault(kw, 0)\n    counts[kw] += 1\ndict.setdefault()方法接收两个参数，第一个参数是健的名称，第二个参数是默认值。假如字典中不存在给定的键，则返回参数中提供的默认值；反之，则返回字典中保存的值。利用dict.setdefault()方法的返回值可以重写for循环中的代码，使其更加简洁：\nstrings = ('puppy', 'kitten', 'puppy', 'puppy',\n           'weasel', 'puppy', 'kitten', 'puppy')\ncounts = {}\n\nfor kw in strings:\n    counts[kw] = counts.setdefault(kw, 0) + 1\n使用collections.defaultdict类\n以上的方法虽然在一定程度上解决了dict中不存在默认值的问题，但是这时候我们会想，有没有一种字典它本身提供了默认值的功能呢？答案是肯定的，那就是collections.defaultdict。\ndefaultdict类就好像是一个dict，但是它是使用一个类型来初始化的：\n>>> from collections import defaultdict\n>>> dd = defaultdict(list)\n>>> dd\ndefaultdict(<type 'list'>, {})\ndefaultdict类的初始化函数接受一个类型作为参数，当所访问的键不存在的时候，可以实例化一个值作为默认值：\n>>> dd['foo']\n[]\n>>> dd\ndefaultdict(<type 'list'>, {'foo': []})\n>>> dd['bar'].append('quux')\n>>> dd\ndefaultdict(<type 'list'>, {'foo': [], 'bar': ['quux']})\n需要注意的是，这种形式的默认值只有在通过dict[key]或者dict.__getitem__(key)访问的时候才有效，这其中的原因在下文会介绍。\n>>> from collections import defaultdict\n>>> dd = defaultdict(list)\n>>> 'something' in dd\nFalse\n>>> dd.pop('something')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nKeyError: 'pop(): dictionary is empty'\n>>> dd.get('something')\n>>> dd['something']\n[]\ndefaultdict类除了接受类型名称作为初始化函数的参数之外，还可以使用任何不带参数的可调用函数，到时该函数的返回结果作为默认值，这样使得默认值的取值更加灵活。下面用一个例子来说明，如何用自定义的不带参数的函数zero()作为defaultdict类的初始化函数的参数：\n>>> from collections import defaultdict\n>>> def zero():\n...     return 0\n...\n>>> dd = defaultdict(zero)\n>>> dd\ndefaultdict(<function zero at 0xb7ed2684>, {})\n>>> dd['foo']\n0\n>>> dd\ndefaultdict(<function zero at 0xb7ed2684>, {'foo': 0})\n利用collections.defaultdict来解决最初的单词统计问题，代码如下：\nfrom collections import defaultdict\n\nstrings = ('puppy', 'kitten', 'puppy', 'puppy',\n           'weasel', 'puppy', 'kitten', 'puppy')\ncounts = defaultdict(lambda: 0)  # 使用lambda来定义简单的函数\n\nfor s in strings:\n    counts[s] += 1\ndefaultdict类是如何实现的\n通过上面的内容，想必大家已经了解了defaultdict类的用法，那么在defaultdict类中又是如何来实现默认值的功能呢？这其中的关键是使用了看__missing__()这个方法：\n>>> from collections import defaultdict\n>>> print defaultdict.__missing__.__doc__\n__missing__(key) # Called by __getitem__ for missing key; pseudo-code:\n  if self.default_factory is None: raise KeyError(key)\n  self[key] = value = self.default_factory()\n  return value\n通过查看__missing__()方法的docstring，可以看出当使用__getitem__()方法访问一个不存在的键时dict[key]这种形式实际上是__getitem__()方法的简化形式)，会调用__missing__()方法获取默认值，并将该键添加到字典中去。\n关于__missing__()方法的具体介绍可以参考Python官方文档中的\"Mapping Types — dict\"一节。\n文档中介绍，从2.5版本开始，如果派生自dict的子类定义了__missing__()方法，当访问不存在的键时，dict[key]会调用__missing__()方法取得默认值。\n从中可以看出，虽然dict支持__missing__()方法，但是在dict本身是不存在这个方法的，而是需要在派生的子类中自行实现这个方法。可以简单的验证这一点：\n>>> print dict.__missing__.__doc__\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nAttributeError: type object 'dict' has no attribute '__missing__'\n同时，我们可以进一步的做实验，定义一个子类Missing并实现__missing__()方法:\n>>> class Missing(dict):\n...     def __missing__(self, key):\n...         return 'missing'\n...\n>>> d = Missing()\n>>> d\n{}\n>>> d['foo']\n'missing'\n>>> d\n{}\n返回结果反映了__missing__()方法确实发挥了作用。在此基础上，我们稍许修改__missing__()方法,使得该子类同defautldict类一样为不存在的键设置一个默认值：\n>>> class Defaulting(dict):\n...     def __missing__(self, key):\n...         self[key] = 'default'\n...         return 'default'\n...\n>>> d = Defaulting()\n>>> d\n{}\n>>> d['foo']\n'default'\n>>> d\n{'foo': 'default'}\n在旧版本的Python中实现类defaultdict的功能\ndefaultdict类是从2.5版本之后才添加的，在一些旧版本中并不支持它，因此为旧版本实现一个兼容的defaultdict类是必要的。这其实很简单，虽然性能可能未必如2.5版本中自带的defautldict类好，但在功能上是一样的。\n首先，__getitem__()方法需要在访问键失败时，调用__missing__()方法：\nclass defaultdict(dict):\n    def __getitem__(self, key):\n        try:\n            return dict.__getitem__(self, key)\n        except KeyError:\n            return self.__missing__(key)\n其次，需要实现__missing__()方法用来设置默认值：\nclass defaultdict(dict):\n    def __getitem__(self, key):\n        try:\n            return dict.__getitem__(self, key)\n        except KeyError:\n            return self.__missing__(key)\n\n    def __missing__(self, key):\n        self[key] = value = self.default_factory()\n        return value\n然后，defaultdict类的初始化函数__init__()需要接受类型或者可调用函数参数:\nclass defaultdict(dict):\n    def __init__(self, default_factory=None, *a, **kw):\n        dict.__init__(self, *a, **kw)\n        self.default_factory = default_factory\n\n    def __getitem__(self, key):\n        try:\n            return dict.__getitem__(self, key)\n        except KeyError:\n            return self.__missing__(key)\n\n    def __missing__(self, key):\n        self[key] = value = self.default_factory()\n        return value\n最后，综合以上内容，通过以下方式完成兼容新旧Python版本的代码：\ntry:\n    from collections import defaultdict\nexcept ImportError:\n    class defaultdict(dict):\n      def __init__(self, default_factory=None, *a, **kw):\n          dict.__init__(self, *a, **kw)\n          self.default_factory = default_factory\n\n      def __getitem__(self, key):\n          try:\n              return dict.__getitem__(self, key)\n          except KeyError:\n              return self.__missing__(key)\n\n      def __missing__(self, key):\n          self[key] = value = self.default_factory()\n          return value\n参考文档\nhttps://docs.python.org/2/lib...\n关于作者：Python技术爱好者，目前从事测试开发相关工作，转载请注明原文出处。欢迎关注我的博客 https://betacat.online，你可以到我的公众号中去当吃瓜群众。\n\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "3"}