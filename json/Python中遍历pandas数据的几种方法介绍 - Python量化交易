{"title": "Python中遍历pandas数据的几种方法介绍 - Python量化交易 ", "index": "python", "content": "前言\nPandas是python的一个数据分析包，提供了大量的快速便捷处理数据的函数和方法。其中Pandas定义了Series 和 DataFrame两种数据类型，这使数据操作变得更简单。Series 是一种一维的数据结构，类似于将列表数据值与索引值相结合。DataFrame 是一种二维的数据结构，接近于电子表格或者mysql数据库的形式。在数据分析中不可避免的涉及到对数据的遍历查询和处理，比如我们需要将dataframe两列数据两两相除，并将结果存储于一个新的列表中。本文通过该例程介绍对pandas数据遍历的几种方法。\n\nfor..in循环迭代方式\nfor语句是Python内置的迭代器工具，用于从可迭代容器对象（如列表、元组、字典、集合、文件等）中逐个读取元素，直到容器中没有更多元素为止，工具和对象之间只要遵循可迭代协议即可进行迭代操作。具体的迭代的过程：可迭代对象通过__iter__方法返回迭代器，迭代器具有__next__方法，for循环不断地调用__next__方法，每次按序返回迭代器中的一个值，直到迭代到最后，没有更多元素时抛出异常StopIteration（python自动处理异常）。迭代的优点是无需把所有元素一次加载到内存中，可以在调用next方法时逐个返回元素，避免出现内存空间不够的情况。\n>>> x = [1,2,3]\n>>> its = x.__iter__() #列表是可迭代对象，否则会提示不是迭代对象\n>>> its\n<list_iterator object at 0x100f32198>\n>>> next(its) # its包含此方法，说明its是迭代器\n1\n>>> next(its) \n2\n>>>next(its) \n3\n>>> next(its) \nTraceback (most recent call last):\n     File \"<stdin>\", line 1, in <module>\nStopIteration\n\n实现代码如下：\ndef haversine_looping(df):\ndisftance_list = []\nfor i in range(0,len(df)):\n    disftance_list.append(df.iloc[i][‘high’]/df.iloc[i][‘open’])\n    return disftance_list\n\n关于上述代码中range的实现方法，我们也可根据迭代器协议自实现相同功能的迭代器（自带iter方法和next方法）应用在for循环中，代码如下：\nclass MyRange:\n    def __init__(self, num):\n          self.i = 0\n          self.num = num\n     def __iter__(self):\n          return self\n     def __next__(self):\n         if self.i < self.num:\n           i = self.i\n           self.i += 1\n           return i\n          else:\n              raise StopIteration()\n for i in MyRange(10):\n    print(i)   \n\n我们也可以通过列表解析的方式用更少的代码实现数据处理功能\ndisftance_list = [df.iloc[i][‘high’]/df.iloc[i][‘open’] for i in range(0,len(df))]\n\n\n\niterrows()生成器方式\niterrows是对dataframe行进行迭代的一个生成器，它返回每行的索引及包含行本身的对象。所谓生成器其实是一种特殊的迭代器，内部支持了迭代器协议。Python中提供生成器函数和生成器表达式两种方式实现生成器，每次请求返回一个结果，不需要一次性构建一个结果列表，节省了内存空间。\n生成器函数：编写为常规的def语句，但是使用yield语句一次返回一个结果，在每个结果之间挂起和继续它们的状态。\ndef gensquares(N):\n    for i in range(N):\n        yield i**2 \nprint gensquares(5)\nfor i in gensquares(5):\n    print(i) \n\n<generator object gensquares at 0xb3d37fa4>\n0\n1\n4\n9\n16\n\n生成器表达式：类似列表解析，按需产生结果的一个对象。\nprint (x**2 for x in range(5))\nprint list(x**2 for x in range(5))\n\n<generator object <genexpr> at 0xb3d31fa4>\n[0, 1, 4, 9, 16]\n\niterrows()实现代码如下：\ndef haversine_looping(df):\ndisftance_list = []\nfor index,row in df.iterrows():\n    disftance_list.append(row[‘high’]/row[‘open’])\n    return disftance_list\n\niterrows代码如下，yield语句挂起该函数并向调用者发送回一组值：\ndef iterrows(self):\n    columns = self.columns\n    klass = self._constructor_sliced\n    for k, v in zip(self.index, self.values):\n        s = klass(v, index=columns, name=k)\n        yield k, s\n\n\n\napply()方法循环方式\napply()方法可将函数应用于dataframe特定行或列。函数由lambda方式在代码中内嵌实现，lambda函数的末尾包含axis参数，用来告知Pandas将函数运用于行（axis = 1）或者列（axis = 0）。\n实现代码如下：\ndf.apply(lambda row: row[‘high’]/row[‘open’], axis =1)\n\n\n\nPandas series 的矢量化方式\nPandas的DataFrame、series基础单元数据结构基于链表，因此可将函数在整个链表上进行矢量化操作，而不用按顺序执行每个值。Pandas包括了非常丰富的矢量化函数库，我们可把整个series（列）作为参数传递，对整个链表进行计算。\n实现代码如下：\ndftest4['rate'] = dftest4['high']/dftest4['open']  \n\n\n\nNumpy arrays的矢量化方式\n由于函数的矢量化实现中只使用了series的数值，因此可使用values 方法将链表从Pandas series转换为NumPy arrays，把NumPy array作为参数传递，对整个链表进行计算。\n实现代码如下：\ndftest5['rate'] = dftest5['high'].values/dftest5['open'].values  \n\n\n\n总结\n使用timeit方法对以上几种遍历方式进行执行时间测试，测试结果如下。可以看出循环执行的速度是最慢的，iterrows()针对Pandas的dataframe进行了优化，相比直接循环有显著提升。apply()方法也是在行之间进行循环，但由于利用了类似Cython的迭代器的一系列全局优化，其效率要比iterrows高很多。NumPy arrays的矢量化运行速度最快，其次是Pandas series矢量化。由于矢量化是同时作用于整个序列的，可以节省更多的时间，相比使用标量操作更好，NumPy使用预编译的C代码在底层进行优化，同时也避免了Pandas series操作过程中的很多开销，例如索引、数据类型等等，因此，NumPy arrays的操作要比Pandas series快得多。\nloop: 1.80301690102 iterrows: 0.724927186966 apply: 0.645957946777pandas series: 0.333024024963 numpy array: 0.260366916656\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "2"}