{"title": "Socket 编程实战 - From SICP to Lisp ", "index": "python,socket", "content": "本文原发于个人博客\nSocket 在英文中的含义为“（连接两个物品的）凹槽”，像the eye socket，意为“眼窝”，此外还有“插座”的意思。在计算机科学中，socket 通常是指一个连接的两个端点，这里的连接可以是同一机器上的，像unix domain socket，也可以是不同机器上的，像network socket。\n本文着重介绍现在用的最多的 network socket，包括其在网络模型中的位置、API 的编程范式、常见错误等方面，最后用 Python 语言中的 socket API 实现几个实际的例子。Socket 中文一般翻译为“套接字”，不得不说这是个让人摸不着头脑的翻译，我也没想到啥“信达雅”的翻译，所以本文直接用其英文表述。本文中所有代码均可在 socket.py 仓库中找到。\n概述\nSocket 作为一种通用的技术规范，首次是由 Berkeley 大学在 1983 为 4.2BSD Unix 提供的，后来逐渐演化为 POSIX 标准。Socket API 是由操作系统提供的一个编程接口，让应用程序可以控制使用 socket 技术。Unix 哲学中有一条一切皆为文件，所以 socket 和 file 的 API 使用很类似：可以进行read、write、open、close等操作。\n现在的网络系统是分层的，理论上有OSI模型，工业界有TCP/IP协议簇。其对比如下：\n\n每层上都有其相应的协议，socket API 不属于TCP/IP协议簇，只是操作系统提供的一个用于网络编程的接口，工作在应用层与传输层之间：\n\n我们平常浏览网站所使用的http协议，收发邮件用的smtp与imap，都是基于 socket API 构建的。\n一个 socket，包含两个必要组成部分：\n\n地址，由 ip 与 端口组成，像192.168.0.1:80。\n协议，socket 所是用的传输协议，目前有三种：TCP、UDP、raw IP。\n\n地址与协议可以确定一个socket；一台机器上，只允许存在一个同样的socket。TCP 端口 53 的 socket 与 UDP 端口 53 的 socket 是两个不同的 socket。\n根据 socket 传输数据方式的不同（使用协议不同），可以分为以下三种：\n\nStream sockets，也称为“面向连接”的 socket，使用 TCP 协议。实际通信前需要进行连接，传输的数据没有特定的结构，所以高层协议需要自己去界定数据的分隔符，但其优势是数据是可靠的。\nDatagram sockets，也称为“无连接”的 socket，使用 UDP 协议。实际通信前不需要连接，一个优势时 UDP 的数据包自身是可分割的（self-delimiting），也就是说每个数据包就标示了数据的开始与结束，其劣势是数据不可靠。\nRaw sockets，通常用在路由器或其他网络设备中，这种 socket 不经过TCP/IP协议簇中的传输层（transport layer），直接由网络层（Internet layer）通向应用层（Application layer），所以这时的数据包就不会包含 tcp 或 udp 头信息。\n\n\nPython socket API\nPython 里面用(ip, port)的元组来表示 socket 的地址属性，用AF_*来表示协议类型。数据通信有两组动词可供选择：send/recv 或 read/write。read/write 方式也是 Java 采用的方式，这里不会对这种方式进行过多的解释，但是需要注意的是：\nread/write 操作的具有 buffer 的“文件”，所以在进行读写后需要调用flush方法去真正发送或读取数据，否则数据会一直停留在缓冲区内。\nTCP socket\nTCP socket 由于在通向前需要建立连接，所以其模式较 UDP socket 负责些。具体如下：\n每个API 的具体含义这里不在赘述，可以查看手册，这里给出 Python 语言的实现的 echo server。\n# echo_server.py\n# coding=utf8\nimport socket\n\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n# 设置 SO_REUSEADDR 后,可以立即使用 TIME_WAIT 状态的 socket\nsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\nsock.bind(('', 5500))\nsock.listen(5)\n\ndef handler(client_sock, addr):\n    print('new client from %s:%s' % addr)\n    msg = client_sock.recv(1024)\n    client_sock.send(msg)\n    client_sock.close()\n    print('client[%s:%s] socket closed' % addr)\n\nif __name__ == '__main__':\n    while 1:\n        client_sock, addr = sock.accept()\n        handler(client_sock, addr)\n\n# echo_client.py\n# coding=utf8\nimport socket\n\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.connect(('', 5500))\nsock.send('hello socket world')\nprint sock.recv(1024)\n\n上面简单的echo server 代码中有一点需要注意的是：server 端的 socket 设置了SO_REUSEADDR为1，目的是可以立即使用处于TIME_WAIT状态的socket，那么TIME_WAIT又是什么意思呢？后面在讲解 tcp 状态变更图时再做详细介绍。\nUDP socket\n\nUDP socket server 端代码在进行bind后，无需调用listen方法。\n# udp_echo_server.py\n# coding=utf8\nimport socket\n\nsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n# 设置 SO_REUSEADDR 后,可以立即使用 TIME_WAIT 状态的 socket\nsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\nsock.bind(('', 5500))\n# 没有调用 listen\n\nif __name__ == '__main__':\n    while 1:\n        data, addr = sock.recvfrom(1024)\n\n        print('new client from %s:%s' % addr)\n        sock.sendto(data, addr)\n\n# udp_echo_client.py\n# coding=utf8\nimport socket\n\nudp_server_addr = ('', 5500)\n\nif __name__ == '__main__':\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    data_to_sent = 'hello udp socket'\n    try:\n        sent = sock.sendto(data_to_sent, udp_server_addr)\n        data, server = sock.recvfrom(1024)\n        print('receive data:[%s] from %s:%s' % ((data,) + server))\n    finally:\n        sock.close()\n\n常见陷阱\n忽略返回值\n本文中的 echo server 示例因为篇幅限制，也忽略了返回值。网络通信是个非常复杂的问题，通常无法保障通信双方的网络状态，很有可能在发送/接收数据时失败或部分失败。所以有必要对发送/接收函数的返回值进行检查。本文中的 tcp echo client 发送数据时，正确写法应该如下：\ntotal_send = 0\ncontent_length = len(data_to_sent)\nwhile total_send < content_length:\n    sent = sock.send(data_to_sent[total_send:])\n    if sent == 0:\n        raise RuntimeError(\"socket connection broken\")\n    total_send += total_send + sent\n\nsend/recv操作的是网络缓冲区的数据，它们不必处理传入的所有数据。\n一般来说，当网络缓冲区填满时，send函数就返回了；当网络缓冲区被清空时，recv 函数就返回。当 recv 函数返回0时，意味着对端已经关闭。\n可以通过下面的方式设置缓冲区大小。\ns.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, buffer_size)\n\n认为 TCP 具有 framing\nTCP 不提供 framing，这使得其很适合于传输数据流。这是其与 UDP 的重要区别之一。UDP 是一个面向消息的协议，能保持一条消息在发送者与接受者之间的完备性。\n代码示例参考：framing_assumptions\nTCP 的状态机\n在前面echo server 的示例中，提到了TIME_WAIT状态，为了正式介绍其概念，需要了解下 TCP 从生成到结束的状态机器。（图片来源）\n\n这个状图转移图非常非常关键，也比较复杂，我自己为了方便记忆，对这个图进行了拆解，仔细分析这个图，可以得出这样一个结论，连接的打开与关闭都有被动（passive）与主动（active）两种，主动关闭时，涉及到的状态转移最多，包括FIN_WAIT_1、FIN_WAIT_2、CLOSING、TIME_WAIT。\n此外，由于 TCP 是可靠的传输协议，所以每次发送一个数据包后，都需要得到对方的确认（ACK），有了上面这两个知识后，再来看下面的图：（图片来源）\n\n\n在主动关闭连接的 socket 调用 close方法的同时，会向被动关闭端发送一个 FIN\n对端收到FIN后，会向主动关闭端发送ACK进行确认，这时被动关闭端处于 CLOSE_WAIT 状态\n当被动关闭端调用close方法进行关闭的同时向主动关闭端发送 FIN 信号，接收到 FIN 的主动关闭端这时就处于 TIME_WAIT 状态\n这时主动关闭端不会立刻转为 CLOSED 状态，而是需要等待 2MSL（max segment life，一个数据包在网络传输中最大的生命周期），以确保被动关闭端能够收到最后发出的 ACK。如果被动关闭端没有收到最后的 ACK，那么被动关闭端就会重新发送 FIN，所以处于TIME_WAIT的主动关闭端会再次发送一个 ACK 信号，这么一来（FIN来）一回（ACK），正好是两个 MSL 的时间。如果等待的时间小于 2MSL，那么新的socket就可以收到之前连接的数据。\n\n前面 echo server 的示例也说明了，处于 TIME_WAIT 并不是说一定不能使用，可以通过设置 socket 的 SO_REUSEADDR 属性以达到不用等待 2MSL 的时间就可以复用socket 的目的，当然，这仅仅适用于测试环境，正常情况下不要修改这个属性。\n实战\nHTTP UA\nhttp 协议是如今万维网的基石，可以通过 socket API 来简单模拟一个浏览器（UA）是如何解析 HTTP 协议数据的。\n#coding=utf8\nimport socket\n\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nbaidu_ip = socket.gethostbyname('baidu.com')\nsock.connect((baidu_ip, 80))\nprint('connected to %s' % baidu_ip)\n\nreq_msg = [\n    'GET / HTTP/1.1',\n    'User-Agent: curl/7.37.1',\n    'Host: baidu.com',\n    'Accept: */*',\n]\ndelimiter = '\\r\\n'\n\nsock.send(delimiter.join(req_msg))\nsock.send(delimiter)\nsock.send(delimiter)\n\nprint('%sreceived%s' % ('-'*20, '-'*20))\nhttp_response = sock.recv(4096)\nprint(http_response)\n运行上面的代码可以得到下面的输出\n--------------------received--------------------\nHTTP/1.1 200 OK\nDate: Tue, 01 Nov 2016 12:16:53 GMT\nServer: Apache\nLast-Modified: Tue, 12 Jan 2010 13:48:00 GMT\nETag: \"51-47cf7e6ee8400\"\nAccept-Ranges: bytes\nContent-Length: 81\nCache-Control: max-age=86400\nExpires: Wed, 02 Nov 2016 12:16:53 GMT\nConnection: Keep-Alive\nContent-Type: text/html\n\n<html>\n<meta http-equiv=\"refresh\" content=\"0;url=http://www.baidu.com/\">\n</html>\nhttp_response是通过直接调用recv(4096)得到的，万一真正的返回大于这个值怎么办？我们前面知道了 TCP 协议是面向流的，它本身并不关心消息的内容，需要应用程序自己去界定消息的边界，对于应用层的 HTTP 协议来说，有几种情况，最简单的一种时通过解析返回值头部的Content-Length属性，这样就知道body的大小了，对于 HTTP 1.1版本，支持Transfer-Encoding: chunked传输，对于这种格式，这里不在展开讲解，大家只需要知道， TCP 协议本身无法区分消息体就可以了。对这块感兴趣的可以查看 CPython 核心模块 http.client\nUnix_domain_socket\nUDS 用于同一机器上不同进程通信的一种机制，其API适用与 network socket 很类似。只是其连接地址为本地文件而已。\n代码示例参考：uds_server.py、uds_client.py\nping\nping 命令作为检测网络联通性最常用的工具，其适用的传输协议既不是TCP，也不是 UDP，而是 ICMP，利用 raw sockets，我们可以适用纯 Python 代码来实现其功能。\n代码示例参考：ping.py\nnetstat vs ss\nnetstat 与 ss 是类 Unix 系统上查看 Socket 信息的命令。netstat 是比较老牌的命令，我常用的选择有\n\n-t，只显示 tcp 连接\n-u，只显示 udp 连接\n-n，不用解析hostname，用 IP 显示主机，可以加快执行速度\n-p，查看连接的进程信息\n-l，只显示监听的连接\n\nss 是新兴的命令，其选项和 netstat 差不多，主要区别是能够进行过滤（通过state与exclude关键字）。\n$ ss -o state time-wait -n | head\nRecv-Q Send-Q             Local Address:Port               Peer Address:Port\n0      0                 10.200.181.220:2222              10.200.180.28:12865  timer:(timewait,33sec,0)\n0      0                      127.0.0.1:45977                 127.0.0.1:3306   timer:(timewait,46sec,0)\n0      0                      127.0.0.1:45945                 127.0.0.1:3306   timer:(timewait,6.621ms,0)\n0      0                 10.200.181.220:2222              10.200.180.28:12280  timer:(timewait,12sec,0)\n0      0                 10.200.181.220:2222              10.200.180.28:35045  timer:(timewait,43sec,0)\n0      0                 10.200.181.220:2222              10.200.180.28:42675  timer:(timewait,46sec,0)\n0      0                      127.0.0.1:45949                 127.0.0.1:3306   timer:(timewait,11sec,0)\n0      0                      127.0.0.1:45954                 127.0.0.1:3306   timer:(timewait,21sec,0)\n0      0               ::ffff:127.0.0.1:3306           ::ffff:127.0.0.1:45964  timer:(timewait,31sec,0)\n这两个命令更多用法可以参考：\n\nSS Utility: Quick Intro\n10 basic examples of linux netstat command\n\n总结\n我们的生活已经离不开网络，平时的开发也充斥着各种复杂的网络应用，从最基本的数据库，到各种分布式系统，不论其应用层怎么复杂，其底层传输数据的的协议簇是一致的。Socket 这一概念我们很少直接与其打交道，但是当我们的系统出现问题时，往往是对底层的协议认识不足造成的，希望这篇文章能对大家编程网络方面的程序有所帮助。\n参考\n\nFive pitfalls of Linux sockets programming\nProgramming Linux sockets, Part 1: Using TCP/IP\nhttp://stackoverflow.com/ques...\nWhat’s The Difference Between The OSI Seven-Layer Network Model And TCP/IP?\nTCP 的那些事儿（上）\nCoping with the TCP TIME-WAIT state on busy Linux servers\n\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "30"}