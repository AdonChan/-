{"title": "python开发第二篇--基本数据类型 - python学习 ", "index": "python", "content": "基本数据类型\n数字类型\n\n只能存取一个值\n数字是不可变类型，根据id来看，不可变类型是可hash\n数字主要是用来计算的，使用方法不是很多，记住如下一种\n\n1.整数类型(int)当十进制用二进制来表示的时候，最少使用的位数\nage = 18\nprint(age.bit_length())\n2.浮点型(float)身高,体质参数,体重\nsalary = 3.1   #salary = salary(3.1)\nprint(salary,type(salary))\n3.复数(complex)\nx = 1 + 2j\nprint(x.real)\nprint(x.imag)\nprint(type(x))\n布尔值(bool)\n布尔值,只有两种一种是True,一种是False\n真为：True假为：False在数字中：只有0为False，其余为True在字符串中：只有空为False，其余为True\n字符串(str)\n\n字符串只有一个值\n字符串是有序的\n不可变类型，可被hash\n\n1.索引字符串是有序的，可以按照索引取值\nname = \"tianjianyu\"\nprint(name[0])   #取第一个值\nprint(name[-1])  #取最后一个值\n2.切片就是通过[索引：索引：步长]取字符串的一段，行成一段新的字符串，原则是顾头不顾尾\nname = \"tianjianyu\"\nprint(name[0:4])     #比如取tian字符串,t为0，n为3，但是切片顾头不顾尾，需要3的位置在加1位，才能取到tian\nprint(name[0:4:1])   #这个1为步长，默认为1，也可以自己指定\nprint(name[:])       #初始位置不写,最后位置也不写，取的是该字符串的全部\nprint(name[::-1])    #初始位置不写,最后位置也不写,但是步长为-1，相当于将整个字符串翻转\n3.captalize,swapcase,title\nstr_1 = \"tianjianyu\"\nprint(str_1.capitalize()) #首字母大写\nstr_2 = \"Tian Jian Yu\"\nprint(str_2.swapcase())   #大小写翻转\nstr_3 = \"tian jian yu\"\nprint(str_3.title())   #每个字母的首字母大写\nstr_4 = \"tianjianyu\"\nprint(str_4.upper())  #将字符串的所有字母转换为大写\nstr_5 = \"TIANJIANYU\"\nprint(str_5.lower())   #将字符串所有字母转换为小写\n4.\"center\"用于填充，比如需要长度为20,name会居中，总长度为20,用空格填充\nname = \"tian\"\nprint(name.center(20))\n5.expandtabs\n# name='egon\\thello'\n# print(name.expandtabs(10))\n\"\"\"\nS.expandtabs(tabsize=8) -> str\n\n        Return a copy of S where all tab characters are expanded using spaces.\n        If tabsize is not given, a tab size of 8 characters is assumed.\n        1.expandtabs后边的参数为几就把几个分在一起；\n        比如为2，那么就两个一组，前边如果有一个了，就在补充一个；\n        反之，如果两个一组前边一个没有，那么就补充两个空格\n\"\"\"\n6.find,index\nname = \"hello world\"\nprint(name.find(\"o\",0,4))  #顾头不顾尾，找到则返回索引位置，找不到则返回-1\nprint(name.index(\"o\",0,4)) #和find一样，但是找不到会报错substring not found\n\n\n7.count用于统计某个元素的个数\nname = \"hello\"\nprint(name.count(\"l\"))\n8.split将一个字符串以什么切割，行成一个新的列表\nname = \"tian jian yu\"\nprint(name.split())\n9.join的用法，用于字符串的拼接,将一个列表拼接成一个字符串，只有在列表内的所有元素都是字符串才可以拼接\nname = [\"tian\",\"jian\",\"yu\"]\nprint(\" \".join(name))\n\n9.format格式化的方法\nprint(\"my name is {} age is {}\".format(\"tian\",18))\nprint(\"my name is {name} age is {age}\".format(name=\"tian\",age=18))\n10.replace将字符串中的元素进行替换，如果不重新赋值，字符串是不可变类型\nmsg = \"hello\"\nprint(msg.replace(\"l\",\"d\",1))\n11.isalnum,isdigit,isalpha判断字符串的组成\nname='tianjianyu123'\nprint(name.isalnum()) #字符串由字母或数字组成\nprint(name.isalpha()) #字符串只由字母组成\nprint(name.isdigit()) #字符串只由数字组成\n元祖(tuple)\n\n元组适用于不变的数据\n元组是有序的\n元组是不可变类型(但是元组可以对嵌套的列表内的元素修改)\n\n1.定义：\nage = (1,2,3,4)\nprint(age,type(age))\n2.索引取值\nage = (1,2,3,4)\nprint(age[1])\n3.切片\nage = (1,2,3,4)\nprint(age[0:3])\n4.根据元素找索引位置\nage = (1,2,3,4)\nprint(age.index(1))\n5.count统计某个元素出现的次数\nage = (1,2,3,4)\nprint(age.index(1))\n列表(list)\n\n存一个值或者多个值，值为任意类型\n有序，可以按照索引取值\n可变类型\n\n1.定义方式，\"[]\"内可以有多个任意类型的值，用\",\"分割\nname = [\"tian\",\"jian\",\"yu\",1,2,3]  #本质name = list([...])\nprint(list(\"hello\"))    #传个字符串的方式\n2.索引取值\nname = [\"tian\",\"jian\",\"yu\",1,2,1]\nprint(name[1])\n3.切片顾头不顾尾\nname = [\"tian\",\"jian\",\"yu\",1,2,1]\nprint(name[0::1])      #取全部列表，步长为1\nprint(name[-1::-1])    #反向去列表全部，类似revers功能\n4.增：insert,append,extend\nname = [\"tian\",\"jian\",\"yu\"]\nname.insert(0,\"qudi\")    #insert指定索引位置添加，如果指定的索引不存在,则在最后添加\nname.append(\"tianjianyu\") #增加到最后\nname.extend(\"abc\")        #迭代的去增加\nprint(name)  #最后打印结果为：['qudi', 'tian', 'jian', 'yu', 'tianjianyu', 'a', 'b', 'c']\n5.删：pop,del,remove,clear\nname = [\"tian\",\"jian\",\"yu\"]\nname.pop(0)   #按照索引去删，返回值为删掉的元素\nname.remove(\"tian\")   #按照元素去删除。返回值为None，拿不到结果\nname.clear()     #清空列表\ndel name[0:1]   #按照位置去删除，也可切片删除没有返回值\n6.改\nname = [\"tian\",\"jian\",\"yu\"]\nname[0] = \"qudi\"       #将索引0位置替换为qudi\nname[1:2] = [\"a\",\"b\"]   #按照切片去替换\nprint(name)             #['qudi', 'a', 'b', 'yu']\n7.查index,切片，for循环\nname = [\"tian\",\"jian\",\"yu\"]\nprint(name.index(\"tian\"))    #按照元素查找返回索引位置\nname = [\"tian\",\"jian\",\"yu\"]\nfor i in name:              #使用for循环查\n    print(i)\n8.count统计某个元素出现的次数\nname = [\"tian\",\"jian\",\"yu\",\"tian\"]\nprint(name.count(\"tian\"))\n9.sort,reverse\na = [5,6,8,9,1,2]\na.sort()\nprint(a)   #[1, 2, 5, 6, 8, 9]正序\n\na = [5,6,8,9,1,2]\na.sort(reverse=True)\nprint(a)   #[9, 8, 6, 5, 2, 1]倒序\n\na = [5,6,8,9,1,2]\na.reverse()\nprint(a)   #[2, 1, 9, 8, 6, 5]整个列表翻转  \n字典(dict)\n\n按照key：value，存取速度快，可以是任意类型,key必须是不可变类型\n3.6版本以前是无序的，3.6以后是有序的，有序不是可以按照索引取值\n可变\n\n1.增\ndic = {\"name\":\"tianjianyu\",\"age\":24}\ndic[\"hobbies\"] = \"gril\"    #增加一对key，val如果key有则将val的值赋值成新的，没有则添加一对新的key，val\ndic[\"name\"] = \"qudi\"\nprint(dic)\ndic = {\"name\":\"tianjianyu\",\"age\":24}\ndic.setdefault(\"name\")     #在字典中添加键值对，如果只有键那对应的值是none,但是如果原字典中存在设置的键值对，则他不会更改或者覆盖\ndic.setdefault(\"hobbies\")\nprint(dic)\n2.删：pop,popitem,clear,del\nname_dict  = {\"name\":\"qudi\",\"age\":18}\nprint(name_dict.pop(\"name\"))   #pop传key值可以返回值\nprint(name_dict.popitem())     #删除一对键值对，返回值为元祖\nprint(name_dict)\nprint(name_dict.clear())  # 清空字典，没有返回值\ndel name_dict   #删除整个字典\n3.改\ndic = {\"name\":\"tianjianyu\",\"age\":24}\ndic[\"name\"] = \"qudi\"   #取到key值之后重新赋予新值\ndic1 = {\"name\":\"tianjianyu\",\"age\":24}\ndic2 = {\"name\":\"qudi\",\"age\":25,\"hobbies\":\"boy\"}\ndic1.update(dic2)   #将dic2所有的键值对覆盖添加（相同的覆盖，没有的添加）到dic1中\nprint(dic1)         #{'name': 'qudi', 'age': 25, 'hobbies': 'boy'}\n4.查\ndic = {\"name\":\"tianjianyu\",\"age\":24}\ndic1 = dic[\"hobbies\"]     #如果没有该key值会报错,KeyError: 'hobbies'\nprint(dic1)\ndic = {\"name\":\"tianjianyu\",\"age\":24}\ndic1 = dic.get(\"name\")  #没有该key，不会报错，可以返回自定义的返回值，有则返回val值\nprint(dic1)\n5.keys,values,items\ndic = {\"name\":\"tianjianyu\",\"age\":24}\nprint(dic.keys())                      #以类似元组的形式返回所有的key,dict_keys(['name', 'age'])\nprint(dic.values())                    #以类似元组的形式返回所有的val,dict_values(['tianjianyu', 24])\nprint(dic.items())                     #以类似元组的形式返回一对key,val,dict_items([('name', 'tianjianyu'), ('age', 24)])\n6.字典的循环\ndic = {\"name\":\"tianjianyu\",\"age\":24}\nfor key in dic.keys():          #dic后边不写,默认是key\n    print(key)\nfor val in dic.values():\n    print(val)\nfor key,val in dic.items():    #\n    print(key,val)\n7.字典fromkeys用于创建一个新字典，以序列seq中元素做字典的键，value为字典所有键对应的初始值。\nseq = ('name', 'age', 'sex')\ndict = dict.fromkeys(seq)\nprint(dict)\n集合\n\n作用：关系运算，去重{}号内可以用逗号分隔，每个元素必须是不可变类型（不可hash）\n集合内的元素不能重复\n无序，不能按照索引取值\n\n1.交集&两个集合相同的数字，不同的数字去掉\nset_1 = {1,2,3,4}\nset_2 = {1,3,4,5}\nprint(set_1&set_2)\n2.合集|所有的数字，相同的数字去掉\nset_1 = {1,2,3,4}\nset_2 = {1,3,4,5}\nprint(set_1 | set_2)\n3.对称差集，没有同时在两个列表中的数字\nset_1 = {1,2,3,4}\nset_2 = {1,3,4,5}\nprint(set_1 ^ set_2)\n4.差集\nset_1 = {1,2,3,4}\nset_2 = {1,3,4,5}\nprint(set_1 - set_2)    #只存在set_1中的值\nprint(set_2 - set_1)    #只存在set_2中的值\n5.父集\nset_1 = {1,2,3,4}\nset_2 = {1,2,3}\nprint(set_1 >= set_2)    #True,判断set_1是否包含set_2\nprint(set_2 >= set_1)    #False,判断set_2是否包含set_1\n6.子集\nset_1 = {1,2,3,4}\nset_2 = {1,3,4}\nprint(set_1 <= set_2)   #False\nprint(set_2 <= set_1)   #True\n注：1.判断父集用>=,返回值为True，证明为父集2.判断子集用<=，返回值为True,证明为子集练习：1.\nl1 = [11, 22, 33, 44, 55]\n将索引为奇数对应的元素删除。\ndel l1[1::2]  # 根据切片步长找出索引为奇数\nprint(l1)\nfor i in range(len(l1)):  # 循环列表时，不要改变列表的大小，否则会影响结果\n    if i % 2 == 1:\n        l1.pop(i)\nprint(l1)\nfor i in range(len(l1) - 1, -1, -1):  # 按照索引倒叙的方式删除，不会影响前边的列表顺序\n    if i % 2 == 1:\n        del l1[i]\nprint(l1)\n2.\ndic = {'k1': 'v1', 'k2': 'v2', 'k3':'v3', 'name':'alex'}\n#删除字典中所有key中带有'k'的键值对\nl1 = []\nfor i in dic:   \n    if 'k' in i:   \n        l1.append(i)   #循环一个字典时，不要改变字典的大小，否则会影响结果\nfor i in l1:\n    del dic[i]\nprint(dic)\n深浅copy\n1.浅copy,外层是独立的，里边的是同一块内存空间\n#1.\n# list1 = [1,2,3]\n# list2 = list1.copy()\n# list1.append(4)\n# print(list1,id(list1))\n# print(list2,id(list2))\n#2.切片的浅copy方法\n# list1 = [1,2,3,[1,2,3]]\n# list2 = list1[:]\n# list1[-1].append(4)\n# list1.append(4)\n# print(list1,id(list1))\n# print(list2,id(list2))\n2.深copy\nimport copy\n# s1 = [1, 2, 3,[11,22]]\n# s2 = copy.deepcopy(s1)\n# s1.append(666)\n# print(s1, s2)\n\n# s1 = [1, 2, 3,[11,22]]\n# s2 = copy.deepcopy(s1)\n# s1[-1].append(666)\n# print(s1, s2)\n# 深copy 无论多少层，都是互相独立的。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}