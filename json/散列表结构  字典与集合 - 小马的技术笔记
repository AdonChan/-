{"title": "散列表结构  字典与集合 - 小马的技术笔记 ", "index": "数据结构,python", "content": "散列表结构  字典与集合\n散列表\n散列表(Hash Table)结构是字典(Dictionary)和集合(Set)的一种实现方式。散列算法的作用是尽可能快地在数据结构中找到一个值。在散列表上插入、删除和取用数据都非常快，但是对于查找操作来说却效率地下\n散列表是基于数组进行设计的，数组的长度是预先设定，如有需要可随时增加。所有元素根据和该元素对应的键，保存在数组的特定位置。使用散列表存储数据时，通过一个散列函数将键映射为一个数字，这个数字范围是0到列表长度。散列函数的选择依赖于键的数据类型，在此我们对键的hash值对数组长度区余的方法。散列表的数组究竟应该有多大？这是编写散列函数时必须要考虑的。对散列表大小的限制，通常数组的长度应该是一个质数。\n理想情况下，散列函数会将每个键值映射为唯一的数组索引，然而，键的数量是无限的，散列表的长度是有限的，一个理想的目标是让散列函数尽量将键均匀地映射到散列表中。即使使用一个高效的散列函数，仍然存在将两个键映射为同一个值的可能，这种现象称为碰撞(collision)。当碰撞发生时，我们需要方案去解决。\n\n\n分离链接：实现散列表底层数组中，每个数组元素是一个新的数据结构，比如另一个数组(二维数组)，这样就能存储多个键了。即使两个键散列后的值相同，依然被保存在同样的位置，只不过它们在第二个数组中的位置不一样罢了。\n\n线性探查：当发生碰撞时，线性探测法检测散列表的下一个位置是否为空。如果为空，就将数据存入该位置；如果不为空，则继续检查下一个位置，直到找到一个空的位置为止。\n\n负载因子：如果我们持续往散列表中添加数据空间会不够用。负载因子是已使用的空间比散列表大小的值。比如，散列表大小为13，已使用空间位8，负载因子位0.62。通常当负载因子超过0.8时，就要新开辟空间并重新散列了。\n散列表的操作：\n\n\n方法\n操作\n\n\n\nput\n向散列表添加新键值，或更新键的值\n\n\nremove\n从散列表删除键值\n\n\nget\n返回键索引到的值\n\n\n\n# python3\nclass HashTable:\n    def __init__(self, size=11):\n        self._keys = [None] * size\n        self._values = [None] * size\n        self._length = 0\n\n    # 获取负载因子\n    @property\n    def _load_factor(self):\n        return self._length / float(len(self._keys))\n\n    # 散列函数\n    def _hash_func(self, key):\n        l = len(self._keys)\n        idx = abs(hash(key)) % l\n        # 获取空索引\n        while self._keys[idx] is not None and \\\n                self._keys[idx] != key:\n            idx = (idx + l + 1) % l\n        return idx\n\n    def put(self, key, value):\n        idx = self._hash_func(key)\n        # 更新\n        if self._keys[idx] == key:\n            self._values[idx] = value\n        # 添加\n        elif self._keys[idx] is None:\n            self._keys[idx] = key\n            self._values[idx] = value\n            self._length += 1\n            # 检查负载因子\n            if self._load_factor >= 0.8:\n                self._rehash()\n\n    def get(self, key):\n        idx = self._hash_func(key)\n        if self._keys[idx] == key:\n            return self._values[idx]\n        return None\n\n    def remove(self, key):\n        idx = self._hash_func(key)\n        if self._keys[idx] == key:\n            self._keys[idx] = None\n            self._values[idx] = None\n            self._length -= 1\n        elif self._keys[idx] is None:\n            self._values[idx] = None\n        else:\n            return -1\n\n    # 重新散列，扩展大小\n    def _rehash(self):\n        old_keys = self._keys\n        old_value = self._values\n        new_size = len(self._keys) * 2\n        self._keys = [None] * new_size\n        self._values = [None] * new_size\n        self._length = 0\n        for idx in range(len(old_keys)):\n            if old_keys[idx] is not None:\n                self.put(old_keys[idx], old_value[idx])\n\n    def length(self):\n        return self._length\n字典\n散列表的基本方法就是字典常用的方法，在此可以继承散列表类的方法，然后完善其他的字典支持的方法。\n字典的操作：\n\n\n方法\n操作\n\n\n\nkeys\n返回所有键\n\n\nvalues\n返回所有值\n\n\nitems\n返回所有键值对\n\n\n\n# python3\nclass Dict(HashTable):\n    def keys(self):\n        return [key for key in self._keys if key is not None]\n\n    def values(self):\n        return [value for value in self._values if value is not None]\n\n    def items(self):\n        return [(self._keys[idx], self._values[idx])\n                for idx in range(0, len(self._keys))\n                if self._keys[idx] is not None]\n\n    def __iter__(self):\n        return iter(self.keys())\n\n    def __len__(self):\n        return self.length()\n\n    def __getitem__(self, key):\n        return self.get(key)\n\n    def __setitem__(self, key, value):\n        self.put(key, value)\n\n    def __contains__(self, key):\n        idx = self._hash_func(key)\n        return self._keys[idx] is not None\n集合\n集合是一种包含不同元素的数据结构。集合中的元素被称为成员。集合的两个重要特性：首先，集合中的成员是无序的；其次：集合中不允许相同的成员存在。\n集合的定义：\n\n不包含任何成员的集合称为空集，包含一切可能成员的集合称为全集。\n如果两个和的成员完全相同，则称两个集合相等。\n如果一个集合中所有的成员都属于另一个集合，则前一集合称为后一集合的子集。\n\n集合的运算：\n\n\n并集：将两个集合中的成员进行合并，得到一个新集合。\n\n交集：两个集合中共同存在的成员组成一个新的集合。\n\n补集：属于一个集合而不属于另一个集合的成员组成的集合。\n\n其实集合也是个散列表，散列表有键和值，在这里我们把值设置位True即可。具体实现如下。\n集合的操作：\n\n\n方法\n操作\n\n\n\nput\n向集合添加成员。\n\n\nremove\n从集合移除成员。\n\n\nunion\n接收一个集合进行并集运算返回结果\n\n\nintersection\n接收一个集合进行交集运算返回结果\n\n\ndifference\n接收一个集合进行补集运算返回结果\n\n\n\n# python3\nclass Set(HashTable):\n    def put(self, key):\n        return super(Set, self).put(key, value=True)\n\n    # 并集运算\n    def union(self, other):\n        if isinstance(other, Set):\n            temp = other\n            for key in self._keys:\n                temp.put(key)\n            return temp\n        else:\n            raise TypeError\n\n    # 交集运算\n    def intersection(self, other):\n        if isinstance(other, Set):\n            temp = Set()\n            for key in self._keys:\n                if key in other:\n                    temp.put(key)\n            return temp\n        else:\n            raise TypeError()\n\n    # 补集运算\n    def difference(self, other):\n        if isinstance(other, Set):\n            temp = Set()\n            for key in self._keys:\n                if key not in other:\n                    temp.put(key)\n            return temp\n        else:\n            raise TypeError()\n\n    def __or__(self, other):\n        return self.union(other)\n\n    def __and__(self, other):\n        return self.intersection(other)\n\n    def __sub__(self, other):\n        return self.difference(other)\n\n    def __len__(self):\n        return self._length\n\n    def __iter__(self):\n        for key in self._keys:\n            if key is not None:\n                yield key\n\n    def __contains__(self, key):\n        idx = self._hash_func(key)\n        return self._keys[idx] is not None\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}