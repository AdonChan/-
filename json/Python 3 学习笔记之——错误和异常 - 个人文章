{"title": "Python 3 学习笔记之——错误和异常 - 个人文章 ", "index": "python", "content": "1. 语法错误\nPython 的语法错误被称为解析错，语法分析器会指出出错的代码行，并且在最先找到的错误的位置标记一个小小的箭头。\n>>> while True \n  File \"<stdin>\", line 1\n    while True \n              ^\nSyntaxError: invalid syntax\n2. 异常\n即使 Python 程序的语法是正确的，但是在运行的时候，也有可能发生错误，运行期监测到的错误称为异常。\n>>> print(name)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nNameError: name 'name' is not defined\n\n>>> a = [1, 2, 3]\n>>> b = a(0)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: 'list' object is not callable\n\n>>> 10 / 0\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nZeroDivisionError: division by zero\n3. 异常处理\ntry 语句按照以下方式工作：\n首先，执行 try 子句，也就是在 try 和 except 之间的语句\n\n如果没有异常发生，忽略 except 子句，程序继续运行\n如果在  try 子句执行过程中发生了异常，那么 try 子句余下的部分将被忽略\n若异常的类型和 except 之后的名称相符，那么对应的 except 子句将被执行，然后再执行  try 语句之后的代码\n若异常没有与任何的  except 匹配，那么这个异常将会传递到上层的 try 中去\n\nwhile True:\n    try:\n        x = int(input(\"Please enter a number: \"))\n        break\n    except ValueError:\n        print(\"Oops!  That was no valid number.  Try again!\")\n\nPlease enter a number: we\nOops!  That was no valid number.  Try again!\nPlease enter a number: sd\nOops!  That was no valid number.  Try again!\nPlease enter a number: 23\n\n在上面的例子中，我们让用户通过键盘来输入一个合法的整数。如果输入的是字符串，那 int 函数就无法将字符串转为整数，程序就会抛出一个异常，然后执行 except 子句，打印信息提示我们重新输入，直到输入一个整数程序 break 结束。\n一个 except 子句可以同时处理多个异常，这些异常被放在一个括号里成为一个元组。\nexcept (RuntimeError, TypeError, NameError):\n    pass\n最后一个 except 子句可以忽略异常的名称，它将被当做通配符使用。此时可以打印出错误信息，然后再次把异常抛出。\nimport sys\n\ntry:\n    f = open('test.txt')\n    s = f.readline()\n    i = int(s.strip())\nexcept OSError as err:\n    print(\"OS error: {0}\".format(err))\nexcept ValueError:\n    print(\"Could not convert data to an integer.\")\nexcept:\n    print(\"Unexpected error:\", sys.exc_info()[0])\n    raise\n\n# 没有相应文件时报错\nOS error: [Errno 2] No such file or directory: 'test.txt'\n\n# 文件中第一行为字符串无法转化为整数时报错\nCould not convert data to an integer.\n\ntry except 语句还有一个可选的 else 子句，如果使用这个子句，那么必须放在所有的 except 子句之后。这个子句将在try子句没有发生任何异常的时候执行。\nimport sys\n\ntry:\n    f = open('test.txt')\n    s = f.readline()\n    i = int(s.strip())\nexcept OSError as err:\n    print(\"OS error: {0}\".format(err))\nexcept ValueError:\n    print(\"Could not convert data to an integer.\")\nexcept:\n    print(\"Unexpected error:\", sys.exc_info()[0])\n    raise\n\nelse:\n    print(i)\n\n# 1\n使用 else 子句比把所有语句都放在 try 子句里面要好，这样可以避免一些意想不到的而 except 又没有捕获到的异常。\n异常处理也可以处理子句中调用函数甚至是间接调用函数里抛出的异常。\n3. 用户自定义异常\n我们可以通过创建一个新的异常类来拥有自己的异常。异常类继承自 Exception，可以直接继承，或者间接继承。\nclass MyError(Exception):\n    \n    def __init__(self, value):\n        self.value = value\n    def __str__(self):\n        return repr(self.value)\n\ntry:\n    raise MyError(2*2)\nexcept MyError as e:\n    print('My exception occurred, value:', e.value)\n\n# My exception occurred, value: 4\n\n4. 定义清理行为\ntry 语句还有另外一个可选的子句 finally，它定义了无论任何情况下都会执行的清理行为。\ndef divide(x, y):\n    try:\n        result = x / y\n    except ZeroDivisionError:\n        print(\"division by zero!\")\n    else:\n        print(\"result is\", result)\n    finally:\n        print(\"executing finally clause\")\n   \ndivide(2, 1)\nresult is 2.0\nexecuting finally clause\n\ndivide(2, 0)\ndivision by zero!\nexecuting finally clause\ndivide('2', '1')\nexecuting finally clause\n\nTypeError     Traceback (most recent call last)\n<ipython-input-19-0fe65f250ff1> in <module>()\n----> 1 divide('2', '1')\n\n<ipython-input-16-fb375c737bea> in divide(x, y)\n      1 def divide(x, y):\n      2     try:\n----> 3         result = x / y\n      4     except ZeroDivisionError:\n      5         print(\"division by zero!\")\n\nTypeError: unsupported operand type(s) for /: 'str' and 'str'\n一些对象定义了标准的清理行为，当程序中不需要它的时候，那么这个标准行为就会执行。关键词 with 语句可以保证诸如文件之类的对象在使用完之后一定会正确=地执行清理行为。\n参考资料 菜鸟教程\n获取更多精彩，请关注「seniusen」! \n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}