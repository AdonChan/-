{"title": "Python super()就是这样 - 个人文章 ", "index": "python", "content": "python的类分别有新式类和经典类，都支持多继承。在类的继承中，如果你想要重写父类的方法而不是覆盖的父类方法，这个时候我们可以使用super()方法来实现\n注意\nPython2.2以前的版本：经典类（classic class）时代经典类是一种没有继承的类，实例类型都是type类型，如果经典类被作为父类，子类调用父类的构造函数时会返回这样的错误 '''TypeError: must be type, not classobj'''这时MRO的方法为DFS（深度优先搜索（子节点顺序：从左到右））。所以本文中使用的是新式类，而新式类的搜索算法是C3算法\nclass C(object):\n    def minus(self,x):\n        return x/2\n\nclass D(C):\n    def minus(self,x):\n        super(D, self).minus()\n        print 'hello'\n上面的代码中C是父类，D是子类，我们在D类重新定义了minus方法，就是在C类的功能基础基础上新添print 'hello'功能。super在这里的作用就是在子类中调用父类的方法，这个也是在单继承常见调用super()的用法。那么问题来了\nclass A(object):\n    def __init__(self):\n        self.n = 10\n\n    def minus(self, m):\n        self.n -= m\n\n\nclass B(A):\n    def __init__(self):\n        self.n = 7\n\n    def minus(self, m):\n        super(B,self).minus(m)\n        self.n -= 2\nb=B()\nb.minus(2)\nprint b.n\n\n那么上面的代码中b.n的输出是什么呢？为什么结果是2呢,而不是5呢？super(B,self).minus(m)明明是调用了父类的minus方法,可是输出结果就是2，是你要明白现在B的实例，而不是A的实例，那么传递的self.n的数值是7，而不是10.\n那么对于多继承的时候，super又是怎样工作的呢？来，现在创建一个继承A的C类,然后再创建一个继承B,C的D类,看看怎样调用super是重写方法。\nclass C(A):\n    def __init__(self):\n        self.n = 12\n\n    def minus(self, m):\n        super(C,self).minus(m)\n        self.n -= 5\n\n\nclass D(B, C):\n    def __init__(self):\n        self.n = 15\n\n    def minus(self, m):\n        super(D,self).minus(m)\n        self.n -= 2\n\nd=D()\nd.minus(2)\nprint d.n\n如上的代码输出的结果是什么呢？别心急，先看看它是怎样运行的。上面提及到新式类寻找子节点时候使用的是C3算法。那么它是怎么找呢。D->B->C->A->object。怎样才能验证这个顺序是对的呢。\nD.__mro__\n(<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <type 'object'>)\nMro是什么呢？对于你定义的每一个类，Python 会计算出一个方法解析顺序（Method Resolution Order, MRO）列表，它代表了类继承的顺序。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}