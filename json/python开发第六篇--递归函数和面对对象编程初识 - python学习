{"title": "python开发第六篇--递归函数和面对对象编程初识 - python学习 ", "index": "python", "content": "递归函数\n递归函数的用法：\n- 递归函数：在一个函数里在调用这个函数本身。\n- 递归的最大深度：998\n实例\n找一个函数的索引位置，递归实现\nl = [2,3,5,10,15,16,18,22,26,30,32,35,41,42,43,55,56,66,67,69,72,76,82,83,88]\ndef two_serarch(list,aim,start=0,end=None):\n    end=len(list) -1 if end is None else end\n    if end >= start:\n        mid_index = (end - start) // 2 + start\n        if aim > list[mid_index]:\n            return two_serarch(list,aim,start=mid_index+1,end=end)\n        elif aim < list[mid_index]:\n            return two_serarch(list,aim,start=start,end=mid_index-1)\n        elif aim == list[mid_index]:\n            return mid_index\n        else:\n            return \"没有此值\"\n    else:\n        return \"没有此值\"\n循环一个列表里的元素，遇到列表在循环\ndef each_list(list_name):\n    for i in list_name:\n        if isinstance(i,list):\n            each_list(i)\n        else:\n            print (i)\n面向对象编程\n初识面对对象\n面向过程的程序设计的核心是过程（流水线式思维），过程即解决问题的步骤，面向过程的设计就好比精心设计好一条流水线，考虑周全什么时候处理什么东西。\n- 优点是：极大的降低了写程序的复杂度，只需要顺着要执行的步骤，堆叠代码即可。\n- 缺点是：一套流水线或者流程就是用来解决一个问题，代码牵一发而动全身。\n- 应用场景：一旦完成基本很少改变的场景，著名的例子有Linux內核，git,以及Apache HTTP Server等。\n\n面向对象的程序设计的核心是对象（上帝式思维），要理解对象为何物，必须把自己当成上帝，上帝眼里世间存在的万物皆为对象，不存在的也可以创造出来。面向对象的程序设计好比如来设计西游记，如来要解决的问题是把经书传给东土大唐，如来想了想解决这个问题需要四个人：唐僧，沙和尚，猪八戒，孙悟空，每个人都有各自的特征和技能（这就是对象的概念，特征和技能分别对应对象的属性和方法），然而这并不好玩，于是如来又安排了一群妖魔鬼怪，为了防止师徒四人在取经路上被搞死，又安排了一群神仙保驾护航，这些都是对象。然后取经开始，师徒四人与妖魔鬼怪神仙互相缠斗着直到最后取得真经。如来根本不会管师徒四人按照什么流程去取。面向对象的程序:\n- 优点是：解决了程序的扩展性。对某一个对象单独修改，会立刻反映到整个体系中，如对游戏中一个人物参数的特征和技能修改都很容易。\n- 缺点：可控性差，无法向面向过程的程序设计流水线式的可以很精准的预测问题的处理流程与结果，面向对象的程序一旦开始就由对象之间的交互解决问题，即便是上帝也无法预测最终结果。于是我们经常看到一个游戏人某一参数的修改极有可能导致阴霸的技能出现，一刀砍死3个人，这个游戏就失去平衡。\n- 应用场景：需求经常变化的软件，一般需求的变化都集中在用户层，互联网应用，企业内部软件，游戏等都是面向对象的程序设计大显身手的好地方。\n名词：类、对象、实例、实例化\n类的相关知识\n1.声明\ndef functionName(args):\n     '函数文档字符串'\n      函数体 \n'''\nclass 类名:\n    '类的文档字符串'\n    类体\n'''\n#我们创建一个类\nclass Data:\n    pass\n2.属性\nclass Person:   #定义一个人类\n    role = 'person'  #人的角色属性都是人\n    def walk(self):  #人都可以走路，也就是有一个走路方法\n        print(\"person is walking...\")\nprint(Person.role)  #查看人的role属性\nprint(Person.walk)  #引用人的走路方法，注意，这里不是在调用\n3.实例化：类名加括号就是实例化，会自动触发__init__函数的运行，可以用它来为每个实例定制自己的特征\nclass Person:   #定义一个人类\n    role = 'person'  #人的角色属性都是人\n    def __init__(self,name):\n        self.name = name  # 每一个角色都有自己的昵称;\n        \n    def walk(self):  #人都可以走路，也就是有一个走路方法\n        print(\"person is walking...\")\n\n\nprint(Person.role)  #查看人的role属性\nprint(Person.walk)  #引用人的走路方法，注意，这里不是在调用\n4.实例化的过程就是类——>对象的过程\n- 语法：对象名 = 类名(参数)\n    1.创建一个对象，开辟一个空间\n    2.自动执行__init__方法，并且对象本身传给self\n    3.将传进的内容封装给对象本身\n\n5.类属性的补充\n一：我们定义的类的属性到底存到哪里了？有两种方式查看\ndir(类名)：查出的是一个名字列表\n类名.__dict__:查出的是一个字典，key为属性名，value为属性值\n\n二：特殊的类属性\n类名.__name__# 类的名字(字符串)\n类名.__doc__# 类的文档字符串\n类名.__base__# 类的第一个父类\n类名.__bases__# 类所有父类构成的元组\n类名.__dict__# 类的字典属性\n类名.__module__# 类定义所在的模块\n类名.__class__# 实例对应的类(仅新式类中)\n对象的相关知识\nclass 类名:\n    def __init__(self,参数1,参数2):\n        self.对象的属性1 = 参数1\n        self.对象的属性2 = 参数2\n    def 方法名(self):pass\n    def 方法名2(self):pass\n\n对象名 = 类名(1,2)  #对象就是实例，代表一个具体的东西\n                  #类名() : 类名+括号就是实例化一个类，相当于调用了__init__方法\n                  #括号里传参数，参数不需要传self，其他与init中的形参一一对应\n                  #结果返回一个对象\n对象名.对象的属性1   #查看对象的属性，直接用 对象名.属性名 即可\n对象名.方法名()     #调用类中的方法，直接用 对象名.方法名() 即可\n练习：\n练习一：在终端输出如下信息\n\n小明，10岁，男，上山去砍柴\n小明，10岁，男，开车去东北\n小明，10岁，男，最爱大保健\n老李，90岁，男，上山去砍柴\n老李，90岁，男，开车去东北\n老李，90岁，男，最爱大保健\nclass Output:\n    def __init__(self,name,age,sex):\n        self.name = name\n        self.age = age\n        self.sex = sex\n    def chopp_wood(self):\n        print(\"{name},{age}岁,{sex},上山去砍柴\".format(name=self.name,age=self.age,sex=self.sex))\n    def drive_car(self):\n        print(\"{name},{age}岁,{sex},开车去东北\".format(name=self.name,age=self.age,sex=self.sex))\n    def health_care(self):\n        print(\"{name},{age}岁,{sex},最爱大保健\".format(name=self.name,age=self.age,sex=self.sex))\nxiaoming = Output(\"小明\",10,\"男\")  #实例化两个对象\nlaoli = Output(\"老李\",90,\"男\")\nxiaoming.chopp_wood()  \nxiaoming.drive_car()\nxiaoming.health_care()\nlaoli.chopp_wood()\nlaoli.drive_car()\nlaoli.health_care()\n类名称空间与对象的名称空间\n1.创建一个类就会创建一个类的名称空间，用来存储类中定义的所有名字，这些名字称为类的属性\n- 类有两种属性：静态属性和动态属性\n    1.静态属性就是直接在类中定义的变量\n    2.动态属性就是定义在类中的方法\n- 其中类的数据属性是共享给所有对象的\n- 而类的动态属性是绑定到所有对象的\n2.创建一个对象/实例就会创建一个对象/实例的名称空间，存放对象/实例的名字，称为对象/实例的属性在obj.name会先从obj自己的名称空间里找name，找不到则去类中找，类也找不到就找父类...最后都找不到就抛出异常\n面向对象的三大特性:继承,多态,封装\n1.继承\n- 继承是一种创建新类的方式，在python中，新建的类可以继承一个或多个父类，父类又可称为基类或超类，新建的类称为派生类或子类。\npython中类的继承分为：单继承和多继承\nclass ParentClass1: #定义父类\n    pass\n\nclass ParentClass2: #定义父类\n    pass\n\nclass SubClass1(ParentClass1): #单继承，基类是ParentClass1，派生类是SubClass\n    pass\n\nclass SubClass2(ParentClass1,ParentClass2): #python支持多继承，用逗号分隔开多个继承的类\n    pass\n查看继承：\nprint(SubClass1.__bases__)#__base__只查看从左到右继承的第一个子类，__bases__则是查看所有继承的父类\nprint(SubClass2.__bases__)\n如果没有指定基类，python的类会默认继承object类\nprint(ParentClass1.__bases__)\nprint(ParentClass2.__bases__)\n(<class 'object'>,)\n(<class 'object'>,)\n2.继承的重要性\n- 继承来重用代码\n==========================第一部分\n例如\n\n　　猫可以：爬树、吃、喝、拉、撒\n\n　　狗可以：看门、吃、喝、拉、撒\n\n如果我们要分别为猫和狗创建一个类，那么就需要为 猫 和 狗 实现他们所有的功能，伪代码如下：\n \n\n#猫和狗有大量相同的内容\nclass 猫：\n\n    def爬树(self):\n        print '爬树'\n\n    def 吃(self):\n        # do something\n\n    def 喝(self):\n        # do something\n\n    def 拉(self):\n        # do something\n\n    def 撒(self):\n        # do something\n\nclass 狗：\n\n    def 看门(self):\n        print '看门'\n\n    def 吃(self):\n        # do something\n\n    def 喝(self):\n        # do something\n\n    def 拉(self):\n        # do something\n\n    def 撒(self):\n        # do something\n\n\n\n==========================第二部分\n上述代码不难看出，吃、喝、拉、撒是猫和狗都具有的功能，而我们却分别的猫和狗的类中编写了两次。如果使用 继承 的思想，如下实现：\n\n　　动物：吃、喝、拉、撒\n\n　　   猫：爬树（猫继承动物的功能）\n\n　　   狗：看门（狗继承动物的功能）\n\n伪代码如下：\nclass 动物:\n\n    def 吃(self):\n        # do something\n\n    def 喝(self):\n        # do something\n\n    def 拉(self):\n        # do something\n\n    def 撒(self):\n        # do something\n\n# 在类后面括号中写入另外一个类名，表示当前类继承另外一个类\nclass 猫(动物)：\n\n    def爬树(self):\n        print '爬树'\n\n# 在类后面括号中写入另外一个类名，表示当前类继承另外一个类\nclass 狗(动物)：\n\n     def 看门(self):\n        print '看门'\n\n\n\n\n==========================第三部分\n#继承的代码实现\nclass Animal:\n\n    def eat(self):\n        print(\"%s 吃 \" %self.name)\n\n    def drink(self):\n        print (\"%s 喝 \" %self.name)\n\n    def shit(self):\n        print (\"%s 拉 \" %self.name)\n\n    def pee(self):\n        print (\"%s 撒 \" %self.name)\n\n\nclass Cat(Animal):\n\n    def __init__(self, name):\n        self.name = name\n        self.breed = '猫'\n\n    def爬树(self):\n        print '爬树'\n\nclass Dog(Animal):\n\n    def __init__(self, name):\n        self.name = name\n        self.breed='狗'\n  \n    def 看门(self):\n        print '看门'\n\n\n\n# ######### 执行 #########\n代码如下：\n\nclass Animal:\n\n    def eat(self):\n        print(\"%s 吃 \" % self.name)\n\n    def drink(self):\n        print(\"%s 喝 \" % self.name)\n\n    def shit(self):\n        print(\"%s 拉 \" % self.name)\n\n    def pee(self):\n        print(\"%s 撒 \" % self.name)\n\n\nclass Cat(Animal):\n\n    def __init__(self, name):\n        self.name = name\n\n    def up_tree(self):\n        print(\"爬树\")\n\n\nclass Dog(Animal):\n\n    def __init__(self, name):\n        self.name = name\n        self.breed = '狗'\n\n    def look_door(self):\n        print(\"看门\")\n\nmao = Cat(\"二虎\")\nmao.eat()\nmao.drink()\nmao.shit()\nmao.pee()\nmao.up_tree()\n\n3.Python的类继承了多个类，那么其寻找方法的方式有两种，分别是：深度优先和广度优先\n- 当类是经典类时，多继承情况下，会按照深度优先方式查找。\n- 当类是新式类时，多继承情况下，会按照广度优先方式查找。\n- 经典类和新式类，从字面上可以看出一个老一个新，新的必然包含了跟多的功能，也是之后推荐的写法，从写法上区分的话，如果 当前类或者父类继承了object类，那么该类便是新式类，否则便是经典类。\n- python2默认是经典类\n- python3默认是新式类\n经典类继承：\nclass D:\n    def bar(self):\n        print 'D.bar'\nclass C(D):\n    def bar(self):\n        print 'C.bar'\nclass B(D):\n    def bar(self):\n        print 'B.bar'\nclass A(B, C):\n    def bar(self):\n        print 'A.bar'\na = A()\n# 执行bar方法时\n# 首先去A类中查找，如果A类中没有，则继续去B类中找，如果B类中么有，则继续去D类中找，如果D类中么有，则继续去C类中找，如果还是未找到，则报错\n# 所以，查找顺序：A --> B --> D --> C\n# 在上述查找bar方法的过程中，一旦找到，则寻找过程立即中断，便不会再继续找了\na.bar()\n经典类多继承\n新式类继承：\n\nclass D(object):\n    def bar(self):\n        print 'D.bar'\nclass C(D):\n    def bar(self):\n        print 'C.bar'\nclass B(D):\n    def bar(self):\n        print 'B.bar'\nclass A(B, C):\n    def bar(self):\n        print 'A.bar'\na = A()\n# 执行bar方法时\n# 首先去A类中查找，如果A类中没有，则继续去B类中找，如果B类中么有，则继续去C类中找，如果C类中么有，则继续去D类中找，如果还是未找到，则报错\n# 所以，查找顺序：A --> B --> C --> D\n# 在上述查找bar方法的过程中，一旦找到，则寻找过程立即中断，便不会再继续找了\na.bar()\n新式类多继承\n经典类：首先去A类中查找，如果A类中没有，则继续去B类中找，如果B类中么有，则继续去D类中找，如果D类中么有，则继续去C类中找，如果还是未找到，则报错新式类：首先去A类中查找，如果A类中没有，则继续去B类中找，如果B类中么有，则继续去C类中找，如果C类中么有，则继续去D类中找，如果还是未找到，则报错注意：在上述查找过程中，一旦找到，则寻找过程立即中断，便不会再继续找了4.组合组合指的是，在一个类中以另外一个类的对象作为数据属性，称为类的组合文字游戏：\nclass Game_person:\n    def __init__(self,nickname,sex,hp,ad):\n        self.nickname = nickname\n        self.sex = sex\n        self.hp = hp\n        self.ad = ad\n    def attack(self,p):\n        p.hp = p.hp - self.ad   #剩余血量\n        print('%s攻击了%s,%s还剩%s血量'%(self.nickname,p.nickname,p.nickname,p.hp))\n    def wuqi(self,wuqi):\n        self.wuqi = wuqi   #tian.wuqi(wuqi1)武器类的对象封装到人的对象中当做一个属性.就叫做组合.\nclass Weapon:\n    def __init__(self,name,ad):  #武器的名字，武器的伤害\n        self.name =name\n        self.ad =ad\n    def fight(self,p1,p2):\n        p2.hp = p2.hp - self.ad\n        print('%s使用%s打了%s%s血,%s还剩%s滴血'%(p1.nickname,self.name ,p2.nickname,self.ad,p2.nickname,p2.hp))\n\ntian = Game_person(\"TIAN\",\"男\",200,10)\ndidi = Game_person(\"DIDI\",\"女\",200,50)\nwuqi = Weapon(\"鞭子\",50)\ntian.wuqi(wuqi)\ntian.wuqi.fight(tian,didi)\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}