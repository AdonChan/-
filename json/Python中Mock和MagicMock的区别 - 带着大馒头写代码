{"title": "Python中Mock和MagicMock的区别 - 带着大馒头写代码 ", "index": "mock,python", "content": "Python的unittest.mock模块中提供了两个主要的mock类，分别是Mock和MagicMock.\n先看一下官方文档的定义：\nMagicMock is a subclass of Mock with all the magic methods pre-created and ready to use.\n其实已经很清楚了，MagicMock是Mock的子类，并且预先创建了全部magic method的mock。也就是说，如果不需要mock magic method，两者使用起来并没有什么分别。\n来看个例子，先定义个类，里面只有一个成员方法，返回10倍的数值:\nclass Person:\n    def get_10_times_value(self, value)\n        return 10 * value\n使用Mock类来mock掉这个成员方法：\ndef test_should_mock_get_10_times_value_with_Mock(self):\n    p = Person()\n    p.get_10_times_value = Mock(return_value=100)\n    \n    self.assertEqual(p.get_10_times_value(), 100)\n使用MagicMock类来mock：\ndef test_should_mock_get_10_times_value_with_MagicMock(self):\n    p = Person()\n    p.get_10_times_value = MagicMock(return_value=100)\n    \n    self.assertEqual(p.get_10_times_value(), 100)\n两者没有任何区别，都成功了mock了成员方法。\n再看下两者的区别：\ndef test_should_raise_exception(self):\n    m = Mock()\n    list(m)\n\nTypeError: 'Mock' object is not iterable\n因为使用Mock类时，默认不会创建__iter__这个magic method的mock，所以报错。\n如果想mock __iter__这个方法，得自己去做，如下：\ndef test_should_mock_magic_method_with_Mock(self):\n    m = Mock()\n    m.__iter__ = Mock(return_value=iter([]))\n    \n    self.assertEqual(list(m), [])\n而使用MagicMock类时默认就会mock掉所有的magic method，所以不需要自己mock，__iter__默认是空数组：\ndef test_should_mock_magic_method_with_MagicMock(self):\n    m = MagicMock()\n    \n    self.assertEqual(list(m), [])\n因为已经默认创建了magic method的mock，所以可以直接使用return_value属性来改变值：\ndef test_should_mock_magic_method_with_MagicMock(self):\n    m = MagicMock()\n    m.__iter__.return_value = [1, 2, 3]\n    \n    self.assertEqual(list(m), [1, 2, 3])\n其他magic method类似。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "1"}