{"title": "Python装饰器 - 个人文章 ", "index": "python", "content": "一, 引用\n\n[书] 流畅的Python\n[书] Effective Python\n\n\n二, 基本概念\n\n问题１：装饰器是什么？\n解答：　严格来说，装饰器只是语法糖，　装饰器是可调用的对象，可以像常规的可调用对象那样调用，特殊的地方是装饰器的参数是一个函数\n问题２：装饰器有什么特性？\n解答：　装饰器有２个特性，一是可以把被装饰的函数替换成其他函数，　二是可以在加载模块时候立即执行\ndef decorate(func):\n    print('running decorate', func)\n    def decorate_inner():\n        print('running decorate_inner function')\n        return func()\n    return decorate_inner\n\n@decorate\ndef func_1():\n    print('running func_1')\n\nif __name__ == '__main__':\n\n    print(func_1)\n\n＃返回值\nrunning decorate <function func_1 at 0x7f29f644d268>\n<function decorate.<locals>.decorate_inner at 0x7f29f641cb70>\n\n问题３：如何使用被装饰函数中的参数？\n解答：　通过args 和　*kwargs 传递被修饰函数中的参数\ndef decorate(func):\n    def decorate_inner(*args, **kwargs):\n        print(type(args), type(kwargs))\n        print('args', args, 'kwargs', kwargs)\n        return func(*args, **kwargs)\n    return decorate_inner\n\n@decorate\ndef func_1(*args, **kwargs):\n    print(args, kwargs)\n\nif __name__ == '__main__':\n\n    func_1('1', '2', '3', para_1='1', para_2='2', para_3='3')\n\n#返回值\n<class 'tuple'> <class 'dict'>\nargs ('1', '2', '3') kwargs {'para_2': '2', 'para_1': '1', 'para_3': '3'}\n('1', '2', '3') {'para_2': '2', 'para_1': '1', 'para_3': '3'}\n\n三, 叠放装饰器\n\n问题１：叠放装饰器执行顺序是什么？\n解答：　如果一个函数被多个装饰器修饰，其实应该是该函数先被最里面的装饰器修饰后（下面例子中函数main()先被inner装饰，变成新的函数），变成另一个函数后，再次被装饰器修饰\ndef outer(func):\n    print('enter outer', func)\n    def wrapper():\n        print('running outer')\n        func()\n    return wrapper\n\ndef inner(func):\n    print('enter inner', func)\n    def wrapper():\n        print('running inner')\n        func()\n    return wrapper\n\n@outer\n@inner\ndef main():\n    print('running main')\n\nif __name__ == '__main__':\n\n    main()\n\n＃返回值\n\nenter inner <function main at 0x7fa1c96e8b70>\nenter outer <function inner.<locals>.wrapper at 0x7fa1c96e8bf8>\nrunning outer\nrunning inner\nrunning main\n\n四, 标准库中的装饰器\n\n问题１：　标准库中都有哪些装饰器？\n解答：　标准库中有多种装饰器，　例如：装饰方法的函数有property, classmethod, staticmethod；　functools模块中的lru_cache, singledispatch,  wraps 等等\nfrom functools import lru_cache\nfrom functools import singledispatch\nfrom functools import wraps\n问题２：为什么要使用@wraps装饰器？它的作用是什么？\n解答：　使用装饰器会产生我们可能不希望出现的副作用，　例如：改变被修饰函数名称，对于调试器或者对象序列化器等需要使用内省机制的那些工具，可能会无法正常运行；其实调用装饰器后，会将同一个作用域中原来函数同名的那个变量（例如下面的func_1）,重新赋值为装饰器返回的对象；使用＠wraps后，会把与内部函数（被修饰函数，例如下面的func_1）相关的重要元数据全部复制到外围函数（例如下面的decorate_inner）\nfrom functools import wraps\n\ndef decorate(func):\n    print('running decorate', func)\n    @wraps(func)\n    def decorate_inner():\n        print('running decorate_inner function', decorate_inner)\n        return func()\n    return decorate_inner\n\n@decorate\ndef func_1():\n    print('running func_1', func_1)\n\nif __name__ == '__main__':\n\n    func_1()\n\n＃返回值\nrunning decorate <function func_1 at 0x7f145d2c2268>\nrunning decorate_inner function <function func_1 at 0x7f145b9731e0>\nrunning func_1 <function func_1 at 0x7f145b9731e0>\n\n\n五, 装饰器设计模式\n\n问题１：　什么是装饰器设计模式？\n解答：　动态的给一个对象添加一些额外的职责，就扩展功能而言，装饰器模式比子类化更加灵活，在设计模式中，装饰器和组件都是抽象类，为了给具体的组件添加行为，具体的装饰器实例要包装具体组件的实例，即，装饰器和所装饰的组件接口一致，对使用该组建的客户透明，将客户的请求转发给该组件，并且可能在转发前后执行一些额外的操作，透明性使得可以递归嵌套多个装饰器，从而可以添加任意多个功能\n问题２：　Python中的装饰器函数和设计模式中的装饰器模式有什么关系？\n解答：　　修饰器模式和Python修饰器之间并不是一对一的等价关系，　Python装饰器函数更为强大，不仅仅可以实现装饰器模式。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "9"}