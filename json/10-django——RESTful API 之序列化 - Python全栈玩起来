{"title": "10-django——RESTful API 之序列化 - Python全栈玩起来 ", "index": "python,django", "content": "Django RESTful API之序列化\n前后端分离：就是前台的开发和后台的开发分离，这个技术方案的实现需要借助API，简单来说就是开发人员提供编程的接口被其他人调用，调用之后会返回数据供其使用\n安装：pip  install  djangorestframework\n什么是序列化？:把模型对象转换为JSON格式然后响应出去，便于客户端进行数据解析\n创建序列化类\n在应用目录下创建名为serializers.py的文件\nfrom rest_framework import serializers\nfrom myApp.models import Student, Grade\n#给学生类创建序列化类\nclass StudentSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Student\n        fields = (\"id\", \"name\", \"sex\", \"age\", \"content\", \"isDelete\", \"grade\")\n#该班级创建序列化类\nclass GradeSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Grade\n        fields = (\"id\", \"name\", \"boyNum\", \"girlNum\", \"isDelete\")\n使用系列化\n\n进入shell环境：python  manage.py  shell\n\n引入序列化类，创建序列化对象查看可序列化的字段:\n\n>>> from myApp.serializers import StudentSerializer\n>>> serializer = StudentSerializer()\n>>> print(serializer)\nStudentSerializer():\n    id = IntegerField(label='ID', read_only=True)\n    name = CharField(max_length=20)\n    sex = BooleanField(required=False)\n    age = IntegerField(max_value=2147483647, min_value=-2147483648)\n    contend = CharField(max_length=40)\n    isDelete = BooleanField(label='IsDelete', required=False)\n    grade = PrimaryKeyRelatedField(queryset=Grade.objects.all())\n找到一个学生:\n>>> from myApp.models import Student\n>>> stu = Student.objects.get(pk=1)\n>>> print(stu)\n薛延美\n依据学生创建序列化对象，再对对象进行序列化操作:\n>>> serializer = StudentSerializer(stu)\n>>> print(serializer.data)\n{'id': 1, 'name': '薛延美', 'sex': False, 'age': 20, 'contend': '我叫薛延美', 'isDelete': False, 'grade': 4}\n>>> print(type(serializer.data))\n<class 'rest_framework.utils.serializer_helpers.ReturnDict'>\n将数据渲染成JSON格式\n>>> from rest_framework.renderers import JSONRenderer\n>>> content = JSONRenderer().render(serializer.data)\n>>> print(content)\nb'{\"id\":1,\"name\":\"\\xe8\\x96\\x9b\\xe5\\xbb\\xb6\\xe7\\xbe\\x8e\",\"sex\":false,\"age\":20,\"contend\":\"\\xe6\\x88\n\\x91\\xe5\\x8f\\xab\\xe8\\x96\\x9b\\xe5\\xbb\\xb6\\xe7\\xbe\\x8e\",\"isDelete\":false,\"grade\":4}'\n反序列化:当客户需要修改、增加、删除数据时，就要这个过程反过来，就叫反序列化\n>>> from rest_framework.parsers import JSONParser\n>>> from django.utils.six import BytesIO\n>>> stream = BytesIO(content)\n>>> print(stream)\n<_io.BytesIO object at 0x000001EECF597E08>\n>>> stu2 = JSONParser().parse(stream)\n>>> print(stu2)\n{'id': 1, 'name': '薛延美', 'sex': False, 'age': 20, 'contend': '我叫薛延美', 'isDelete': False, 'grade': 4}\n>>> print(type(stu2))\n<class 'dict'>\n检测数据并保存\n>>> stu2.save()\nTraceback (most recent call last):\n  File \"<console>\", line 1, in <module>\nAttributeError: 'dict' object has no attribute 'save'\n>>> serializer = StudentSerializer(data=stu2)\n>>> print(serializer.is_valid())\nTrue\n>>> print(serializer.validated_data)\nOrderedDict([('name', '薛延美'), ('sex', False), ('age', 20), ('contend', '我叫薛延美'), ('isDel\nete', False), ('grade', <Grade: python04>)])\n>>> print(type(serializer.validated_data))\n<class 'collections.OrderedDict'>\n>>> print(serializer.validated_data[\"name\"])\n薛延美\n>>> serializer.save()\n<Student: 薛延美>\n视图实现使用序列化\nfrom django.shortcuts import render\nfrom django.http import HttpResponse, JsonResponse\n\nfrom myApp.models import Student, Grade\n\nfrom rest_framework.renderers import JSONRenderer\nfrom rest_framework.parsers import JSONParser\nfrom django.utils.six import BytesIO\n\nfrom myApp.serializers import StudentSerializer, GradeSerializer\n\ndef studentsList(request):\n    if request.method == \"GET\":\n        stus = Student.objects.all()\n        #序列化\n        serializer = StudentSerializer(stus, many=True)\n        return JsonResponse(serializer.data, safe=False)\n    elif request.method == \"POST\":\n        # content = JSONRenderer().render(request.POST)\n        # stream = BytesIO(content)\n        # stuDict = JSONParser().parse(stream)\n        # serializer = StudentSerializer(data=stuDict)\n        serializer = StudentSerializer(data=request.POST)\n        if serializer.is_valid():\n            #存数据\n            serializer.save()\n            return JsonResponse(serializer.data, status=201)\n        return JsonResponse({\"error\":serializer.errors}, status=400)\ndef studentDetail(request, pk):\n    try:\n        stu = Student.objects.get(pk=pk)\n    except Student.DoesNotExist as e:\n        return JsonResponse({\"error\":str(e)}, status=404)\n\n    if request.method == \"GET\":\n        serializer = StudentSerializer(stu)\n        return JsonResponse(serializer.data)\n    elif request.method == \"PUT\":\n        #content = JSONRenderer().render(request.data)\n        #stream = BytesIO(content)\n        #stuDict = JSONParser().parse(stream)\n        # print(stuDict)\n        #修改\n        serializer = StudentSerializer(stu, data=request.data)\n        if serializer.is_valid():\n            #存数据\n            serializer.save()\n            return JsonResponse(serializer.data, status=201)\n        return JsonResponse({\"error\":serializer.errors}, status=400)\n    elif request.method == \"DELETE\":\n        stu.delete()\n        return HttpResponse(status=204,content_type=\"application/json\")\nDjango  RESTful  API  之请求与响应\n激活应用\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'myApp',\n    'rest_framework',\n]\nRequest对象\nrequest.POST: 只能处理表单数据，并且只能处理POST请求扩展:  request.data   能处理各种请求的数据，可以处理PUT和PATCH请求的数据\n\nResponse对象\nHttpResponse、JsonResponse类: 用于返回json数据，在return的时候需要指明json格式扩展: Reponse类   会根据客户端的请求头信息返回正确的内容类型\n\n状态码\n发送http请求会返回各种各样的状态码，但是状态码都是数字，不能够明确的让程序员了解是什么问题扩展  HTTP_400_BAD_REQUEST  极大提高了可读性\n\n视图\n\n@api_view: 是装饰器，用在基于函数的视图上\nAPIView:  是类，用在基于类的视图上\n作用: 提供一些功能，让程序员省去了很多工作，确保在视图中收到request对象或在对象中添加上下文 装饰器可以在接收到输入错误的request.data时抛出ParseError异常，在适当的时候返回405状态码\n\n代码\n# from django.shortcuts import render\n# from django.http import HttpResponse, JsonResponse\nfrom myApp.models import Student, Grade\n\n# from rest_framework.renderers import JSONRenderer\n# from rest_framework.parsers import JSONParser\n# from django.utils.six import BytesIO\n\nfrom myApp.serializers import StudentSerializer\n\nfrom rest_framework import status\nfrom rest_framework.decorators import api_view\nfrom rest_framework.response import Response\n\n@api_view([\"GET\", \"POST\"])\ndef studentsList(request):\n    if request.method == \"GET\":\n        stus = Student.objects.all()\n        #序列化\n        serializer = StudentSerializer(stus, many=True)\n        # 不需要指定json格式，返回客户端可以返回json或者HTML，返回HTML内容的话，会在浏览器中经过渲染成页面\n        return Response(serializer.data, status=status.HTTP_200_OK)\n    elif request.method == \"POST\":\n        # content = JSONRenderer().render(request.POST)\n        # stream = BytesIO(content)\n        # stuDict = JSONParser().parse(stream)\n        serializer = StudentSerializer(data=request.data)\n        if serializer.is_valid():\n            #存数据\n            serializer.save()\n            return Response(serializer.data, status=status.HTTP_201_CREATED)\n        return Response({\"error\":serializer.errors}, status=status.HTTP_400_BAD_REQUEST)\n\n@api_view([\"GET\", \"PUT\", \"DELETE\"])\ndef studentDetail(request, pk):\n    try:\n        stu = Student.objects.get(pk=pk)\n    except Student.DoesNotExist as e:\n        return Response({\"error\":str(e)}, status=status.HTTP_404_NOT_FOUND)\n\n    if request.method == \"GET\":\n        serializer = StudentSerializer(stu)\n        return Response(serializer.data)\n    elif request.method == \"PUT\":\n        # content = JSONRenderer().render(request.POST)\n        # stream = BytesIO(content)\n        # stuDict = JSONParser().parse(stream)\n        # print(stuDict)\n        #修改\n        serializer = StudentSerializer(stu, data=request.data)\n        if serializer.is_valid():\n            #存数据\n            serializer.save()\n            return Response(serializer.data, status=status.HTTP_201_CREATED)\n        return Response({\"error\":serializer.errors}, status=status.HTTP_400_BAD_REQUEST)\n    elif request.method == \"DELETE\":\n        stu.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n向URL添加可选的后缀\n视图\ndef studentsList(request, format=None):\ndef studentDetail(request, pk, format=None):\n路由\nfrom django.conf.urls import url\nfrom myApp import views\n#格式后缀\nfrom rest_framework.urlpatterns import format_suffix_patterns\n\nurlpatterns = [\n    # GET /students/\n    # POST /students/\n    url(r'^students/$', views.studentsList),\n    # GET /students/id\n    # PUT /students/id\n    # PATCH /students/id\n    # DELETE /students/id\n    url(r'^students/(?P<pk>\\d+)/$', views.studentDetail),\n]\nurlpatterns = format_suffix_patterns(urlpatterns)\n测试\nhttp://127.0.0.1:8000/students.api\nhttp://127.0.0.1:8000/students.json\nDjango  RESTful  API  之基于类的视图\n把视图变成类\nfrom myApp.models import Student\nfrom myApp.serializers import StudentSerializer\nfrom rest_framework import status\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\nfrom django.http import Http404\n\nclass StudentsList(APIView):\n    def get(self, request, format=None):\n        stus = Student.objects.all()\n        serializer = StudentSerializer(stus, many=True)\n        return Response(serializer.data, status=status.HTTP_200_OK)\n    def post(self, request, format=None):\n        serializer = StudentSerializer(data=request.data)\n        if serializer.is_valid():\n            serializer.save()\n            return Response(serializer.data, status=status.HTTP_201_CREATED)\n        return Response({\"error\": serializer.errors}, status=status.HTTP_400_BAD_REQUEST)\n\nclass StudentDetail(APIView):\n    def getObject(self, pk):\n        try:\n            return Student.objects.get(pk=pk)\n        except Student.DoesNotExist as e:\n            raise Http404\n    def get(self, request, pk, format=None):\n        stu = self.getObject(pk)\n        serializer = StudentSerializer(stu)\n        return Response(serializer.data)\n    def put(self, request, pk, format=None):\n        stu = self.getObject(pk)\n        serializer = StudentSerializer(stu, data=request.data)\n        if serializer.is_valid():\n            serializer.save()\n            return Response(serializer.data, status=status.HTTP_201_CREATED)\n        return Response({\"error\": serializer.errors}, status=status.HTTP_400_BAD_REQUEST)\n    def delete(self, request, pk, format=None):\n        stu = self.getObject(pk)\n        stu.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n修改路由匹配类视图\nfrom django.conf.urls import url\nfrom myApp import views\n#格式后缀\nfrom rest_framework.urlpatterns import format_suffix_patterns\n\nurlpatterns = [\n    # GET /students/\n    # POST /students/\n    url(r'^students/$', views.StudentsList.as_view()),\n    # GET /students/id\n    # PUT /students/id\n    # PATCH /students/id\n    # DELETE /students/id\n    url(r'^students/(?P<pk>\\d+)/$', views.StudentDetail.as_view()),\n]\nurlpatterns = format_suffix_patterns(urlpatterns)\n优点\n\n把各种HTTP请求分离开\n可以轻松构成可重复使用的行为\n可以大大简化代码\n增加了可读性\n\n使用Mixins类\n基本使用\nfrom myApp.models import Student\nfrom myApp.serializers import StudentSerializer\nfrom rest_framework import mixins, generics\n\n#父类中有且只有一个能继承自APIView类\nclass StudentsList(mixins.ListModelMixin, mixins.CreateModelMixin, generics.GenericAPIView):\n    queryset = Student.objects.all()\n    serializer_class = StudentSerializer\n    def get(self, request, *args, **kwargs):\n        return self.list(request, *args, **kwargs)\n    def post(self, request, *args, **kwargs):\n        return self.create(request, *args, **kwargs)\n\nclass StudentDetail(mixins.RetrieveModelMixin, mixins.UpdateModelMixin, mixins.DestroyModelMixin, generics.GenericAPIView):\n    queryset = Student.objects.all()\n    serializer_class = StudentSerializer\n    def get(self, request, *args, **kwargs):\n        return self.retrieve(request, *args, **kwargs)\n    def put(self, request, *args, **kwargs):\n        return self.update(request, *args, **kwargs)\n    def delete(self, request, *args, **kwargs):\n        return self.destroy(request, *args, **kwargs)\n通用视图使用\nfrom myApp.models import Student\nfrom myApp.serializers import StudentSerializer\nfrom rest_framework import generics\nclass StudentsList(generics.ListCreateAPIView):\n    queryset = Student.objects.all()\n    serializer_class = StudentSerializer\nclass StudentDetail(generics.RetrieveUpdateDestroyAPIView):\n    queryset = Student.objects.all()\n    serializer_class = StudentSerializer\nDjango  RESTful  API  之认证和权限\n如果没有权限认证功能，任何资源都会被任何用户随意修改，所以实现如下功能\n\nStudent与其创建者相互关联\n只有经过身份验证(登陆)的用户才可以创建Student对象\n只有创建该Student对象的用户才可以对齐进行更新或者删除\n未经验证的用户只有访问(只读)的功能\n\n给学生添加所属用户字段：owner = models.ForeignKey(\"auth.User\", related_name=\"students\")\n重新生成表\n创建几个用户  python  manage.py  createsuperuser\n在serializers.py文件中给User添加序列化类\nfrom django.contrib.auth.models import User\nclass UserSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = User\n        fields = (\"id\", \"username\", \"students\")\n增加用户的接口\n路由\nfrom django.conf.urls import url\nfrom myApp import views\n#格式后缀\nfrom rest_framework.urlpatterns import format_suffix_patterns\n\nurlpatterns = [\n    url(r'^students/$', views.StudentsList.as_view()),\n    url(r'^students/(?P<pk>\\d+)/$', views.StudentDetail.as_view()),\n\n    url(r'^users/$', views.UsersList.as_view()),\n    url(r'^users/(?P<pk>\\d+)/$', views.UserDetail.as_view()),\n]\nurlpatterns = format_suffix_patterns(urlpatterns)\n视图\nfrom django.contrib.auth.models import  User\nclass UsersList(generics.ListCreateAPIView):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\nclass UserDetail(generics.RetrieveDestroyAPIView):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n把Student和User关联\n概述: 还不能把Student和User关联，因为在使用的时候User的数据时通过Request传入的，而不是以序列化数据传递的，此时刚才添加了一个owner作为外键，此时使用外键\nclass StudentsList(generics.ListCreateAPIView):\n    queryset = Student.objects.all()\n    serializer_class = StudentSerializer\n    \n    #让用户在通过post请求创建一个新的student时，在保证创建学生时会把request中的user赋值给该学生的owner字段\n    def perform_create(self, serializer):\n        serializer.save(owner=self.request.user)\n在显示学生时还需要显示学生属于哪个用户\nclass StudentSerializer(serializers.ModelSerializer):\n    class Meta:\n        owner = serializers.ReadOnlyField(source=\"owner.username\")\n        model = Student\n        fields = (\"id\", \"name\", \"sex\", \"age\", \"contend\", \"isDelete\", \"grade\", \"owner\")\n添加权限\nfrom rest_framework import permissions\nclass StudentsList(generics.ListCreateAPIView):\n    queryset = Student.objects.all()\n    serializer_class = StudentSerializer\n    permission_classes = (permissions.IsAuthenticatedOrReadOnly,)\n    #让用户在通过post请求创建一个新的student时，在保证创建学生时会把request中的user赋值给该学生的owner字段\n    def perform_create(self, serializer):\n        serializer.save(owner=self.request.user)\nclass StudentDetail(generics.RetrieveUpdateDestroyAPIView):\n    queryset = Student.objects.all()\n    serializer_class = StudentSerializer\n    # 只有所有者用户才能删除、修改，其他用户只能访问\n    permission_classes = (permissions.IsAuthenticatedOrReadOnly,)\n为可浏览的API添加登陆功能\n工程目录下与工程目同名目录下的urls.py文件\nfrom django.conf.urls import url, include\nfrom django.contrib import admin\n\nurlpatterns = [\n    url(r'^admin/', admin.site.urls),\n    url(r'^api-auth/', include(\"rest_framework.urls\", namespace=\"rest_framework\")),\n    url(r'^', include(\"myApp.urls\")),\n]\n添加对象权限\n要实现让所有的Students可以被所有人访问，但是每个学生只能被其创建者所操作。\n需要自定义权限，让每个学生只能被其创建者所操作，在应用目录下创建permissions.py的文件\nfrom rest_framework import permissions\n\nclass IsOwnerOrReadOnly(permissions.BasePermission):\n    def has_object_permission(self, request, view, obj):\n        if request.method in permissions.SAFE_METHODS:\n            # 用户请求为GET 可以只读\n            return True\n        return obj.owner == request.user\n添加自定义权限\nfrom myApp.permissions import IsOwnerOrReadOnly\nclass StudentDetail(generics.RetrieveUpdateDestroyAPIView):\n    queryset = Student.objects.all()\n    serializer_class = StudentSerializer\n    # 只有所有者用户才能删除、修改，其他用户只能访问\n    permission_classes = (permissions.IsAuthenticatedOrReadOnly,IsOwnerOrReadOnly)\nAPI授权\n\n由于现在我们还没有使用Authentication类，所以项目目前还是使用默认的SessionAuthentication和BaseAuthentication\n在使用浏览器访问API的时候，浏览器会帮助我们保存会话信息，所以当权限满足是就可以对一个学生对象进行删除或者更新，还可以创建学生\n当如果通过命令来操作API，我们就必须在每次发送请求是附带验证信息 : http://user1:sunck1999@127.0.0.1:8000/students/1/\n程序中使用  from django.contrib.auth import login\n\n\nDjango  RESTful  API  之ViewSet和Routers\n目的: 介绍另一种基于类的视图的写法，它的抽象程度更高，代码更少\n使用ViewSets重构视图\nfrom myApp.models import Student\nfrom myApp.serializers import StudentSerializer, UserSerializer\nfrom rest_framework import permissions\nfrom myApp.permissions import IsOwnerOrReadOnly\nfrom django.contrib.auth.models import  User\nfrom rest_framework import viewsets\n\nclass StudentViewSet(viewsets.ModelViewSet):\n    queryset = Student.objects.all()\n    serializer_class = StudentSerializer\n    permission_classes = (permissions.IsAuthenticatedOrReadOnly, IsOwnerOrReadOnly)\n    def perform_create(self, serializer):\n        serializer.save(owner=self.request.user)\n\nclass UserViewSet(viewsets.ReadOnlyModelViewSet):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n重构路由\nfrom django.conf.urls import url, include\nfrom myApp.views import StudentViewSet, UserViewSet\nfrom rest_framework.urlpatterns import format_suffix_patterns\n\nstudents_list = StudentViewSet.as_view({\n    \"get\":\"list\",\n    \"post\":\"create\"\n})\nstudent_detail = StudentViewSet.as_view({\n    \"get\":\"retrieve\",\n    \"put\":\"update\",\n    \"patch\":\"partial_update\",\n    \"delete\":\"destroy\"\n})\nusers_list = UserViewSet.as_view({\n    \"get\":\"list\"\n})\nuser_detail = UserViewSet.as_view({\n    \"get\":\"retrieve\"\n})\nurlpatterns = format_suffix_patterns([\n    url(r'^students/$', students_list, name=\"students_list\"),\n    url(r'^students/(?P<pk>\\d+)/$', student_detail, name=\"student_detail\"),\n    url(r'^users/$', users_list, name=\"users_list\"),\n    url(r'^users/(?P<pk>\\d+)/$', user_detail, name=\"user_detail\"),\n])\n使用Routers\nfrom django.conf.urls import url, include\nfrom myApp import views\nfrom rest_framework.routers import DefaultRouter\n\nrouter = DefaultRouter()\nrouter.register(r'students', views.StudentViewSet)\nrouter.register(r'users', views.UserViewSet)\n\nurlpatterns = [\n    url(r'^', include(router.urls))\n]\n\n                ", "mainLikeNum": ["7 "], "mainBookmarkNum": "3"}