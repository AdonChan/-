{"title": "[Python]在一段Python程序中使用多次事件循环 - 追不上乌龟的兔子 ", "index": "python", "content": "背景\n我们在Python异步程序编写中经常要用到如下的结构\nimport asyncio\nasync def doAsync():\n    await asyncio.sleep(0)\n    #...\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(doAsync())\n    loop.close()\n这当然是很不错的，但当你第二次使用loop的时候程序就会抛出异常RuntimeError: Event loop is closed,这也无可厚非，理想的程序也应该是在一个时间循环中解决掉各种异步IO的问题。但放在终端环境如Ipython中，如果想要练习Python的异步程序的编写的话每次都要重新开启终端未免太过于麻烦，这时候要探寻有没有更好的解决方案。\n解决方案\n我们可以使用asyncio.new_event_loop函数建立一个新的事件循环，并使用asyncio.set_event_loop设置全局的事件循环，这时候就可以多次运行异步的事件循环了，不过最好保存默认的asyncio.get_event_loop并在事件循环结束的时候还原回去。最终我们的代码就像这样。\n代码\nimport asyncio\nasync def doAsync():\n    await asyncio.sleep(0)\n    #...\ndef runEventLoop()\n    loop = asyncio.new_event_loop()\n    asyncio.set_event_loop(loop)\n    loop.run_until_complete(doAsync())\n    loop.close()\nif __name__ == \"__main__\":\n    oldloop = asyncio.get_event_loop()\n    runEventLoop()\n    runEventLoop()\n    asyncio.set_event_loop(oldloop)\n感想\n事件循环本来就是要一起做很多事情，在正式的Python代码中还是只用一个默认的事件循环比较好，平时的学习练习的话倒是随意了。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "6"}