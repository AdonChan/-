{"title": "Python-SQLALchemy - ormsf ", "index": "python,sqlalchemy,mysql", "content": "官方文档\nInitialization\n# 检查是否已经安装以及版本号\n>>> import sqlalchemy\n>>> sqlalchemy.__version__ \n’1.1.4‘\n>>> from sqlalchemy.ext.declarative import declarative_base\n# model都是要继承自Base\n>>> Base = declarative_base()\n\n>>> from sqlalchemy import Column, Integer, String\n>>> class User(Base):\n...     __tablename__ = 'users' # 指定数据表名\n...\n...     id = Column(Integer, primary_key=True)\n...     name = Column(String(50))\n...     fullname = Column(String(50))\n...     password = Column(String(50))\n...\n...     def __repr__(self):\n...        return \"<User(name='%s', fullname='%s', password='%s')>\" % (\n...                             self.name, self.fullname, self.password)\n\n\n# 查看创建的数据表结构\n>>> User.__table__ \nTable('users', MetaData(bind=None),\n            Column('id', Integer(), table=<users>, primary_key=True, nullable=False),\n            Column('name', String(length=50), table=<users>),\n            Column('fullname', String(length=50), table=<users>),\n            Column('password', String(length=50), table=<users>), schema=None)\n\n正式创建数据表\n>>> from sqlalchemy import create_engine\n\n# 连接到mysql\n>>> engine = create_engine(\"mysql://root:root@localhost:3306/python?charset=utf8\",\n                           encoding=\"utf-8\", echo=True)\n\n# 正式创建数据表\n>>> Base.metadata.create_all(engine)\nCREATE TABLE users (\n    id INTEGER NOT NULL AUTO_INCREMENT, \n    name VARCHAR(50), \n    fullname VARCHAR(50), \n    password VARCHAR(50), \n    PRIMARY KEY (id)\n)\nCreating a Session\n下面的操作都是要通过会话对象操作\n>>> from sqlalchemy.orm import sessionmaker\n>>> Session = sessionmaker(bind=engine)\n>>> session = Session()\nAdding and Updating Objects\n添加一个User对象\n>>> ed_user = User(name='ed', fullname='Ed Jones', password='edspassword')\n>>> session.add(ed_user)\n查询一下，使用filter_by来过滤，first只列出第一个查询到的对象\n>>> our_user = session.query(User).filter_by(name='ed').first()\nBEGIN (implicit)\nINSERT INTO users (name, fullname, password) VALUES (?, ?, ?)\n('ed', 'Ed Jones', 'edspassword')\n\nSELECT users.id AS users_id,\n        users.name AS users_name,\n        users.fullname AS users_fullname,\n        users.password AS users_password\nFROM users\nWHERE users.name = ?\n LIMIT ? OFFSET ?\n('ed', 1, 0)\n\n>>> our_user\n<User(name='ed', fullname='Ed Jones', password='edspassword')>\n\n>>> ed_user is our_user\nTrue\n使用add_all，一次性添加多个对象\n>>> session.add_all([\n...     User(name='wendy', fullname='Wendy Williams', password='foobar'),\n...     User(name='mary', fullname='Mary Contrary', password='xxg527'),\n...     User(name='fred', fullname='Fred Flinstone', password='blah')])\nSession很智能，比如说，它知道Ed Jones被修改了\n# 可以直接修改ed_user对象\n>>> ed_user.password = 'f8s7ccs'\n\n# session会自动知道哪些数据被修改了\n>>> session.dirty\nIdentitySet([<User(name='ed', fullname='Ed Jones', password='f8s7ccs')>])\n\n# session也可以知道哪些对象被新建了\n>>> session.new\nIdentitySet([<User(name='wendy', fullname='Wendy Williams', password='foobar')>,\n<User(name='mary', fullname='Mary Contrary', password='xxg527')>,\n<User(name='fred', fullname='Fred Flinstone', password='blah')>])\n对数据库进行了变更，自然要进行commit，从echo语句我们可以看出，我们更新了1个对象，创建了3个对象。\n>>> session.commit()\nUPDATE users SET password=? WHERE users.id = ?\n('f8s7ccs', 1)\nINSERT INTO users (name, fullname, password) VALUES (?, ?, ?)\n('wendy', 'Wendy Williams', 'foobar')\nINSERT INTO users (name, fullname, password) VALUES (?, ?, ?)\n('mary', 'Mary Contrary', 'xxg527')\nINSERT INTO users (name, fullname, password) VALUES (?, ?, ?)\n('fred', 'Fred Flinstone', 'blah')\nCOMMIT\n\n>>> ed_user.id\nBEGIN (implicit)\nSELECT users.id AS users_id,\n        users.name AS users_name,\n        users.fullname AS users_fullname,\n        users.password AS users_password\nFROM users\nWHERE users.id = ?\n(1,)\n1\nRolling Back\n因为Session是工作在一个transaction内部，有时候我们可能不小心做了一些误删除的操作，可以回滚。我们先修改ed_user的用户名为Edwardo，然后重新添加一个新User，但是记住这个时候我们还没有commit。\n>>> ed_user.name = 'Edwardo'\nand we’ll add another erroneous user, fake_user:\n\n>>> fake_user = User(name='fakeuser', fullname='Invalid', password='12345')\n>>> session.add(fake_user)\nQuerying the session, we can see that they’re flushed into the current transaction:\n查询检验一下\n>>> session.query(User).filter(User.name.in_(['Edwardo', 'fakeuser'])).all()\nUPDATE users SET name=? WHERE users.id = ?\n('Edwardo', 1)\nINSERT INTO users (name, fullname, password) VALUES (?, ?, ?)\n('fakeuser', 'Invalid', '12345')\nSELECT users.id AS users_id,\n        users.name AS users_name,\n        users.fullname AS users_fullname,\n        users.password AS users_password\nFROM users\nWHERE users.name IN (?, ?)\n('Edwardo', 'fakeuser')\n[<User(name='Edwardo', fullname='Ed Jones', password='f8s7ccs')>, <User(name='fakeuser', fullname='Invalid', password='12345')>]\n回滚，我们可以知道ed_user‘s name is back to ed以及fake_user has been kicked out of the session\n>>> session.rollback()\nROLLBACK\n\n>>> ed_user.name\nBEGIN (implicit)\nSELECT users.id AS users_id,\n        users.name AS users_name,\n        users.fullname AS users_fullname,\n        users.password AS users_password\nFROM users\nWHERE users.id = ?\n(1,)\nu'ed'\n\n>>> fake_user in session\nFalse\nissuing a SELECT illustrates the changes made to the database:\n这个时候再查询，很明显fakeuser已经消失了，ed用户的名字重新变回了ed而不是Edwordo\n>>> session.query(User).filter(User.name.in_(['ed', 'fakeuser'])).all()\nSELECT users.id AS users_id,\n        users.name AS users_name,\n        users.fullname AS users_fullname,\n        users.password AS users_password\nFROM users\nWHERE users.name IN (?, ?)\n('ed', 'fakeuser')\n[<User(name='ed', fullname='Ed Jones', password='f8s7ccs')>]\nCouting\n用于查询操作相对应的count()操作\n>>> session.query(User).filter(User.name.like('%ed')).count()\n2\n\n>>> from sqlalchemy import func\n>>> session.query(func.count(User.name), User.name).group_by(User.name).all()\n[(1, u'ed'), (1, u'fred'), (1, u'mary'), (1, u'wendy')]\nQuerying\n一个通过在Session上使用query方法可以创建一个Query object\n按照用户id进行排序来进行查询\n>>> for instance in session.query(User).order_by(User.id):\n...     print(instance.name, instance.fullname)\ned Ed Jones\nwendy Wendy Williams\nmary Mary Contrary\nfred Fred Flinstone\nquery方法也可以接收ORM-instrumented descriptors作为参数。返回结果是一个named tuples\n>>> for name, fullname in session.query(User.name, User.fullname):\n...     print(name, fullname)\ned Ed Jones\nwendy Wendy Williams\nmary Mary Contrary\nfred Fred Flinstone\nThe tuples returned by Query are named tuples, supplied by the KeyedTuple class, and can be treated much like an ordinary Python object. The names are the same as the attribute’s name for an attribute, and the class name for a class:\n>>> for row in session.query(User, User.name).all():\n...    print(row.User, row.name)\n<User(name='ed', fullname='Ed Jones', password='f8s7ccs')> ed\n<User(name='wendy', fullname='Wendy Williams', password='foobar')> wendy\n<User(name='mary', fullname='Mary Contrary', password='xxg527')> mary\n<User(name='fred', fullname='Fred Flinstone', password='blah')> fred\nYou can control the names of individual column expressions using the label() construct, which is available from any ColumnElement-derived object, as well as any class attribute which is mapped to one (such as User.name):\n>>> for row in session.query(User.name.label('name_label')).all():\n...    print(row.name_label)\ned\nwendy\nmary\nfred\nThe name given to a full entity such as User, assuming that multiple entities are present in the call to query(), can be controlled using aliased() :\n>>> from sqlalchemy.orm import aliased\n>>> user_alias = aliased(User, name='user_alias')\n\n>>> for row in session.query(user_alias, user_alias.name).all():\n...    print(row.user_alias)\n<User(name='ed', fullname='Ed Jones', password='f8s7ccs')>\n<User(name='wendy', fullname='Wendy Williams', password='foobar')>\n<User(name='mary', fullname='Mary Contrary', password='xxg527')>\n<User(name='fred', fullname='Fred Flinstone', password='blah')>\nBasic operations with Query include issuing LIMIT and OFFSET, most conveniently using Python array slices and typically in conjunction with ORDER BY:\n>>> for u in session.query(User).order_by(User.id)[1:3]:\n...    print(u)\n<User(name='wendy', fullname='Wendy Williams', password='foobar')>\n<User(name='mary', fullname='Mary Contrary', password='xxg527')>\nand filtering results, which is accomplished either with filter_by(), which uses keyword arguments:\n\n>>> for name, in session.query(User.name).\\\n...             filter_by(fullname='Ed Jones'):\n...    print(name)\ned\n\n>>> for name, in session.query(User.name).\\\n...             filter(User.fullname=='Ed Jones'):\n...    print(name)\ned\n\nThe Query object is fully generative, meaning that most method calls return a new Query object upon which further criteria may be added. For example, to query for users named “ed” with a full name of “Ed Jones”, you can call filter() twice, which joins criteria using AND:\n>>> for user in session.query(User).\\\n...          filter(User.name=='ed').\\\n...          filter(User.fullname=='Ed Jones'):\n...    print(user)\n<User(name='ed', fullname='Ed Jones', password='f8s7ccs')>\nCommon Filter Operators\n下面列出了filter()最常用的一些operators\nequals:\nquery.filter(User.name == 'ed')\n\nnot equals:\nquery.filter(User.name != 'ed')\n\nLIKE:\nquery.filter(User.name.like('%ed%'))\n\nIN:\nquery.filter(User.name.in_(['ed', 'wendy', 'jack']))\n\n# works with query objects too:\nquery.filter(User.name.in_(\n        session.query(User.name).filter(User.name.like('%ed%'))\n))\n\nNOT IN:\nquery.filter(User.name.in_(['ed', 'wendy', 'jack']))\n\nIS NULL:\nquery.filter(User.name == None)\n\n# alternatively, if pep8/linters are a concern\nquery.filter(User.name.is_(None))\n\nIS NOT NULL:\nquery.filter(User.name != None)\n\n# alternatively, if pep8/linters are a concern\nquery.filter(User.name.isnot(None))\n\nAND:\n# use and_()\nfrom sqlalchemy import and_\nquery.filter(and_(User.name == 'ed', User.fullname == 'Ed Jones'))\n\n# or send multiple expressions to .filter()\nquery.filter(User.name == 'ed', User.fullname == 'Ed Jones')\n\n# or chain multiple filter()/filter_by() calls\nquery.filter(User.name == 'ed').filter(User.fullname == 'Ed Jones')\n\nNote\nMake sure you use and_() and not the Python and operator!\n\nOR:\nfrom sqlalchemy import or_\nquery.filter(or_(User.name == 'ed', User.name == 'wendy'))\n\nNote\nMake sure you use or_() and not the Python or operator!\n\nMATCH:\nquery.filter(User.name.match('wendy'))\n\nNote\nmatch() uses a database-specific MATCH or CONTAINS function;\nits behavior will vary by backend and is not available on some backends such as SQLite.\nBuilding a Relationship\n创建对象与对象之间的关系，下面我们新建一个Address表，下面的操作相比django的orm繁琐一些，要同时在两个class内部同时设置relationship\n>>> from sqlalchemy import ForeignKey\n>>> from sqlalchemy.orm import relationship\n\n>>> class Address(Base):\n...     __tablename__ = 'addresses'\n...     id = Column(Integer, primary_key=True)\n...     email_address = Column(String(50), nullable=False)\n...     user_id = Column(Integer, ForeignKey('users.id'))\n...\n...     user = relationship(\"User\", back_populates=\"addresses\") # 将地址表和用户表关联\n...\n...     def __repr__(self):\n...         return \"<Address(email_address='%s')>\" % self.email_address\n\n\n# 在用户表中还要重新设置一次\n>>> User.addresses = relationship(\n...     \"Address\", order_by=Address.id, back_populates=\"user\")\n\n>>> Base.metadata.create_all(engine)\nWorking with Related Objects\n现在我们创建了一个User，与它对应的一个空addresses集合也将创立。集合类型可以是各种合法类型，比如set/dictionaries(see Customizing Collection Access for details)，但是默认集合是一个list。\n现在我们再来创建一个用户Jack\n>>> jack = User(name='jack', fullname='Jack Bean', password='gjffdd')\n>>> jack.addresses\n[]\nWe are free to add Address objects on our User object. In this case we just assign a full list directly:\n现在我们将用户Jack和一些地址关联起来\n>>> jack.addresses = [\n...                 Address(email_address='jack@google.com'),\n...                 Address(email_address='j25@yahoo.com')]\n\nWhen using a bidirectional relationship, elements added in one direction automatically become visible in the other direction. This behavior occurs based on attribute on-change events and is evaluated in Python, without using any SQL:现在可以通过地址对象访问用户对象了\n>>> jack.addresses[1]\n<Address(email_address='j25@yahoo.com')>\n\n>>> jack.addresses[1].user\n<User(name='jack', fullname='Jack Bean', password='gjffdd')>\n\nLet’s add and commit Jack Bean to the database. jack as well as the two Address members in the corresponding addresses collection are both added to the session at once, using a process known as cascading:\n接下来commit保存到数据库\n>>> session.add(jack)\n>>> session.commit()\nsqlalchemy.engine.base.Engine INSERT INTO addresses (email_address, user_id) VALUES (%s, %s)\nsqlalchemy.engine.base.Engine ('jack@google.com', 5L)\nsqlalchemy.engine.base.Engine INSERT INTO addresses (email_address, user_id) VALUES (%s, %s)\nsqlalchemy.engine.base.Engine ('j25@yahoo.com', 5L)\nsqlalchemy.engine.base.Engine COMMIT\nQuerying for Jack, we get just Jack back. No SQL is yet issued for Jack’s addresses:\n>>> jack = session.query(User).\\\n... filter_by(name='jack').one()\n>>> jack\n<User(name='jack', fullname='Jack Bean', password='gjffdd')>\nLet’s look at the addresses collection. Watch the SQL:\n\n>>> jack.addresses\n[<Address(email_address='jack@google.com')>, <Address(email_address='j25@yahoo.com')>]\nWhen we accessed the addresses collection, SQL was suddenly issued. This is an example of a lazy loading relationship. The addresses collection is now loaded and behaves just like an ordinary list. We’ll cover ways to optimize the loading of this collection in a bit.\nDelete\n删除操作，接下来我们尝试删除jack对象，注意地址对象并不会因此而删除\n>>> session.delete(jack)\n>>> session.query(User).filter_by(name='jack').count()\n0\nSo far, so good. How about Jack’s Address objects ?\n\n>>> session.query(Address).filter(\n...     Address.email_address.in_(['jack@google.com', 'j25@yahoo.com'])\n...  ).count()\n2\nUh oh, they’re still there ! Analyzing the flush SQL, we can see that the user_id column of each address was set to NULL, but the rows weren’t deleted. SQLAlchemy doesn’t assume that deletes cascade, you have to tell it to do so. Configuring delete/delete-orphan Cascade. We will configure cascade options on the User.addresses relationship to change the behavior. While SQLAlchemy allows you to add new attributes and relationships to mappings at any point in time, in this case the existing relationship needs to be removed, so we need to tear down the mappings completely and start again - we’ll close the Session:\n直接close来rollback，并不进行commit\n>>> session.close()\nROLLBACK\nUse a new declarative_base():\n>>> Base = declarative_base()\nNext we’ll declare the User class, adding in the addresses relationshipincluding the cascade configuration (we’ll leave the constructor out too):\n>>> class User(Base):\n...     __tablename__ = 'users'\n...\n...     id = Column(Integer, primary_key=True)\n...     name = Column(String(50))\n...     fullname = Column(String(50))\n...     password = Column(String(50))\n...\n...     addresses = relationship(\"Address\", back_populates='user',\n...                     cascade=\"all, delete, delete-orphan\")\n...\n...     def __repr__(self):\n...        return \"<User(name='%s', fullname='%s', password='%s')>\" % (\n...                                self.name, self.fullname, self.password)\nThen we recreate Address, noting that in this casewe’ve created the Address.user relationship via the User class already:\n>>> class Address(Base):\n...     __tablename__ = 'addresses'\n...     id = Column(Integer, primary_key=True)\n...     email_address = Column(String(50), nullable=False)\n...     user_id = Column(Integer, ForeignKey('users.id'))\n...     user = relationship(\"User\", back_populates=\"addresses\")\n...\n...     def __repr__(self):\n...         return \"<Address(email_address='%s')>\" % self.email_address\nNow when we load the user jack (below using get(), which loads by primary key), removing an address from the corresponding addresses collection will result in that Address being deleted:\n# load Jack by primary key\n>>> jack = session.query(User).get(5)\n\n# remove one Address (lazy load fires off)\n>>> del jack.addresses[1]\n\n# only one address remains\n>>> session.query(Address).filter(\n...     Address.email_address.in_(['jack@google.com', 'j25@yahoo.com'])\n... ).count()\n1\n\nDeleting Jack will delete both Jack and the remaining Address associated with the user:\n>>> session.delete(jack)\n\n>>> session.query(User).filter_by(name='jack').count()\n0\n\n>>> session.query(Address).filter(\n...    Address.email_address.in_(['jack@google.com', 'j25@yahoo.com'])\n... ).count()\n0\nFurther detail on configuration of cascades is at Cascades. The cascade functionality can also integrate smoothly with the ON DELETE CASCADE functionality of the relational database. See Using Passive Deletes for details.\nbackref\n上面同时设置两个relationship太麻烦了，可以使用backref\nfrom sqlalchemy import Integer, ForeignKey, String, Column\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import relationship\n\nBase = declarative_base()\n\nclass User(Base):\n    __tablename__ = 'user'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n\n    addresses = relationship(\"Address\", backref=\"user\")\n\nclass Address(Base):\n    __tablename__ = 'address'\n    id = Column(Integer, primary_key=True)\n    email = Column(String)\n    user_id = Column(Integer, ForeignKey('user.id'))\nThe above configuration establishes a collection of Address objects on User called User.addresses. It also establishes a .user attribute on Address which will refer to the parent User object.\nIn fact, the backref keyword is only a common shortcut for placing a second relationship() onto the Address mapping, including the establishment of an event listener on both sides which will mirror attribute operations in both directions. The above configuration is equivalent to:\nrom sqlalchemy import Integer, ForeignKey, String, Column\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import relationship\n\nBase = declarative_base()\n\nclass User(Base):\n    __tablename__ = 'user'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n\n    addresses = relationship(\"Address\", back_populates=\"user\")\n        \nclass Address(Base):\n    __tablename__ = 'address'\n    id = Column(Integer, primary_key=True)\n    email = Column(String)\n    user_id = Column(Integer, ForeignKey('user.id'))\n\n    user = relationship(\"User\", back_populates=\"addresses\")\nAbove, we add a .user relationship to Address explicitly. On both relationships, the back_populates directive tells each relationship about the other one, indicating that they should establish “bidirectional” behavior between each other. The primary effect of this configuration is that the relationship adds event handlers to both attributes which have the behavior of “when an append or set event occurs here, set ourselves onto the incoming attribute using this particular attribute name”. The behavior is illustrated as follows. Start with a User and an Address instance. The .addresses collection is empty, and the .user attribute is None:\n>>> u1 = User()\n>>> a1 = Address()\n>>> u1.addresses\n[]\n>>> print(a1.user)\nNone\nHowever, once the Address is appended to the u1.addresses collection, both the collection and the scalar attribute have been populated:\n>>> u1.addresses.append(a1)\n>>> u1.addresses\n[<__main__.Address object at 0x12a6ed0>]\n>>> a1.user\n<__main__.User object at 0x12a6590>\nThis behavior of course works in reverse for removal operations as well, as well as for equivalent operations on both sides. Such as when .user is set again to None, the Address object is removed from the reverse collection:\n>>> a1.user = None\n>>> u1.addresses\n[]\nThe manipulation of the .addresses collection and the .user attribute occurs entirely in Python without any interaction with the SQL database. Without this behavior, the proper state would be apparent on both sides once the data has been flushed to the database, and later reloaded after a commit or expiration operation occurs. The backref/back_populates behavior has the advantage that common bidirectional operations can reflect the correct state without requiring a database round trip.\nRemember, when the backref keyword is used on a single relationship, it’s exactly the same as if the above two relationships were created individually using back_populates on each.\nmysql操作\n检验一下我们上面的成果以及熟悉创建的mysql表的结构\n地址表的结构\n> SHOW CREATE TABLE addresses;\n+-----------+----------------+\n| Table     | Create Table   |\n|-----------+----------------|\n| addresses | CREATE TABLE `addresses` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `email_address` varchar(50) NOT NULL,\n  `user_id` int(11) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `user_id` (`user_id`),\n  CONSTRAINT `addresses_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8                |\n+-----------+----------------+\n1 row in set\nTime: 0.005s\n\n> DESC addresses;\n+---------------+-------------+--------+-------+-----------+----------------+\n| Field         | Type        | Null   | Key   |   Default | Extra          |\n|---------------+-------------+--------+-------+-----------+----------------|\n| id            | int(11)     | NO     | PRI   |    <null> | auto_increment |\n| email_address | varchar(50) | NO     |       |    <null> |                |\n| user_id       | int(11)     | YES    | MUL   |    <null> |                |\n+---------------+-------------+--------+-------+-----------+----------------+\n3 rows in set\nTime: 0.002s\n用户表的结构\n> SHOW CREATE TABLE users;\n+---------+----------------+\n| Table   | Create Table   |\n|---------+----------------|\n| users   | CREATE TABLE `users` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(50) DEFAULT NULL,\n  `fullname` varchar(50) DEFAULT NULL,\n  `password` varchar(50) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8                |\n+---------+----------------+\n1 row in set\nTime: 0.002s\n\n> DESC users;\n+----------+-------------+--------+-------+-----------+----------------+\n| Field    | Type        | Null   | Key   |   Default | Extra          |\n|----------+-------------+--------+-------+-----------+----------------|\n| id       | int(11)     | NO     | PRI   |    <null> | auto_increment |\n| name     | varchar(50) | YES    |       |    <null> |                |\n| fullname | varchar(50) | YES    |       |    <null> |                |\n| password | varchar(50) | YES    |       |    <null> |                |\n+----------+-------------+--------+-------+-----------+----------------+\n4 rows in set\nTime: 0.003s\n详细数据\n> SELECT * FROM addresses;\n+------+-----------------+-----------+\n|   id | email_address   |   user_id |\n|------+-----------------+-----------|\n|    3 | jack@google.com |         5 |\n|    4 | j25@yahoo.com   |         5 |\n+------+-----------------+-----------+\n2 rows in set\nTime: 0.002s\n\n> SELECT * FROM users;\n+------+--------+----------------+------------+\n|   id | name   | fullname       | password   |\n|------+--------+----------------+------------|\n|    1 | ed     | Ed Jones       | f8s7ccs    |\n|    2 | wendy  | Wendy Williams | foobar     |\n|    3 | mary   | Mary Contrary  | xxg527     |\n|    4 | fred   | Fred Flinstone | blah       |\n|    5 | jack   | Jack Bean      | gjffdd     |\n+------+--------+----------------+------------+\n5 rows in set\nTime: 0.003s\n知乎live设计模型\nfrom sqlalchemy import Column, String, Integer, create_engine, SmallInteger\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.ext.declarative import declarative_base\n\nDB_URI = 'sqlite:///user.db'\nBase = declarative_base()\nengine = create_engine(DB_URI)\nBase.metadata.bind = engine\nSession = sessionmaker(bind=engine)\nsession = Session()\nclass User(Base):\n    __tablename__ = 'live_user'\n    \n    id = Column(Integer, unique=True, primary_key=True, autoincrement=True)\n    speaker_id = Column(String(40), index=True, unique=True)\n    name = Column(String(40), index=True, nullable=False)\n    gender = Column(SmallInteger, default=2)\n    headline = Column(String(200))\n    avatar_url = Column(String(100), nullable=False)\n    bio = Column(String(200))\n    description = Column(String())\n    \n    @classmethod\n    def add(cls, **kwargs):\n        speaker_id = kwargs.get('speaker_id', None)\n        if id is not None:\n            r = session.query(cls).filter_by(speaker_id=speaker_id).first()\n            if r:\n                return r\n        try:\n            r = cls(**kwargs)\n            session.add(r)\n            session.commit()\n        except:\n            session.rollback()\n            raise\n        else:\n            return r\nBase.metadata.create_all()\n接口分为2种：\n\nhttps://api.zhihu.com/lives/o... (未结束)\nhttps://api.zhihu.com/lives/e... (已结束)\n\nelasticsearch-dsl-py相比elasticsearch-py做了各种封装，DSL也支持用类代表一个doc_type（类似数据库中的Table），实现ORM的效果。我们就用它来写Live模型：\nfrom elasticsearch_dsl import DocType, Date, Integer, Text, Float, Boolean\nfrom elasticsearch_dsl.connections import connections\nfrom elasticsearch_dsl.query import SF, Q\nfrom config import SEARCH_FIELDS\nfrom .speaker import User, session\n\nconnections.create_connection(hosts=['localhost'])\nclass Live(DocType):\n    id = Integer()\n    speaker_id = Integer()\n    feedback_score = Float() # 评分\n    topic_names = Text(analyzer='ik_max_word')  # 话题标签名字\n    seats_taken = Integer()  # 参与人数\n    subject = Text(analyzer='ik_max_word')  # 标题\n    amount = Float()  # 价格(RMB)\n    description = Text(analyzer='ik_max_word')\n    status = Boolean()  # public(True)/ended(False)\n    starts_at = Date()\n    outline = Text(analyzer='ik_max_word')  # Live内容\n    speaker_message_count = Integer()\n    tag_names = Text(analyzer='ik_max_word')\n    liked_num = Integer()\n    \n    class Meta:\n        index = 'live'\n        \n    @classmethod\n    def add(cls, **kwargs):\n        id = kwargs.pop('id', None)\n        if id is None:\n            return False\n        live = cls(meta={'id': id}, **kwargs)\n        live.save()\n        return live\n它允许我们用一种非常可维护的方法来组织字典：\nIn : from elasticsearch_dsl.query import Q\nIn : Q('multi_match', subject='python').to_dict()\nOut: {'multi_match': {'subject': 'python'}}\nIn : from elasticsearch import Elasticsearch\nIn : from elasticsearch_dsl import Search, Q\nIn : s = Search(using=client, index='live')\nIn : s = s.query('match', subject='python').query(~Q('match', description='量化'))\nIn : s.execute()\nOut: <Response: [<Hit(live/live/789840559912009728): {'subject': 'Python 工程师的入门和进阶', 'feedback_score': 4.5, 'stat...}>]>\n上述例子表示从live这个索引（类似数据库中的Database）中找到subject字典包含python，但是description字段不包含量化的Live。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "3"}