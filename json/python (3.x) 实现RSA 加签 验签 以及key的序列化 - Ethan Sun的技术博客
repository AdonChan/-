{"title": "python (3.x) 实现RSA 加签 验签 以及key的序列化 - Ethan Sun的技术博客 ", "index": "python,cryptography", "content": "首先 安装cryptography\nsudo pip3 install cryptography\n确认安装的是2.1.x版本 (1.x版本的api是不一样的).\n生成公私钥对:\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives.asymmetric import rsa, padding\nfrom cryptography.hazmat.primitives import serialization, hashes\nfrom base64 import b64encode, b64decode\n\n# 生成私钥 (同时包含公钥), 此处为RSA 2048\nprivate_key = rsa.generate_private_key(\n    public_exponent=65537,\n    key_size=2048,\n    backend=default_backend()\n)\n序列化公钥 私钥, 并写入文件存储.\n\n# 序列化私钥\npem = private_key.private_bytes(\n   encoding=serialization.Encoding.PEM,\n   format=serialization.PrivateFormat.PKCS8,\n   # 无密码\n   encryption_algorithm=serialization.NoEncryption()\n   # 也可以加入密码保护私钥:\n   # encryption_algorithm=serialization.BestAvailableEncryption(b'mypassword')\n)\n\n# 将私钥写入文件\nwith open('private.pem', 'wb') as f:\n    f.write(pem)\n\npublic_key = private_key.public_key()\n\npub_pem = public_key.public_bytes(\n   encoding=serialization.Encoding.PEM,\n   format=serialization.PublicFormat.SubjectPublicKeyInfo\n)\n\n# 将公钥写入文件\nwith open('public.pem', 'wb') as f:\n    f.write(pub_pem)\n\n也可以采用其他序列化方法, 比如对公钥, 生成OpenSSH格式的序列化字符串:\npublic_key.public_bytes(\n    encoding=serialization.Encoding.OpenSSH,\n    format=serialization.PublicFormat.OpenSSH\n)\n输出类似于:\nb'ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCbySUldhJYrDmf8+yyQXMB5HsIMwownZq3ft7k1nei/kVC/720np/1xyk7U8yNc2jL9Yb/pctD/0WAnI7vrkIVQniYfRwiEohDlZHGIvlUpXS4dtKvbOFRDQod9nn4Q9VwfrMq4yuBbKSaCqwcu8rkApWyj36\nXhTV5/mT7Zs4H4m3OAyCVD2kkAoZYYbxA+pBNDLDcU4VlUuiC1FaWLTdU5dV6A0IGRGlOuFw4qaJZaFLu6mANaRdX836LA5DOmKpcwerb0ae3eGHZNSLQO6JkIT7oe/I+417jz5JmUI3V35BjKUrd7VjBgbE0jvpkxrzMFCaoOWP0BzTDn+C64fSR'\n此后可以从文件读出公钥(私钥)\n# 从文件读出并创建公钥\nwith open(\"public.pem\", \"rb\") as pub_key_file:\n    # 读入私钥为 load_pem_private_key\n    public_key = serialization.load_pem_public_key(\n        pub_key_file.read(),\n        # 读入私钥此处还有: password=b'xxxx',\n        backend=default_backend()\n    )\n对于openSSH格式, 应采用load_ssh_public_key\n给指定消息加签, 获得签名\n# 需要加签的消息\nmessage = b\"A message I want to sign\"\n# 对消息加签, 获得签名, 为bytes\nsignature = private_key.sign(\n    message,\n    padding.PSS(\n        mgf=padding.MGF1(hashes.SHA1()),\n        salt_length=padding.PSS.MAX_LENGTH\n    ),\n    hashes.SHA1()\n)\n\n# 需要传输, 展示, 存储时, 可以将签名转为base64格式的bytes,\n# 也可以继续转为str: str(enc_sig, 'utf-8')\nenc_sig = b64encode(signature)\n验证签名:\n# 通过signature, 公钥 给 消息message 验签, 验证是由私钥持有者发出的这条消息.\n# 如果验签通过, 则正常通过, 否则, 抛出 cryptography.exceptions.InvalidSignature 异常\npublic_key.verify(\n    signature,\n    message,\n    padding.PSS(\n        mgf=padding.MGF1(hashes.SHA1()),\n        salt_length=padding.PSS.MAX_LENGTH\n    ),\n    hashes.SHA1()\n)\n这样生成的签名base64encode之后, 会有344byte 的长度.\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}