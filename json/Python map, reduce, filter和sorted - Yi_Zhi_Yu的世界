{"title": "Python map, reduce, filter和sorted - Yi_Zhi_Yu的世界 ", "index": "python2.7,python", "content": "map\n\nmap(funcname, list)\n\n\npython的map 函数使得函数能直接以list的每个元素作为参数传递到funcname中, 并返回响应的新的list\n如下:\n\ndef sq(x):\n    return x*x  #求x的平方\nmap(sq, [1,3, 5,7,9]) #[1, 9, 25, 49, 81]\n\n\n在需要对list中的每个元素做转换的时候, 会很方便\n\n比如,把list中的每个int 转换成str\n\nmap(str, [23,43,4545,324]) #['23', '43', '4545', '324']\n\n\n当然, 第二个参数是list, 也可以是tuple　或者是set类list结构的, dict 是不行的,不过返回的结果都是list\n\nmap(sq, (1,3, 5,7,9)) # tuple [1, 9, 25, 49, 81]\nmap(sq, set([1,3, 5,3,7,9])) # set [1, 9, 81, 25, 49]\n\n\n这里顺便说一下, dict的结构是用{} 表示的,如\n\n {\"name\": \"Yi_Zhi_Yu\", \"age\":25}\n\n\n是直观的key-value形式, 那么如果{}中的是一个类list的结构呢, 如:\n\n{\"Yi_Zhi_Yu\", 25}\n\n\n其实, 这就是set的最终返回形式, 等价于:\n\nset([\"Yi_Zhi_Yu\", 25])# 你会看到最终的输出形式是{25, 'Yi_Zhi_Yu'}\n\n\n那么, 自然{}有重复值得时候也会去重\n\n   {1,3, 5, 3, 7, 9}  #{1, 3, 5, 7, 9}\n\n\nreduce\n\nreduce(funcname, list)\n\n\n与map相比 , reduce类似于一个聚合类的应用方法, 把list中的参数, 依次传递给funcname, 每次funcname的参数都是上个funcname 执行结果和下一个list中的元素, 所以, funcname 的 参数必须是两个. 从执行过程看, 有点像递归\n\n例如: 求range(1, 101)(不包括101)的和,\n\ndef c_sum(x, y):\n    return x + y;\nreduce(c_sum, range(1,101)) #5050\n\n\nfilter\n\nfilter(funcname, list)\n\n\n执行过程依次将list中的元素传递到funcname函数中, 根据funcname返回的True或False 保留或丢弃元素\n\n例: 返回某个list中的所有int数据\n\n def is_int(x):\n    if isinstance(x, (int)):\n        return True\n    else:\n        return False\n\n filter(is_int, [\"Yi\",2, \"3\", 4]) #[2, 4]\n\n\nsorted\n\nsorted( list, [comp_func])\n\n\n排序方法, 第二个是可选参数, 根据可选参数返回的值, 对结果进行排序, comp_func 接受两个参数(x, y), 最终返回的结果应该是-1.0,1, 如果返回的是-1, 表示x<y , 0表示x=y, 1表示x>y, 所以, 实际的排序可以自定义\n默认是正序排序:\n\nsorted([3,4, 12, 5, 9, 1])  #[1, 3, 4, 5, 9, 12]\n\n\n如果是需要倒序排列, 自定义方法:\n\n def m_order(x, y):\n    if(x > y):\n        return -1\n    elif(x == y):\n        return 0\n    else:\n        return 1\nsorted([3,4, 12, 5, 9, 1], m_order)  #[12, 9, 5, 4, 3, 1]\n\n\nPS: 以上为学习笔记, 如有错误, 还望指正\n  参考：廖雪峰Python教程\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "9"}