{"title": "Bottle源码阅读（二） - 学无止境 ", "index": "python,bottle", "content": "在《Bottle源码阅读（一）》中，我们了解了bottle如何接收请求，处理请求以及如何检测模块变化重启server。在ServerHandler类中的run函数中，application接受了两个参数，一个envrion， 和一个start_response的方法，接下来我们就来了解我们写的应用函数是如何被封装成适配的application。\n1.上层调用\n先看一个简单的例子\nfrom bottle import get, run\n@get('/hello')\ndef hello():\n    return \"hello\"\n\nrun(host='localhost', port=8080)\n通过get装饰器，使requestline ’/hello‘ 路由到hello函数，并将函数返回的结果通过WSGIRequestHandler 中的wfile返回。\n接下来我们看一下get源码是怎么实现的\n\nroute     = make_default_app_wrapper('route')\n# 经过封装后，get最终获得的是具备有Bottle.get一些属性的装饰器\nget       = make_default_app_wrapper('get')\npost      = make_default_app_wrapper('post')\nput       = make_default_app_wrapper('put')\ndelete    = make_default_app_wrapper('delete')\nerror     = make_default_app_wrapper('error')\nmount     = make_default_app_wrapper('mount')\nhook      = make_default_app_wrapper('hook')\ninstall   = make_default_app_wrapper('install')\nuninstall = make_default_app_wrapper('uninstall')\nurl       = make_default_app_wrapper('get_url')\n\ndef make_default_app_wrapper(name):\n    ''' Return a callable that relays calls to the current default app. '''\n    \n    # 当name为'get'时，将Bottle.get的属性传递给wrapper，使其具备相同的属性。\n    @functools.wraps(getattr(Bottle, name))\n    def wrapper(*a, **ka):\n        # 使用默认的app， 也就是说，应用函数的装饰器实际是Bottle.get(*a, **ka)\n        return getattr(app(), name)(*a, **ka)\n    return wrapper\n    \n\napp = default_app = AppStack()\napp.push()\nclass AppStack(list):\n    \"\"\" A stack-like list. Calling it returns the head of the stack. \"\"\"\n\n    def __call__(self):\n        \"\"\" Return the current default application. \"\"\"\n        return self[-1]\n\n    def push(self, value=None):\n        \"\"\" Add a new :class:`Bottle` instance to the stack \"\"\"\n        if not isinstance(value, Bottle):\n            value = Bottle()\n        self.append(value)\n        return value\n我们可以顺便看一下wraps和update_wrapper的源码， wraps实际调用了partial函数（C写的),update_wrapper保留了被装饰函数原来的属性('__module__', '__name__', '__doc__')\ndef update_wrapper(wrapper,\n                   wrapped,\n                   assigned = WRAPPER_ASSIGNMENTS,\n                   updated = WRAPPER_UPDATES):\n    for attr in assigned:\n        setattr(wrapper, attr, getattr(wrapped, attr))\n    for attr in updated:\n        getattr(wrapper, attr).update(getattr(wrapped, attr, {}))\n    # Return the wrapper so this can be used as a decorator via partial()\n    return wrapper\n\ndef wraps(wrapped,\n          assigned = WRAPPER_ASSIGNMENTS,\n          updated = WRAPPER_UPDATES):\n    return partial(update_wrapper, wrapped=wrapped,\n                   assigned=assigned, updated=updated)\n2.Bottle类中的应用函数装饰器\n由上述我们可以知道应用函数装饰器@get(’/hello‘)，实际为Bottle.get(a, *ka) 。get实际调用route，hello函数作为callback， ’/hello‘作为path， 并将Route实例后添加进self.route，当接收请求时再由self.match调用self.router.match(environ)返回对应的Route实例，并将callback执行结果响应返回\n    def get(self, path=None, method='GET', **options):\n        \"\"\" Equals :meth:`route`. \"\"\"\n        return self.route(path, method, **options)\n        \n    def route(self, path=None, method='GET', callback=None, name=None,\n              apply=None, skip=None, **config):\n\n        if callable(path): path, callback = None, path\n        plugins = makelist(apply)\n        skiplist = makelist(skip)\n        def decorator(callback):\n            # TODO: Documentation and tests\n            if isinstance(callback, basestring): callback = load(callback)\n            for rule in makelist(path) or yieldroutes(callback):\n                for verb in makelist(method):\n                    verb = verb.upper()\n                    route = Route(self, rule, verb, callback, name=name,\n                                  plugins=plugins, skiplist=skiplist, **config)\n                    self.add_route(route)\n            return callback\n        return decorator(callback) if callback else decorator\n\n3.断点查看请求响应过程\n1. ServerHandler类中的run函数中, application 为Bottle一个实例\n    self.result = application(self.environ, self.start_response)\n\n2. bottle.Bottle类中\n    def __init__(self, catchall=True, autojson=True):\n        self.router = Router()\n    \n    # Router类主要建立url，method和应用函数的映射字典，同时实现match方法\n    def add_route(self, route):\n        ''' Add a route object, but do not change the :data:`Route.app`\n            attribute.'''\n        self.routes.append(route)\n        self.router.add(route.rule, route.method, route, name=route.name)\n        if DEBUG: route.prepare()\n\n    \n    def __call__(self, environ, start_response):\n        ''' Each instance of :class:'Bottle' is a WSGI application. '''\n        return self.wsgi(environ, start_response)\n        \n    \n    def wsgi(self, environ, start_response):\n            ...\n            out = self._cast(self._handle(environ))\n            ...\n            return out\n            \n    def _handle(self, environ):\n            ...\n                # 上述中应用函数的装饰器，就将应用函数和路径作为参数实例化了一个Route实例，并将它添加到了router中，调用match时，通过正则表达式匹配调用相应的route实例\n                route, args = self.router.match(environ)\n            ...\n                return route.call(**args)\n            ...\n            \n3.bottle.Route类，主要是封装了应用函数及其对应的metadata和配置\n    @cached_property\n    def call(self):\n        ''' The route callback with all plugins applied. This property is\n            created on demand and then cached to speed up subsequent requests.'''\n        return self._make_callback()\n     \n    def _make_callback(self):\n        callback = self.callback\n        for plugin in self.all_plugins():\n            try:\n                if hasattr(plugin, 'apply'):\n                    api = getattr(plugin, 'api', 1)\n                    context = self if api > 1 else self._context\n                    callback = plugin.apply(callback, context)\n            ...\n        return callback\n        \n4. 在上述的调用过程的plugin在本例中使用JSONPlugin， 将应用函数的结果序列化之后返回\nclass JSONPlugin(object):\n    name = 'json'\n    api  = 2\n\n    def __init__(self, json_dumps=json_dumps):\n        self.json_dumps = json_dumps\n\n    def apply(self, callback, route):\n        dumps = self.json_dumps\n        if not dumps: return callback\n        def wrapper(*a, **ka):\n            try:\n                rv = callback(*a, **ka)\n            except HTTPError:\n                rv = _e()\n\n            if isinstance(rv, dict):\n                #Attempt to serialize, raises exception on failure\n                json_response = dumps(rv)\n                #Set content type only if serialization succesful\n                response.content_type = 'application/json'\n                return json_response\n            elif isinstance(rv, HTTPResponse) and isinstance(rv.body, dict):\n                rv.body = dumps(rv.body)\n                rv.content_type = 'application/json'\n            return rv\n\n        return wrapper\n        \n4.缓存响应结果\n上述代码中，我们注意到在调用call函数时使用了cached_property的装饰器，当第一次发起请求时，应用函数会被执行，而结果也将被保存。当再次请求，只需要从__dict__中获取相应的属性值即可\nclass cached_property(object):\n    ''' A property that is only computed once per instance and then replaces\n        itself with an ordinary attribute. Deleting the attribute resets the\n        property. '''\n\n    def __init__(self, func):\n        self.__doc__ = getattr(func, '__doc__')\n        self.func = func\n\n    def __get__(self, obj, cls):\n        if obj is None: return self\n        # 在调用时，会先从__dict__属性中查找对应的属性值，如果找不到则再使用func函数的执行结果\n        value = obj.__dict__[self.func.__name__] = self.func(obj)\n        return value\n看到这里，我们大概就清楚了从发起请求到解析请求，路由分发，返回应用函数结果的大概流程。url与callback的映射关系建立和match需要重点关注一下Router类，而callback的结果解析与相关的metadata则需要继续关注Route类\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}