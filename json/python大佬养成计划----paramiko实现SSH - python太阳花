{"title": "python大佬养成计划----paramiko实现SSH - python太阳花 ", "index": "python", "content": "paramiko模块\nSSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题.\nparamiko是用python语言写的一个模块，遵循SSH2协议，支持以加密和认证的方式，进行远程服务器的连接。paramiko支持Linux, Solaris, BSD, MacOS X, Windows等平台通过SSH从一个平台连接到另外一个平台。利用该模块，可以方便的进行ssh连接和sftp协议进行sftp文件传输。\n远程密码连接\n#基于ssh,用于连接远程服务器做操作：远程执行命令，上传或下载文件\nimport paramiko\n\n#创建一个ssh对象\nclient = paramiko.SSHClient()\n#2.解决问题：首次连接，会出现\n# Are you sure you want to continue connecting (yes/no)? yes\n# 自动选择yes\n\n# 允许连接不在know_hosts文件中的主机\nclient.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n\n#3.连接服务器\nclient.connect(hostname='172.25.254.19',port=22,username='root',password='westos')\n\n#4.执行操作\nstdin,stdout,stderr = client.exec_command('hostname')#标准输入，标准输出，标准错误输出。\n#Execute a command on the SSH server.  A new `.Channel` is opened and\n# the requested command is executed.  The command's input and output\n# streams are returned as Python ``file``-like objects representing\n# stdin, stdout, and stderr.\n\n#5.获取命令的执行结果\nres = stdout.read().decode('utf-8')#使结果具有可读性\n\nprint(res)\n\n#6.断开连接\nclient.close()\n\n批量连接\n批量连接host.txt文件中的主机，返回执行结果格式：172.25.254.1:22:root:westos\nimport paramiko\nwith open('host.txt') as f: #保证host.txt文件在当前目录下\n    hostinfos = f.readlines()   #列表形式，['172.25.254.1:22:root:westos\\n', '172.25.254.2:22:root:westos\\n', '172.25.254.3:22:root:westos\\n', '172.25.254.19:22:root:westos\\n']\n\n    for hostinfo in hostinfos:\n        hostinfo = hostinfo.strip() #去掉空格,字符串格式,172.25.254.2:22:root:westos\n        print('正在连接%s主机' %(hostinfo.split(':')[0]))\n        hostname,port,username,passwd = hostinfo.split(':')\n        try:\n            client = paramiko.SSHClient()\n            client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n            client.connect(hostname=hostname,port=port,username=username,password=passwd)\n            stdin,stdout,stderr = client.exec_command('hostname')\n            res = stdout.read().decode('utf-8')\n            print('结果为：',res)\n        except Exception as e :\n            print(\"Connection is failed,the reason is :\",e)\n        finally:\n            client.close()\n            print(\"连接结束\")\n\n基于公钥连接\n免密登录远程主机首先在需要连接的主机上生成一对公钥和私钥，本机获取到需要连接的主机的私钥时，就可以通过公私钥配对，登陆远程主机。这里需要id_rsa存放你所连接的主机的私钥\nimport paramiko\nfrom paramiko.ssh_exception import NoValidConnectionsError, AuthenticationException\n\ndef conn(cmd,hostname,port=22,username='root'):\n    client = paramiko.SSHClient()\n    private_key = paramiko.RSAKey.from_private_key_file('id_rsa')#id_rsa存放私钥\n    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n    try:\n        client.connect(hostname=hostname,\n            port=port,username=username,pkey=private_key)\n    except NoValidConnectionsError as e:\n        print('...连接失败...')\n    except AuthenticationException as e:\n        print('...密码错误...')\n    else:\n        stdin, stdout, stderr = client.exec_command(cmd)\n        result = stdout.read().decode('utf-8')\n        print(result)\n\n    finally:\n        client.close()\n\n\nif __name__=='__main__':\n    for count in range(13,20):\n        hostname = '172.25.254.%s' %(count)\n        print('正在连接主机：',hostname)\n        conn('hostname',hostname)\n    print(\"...连接结束...\")\n\n基于用户名密码上传下载文件\nsftp是Secure File Transfer Protocol的缩写，安全文件传送协议。可以为传输文件提供一种安全的网络的加密方法。\nimport paramiko\ntran = paramiko.Transport('172.25.254.19',22)\ntran.connect(username='root',password='westos')\n\n\nsftp = paramiko.SFTPClient.from_transport(tran)\n#class SFTPClient(BaseSFTP, ClosingContextManager)\n#SFTP client object.\n# Used to open an SFTP session across an open SSH `.Transport` and perform\n# remote file operations.\n# Instances of this class may be used as context managers.\nsftp.put('/home/kiosk/PycharmProjects/day18/07_pratice.py','/mnt/practice.py')\nsftp.get('/mnt/passwd','hallo')\ntran.close()\n\nparamiko再封装\n使paramiko模块执行自己想要的操作\nimport paramiko\nimport os\nfrom paramiko.ssh_exception import NoValidConnectionsError, AuthenticationException, SSHException\n\nclass SshRrmote(object):\n    def __init__(self,cmd,hostname,port,username,passwd):\n        self.hostname = hostname\n        self.passwd = passwd\n        self.cmd = cmd\n        self.username = username\n        self.port = port\n    def run(self):\n        \"\"\"默认调用的内容\"\"\"\n        # cmd hostname\n        # put local_file remote_file\n        # get remote_file local_file\n        cmd_str = self.cmd.split()[0]  # cmd\n        # 类的反射, 判断类里面是否可以支持该操作?\n        if hasattr(self, 'do_' + cmd_str):  # do_cmd\n            getattr(self, 'do_' + cmd_str)()\n        else:\n            print(\"目前不支持该功能\")\n    def do_cmd(self):\n        client = paramiko.SSHClient()\n        try:\n            client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n            client.connect(hostname=self.hostname,port=int(self.port),username=self.username,password=self.passwd)\n\n        except NoValidConnectionsError as e:\n            print('...连接失败...')\n        except AuthenticationException as e:\n            print('...密码错误...')\n        else:\n            cmd = ' '.join(self.cmd.split()[1:])\n            stdin, stdout, stderr = client.exec_command(cmd)\n            result = stdout.read().decode('utf-8')\n            print('执行结果',result)\n        finally:\n            print('断开%s的连接' %(self.hostname))\n            client.close()\n    def do_get(self):\n        #有待改进，因为连接多个主机时，会覆盖文件\n        print('开始下载')\n        try:\n            trans = paramiko.Transport(self.hostname,int(self.port))\n            trans.connect(username=self.username,password=self.passwd)\n            print('hello')\n        except SSHException as e:\n            print(\"连接失败\")\n        else:\n            sftp = paramiko.SFTPClient.from_transport(trans)\n            cmd = self.cmd.split()[1:]\n            if len(cmd)==2:\n                sftp.get(cmd[0],cmd[1])\n                print(\"下载文件%s成功，并保存为%s\" %(cmd[0],cmd[1]))\n            else:\n                print(\"参数有误\")\n            trans.close()\n    def do_put(self):\n        # put /tmp/passwd /tmp/passwd  # 将本机的/tmp/passwd文件上传到远程主机的/tmp/passwd;\n        print(\"开始上传\")   #注意你使用的用户是否为kiosk\n        try:\n            trans = paramiko.Transport(self.hostname, int(self.port))\n            trans.connect(username=self.username, password=self.passwd)\n\n        except SSHException as e:\n            print(\"连接失败\")\n        else:\n            sftp = paramiko.SFTPClient.from_transport(trans)\n            cmd = self.cmd.split()[1:]\n            if len(cmd) == 2:\n                sftp.put(cmd[0],cmd[1])\n                print(\"上传文件%s成功，并保存为%s\" %(cmd[0], cmd[1]))\n            else:\n                print(\"参数有误\")\n            trans.close()\n\n#1.选择要操作的主机组：mysql,web,ftp\n#       主机信息怎么存？将不同的主机信息存放在不同的文件中\n#2.根据选择的主机组，显示包含的主机IP/主机名\n#3.让用户确认信息，选择需要批量执行的命令\n#   -cmd shell命令\n#   -put 本地文件 远程文件\n#   -get 远程文件 本地文件\n\ndef main():\n    groups = [file.rstrip('.conf') for file in os.listdir('conf')]\n    print('主机组显示'.center(50,'*'))\n    [print('\\t',item) for item in groups]\n    choiceGroup = input(\"请选择批量操作的主机组(eg:web):\")\n    with open('conf/'+choiceGroup+'.conf') as f:\n        info = f.readlines()\n        print(\"批量执行脚本\".center(50, '*'))\n        while True:\n            cmd = input(\">>\").strip()\n            if cmd:\n                if cmd =='exit':\n                    print(\"连接执行结束\")\n                    break\n                for item in info:\n                    item=item.strip()\n                    print(item.split(':')[0].center(50,'-'))\n                    hostname,port,username,passwd = item.split(':')\n                    ssh = SshRrmote(cmd,hostname,port,username,passwd)\n                    ssh.run()\n\nmain()\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}