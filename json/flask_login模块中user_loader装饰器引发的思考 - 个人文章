{"title": "flask_login模块中user_loader装饰器引发的思考 - 个人文章 ", "index": "flask,python", "content": "今天看书遇到了flask login模块中的信号机制，看到user_loader这个装饰器时有些疑惑，为什么需要这个装饰器呢，先看一下源码：\ndef user_loader(self, callback):\n    '''\n    This sets the callback for reloading a user from the session. The\n    function you set should take a user ID (a ``unicode``) and return a\n    user object, or ``None`` if the user does not exist.\n\n    :param callback: The callback for retrieving a user object.\n    :type callback: callable\n    '''\n    self.user_callback = callback\n    return callback\n\n看到这不禁疑惑，它的作用只是将被它包装的函数存到self.user_callback这个属性中去，我们先到login_user这个登陆函数中去看看：\ndef login_user(user, remember=False, duration=None, force=False, fresh=True):\n    if not force and not user.is_active:\n        return False\n\n    user_id = getattr(user, current_app.login_manager.id_attribute)()\n    session['user_id'] = user_id\n    session['_fresh'] = fresh\n    session['_id'] = current_app.login_manager._session_identifier_generator()\n\n    if remember:\n        session['remember'] = 'set'\n        if duration is not None:\n            try:\n                # equal to timedelta.total_seconds() but works with Python 2.6\n                session['remember_seconds'] = (duration.microseconds +\n                                               (duration.seconds +\n                                                duration.days * 24 * 3600) *\n                                               10**6) / 10.0**6\n            except AttributeError:\n                raise Exception('duration must be a datetime.timedelta, '\n                                'instead got: {0}'.format(duration))\n\n    _request_ctx_stack.top.user = user\n    user_logged_in.send(current_app._get_current_object(), user=_get_user())\n    return True\n\n可以看到，login_user这个函数接受user这个主要的参数，getattr(user, current_app.login_manager.id_attribute)()这句是为了调用user中的get_id方法\nself.id_attribute = ID_ATTRIBUTE\nID_ATTRIBUTE = 'get_id'\n\n注意在getattr后面还有个()所以会调用对应的方法，所以user_id中就存放了登陆用户的id号，并写入到session中去，如果设置了remember为True的话，关掉浏览器重新打开后，用户不会退出，函数的最后_request_ctx_stack.top.user = user，将当前user加入到请求上下文的栈顶，就能用current_user获取了。上面说到self.user_callback已经存了被user_loader装饰的函数，那么在哪里用到了它呢，我在login_manager.py中查找，发现只有一个方法使用到了这个熟悉，这个方法是reload_user()：\ndef reload_user(self, user=None):\n    '''\n    This set the ctx.user with the user object loaded by your customized\n    user_loader callback function, which should retrieved the user object\n    with the user_id got from session.\n\n    Syntax example:\n    from flask_login import LoginManager\n    @login_manager.user_loader\n    def any_valid_func_name(user_id):\n        # get your user object using the given user_id,\n        # if you use SQLAlchemy, for example:\n        user_obj = User.query.get(int(user_id))\n        return user_obj\n\n    Reason to let YOU define this self.user_callback:\n        Because we won't know how/where you will load you user object.\n    '''\n    ctx = _request_ctx_stack.top\n\n    if user is None:\n        user_id = session.get('user_id')\n        if user_id is None:\n            ctx.user = self.anonymous_user()\n        else:\n            if self.user_callback is None:\n                raise Exception(\n                    \"No user_loader has been installed for this \"\n                    \"LoginManager. Refer to\"\n                    \"https://flask-login.readthedocs.io/\"\n                    \"en/latest/#how-it-works for more info.\")\n            user = self.user_callback(user_id)\n            if user is None:\n                ctx.user = self.anonymous_user()\n            else:\n                ctx.user = user\n    else:\n        ctx.user = user\n\n它先从请求上下文中取出最新的请求，如果没有传入user，那么会从session中试图取出对应的user_id，这是一种保护机制，不使用cookie，而使用session，user_id在login时会写入session，如果登陆时remember参数传入了True，那么关闭浏览器重新打开后session['user_id']将不会被清除，这时候也就可以获取到了，如果登陆时没有设置remember为True，那么关闭浏览器后user_id会被设为None，则ctx.user = self.anonymous_user()，栈顶的用户为匿名用户，也就需要重新登陆了;取出了user_id，并且self.user_callback不为空，则会调用被user_loader装饰的函数，并传入user_id，在被装饰的函数中我们要根据这个user_id来查找并返回对应的用户实例，如果成功返回，那么当前请求上下文栈顶的用户就设置为返回的用户。你可能会问，为什么要重载用户呢？因为http协议是无状态的，每次都会发送一个新的请求，请求上下文的栈顶会被新的请求覆盖，对应的user属性也就没了，所以需要通过reload_user重载上一次记录在session中并且未被清除的用户，重载失败则需要重新登陆，这也就是这个装饰器的作用了。最后我们看下logout_user()这个方法：\ndef logout_user():\n'''\nLogs a user out. (You do not need to pass the actual user.) This will\nalso clean up the remember me cookie if it exists.\n'''\n\nuser = _get_user()\n\nif 'user_id' in session:\n    session.pop('user_id')\n\nif '_fresh' in session:\n    session.pop('_fresh')\n\ncookie_name = current_app.config.get('REMEMBER_COOKIE_NAME', COOKIE_NAME)\nif cookie_name in request.cookies:\n    session['remember'] = 'clear'\n    if 'remember_seconds' in session:\n        session.pop('remember_seconds')\n\nuser_logged_out.send(current_app._get_current_object(), user=user)\n\ncurrent_app.login_manager.reload_user()\nreturn True\n\nlogout主要是清除了session和cookie中的关键参数，比如login时设置的user_id以及remember等，清除后又调用了reload_user()，根据之前的逻辑，当然不可能重载成功，因为user_id已经为None了，执行到ctx.user = self.anonymous_user()就已经结束了，其实reload_user算是这个模块中很关键的一个函数，login_manager这个类也是这个模块的核心所在，以后有时间继续研究。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "1"}