{"title": "Python数据分析 - numpy - 7BLOG ", "index": "python", "content": "前言\nNUMPY（以下简称NP）是Python数据分析必不可少的第三方库，np的出现一定程度上解决了Python运算性能不佳的问题，同时提供了更加精确的数据类型。如今，np被Python其它科学计算包作为基础包，已成为Python 数据分析的基础，可以说，NP是SciPy、Pandas等数据处理或科学计算库最基本的函数功能库。因此，理解np的数据类型对python数据分析十分有帮助。下面，本文将介绍Np的常用操作和基本数据类型。\nNP提供了以下重点功能。\n\n一个强大的N维数组对象ndarray\n广功能函数\n整合C/C++/Fortran代码的工具\n提供了线性代数、傅里叶变换、随机数生成的相关功能\n\n为了更加直观的了解Np的强大与作用，我们先看作用再看方法：\n使用NUMPY操作数据集\n在操作数据之前，我们先来理解什么是维度：\n什么是维度\n维度是一组数据的组织形式，不同数据维度可能表示不同的含义。一维数据由对等关系的有序或无序数据构成，采用线性方式组织，可以用数组表示。通俗来讲，\n1，2，3，4\n这么一行数据就可以称之为一维数据，但如果我们再对其折叠：\n1，2，3，4\n那么他就成为了二维数据，又可以称之为矩阵。\n什么是数据集\n数据集，顾名思义就是数据的集合，是用以训练程序的数据集合，一般是二维或者多维数表。如果我们想自己手工新建一个数据集，可以直接新建一个文本文件，只要有恰当的数据，都可以称之为数据集：\n城市,环比,同比,定基\n北京,100.1,100.2,100.3\n上海,111.1,111.2,111.3\n南京,133.0,133.3,133.4\n比如这样，我们就可以称上面的文件称之为数据集。我们还注意到，上面数据是使用逗号作为分隔符分隔数据的，它简单描述了数据的内容和含义，并使用半角逗号作为分隔符。像这样，用逗号分隔的数据集就称之为CSV（Comma-Separated Value,逗号分隔值）数据集，它是一种常见的文件格式，用来存储批量的数据。它就像一张excel表，用来存储简单结构的数据。怎么样，数据集的概念是否特别简单呢？\n生成数据集\n数据集是一个简单的概念，但每次使用手工的方式去写毕竟不方便，所以，我们可以使用np的内置函数来生成数据集：\nnp.savetxt(frame,array,fmt='%.18e\",delimiter=None)\n\nframe：文件、字符串、或产生器的名字，可以是.gz，.bz2的压缩文件\narrray：存入文件的NP的数组\nfmt(format):写入文件的格式，如%d,%.2f,%.18e(默认，科学计数法保留18位)\ndelemiter:分割字符串，默认是任何空格。\n\n我们可以这样写下代码：\na= np.arange(20).reshape(4,5)\nnp.savetxt('demo.csv',a,fmt='%d',delimiter=',')\n这样，我们就会在当前的工作目录下发现一个新的demo.csv，用记事本打开，里面是一个4 * 5的矩阵，元素0~19。\n读取数据集\n既然生成，那就可以读取，同样使用np：\nnp.loadtxt(frame,dtype=np.float,delimiter=None,inpack=False)\n\nframe:指定读入的文件来源\ndtype:数据类型，默认为np.float。\ndelimiter:分割字符串\nunpack：默认为False读入文件写入一个数组，如果为True，读入属性将分别写入不同变量\n\n同样的我们只需要写下代码：\nnp.loadtxt(\"demo.csv\",delimiter=\",\")\n就可以查看到我们先前写入的数组a。\nCSV文件的局限\n可以发现，CSV文件只能有效存储和读取一维和二维数组，因为更高的维度无法更直观的文本下显现出来，这时，更加灵活的存取方式就呼之欲出了，但讲之前先卖个关子，再介绍一个不太常用的方法：tofile：对于NP中的ndarray数组，我们可以使用NP中的tofile方法。\na.tofile(frame,sep='',format='%d')\n\nframe:文件，字符串\n数据分割字符串，如果不写，将使用二进制文件存储\nformat：写入数据的格式\n\n同样，我们只需要命令：\nimport numpy as np\na = np.arange(100).reshape(5,10,2)\na.tofile(\"a.dat\",sep=',',format='%d')\n\n就可以生成新的CSV数据集。\n此时，我们如果打开a.dat文件，我们可以看到数组1,2,3……99。但是与CSV不同，这个文件并没有包含数字的维度信息，他只是将数组所有元素逐一的列出。而且如果我们不指定sep，将保存为二进制文件，虽然对人不可读，但将占用更小的空间。\n既然tofile可以保存文本文件，那么也很容易猜到对应的fromfile可以还原这些信息。\nnp.fromfile(frame,dtype=float,count=-1,sep='')\n\nframe：文件\ndtype：读取元素使用的数据类型，默认为float\ncount：读文件的个数，默认-1，读取全部\nsep:数据分割字符串，如果是空串，写入文件为二进制。\n\n如果我们想要重新恢复数据的维度信息，我们需要重新使用reshape来恢复维度信息：\nc = np.fromfile(\"b.dat\",sep=',',dtype=np.int).reshape(5,10,2)\n\n不得不说，当我看到这个方法时感觉这两个真是蠢爆了，使用savetxt / loadtxt 至少还能保存个二维信息，而使用了tofile / fromfile 方法居然把数被伸展为一维的，然后自己记住维度信息(╯‵□′)╯︵┻━┻。\n因此，为了保存更复杂的数据类型，二维以上的数据信息，save / load 函数成功解决了这个问题：（为了方便，两个函数就放到一起了）\n保存 / 读取高维度数据\nnp.save(frame,array)或np.savez(fname,array)(压缩)\n+ frame：文件名，以.npy为扩展名，压缩扩展名为.npz\n+ array：数组变量\nnp.load(fname)\nDemo:\na = np.arange(100).reshape(5,10,2)\nnp.save(\"a.npy\",a)\nb=np.load(\"a.npy\")\n附录\n附录中提供NP的常用方法及注释，做查询用。\nnp数组定义\n>>>lst = [[1,3,5],[2,4,6]]\n>>>np_lst = np.array(lst,dtype=np.float)\n>>>print(np_lst.shape)#返回数组的行列\n>>>print(np_lst.ndim)#返回数组的维数\n>>>print(np_lst.dtype)#返回数据类型，float默认为64\n>>>print(np_lst.itemsize)#np.array每个元素的大小，float64占8个字节\n>>>print(np_lst.size)#大小，6个元素\n(2, 3)\n2\nfloat64\n8\n6\n\n初始化数组\n>>>print(np.zeros([2,4])#初始化一个2行4列的数组\n>>>print(np.ones([2,4])\n[[ 0.  0.  0.  0.]\n[ 0.  0.  0.  0.]]\n[[ 1.  1.  1.  1.]\n[ 1.  1.  1.  1.]]\n随机序列\n>>>print(np.random.rand(2,4))#将生成一个处于0~1之间2行4列的随机数序列（不加参数将只返回一个）\n[[ 0.39531286  0.4845      0.1463168   0.82327991]\n[ 0.89042255  0.65049931  0.43890163  0.89577744]]\n如果想要多个随机整数：\nprint(np.random.randint(22,55,3))#必须有（前两个参数）指定范围，第三个参数用于指定生成的个数\n[27 40 29]\nprint(np.random.randn(2，4))#生成标准正态随机数\n[[-1.15561548  0.3689953   0.38253231 -1.16346441]\n[-1.32625322 -0.41707673 -0.11822205 -0.95807535]]\nprint(np.random.choice([10,20,40,33]))#从指定可迭代的数组中生成随机数\n20\nprint(np.random.beta(1,10,4))#生成4个beta分布\n[ 0.02258548  0.25848896  0.00696899  0.0609543 ]\n多维数组运算\nprint(np.arange(1,11,2))#得到step为2的range序列\n[1 3 5 7 9]\n还可以使用reshape函数，对数组结构重定义：\nprint(np.arange(1,11).reshape(2,5))#（5可以缺省为-1）\n[[ 1  2  3  4  5]\n[ 6  7  8  9 10]]\n下面介绍一些常用的运算操作：\nlst=np.arange(1,11).reshape(2,5)\nprint(np.exp(lst))#自然指数操作\n[[  2.71828183e+00   7.38905610e+00   2.00855369e+01   5.45981500e+01    1.48413159e+02]\n[  4.03428793e+02   1.09663316e+03   2.98095799e+03   8.10308393e+03    2.20264658e+04]]\n此外，还可以sqrt、log、sin、sum、max等操作：我们下定义一个三维数组：\nlst = np.array([\n                [[1,2,3,4],[4,5,6,7]],\n                [[7,8,9,10],[10,11,12,13]],\n                [[14,15,16,17],[18,19,20,21]]\n            ])\nprint(lst.sum())\n252\n我们可以看到sum方法对lst的所有元素都进行了求和，此外我们还可以通过对sum方法增加参数axis的方式来设置求和的深入维度：\nprint(lst.sum(axis=0))\n[[22 25 28 31]#22=1+7+14；25=2+8+15\n[32 35 38 41]]\nprint(lst.sum(axis=1))\n[[ 5  7  9 11]#5=1+4；7=2+5\n[17 19 21 23]\n[32 34 36 38]]\nprint(lst.sum(axis=2))\n[[10 22]#10=1+2+3+4；22=4+5+6+7\n[34 46]\n[62 78]]\n这里的axis取值为数组维数-1，axis可以理解为进行运算操作时的深入程度，axis越大，深入程度越大。同理，不仅sum函数，max等函数也可以一样理解。\n相加运算\nnumpy.array是np最简单的数据结构。np.array相比与Python原生列表其强大之处在于可以实现对数组数据的运算。我们知道，list只能对元素的追加。而numpy是真正意义上的数据运算。例如\n    In [1]: import numpy as np\n    In [2]: list1 = np.array([10,20,30,40])\n    In [3]: list2 = np.array([4,3,2,1])\n    In [4]: print(list1)\n    [10 20 30 40]\n    In [5]: print(list1+list2)\n    [14 23 32 41]    \n但np最强大的地方不在于简单的一维运算，Np对矩阵也能进行基本的运算操作：\nlst1 =np.array([10,20,30,40])\nlst2 = np.array([4,3,2,1])\nprint(np.dot(lst1.reshape([2,2]),lst2.reshape([2,2])))\n[[10 22]\n[34 46]\n[62 78]]\n[[ 80  50]\n[200 130]]\n\n此外，由于原生list没有确定的数据类型，所以维护起来成本较高，而使用C编写的numpy，则可以声明各种常见的数据类型：\nlst = [[1,3,5],[2,4,6]]\nnp_lst = np.array(lst,dtype=np.float)\nnp所支持的数据类型都有bool、int8/16/32/64/128/、uint8/16/32/64/128、float16/32/43、complex64/128、string。\n总结\nPython作为一门弱类型语言，有其不可避免的缺点。但NP的出现，弥补了这些缺点，使其具备了构造复杂数据类型的能力，为Python数据分析提供了基础。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "4"}