{"title": "【generator101】 - stackless的api - taowen ", "index": "stackless,python", "content": "如果说greenlet相比generator来说，是一种隐式的协程的话，stackless python提供的api就更加隐式了。\n\nimport stackless\n\ndef func(a, b):\n    print('2 current: %s' % stackless.getcurrent())\n    print('2 main: %s' % stackless.getmain())\n    print('2 prev: %s' % stackless.getcurrent().prev)\n    print('2 next: %s' % stackless.getcurrent().next)\n    print(a)\n    stackless.schedule()\n    print(b)\n    stackless.schedule()\n    print('finished')\n\nt = stackless.tasklet()\nt.bind(func, ('hello',), {'b': 'world'})\nprint('1 current: %s' % stackless.getcurrent())\nprint('1 main: %s' % stackless.getmain())\nprint('1 run count: %s' % stackless.runcount)\nt.insert()\nprint('2 run count: %s' % stackless.runcount)\nstackless.schedule()\nprint('scheduled back to main')\nstackless.schedule()\nprint('2 run count: %s' % stackless.runcount)\nstackless.schedule()\nprint('2 run count: %s' % stackless.runcount)\n\n\n这段代码的输出是这样的：\n\n1 current: <_stackless.tasklet object at 0x7ffa189b71a0>\n1 main: <_stackless.tasklet object at 0x7ffa189b71a0>\n1 run count: 1\n2 run count: 2\n2 current: <_stackless.tasklet object at 0x7ffa18885f30>\n2 main: <_stackless.tasklet object at 0x7ffa189b71a0>\n2 prev: <_stackless.tasklet object at 0x7ffa189b71a0>\n2 next: <_stackless.tasklet object at 0x7ffa189b71a0>\nhello\nscheduled back to main\nworld\n2 run count: 2\nfinished\n2 run count: 1\n\n\n与greenlet的代码不同，当一个协程希望切换出去的时候，它无法指定把控制权交给谁。在stackless的api里没有父子协程的概念，无法像generator那样一个yield跳回到父，也无法向greenlet那样greenlet.getcurrent().parent找到父然后跳回去。stackless里就一行\n\nstackless.schedule()\n\n\n尼玛，这是要往哪里跳？stackless压根没有提供底层的协程给程序员直接使用，它提供的tasklet的api附赠了一个tasklet的scheduler。这个scheduler的调用方式就是stackless.schedule。scheduler把tasklet串成一个链表，每个tasklet都有一个prev一个next，当stackless.schedule的时候就取当前tasklet的next，把下一个tasklet拉起来执行。通过调用stackless.runcount可以知道这个链表目前的大小。可以看到最开始是1，insert之后变成了2，当func执行完了又变回了1。\n正式因为stackless没有把底层的协程直接控制接口开放，而是强买强卖了一个scheduler，所以想要在stackless像greenlet那样随心所欲的操纵协程还是颇费一番周折的。最后还是有高人把stackless的高阶接口重新封装成了和greenlet一样的底层接口了。目的就是为了让gevent可以跑在stackless python上（虽然比cPython版本的还慢）：http://syncless.googlecode.com/svn/trunk/syncless/greenlet_using_stackless.py\n另外有有一个反过来的版本，在greenlet上封装了一个和stackless python一样的带scheduler的apihttp://syncless.googlecode.com/svn/trunk/syncless/greenstackless.py\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}