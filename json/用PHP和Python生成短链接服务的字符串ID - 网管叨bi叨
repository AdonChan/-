{"title": "用PHP和Python生成短链接服务的字符串ID - 网管叨bi叨 ", "index": "算法,python,php", "content": "假设你想做一个像微博短链接那样的短链接服务，短链接服务生成的URL都非常短例如: http://t.cn/E70Piib, 我们应该都能想到链接中的E70Piib对应的就是存储长链接地址的数据记录的ID，可是这个有大小写字母和数字构成的唯一ID是怎么生成的呢，刚学编程的时候我们用的方法都试拼接一个足够唯一的字符串（比如时间戳加用户ID等等）然后再用MD5或者SHA1散列算法算出一个散列值，用这种方法得到的唯一ID有可能比原始的链接的长度还要长，所以如何来优雅的生成足够短的字符串唯一ID呢？\n我们先来看一个数学问题，普通的数字ID是用十进制来表示的，在十进制中每位都有10种可能（0-9），所以5位的十进制数能呈现最多10 * 10 * 10 * 10 * 10 = 100,000 个ID。 \n现在如果用32进制来表达一个5位数字需要多少位呢？\n<?php \necho base_convert(10000, 10, 32); //答案是 '90g'\n32进制是数字和一些小些字母来组成，所以5位32进制可表达的唯一ID有 32 * 32 * 32 * 32 * 32 = 33,554,432个，数量已经很大了。\n使用32进制也能生成比较短的字符串唯一ID，不过还有更好的解决方案，你也看到了上面短链接的唯一ID里还包含大写字母。\n接下来我们使用62进制转换，将一个十进制数字转化为对应的62进制表示。\n（为什么用62进制？数字加大小写字母一共是62个）\n常用的这几个编程语言里没有提供62进制的转换，所以就需要我们自己写一个函数来进行10进制到62进制的转换。\n/**\n * Convert a numeric string from base 10 to another base.\n *\n * @param $value  decimal string\n * @param int $b  base , max is 62\n * @return string\n */\nfunction to_base($value, $b = 62)\n{\n    $base = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n    $r = $value  % $b;\n    $result = $base[$r];\n    $q = floor($value / $b);\n\n    while ($q)\n    {\n        $r = $q % $b;\n        $q = floor($q / $b);\n        $result = $base[$r].$result;\n    }\n\n    return $result;\n}\n\n/**\n * Convert a 10 base numeric string to a 62 base string\n *\n * @param  int     $value\n * @return string\n */\nfunction base62_encode($value)\n{\n    return to_base($value, 62);\n}\n定义好上面的函数后，让我们将100,000,000 转换成62进制试一试：\necho base62_encode(100000000); //结果是6LAze\n理解了将十进制正整数转换成62进制的字符串表示形式的原理后，在任何编程语言里都可以很轻松地实现一个转换函数，下面再提供一个Python版本的Base62.encode\n#!/usr/bin/python\n# -*- coding=UTF-8 -*-\n\nfrom __future__ import print_function, division\n\nBASE62 = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\ndef encode(num, alphabet=BASE62):\n    \"\"\"Encode a positive number in Base X\n\n    Arguments:\n    - `num`: The number to encode\n    - `alphabet`: The alphabet to use for encoding\n    \"\"\"\n    if num == 0:\n        return alphabet[0]\n    arr = []\n    base = len(alphabet)\n    while num:\n        num, rem = divmod(num, base)\n        arr.append(alphabet[rem])\n    arr.reverse()\n    return ''.join(arr)\n Python函数注解\n\npython的divmod函数用第一个参数num除以第二个参数base，并以元组的形式返回商和余数。\n因为divmod返回两个元素构成的元组，在python中元组可以简写省略两边地括号，所以num, rem = divmod(num, base)是一个元组赋值表达式，并不是divmod函数返回了两个返回值。\n\n一亿用62进制表示出来后的结果是6LAze , 生成的唯一字符串ID足够短。短链接只是一个应用场景，base62还可以应用到很多需要表示唯一ID的地方，这样一来你就不用再使用那些哈希算法来生成那么冗长的字符串了，虽然只是节省了一些空间但是这在高访问量的URL和海量数据的存储中还是能省下来不少资源的。\n\n                ", "mainLikeNum": ["23 "], "mainBookmarkNum": "15"}