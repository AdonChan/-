{"title": "Python_文件操作 - 活到老学到老 ", "index": "python", "content": "python对文件或者文件夹的操作\n\n\n操作\n说明\n\n\n\nos.getcwd()\n得到当前工作目录，即当前Python脚本工作的目录路径\n\n\nos.listdir()\n返回指定目录下的所有文件和目录名\n\n\nos.remove()\n函数用来删除一个文件\n\n\nos.removedirs(r\"c\\python\")\n删除多个目录\n\n\nos.path.isfile()\n检验给出的路径是否是一个文件\n\n\nos.path.isdir()\n检验给出的路径是否是一个目录\n\n\nos.path.isabs()\n判断是否是绝对路径\n\n\nos.path.exists()\n检验给出的路径是否真地存\n\n\nos.path.split()\n返回一个路径的目录名和文件名\n\n\neg os.path.split('/home/swaroop/byte/code/poem.txt')\n结果：('/home/swaroop/byte/code', 'poem.txt')\n\n\nos.path.splitext()\n分离扩展名\n\n\nos.path.dirname()\n获取路径名\n\n\nos.path.basename()\n获取文件名\n\n\nos.system()\n运行shell命令\n\n\nos.getenv() 与os.putenv()\n读取和设置环境变量\n\n\nos.linesep 给出当前平台使用的行终止符\nWindows使用'rn'，Linux使用'n'而Mac使用'r'\n\n\nos.name 指示你正在使用的平台\n对于Windows，它是'nt'，而对于Linux/Unix用户，它是'posix'\n\n\nos.rename(old, new)\n重命名：\n\n\nos.makedirs(r\"c：\\python\\test\")\n创建多级目录\n\n\nos.mkdir(\"test\")\n创建单个目录\n\n\nos.stat(file)\n获取文件属性\n\n\nos.chmod(file)\n修改文件权限与时间戳\n\n\nos.exit()\n终止当前进程\n\n\nos.path.getsize(filename)\n获取文件大小\n\n\nos.mkdir(\"file\")\n创建目录\n\n\nshutil.copyfile(\"oldfile\",\"newfile\")\n复制文件, oldfile和newfile都只能是文件\n\n\nshutil.copy(\"oldfile\",\"newfile\")\noldfile只能是文件夹，newfile可以是文件，也可以是目标目录\n\n\nshutil.copytree(\"olddir\",\"newdir\")\n复制文件夹, olddir和newdir都只能是目录，且newdir必须不存在\n\n\nos.rename(\"oldname\",\"newname\")\n重命名文件（目录）,文件或目录都是使用这条命令\n\n\nshutil.move(\"oldpos\",\"newpos\")\n移动文件（目录）\n\n\nos.remove(\"file\")\n删除文件\n\n\nos.rmdir(\"dir\")\n删除目录, 只能删除空目录\n\n\nshutil.rmtree(\"dir\")\n空目录、有内容的目录都可以删\n\n\nos.chdir(\"path\")\n转换目录, 换路径\n\n\nos.mknod(\"test.txt\")\n创建空文件\n\n\n\nopen 模式：\n\n\n操作\n说明\n\n\n\nr\n以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。\n\n\nw\n以写方式打开，\n\n\na\n以追加模式打开 (从 EOF 开始, 必要时创建新文件)\n\n\nr+\n以读写模式打开\n\n\nw+\n以读写模式打开 (参见 w )\n\n\na+\n以读写模式打开 (参见 a )\n\n\nrb\n以二进制读模式打开\n\n\nwb\n以二进制写模式打开 (参见 w )\n\n\nab\n以二进制追加模式打开 (参见 a )\n\n\nrb+\n以二进制读写模式打开 (参见 r+ )\n\n\nwb+\n以二进制读写模式打开 (参见 w+ )\n\n\nab+\n以二进制读写模式打开 (参见 a+ )\n\n\nfp = open(\"test.txt\", \"w\")\n直接打开一个文件，如果文件不存在则创建文件\n\n\nfp.read([size])\nsize为读取的长度，以byte为单位\n\n\nfp.readline([size])\n读一行，如果定义了size，有可能返回的只是一行的一部分\n\n\nfp.readlines([size])\n把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长，也就是说可能只读到文件的一部分。\n\n\nfp.write(str)\n把str写到文件中，write()并不会在str后加上一个换行符\n\n\nfp.writelines(seq)\n把seq的内容全部写到文件中(多行一次性写入)。这个函数也只是忠实地写入，不会在每行后面加上任何东西。\n\n\nfp.close()\n关闭文件。python会在一个文件不用后自动关闭文件，不过这一功能没有保证，最好还是养成自己关闭的习惯。  如果一个文件在关闭后还对其进行操作会产生ValueError\n\n\nfp.flush()\n把缓冲区的内容写入硬盘\n\n\nfp.fileno()\n返回一个长整型的”文件标签“\n\n\nfp.isatty()\n文件是否是一个终端设备文件（unix系统中的）\n\n\nfp.tell()\n返回文件操作标记的当前位置，以文件的开头为原点\n\n\nfp.next()\n返回下一行，并将文件操作标记位移到下一行。把一个file用于for … in file这样的语句时，就是调用next()函数来实现遍历的。\n\n\nfp.seek(offset[,whence])\n将文件打操作标记移到offset的位置。这个offset一般是相对于文件的开头来计算的，一般为正数。但如果提供了whence参数就不一定了，whence可以为0表示从头开始计算，1表示以当前位置为原点计算。2表示以文件末尾为原点进行计算。需要注意，如果文件以a或a+的模式打开，每次进行写操作时，文件操作标记会自动返回到文件末尾。\n\n\nfp.truncate([size])\n把文件裁成规定的大小，默认的是裁到当前文件操作标记的位置。如果size比文件的大小还要大，依据系统的不同可能是不改变文件，也可能是用0把文件补到相应的大小，也可能是以一些随机的内容加上去。\n\n\n\n参考链接:文章参考菜鸟教程\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "2"}