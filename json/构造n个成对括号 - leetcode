{"title": "构造n个成对括号 - leetcode ", "index": "leetcode,算法,python", "content": "构造n个成对括号\nGenerate Parentheses\n\n给出一个整数n，实现一个函数生成n对小括号，n对小括号的左右括弧顺序不限，但应该闭合。\nGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n\nexample 1\nFor example, given n = 3, a solution set is:\n\n[\n  \"((()))\",\n  \"(()())\",\n  \"(())()\",\n  \"()(())\",\n  \"()()()\"\n].\n\n思路\n\nn=2的情况为n=1时的括号串()中在缝隙位置再插入一个括号，如1(2)3中1,2,3位置。可以用set剔除重复元素。\n递归解决，n=3时为在()()和(())中再插入一个括号。\n思路2来源自leetcode讨论区，使用open记录已经有多少左括号，如果n==0，将\")\" * open闭合。\n\n代码\nclass Solution(object):\n\n    def __init__(self):\n        self.table = {1: ['()']}\n\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        if n == 1:\n            return self.table[1]\n        if n-1 in self.table.keys():\n            nset = set()\n            n1set = self.table[n-1]\n            for _, item in enumerate(n1set):\n                for j in range(len(item)):\n                    nset.add(item[0:j] + '()' + item[j:])\n            self.table[n] = list(nset)\n            return self.table[n]\n        else:\n            self.generateParenthesis(n-1)\n            return self.generateParenthesis(n)\n\n\n    def gen2(self, n, open=0):\n        if n == 0: return [')'*open]\n        if open == 0:\n            return ['('+x for x in self.gen2(n-1, 1)]\n        else:\n            return [')'+x for x in self.gen2(n, open-1)] + ['('+x for x in self.gen2(n-1, open+1)]\n本题以及其它leetcode题目代码github地址: github地址\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}