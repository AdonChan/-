{"title": "Python 探针实现原理 - mozillazg 的学习笔记 ", "index": "探针,apm,python", "content": "本文将简单讲述一下 Python 探针的实现原理。 同时为了验证这个原理，我们也会一起来实现一个简单的统计指定函数执行时间的探针程序。\n探针的实现主要涉及以下几个知识点:\n\nsys.meta_path\nsitecustomize.py\n\nsys.meta_path\nsys.meta_path 这个简单的来说就是可以实现 import hook 的功能， 当执行 import 相关的操作时，会触发 sys.meta_path 列表中定义的对象。 关于 sys.meta_path 更详细的资料请查阅 python 文档中 sys.meta_path 相关内容以及 PEP 0302 。\nsys.meta_path 中的对象需要实现一个 find_module 方法， 这个 find_module 方法返回 None 或一个实现了 load_module 方法的对象 (代码可以从 github 上下载 part1_) :\nimport sys\n\n\nclass MetaPathFinder:\n\n    def find_module(self, fullname, path=None):\n        print('find_module {}'.format(fullname))\n        return MetaPathLoader()\n\n\nclass MetaPathLoader:\n\n    def load_module(self, fullname):\n        print('load_module {}'.format(fullname))\n        sys.modules[fullname] = sys\n        return sys\n\nsys.meta_path.insert(0, MetaPathFinder())\n\nif __name__ == '__main__':\n    import http\n    print(http)\n    print(http.version_info)\nload_module 方法返回一个 module 对象，这个对象就是 import 的 module 对象了。 比如我上面那样就把 http 替换为 sys 这个 module 了。\n$ python meta_path1.py\nfind_module http\nload_module http\n<module 'sys' (built-in)>\nsys.version_info(major=3, minor=5, micro=1, releaselevel='final', serial=0)\n通过 sys.meta_path 我们就可以实现 import hook 的功能： 当 import 预定的 module 时，对这个 module 里的对象来个狸猫换太子， 从而实现获取函数或方法的执行时间等探测信息。\n上面说到了狸猫换太子，那么怎么对一个对象进行狸猫换太子的操作呢？ 对于函数对象，我们可以使用装饰器的方式来替换函数对象(代码可以从 github 上下载 part2) :\n  \n import functools\n import time}\ndef func_wrapper(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        print('start func')\n        start = time.time()\n        result = func(*args, **kwargs)\n        end = time.time()\n        print('spent {}s'.format(end - start))\n        return result\n    return wrapper\n\n\ndef sleep(n):\n    time.sleep(n)\n    return n\n\nif __name__ == '__main__':\n    func = func_wrapper(sleep)\n    print(func(3))\n执行结果:\n$ python func_wrapper.py\nstart func\nspent 3.004966974258423s\n3\n\n下面我们来实现一个计算指定模块的指定函数的执行时间的功能(代码可以从 github 上下载 part3) 。\n假设我们的模块文件是 hello.py:\nimport time\n\n\ndef sleep(n):\n    time.sleep(n)\n    return n\n我们的 import hook 是 hook.py:\nimport functools\nimport importlib\nimport sys\nimport time\n\n_hook_modules = {'hello'}\n\n\nclass MetaPathFinder:\n\n    def find_module(self, fullname, path=None):\n        print('find_module {}'.format(fullname))\n        if fullname in _hook_modules:\n            return MetaPathLoader()\n\n\nclass MetaPathLoader:\n\n    def load_module(self, fullname):\n        print('load_module {}'.format(fullname))\n        # ``sys.modules`` 中保存的是已经导入过的 module\n        if fullname in sys.modules:\n            return sys.modules[fullname]\n\n        # 先从 sys.meta_path 中删除自定义的 finder\n        # 防止下面执行 import_module 的时候再次触发此 finder\n        # 从而出现递归调用的问题\n        finder = sys.meta_path.pop(0)\n        # 导入 module\n        module = importlib.import_module(fullname)\n\n        module_hook(fullname, module)\n\n        sys.meta_path.insert(0, finder)\n        return module\n\nsys.meta_path.insert(0, MetaPathFinder())\n\n\ndef module_hook(fullname, module):\n    if fullname == 'hello':\n        module.sleep = func_wrapper(module.sleep)\n\n\ndef func_wrapper(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        print('start func')\n        start = time.time()\n        result = func(*args, **kwargs)\n        end = time.time()\n        print('spent {}s'.format(end - start))\n        return result\n    return wrapper\n测试代码:\n>>> import hook\n>>> import hello\nfind_module hello\nload_module hello\n>>>\n>>> hello.sleep(3)\nstart func\nspent 3.0029919147491455s\n3\n>>>\n其实上面的代码已经实现了探针的基本功能。不过有一个问题就是上面的代码需要显示的 执行 import hook 操作才会注册上我们定义的 hook。\n那么有没有办法在启动 python 解释器的时候自动执行 import hook 的操作呢？ 答案就是可以通过定义 sitecustomize.py 的方式来实现这个功能。\nsitecustomize.py\n简单的说就是，python 解释器初始化的时候会自动 import PYTHONPATH 下存在的 sitecustomize 和 usercustomize 模块:\n实验项目的目录结构如下(代码可以从 github 上下载 part4) :\n$ tree\n.\n├── sitecustomize.py\n└── usercustomize.py\n\nsitecustomize.py:\n$ cat sitecustomize.py\nprint('this is sitecustomize')\n\nusercustomize.py:\n$ cat usercustomize.py\nprint('this is usercustomize')\n\n把当前目录加到 PYTHONPATH 中，然后看看效果:\n$ export PYTHONPATH=.\n$ python\nthis is sitecustomize       <----\nthis is usercustomize       <----\nPython 3.5.1 (default, Dec 24 2015, 17:20:27)\n[GCC 4.2.1 Compatible Apple LLVM 7.0.2 (clang-700.1.81)] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>>\n可以看到确实自动导入了。所以我们可以把之前的探测程序改为支持自动执行 import hook (代码可以从 github 上下载 part5) 。\n目录结构:\n$ tree\n.\n├── hello.py\n├── hook.py\n├── sitecustomize.py\n\nsitecustomize.py:\n$ cat sitecustomize.py\nimport hook\n\n结果:\n$ export PYTHONPATH=.\n$ python\nfind_module usercustomize\nPython 3.5.1 (default, Dec 24 2015, 17:20:27)\n[GCC 4.2.1 Compatible Apple LLVM 7.0.2 (clang-700.1.81)] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\nfind_module readline\nfind_module atexit\nfind_module rlcompleter\n>>>\n>>> import hello\nfind_module hello\nload_module hello\n>>>\n>>> hello.sleep(3)\nstart func\nspent 3.005002021789551s\n3\n不过上面的探测程序其实还有一个问题，那就是需要手动修改 PYTHONPATH 。 用过探针程序的朋友应该会记得， 使用 newrelic 之类的探针只需要执行一条命令就 可以了： newrelic-admin run-program python hello.py 实际上修改 PYTHONPATH 的操作是在 newrelic-admin 这个程序里完成的。\n下面我们也要来实现一个类似的命令行程序，就叫 agent.py 吧。\nagent\n还是在上一个程序的基础上修改。先调整一个目录结构，把 hook 操作放到一个单独的目录下， 方便设置 PYTHONPATH 后不会有其他的干扰（代码可以从 github 上下载 part6 ）。\n$ mkdir bootstrap\n$ mv hook.py bootstrap/_hook.py\n$ touch bootstrap/__init__.py\n$ touch agent.py\n$ tree\n.\n├── bootstrap\n│   ├── __init__.py\n│   ├── _hook.py\n│   └── sitecustomize.py\n├── hello.py\n├── test.py\n├── agent.py\n\nbootstrap/sitecustomize.py 的内容修改为:\n$ cat bootstrap/sitecustomize.py\nimport _hook\n\nagent.py 的内容如下:\nimport os\nimport sys\n\ncurrent_dir = os.path.dirname(os.path.realpath(__file__))\nboot_dir = os.path.join(current_dir, 'bootstrap')\n\n\ndef main():\n    args = sys.argv[1:]\n    os.environ['PYTHONPATH'] = boot_dir\n    # 执行后面的 python 程序命令\n    # sys.executable 是 python 解释器程序的绝对路径 ``which python``\n    # >>> sys.executable\n    # '/usr/local/var/pyenv/versions/3.5.1/bin/python3.5'\n    os.execl(sys.executable, sys.executable, *args)\n\nif __name__ == '__main__':\n    main()\ntest.py 的内容为:\n$ cat test.py\nimport sys\nimport hello\n\nprint(sys.argv)\nprint(hello.sleep(3))\n\n使用方法:\n$ python agent.py test.py arg1 arg2\nfind_module usercustomize\nfind_module hello\nload_module hello\n['test.py', 'arg1', 'arg2']\nstart func\nspent 3.005035161972046s\n3\n\n至此，我们就实现了一个简单的 python 探针程序。当然，跟实际使用的探针程序相比肯定是有 很大的差距的，这篇文章主要是讲解一下探针背后的实现原理。\n如果大家对商用探针程序的具体实现感兴趣的话，可以看一下国外的 New Relic 或国内的 OneAPM, 听云 等这些 APM 厂商的商用 python 探针的源代码。\nP.S. 本文首发于 我的博客 ;)P.S. 本文涉及的代码可以从 Github 上获取 ;)\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "11"}