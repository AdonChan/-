{"title": "Python数据结构——栈 - Geek情怀 ", "index": "栈,数据结构与算法,python", "content": "栈是一种特殊的列表，栈内的元素只能通过列表的一端访问，这一端称为栈顶。咖啡厅内的一摞盘子是现实世界中常见的栈的例子。只能从最上面取盘子，盘子洗净后，也只能摞在这一摞盘子的最上面。栈被称为一种后入先出（LIFO，last-in-first-out）的数据结构。\n由于栈具有后入先出的特点，所以任何不在栈顶的元素都无法访问。为了得到栈底的元素，必须先拿掉上面的元素。\n对栈的两种主要操作是将一个元素压入栈和将一个元素弹出栈。入栈使用push()方法，出栈使用pop()方法。下图演示了入栈和出栈的过程。\n\n另一个常用的操作是预览栈顶的元素。pop()方法虽然可以访问栈顶的元素，但是调用该方法后，栈顶元素也从栈中被永久性地删除了。peek()方法则只返回栈顶元素，而不删除它。\n为了记录栈顶元素的位置，同时也为了标记哪里可以加入新元素，我们使用变量top，当向栈内压入元素时，该变量增大；从栈内弹出元素时，该变量减小。\npush()、pop()和peek()是栈的3个主要方法，但是栈还有其他方法和属性。\nstack通常的操作：\nStack()    建立一个空的栈对象\npush()     把一个元素添加到栈的最顶层\npop()      删除栈最顶层的元素，并返回这个元素\npeek()     返回最顶层的元素，并不删除它\nisEmpty()  判断栈是否为空\nsize()     返回栈中元素的个数\n\n简单案例以及操作结果：\n\n\nStack Operation\nStack Contents\nReturn Value\n\n\n\ns.isEmpty()\n[]\nTrue\n\n\ns.push(4)\n[4]\n \n\n\ns.push('dog')\n[4,'dog']\n \n\n\ns.peek()\n[4,'dog']\n'dog'\n\n\ns.push(True)\n[4,'dog',True]\n \n\n\ns.size()\n[4,'dog',True]\n3\n\n\ns.isEmpty()\n[4,'dog',True]\nFalse\n\n\ns.push(8.4)\n[4,'dog',True,8.4]\n \n\n\ns.pop()\n[4,'dog',True]\n8.4\n\n\ns.pop()\n[4,'dog']\nTrue\n\n\ns.size()\n[4,'dog']\n2\n\n\n\n这里使用python的list对象模拟栈的实现：\nclass Stack: \n    \"\"\"模拟栈\"\"\" \n    def __init__(self): \n        self.items = [] \n\n    def isEmpty(self): \n        return len(self.items)==0  \n\n    def push(self, item): \n        self.items.append(item) \n\n    def pop(self): \n        return self.items.pop()  \n\n    def peek(self): \n        if not self.isEmpty(): \n            return self.items[len(self.items)-1] \n\n    def size(self): \n        return len(self.items) \n\n创建一个栈对象，并加入操作方法：\ns=Stack() \nprint(s.isEmpty()) \ns.push(4) \ns.push('dog') \nprint(s.peek()) \ns.push(True) \nprint(s.size()) \nprint(s.isEmpty()) \ns.push(8.4) \nprint(s.pop()) \nprint(s.pop()) \nprint(s.size()) \n\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "14"}