{"title": "Python 3 入门，看这篇就够了 - 格物 ", "index": "python", "content": "简介\nPython 是一种高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。Python 由 Guido van Rossum 于 1989 年底在荷兰国家数学和计算机科学研究所发明，第一个公开发行版发行于 1991 年。\n特点\n\n\n易于学习：Python 有相对较少的关键字，结构简单，和一个明确定义的语法，学习起来更加简单。\n\n易于阅读：Python 代码定义的更清晰。\n\n易于维护：Python 的成功在于它的源代码是相当容易维护的。\n\n一个广泛的标准库：Python 的最大的优势之一是丰富的库，跨平台的，在 UNIX，Windows 和 macOS 兼容很好。\n\n互动模式：互动模式的支持，您可以从终端输入执行代码并获得结果的语言，互动的测试和调试代码片断。\n\n可移植：基于其开放源代码的特性，Python 已经被移植（也就是使其工作）到许多平台。\n\n可扩展：如果你需要一段运行很快的关键代码，或者是想要编写一些不愿开放的算法，你可以使用 C 或 C++ 完成那部分程序，然后从你的 Python 程序中调用。\n\n数据库：Python 提供所有主要的商业数据库的接口。\n\nGUI 编程：Python 支持 GUI 可以创建和移植到许多系统调用。\n\n可嵌入：你可以将 Python 嵌入到 C/C++ 程序，让你的程序的用户获得\"脚本化\"的能力。\n\n面向对象：Python 是强面向对象的语言，程序中任何内容统称为对象，包括数字、字符串、函数等。\n\n基础语法\n运行 Python\n交互式解释器\n在命令行窗口执行python后，进入 Python 的交互式解释器。exit() 或 Ctrl + D 组合键退出交互式解释器。\n命令行脚本\n在命令行窗口执行python script-file.py，以执行 Python 脚本文件。\n指定解释器\n如果在 Python 脚本文件首行输入#!/usr/bin/env python，那么可以在命令行窗口中执行/path/to/script-file.py以执行该脚本文件。\n注：该方法不支持 Windows 环境。\n编码\n默认情况下，3.x 源码文件都是 UTF-8 编码，字符串都是 Unicode 字符。也可以手动指定文件编码：\n# -*- coding: utf-8 -*-\n或者\n# encoding: utf-8\n注意: 该行标注必须位于文件第一行\n标识符\n\n第一个字符必须是英文字母或下划线 _ 。\n标识符的其他的部分由字母、数字和下划线组成。\n标识符对大小写敏感。\n\n注：从 3.x 开始，非 ASCII 标识符也是允许的，但不建议。\n保留字\n保留字即关键字，我们不能把它们用作任何标识符名称。Python 的标准库提供了一个 keyword 模块，可以输出当前版本的所有关键字：\n>>> import keyword\n>>> keyword.kwlist\n['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']\n注释\n单行注释采用#，多行注释采用'''或\"\"\"。\n# 这是单行注释\n\n'''\n这是多行注释\n\n这是多行注释\n'''\n\n\"\"\"\n这也是多行注释\n\n这也是多行注释\n\"\"\"\n行与缩进\nPython 最具特色的就是使用缩进来表示代码块，不需要使用大括号 {}。缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。缩进不一致，会导致运行错误。\n多行语句\nPython 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠\\来实现多行语句。\ntotal = item_one + \\\n        item_two + \\\n        item_three\n在 [], {}, 或 () 中的多行语句，不需要使用反斜杠\\。\n空行\n函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。\n空行与代码缩进不同，空行并不是 Python 语法的一部分。书写时不插入空行，Python 解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。\n记住：空行也是程序代码的一部分。\n等待用户输入\ninput函数可以实现等待并接收命令行中的用户输入。\ncontent = input(\"\\n\\n请输入点东西并按 Enter 键\\n\")\nprint(content)\n同一行写多条语句\nPython 可以在同一行中使用多条语句，语句之间使用分号;分割。\nimport sys; x = 'hello world'; sys.stdout.write(x + '\\n')\n多个语句构成代码组\n缩进相同的一组语句构成一个代码块，我们称之代码组。\n像if、while、def和class这样的复合语句，首行以关键字开始，以冒号:结束，该行之后的一行或多行代码构成代码组。\n我们将首行及后面的代码组称为一个子句(clause)。\nprint 输出\nprint 默认输出是换行的，如果要实现不换行需要在变量末尾加上end=\"\"或别的非换行符字符串：\nprint('123') # 默认换行\nprint('123', end = \"\") # 不换行\nimport 与 from...import\n在 Python 用 import 或者 from...import 来导入相应的模块。\n将整个模块导入，格式为：import module_name\n从某个模块中导入某个函数,格式为：from module_name import func1\n从某个模块中导入多个函数,格式为：from module_name import func1, func2, func3\n将某个模块中的全部函数导入，格式为：from module_name import *\n运算符\n算术运算符\n\n\n运算符\n描述\n\n\n\n+\n加\n\n\n-\n减\n\n\n*\n乘\n\n\n/\n除\n\n\n%\n取模\n\n\n**\n幂\n\n\n//\n取整除\n\n\n\n比较运算符\n\n\n运算符\n描述\n\n\n\n==\n等于\n\n\n!=\n不等于\n\n\n>\n大于\n\n\n<\n小于\n\n\n>=\n大于等于\n\n\n<=\n小于等于\n\n\n\n赋值运算符\n\n\n运算符\n描述\n\n\n\n=\n简单的赋值运算符\n\n\n+=\n加法赋值运算符\n\n\n-=\n减法赋值运算符\n\n\n*=\n乘法赋值运算符\n\n\n/=\n除法赋值运算符\n\n\n%=\n取模赋值运算符\n\n\n**=\n幂赋值运算符\n\n\n//=\n取整除赋值运算符\n\n\n\n位运算符\n\n\n运算符\n描述\n\n\n\n&\n按位与运算符：参与运算的两个值,如果两个相应位都为1，则该位的结果为1，否则为0\n\n\n\\\n \n按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1\n\n\n^\n按位异或运算符：当两对应的二进位相异时，结果为1\n\n\n~\n按位取反运算符：对数据的每个二进制位取反，即把1变为0，把0变为1。~x 类似于 -x-1\n\n\n<<\n左移动运算符：运算数的各二进位全部左移若干位，由\"<<\"右边的数指定移动的位数，高位丢弃，低位补0\n\n\n>>\n右移动运算符：把\">>\"左边的运算数的各二进位全部右移若干位，\">>\"右边的数指定移动的位数\n\n\n\n逻辑运算符\n\n\n运算符\n逻辑表达式\n描述\n\n\n\nand\nx and y\n布尔\"与\" - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值\n\n\nor\nx or y\n布尔\"或\" - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值\n\n\nnot\nnot x\n布尔\"非\" - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True\n\n\n\n成员运算符\n\n\n运算符\n描述\n\n\n\nin\n如果在指定的序列中找到值返回 True，否则返回 False\n\n\nnot in\n如果在指定的序列中没有找到值返回 True，否则返回 False\n\n\n\n身份运算符\n\n\n运算符\n描述\n实例\n\n\n\nis\nis 是判断两个标识符是不是引用自一个对象\nx is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False\n\n\nis not\nis not 是判断两个标识符是不是引用自不同对象\nx is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False\n\n\n\n运算符优先级\n\n\n运算符\n描述\n\n\n\n\n(expressions...), [expressions...], {key: value...}, {expressions...}\n\n表示绑定或元组、表示列表、表示字典、表示集合\n\n\n\nx[index], x[index:index], x(arguments...), x.attribute\n\n下标、切片、调用、属性引用\n\n\n**\n指数 (最高优先级)\n\n\n\n~ + -\n\n按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)\n\n\n\n* / % //\n\n乘，除，取模和取整除\n\n\n\n+ -\n\n加法减法\n\n\n\n>> <<\n\n右移，左移运算符\n\n\n&\n位 'AND'\n\n\n\n^ `\n`\n位运算符\n\n\n\n<= < > >=\n\n比较运算符\n\n\n\n<> == !=\n\n等于运算符\n\n\n\n= %= /= //= -= += *= **=\n\n赋值运算符\n\n\n\nis is not\n\n身份运算符\n\n\n\nin not in\n\n成员运算符\n\n\n\nand or not\n\n逻辑运算符\n\n\nif - else\n条件表达式\n\n\nlambda\nLambda 表达式\n\n\n\n具有相同优先级的运算符将从左至右的方式依次进行。用小括号()可以改变运算顺序。\n变量\n变量在使用前必须先\"定义\"（即赋予变量一个值），否则会报错：\n>>> name\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nNameError: name 'name' is not defined\n数据类型\n布尔(bool)\n只有 True 和 False 两个值，表示真或假。\n数字(number)\n整型(int)\n整数值，可正数亦可复数，无小数。3.x 整型是没有限制大小的，可以当作 Long 类型使用，所以 3.x 没有 2.x 的 Long 类型。\n浮点型(float)\n浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 10^2 = 250）\n复数(complex)\n复数由实数部分和虚数部分构成，可以用a + bj，或者complex(a,b)表示，复数的实部 a 和虚部 b 都是浮点型。\n数字运算\n\n不同类型的数字混合运算时会将整数转换为浮点数\n在不同的机器上浮点运算的结果可能会不一样\n在整数除法中，除法 / 总是返回一个浮点数，如果只想得到整数的结果，丢弃可能的分数部分，可以使用运算符 //。\n\n// 得到的并不一定是整数类型的数，它与分母分子的数据类型有关系\n在交互模式中，最后被输出的表达式结果被赋值给变量 _，_ 是个只读变量\n\n数学函数\n注：以下函数的使用，需先导入 math 包。\n\n\n函数\n描述\n\n\n\nabs(x)\n返回数字的整型绝对值，如 abs(-10) 返回 10\n\n\nceil(x)\n返回数字的上入整数，如 math.ceil(4.1) 返回 5\n\n\ncmp(x, y)\n如果 x < y 返回 -1，如果 x == y 返回 0，如果 x > y 返回 1。Python 3 已废弃 。使用 使用 (x>y)-(x<y) 替换。\n\n\nexp(x)\n返回 e 的 x 次幂(ex)，如 math.exp(1) 返回2.718281828459045\n\n\nfabs(x)\n返回数字的浮点数绝对值，如 math.fabs(-10) 返回10.0\n\n\nfloor(x)\n返回数字的下舍整数，如 math.floor(4.9) 返回 4\n\n\nlog(x)\n如 math.log(math.e) 返回 1.0，math.log(100,10) 返回 2.0\n\n\nlog10(x)\n返回以 10 为基数的 x 的对数，如 math.log10(100) 返回 2.0\n\n\nmax(x1, x2,...)\n返回给定参数的最大值，参数可以为序列\n\n\nmin(x1, x2,...)\n返回给定参数的最小值，参数可以为序列\n\n\nmodf(x)\n返回 x 的整数部分与小数部分，两部分的数值符号与 x 相同，整数部分以浮点型表示\n\n\npow(x, y)\n幂等函数， x**y 运算后的值\n\n\nround(x [,n])\n返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数\n\n\nsqrt(x)\n返回数字 x 的平方根\n\n\n\n随机数函数\n注：以下函数的使用，需先导入 random 包。\n\n\n函数\n描述\n\n\n\nchoice(seq)\n从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数\n\n\nrandrange ([start,] stop [,step])\n从指定范围内，按指定基数递增的集合中获取一个随机数，基数缺省值为1\n\n\nrandom()\n随机生成下一个实数，它在[0,1)范围内\n\n\nseed([x])\n改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed\n\n\nshuffle(lst)\n将序列的所有元素随机排序\n\n\nuniform(x, y)\n随机生成下一个实数，它在[x,y]范围内\n\n\n\n三角函数\n注：以下函数的使用，需先导入 math 包。\n\n\n函数\n描述\n\n\n\nacos(x)\n返回 x 的反余弦弧度值\n\n\nasin(x)\n返回 x 的反正弦弧度值\n\n\natan(x)\n返回 x 的反正切弧度值\n\n\natan2(y, x)\n返回给定的 X 及 Y 坐标值的反正切值\n\n\ncos(x)\n返回 x 的弧度的余弦值\n\n\nhypot(x, y)\n返回欧几里德范数 sqrt(x*x + y*y)\n\n\n\nsin(x)\n返回的 x 弧度的正弦值\n\n\ntan(x)\n返回 x 弧度的正切值\n\n\ndegrees(x)\n将弧度转换为角度，如 degrees(math.pi/2) 返回 90.0\n\n\nradians(x)\n将角度转换为弧度\n\n\n\n数学常量\n\n\n常量\n描述\n\n\n\npi\n数学常量 pi（圆周率，一般以π来表示）\n\n\ne\n数学常量 e，e 即自然常数（自然常数）\n\n\n\n字符串(string)\n\n单引号和双引号使用完全相同\n使用三引号('''或\"\"\")可以指定一个多行字符串\n转义符(反斜杠\\)可以用来转义，使用r可以让反斜杠不发生转义，如r\"this is a line with \\n\"，则\\n会显示，并不是换行\n按字面意义级联字符串，如\"this \" \"is \" \"string\"会被自动转换为this is string\n\n字符串可以用 + 运算符连接在一起，用 * 运算符重复\n字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始\n字符串不能改变\n没有单独的字符类型，一个字符就是长度为 1 的字符串\n字符串的截取的语法格式如下：变量[头下标:尾下标]\n\n\n转义字符\n\n\n转义字符\n描述\n\n\n\n\\\n在行尾时，续行符\n\n\n\\\\\n反斜杠符号\n\n\n\\'\n单引号\n\n\n\\\"\n双引号\n\n\na\n响铃\n\n\nb\n退格(Backspace)\n\n\ne\n转义\n\n\n000\n空\n\n\nn\n换行\n\n\nv\n纵向制表符\n\n\nt\n横向制表符\n\n\nr\n回车\n\n\nf\n换页\n\n\noyy\n八进制数，yy代表字符，例如：o12代表换行\n\n\nxyy\n十六进制数，yy代表字符，例如：x0a代表换行\n\n\nother\n其它的字符以普通格式输出\n\n\n\n字符串运算符\n\n\n操作符\n描述\n实例\n\n\n\n+\n字符串连接\n\n'Hello' + 'Python' 输出结果：'HelloPython'\n\n\n*\n重复输出字符串\n\n'Hello' * 2 输出结果：'HelloHello'\n\n\n[]\n通过索引获取字符串中字符\n\n'Hello'[1] 输出结果 e\n\n\n[ : ]\n截取字符串中的一部分\n\n'Hello'[1:4] 输出结果 ell\n\n\nin\n成员运算符，如果字符串中包含给定的字符返回 True\n\n'H' in 'Hello' 输出结果 True\n\n\nnot in\n成员运算符，如果字符串中不包含给定的字符返回 True\n\n'M' not in 'Hello' 输出结果 True\n\n\nr/R\n原始字符串，所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母 r（可以大小写）以外，与普通字符串有着几乎完全相同的语法\n\nprint(r'\\n') 或 print(R'\\n')\n\n\n\n%\n格式化字符串\n \n\n\n\n字符串格式化\n在 Python 中，字符串格式化不是 sprintf 函数，而是用 % 符号。例如：\nprint(\"我叫%s， 今年 %d 岁！\" % ('小明', 10))\n\n// 输出:\n我叫小明， 今年 10 岁！\n格式化符号:\n\n\n符号\n描述\n\n\n\n%c\n格式化字符及其 ASCII 码\n\n\n%s\n格式化字符串\n\n\n%d\n格式化整数\n\n\n%u\n格式化无符号整型\n\n\n%o\n格式化无符号八进制数\n\n\n%x\n格式化无符号十六进制数\n\n\n%X\n格式化无符号十六进制数（大写）\n\n\n%f\n格式化浮点数字，可指定小数点后的精度\n\n\n%e\n用科学计数法格式化浮点数\n\n\n%E\n作用同 %e，用科学计数法格式化浮点数\n\n\n%g\n%f 和 %e 的简写\n\n\n%G\n%f 和 %E 的简写\n\n\n%p\n用十六进制数格式化变量的地址\n\n\n\n辅助指令:\n\n\n指令\n描述\n\n\n\n*\n定义宽度或者小数点精度\n\n\n-\n用做左对齐\n\n\n+\n在正数前面显示加号\n\n\n<sp>\n在正数前面显示空格\n\n\n#\n在八进制数前面显示零('0')，在十六进制前面显示'0x'或者'0X'(取决于用的是'x'还是'X')\n\n\n0\n显示的数字前面填充'0'而不是默认的空格\n\n\n%\n'%%'输出一个单一的'%'\n\n\n(var)\n映射变量(字典参数)\n\n\nm.n.\nm 是显示的最小总宽度，n 是小数点后的位数(如果可用的话)\n\n\n\nPython 2.6 开始，新增了一种格式化字符串的函数 str.format()，它增强了字符串格式化的功能。\n多行字符串\n\n用三引号(''' 或 \"\"\")包裹字符串内容\n多行字符串内容支持转义符，用法与单双引号一样\n三引号包裹的内容，有变量接收或操作即字符串，否则就是多行注释\n\n实例：\nstring = '''\nprint(\\tmath.fabs(-10))\n\nprint(\\nrandom.choice(li))\n'''\n\nprint(string)\n输出：\nprint(  math.fabs(-10))\n\nprint(\nrandom.choice(li))\nUnicode\n在 2.x 中，普通字符串是以 8 位 ASCII 码进行存储的，而 Unicode 字符串则存储为 16 位 Unicode 字符串，这样能够表示更多的字符集。使用的语法是在字符串前面加上前缀 u。\n在 3.x 中，所有的字符串都是 Unicode 字符串。\n字符串函数\n\n\n方法名\n描述\n\n\n\nstr.capitalize()\n首字母大写，其余字符小写\n\n\nstr.center(width[, fillchar])\n返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格\n\n\nstr.count(sub, start= 0,end=len(string))\n统计子字符串在字符串中出现的次数\n\n\nstr.encode(encoding='UTF-8',errors='strict')\n以指定的编码格式编码字符串，返回 bytes 对象\n\n\nbytes.decode(encoding=\"utf-8\", errors=\"strict\")\n以指定的编码格式解码 bytes 对象，返回字符串\n\n\nstr.endswith(suffix[, start[, end]])\n判断字符串是否以指定后缀结尾\n\n\nstr.expandtabs(tabsize=8)\n把字符串中的 tab 符号(\\t)转为空格\n\n\nstr.find(str, beg=0, end=len(string))\n如果包含子字符串返回开始的索引值，否则返回-1\n\n\nstr.index(str, beg=0, end=len(string))\n如果包含子字符串返回开始的索引值，否则抛出异常\n\n\nstr.isalnum()\n检测字符串是否只由字母和数字组成\n\n\nstr.isalpha()\n检测字符串是否只由字母组成\n\n\nstr.isdigit()\n检测字符串是否只由数字组成\n\n\nstr.islower()\n如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False\n\n\nstr.isupper()\n检测字符串中所有的字母是否都为大写\n\n\nstr.isspace()\n如果字符串中只包含空格，则返回 True，否则返回 False\n\n\nstr.istitle()\n检测字符串中所有的单词拼写首字母是否为大写，且其他字母为小写\n\n\nstr.join(sequence)\n将序列的元素以指定的字符连接生成一个新的字符串\n\n\nlen(s)\n返回对象（字符串、列表、元组等）长度或项目个数\n\n\nstr.ljust(width[, fillchar])\n返回一个原字符串左对齐,并使用空格填充至指定长度的新字符串。如果指定的长度小于原字符串的长度则返回原字符串\n\n\nstr.lower()\n转换字符串中所有大写字符为小写\n\n\nstr.upper()\n转换字符串中所有小写字符为大写\n\n\nstr.strip([chars])\n移除字符串头尾指定的字符（默认为空格）或字符序列\n\n\nstr.maketrans(intab, outtab)\n用于创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。两个字符串的长度必须相同，为一一对应的关系。\n\n\nstr.translate(table)\n根据参数table给出的表转换字符串的字符\n\n\nmax(str)\n返回字符串中最大的字符\n\n\nmin(str)\n返回字符串中最小的字符\n\n\nstr.replace(old, new[, max])\n把字符串中的 old（旧字符串） 替换成 new(新字符串)，如果指定第三个参数max，则替换不超过 max 次\n\n\nstr.split(str=\"\", num=string.count(str))\n通过指定分隔符对字符串进行切片，如果参数 num 有指定值，则仅分隔 num 个子字符串\n\n\nstr.splitlines([keepends])\n按照行('r', 'rn', n')分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符\n\n\nstr.startswith(str, beg=0,end=len(string))\n检查字符串是否是以指定子字符串开头\n\n\nstr.swapcase()\n对字符串的大小写字母进行互换\n\n\nstr.title()\n返回\"标题化\"的字符串，即所有单词都是以大写开始，其余字母均为小写\n\n\nstr.zfill(width)\n返回指定长度的字符串，原字符串右对齐，前面填充0\n\n\nstr.isdecimal()\n检查字符串是否只包含十进制字符，只适用于 Unicode 对象\n\n\n\n字节(bytes)\n在 3.x 中，字符串和二进制数据完全区分开。文本总是 Unicode，由 str 类型表示，二进制数据则由 bytes 类型表示。Python 3 不会以任意隐式的方式混用 str 和 bytes，你不能拼接字符串和字节流，也无法在字节流里搜索字符串（反之亦然），也不能将字符串传入参数为字节流的函数（反之亦然）。\n\nbytes 类型与 str 类型，二者的方法仅有 encode() 和 decode() 不同。\nbytes 类型数据需在常规的 str 类型前加个 b 以示区分，例如 b'abc'。\n只有在需要将 str 编码(encode)成 bytes 的时候，比如：通过网络传输数据；或者需要将 bytes 解码(decode)成 str 的时候，我们才会关注 str 和 bytes 的区别。\n\nbytes 转 str：\nb'abc'.decode()\nstr(b'abc')\nstr(b'abc', encoding='utf-8')\nstr 转 bytes：\n'中国'.encode()\n\nbytes('中国', encoding='utf-8')\n列表(list)\n\n列表是一种无序的、可重复的数据序列，可以随时添加、删除其中的元素。\n列表页的每个元素都分配一个数字索引，从 0 开始\n列表使用方括号创建，使用逗号分隔元素\n列表元素值可以是任意类型，包括变量\n使用方括号对列表进行元素访问、切片、修改、删除等操作，开闭合区间为[)形式\n列表的元素访问可以嵌套\n方括号内可以是任意表达式\n\n创建列表\nhello = (1, 2, 3)\nli = [1, \"2\", [3, 'a'], (1, 3), hello]\n访问元素\nli = [1, \"2\", [3, 'a'], (1, 3)]\nprint(li[3])        # (1, 3)\nprint(li[-2])       # [3, 'a']\n切片访问\n格式: list_name[begin:end:step]begin 表示起始位置(默认为0)，end 表示结束位置(默认为最后一个元素)，step 表示步长(默认为1)\nhello = (1, 2, 3)\nli = [1, \"2\", [3, 'a'], (1, 3), hello]\n\nprint(li)           # [1, '2', [3, 'a'], (1, 3), (1, 2, 3)]\nprint(li[1:2])      # ['2']\nprint(li[:2])       # [1, '2']\nprint(li[:])        # [1, '2', [3, 'a'], (1, 3), (1, 2, 3)]\nprint(li[2:])       # [[3, 'a'], (1, 3), (1, 2, 3)]\nprint(li[1:-1:2])   # ['2', (1, 3)]\n访问内嵌 list 的元素：\nli = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ['a', 'b', 'c']]\n\nprint(li[1:-1:2][1:3])      # (3, 5)\nprint(li[-1][1:3])          # ['b', 'c']\nprint(li[-1][1])            # b\n修改列表\n通过使用方括号，可以非常灵活的对列表的元素进行修改、替换、删除等操作。\nli = [0, 1, 2, 3, 4, 5]\n\nli[len(li) - 2] = 22    # 修改 [0, 1, 2, 22, 4, 5]\nli[3] = 33              # 修改 [0, 1, 2, 33, 4, 5]\nli[1:-1] = [9, 9]       # 替换 [0, 9, 9, 5]\nli[1:-1] = []           # 删除 [0, 5]\n删除元素\n可以用 del 语句来删除列表的指定范围的元素。\nli = [0, 1, 2, 3, 4, 5]\n\ndel li[3]       # [0, 1, 2, 4, 5]\ndel li[2:-1]    # [0, 1, 5]\n列表操作符\n\n\n+ 用于合并列表\n\n* 用于重复列表元素\n\nin 用于判断元素是否存在于列表中\n\nfor ... in ... 用于遍历列表元素\n\n[1, 2, 3] + [3, 4, 5]           # [1, 2, 3, 3, 4, 5]\n[1, 2, 3] * 2                   # [1, 2, 3, 1, 2, 3]\n3 in [1, 2, 3]                  # True\nfor x in [1, 2, 3]: print(x)    # 1 2 3\n列表函数\n\n\nlen(list) 列表元素个数\n\nmax(list) 列表元素中的最大值\n\nmin(list) 列表元素中的最小值\n\nlist(seq) 将元组转换为列表\n\nli = [0, 1, 5]\n\nmax(li)     # 5\nlen(li)     # 3\n注: 对列表使用 max/min 函数，2.x 中对元素值类型无要求，3.x 则要求元素值类型必须一致。\n列表方法\n\nlist.append(obj)在列表末尾添加新的对象\n\nlist.count(obj)返回元素在列表中出现的次数\n\nlist.extend(seq)在列表末尾一次性追加另一个序列中的多个值\n\nlist.index(obj)返回查找对象的索引位置，如果没有找到对象则抛出异常\n\nlist.insert(index, obj)将指定对象插入列表的指定位置\n\nlist.pop([index=-1]])移除列表中的一个元素（默认最后一个元素），并且返回该元素的值\n\nlist.remove(obj)移除列表中某个值的第一个匹配项\n\nlist.reverse()反向排序列表的元素\n\nlist.sort(cmp=None, key=None, reverse=False)对原列表进行排序，如果指定参数，则使用比较函数指定的比较函数\n\nlist.clear()清空列表还可以使用 del list[:]、li = [] 等方式实现\n\nlist.copy()复制列表默认使用等号赋值给另一个变量，实际上是引用列表变量。如果要实现\n\n\n列表推导式\n列表推导式提供了从序列创建列表的简单途径。通常应用程序将一些操作应用于某个序列的每个元素，用其获得的结果作为生成新列表的元素，或者根据确定的判定条件创建子序列。\n每个列表推导式都在 for 之后跟一个表达式，然后有零到多个 for 或 if 子句。返回结果是一个根据表达从其后的 for 和 if 上下文环境中生成出来的列表。如果希望表达式推导出一个元组，就必须使用括号。\n将列表中每个数值乘三，获得一个新的列表：\nvec = [2, 4, 6]\n[(x, x**2) for x in vec]\n\n# [(2, 4), (4, 16), (6, 36)]\n对序列里每一个元素逐个调用某方法：\nfreshfruit = ['  banana', '  loganberry ', 'passion fruit  ']\n[weapon.strip() for weapon in freshfruit]\n\n# ['banana', 'loganberry', 'passion fruit']\n用 if 子句作为过滤器：\nvec = [2, 4, 6]\n[3*x for x in vec if x > 3]\n\n# [12, 18]\nvec1 = [2, 4, 6]\nvec2 = [4, 3, -9]\n\n[x*y for x in vec1 for y in vec2]\n# [8, 6, -18, 16, 12, -36, 24, 18, -54]\n\n[vec1[i]*vec2[i] for i in range(len(vec1))]\n# [8, 12, -54]\n列表嵌套解析：\nmatrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9],\n]\n\nnew_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\nprint(new_matrix)\n\n# [[1, 4, 7], [2, 5, 8], [3, 6, 9]]\n元组(tuple)\n\n元组与列表类似，不同之处在于元组的元素不能修改\n元组使用小括号，列表使用方括号\n元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可\n没有 append()，insert() 这样进行修改的方法，其他方法都与列表一样\n字典中的键必须是唯一的同时不可变的，值则没有限制\n元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符使用\n\n访问元组\n访问元组的方式与列表是一致的。元组的元素可以直接赋值给多个变量，但变量数必须与元素数量一致。\na, b, c = (1, 2, 3)\nprint(a, b, c)\n组合元组\n元组中的元素值是不允许修改的，但我们可以对元组进行连接组合\ntup1 = (12, 34.56);\ntup2 = ('abc', 'xyz')\ntup3 = tup1 + tup2;\nprint (tup3)\n\n# (12, 34.56, 'abc', 'xyz')\n删除元组\n元组中的元素值是不允许删除的，但我们可以使用 del 语句来删除整个元组\n元组函数\n\n\nlen(tuple) 元组元素个数\n\nmax(tuple) 元组元素中的最大值\n\nmin(tuple) 元组元素中的最小值\n\ntuple(tuple) 将列表转换为元组\n\n元组推导式\nt = 1, 2, 3\nprint(t)\n# (1, 2, 3)\n\nu = t, (3, 4, 5)\nprint(u)\n# ((1, 2, 3), (3, 4, 5))\n字典(dict)\n\n字典是另一种可变容器模型，可存储任意类型对象\n字典的每个键值(key=>value)对用冒号(:)分割，每个对之间用逗号(,)分割，整个字典包括在花括号({})中\n键必须是唯一的，但值则不必\n值可以是任意数据类型\n键必须是不可变的，例如：数字、字符串、元组可以，但列表就不行\n如果用字典里没有的键访问数据，会报错\n字典的元素没有顺序，不能通过下标引用元素，通过键来引用\n字典内部存放的顺序和 key 放入的顺序是没有关系的\n\n格式如下:\nd = {key1 : value1, key2 : value2 }\n访问字典\ndis = {'a': 1, 'b': [1, 2, 3]}\n\nprint(dis['b'][2])\n修改字典\ndis = {'a': 1, 'b': [1, 2, 3], 9: {'name': 'hello'}}\n\ndis[9]['name'] = 999\nprint(dis)\n\n# {'a': 1, 9: {'name': 999}, 'b': [1, 2, 3]}\n删除字典\n用 del 语句删除字典或字典的元素。\ndis = {'a': 1, 'b': [1, 2, 3], 9: {'name': 'hello'}}\n\ndel dis[9]['name']\nprint(dis)\n\ndel dis         # 删除字典\n\n# {'a': 1, 9: {}, 'b': [1, 2, 3]}\n字典函数\n\n\nlen(dict) 计算字典元素个数，即键的总数\n\nstr(dict) 输出字典，以可打印的字符串表示\n\ntype(variable) 返回输入的变量类型，如果变量是字典就返回字典类型\n\nkey in dict 判断键是否存在于字典中\n\n字典方法\n\ndict.clear()删除字典内所有元素\n\ndict.copy()返回一个字典的浅复制\n\ndict.fromkeys(seq[, value])创建一个新字典，以序列 seq 中元素做字典的键，value 为字典所有键对应的初始值\n\ndict.get(key, default=None)返回指定键的值，如果值不在字典中返回默认值\n\ndict.items()以列表形式返回可遍历的(键, 值)元组数组\n\ndict.keys()以列表返回一个字典所有的键\n\ndict.values()以列表返回字典中的所有值\n\ndict.setdefault(key, default=None)如果 key 在字典中，返回对应的值。如果不在字典中，则插入 key 及设置的默认值 default，并返回 default ，default 默认值为 None。\n\n\ndict.update(dict2)\n把字典参数 dict2 的键/值对更新到字典 dict 里\ndic1 = {'a': 'a'}\ndic2 = {9: 9, 'a': 'b'}\ndic1.update(dic2)\nprint(dic1)\n\n# {'a': 'b', 9: 9}\n\ndict.pop(key[,default])删除字典给定键 key 所对应的值，返回值为被删除的值。key 值必须给出，否则返回 default 值。\n\ndict.popitem()随机返回并删除字典中的一对键和值(一般删除末尾对)\n\n\n字典推导式\n构造函数 dict() 直接从键值对元组列表中构建字典。如果有固定的模式，列表推导式指定特定的键值对：\n>>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])\n{'sape': 4139, 'jack': 4098, 'guido': 4127}\n此外，字典推导可以用来创建任意键和值的表达式词典：\n>>> {x: x**2 for x in (2, 4, 6)}\n{2: 4, 4: 16, 6: 36}\n如果关键字只是简单的字符串，使用关键字参数指定键值对有时候更方便：\n>>> dict(sape=4139, guido=4127, jack=4098)\n{'sape': 4139, 'jack': 4098, 'guido': 4127}\n集合(set)\n集合是一个无序不重复元素的序列\n创建集合\n\n可以使用大括号 {} 或者 set() 函数创建集合\n创建一个空集合必须用 set() 而不是 {}，因为 {} 是用来创建一个空字典\n\nset(value) 方式创建集合，value 可以是字符串、列表、元组、字典等序列类型\n创建、添加、修改等操作，集合会自动去重\n\n{1, 2, 1, 3}            # {} {1, 2, 3}\nset('12345')            # 字符串 {'3', '5', '4', '2', '1'}\nset([1, 'a', 23.4])     # 列表 {1, 'a', 23.4}\nset((1, 'a', 23.4))     # 元组 {1, 'a', 23.4}\nset({1:1, 'b': 9})      # 字典 {1, 'b'}\n添加元素\n将元素 val 添加到集合 set 中，如果元素已存在，则不进行任何操作：\nset.add(val)\n也可以用 update 方法批量添加元素，参数可以是列表，元组，字典等：\nset.update(list1, list2,...)\n移除元素\n如果存在元素 val 则移除，不存在就报错：\nset.remove(val)\n如果存在元素 val 则移除，不存在也不会报错：\nset.discard(val)\n随机移除一个元素：\nset.pop()\n元素个数\n与其他序列一样，可以用 len(set) 获取集合的元素个数。\n清空集合\nset.clear()\n\nset = set()\n判断元素是否存在\nval in set\n其他方法\n\nset.copy()复制集合\n\nset.difference(set2)求差集，在 set 中却不在 set2 中\n\nset.intersection(set2)求交集，同时存在于 set 和 set2 中\n\nset.union(set2)求并集，所有 set 和 set2 的元素\n\nset.symmetric_difference(set2)求对称差集，不同时出现在两个集合中的元素\n\nset.isdisjoint(set2)如果两个集合没有相同的元素，返回 True\n\nset.issubset(set2)如果 set 是 set2 的一个子集，返回 True\n\nset.issuperset(set2)如果 set 是 set2 的一个超集，返回 True\n\n\n集合计算\na = set('abracadabra')\nb = set('alacazam')\n\nprint(a)                                  # a 中唯一的字母\n# {'a', 'r', 'b', 'c', 'd'}\n\nprint(a - b)                              # 在 a 中的字母，但不在 b 中\n# {'r', 'd', 'b'}\n\nprint(a | b)                              # 在 a 或 b 中的字母\n# {'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}\n\nprint(a & b)                              # 在 a 和 b 中都有的字母\n# {'a', 'c'}\nprint(a ^ b)                              # 在 a 或 b 中的字母，但不同时在 a 和 b 中\n# {'r', 'd', 'b', 'm', 'z', 'l'}\n集合推导式\na = {x for x in 'abracadabra' if x not in 'abc'}\nprint(a)\n# {'d', 'r'}\n流程控制\nif 控制\nif 表达式1:\n    语句\n    if 表达式2:\n        语句\n    elif 表达式3:\n        语句\n    else:\n        语句\nelif 表达式4:\n    语句\nelse:\n    语句\n1、每个条件后面要使用冒号 :，表示接下来是满足条件后要执行的语句块。2、使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。3、在 Python 中没有 switch - case 语句。\n三元运算符：\n<表达式1> if <条件> else <表达式2>\n编写条件语句时，应该尽量避免使用嵌套语句。嵌套语句不便于阅读，而且可能会忽略一些可能性。\nfor 遍历\nfor <循环变量> in <循环对象>：\n    <语句1>\nelse:\n    <语句2>\nelse 语句中的语句2只有循环正常退出（遍历完所有遍历对象中的值）时执行。\n在字典中遍历时，关键字和对应的值可以使用 items() 方法同时解读出来：\nknights = {'gallahad': 'the pure', 'robin': 'the brave'}\nfor k, v in knights.items():\n    print(k, v)\n在序列中遍历时，索引位置和对应值可以使用 enumerate() 函数同时得到：\nfor i, v in enumerate(['tic', 'tac', 'toe']):\n    print(i, v)\n同时遍历两个或更多的序列，可以使用 zip() 组合：\nquestions = ['name', 'quest', 'favorite color']\nanswers = ['lancelot', 'the holy grail', 'blue']\nfor q, a in zip(questions, answers):\n    print('What is your {0}?  It is {1}.'.format(q, a))\n要反向遍历一个序列，首先指定这个序列，然后调用 reversed() 函数：\nfor i in reversed(range(1, 10, 2)):\n    print(i)\n要按顺序遍历一个序列，使用 sorted() 函数返回一个已排序的序列，并不修改原值：\nbasket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\nfor f in sorted(set(basket)):\n    print(f)\nwhile 循环\nwhile<条件>：\n    <语句1>\nelse：\n    <语句2>\nbreak、continue、pass\nbreak 语句用在 while 和 for 循环中，break 语句用来终止循环语句，即循环条件没有 False 条件或者序列还没被完全递归完，也会停止执行循环语句。　　continue 语句用在 while 和 for 循环中，continue 语句用来告诉 Python 跳过当前循环的剩余语句，然后继续进行下一轮循环。 continue 语句跳出本次循环，而 break 跳出整个循环。\npass 是空语句，是为了保持程序结构的完整性。pass 不做任何事情，一般用做占位语句。\n迭代器\n\n迭代器是一个可以记住遍历的位置的对象。\n迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。\n迭代器有两个基本的方法：iter() 和 next()。\n字符串，列表或元组对象都可用于创建迭代器。\n\n迭代器可以被 for 循环进行遍历：\nli = [1, 2, 3]\nit = iter(li)\nfor val in it:\n    print(val)\n迭代器也可以用 next() 函数访问下一个元素值：\nimport sys\n \nli = [1,2,3,4]\nit = iter(li)\n \nwhile True:\n    try:\n        print (next(it))\n    except StopIteration:\n        sys.exit()\n生成器\n\n在 Python 中，使用了 yield 的函数被称为生成器（generator）。\n跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。\n在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。\n调用一个生成器函数，返回的是一个迭代器对象。\n\nimport sys\n \ndef fibonacci(n): # 生成器函数 - 斐波那契\n    a, b, counter = 0, 1, 0\n    while True:\n        if (counter > n): \n            return\n        yield a\n        a, b = b, a + b\n        counter += 1\n\nf = fibonacci(10) # f 是一个迭代器，由生成器返回生成\n \nwhile True:\n    try:\n        print(next(f))\n    except StopIteration:\n        sys.exit()\n函数\n自定义函数\n函数（Functions）是指可重复使用的程序片段。它们允许你为某个代码块赋予名字，允许你通过这一特殊的名字在你的程序任何地方来运行代码块，并可重复任何次数。这就是所谓的调用（Calling）函数。\n\n函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 ()。\n任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。\n函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。\n函数内容以冒号起始，并且缩进。\n\nreturn [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的 return 相当于返回 None。\n\nreturn 可以返回多个值，此时返回的数据未元组类型。\n定义参数时，带默认值的参数必须在无默认值参数的后面。\n\ndef 函数名（参数列表）:\n    函数体\n参数传递\n在 Python 中，类型属于对象，变量是没有类型的：\na = [1,2,3]\n\na = \"Runoob\"\n以上代码中，[1,2,3] 是 List 类型，\"Runoob\" 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是指向 List 类型对象，也可以是指向 String 类型对象。\n可更改与不可更改对象\n在 Python 中，字符串，数字和元组是不可更改的对象，而列表、字典等则是可以修改的对象。\n\n\n不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。\n\n可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。\n\nPython 函数的参数传递：\n\n\n不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。\n\n可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响\n\nPython 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。\n参数\n必需参数\n必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。\n关键字参数\n关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。\ndef print_info(name, age):\n    \"打印任何传入的字符串\"\n    print(\"名字: \", name)\n    print(\"年龄: \", age)\n    return\n\nprint_info(age=50, name=\"john\")\n默认参数\n调用函数时，如果没有传递参数，则会使用默认参数。\ndef print_info(name, age=35):\n    print (\"名字: \", name)\n    print (\"年龄: \", age)\n    return\n\nprint_info(age=50, name=\"john\")\nprint(\"------------------------\")\nprint_info(name=\"john\")\n不定长参数\n\n加了星号 * 的参数会以元组的形式导入，存放所有未命名的变量参数。\n如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。\n\ndef print_info(arg1, *vartuple):\n    print(\"输出: \")\n    print(arg1)\n    for var in vartuple:\n        print (var)\n    return\n\nprint_info(10)\nprint_info(70, 60, 50)\n加了两个星号 ** 的参数会以字典的形式导入。变量名为键，变量值为字典元素值。\ndef print_info(arg1, **vardict):\n    print(\"输出: \")\n    print(arg1)\n    print(vardict)\n\nprint_info(1, a=2, b=3)\n匿名函数\nPython 使用 lambda 来创建匿名函数。\n所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。\nlambda 只是一个表达式，函数体比 def 简单很多。lambda 的主体是一个表达式，而不是一个代码块。仅仅能在 lambda 表达式中封装有限的逻辑进去。lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。虽然 lambda 函数看起来只能写一行，却不等同于 C 或 C++ 的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。\n# 语法格式\nlambda [arg1 [,arg2,.....argn]]:expression\n变量作用域\n\nL （Local） 局部作用域\nE （Enclosing） 闭包函数外的函数中\nG （Global） 全局作用域\nB （Built-in） 内建作用域\n\n以 L –> E –> G –> B 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内建中找。\nPython 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 if/elif/else/、try/except、for/while等）是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问。\n定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。\n局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。\n当内部作用域想修改外部作用域的变量时，就要用到global和nonlocal关键字。\nnum = 1\ndef fun1():\n    global num  # 需要使用 global 关键字声明\n    print(num) \n    num = 123\n    print(num)\nfun1()\n如果要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量则需要 nonlocal 关键字。\ndef outer():\n    num = 10\n    def inner():\n        nonlocal num   # nonlocal关键字声明\n        num = 100\n        print(num)\n    inner()\n    print(num)\nouter()\n模块\n编写模块有很多种方法，其中最简单的一种便是创建一个包含函数与变量、以 .py 为后缀的文件。\n另一种方法是使用撰写 Python 解释器本身的本地语言来编写模块。举例来说，你可以使用 C 语言来撰写 Python 模块，并且在编译后，你可以通过标准 Python 解释器在你的 Python 代码中使用它们。\n模块是一个包含所有你定义的函数和变量的文件，其后缀名是.py。模块可以被别的程序引入，以使用该模块中的函数等功能。这也是使用 Python 标准库的方法。\n当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。\n搜索路径是一个解释器会先进行搜索的所有目录的列表。如想要导入模块，需要把命令放在脚本的顶端。\n一个模块只会被导入一次，这样可以防止导入模块被一遍又一遍地执行。\n搜索路径被存储在 sys 模块中的 path 变量。当前目录指的是程序启动的目录。\n导入模块\n导入模块：\nimport module1[, module2[,... moduleN]\n从模块中导入一个指定的部分到当前命名空间中：\nfrom modname import name1[, name2[, ... nameN]]\n把一个模块的所有内容全都导入到当前的命名空间：\nfrom modname import *\n_name_ 属性\n每个模块都有一个 __name__ 属性，当其值是 '__main__' 时，表明该模块自身在运行，否则是被引入。\n一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用 __name__ 属性来使该程序块仅在该模块自身运行时执行。\nif __name__ == '__main__':\n    print('程序自身在运行')\nelse:\n    print('我来自另一模块')\ndir 函数\n内置的函数 dir() 可以找到模块内定义的所有名称。以一个字符串列表的形式返回。\n如果没有给定参数，那么 dir() 函数会罗列出当前定义的所有名称。\n在 Python 中万物皆对象，int、str、float、list、tuple等内置数据类型其实也是类，也可以用 dir(int) 查看 int 包含的所有方法。也可以使用 help(int) 查看 int 类的帮助信息。\n包\n包是一种管理 Python 模块命名空间的形式，采用\"点模块名称\"。\n比如一个模块的名称是 A.B， 那么他表示一个包 A中的子模块 B 。\n就好像使用模块的时候，你不用担心不同模块之间的全局变量相互影响一样，采用点模块名称这种形式也不用担心不同库之间的模块重名的情况。\n在导入一个包的时候，Python 会根据 sys.path 中的目录来寻找这个包中包含的子目录。\n目录只有包含一个叫做 __init__.py 的文件才会被认作是一个包，主要是为了避免一些滥俗的名字（比如叫做 string）不小心的影响搜索路径中的有效模块。\n最简单的情况，放一个空的 __init__.py 文件就可以了。当然这个文件中也可以包含一些初始化代码或者为 __all__ 变量赋值。\n第三方模块\n\neasy_install 和 pip 都是用来下载安装 Python 一个公共资源库 PyPI 的相关资源包的，pip 是 easy_install 的改进版，提供更好的提示信息，删除 package 等功能。老版本的 python 中只有 easy_install，没有pip。\neasy_install 打包和发布 Python 包，pip 是包管理。\n\neasy_install 的用法：\n\n\n安装一个包\neasy_install 包名\neasy_install \"包名 == 包的版本号\"\n\n\n升级一个包\neasy_install -U \"包名 >= 包的版本号\"\n\n\npip 的用法：\n\n\n安装一个包\npip install 包名\n\npip install 包名 == 包的版本号\n\n\n升级一个包（如果不提供version号，升级到最新版本）\npip install --upgrade 包名 >= 包的版本号\n\n\n删除一个包\npip uninstall 包名\n\n\n已安装包列表\npip list\n\n\n面向对象\n类与对象是面向对象编程的两个主要方面。一个类（Class）能够创建一种新的类型（Type），其中对象（Object）就是类的实例（Instance）。可以这样来类比：你可以拥有类型 int 的变量，也就是说存储整数的变量是 int 类的实例（对象）。\n\n\n类(Class)：用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。\n\n方法：类中定义的函数。\n\n类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。\n\n数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。\n\n方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。\n\n实例变量：定义在方法中的变量，只作用于当前实例的类。\n\n继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟\"是一个（is-a）\"关系（例图，Dog是一个Animal）。\n\n实例化：创建一个类的实例，类的具体对象。\n\n对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。\n\nPython 中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。\n对象可以包含任意数量和类型的数据。\nself\nself 表示的是当前实例，代表当前对象的地址。类由 self.__class__ 表示。\nself 不是关键字，其他名称也可以替代，但 self 是个通用的标准名称。\n类\n类由 class 关键字来创建。类实例化后，可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性。\n对象方法\n方法由 def 关键字定义，与函数不同的是，方法必须包含参数 self, 且为第一个参数，self 代表的是本类的实例。\n类方法\n装饰器 @classmethod 可以将方法标识为类方法。类方法的第一个参数必须为 cls，而不再是 self。\n静态方法\n装饰器 @staticmethod 可以将方法标识为静态方法。静态方法的第一个参数不再指定，也就不需要 self 或 cls。\n__init__ 方法\n__init__ 方法即构造方法，会在类的对象被实例化时先运行，可以将初始化的操作放置到该方法中。\n如果重写了 __init__，实例化子类就不会调用父类已经定义的 __init__。\n变量\n类变量（Class Variable）是共享的（Shared）——它们可以被属于该类的所有实例访问。该类变量只拥有一个副本，当任何一个对象对类变量作出改变时，发生的变动将在其它所有实例中都会得到体现。\n对象变量（Object variable）由类的每一个独立的对象或实例所拥有。在这种情况下，每个对象都拥有属于它自己的字段的副本，也就是说，它们不会被共享，也不会以任何方式与其它不同实例中的相同名称的字段产生关联。\n在 Python 中，变量名类似 __xxx__ 的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是 private 变量，所以，不能用 __name__、__score__ 这样的变量名。\n访问控制\n\n私有属性__private_attr：两个下划线开头，声明该属性为私有，不能在类地外部被使用或直接访问。\n\n私有方法__private_method：两个下划线开头，声明该方法为私有方法，只能在类的内部调用，不能在类地外部调用。\n\n\n我们还认为约定，一个下划线开头的属性或方法为受保护的。比如，_protected_attr、_protected_method。\n继承\n类可以继承，并且支持继承多个父类。在定义类时，类名后的括号中指定要继承的父类，多个父类之间用逗号分隔。\n子类的实例可以完全访问所继承所有父类的非私有属性和方法。\n若是父类中有相同的方法名，而在子类使用时未指定，Python 从左至右搜索，即方法在子类中未找到时，从左到右查找父类中是否包含方法。\n方法重写\n子类的方法可以重写父类的方法。重写的方法参数不强制要求保持一致，不过合理的设计都应该保持一致。\nsuper() 函数可以调用父类的一个方法，以多继承问题。\n类的专有方法：\n\n\n__init__: 构造函数，在生成对象时调用\n\n__del__: 析构函数，释放对象时使用\n\n__repr__: 打印，转换\n\n__setitem__: 按照索引赋值\n\n__getitem__: 按照索引获取值\n\n__len__: 获得长度\n\n__cmp__: 比较运算\n\n__call__: 函数调用\n\n__add__: 加运算\n\n__sub__: 减运算\n\n__mul__: 乘运算\n\n__div__: 除运算\n\n__mod__: 求余运算\n\n__pow__: 乘方\n\n类的专有方法也支持重载。\n实例\nclass Person:\n    \"\"\"人员信息\"\"\"\n\n    # 姓名(共有属性)\n    name = ''\n\n    # 年龄(共有属性)\n    age = 0\n\n    def __init__(self, name='', age=0):\n        self.name = name\n        self.age = age\n\n    # 重载专有方法: __str__\n    def __str__(self):\n        return \"这里重载了 __str__ 专有方法, \" + str({'name': self.name, 'age': self.age})\n\n    def set_age(self, age):\n        self.age = age\n\n\nclass Account:\n    \"\"\"账户信息\"\"\"\n\n    # 账户余额(私有属性)\n    __balance = 0\n\n    # 所有账户总额\n    __total_balance = 0\n\n    # 获取账户余额\n    # self 必须是方法的第一个参数\n    def balance(self):\n        return self.__balance\n\n    # 增加账户余额\n    def balance_add(self, cost):\n        # self 访问的是本实例\n        self.__balance += cost\n        # self.__class__ 可以访问类\n        self.__class__.__total_balance += cost\n\n    # 类方法(用 @classmethod 标识，第一个参数为 cls)\n    @classmethod\n    def total_balance(cls):\n        return cls.__total_balance\n\n    # 静态方法(用 @staticmethod 标识，不需要类参数或实例参数)\n    @staticmethod\n    def exchange(a, b):\n        return b, a\n\n\nclass Teacher(Person, Account):\n    \"\"\"教师\"\"\"\n\n    # 班级名称\n    _class_name = ''\n\n    def __init__(self, name):\n        # 第一种重载父类__init__()构造方法\n        # super(子类，self).__init__(参数1，参数2，....)\n        super(Teacher, self).__init__(name)\n\n    def get_info(self):\n        # 以字典的形式返回个人信息\n        return {\n            'name': self.name,  # 此处访问的是父类Person的属性值\n            'age': self.age,\n            'class_name': self._class_name,\n            'balance': self.balance(),  # 此处调用的是子类重载过的方法\n        }\n\n    # 方法重载\n    def balance(self):\n        # Account.__balance 为私有属性，子类无法访问，所以父类提供方法进行访问\n        return Account.balance(self) * 1.1\n\n\nclass Student(Person, Account):\n    \"\"\"学生\"\"\"\n\n    _teacher_name = ''\n\n    def __init__(self, name, age=18):\n        # 第二种重载父类__init__()构造方法\n        # 父类名称.__init__(self,参数1，参数2，...)\n        Person.__init__(self, name, age)\n\n    def get_info(self):\n        # 以字典的形式返回个人信息\n        return {\n            'name': self.name,  # 此处访问的是父类Person的属性值\n            'age': self.age,\n            'teacher_name': self._teacher_name,\n            'balance': self.balance(),\n        }\n\n\n# 教师 John\njohn = Teacher('John')\njohn.balance_add(20)\njohn.set_age(36)  # 子类的实例可以直接调用父类的方法\nprint(\"John's info:\", john.get_info())\n\n# 学生 Mary\nmary = Student('Mary', 18)\nmary.balance_add(18)\nprint(\"Mary's info:\", mary.get_info())\n\n# 学生 Fake\nfake = Student('Fake')\nfake.balance_add(30)\nprint(\"Fake's info\", fake.get_info())\n\n# 三种不同的方式调用静态方法\nprint(\"john.exchange('a', 'b'):\", john.exchange('a', 'b'))\nprint('Teacher.exchange(1, 2)', Teacher.exchange(1, 2))\nprint('Account.exchange(10, 20):', Account.exchange(10, 20))\n\n# 类方法、类属性\nprint('Account.total_balance():', Account.total_balance())\nprint('Teacher.total_balance():', Teacher.total_balance())\nprint('Student.total_balance():', Student.total_balance())\n\n# 重载专有方法\nprint(fake)\n输出：\nJohn's info: {'name': 'John', 'age': 36, 'class_name': '', 'balance': 22.0}\nMary's info: {'name': 'Mary', 'age': 18, 'teacher_name': '', 'balance': 18}\nFake's info {'name': 'Fake', 'age': 18, 'teacher_name': '', 'balance': 30}\njohn.exchange('a', 'b'): ('b', 'a')\nTeacher.exchange(1, 2) (2, 1)\nAccount.exchange(10, 20): (20, 10)\nAccount.total_balance(): 0\nTeacher.total_balance(): 20\nStudent.total_balance(): 48\n这里重载了 __str__ 专有方法, {'name': 'Fake', 'age': 18}\n错误和异常\n语法错误\nSyntaxError 类表示语法错误，当解释器发现代码无法通过语法检查时会触发的错误。语法错误是无法用 try...except...捕获的。\n>>> print:\n  File \"<stdin>\", line 1\n    print:\n         ^\nSyntaxError: invalid syntax\n异常\n即便程序的语法是正确的，在运行它的时候，也有可能发生错误。运行时发生的错误被称为异常。错误信息的前面部分显示了异常发生的上下文，并以调用栈的形式显示具体信息。\n>>> 1 + '0'\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\n异常处理\nPython 提供了 try ... except ... 的语法结构来捕获和处理异常。\ntry 语句执行流程大致如下：\nst=>start: try 子句\ncond_has_error=>condition: 是否有异常\ncond_has_else=>condition: 是否有 else 子句\ncond_has_finally=>condition: 是否有 finally 子句\nio=>inputoutput: verification\nop_except=>operation: except 子句处理异常\nop_else=>operation: 执行 else 子句\nop_finally=>operation: 执行 finally 子句\ne=>end: 结束\n\nst->cond_has_error\ncond_has_error(yes, right)->op_except->cond_has_else\ncond_has_error(no)->cond_has_else\ncond_has_else(yes, right)->op_else->cond_has_finally\ncond_has_else(no)->cond_has_finally\ncond_has_finally(yes, right)->op_finally->e\ncond_has_finally(no)->e\n\n首先，执行 try 子句（在关键字 try 和关键字 except 之间的语句）\n如果没有异常发生，忽略 except 子句，try 子句执行后结束。\n如果在执行 try 子句的过程中发生了异常，那么 try 子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的 except 子句将被执行。最后执行 try 语句之后的代码。\n如果一个异常没有与任何的 except 匹配，那么这个异常将会传递给上层的 try 中。\n一个 try 语句可能包含多个 except 子句，分别来处理不同的特定的异常。\n最多只有一个 except 子句会被执行。\n处理程序将只针对对应的 try 子句中的异常进行处理，而不是其他的 try 的处理程序中的异常。\n一个 except 子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组。\n最后一个 except 子句可以忽略异常的名称，它将被当作通配符使用。可以使用这种方法打印一个错误信息，然后再次把异常抛出。\ntry except 语句还有一个可选的 else 子句，如果使用这个子句，那么必须放在所有的 except 子句之后。这个子句将在 try 子句没有发生任何异常的时候执行。\n异常处理并不仅仅处理那些直接发生在 try 子句中的异常，而且还能处理子句中调用的函数（甚至间接调用的函数）里抛出的异常。\n不管 try 子句里面有没有发生异常，finally 子句都会执行。\n如果一个异常在 try 子句里（或者在 except 和 else 子句里）被抛出，而又没有任何的 except 把它截住，那么这个异常会在 finally 子句执行后再次被抛出。\n\n抛出异常\n使用 raise 语句抛出一个指定的异常。\nraise 唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是 Exception 的子类）。\n如果你只想知道这是否抛出了一个异常，并不想去处理它，那么一个简单的 raise 语句就可以再次把它抛出。\n自定义异常\n可以通过创建一个新的异常类来拥有自己的异常。异常类继承自 Exception 类，可以直接继承，或者间接继承。\n当创建一个模块有可能抛出多种不同的异常时，一种通常的做法是为这个包建立一个基础异常类，然后基于这个基础类为不同的错误情况创建不同的子类。\n大多数的异常的名字都以\"Error\"结尾，就跟标准的异常命名一样。\n实例\nimport sys\n\n\nclass Error(Exception):\n    \"\"\"Base class for exceptions in this module.\"\"\"\n    pass\n\n\n# 自定义异常\nclass InputError(Error):\n    \"\"\"Exception raised for errors in the input.\n\n    Attributes:\n        expression -- input expression in which the error occurred\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, expression, message):\n        self.expression = expression\n        self.message = message\n\n\ntry:\n    print('code start running...')\n\n    raise InputError('input()', 'input error')\n\n    # ValueError\n    int('a')\n\n    # TypeError\n    s = 1 + 'a'\n\n    dit = {'name': 'john'}\n    # KeyError\n    print(dit['1'])\nexcept InputError as ex:\n    print(\"InputError:\", ex.message)\nexcept TypeError as ex:\n    print('TypeError:', ex.args)\n    pass\nexcept (KeyError, IndexError) as ex:\n    \"\"\"支持同时处理多个异常, 用括号放到元组里\"\"\"\n    print(sys.exc_info())\nexcept:\n    \"\"\"捕获其他未指定的异常\"\"\"\n    print(\"Unexpected error:\", sys.exc_info()[0])\n    # raise 用于抛出异常\n    raise RuntimeError('RuntimeError')\nelse:\n    \"\"\"当无任何异常时, 会执行 else 子句\"\"\"\n    print('\"else\" 子句...')\nfinally:\n    \"\"\"无论有无异常, 均会执行 finally\"\"\"\n    print('finally, ending')\n文件操作\n打开文件\nopen() 函数用于打开/创建一个文件，并返回一个 file 对象：\nopen(filename, mode)\n\nfilename：包含了你要访问的文件名称的字符串值\nmode：决定了打开文件的模式：只读，写入，追加等\n\n文件打开模式：\n\n\n模式\n描述\n\n\n\nr\n以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。\n\n\nrb\n以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。\n\n\nr+\n打开一个文件用于读写。文件指针将会放在文件的开头。\n\n\nrb+\n以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。\n\n\nw\n打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。\n\n\nwb\n以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。\n\n\nw+\n打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。\n\n\nwb+\n以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。\n\n\na\n打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。\n\n\nab\n以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。\n\n\na+\n打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。\n\n\nab+\n以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。\n\n\n\n文件对象方法\n\n\nfileObject.close()close() 方法用于关闭一个已打开的文件。关闭后的文件不能再进行读写操作，否则会触发 ValueError 错误。 close() 方法允许调用多次。\n当 file 对象，被引用到操作另外一个文件时，Python 会自动关闭之前的 file 对象。 使用 close() 方法关闭文件是一个好的习惯。\n\n\nfileObject.flush()flush() 方法是用来刷新缓冲区的，即将缓冲区中的数据立刻写入文件，同时清空缓冲区，不需要是被动的等待输出缓冲区写入。\n一般情况下，文件关闭后会自动刷新缓冲区，但有时你需要在关闭前刷新它，这时就可以使用 flush() 方法。\n\n\nfileObject.fileno()fileno() 方法返回一个整型的文件描述符(file descriptor FD 整型)，可用于底层操作系统的 I/O 操作。\n\n\nfileObject.isatty()isatty() 方法检测文件是否连接到一个终端设备，如果是返回 True，否则返回 False。\n\n\nnext(iterator[,default])Python 3 中的 File 对象不支持 next() 方法。 Python 3 的内置函数 next() 通过迭代器调用 __next__() 方法返回下一项。在循环中，next() 函数会在每次循环中调用，该方法返回文件的下一行，如果到达结尾(EOF)，则触发 StopIteration。\n\n\nfileObject.read()read() 方法用于从文件读取指定的字节数，如果未给定或为负则读取所有。\n\n\nfileObject.readline()readline() 方法用于从文件读取整行，包括 \"n\" 字符。如果指定了一个非负数的参数，则返回指定大小的字节数，包括 \"n\" 字符。\n\n\nfileObject.readlines()readlines() 方法用于读取所有行(直到结束符 EOF)并返回列表，该列表可以由 Python 的 for... in ... 结构进行处理。如果碰到结束符 EOF，则返回空字符串。\n\n\nfileObject.seek(offset[, whence])seek() 方法用于移动文件读取指针到指定位置。\nwhence 的值, 如果是 0 表示开头, 如果是 1 表示当前位置, 2 表示文件的结尾。whence 值为默认为0，即文件开头。例如：\nseek(x, 0)：从起始位置即文件首行首字符开始移动 x 个字符\nseek(x, 1)：表示从当前位置往后移动 x 个字符\nseek(-x, 2)：表示从文件的结尾往前移动 x 个字符\n\n\nfileObject.tell(offset[, whence])tell() 方法返回文件的当前位置，即文件指针当前位置。\n\n\nfileObject.truncate([size])truncate() 方法用于从文件的首行首字符开始截断，截断文件为 size 个字符，无 size 表示从当前位置截断；截断之后 V 后面的所有字符被删除，其中 Widnows 系统下的换行代表2个字符大小。\n\n\nfileObject.write([str])write() 方法用于向文件中写入指定字符串。\n在文件关闭前或缓冲区刷新前，字符串内容存储在缓冲区中，这时你在文件中是看不到写入的内容的。\n如果文件打开模式带 b，那写入文件内容时，str (参数)要用 encode 方法转为 bytes 形式，否则报错：TypeError: a bytes-like object is required, not 'str'。\n\n\nfileObject.writelines([str])writelines() 方法用于向文件中写入一序列的字符串。这一序列字符串可以是由迭代对象产生的，如一个字符串列表。换行需要指定换行符 \\n。\n\n\n实例\nfilename = 'data.log'\n\n# 打开文件(a+ 追加读写模式)\n# 用 with 关键字的方式打开文件，会自动关闭文件资源\nwith open(filename, 'w+', encoding='utf-8') as file:\n    print('文件名称: {}'.format(file.name))\n    print('文件编码: {}'.format(file.encoding))\n    print('文件打开模式: {}'.format(file.mode))\n    print('文件是否可读: {}'.format(file.readable()))\n    print('文件是否可写: {}'.format(file.writable()))\n\n    print('此时文件指针位置为: {}'.format(file.tell()))\n\n    # 写入内容\n    num = file.write(\"第一行内容\\n\")\n    print('写入文件 {} 个字符'.format(num))\n\n    # 文件指针在文件尾部，故无内容\n    print(file.readline(), file.tell())\n\n    # 改变文件指针到文件头部\n    file.seek(0)\n\n    # 改变文件指针后，读取到第一行内容\n    print(file.readline(), file.tell())\n\n    # 但文件指针的改变，却不会影响到写入的位置\n    file.write('第二次写入的内容\\n')\n\n    # 文件指针又回到了文件尾\n    print(file.readline(), file.tell())\n\n    # file.read() 从当前文件指针位置读取指定长度的字符\n    file.seek(0)\n    print(file.read(9))\n\n    # 按行分割文件，返回字符串列表\n    file.seek(0)\n    print(file.readlines())\n\n    # 迭代文件对象，一行一个元素\n    file.seek(0)\n    for line in file:\n        print(line, end='')\n\n# 关闭文件资源\nif not file.closed:\n    file.close()\n输出：\n文件名称: data.log\n文件编码: utf-8\n文件打开模式: w+\n文件是否可读: True\n文件是否可写: True\n此时文件指针位置为: 0\n写入文件 6 个字符\n 16\n第一行内容\n 16\n 41\n第一行内容\n第二次\n['第一行内容\\n', '第二次写入的内容\\n']\n第一行内容\n第二次写入的内容\n序列化\n在 Python 中 pickle 模块实现对数据的序列化和反序列化。pickle 支持任何数据类型，包括内置数据类型、函数、类、对象等。\n方法\ndump\n将数据对象序列化后写入文件\npickle.dump(obj, file, protocol=None, fix_imports=True)\n必填参数 obj 表示将要封装的对象。必填参数 file 表示 obj 要写入的文件对象，file 必须以二进制可写模式打开，即wb。可选参数 protocol 表示告知 pickle 使用的协议，支持的协议有 0,1,2,3，默认的协议是添加在 Python 3 中的协议3。\nload\n从文件中读取内容并反序列化\npickle.load(file, fix_imports=True, encoding='ASCII', errors='strict')\n必填参数 file 必须以二进制可读模式打开，即rb，其他都为可选参数。\ndumps\n以字节对象形式返回封装的对象，不需要写入文件中\npickle.dumps(obj, protocol=None, fix_imports=True)\nloads\n从字节对象中读取被封装的对象，并返回\npickle.loads(bytes_object, fix_imports=True, encoding='ASCII', errors='strict')\n实例\nimport pickle\n\ndata = [1, 2, 3]\n\n# 序列化数据并以字节对象返回\ndumps_obj = pickle.dumps(data)\nprint('pickle.dumps():', dumps_obj)\n\n# 从字节对象中反序列化数据\nloads_data = pickle.loads(dumps_obj)\nprint('pickle.loads():', loads_data)\n\nfilename = 'data.log'\n\n# 序列化数据到文件中\nwith open(filename, 'wb') as file:\n    pickle.dump(data, file)\n\n# 从文件中加载并反序列化\nwith open(filename, 'rb') as file:\n    load_data = pickle.load(file)\n    print('pickle.load():', load_data)\n输出：\npickle.dumps(): b'\\x80\\x03]q\\x00(K\\x01K\\x02K\\x03e.'\npickle.loads(): [1, 2, 3]\npickle.load(): [1, 2, 3]\n命名规范\nPython 之父 Guido 推荐的规范\n\n\nType\nPublic\nInternal\n\n\n\nModules\nlower_with_under\n_lower_with_under\n\n\nPackages\nlower_with_under\n \n\n\nClasses\nCapWords\n_CapWords\n\n\nExceptions\nCapWords\n \n\n\nFunctions\nlower_with_under()\n_lower_with_under()\n\n\nGlobal/Class Constants\nCAPS_WITH_UNDER\n_CAPS_WITH_UNDER\n\n\nGlobal/Class Variables\nlower_with_under\n_lower_with_under\n\n\nInstance Variables\nlower_with_under\n_lower_with_under (protected) or __lower_with_under (private)\n\n\nMethod Names\nlower_with_under()\n_lower_with_under() (protected) or __lower_with_under() (private)\n\n\nFunction/Method Parameters\nlower_with_under\n \n\n\nLocal Variables\nlower_with_under\n \n\n\n\n一份来自谷歌的 Python 风格规范：\nhttp://zh-google-styleguide.r...\n参考资料\n\n简明 Python 教程\nPython 3 教程 | 菜鸟教程\nPython数据类型之“序列概述与基本序列类型(Basic Sequences)”\nPython基本数据类型——元组和集合\npython基础----特性（property）、静态方法（staticmethod）、类方法（classmethod）、__str__的用法\n\n\n原文地址: https://shockerli.net/post/py...\n\n\n                ", "mainLikeNum": ["35 "], "mainBookmarkNum": "33"}