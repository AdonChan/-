{"title": "opencv python Meanshift 和 Camshift  - 个人文章 ", "index": "opencv-python,opencv,python", "content": "Meanshift and Camshift \nMeanshift\nMeanshift 算法的基本原理简单,假设我们有一堆点，和一个小的圆形窗口，Meanshift 算法就是不断移动小圆形窗口，直到找到圆形区域内最大灰度密度处为止.\n\n初始窗口以蓝色圆圈显示，名称为“C1”,其原始中心标有蓝色矩形，名为“C1_o”.但是，这个窗口当中所有点的点集构成的质心在蓝色圆形点处,圆环的型心和质心并不重合,所以,移动蓝色的窗口以使型心与之前得到的质心重合.不断执行上面的移动过程，直到型心和质心大致重合结束. 通常通过直方图反投影图像和初始目标位置,当物体移动时,移动反映在直方图反投影图像中,最后圆形的窗口会落到像素分布最大的地方，也就是图中的绿色圈并命名为C2.\nmeanshift in OpenCV\n首先要设定目标，并计算的直方图，然后对这个直方图在每一帧当中进行反向投影.需要提供一个初试的窗口位置,计算HSV模型当中H(色调)的直方图,为了避免低亮度造成的影响，使用 cv2.inRange()将低亮度值忽略.\nimport numpy as np\nimport cv2\nimport matplotlib.pyplot as plt\n\ncap = cv2.VideoCapture('test.mp4')\n# take first frame of the video\nret,frame = cap.read()\n\n# setup initial location of window\nr,h,c,w = 50,200,50,100  # simply hardcoded the values\ntrack_window = (c,r,w,h)\n\n# set up the ROI for tracking\nroi = frame[r:r+h, c:c+w]\nhsv_roi =  cv2.cvtColor(roi, cv2.COLOR_BGR2HSV)\nmask = cv2.inRange(hsv_roi, np.array((0., 60.,32.)), np.array((180.,255.,255.)))\nroi_hist = cv2.calcHist([hsv_roi],[0],mask,[180],[0,180])\ncv2.normalize(roi_hist,roi_hist,0,255,cv2.NORM_MINMAX)\n\n# Setup the termination criteria, either 10 iteration or move by atleast 1 pt\nterm_crit = ( cv2.TERM_CRITERIA_EPS | cv2.TERM_CRITERIA_COUNT, 10, 1 )\n\nwhile(1):\n    ret ,frame = cap.read()\n\n    if ret == True:\n        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)\n        dst = cv2.calcBackProject([hsv],[0],roi_hist,[0,180],1)\n\n        # apply meanshift to get the new location\n        ret, track_window = cv2.CamShift(dst, track_window, term_crit)\n\n        # Draw it on image\n        pts = cv2.boxPoints(ret)\n        pts = np.int0(pts)\n        img2 = cv2.polylines(frame,[pts],True, 255,2)\n        cv2.imshow('img2',img2)\n\n        k = cv2.waitKey(60) & 0xff\n        if k == 27:\n            break\n        else:\n            cv2.imwrite(chr(k)+\".jpg\",img2)\n\n    else:\n        break\n\ncv2.destroyAllWindows()\ncap.release()\n\n\nCamShift\n在目标跟踪中，物体的大小不是固定的，所以设置的跟踪窗口也应该随之变化，CAMshift算法，首先使用meanshift算法找到目标，然后调整窗口大小，而且还会计算目标对象的的最佳外接圆的角度，并调整窗口，并使用调整后的窗口对物体继续追踪.\nCamshift in OpenCV\n它与meanshift几乎相同，但它返回一个旋转的矩形.\nimport numpy as np\nimport cv2\nimport matplotlib.pyplot as plt\n\ncap = cv2.VideoCapture('test.mp4')\n# take first frame of the video\nret,frame = cap.read()\n\n# setup initial location of window\nr,h,c,w = 50,200,50,100  # simply hardcoded the values\ntrack_window = (c,r,w,h)\n\n# set up the ROI for tracking\nroi = frame[r:r+h, c:c+w]\nhsv_roi =  cv2.cvtColor(roi, cv2.COLOR_BGR2HSV)\nmask = cv2.inRange(hsv_roi, np.array((0., 60.,32.)), np.array((180.,255.,255.)))\nroi_hist = cv2.calcHist([hsv_roi],[0],mask,[180],[0,180])\ncv2.normalize(roi_hist,roi_hist,0,255,cv2.NORM_MINMAX)\n\n# Setup the termination criteria, either 10 iteration or move by atleast 1 pt\nterm_crit = ( cv2.TERM_CRITERIA_EPS | cv2.TERM_CRITERIA_COUNT, 10, 1 )\n\nwhile(1):\n    ret ,frame = cap.read()\n\n    if ret == True:\n        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)\n        dst = cv2.calcBackProject([hsv],[0],roi_hist,[0,180],1)\n\n        # apply meanshift to get the new location\n        ret, track_window = cv2.CamShift(dst, track_window, term_crit)\n\n        # Draw it on image\n        pts = cv2.boxPoints(ret)\n        pts = np.int0(pts)\n        img2 = cv2.polylines(frame,[pts],True, 255,2)\n        cv2.imshow('img2',img2)\n\n        k = cv2.waitKey(60) & 0xff\n        if k == 27:\n            break\n        else:\n            cv2.imwrite(chr(k)+\".jpg\",img2)\n\n    else:\n        break\n\ncv2.destroyAllWindows()\ncap.release()\n\n\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}