{"title": "setup.py 技巧 - yexiaoxiaobai ", "index": "setup.py,python", "content": "\n  本文原文是 setup.py tricks\n\n\n\n\n在开始之前，我要声明我们要解释的是‘技巧’。不是最佳实践，并且在至少一种情况下，它是不可取的。\n\n说到不明智的做法，在某时我将写一篇“setup.py 陷阱”的博客文章，我相信你应该绝不会在 setup.py 模块做的事情。\n\n技巧\n\n这些技巧使得我的 Python 包管理更容易一点。在你试图实现它们之前，我建议你最少有创建新包的基础经验。有两种方式可以学习到 Python 包的知识，一个是  New Library Sprint（适合初学者），另外一个是  Python Packaging User Guide（更高级）。\n\n'python setup.py publish'\n\n这是一切开始的地方。某天我看到了一些 Tom Christie 的代码，并发现了 Django Rest 框架的 setup.py 模块的 python setup.py publish 命令。它看起来像这样：\n\n# setup.py\nimport os\nimport sys\n\n# I'll discuss version tricks in a future blog post.\nversion = \"42.0.0\"\n\nif sys.argv[-1] == 'publish':\n    os.system(\"python setup.py sdist upload\")\n    os.system(\"python setup.py bdist_wheel upload\")\n    print(\"You probably want to also tag the version now:\")\n    print(\"  git tag -a %s -m 'version %s'\" % (version, version))\n    print(\"  git push --tags\")\n    sys.exit()\n\n# Below this point is the rest of the setup() function\n\n\n了不起的是使用的这个技术我没有发现有稍微隐秘的 python setup.py sdist upload  命令，或者实际上隐秘的是  python setup.py bdist_wheel upload。当我把其中一个包 push 到 PyPI 上去的时候，我仅仅需要键入：\n\n$ python setup.py publish\n\n\n非常简单。\n\n'python setup.py tag'\n\nTom Christie 的 python setup.py publish 命令的问题是它强迫我打印输出 git tag 命令。好吧，让我们说实话吧，它强迫我复制/粘贴我的输出到我的屏幕上。因此，对于我自己，我‘创造’了 python setup.py tag  命令：\n\n# setup.py\n\nif sys.argv[-1] == 'tag':\n    os.system(\"git tag -a %s -m 'version %s'\" % (version, version))\n    os.system(\"git push --tags\")\n    sys.exit()\n\n\n相当漂亮，是不是？现在我不需要记住一些隐秘的 git 命令。然后我获得了更短的 python setup.py publish 命令：\n\nif sys.argv[-1] == 'publish':\n    os.system(\"python setup.py sdist upload\")\n    os.system(\"python setup.py bdist_wheel upload\")\n    sys.exit()\n\n\n当我需要一个版本发布，我提交我的代码然后键入：\n\n$ python setup.py publish\n$ python setup.py tag\n\n\n为什么我部组合这些命令？好吧，你不会支持 put 东西像 'RC1' 或 '-alpha' 到你的 PyPI 版本名字。通过分离这些命令，我可以更细粒度的控制包发布。我鼓励在  git tags 中对 alpha，beta，和 候选版本分类，而不是正式 PyPI 版本。\n\n'python setup.py test'\n\n我很确定我的一些读者使用这个技巧会有一个严重的问题。实际上，依赖于管理  Python 包架构的响应，它可能会被移动到我即将出版的“陷阱”的博客文章。\n\n我喜欢 py.test。我已经写了一遍关于使用 py.test 的博客，我尝试在任何地方使用它。我们应该如何配合进  python setup.py test。恰好在那个时刻，使得我舒服的是使用 py.test 在 setup.py 中加入指定的类。\n\n幸运的是，有另外一种方式：\n\nif sys.argv[-1] == 'test':\n    test_requirements = [\n        'pytest',\n        'flake8',\n        'coverage'\n    ]\n    try:\n        modules = map(__import__, test_requirements)\n    except ImportError as e:\n        err_msg = e.message.replace(\"No module named \", \"\")\n        msg = \"%s is not installed. Install your test requirments.\" % err_msg\n        raise ImportError(msg)\n    os.system('py.test')\n    sys.exit()\n\n\n这意味着我用一个简单的添加代码使用了 py.test 和 python setup.py test 。\n\n$ python setup.py test\n\n\n理论上，可以运行 pip install 安装缺失的包，或者从一个  requirements 文件中调用它们。尽管如此，因为这些技巧，我喜欢让事情简单明了。如果我得到足够明确的结果，我将更新这个示例来包含调用  pip 来安装缺失的 requirements。\n\n\n  注意，这并不意味着我不使用 tox，我使用 tox 来调用我 python setup.py test 的版本。\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "11"}