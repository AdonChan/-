{"title": "三剑客之AWK - 达龙 ", "index": "linux,python", "content": "博文参考\nhttp://www.178linux.com/6553\nhttp://baike.baidu.com/link?url=Y4lo-kWxygpw7NLaKTSehvpkAM7ogKA6GPVxaM23MMSzjmfsx4o3mey7-VVqu1pDhZJqa0sr7cJNhggIHC5JT_\nAWK简介\n awk是一种模式扫描和处理工具，相对于grep的查找，sed的编辑，它在对数据进行分析生成报表时显得尤为强大。awk通过逐行遍历一个或多个文件的方式，查找模式匹配到的行，而后以指定的分隔符（缺省为空格）进行切片，然后针对切片数据进行处理和分析。事实上，gawk有自己的语言，其本身就相当于一个解释器，允许用户创建简短的程序读取输入文件，对输入数据执行排序、计算以及生成报表操作，甚至可以类似bash shell实现诸如循环、数组、条件判断、函数、变量等功能，进而完成更为复杂的数据分析处理任务。\nawk的使用方式\n1、命令行方式:awk [-F field-separator] ‘COMMAND’inputfiles\n//其中COMMAND是awk的执行命令，用来处理数据，[-F field-separator]是可选选项，inputfiles是待处理文件。\n\n//awk使用中，需要处理的文件，逐行使用分隔符分割成若干个字段，称之为域，分隔符默认是空格，可使用-F选项来指定分隔符\n2、shell脚本模式将所需执行的awk命令插入awk脚本文件，然后在首行设置命令解释器为#!/bin/awk,通过键入脚本名的方式调用。\n3、所有awk命令写入到一个单独的文件，当处理同一类文件需求时，使用awk -f awk-script inputfiles调用之，其中awk-script指awk脚本。\nawk基本用法\nawk[OPTIONS]'program'FILE1 FILE2...\n\nprogram：PATTERN｛ACTION STATEMENT｝\nprogram:编程语言\nPATTERN：模式\nACTION STATEMENT：动作语句，可以有多个语句组成，各语句之间使用分号隔开；如：print，printf\nOPTIONS：\n    -F[]：指明输入字段分隔符\n    -v VAR_NAME=VALUE：变量赋值\n    -f /PATH/FROM/AWK_SCRIPT 指定脚本文件\nawk处理文本按一行读取，根据输入分隔符切片（默认为空格字符），切n个片，然后将每个片赋予awk内部一个变量进行保存，其这个过程变量名为$1,$2,$3...直到最后一个，最后就可以对这些片单独处理。\n\n\nprint输出命令\n输出默认分割符：空白字符\nitem之间逗号分割\nprint \" \" 输出空白字符print $0 输出整行\nawk [options] 'BEGIN{action}pattern{action}END{action}' file\nawk 语法组成： BEGIN语句块，能够使用模式匹配的通用语句块，END语句块\nawk执行时，由分隔符分割的字段（域）标记$1,$2,$n为域标识,$0为所有域\n文件的每一行称为记录\n省略action默认执行print $0操作\n\npattern 模式\naction  动作;行为\nrow column  行,记录\nrecord field 列,域,字段\n案例\n[root@mm ~]#echo -e \"hello,world \\nhello world\" >1.sh\n基本输出\n[root@mm ~]#awk '{print $1}' 1.sh\n引号的作用\n[root@mm ~]#awk '{print \"hi\",$1}' 1.sh\n[root@mm ~]#awk '{print \"hi:$1\"}' 1.sh\n[root@mm ~]#awk '{print \"hi:$1\",666}' 1.sh\n空白输出\n[root@mm ~]#awk '{print}' 1.sh\n[root@mm ~]#awk '{print \"\"}' 1.sh\nawk默认从键盘输入，不管输入什么，输出都是hello\n变量\n内置变量：\nFS：输出字段分割符，默认空白\nRS：输入时的行分割符，默认换行符\nOFS：输出时的字段分割符，默认空白字符\nORS：输出时的行分割符，默认换行符\nNF\n    print NF：当前行的字段数\n    print $NF：显示当前行的第NF字段的值\nNR：行数；命令后跟的所有文件统一合并计算\nFNR：行数；个文件单独计数\nFILENAME：当前正被awk读取的文件名\nARGC：awk命令行中的参数个数\nARGV：数组，保存命令行参数本身\n自定义变量：\n\nawk -F: 'END{print NF}' /etc/passwd #表示以:分割的有7段(显示总字段)\nawk -F: '{print $(NF-1)}' /etc/passwd #取出最后一个字段的\nawk -F: '{print NR,$1}' /etc/passwd #显示行号\nawk '{print NR,$0}' /etc/issue /etc/fstab #两个文件合并显示行号\nawk '{print FNR,$0}' /etc/issue /etc/fstab #两个文件分开显示行号\nawk '{print FNR,$0,FILENAME}' /etc/issue /etc/fstab 显示文件名(FILENAME)\n\nawk 'BEGIN{print ARGC}' /etc/issue /etc/fstab /etc/passwd #显示给的参数个数(BEGIN只显示一个参数)\nawk 'BEGIN{print ARGC,ARGV[2]}' /etc/issue /etc/fstab /etc/passwd #根据参数的个数(索引)取出文件名([0]下标是awk)\nawk 'BEGIN{print ARGC,ARGV[ARGC-2]}' /etc/issue /etc/fstab /etc/passwd #倒着显示给的参数\nawk '{sex=\"male\";print sex}' /etc/passwd #打印变量自定义sex\nawk 'END{sex=\"male\";print sex}' /etc/passwd #打印最后一个sex\nawk '{sex=\"male\";age=20;print sex,age}' /etc/passwd  #必须先定义再使用，不然第一个定义不到\n案例\n[root@mm ~]#awk -F, '{print $1}' 1.sh\n[root@mm ~]#awk -v FS=',' '{print $1}' 1.sh\n[root@mm ~]#awk -v FS=',' '{print $1,$2}' 1.sh\n[root@mm ~]#awk -v FS=',' -v OFS='&' '{print $1,$2}' 1.sh\n[root@mm ~]#awk -v RS=' ' '{print $1}' 1.sh\n[root@mm ~]#awk -v RS=' ' -v ORS='-' '{print}' 1.sh\n[root@mm ~]#awk '{print NF}' 1.sh\n[root@mm ~]#awk '{print $NF}' 1.sh\n[root@mm ~]#awk '{print NR}' 1.sh 2.sh\n[root@mm ~]#awk '{print FNR}' 1.sh 2.sh\n[root@mm ~]#awk '{print FILENAME}' 1.sh\n[root@mm ~]#awk '{print ARGC}' 1.sh\n[root@mm ~]#awk '{print ARGV[0]}' 1.sh \n[root@mm ~]#awk '{print ARGV[1]}' 1.sh\n[root@mm ~]#awk -v hi=\"hi bro\" '{print hi}' 1.sh\n[root@mm ~]#awk '{hi=\"hi bro\";print hi}' 1.sh\n\nprintf输出命令\n%c：显示字符ASCLL码\n%d,%i：十进制整数\n%e,%E：科学计数法显示数值\n%f：浮点数\n%g,%G：科学计数法或浮点数 格式显示数值\n%s：字符串\n%u：无符号整数\n%%：%符合本身\n案例\n[root@mm grub.d]#cat /etc/issue\nUser:Centos,UID:6\nUser:Kernel,UID:0    \nUser:, UID:0\nUser:CentOS release 6.6(Final)\nUser:Kernel \\r on an \\m\nUser:\nawk -F: '{printf \"User:%s\\n\",$1}' /etc/issue\nUser:%s\\n表示对后面$1的内容以字符串形式显示，并且在其前面加上User:字符串，同时结尾添加换行符\nawk -F' ' '{printf \"User:%s,UID:%d\\n\",$1,$3}' /etc/issue\nUser:%s,UID:%d\\n表示对后面的$1的内容以字符串的形式显示，对$2后面内容十进制显示，同时结尾添加换行符。\nawk -F' ' '{printf\"User:%-15s,UID:%15d\\n\",$1,$3}' /etc/issue\n左边一栏以左对齐方式显示15个字符长度，右边栏以默认对齐方式右对齐显示15个字符的长度\n[root@mm ~]#awk -F, '{printf \"first record:%s\\n\",$1}' 1.sh\n\n\n三目表达式{条件满足 条件不满足？满足 执行命令:不满足 执行命令;打印%15是占位符($1) %-s是占位符(usertype) n (换行符) :(冒号分割符)}\nawk -F: '{printf \"%s\",$1}' /etc/passwd #%s占位符，%s后加/n换行\nawk  -F: '{printf \"%s %4.2f\\n\",$1,$3}' /etc/passwd #%s是$1占位符；%4.2f指2位小数，$3的占位符\nawk -F: '{printf \"username:%-30s uid:%10d\\n\",$1,$3}' /etc/passwd #username(显示):(分割符)%-30s(%s是$1的占位符并且左对齐-30个字符) uid(显示):%10d(%d是$3的占位符10右对齐)\\n(换行)\",$1,$3\n操作符\na.算数操作符\n    -x：负值\n    +x：转化为数值\nb.字符操作符\nc.赋值操作符\n    =，+=，-=，*=，/=，%=，^=，++，--\nd.比较操作符\n    >，>=，<，<=，==，!=\nawk -F: '!($3>=50){print $3}' /etc/passwd\ne.模式匹配配操作符\n    ~：是否能由右侧指定的模式所匹配\n    ~!：是否不能由右侧指定模式所匹配\nf.逻辑操作符\n    &&：与运算\nawk -F: '$3>=0 && $3<=1000 {print $1}' /etc/passwd\n    ||：或运算\ng.条件表达式\nawk -F: '{$3>=500?usertype=\"Common User\":usertype=\"Sysadmin or Sysuser\";printf \"%15s:%-s\\n\",$1,usertype}' /etc/passwd\nh.函数调用\n案例\n[root@mm ~]#awk -F: '$3>=0 && $3<=1000 {print $1}' /etc/passwd\n[root@mm grub.d]#awk -F: '!($3>=50){print $3}' /etc/passwd\n\n[root@mm grub.d]#awk -F: 'BEGIN{print \"username    uid \\n------------\"}{print $1,$3}END{print\"=========\"}' /etc/passwd\n\nPATTERN模式\n1）empty：空模式，匹配所有行\n2）/Regular Expression/：仅将ACTION应用于能够被Regular Expression所匹配到的行\nawk -F: '/^[ab]/{print $1,$3}' /etc/passwd\n3）relational expression：关系表达式，结果非0或非空字符串为真，否则为假；\nawk -F: '$3>=500{print $1,$3}' /etc/passwd\nawk -F: '$1~/root/{print $1,$3}' /etc/passwd\n4）line ranges：行范围\n5）BEGIN/END\n    BEGIN：格式化前用于输出表头或做一个预处理操作\n    END：格式化后用于输出表尾或做出清理操作\n案例\n常用ACTION\n1）EXPRESSIONS：变量赋值\n2）Control Statements：控制语句\n3）Compound Statements：复合语句\n4）input statements\n5）output statements \n控制语句\n第一中用法：\n1）if-else\nawk -F: '{if($3>=500)print $1,$3}' /etc/passwd\n[root@mm ~]#awk '{if(NF>=6)print NF,$0}' /etc/passwd\n[root@mm ~]#awk '{if(NF>=6)print NF,$0}' /etc/passwd\n[root@mm ~]#awk -F: '{if($3>=500){print $1,\"is a common user\"} else {print $1,\"is a sysadmin or sysuser\"}}' /etc/passwd\n2）while 循环\nawk '{i=1;while(i<=NF){if(length($i)>=6){print $i};i++}}' /etc/passwd\n3）do-while 循环\n4）for 循环\nawk '{for(i=1;i<=NF;i++){if(length($i)>=6)print $i}}' /etc/issue\n第二中用法：\n5）swtich                                                                                    \n6）break and continue\n7）next：提前结束本行处理；提前进入下行处理操作\nawk -F: '{if($3%2==0)next;print $1,$3}' /etc/passwd\n数组\n关联数组\n    index-expression：可以使用任意字符\n数组遍历\n函数\n1）内建函数\n数值处理：rand():返回0至1之间的一个随机数\n字符串处理：\nlength([s])：返回指定的字符串的长度\nsub(r,s[,t])：\ngsub(r,s[,t])：\nsplit(s,a[,r])：\n2）用户自定义函数 \n经验\n统计指定的web访问日志中各ip的资源访问次数\nawk '{ip[$1]++}END{for(i in ip)print i,ip[i]}' /var/log/httpd/access_log \n统计当前系统上所有tcp连接的各种状态的个数\nss -tan|awk '!/^State/{state[$1]++}END{for(i in state)print i,state[i]}'\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "8"}