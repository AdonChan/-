{"title": "django rest framework个人学习笔记（六）————Tutorial4.认证于授权 - 个人文章 ", "index": "django-rest-framework,python", "content": "官网地址目前，我们的API没有对如 edit 或者 delect做出任何限制。我们希望有一些更加高级的功能能够做到：\n\nCode snippets 应该永远和创建者相关\n只有认证的用户才能够创建snippets\n只有创建者才能更新或者删除他的snippet\n没有认真的用户应该只能读\n\n向我们的model添加内容\n我们对我们的code snippets models做一些修改。首先，我们添加几个字段。其中一个字段用于表示code snippet的创建者。另外一个字段用于储存突出显示的代码的HTML表示形式。添加下列两个字段到 models.py文件中的Snippetmodel。\nowner = models.ForeignKey('auth.User',related_name='snippets',on_delete=models.CASADE)\nhighlighted = models.TextField()\n我们也需要确保，当这个model被保存的时候，我们使用pygments代码高亮库来填充我们的highlighted字段。我们需要导入一些东西：\nfrom pygments.lexers import get_lexer_by_name\nfrom pygments.formatters.html import HtmlFormatter\nfrom pygments import highlight\n然后我们需要为我们的Snippetmodel添加.save()方法\ndef save(self,*args,**kwargs):\n    \"\"\"\n    使用'pygments'库来创建高亮HTML代码的表示\n    \"\"\"\n    lexer = get_lexer_by_name(self.language)\n    linenos = self.linenos and 'table' or False\n    options = self.title and {'title': self.title} or {}\n    formatter = HtmlFormatter(style=self.style, linenos=linenos,\n                              full=True, **options)\n    self.highlighted = highlight(self.code, lexer, formatter)\n    super(Snippet, self).save(*args, **kwargs)\n当所有都昨晚之后，我们需要更新我们的数据库。通常，为了实现这一点，我们会创建数据迁移文件（migration）,但是本教程用于教学，所以我们直接删除数据库并重新创建。\nrm -f db.sqlite3\nrm -r snippets/migrations\npython manage.py makemigrations snippets\npython manage.py migrate\n你也可以创建几个不同的用户来测试我们的API。最快的方式就是使用createsuperuser命令。\npython manage.py createsuperuser\n为我们的User models 添加终端\n现在，我们有一些可用的用户了。我们最好为我们的API添加用户代理。\nfrom django.contrib.auth.models import User\n\nclass UserSerializer(serializer.ModelSerializer):\n    snippets = serializer.PrimaryKeyRelatedField(many=True,queryset=Snippet.objects.all())\n    \n    class Meta:\n        model = User\n        fields = {\"id\",\"username\",\"snippets\"}\n因为snippets是Usermodels 的反向关系，在默认的ModelSerializerclass中，并不会包含这种关系，所以我们需要添加一个明确的字段来表示这个关系。\n我们还需要添加一些view在views.py文件中。我们希望我们的用户表示为只读视图。所以我们使用ListAPIView和RetrieveAPIView通用class-based views.\nfrom django.contrib.auth.models import User\nfrom snippets.Serializers import UserSerializer\n\nclass UserList(generics.ListAPIView):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n   \nclass UserDetail(generics.RetrieveAPIView):\n    queryset = User.object.all()\n    serializer_class = UserSerializer\n最后，我们需要添加我们的视图到API中，添加以下的patterns到urls.py文件中：\nurl(r'^users/$', views.UserList.as_view()),\nurl(r'^users/(?P<pk>[0-9]+)/$', views.UserDetail.as_view()),\n关联User和Snippets\n现在，如果我们创建一个code snippet,我们无法将创建的snippet和创建者关联起来,User数据不是作为序列化的一部分发送的，而是作为request的一个属性.我们处理这个问题的方法是，在我们的snippet views中重写.perform_create()方法,这允许我们修改实例保存的方式,处理任何传入请求和请求url中的参数。在SnippetListview class中，添加如下方法：\ndef perform_create(self,serializer):\n    serializer.save(owner=self.request.user)\n我们的create()序列化方法将会从request中验证通过的数据里添加额外的owner字段。\n更新我们的serializer\n现在，我们的snippet已经和他的创建者关联了。让我们来更新SnippetSerializer来体现这个关联。添加以下的字段在我们的serializers.py文件中：\nowner = serializers.ReadOnlyField(source='owner.username')\n注意：确保你的Meta class的fields中添加了'owner'这个字段做了一个很有趣的事。这个source参数控制哪一个属性用于填充字段，并且可以指向这个序列化实例上的任何属性，它也可以使用.来访问属性下的属性，这类似于django的模板语言.这个字段我们也能够添加ReadOnlyFieldclass,来不同于其他字段，如CharField,BooleanField等...ReadOnlyField永远只能读，并且使用序列化表示，但是当我们反序列化时，不能更新模块。我们也能够使用CharField(read_only=True)\n为我们的视图添加必要的权限\n现在，我们的code snippets 已经和users关联，我们希望确保只有认证的用户才能够创建,更新和删除code snippets。REST framework包含了几种permission class，我们可以使用这些类来限制哪些人有权限使用这些view.在这个案例中，我们需要的是IsAuthenticateOrReadOnly。这将确保认证用户拥有读写权限，而未认证用户只有读的权限。首先，添加以下的内容到views模块。\nfrom rest_framework import permissions\n然后，添加以下的属性到SnippetList和SnippetDetailview classes\npermission_classes = (permissions.IsAuthenticatedOrReadOnly,)\n在我们的Browsable API中添加登录\n如果你打开浏览器并导航到browsable API，你发现你没有登录，不能够创建新的code snippets.为了做到这一点，我们需要用户能够登录。我们能够在我们的browsable API中添加login view，来编写我们的项目级urls.py文件（根urls.py文件）。添加以下内容到文件中：\nfrom django.conf.urls import include\n然后，添加login和logout view在我们的browsable API.\nurlpatterns += [\n    url(r'^api-auth/',include('rest_framework.urls',namespace='rest_framework')),\n]\n事实上，r'^api-auth/'部分，你可以使用任何你想用的url。唯一的限制是namespace必须是rest_framework。在django1.9+中，REST framework将设置namespace，所以你可以把这个限制排除在外。现在，如果你再一次打开浏览器并刷新页面，你将会看到页面的右上角看到登录链接。创建了一些code snippets后，导航到'users/'，在每个user的snippets字段中，都会显示相对应的code snippets。\nObject级别的权限\n我们希望所有用户都能看到所有code snippets，但是只有创建者能够修改或者删除他的code snippets.为了实现这个功能，我们需要创建一个自定义的permission.在snippets app 中，创建一个新文件permissions.py：\nfrom rest_framework import permissions\n\nclass IsOwnerOrReadOnly(permissions.BasePermission):\n    \"\"\"\n    自定义permission 保证只有所有者能够编写。\n    \"\"\"\n    def has_object_permission(self,request,view,obj):\n        #任何请求都拥有读权限\n        #所以我们永远允许GET,HEAD,OPTIONS requests\n        if request.method in permissions.SAFE_METHODS:\n            return True\n        return obj.owner == request.user\n现在，我们将我们自定义的permission添加到snippetDetailview class中：\n    permission_classes = (permissions.IsAuthenticateOrReadOnly,IsOwnerOrReadOnly)\nAPI认证\n因为我们现在为我们的API设置了permission，如果我们需要写任何snippets，我们需要认证我们的请求。我们还没有设置任何身份认证，所以默认的认证是sessionAuthentication和BasucAuthentication.当我们通过浏览器与API交互时，我们可以登录，然后浏览器的session将会为我们的请求提供身份认证。如果我们以编程的方式于API进行交互，我们需要在每个请求上显式地提供身份验证凭证。如果我们尝试创建一个snippet，就会得到一个错误：\nhttp POST http://127.0.0.1:8000/snippets/ code=\"print 123\"\n\n{\n    \"detail\": \"Authentication credentials were not provided.\"\n}\n我们可以包含我们的账户名密码来请求创建：\nhttp -a tom:password123 POST http://127.0.0.1:8000/snippets/ code=\"print 789\"\n\n{\n    \"id\": 1,\n    \"owner\": \"tom\",\n    \"title\": \"foo\",\n    \"code\": \"print 789\",\n    \"linenos\": false,\n    \"language\": \"python\",\n    \"style\": \"friendly\"\n}\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "2"}