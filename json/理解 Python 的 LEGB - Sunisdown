{"title": "理解 Python 的 LEGB - Sunisdown ", "index": "namespaces,legb,python", "content": "理解 Python 的 LEGB\n\n名字空间\n\n\nPython 的名字空间是 Python 一个非常核心的内容。\n其他语言中如 C 中，变量名是内存地址的别名，而在 Python 中，名字是一个字符串对象，它与他指向的对象构成一个{name:object}关联。\nPython 由很多名字空间，而 LEGB 则是名字空间的一种查找规则。\n\n作用域\n\n\nPython 中name-object的关联存储在不同的作用域中，各个不同的作用域是相互独立的。而我们就在不同的作用域中搜索name-object。\n\n举个栗子，来说明作用域是相互独立的。\n\nIn [11]: i = \"G\"\n\nIn [12]: def test():\n            i = \"L\"\n            print i, \"in locals\"\n   ....:\n\nIn [13]: test()\n        L in locals\n\nIn [14]: print i, \"in globals\"\n        G in globals\n\n\n在上面的栗子中，我们定义了两次 i，在 test 函数中是 i-L,在外面是 i-G。为什么在 test 函数中，我们 i 指向的是对象 L，而在外面，i 指向的则是 G？这就是 LEGB 的作用。\n\n简述\n\n\n简而言之，LEGB 代表名字查找顺序: locals -> enclosing function -> globals -> __builtins__\n\n\nlocals 是函数内的名字空间，包括局部变量和形参\nenclosing 外部嵌套函数的名字空间（闭包中常见）\nglobals 全局变量，函数定义所在模块的名字空间\nbuiltins 内置模块的名字空间\n\n所以，在 Python 中检索一个变量的时候，优先回到 locals 里面来检索，检索不到的情况下会检索 enclosing ，enclosing 没有则到 globals 全局变量里面检索，最后是到 builtins 里面来检索。\n\n当然，因为 builtins 的特殊性，我们可以直接在 builtins 里面添加变量，这样就可以在任意模块中访问变量，不过这种方法太过于变态，不推荐这么做。\n\nlocals，globals\n\n\n函数的形参跟内部变量都存储在 locals 中。\n\nIn [1]: def f(x):\n   ...:     a = x\n   ...:     print a\n   ...:     print locals()\n   ...:\n\n\nIn [2]: f(\"hello\")\nhello\n{'a': 'hello', 'x': 'hello'}\n\n\n不过在函数内部调用global 声明的时候，可以将变量存储在 globals 中\n\nIn [6]: def f(x):\n   ...:     global a\n   ...:     a = x\n   ...:     print a\n   ...:     print locals()\n   ...:\n\nIn [7]: f(\"hello\")\nhello\n{'x': 'hello'}\n\nIn [8]: print a\nhello\n\nIn [9]: print x\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\n<ipython-input-9-2d264e11d975> in <module>()\n----> 1 print x\n\nNameError: name 'x' is not defined\n\n\n如上面栗子中那样，在函数中声明 a 为全局变量，则函数 f 的 locals只有参数 x，而没有变量，而在外部可以使用变量 a，而使用 x 的时候则是NameError\n\nEnclosed\n\n\nEnclosing 是外部嵌套函数的名字空间。我们经常在闭包中用到。在 Python3中提供了一个 nonlocal关键字来修改外部嵌套函数的名字空间，但是要使用 Python3才有，我等使用 Python2的只能眼馋一下。\n\nIn [11]: def outer():\n   ....:     a_var = 'enclosed value'\n   ....:     print a_var\n   ....:     def inner():\n   ....:         a_var = 'local value'\n   ....:         print(a_var)\n   ....:     inner()\n   ....:     print a_var\n   ....:\n\nIn [12]: outer()\nenclosed value\nlocal value\nenclosed value\n\n\n下面的栗子简单示范一下 nonlocal 的用法，实在 Python3下面才可以正常运行的：\n\nIn [1]: a_var = 'global value'\n\nIn [2]: def outer():\n   ...:     a_var = \"local value\"\n   ...:     print(\"outer befor\", a_var)\n   ...:     def inner():\n   ...:         nonlocal a_var\n   ...:         a_var = \"inner value\"\n   ...:         print(\"in inner():\", a_var)\n   ...:     inner()\n   ...:     print(\"outer inner:\", a_var)\n   ...:\n\nIn [3]: outer()\nouter befor local value\nin inner(): inner value\nouter inner: inner value\n\nIn [4]: print(a_var)\nglobal value\n\n\nbuiltins\n\n\nbuiltins 则是内置模块，轻易不要修改\n\nIn [19]: b\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\n<ipython-input-19-3b5d5c371295> in <module>()\n----> 1 b\n\nNameError: name 'b' is not defined\n\nIn [20]: __builtins__.b = \"builtins\"\n\nIn [21]: b\nOut[21]: 'builtins'\n\n\n上面栗子中在第一次调用b的时候报错NameError，之后我们修改 builtins 的名字空间，将名字b与值\"builtins\"进行关联，就可以正常调用了。这种非常规用法不建议使用。\n\n                ", "mainLikeNum": ["5 "], "mainBookmarkNum": "10"}