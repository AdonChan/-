{"title": "Theano - 导数 - 数据分析 ", "index": "python3.x,python3.5,python", "content": "计算梯度\n计算x^2的梯度\nimport numpy\nimport theano\nimport theano.tensor as T\nfrom theano import pp\nx = T.dscalar('x')\ny = x ** 2\ngy = T.grad(y, x)\npp(gy)\nf = theano.function([x], gy)\npp(f.maker.fgraph.outputs[0])\nf(4)\nnumpy.allclose(f(94.2), 188.4)\n计算逻辑函数的梯度\nx = T.dmatrix('x')\ns = T.sum(1 / (1 + T.exp(-x)))\ngs = T.grad(s, x)\ndlogistic = theano.function([x], gs)\ndlogistic([[0, 1], [-1, -2]])\n计算Jacobian\nx = T.dvector('x')\ny = x ** 2\nJ, updates = theano.scan(lambda i, y, x: T.grad(y[i], x), sequences=T.arange(y.shape[0]), non_sequences=[y,x])\nf = theano.function([x], J, updates=updates)\nf([4, 4])\n计算Hessian矩阵\nx = T.dvector('x')\ny = x ** 2\ncost = y.sum()\ngy = T.grad(cost, x)\nH, updates = theano.scan(lambda i, gy, x: T.grad(gy[i], x), sequences=T.arange(gy.shape[0]), non_sequences=[gy,x])\nf = theano.function([x], H, updates=updates)\nf([4,4])\nJacobian times a Vector\n右算子(R-operator)\nW = T.dmatrix('W')\nV = T.dmatrix('V')\nx = T.dvector('x')\ny = T.dot(x, W)\nJV = T.Rop(y, W, V)\nf = theano.function([W, V, x], JV)\nf([[1,1], [1,1]], [[2,2], [2,2]], [0,1])\n左算子（L-operator)\nW = T.dmatrix('W')\nv = T.dvector('v')\nx = T.dvector('x')\ny = T.dot(x, W)\nVJ = T.Lop(y, W, v)\nf = theano.function([v, x], VJ)\nf([2,2], [0,1])\nHessian times a Vector\nx = T.dvector('x')\nv = T.dvector('v')\ny = T.sum(x ** 2)\ngy = T.grad(y, x)\nvH = T.grad(T.sum(gy * v), x)\nf = theano.function([x,v], vH)\nf([4,4], [2,2])\n右算子\nx = T.dvector('x')\nv = T.dvector('v')\ny = T.sum(x ** 2)\ngy = T.grad(y, x)\nHv = T.Rop(gy, x, v)\nf = theano.function([x,v], Hv)\nf([4,4], [2,2])\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}