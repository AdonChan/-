{"title": "python 数据模型 - 终南山下 ", "index": "python", "content": "Python数据模型\n\n数据模型是对Python框架的描述,它规范了这门语言自身构建模块的接口, 这些模块包括但不限于序列, 迭代器, 函数, 类和上下文管理器.\nPython解释器遇到特殊方法时,会使用特殊方法去激活一些基本的对象操作,这些特殊方法以双下划线开头,以双下划线结尾(例如: __getitem__)\n比如 obj[key]的背后就是__getitem__方法,为了能求得my_collection[key]的值, 解释器实际会调用my_collection.__getitem__(key)\n\nex1:__getitem__ 和 __len__方法\n#!/usr/bin/env python\n# coding=utf-8\n\nimport collections\n\n\nCard = collections.namedtuple('Card', ['rank', 'suit'])\n\nclass FrenchDeck:\n    \"\"\"\n    通过实现特殊方法利用python数据模型的好处:\n    1. 作为你类的用户, 他们不必去记住标准操作的各式名称('怎么得到元素的总和?.size()还是.length()还是别的什么')\n    2. 可以更加方便的利用Python的标准库,比如random.choice函数,从而不用重复发明轮子.\n    \"\"\"\n    ranks = [str(n) for n in range(2, 11)] + list('JQKA')\n    suits = 'spades diamonds clubs hearts'.split()\n\n    def __init__(self):\n        self._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks]\n\n    def __len__(self):\n        return len(self._cards)\n\n    def __getitem__(self, position):\n        return self._cards[position]\n\nbeer_card = Card('7', 'diamonds')\nprint(beer_card)\ndeck = FrenchDeck()\nprint(len(deck))  # 总牌数\n\nprint(deck[0])  # 第一张牌\nprint(deck[-1])  # 最后一张牌\n\n\nfrom random import choice\nprint(choice(deck))  # 随机抽取\n\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}