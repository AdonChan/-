{"title": "Flask中的请求上下文和应用上下文 - 个人文章 ", "index": "flask,python", "content": "在Flask中处理请求时，应用会生成一个“请求上下文”对象。整个请求的处理过程，都会在这个上下文对象中进行。这保证了请求的处理过程不被干扰。处理请求的具体代码如下：\ndef wsgi_app(self, environ, start_response):\n    with self.request_context(environ):\n        # with语句中生成一个`response`对象\n        ...\n    return response(environ, start_response)\n在Flask 0.9版本之前，应用只有“请求上下文”对象，它包含了和请求处理相关的信息。同时Flask还根据werkzeug.local模块中实现的一种数据结构LocalStack用来存储“请求上下文”对象。这在{% post_link 一个Flask应用运行过程剖析 一个Flask应用运行过程剖析 %}中有所介绍。在0.9版本中，Flask又引入了“应用上下文”的概念。本文主要Flask中的这两个“上下文”对象。\nLocalStack\n在介绍“请求上下文”和“应用上下文”之前，我们对LocalStack简要做一个回顾。在Werkzeug库——local模块一文中，我们讲解了werkzeug.local模块中实现的三个类Local、LocalStack和LocalProxy。关于它们的概念和详细介绍，可以查看上面的文章。这里，我们用一个例子来说明Flask中使用的一种数据结构LocalStack。\n>>> from werkzeug.local import LocalStack\n>>> import threading\n\n# 创建一个`LocalStack`对象\n>>> local_stack = LocalStack()\n# 查看local_stack中存储的信息\n>>> local_stack._local.__storage__\n{}\n\n# 定义一个函数，这个函数可以向`LocalStack`中添加数据\n>>> def worker(i):\n        local_stack.push(i)\n\n# 使用3个线程运行函数`worker`\n>>> for i in range(3):\n        t = threading.Thread(target=worker, args=(i,))\n        t.start()\n\n# 再次查看local_stack中存储的信息\n>>> local_stack._local.__storage__\n{<greenlet.greenlet at 0x4bee5a0>: {'stack': [2]},\n <greenlet.greenlet at 0x4bee638>: {'stack': [1]},\n <greenlet.greenlet at 0x4bee6d0>: {'stack': [0]}\n}\n由上面的例子可以看出，存储在LocalStack中的信息以字典的形式存在：键为线程/协程的标识数值，值也是字典形式。每当有一个线程/协程上要将一个对象push进LocalStack栈中，会形成如上一个“键-值”对。这样的一种结构很好地实现了线程/协程的隔离，每个线程/协程都会根据自己线程/协程的标识数值确定存储在栈结构中的值。\nLocalStack还实现了push、pop、top等方法。其中top方法永远指向栈顶的元素。栈顶的元素是指当前线程/协程中最后被推入栈中的元素，即local_stack._local.stack[-1](注意，是stack键对应的对象中最后被推入的元素)。\n请求上下文\nFlask中所有的请求处理都在“请求上下文”中进行，在它设计之初便就有这个概念。由于0.9版本代码比较复杂，这里还是以0.1版本的代码为例进行说明。本质上这两个版本的“请求上下文”的运行原理没有变化，只是新版本增加了一些功能，这点在后面再进行解释。\n请求上下文——0.1版本\n# Flask v0.1\nclass _RequestContext(object):\n    \"\"\"The request context contains all request relevant information.  It is\n    created at the beginning of the request and pushed to the\n    `_request_ctx_stack` and removed at the end of it.  It will create the\n    URL adapter and request object for the WSGI environment provided.\n    \"\"\"\n\n    def __init__(self, app, environ):\n        self.app = app\n        self.url_adapter = app.url_map.bind_to_environ(environ)\n        self.request = app.request_class(environ)\n        self.session = app.open_session(self.request)\n        self.g = _RequestGlobals()\n        self.flashes = None\n\n    def __enter__(self):\n        _request_ctx_stack.push(self)\n\n    def __exit__(self, exc_type, exc_value, tb):\n        # do not pop the request stack if we are in debug mode and an\n        # exception happened.  This will allow the debugger to still\n        # access the request object in the interactive shell.\n        if tb is None or not self.app.debug:\n            _request_ctx_stack.pop()\n由上面“请求上下文”的实现可知：\n\n“请求上下文”是一个上下文对象，实现了__enter__和__exit__方法。可以使用with语句构造一个上下文环境。\n进入上下文环境时，_request_ctx_stack这个栈中会推入一个_RequestContext对象。这个栈结构就是上面讲的LocalStack栈。\n推入栈中的_RequestContext对象有一些属性，包含了请求的的所有相关信息。例如app、request、session、g、flashes。还有一个url_adapter，这个对象可以进行URL匹配。\n在with语句构造的上下文环境中可以进行请求处理。当退出上下文环境时，_request_ctx_stack这个栈会销毁刚才存储的上下文对象。\n\n以上的运行逻辑使得请求的处理始终在一个上下文环境中，这保证了请求处理过程不被干扰，而且请求上下文对象保存在LocalStack栈中，也很好地实现了线程/协程的隔离。\n以下是一个简单的例子：\n# example - Flask v0.1\n>>> from flask import Flask, _request_ctx_stack\n>>> import threading\n>>> app = Flask(__name__)\n# 先观察_request_ctx_stack中包含的信息\n>>> _request_ctx_stack._local.__storage__\n{}\n\n# 创建一个函数，用于向栈中推入请求上下文\n# 本例中不使用`with`语句\n>>> def worker():\n        # 使用应用的test_request_context()方法创建请求上下文\n        request_context = app.test_request_context()\n        _request_ctx_stack.push(request_context)\n\n# 创建3个进程分别执行worker方法\n>>> for i in range(3):\n        t = threading.Thread(target=worker)\n        t.start()\n\n# 再观察_request_ctx_stack中包含的信息\n>>> _request_ctx_stack._local.__storage__\n{<greenlet.greenlet at 0x5e45df0>: {'stack': [<flask._RequestContext at 0x710c668>]},\n <greenlet.greenlet at 0x5e45e88>: {'stack': [<flask._RequestContext at 0x7107f28>]},\n <greenlet.greenlet at 0x5e45f20>: {'stack': [<flask._RequestContext at 0x71077f0>]}\n}\n上面的结果显示：_request_ctx_stack中为每一个线程创建了一个“键-值”对，每一“键-值”对中包含一个请求上下文对象。如果使用with语句，在离开上下文环境时栈中销毁存储的上下文对象信息。\n请求上下文——0.9版本\n在0.9版本中，Flask引入了“应用上下文”的概念，这对“请求上下文”的实现有一定的改变。这个版本的“请求上下文”也是一个上下文对象。在使用with语句进入上下文环境后，_request_ctx_stack会存储这个上下文对象。不过与0.1版本相比，有以下几点改变：\n\n请求上下文实现了push、pop方法，这使得对于请求上下文的操作更加的灵活；\n伴随着请求上下文对象的生成并存储在栈结构中，Flask还会生成一个“应用上下文”对象，而且“应用上下文”对象也会存储在另一个栈结构中去。这是两个版本最大的不同。\n\n我们先看一下0.9版本相关的代码：\n# Flask v0.9\ndef push(self):\n    \"\"\"Binds the request context to the current context.\"\"\"\n    top = _request_ctx_stack.top\n    if top is not None and top.preserved:\n        top.pop()\n\n    # Before we push the request context we have to ensure that there\n    # is an application context.\n    app_ctx = _app_ctx_stack.top\n    if app_ctx is None or app_ctx.app != self.app:\n        app_ctx = self.app.app_context()\n        app_ctx.push()\n        self._implicit_app_ctx_stack.append(app_ctx)\n    else:\n        self._implicit_app_ctx_stack.append(None)\n\n    _request_ctx_stack.push(self)\n\n    self.session = self.app.open_session(self.request)\n    if self.session is None:\n        self.session = self.app.make_null_session()\n我们注意到，0.9版本的“请求上下文”的pop方法中，当要将一个“请求上下文”推入_request_ctx_stack栈中的时候，会先检查另一个栈_app_ctx_stack的栈顶是否存在“应用上下文”对象或者栈顶的“应用上下文”对象的应用是否是当前应用。如果不存在或者不是当前对象，Flask会自动先生成一个“应用上下文”对象，并将其推入_app_ctx_stack中。\n我们再看离开上下文时的相关代码：\n# Flask v0.9\ndef pop(self, exc=None):\n    \"\"\"Pops the request context and unbinds it by doing that.  This will\n    also trigger the execution of functions registered by the\n    :meth:`~flask.Flask.teardown_request` decorator.\n\n    .. versionchanged:: 0.9\n       Added the `exc` argument.\n    \"\"\"\n    app_ctx = self._implicit_app_ctx_stack.pop()\n\n    clear_request = False\n    if not self._implicit_app_ctx_stack:\n        self.preserved = False\n        if exc is None:\n            exc = sys.exc_info()[1]\n        self.app.do_teardown_request(exc)\n        clear_request = True\n\n    rv = _request_ctx_stack.pop()\n    assert rv is self, 'Popped wrong request context.  (%r instead of %r)' \\\n        % (rv, self)\n\n    # get rid of circular dependencies at the end of the request\n    # so that we don't require the GC to be active.\n    if clear_request:\n        rv.request.environ['werkzeug.request'] = None\n\n    # Get rid of the app as well if necessary.\n    if app_ctx is not None:\n        app_ctx.pop(exc)\n上面代码中的细节先不讨论。注意到当要离开以上“请求上下文”环境的时候，Flask会先将“请求上下文”对象从_request_ctx_stack栈中销毁，之后会根据实际的情况确定销毁“应用上下文”对象。\n以下还是以一个简单的例子进行说明：\n# example - Flask v0.9\n>>> from flask import Flask, _request_ctx_stack, _app_ctx_stack\n>>> app = Flask(__name__)\n\n# 先检查两个栈的内容\n>>> _request_ctx_stack._local.__storage__\n{}\n>>> _app_ctx_stack._local.__storage__\n{}\n\n# 生成一个请求上下文对象\n>>> request_context = app.test_request_context()\n>>> request_context.push()\n\n# 请求上下文推入栈后，再次查看两个栈的内容\n>>> _request_ctx_stack._local.__storage__\n{<greenlet.greenlet at 0x6eb32a8>: {'stack': [<RequestContext 'http://localhost/' [GET] of __main__>]}}\n>>> _app_ctx_stack._local.__storage__\n{<greenlet.greenlet at 0x6eb32a8>: {'stack': [<flask.ctx.AppContext at 0x5c96a58>]}}\n\n>>> request_context.pop()\n\n# 销毁请求上下文时，再次查看两个栈的内容\n>>> _request_ctx_stack._local.__storage__\n{}\n>>> _app_ctx_stack._local.__storage__\n{}\n应用上下文\n上部分中简单介绍了“应用上下文”和“请求上下文”的关系。那什么是“应用上下文”呢？我们先看一下它的类：\nclass AppContext(object):\n    \"\"\"The application context binds an application object implicitly\n    to the current thread or greenlet, similar to how the\n    :class:`RequestContext` binds request information.  The application\n    context is also implicitly created if a request context is created\n    but the application is not on top of the individual application\n    context.\n    \"\"\"\n\n    def __init__(self, app):\n        self.app = app\n        self.url_adapter = app.create_url_adapter(None)\n\n        # Like request context, app contexts can be pushed multiple times\n        # but there a basic \"refcount\" is enough to track them.\n        self._refcnt = 0\n\n    def push(self):\n        \"\"\"Binds the app context to the current context.\"\"\"\n        self._refcnt += 1\n        _app_ctx_stack.push(self)\n\n    def pop(self, exc=None):\n        \"\"\"Pops the app context.\"\"\"\n        self._refcnt -= 1\n        if self._refcnt <= 0:\n            if exc is None:\n                exc = sys.exc_info()[1]\n            self.app.do_teardown_appcontext(exc)\n        rv = _app_ctx_stack.pop()\n        assert rv is self, 'Popped wrong app context.  (%r instead of %r)' \\\n            % (rv, self)\n\n    def __enter__(self):\n        self.push()\n        return self\n\n    def __exit__(self, exc_type, exc_value, tb):\n        self.pop(exc_value)\n由以上代码可以看出：“应用上下文”也是一个上下文对象，可以使用with语句构造一个上下文环境，它也实现了push、pop等方法。“应用上下文”的构造函数也和“请求上下文”类似，都有app、url_adapter等属性。“应用上下文”存在的一个主要功能就是确定请求所在的应用。\n然而，以上的论述却又让人产生这样的疑问：既然“请求上下文”中也包含app等和当前应用相关的信息，那么只要调用_request_ctx_stack.top.app或者魔法current_app就可以确定请求所在的应用了，那为什么还需要“应用上下文”对象呢？对于单应用单请求来说，使用“请求上下文”确实就可以了。然而，Flask的设计理念之一就是多应用的支持。当在一个应用的请求上下文环境中，需要嵌套处理另一个应用的相关操作时，“请求上下文”显然就不能很好地解决问题了。如何让请求找到“正确”的应用呢？我们可能会想到，可以再增加一个请求上下文环境，并将其推入_request_ctx_stack栈中。由于两个上下文环境的运行是独立的，不会相互干扰，所以通过调用_request_ctx_stack.top.app或者魔法current_app也可以获得当前上下文环境正在处理哪个应用。这种办法在一定程度上可行，但是如果对于第二个应用的处理不涉及到相关请求，那也就无从谈起“请求上下文”。\n为了应对这个问题，Flask中将应用相关的信息单独拿出来，形成一个“应用上下文”对象。这个对象可以和“请求上下文”一起使用，也可以单独拿出来使用。不过有一点需要注意的是：在创建“请求上下文”时一定要创建一个“应用上下文”对象。有了“应用上下文”对象，便可以很容易地确定当前处理哪个应用，这就是魔法current_app。在0.1版本中，current_app是对_request_ctx_stack.top.app的引用，而在0.9版本中current_app是对_app_ctx_stack.top.app的引用。\n下面以一个多应用的例子进行说明：\n# example - Flask v0.9\n>>> from flask import Flask, _request_ctx_stack, _app_ctx_stack\n# 创建两个Flask应用\n>>> app = Flask(__name__)\n>>> app2 = Flask(__name__)\n# 先查看两个栈中的内容\n>>> _request_ctx_stack._local.__storage__\n{}\n>>> _app_ctx_stack._local.__storage__\n{}\n# 构建一个app的请求上下文环境，在这个环境中运行app2的相关操作\n>>> with app.test_request_context():\n        print \"Enter app's Request Context:\"\n        print _request_ctx_stack._local.__storage__\n        print _app_ctx_stack._local.__storage__\n        print\n        with app2.app_context():\n            print \"Enter app2's App Context:\"\n            print _request_ctx_stack._local.__storage__\n            print _app_ctx_stack._local.__storage__\n            print\n            # do something\n        print \"Exit app2's App Context:\"\n        print _request_ctx_stack._local.__storage__\n        print _app_ctx_stack._local.__storage__\n        print\n# Result\nEnter app's Request Context:\n{<greenlet.greenlet object at 0x000000000727A178>: {'stack': [<RequestContext 'http://localhost/' [GET] of __main__>]}}\n{<greenlet.greenlet object at 0x000000000727A178>: {'stack': [<flask.ctx.AppContext object at 0x0000000005DD0DD8>]}}\n\nEnter app2's App Context:\n{<greenlet.greenlet object at 0x000000000727A178>: {'stack': [<RequestContext 'http://localhost/' [GET] of __main__>]}}\n{<greenlet.greenlet object at 0x000000000727A178>: {'stack': [<flask.ctx.AppContext object at 0x0000000005DD0DD8>, <flask.ctx.AppContext object at 0x0000000007313198>]}}\n\nExit app2's App Context\n{<greenlet.greenlet object at 0x000000000727A178>: {'stack': [<RequestContext 'http://localhost/' [GET] of __main__>]}}\n{<greenlet.greenlet object at 0x000000000727A178>: {'stack': [<flask.ctx.AppContext object at 0x0000000005DD0DD8>]}}\n在以上的例子中：\n\n我们首先创建了两个Flask应用app和app2；\n接着我们构建了一个app的请求上下文环境。当进入这个环境中时，这时查看两个栈的内容，发现两个栈中已经有了当前请求的请求上下文对象和应用上下文对象。并且栈顶的元素都是app的请求上下文和应用上下文；\n之后，我们再在这个环境中嵌套app2的应用上下文。当进入app2的应用上下文环境时，两个上下文环境便隔离开来，此时再查看两个栈的内容，发现_app_ctx_stack中推入了app2的应用上下文对象，并且栈顶指向它。这时在app2的应用上下文环境中，current_app便会一直指向app2；\n当离开app2的应用上下文环境，_app_ctx_stack栈便会销毁app2的应用上下文对象。这时查看两个栈的内容，发现两个栈中只有app的请求的请求上下文对象和应用上下文对象。\n最后，离开app的请求上下文环境后，两个栈便会销毁app的请求的请求上下文对象和应用上下文对象，栈为空。\n\n与上下文对象有关的“全局变量”\n在Flask中，为了更加方便地处理一些变量，特地提出了“全局变量”的概念。这些全局变量有：\n# Flask v0.9\n_request_ctx_stack = LocalStack()\n_app_ctx_stack = LocalStack()\ncurrent_app = LocalProxy(_find_app)\nrequest = LocalProxy(partial(_lookup_object, 'request'))\nsession = LocalProxy(partial(_lookup_object, 'session'))\ng = LocalProxy(partial(_lookup_object, 'g'))\n\n# 辅助函数\ndef _lookup_object(name):\n    top = _request_ctx_stack.top\n    if top is None:\n        raise RuntimeError('working outside of request context')\n    return getattr(top, name)\n\n\ndef _find_app():\n    top = _app_ctx_stack.top\n    if top is None:\n        raise RuntimeError('working outside of application context')\n    return top.app\n可以看出，Flask中使用的一些“全局变量”，包括current_app、request、session、g等都来自于上下文对象。其中current_app一直指向_app_ctx_stack栈顶的“应用上下文”对象，是对当前应用的引用。而request、session、g等一直指向_request_ctx_stack栈顶的“请求上下文”对象，分别引用请求上下文的request、session和g。不过，从 Flask 0.10 起，对象 g 存储在应用上下文中而不再是请求上下文中。\n另外一个问题，在形成这些“全局变量”的时候，使用了werkzeug.local模块的LocalProxy类。之所以要用该类，主要是为了动态地实现对栈顶元素的引用。如果不使用这个类，在生成上述“全局变量”的时候，它们因为指向栈顶元素，而栈顶元素此时为None，所以这些变量也会被设置为None常量。后续即使有上下文对象被推入栈中，相应的“全局变量”也不会发生改变。为了动态地实现对栈顶元素的引用，这里必须使用werkzeug.local模块的LocalProxy类。\n\n                ", "mainLikeNum": ["4 "], "mainBookmarkNum": "9"}