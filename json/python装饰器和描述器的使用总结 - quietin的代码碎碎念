{"title": "python装饰器和描述器的使用总结 - quietin的代码碎碎念 ", "index": "python", "content": "被某些中文教程坑过，我的建议是有问题看官方文档，即使没有很详细的例子，至少不坑\n装饰器\n毫无疑问在python中用得非常多\ndef deco(func):\n    def _deco():\n        print 'before invoked'\n        func()\n        print 'after invoked'\n    return _deco\n\n@deco\ndef f():\n    print 'f is invoked'\n在f上加deco装饰器相当于f = deco(f), 和functools.partial有些类似\n如果被装饰的函数f带参数且有返回值\ndef deco(func):\n    def _deco(*args, **kwargs):\n        print 'before invoked'\n        ret = func(*args, **kwargs)\n        print 'after invoded'\n        return ret\n    return _deco\n\n@deco\ndef f(a):\n    print 'f is invoked'\n    return a + 1\n如果装饰器带有参数，需要多包一层，把参数调用包进去\ndef deco(*args):\n    def _deco(func):\n        def __deco(*args, **kwargs):\n            print 'decorator args is', args\n            print 'before invoked'\n            ret = func(*args, **kwargs)\n            print 'after invoded'\n            return ret\n        return __deco\n    return _deco\n   \n@deco('test')\ndef f(a):\n    print 'f is invoked'\n    return a + 1\n只有最里面一层的__deco才会每次都调用，其它外层函数只在包装时调用一次，当然，你可以在其中声明变量，然后拿到__deco里使用。如果需要保留函数名，则在__deco上加@functools.wraps装饰器\n使用 类 作装饰器，注意是类此时相当于装饰函数，被装饰的函数会作为实例化参数，得到一个类实例，以python wiki上一个做登录检查的代码为例\nclass LoginCheck:\n    def __init__(self, f):\n        self._f = f\n\n    def __call__(self, *args):\n        Status = check_function()\n        if Status is 1:\n            return self._f(*args)\n        else:\n            return alt_function()\n\n\ndef check_function():\n    return test\n\n\ndef alt_function():\n    return 'Sorry - this is the forced behaviour'\n\n\n@LoginCheck\ndef display_members_page():\n    print 'This is the members page'\n描述器\n描述器在监视特定属性的时候很有用，其只在新式类中起作用。所有的描述器协议如下：\ndescr.__get__(self, obj, type=None) --> valuedescr.__set__(self, obj, value) --> Nonedescr.__delete__(self, obj) --> None\n如果一个对象同时定义了 __get__() 和 __set__(),它叫做资料描述器(data descriptor)。仅定义了 __get__() 的描述器叫非资料描述器描述器在属性访问时被自动调用。举例来说, obj.x 会在 obj 的字典中找x ,如果x定义了 __get__方法，那么 x.__get__(obj)会依据下面的优先规则被调用\n调用优先级:资料描述器 -> 实例字典 -> 非资料描述器\n常用的描述器就是property了，一般都只实现了__get__的接口先给出一个classmethod的实现和一个用于测试描述器优先级的类\nclass classproperty(object):\n    def __init__(self, func):\n        self.func = func\n\n    def __get__(self, instance, owner):\n        return self.func(owner)\n\n\nclass MyClass(object):\n\n    @classproperty\n    def name(cls):\n        return cls.__name__\n\n    @property\n    def x(self):\n        return self._data\n\n    @x.setter\n    def x(self, value):\n        self._data = value\n\n    @x.deleter\n    def x(self):\n        del self._data\n\n    def __init__(self, val):\n        self._data = val\n        self.x = 3\n        self.name = 'test'\n接下来调用\ns = MyClass(99)\nprint s.x\nprint s.name\nprint s.__dict__\n很明显x是资料描述器，而name不是，所以结果是\n35{'_data': 3, 'name': 'test'}\n如果给classproperty加上__set__，那么就会调用被装饰的name，而不是实例化时实例字典中的name\n一个property的python 实现\nclass Property(object):\n    \"Emulate PyProperty_Type() in Objects/descrobject.c\"\n\n    def __init__(self, fget=None, fset=None, fdel=None, doc=None):\n        self.fget = fget\n        self.fset = fset\n        self.fdel = fdel\n        self.__doc__ = doc\n\n    def __get__(self, obj, objtype=None):\n        if obj is None:\n            return self\n        if self.fget is None:\n            raise AttributeError, \"unreadable attribute\"\n        return self.fget(obj)\n\n    def __set__(self, obj, value):\n        if self.fset is None:\n            raise AttributeError, \"can't set attribute\"\n        self.fset(obj, value)\n\n    def __delete__(self, obj):\n        if self.fdel is None:\n            raise AttributeError, \"can't delete attribute\"\n        self.fdel(obj)\n\n    def getter(self, fget):\n        return type(self)(fget, self.fset, self.fdel, self.__doc__)\n\n    def setter(self, fset):\n        return type(self)(self.fget, fset, self.fdel, self.__doc__)\n\n    def deleter(self, fdel):\n        return type(self)(self.fget, self.fset, fdel, self.__doc__)\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "22"}