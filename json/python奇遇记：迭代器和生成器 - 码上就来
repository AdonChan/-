{"title": "python奇遇记：迭代器和生成器 - 码上就来 ", "index": "python", "content": "来说说迭代器和生成器，还有可迭代对象和生成器表达式。\n之前简单的提到过，一个对象是可迭代的可以理解为能够使用for循环。这样说其实不太准确，某个对象可迭代是因为它内部实现了$__iter__$这个特殊方法。比如在python中，序列类型（列表，元组这些）都是可以迭代的，因为内部都有$__iter__$方法的实现。\n不过，其实我们不用特别的实现$__iter__$方法，只要实现了$__getitem__$方法就可以。这个方法我之前介绍过，实现它之后就可以进行切片以及迭代操作。为什么？因为在对一个对象迭代时如果找不到$__iter__$方法，python会自动去寻找$__getitem__$方法，然后构造一个迭代器，从0开始获取元素。\n说了半天，迭代器又是什么东西？可迭代对象，迭代器，这两个是一样的吗？\n迭代器是实现了$__next__$特殊方法的对象，而可迭代对象实现了$__iter__$方法，如果你需要迭代器能够迭代自身，也需要实现$__iter__$方法。要注意的是，可迭代的对象必须实现$__iter__$方法，但不能实现 $__next__$ 方法。\n在迭代器中实现了$__next__$方法，你就能使用next(data)来依次产出数据，如果此时没有数据了，就会产生异常。像生孩子一样，next一下生一个。\n有点绕是不是，其实，一般只要知道可迭代对象以及它是如何实现的就行了，python 中常常用生成器来代替迭代器，可以说，生成器就是迭代器。因为生成器也实现了$__iter__$和$__next__$方法。\npython中还有一个iter函数用来生成迭代器，比如把一个列表放进去，就可以使用next方法来一个个调用了。\n说了这么多，来看个例子。\ndata = [1, 2, 3, 4]\n\n# data是列表，是个可迭代对象\n# 使用循环迭代\nfor i, j in enumerate(data):\n    print(i, j)\n\n# 生成一个迭代器\nd = iter(data)\n# 调用next\nnext(d)\n# 调用四次之后就会产生异常\n0 1\n1 2\n2 3\n3 4\n\n\n\n\n\n1\n\n\n\n我们来自己实现一个迭代器。\n# 从后往前产出列表中的数据\nclass ReverseList:\n\n    def __init__(self, item):\n       #用range构造一个列表\n        self.list = list(range(item))\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n\n        try:\n            return self.list.pop()\n        except:\n            raise StopIteration\n用一下试试。\ndata = ReverseList(4)\n\n# 调用next，从后往前产出数据\nprint(next(data))\nprint(next(data))\nprint(next(data))\nprint(next(data))\n# 如果继续调用，会产生错误，因为没有数据可产出了\nprint(next(data))\n3\n2\n1\n0\n\n\n\n---------------------------------------------------------------------------\n\nIndexError                                Traceback (most recent call last)\n\n<ipython-input-30-cfc36c66205d> in __next__(self)\n     12         try:\n---> 13             return self.list.pop()\n     14         except:\n\n\nIndexError: pop from empty list\n\n\nDuring handling of the above exception, another exception occurred:\n\n\nStopIteration                             Traceback (most recent call last)\n\n<ipython-input-35-1dd792231191> in <module>()\n      7 print(next(data))\n      8 # 如果继续调用，会产生错误，因为没有数据可产出了\n----> 9 print(next(data))\n\n\n<ipython-input-30-cfc36c66205d> in __next__(self)\n     13             return self.list.pop()\n     14         except:\n---> 15             raise StopIteration\n\n\nStopIteration: \n\n\n那什么又是生成器？\n在程序设计中，内存是个很宝贵的东西，占用太多的内存总是不好的，生成器的作用就是我先把你的数据表示出来，但是实际上并不占用内存空间，只有在你调用它时才会占用。一般情况下，比如你定义了一个列表，会自动的使用一段内存空间。\n在 python中，只要定义了yield关键字的函数就是生成器。上面说了，生成器就是迭代器，你可以进行迭代操作（循环），调用next来一个个产出数据。\ndef gen123():\n    yield 1\n    yield 2\n    yield 3\n\nfor i in gen123():\n    print(i)\n\ng = gen123()\nprint(next(g))\n1\n2\n3\n1\n\n\n虽然说生成器就是迭代器，但是在python的定义中，迭代器用来遍历集合，从中产出元素，而生成器无需遍历集合就能生成值，比如range()函数，生成器不仅能够产出集合中的元素，还可以产出派生自元素的其他值。\n我在上一篇文章（Python奇遇记：数据结构窥探2）中提到过生成器表达式，只介绍了一下它的用法，那么生成器表达式是什么东西？\n其实，生成器表达式就是生成器的快速实现而已，类似于之前讲过的具名元组。有些时候需要快速的生成一段数据，使用生成器表达式即可，无需定义函数再调用。\n\n本人才疏学浅，上文中难免有些错误，还请各位品评指正。如果觉得写的还行，欢迎关注我的公众号MLGroup,带你走进机器学习的世界。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "2"}