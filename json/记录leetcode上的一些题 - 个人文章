{"title": "记录leetcode上的一些题 - 个人文章 ", "index": "leetcode,python", "content": "此篇文章最先发布在我的博客mbinary上    记录OJ上的一些题，基本上是leetcode上的题，其他的我会标注出来，用的语言目前是python,写的代码很庸俗，请大神不要见笑(>_<)\n# 2017-8-20\n\nInteger to Roman\n  题目\n\nGiven an integer, convert it to a roman numeral.Input is guaranteed to be within the range from 1 to 3999.罗马数字的规则如下：\n\n罗马数字共有7个，即Ⅰ（1）、Ⅴ（5）、Ⅹ（10）、Ⅼ（50）、Ⅽ（100）、Ⅾ（500）和Ⅿ（1000）。按照下述的规则可以表示任意正整数。需要注意的是罗马数字中没有“0”，与进位制无关。一般认为罗马数字只用来记数，而不作演算。\n\n\n重复数次：一个罗马数字重复几次，就表示这个数的几倍。\n\n右加左减：\n\n在较大的罗马数字的右边记上较小的罗马数字，表示大数字加小数字。\n在较大的罗马数字的左边记上较小的罗马数字，表示大数字减小数字。\n左减的数字有限制，仅限于I、X、C。比如45不可以写成VL，只能是XLV\n左减时不可跨越一个位值。比如，99不可以用IC（ 100-1）表示，而是用XCIX（[100-10]+[10-1]）表示。（等同于阿拉伯数字每位数字分别表示。）\n左减数字必须为一位，比如8写成VIII，而非IIX。\n右加数字不可连续超过三位，比如14写成XIV，而非XIIII。（见下方“数码限制”一项。）\n\n\n\n加线乘千：在罗马数字的上方加上一条横线或者加上下标的Ⅿ，表示将这个数乘以1000，即是原数的1000倍。同理，如果上方有两条横线，即是原数的1000000（ {displaystyle 1000^{2}} 1000^{{2}}）倍。\n\n数码限制：同一数码最多只能连续出现三次，如40不可表示为XXXX，而要表示为XL。例外：由于IV是古罗马神话主神朱庇特（即IVPITER，古罗马字母里没有J和U）的首字，因此有时用IIII代替IV。\n\n\n      思路这道题还是蛮有意思的，同样用递归的方法，在了解拼写规则后，要从数值范围来判断罗马数字的结构，即取哪个字母？哪种组合？左或是右？孪生题是Roman to Interger比较简单  代码\n#python\nclass Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        dic = {0:'',1:'I',5:'V',10:'X',50:'L',100:'C',500:'D',1000:'M'}\n        ks = [1,5,10,50,100,500,1000]\n        \n        def convert(num):\n            if num in dic.keys():\n                return dic[num]\n            if num > 1000:\n                n = int(num/1000)\n                num -= n * 1000\n                return  'M'*n + convert(num)\n            n = 1000\n            for i in ks:\n                if i > num :\n                    n = i\n                    break\n            exp = 1\n            flag = False\n            while exp <= n:   # judge if n is 10 exp k\n                if exp == n:\n                    flag = True\n                    break\n                exp *= 10\n            if flag:\n                small = n / 10\n                if num >= 9 * small:\n                    return dic[small] + dic[n] + convert(small -(n-num)) \n                else:\n                    return dic[n/2] + convert(num - n/2)\n            else:\n                small = n / 5\n                if n - small <= num :\n                    return dic[small] + dic[n] + convert(small - (n-num))\n                else:\n                    n2 = int(num / small)\n                    num -= n2 * small\n                    return dic[small] * n2 + convert(num)\n        return convert(num)             \n\nword search\n  题目\n\n\nGiven a 2D board and a word, find if the word exists in the grid.\nThe word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\n\nFor example,\nGiven board =\n[\n  ['A','B','C','E'],\n  ['S','F','C','S'],\n  ['A','D','E','E']\n]\nword = \"ABCCED\", -> returns true,\nword = \"SEE\", -> returns true,\nword = \"ABCB\", -> returns false.\n     思路这道题可以用递归函数来解决，注意到，eg从“a” 中判断是否有“aa” ，如果直接递归是返回true的，这不对，要就是说在一次判断中，已判断过的字母不能再判断，所以参数应该还有一个board，记录当前的字母状态，考虑到python是用的引用，传递参数时没有复制，我又不想额外再去复制board，就在函数中记下当前位置的字母，在函数调用结束再改回来的。哈哈！  代码\n#python\nclass Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        row = len(board)\n        col = len(board[0])\n        num = len(word)\n        def find(r,c,n):\n            if n == num-1 and board[r][c] == word[n]:\n                return True\n            if board[r][c] != word[n] or n == num-1:\n                return  False\n            tmp = board[r][c]    #save  the  val\n            board[r][c] = 0\n            if r < row-1 and find(r+1,c,n+1):\n                return True\n            if r > 0 and find(r-1,c,n+1):\n                return True\n            if c  0 and find(r,c-1,n+1):\n                return True\n            board[r][c] = tmp\n            return False\n        for i in range(row):\n            for j in range(col):\n                if find(i,j,0):\n                    return True\n        return False\n# 2017-8-19\n\n3 sum\n  题目\n\nGiven an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.Note: The solution set must not contain duplicate triplets.\nFor example, given array S = [-1, 0, 1, 2, -1, -4],\n\nA solution set is:\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]\n    思路最开始我想的就直接3重循环，再加判重的循环，暴力求解，当然超时了，要高于O(n3)。后来想到可以将正负数，0，分成三组来组合，然而最后两个数据过不了，在网上搜了一下，可以固定一个数，头尾双指针来移动，这是O(n2)。哎，折腾了一晚上，我好菜啊。 这是前几次的结果[站外图片上传中……(1)]\n     代码  (分成正负0三组，写了很多判断语句，唉，庸俗的代码。 )\n#python\n\nclass Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        rst = []\n        zero = []   #zeros\n        neg = []    #negative\n        pos = []    #positive\n        for i in (nums):\n            if i < 0:\n                neg.append(i)\n            elif i > 0:\n                pos.append(i)\n            else:\n                zero.append(i)\n        if len(zero) > 2:\n            rst.append([0,0,0])\n        if neg == []  or  pos == []:\n            return rst\n        if zero != []:\n            if len(neg) > len(pos):\n                for i in pos:\n                    if -i in neg:\n                        rst.append([-i,0,i])\n            else:\n                for i in neg:\n                    if -i in pos:\n                        rst.append([i,0,-i])\n        pos.sort()\n        neg.sort()\n        if len(pos) == 1 and len(neg) == 1:\n            return rst\n        elif len(pos) == 1 :\n            tmp = len(neg) - 1\n            while tmp > 0:\n                sum = neg[tmp] + neg[tmp-1]\n                if sum == - pos[0]:\n                    rst.append([neg[tmp-1],neg[tmp],pos[0]])\n                    break\n                elif sum < - pos[0]:\n                    break\n                tmp -= 1\n        elif len(neg) == 1:\n            tmp = 0\n            while tmp < len(pos) - 1 :\n                sum = pos[tmp] + pos[tmp+1]\n                if sum == - neg[0]:\n                    rst.append([neg[0],pos[tmp],pos[tmp+1]])\n                    break\n                elif sum > - neg[0]:\n                    break\n                tmp -= 1\n        sameI = []     #avoid test several same num\n        for i in range(len(pos)-1):\n            if i in sameI:\n                continue\n            sameI.append(i)\n            sameJ=[]\n            for j in range(i+1,len(pos)):\n                if j in sameJ:\n                    continue\n                sameJ.append(j)\n                sum = pos[i] + pos[j]\n                for k in neg:\n                    if   sum > -k:\n                        break\n                    elif sum == -k:\n                        rst.append([k,pos[i],pos[j]])\n        sameI = []\n        for i in range(len(neg)-1):\n            if i in sameI:\n                continue\n            sameI.append(i)\n            sameJ=[]\n            for j in range(i+1,len(neg)):\n                if j in sameJ:\n                    continue\n                sameJ.append(j)\n                sum = neg[i] + neg[j]\n                for k in pos:\n                    if   sum > -k:\n                        break\n                    elif sum == -k:\n                        rst.append([neg[i],neg[j],k])\n        fnl = []   \n        for i in rst:\n            if i not in fnl:\n                fnl.append(i)\n        return fnl \n    代码  (头尾双指针，过了，注意判重的方法，前一个用的if，后面在找到答案时用while)\n#python\nclass Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        rst=[]\n        nums.sort()\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            head = i+1\n            tail = len(nums) - 1\n            while head < tail:\n                if nums[i] + nums[head] + nums[tail]  == 0:\n                    rst.append([nums[i],nums[head],nums[tail]])\n                    head += 1\n                    tail -= 1\n                    while head< tail and nums[head] == nums[head -1]:\n            head = i+1\n            tail = len(nums) - 1\n            while head < tail:\n                if nums[i] + nums[head] + nums[tail]  == 0:\n                    rst.append([nums[i],nums[head],nums[tail]])\n                    head += 1\n                    tail -= 1\n                    while head< tail and nums[head] == nums[head -1]:\n                        head += 1\n                    while head<tail and  tail < len(nums)-1 and nums[tail]== nums[tail +1]:\n                        tail -= 1\n                elif nums[i] + nums[head] + nums[tail]  < 0:\n                    head += 1\n                else:\n                    tail -= 1\n        return rst\n2017-8-17\n\njump game\n  题目    \n\n\nGiven an array of non-negative integers, you are initially positioned at the first index of the array.Each element in the array represents your maximum jump length at that position.Determine if you are able to reach the last index.  \nFor example:\n\nA = [2,3,1,1,4], return true.A = [3,2,1,0,4], return false.      \n    思路由于只有非负数，不能成功的点一定是当前位置为0，所以可以将列表中所以的0找出来，并记下位置（下标），然后从这个位置开始往前搜索，若存在能跳过此位置的点，则能跳过，去除这个0，一直跳过所有0\n    代码\n#python\n    class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n\n        if len(nums) == 1:\n            return True\n        zeros = []\n        for i,j in enumerate(nums):\n            if j == 0:\n                zeros.append(i)\n        while zeros != []:\n            i = zeros[0]\n            tmp = i - 1\n            flag = 0\n            while tmp >= 0:\n                if nums[tmp] > i-tmp  or nums[tmp]+tmp+1 >=len(nums):\n                    flag = 1\n                    break\n                tmp -= 1\n            if flag == 0 :\n                return False\n            del zeros[0]\n            \n        return True\n\n\nsuper pow\n  题目\n\n\nYour task is to calculate ab mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array.\nExample1: a = 2\n\nb = [3] Result: 8\nExample2:\na = 2b = [1,0]Result: 1024\n  思路这道题显然不能直接计算，可以用欧拉定理对任意正整数a,正整数m,(a,m) = 1,ƒ(m) 为比m小的与m互质的(注意不一定是质数)正整数的个数，则 aƒ(m)  ≡ 1 (mod m) 。再利用性质： a ≡ b (mod m) ,c ≡ d (mod m) ,则ac ≡ bd (mod m)  证明就不写了，打数学符号太累了（T^T）,给个传送门吧--> 欧拉定理)\n  代码\n    #python\n    class Solution(object):\n    def superPow(self, a, b):\n        \"\"\"\n        :type a: int\n        :type b: List[int]\n        :rtype: int\n        \"\"\"\n        m = 1337\n        if a % m == 0:\n            return 0\n        sum = 0\n        for i in b:\n            sum = 10 * sum + i    \n        phi = 0\n        for i in range(1,m):\n            if (i % 7 != 0) and (i % 191 != 0):\n                phi += 1\n        sum = sum % phi\n        return (a**sum) % 1337\n        # if m a prime num ,use the small law of Fermat\n        # else use the law of Euler\n    \n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}