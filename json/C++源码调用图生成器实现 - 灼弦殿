{"title": "C++源码调用图生成器实现 - 灼弦殿 ", "index": "c++,源码分析,python", "content": "前言\n之前受知乎用户mailto1587启发，写了个C++源码的调用图生成器，可以以图示法显示C++函数的调用关系，代码放在了github仓库里，仅供参考：CodeSnippet/python/SRCGraphviz/c++ at master · Cheukyin/CodeSnippet · GitHub\n主要思路\n利用gcc/g++的-finstrument-functions的注入选项，得到每个函数的调用地址信息，生成一个trace文件，然后利用addr2line和c++filt将函数名及其所在源码位置从地址中解析出来，从而得到程序的Call Stack，然后用pygraphviz画出来\n使用示例\n比如我现在有A.hpp、B.hpp、C.hpp、ABCTest.cpp这几个文件，我想看他们的Call Graph\n源码如下：\n然后按下面编译(instrument.c在上面github地址中可以下载，用于注入地址信息）：g++ -g -finstrument-functions -O0 instrument.c ABCTest.cpp -o test然后运行程序，得到trace.txt输入shell命令./test最后 输入shell命令python CallGraph.py trace.txt test弹出一张Call Graph\n图上标注含义:\n\n绿线表示程序启动后的第一次调用\n红线表示进入当前上下文的最后一次调用\n每一条线表示一次调用，#符号后面的数字是序号，at XXX表示该次调用发生在这个文件（文件路径在框上方）的第几行\n在圆圈里，XXX:YYY，YYY是调用的函数名，XXX表示这个函数是在该文件的第几行被定义的\n\n获取C/C++调用关系\n利用-finstrument-functions编译选项，可以让编译器在每个函数的开头和结尾注入__cyg_profile_func_enter和 __cyg_profile_func_exit这两个函数的实现由用户定义\n在本例中，只用到__cyg_profile_func_enter，定义在instrument.c中，其函数原型如下:void __cyg_profile_func_enter (void *this_fn, void *call_site);其中this_fn为 被调用的地址，call_site为 调用方的地址\n显然，假如我们把所有的 调用方和被调用方的地址 都打印出来，就可以得到一张完整的运行时Call Graph\n因此，我们的instrument.c实现如下：\n/* Function prototypes with attributes */\nvoid main_constructor( void )\n    __attribute__ ((no_instrument_function, constructor));\n\nvoid main_destructor( void )\n    __attribute__ ((no_instrument_function, destructor));\n\nvoid __cyg_profile_func_enter( void *, void * )\n    __attribute__ ((no_instrument_function));\n\nvoid __cyg_profile_func_exit( void *, void * )\n    __attribute__ ((no_instrument_function));\n\nstatic FILE *fp;\n\nvoid main_constructor( void )\n{\n  fp = fopen( \"trace.txt\", \"w\" );\n  if (fp == NULL) exit(-1);\n}\n\nvoid main_deconstructor( void )\n{\n  fclose( fp );\n}\n\nvoid __cyg_profile_func_enter( void *this_fn, void *call_site )\n{\n    /* fprintf(fp, \"E %p %p\\n\", (int *)this_fn, (int *)call_site); */\n    fprintf(fp, \"%p %p\\n\", (int *)this_fn, (int *)call_site);\n}\n其中main_constructor在 调用main 前执行，main_deconstructor在调用main后执行，以上几个函数的作用就是 将所有的 调用方和被调用方的地址 写入trace.txt中\n然而，现在有一个问题，就是trace.txt中保存的是地址，我们如何将地址翻译成源码中的符号？答案就是用addr2line\n以上面ABCTest.cpp工程为例，比如我们现在有地址0x400974，输入以下命令addr2line 0x400aa4 -e a.out -f结果为\n_ZN1A4AOneEv\n/home/cheukyin/PersonalProjects/CodeSnippet/python/SRCGraphviz/c++/A.hpp:11\n第一行该地址所在的函数名，第二行为函数所在的源码位置\n然而，你一定会问，_ZN1A4AOneEv是什么鬼？为实现重载、命名空间等功能，因此C++有name mangling，因此函数名是不可读的\n我们需要利用c++filt作进一步解析：输入shell命令 addr2line 0x400aa4 -e a.out -f | c++filt结果是不是就清晰很多：\nA::AOne()\n/home/cheukyin/PersonalProjects/CodeSnippet/python/SRCGraphviz/c++/A.hpp:11\n注意这个结果中包含了函数名、函数所在文件和行号\n调用图渲染\n经过上面的步骤，我们已经可以把所有的(调用方, 被调用方)对分析出来了，相当于获取到调用图所有的节点和边，最后可以用pygraphviz将 每一条调用关系 画出来即可，代码用python实现在 CallGraph.py 中\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "2"}