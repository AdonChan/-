{"title": "流畅的python读书笔记-第九章-符合Python风格的对象 - 个人文章 ", "index": "python", "content": "绝对不要使用两个前导下划线，这是很烦人的自私行为。——Ian Bicking\n对象表示形式\nrepr()　　以便于开发者理解的方式返回对象的字符串表示形式。str()　　以便于用户理解的方式返回对象的字符串表示形式。\n制作一个向量类,和第一章的有点类似\n❸ 定义 iter 方法，把 Vector2d 实例变成可迭代的对象，这样才能拆包（例如，x, y = my_vector）。这个方法的实现方式很简单，直接调用生成器表达式一个接一个产出分量。这一行也可以写成 yield self.x; yield.self.y。第 14 章会进一步讨论 iter 特殊方法、生成器表达式和yield 关键字。\n\n❻ print 函数会调用 str 函数，对 Vector2d 来说，输出的是一个有序对。❼ bytes 函数会调用 bytes 方法，生成实例的二进制表示形式。bool 函数会调用 bool 方法，如果 Vector2d 实例的模为零，返回 False，否则返回 True。\n另一种实现\nfrom array import array\nimport math\n\n\nclass Vector2d:\n    typecode = 'd'\n\n    def __init__(self, x, y):\n        self.x = float(x)\n        self.y = float(y)\n\n    def __iter__(self):\n        return (i for i in (self.x, self.y))\n\n    def __repr__(self):\n        class_name = type(self).__name__\n        return '{}({!r}, {!r})'.format(class_name, *self)\n\n    def __str__(self):\n        return str(tuple(self))\n\n    def __bytes__(self):\n        return (bytes([ord(self.typecode)]) +\n                bytes(array(self.typecode, self)))\n\n    def __eq__(self, other):\n        return tuple(self) == tuple(other)\n\n    def __abs__(self):\n        return math.hypot(self.x, self.y)\n\n    def __bool__(self):\n        return bool(abs(self))\n\n❷ 在 init 方法中把 x 和 y 转换成浮点数，尽早捕获错误，以防调用 Vector2d 函数时传入不当参数。❸ 定义 iter 方法，把 Vector2d 实例变成可迭代的对象，这样才能拆包（例如，x, y = my_vector）。这个方法的实现方式很简单，直接调用生成器表达式一个接一个产出分量。这一行也可以写成 yield self.x; yield.self.y。第 14 章会进一步讨论 iter 特殊方法、生成器表达式和yield 关键字。\n'__eq__ 方法'，在两个操作数都是 Vector2d 实例时可用，不过拿 Vector2d 实例与其他具有相同数值的可迭代对象相比，结果也是 True（如Vector(3, 4) == [3, 4]）。这个行为可以视作特性，也可以视作缺陷。\n备选构造方法\n1.把 Vector2d 实例转换成字节序列了；2.同理，也应该能从字节序列转换成Vector2d 实例。3.在标准库中探索一番之后，我们发现 array.array 有个类方法.frombytes（2.9.1 节介绍过）正好符合需求。\n代码如下:\nfrom array import array\nimport math\n\n\nclass Vector2d:\n    typecode = 'd'\n\n    def __init__(self, x, y):\n        self.x = float(x)\n        self.y = float(y)\n\n    def __iter__(self):\n        return (i for i in (self.x, self.y))\n\n    def __repr__(self):\n        class_name = type(self).__name__\n        return '{}({!r}, {!r})'.format(class_name, *self)\n\n    def __str__(self):\n        return str(tuple(self))\n\n    def __bytes__(self):\n        return (bytes([ord(self.typecode)]) +\n                bytes(array(self.typecode, self)))\n\n    def __eq__(self, other):\n        return tuple(self) == tuple(other)\n\n    def __abs__(self):\n        return math.hypot(self.x, self.y)\n\n    def __bool__(self):\n        return bool(abs(self))\n\n    @classmethod\n    def frombytes(cls, octets):\n        typecode = chr(octets[0])\n        memv = memoryview(octets[1:]).cast(typecode)\n        return cls(*memv)\n\n❸ 从第一个字节中读取 typecode。❹ 使用传入的 octets 字节序列创建一个 memoryview，然后使用 typecode 转换。2.9.2 节简单介绍过 memoryview，说明了它的 .cast 方法。❺ 拆包转换后的 memoryview，得到构造方法所需的一对参数。内置的 format() 函数和 str.format() 方法把各个类型的格式化方式委托给相应的.__format__(format_spec) 方法。format_spec 是格式说明符，它是：format(my_obj, format_spec) 的第二个参数，或者str.format() 方法的格式字符串，{} 里代换字段中冒号后面的部分\nclassmethod与staticmethod\n\n定义操作类，而不是操作实例的方法。\nclassmethod 改变了调用方法的方式，因此类方法的第一个参数是类本身，而不是实例。\nclassmethod 最常见的用途是定义备选构造方法，例如示例 9-3 中的frombytes。\n注意，frombytes 的最后一行使用 cls 参数构建了一个新实例，即cls(*memv)。\n我们对 classmethod 的作用已经有所了解（而且知道 staticmethod 不是特别有 用）\n\n9.5　格式化显示\n\n内置的 format() 函数和 str.format() 方法把各个类型的格式化方式委托给相应的.__format__(format_spec) 方法。\nformat_spec 是格式说明符，它是：format(my_obj, format_spec) 的第二个参数，或者str.format() 方法的格式字符串，\n{} 里代换字段中冒号后面的部分\n\n>>> brl = 1/2.43 # BRL到USD的货币兑换比价\n>>> brl\n0.4115226337448559\n>>> format(brl, '0.4f') # ➊\n'0.4115'\n>>> '1 BRL = {rate:0.2f} USD'.format(rate=brl) # ➋\n'1 BRL = 0.41 USD'\n格式规范微语言为一些内置类型提供了专用的表示代码。比如，b 和 x 分别表示二进制和十六进制的 int 类型，f 表示小数形式的 float 类型，而 % 表示百分数形式：\n>>> format(42, 'b')\n'101010'\n>>> format(2/3, '.1%')\n'66.7%'\ndatetime 模块中的类，它们的 format 方法使用的格式代码与 strftime() 函数一样。\n>>> from datetime import datetime\n>>> now = datetime.now()\n>>> format(now, '%H:%M:%S')\n'18:49:05'\n>>> \"It's now {:%I:%M %p}\".format(now)\n\"It's now 06:49 PM\"\n如果类没有定义 format 方法，从 object 继承的方法会返回 str(my_object)。我们为 Vector2d 类定义了 str 方法\n>>> v1 = Vector2d(3, 4)\n>>> format(v1)\n'(3.0, 4.0)'\n向量类做format\nfrom array import array\nimport math\n\n\nclass Vector2d:\n    typecode = 'd'\n\n    def __init__(self, x, y):\n        self.x = float(x)\n        self.y = float(y)\n\n    def __iter__(self):\n        return (i for i in (self.x, self.y))\n\n    def __repr__(self):\n        class_name = type(self).__name__\n        return '{}({!r}, {!r})'.format(class_name, *self)\n\n    def __str__(self):\n        return str(tuple(self))\n\n    def __bytes__(self):\n        return (bytes([ord(self.typecode)]) +\n                bytes(array(self.typecode, self)))\n\n    def __eq__(self, other):\n        return tuple(self) == tuple(other)\n\n    def __abs__(self):\n        return math.hypot(self.x, self.y)\n\n    def __bool__(self):\n        return bool(abs(self))\n\n    @classmethod\n    def frombytes(cls, octets):\n        typecode = chr(octets[0])\n        memv = memoryview(octets[1:]).cast(typecode)\n        return cls(*memv)\n\n    def __format__(self, fmt_spec=''):\n        components = (format(c, fmt_spec) for c in self) # ➊\n        #这里还是有些看不懂,拆包拆出来个啥?\n        return '({}, {})'.format(*components)\n    \n        \n\n\nv1 = Vector2d(3, 4)\nprint(format(v1))\n\nprint(format(v1, '.2f'))\n\nprint(format(v1, '.3e'))\n增强 format 方法，计算极坐标\n我们已经定义了计算模的 abs 方法，因此还要定义一个简单的angle 方法，使用 math.atan2() 函数计算角度\nfrom array import array\nimport math\n\n\nclass Vector2d:\n    typecode = 'd'\n\n    def __init__(self, x, y):\n        self.x = float(x)\n        self.y = float(y)\n\n    def __iter__(self):\n        return (i for i in (self.x, self.y))\n\n    def __repr__(self):\n        class_name = type(self).__name__\n        return '{}({!r}, {!r})'.format(class_name, *self)\n\n    def __str__(self):\n        return str(tuple(self))\n\n    def __bytes__(self):\n        return (bytes([ord(self.typecode)]) +\n                bytes(array(self.typecode, self)))\n\n    def __eq__(self, other):\n        return tuple(self) == tuple(other)\n\n    def __abs__(self):\n        return math.hypot(self.x, self.y)\n\n    def __bool__(self):\n        return bool(abs(self))\n\n    @classmethod\n    def frombytes(cls, octets):\n        typecode = chr(octets[0])\n        memv = memoryview(octets[1:]).cast(typecode)\n        return cls(*memv)\n\n    def angle(self):\n        return math.atan2(self.y, self.x)\n\n    def __format__(self, fmt_spec=''):\n        if fmt_spec.endswith('p'):\n            fmt_spec = fmt_spec[:-1]\n            coords = (abs(self), self.angle())\n            outer_fmt = '<{}, {}>'\n        else:\n            coords = self\n            outer_fmt = '({}, {})'\n        components = (format(c, fmt_spec) for c in coords)\n        return outer_fmt.format(*components)\n\n\nprint(format(Vector2d(1, 1), 'p'))\nprint(format(Vector2d(1, 1), '.3ep'))\nprint(format(Vector2d(1, 1), '0.5fp'))\n\n可散列的Vector2d\n为了把 Vector2d 实例变成可散列的，必须使用 hash 方法（还需要 eq 方法，前面已经实现了）。此外，还要让向量不可变，\n\n目前，我们可以为分量赋新值，如 v1.x = 7，Vector2d 类的代码并不阻止这么做。我们想要的行为是这样的：\n>>> v1.x, v1.y\n(3.0, 4.0)\n>>> v1.x = 7\nTraceback (most recent call last):\n ...\nAttributeError: can't set attribute\n#为此，我们要把 x 和 y 分量设为只读特性，\n不完整代码\nclass Vector2d:\n    typecode = 'd'\n\n    def __init__(self, x, y):\n        self.__x = float(x)\n        self.__y = float(y)\n\n    @property\n    def x(self):\n        return self.__x\n\n    @property\n    def y(self):\n        return self.__y\n\n    def __iter__(self):\n        return (i for i in (self.x, self.y))\n        \n    def __hash__(self):\n        return hash(self.x) ^ hash(self.y)\n\n使用两个前导下划线（尾部没有下划线，或者有一个下划线），把属性标记为私有\n的\n\n@property 装饰器把读值方法标记为特性。\n读值方法与公开属性同名，都是 x。\n使用位运算符异或（^）混合各分量的散列值——我们会这么做\n\n要想创建可散列的类型，不一定要实现特性，也不一定要保护实例属性。只需正确地实现 hash 和 eq 方法即可。但是，实例的散列值绝不应该变化，hash成功了\n>>> v1 = Vector2d(3, 4)\n>>> v2 = Vector2d(3.1, 4.2)\n>>> hash(v1), hash(v2)\n(7, 384307168202284039)\n>>> set([v1, v2])\n{Vector2d(3.1, 4.2), Vector2d(3.0, 4.0)}\n\n\n如果定义的类型有标量数值，可能还要实现 int 和 float 方法（分别被 int()和 float() 构造函数调用），以便在某些情况下用于强制转换类型。\n此外，还有用于支持内置的 complex() 构造函数的 complex 方法。\nVector2d 或许应该提供__complex__ 方法，不过我把它留作练习给读者。\n\n完整的向量类代码\nfrom array import array\nimport math\n\n\nclass Vector2d:\n    typecode = 'd'\n\n    def __init__(self, x, y):\n        self.__x = float(x)\n        self.__y = float(y)\n\n    @property\n    def x(self):\n        return self.__x\n\n    @property\n    def y(self):\n        return self.__y\n\n    def __iter__(self):\n        return (i for i in (self.x, self.y))\n\n    def __repr__(self):\n        class_name = type(self).__name__\n        return '{}({!r}, {!r})'.format(class_name, *self)\n\n    def __str__(self):\n        return str(tuple(self))\n\n    def __bytes__(self):\n        return (bytes([ord(self.typecode)]) +\n                bytes(array(self.typecode, self)))\n\n    def __eq__(self, other):\n        return tuple(self) == tuple(other)\n\n    def __hash__(self):\n        return hash(self.x) ^ hash(self.y)\n\n    def __abs__(self):\n        return math.hypot(self.x, self.y)\n\n    def __bool__(self):\n        return bool(abs(self))\n\n    def angle(self):\n        return math.atan2(self.y, self.x)\n\n    def __format__(self, fmt_spec=''):\n        if fmt_spec.endswith('p'):\n            fmt_spec = fmt_spec[:-1]\n            coords = (abs(self), self.angle())\n            outer_fmt = '<{}, {}>'\n\n        else:\n            coords = self\n            outer_fmt = '({}, {})'\n        components = (format(c, fmt_spec) for c in coords)\n        return outer_fmt.format(*components)\n\n    @classmethod\n    def frombytes(cls, octets):\n        typecode = chr(octets[0])\n        memv = memoryview(octets[1:]).cast(typecode)\n        return cls(*memv)\n\nPython的私有属性和“受保护的”属性\n举个例子。有人编写了一个名为 Dog 的类，这个类的内部用到了 mood 实例属性，但是没有将其开放。现在，你创建了 Dog 类的子类：Beagle。如果你在毫不知情的情况下又创建了名为 mood 的实例属性，那么在继承的方法中就会把 Dog 类的 mood 属性覆盖掉。这是个难以调试的问题。为了避免这种情况，如果以 mood 的形式（两个前导下划线，尾部没有或最多有一个下划线）命名实例属性，Python 会把属性名存入实例的 __dict 属性中，而且会在前面加上一个下划线和类名。因此，对 Dog 类来说，__mood 会变成 _Dog__mood；对 Beagle类来说，会变成 _Beagle__mood。这个语言特性叫名称改写（name mangling）。\n>>> v1 = Vector2d(3, 4)\n>>> v1.__dict__\n{'_Vector2d__y': 4.0, '_Vector2d__x': 3.0}\n>>> v1._Vector2d__x\n3.0\n对于私有属性推荐这么做\nPython 解释器不会对使用单个下划线的属性名做特殊处理，不过这是很多 Python 程序员严格遵守的约定，他们不会在类外部访问这种属性。 遵守使用一个下划线标记对象的私有属性很容易，就像遵守使用全大写字母编写常量那样容易。\n使用 slots 类属性节省空间\n但是，如果我们想要限制class的属性怎么办？比如，只允许对Student实例添加name和age属性。为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的__slots__变量，来限制该class能添加的属性\nclass Vector2d:\n __slots__ = ('__x', '__y')\n typecode = 'd'\n在类中定义 slots 属性的目的是告诉解释器：“这个类中的所有实例属性都在这儿了！”这样，Python 会在各个实例中使用类似元组的结构存储实例变量，从而避免使用消耗内存的 dict 属性。如果有数百万个实例同时活动，这样做能节省大量内存。\n综上，__slots__ 属性有些需要注意的地方，而且不能滥用，不能使用它限制用户能赋值的属性。处理列表数据时 slots 属性最有用，例如模式固定的数据库记录，以及特大型数据集。如果你的程序不用处理数百万个实例，或许不值得费劲去创建不寻常的类，那就禁止它创建动态属性或者不支持弱引用。与其他优化措施一样，仅当权衡当下的需求并仔细搜集资料后证明确实有必要时，才应该使用 slots 属性。\n\n覆盖类属性\n因为 Vector2d 实例本身没有 typecode 属性，所以 self.typecode 默认获取的是 Vector2d.typecode 类属性的值\nVecto2d.__repr__ 方法中为什么没有硬编码 class_name 的值，而是\n使用 type(self).__name__ 获取，如下所示：\n # 在Vector2d类中定义\n def __repr__(self):\n class_name = type(self).__name__\n return '{}({!r}, {!r})'.format(class_name, *self)\n\n如果硬编码 class_name 的值，那么 Vector2d 的子类（如 ShortVector2d）要覆盖__repr__ 方法，只是为了修改 class_name 的值。\n从实例的类型中读取类名，__repr__ 方法就可以放心继承。\n\n如何利用数据模型处理 Python 的其他功能：提供不同的对象表示形式、实现自定义的格式代码、公开只读属性，以及通过 hash() 函数支持集合和映射\n小总结\n\n所有用于获取字符串和字节序列表示形式的方法：__repr__、__str__、__format__ 和 __bytes__。\n把对象转换成数字的几个方法：__abs__、__bool__和 __hash__。\n用于测试字节序列转换和支持散列（连同 hash 方法）的 eq 运算符。\n\nformat\n\n现 format 方法，对提供给内置函数 format(obj,format_spec) 的 format_spec\n提供给 str.format 方法的'{:«format_spec»}' 位于代换字段中的 «format_spec» 做简单的解析\n\n用 slots 属性节省内存，以及这么做要注意的问题。\nslots 属性有点棘手，因此仅当处理特别多的实例（数百万个，而不是几千个）时才建议使用。\n可散列\n实现了 hash 方法，使用推荐的异或运算符计算实例属性的散列值\n私有属性最好用 命名规则来实现\nself.__x 这种方式有好有坏\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}