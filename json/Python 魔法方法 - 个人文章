{"title": "Python 魔法方法 - 个人文章 ", "index": "python", "content": "Python 魔法方法\n基础:\n\n\n如果你想...\n所以,你写...\nPython调用...\n\n\n\n初始化一个实例\nx = MyClass()\nx.__init__()\n\n\n作为一个字符串的\"官方\"表示\nrepr(x)\nx.__repr__()\n\n\n作为一个字符串\nstr(x)\nx.__str__()\n\n\n作为字节数组\nbytes(x)\nx.__bytes__()\n\n\n作为格式化字符串\nformat(x, format_spec)\nx.__format__(format_spec)\n\n\n\n\n\n__init__()方法在创建实例后调用.如果你想控制创建过程,请使用__new__()方法\n按照惯例, __repr__() 应该返回一个有效的Python表达式的字符串\n\n__str__()方法也被称为你的print(x)\n\n\n迭代相关\n\n\n如果你想...\n所以,你写...\nPython调用...\n\n\n\n遍历一个序列\niter(seq)\nseq.__iter__()\n\n\n从迭代器中获取下一个值\nnext(seq)\nseq.__next__()\n\n\n以相反的顺序创建一个迭代器\nreversed(seq)\nseq.__reversed__()\n\n\n\n\n\n__iter__()无论何时创建新的迭代器,都会调用该方法.\n\n__next__()每当你从迭代器中检索一下个值的时候,都会调用该方法\n\n__reversed__()方法并不常见.它需要一个现有序列并返回一个迭代器,该序列是倒序的顺序.\n\n属性\n\n\n如果你想...\n所以,你写...\nPython调用...\n\n\n\n得到一个属性\nx.my_property\nx.__getattribute__('my_property')\n\n\n获得一个属性\nx.my_property\nx.__getattr__('my_property')\n\n\n设置一个属性\nx.my_property = value\nx.__setattr__('my_property', value)\n\n\n阐述一个属性\ndel x.my_property\nx.__delattr__('my_property')\n\n\n列出所有属性和方法\ndir(x)\nx.__dir__()\n\n\n\n\n如果你的类定义了一个__getattribute__()方法,Python将在每次引用任何属性或方法名时调用它.\n如果你的类定义了一个__getattr__()方法,Python只会在所有普通地方查找属性后调用它.如果一个实例x定义了一个属性 color, x.color将不会调用x.__getattr__('color'); 它将简单地返回已经定义的x.color值.\n\n__setattr__()只要你为属性指定值,就会调用该方法.\n\n__delattr__()只要删除属性,就会调用该方法.\n\n__dir__()如果您定义一个__getattr__() 或者 __getattribute__() 方法,该方法很有用.通常情况下,调用dir(x)只会列出常规属性和方法.\n\n__getattr__()和__getattribute__()方法之间的区别很微妙但很重要.\n函数类\n通过定义__call__()方法,您可以创建一个可调用类的实例 - 就像函数可调用一样.\n\n\n如果你想...\n所以,你写...\nPython调用...\n\n\n来\"调用\"像函数一样的实例\nmy_instance()\nmy_instance.__call__()\n\n\n行为\n如果你的类作为一组值的容器 - 也就是说,如果问你的类是否\"包含\"一个值是有意义的 - 那么它应该定义下面的特殊方法,使它像一个集合一样.\n\n\n如果你想...\n所以,你写...\nPython调用...\n\n\n\n序列的数量\nlen(s)\ns.__len__()\n\n\n否包含特定的值\nx in s\ns.__contains__(s)\n\n\n\n字典(映射)\n\n\n如果你想...\n所以,你写...\nPython调用...\n\n\n\n通过它的key来获得值\nx[key]\nx.__getitem__(key)\n\n\n通过它的key来设置一个值\nx[key] = value\nx.__setitem__(key, value)\n\n\n删除键值对\ndel x[key]\nx.__delitem__(key)\n\n\n为丢失的key提供默认值\nx[nonexistent_key]\nx.__missing__(nonexistent_key)\n\n\n\n数字\n\n\n如果你想...\n所以,你写...\nPython调用...\n\n\n\n加\nx + y\nx.__add__(y)\n\n\n减\nx - y\nx.__sub__(y)\n\n\n乘\nx * y\nx.__mul__(y)\n\n\n整除\nx / y\nx.__trueiv__(y)\n\n\n除\nx // y\nx.__floordiv__(v)\n\n\n取余\nx % y\nx.__mod__(y)\n\n\n整除与取余\ndivmod(x, y)\nx.__divmod__(y)\n\n\n平方\nx ** y\nx.__pow__(y)\n\n\n左移\nx << y\nx.__lshift__(y)\n\n\n友移\nx >> y\nx.__rshift__(y)\n\n\n按位and运算\nx & y\nx.__and__(y)\n\n\n按位xor或运算\nx ^ y\nx.__xor__(y)\n\n\n按位or运算\n`x\ny`\nx.__or__(y)\n\n\n\n上述一组特殊方法采用第一种方法:给定x / y,它们提供了一种方法让x说\"我知道如何用y整除自己\".以下一组特殊方法解决了第二种方法:它们为y提供了一种方法来说\"我知道如何成为分母,并将自己整除x\".\n\n\n如果你想...\n所以,你写...\nPython调用...\n\n\n\n加\nx + y\nx.__radd__(y)\n\n\n减\nx - y\nx.__rsub__(y)\n\n\n乘\nx * y\nx.__rmul__(y)\n\n\n整除\nx / y\nx.__rtrueiv__(y)\n\n\n除\nx // y\nx.__rfloordiv__(v)\n\n\n取余\nx % y\nx.__rmod__(y)\n\n\n整除与取余\ndivmod(x, y)\nx.__rdivmod__(y)\n\n\n平方\nx ** y\nx.__rpow__(y)\n\n\n左移\nx << y\nx.__rlshift__(y)\n\n\n友移\nx >> y\nx.__rrshift__(y)\n\n\n按位and运算\nx & y\nx.__rand__(y)\n\n\n按位xor或运算\nx ^ y\nx.__rxor__(y)\n\n\n按位or运算\n`x\ny`\nx.__ror__(y)\n\n\n\n可是等等！还有更多！如果你正在进行\"就地\"操作,如x /= 3则可以定义更多特殊的方法.\n\n\n如果你想...\n所以,你写...\nPython调用...\n\n\n\n加\nx + y\nx.__iadd__(y)\n\n\n减\nx - y\nx.__isub__(y)\n\n\n乘\nx * y\nx.__imul__(y)\n\n\n整除\nx / y\nx.__itrueiv__(y)\n\n\n除\nx // y\nx.__ifloordiv__(v)\n\n\n取余\nx % y\nx.__imod__(y)\n\n\n整除与取余\ndivmod(x, y)\nx.__idivmod__(y)\n\n\n平方\nx ** y\nx.__ipow__(y)\n\n\n左移\nx << y\nx.__ilshift__(y)\n\n\n友移\nx >> y\nx.__irshift__(y)\n\n\n按位and运算\nx & y\nx.__iand__(y)\n\n\n按位xor或运算\nx ^ y\nx.__ixor__(y)\n\n\n按位or运算\n`x\ny`\nx.__ior__(y)\n\n\n\n还有一些\"单个数\"数学运算可以让你自己对类似数字的对象进行数学运算.\n\n\n如果你想...\n所以,你写...\nPython调用...\n\n\n\n负数\n-x\nx.__neg__()\n\n\n正数\n+x\nx.__pos__()\n\n\n绝对值\nabs(x)\nx.__abs__()\n\n\n逆\n~x\nx.__invert__()\n\n\n复数\ncomplex(x)\nx.__complex__()\n\n\n整数\nint(x)\nx.__int__()\n\n\n浮点数\nfloat(x)\nx.__float__()\n\n\n四舍五入到最近的整数\nround(x)\nx.__round__()\n\n\n四舍五入到最近的n位数\nround(x, n)\nx.__round__(n)\n\n\n最小整数\nmath.ceil(x)\nx.__ceil__()\n\n\n最大整数\nmath.floor(x)\nx.__floor__()\n\n\n截断x到0的最接近的整数\nmath.trunc(x)\nx.__trunc__()\n\n\n数字作为列表索引\na_list[x]\na_list[x.__index__()]\n\n\n\n比较\n\n\n如果你想...\n所以,你写...\nPython调用...\n\n\n\n等于\nx == y\nx.__eq__(y)\n\n\n不等于\nx != y\nx.__ne__(y)\n\n\n小于\nx < y\nx.__lt__(y)\n\n\n小于等于\nx <= y\nx.__le__(y)\n\n\n大于\nx > y\nx.__gt__(y)\n\n\n大于等于\nx >= y\nx.__ge__(y)\n\n\n布尔\nif x:\nx.__bool__()\n\n\n\n序列化\n\n\n如果你想...\n所以,你写...\nPython调用...\n\n\n\n对象副本\ncopy.copy(x)\nx.__copy__()\n\n\n深拷贝\ncopy.deepcopy(x)\nx.__deepcopy__()\n\n\n序列化一个对象\npickle.dump(x, file)\nx.__getstate__()\n\n\n序列化一个对象\npickle.dump(x, file)\nx.__reduce__()\n\n\n序列化一个对象\npickle.dump(x, file, protocol_version)\nx.__reduce_ex__(protocol_version)\n\n\n取出恢复后的状态\nx = pickle.load(fp)\nx.__getnewargs__()\n\n\n取出恢复后的状态\nx = pickle.load(fp)\nx.__setstate__()\n\n\n\nwith 语句\nwith块限定了运行时上下文;在执行with语句时,\"进入\"上下文,并在执行块中的最后一个语句后\"退出\"上下文.\n\n\n如果你想...\n所以,你写...\nPython调用...\n\n\n\n进入with语句块\nwith x:\nx.__enter__()\n\n\n退出with语句块\nwith x:\nx.__exit__(exc_type, exc_value, traceback)\n\n\n\n真正深奥的东西\n\n\n如果你想...\n所以,你写...\nPython调用...\n\n\n\n \nx = MyClass()\nx.__new__()\n\n\n \ndel x\nx.__del__()\n\n\n \n``\nx.__solts__()\n\n\n \nhash(x)\nx.__hash__()\n\n\n \nx.color\ntype(x).__dict__['color'].__get__(x, type(x))\n\n\n \nx.color = 'PapayaWhip'\ntype(x).__dict__['color'].__set__(x, 'PapayaWhip')\n\n\n \ndel x.color\ntype(x).__dict__['color'].__del__(x)\n\n\n \nisinstance(x, MyClass)\nMyClass.__instancecheck__(x)\n\n\n \nisinstance(C, MyClass)\nMyClass.__subclasscheck__(C)\n\n\n \nisinstance(C, MyABC)\nMyABC.__subclasshook__(C)\n\n\n\nPython正确调用__del__()特殊方法时非常复杂.为了完全理解它,你需要知道Python如何跟踪内存中的对象.这里有一篇关于Python垃圾收集和类析构函数的好文章.你还应该阅读关于弱引用,weakref模块,以及可能的gc模块以获得更好的度量.\n\n                ", "mainLikeNum": ["4 "], "mainBookmarkNum": "6"}