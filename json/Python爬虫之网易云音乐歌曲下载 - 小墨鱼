{"title": "Python爬虫之网易云音乐歌曲下载 - 小墨鱼 ", "index": "python,网易云音乐,网页爬虫,下载", "content": "Python爬虫之网易云音乐下载\n目标\n用Python根据网易云音乐的ID，下载音乐，保存到本地MP3格式\n可以下载歌曲的范围：所有能够听的歌曲\n配置基础\nPython 3.5\n模块\n\npycrypto\nbase64\nrequests\njson\nsys（可选）\nprogressbar（可选）\n\npycrypto\n这是哈希函数（如SHA256和RIPEMD160）和各种加密算法（AES，DES，RSA，ElGamal等）的集合。主要是用来加密解密，为何要用这个呢，稍后分析\n安装\npip install pycrypto\nbase64\npython 自带的模块，主要是配合pycrypto模块使用\nrequests、json\nrequests主要用来发送网络请求， json主要用于解析网络请求的response\n分析\n为了避免麻烦，我们选择网页版的网易云音乐而不用客户端的，省去抓包的麻烦我们随便选择一首歌（这里选择：一千零一夜 ）然后打开网页，得到如下界面：\n\n然后打开浏览器网络面板，点击播放按钮，然后查看网络请求，如下：\n\n一共发送了四个网络请求，仔细一点，我们发现了一个有趣的请求，就是上图最后一个，带有.mp3后缀的那个，很明显，这里是将一千零一夜这首歌缓存了下来，复制该网络请求到浏览器地址栏打开，然后浏览器就开始下载一千零一夜这首歌。到此，好像前面提的所谓的目标完成了，但是我不开心，身为一个开发人员，这么没有技术含量的东西，是不是可以考虑用技术去实现呢。能不能输入一个歌曲的ID，然后就把歌曲下回来呢。我们播放多几首歌曲，很容易发现，每一首歌曲都会有一个独立的链接，仔细看看这个链接（http://m10.music.126.net/2018...），显然是经过处理的，这个处理有可能是前端直接处理的，也有可能是后端处理的（是不是说了等于白说。。。），后端处理会有多种情况，其中一种就是另一个网络请求返回来对应的东西，反正网络请求不多，我们先看看网咯请求，一看吓一跳，还真蒙着了，上图中第一个网络请求返回来的数据\n\n再看一下请求的组成\n\n只要模拟这个请求，就可以得到歌曲的链接，只要得到链接就能下载歌曲。在该请求的参数中，params以及encSecKey都是一个经过加密的数据，在反复分析点击播放按钮的事件后，得到JavaScript进行了如下操作\nvar bPc2x = window.asrsea(JSON.stringify(j4n), buv7o([\"流泪\", \"强\"]), buv7o(Tg9X.md), buv7o([\"爱心\", \"女孩\", \"惊恐\", \"大笑\"]));\n            e4i.data = k4o.cE5J({\n                params: bPc2x.encText,\n                encSecKey: bPc2x.encSecKey\n            })\n其中，window.asrsea函数代码如下\n!function() {\n    function a(a) {\n        var d, e, b = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\", c = \"\";\n        for (d = 0; a > d; d += 1)\n            e = Math.random() * b.length,\n            e = Math.floor(e),\n            c += b.charAt(e);\n        return c\n    }\n    function b(a, b) {\n        var c = CryptoJS.enc.Utf8.parse(b)\n          , d = CryptoJS.enc.Utf8.parse(\"0102030405060708\")\n          , e = CryptoJS.enc.Utf8.parse(a)\n          , f = CryptoJS.AES.encrypt(e, c, {\n            iv: d,\n            mode: CryptoJS.mode.CBC\n        });\n        return f.toString()\n    }\n    function c(a, b, c) {\n        var d, e;\n        return setMaxDigits(131),\n        d = new RSAKeyPair(b,\"\",c),\n        e = encryptedString(d, a)\n    }\n    function d(d, e, f, g) {\n        var h = {}\n          , i = a(16);\n        return h.encText = b(d, g),\n        h.encText = b(h.encText, i),\n        h.encSecKey = c(i, e, f),\n        h\n    }\n    function e(a, b, d, e) {\n        var f = {};\n        return f.encText = c(a + e, b, d),\n        f\n    }\n    window.asrsea = d,\n    window.ecnonasr = e\n}();\n由上得知，window.asrsea一共传递了四个参数（假设为window.asrsea(a, b, c, d)），而这四个参数中，只有 a是一个跟歌曲id相关的参数，其他三个都是一个常量\nb = \"010001\";\nc = \"00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7\"\nd = \"0CoJUm6Qyw8W8jud\"\n再研究window.asrsea的代码，发现请求的两个参数params以及encSecKey都在这里加密了，其中params经过了两次AES加密，第一次加密的时候，传入了两个参数，一个是a，一个是d,第二个加密的两个参数，第一个是第一次加密的结果,第二个是一个16位的随机字符串，因为是一个随机的字符串，所以我们可以随便用一个16位的字符串就行了，由于这里这个随机的字符串固定了，那第二个参数encSecKey就是一个固定的值至此，我们的分析完成，也得到了需要的信息\nPython实现\nPython想要模拟请求，那就需要进行AES加密，因此我们就用到了开始所说的pycrypto模块\nfrom Crypto.Cipher import AES\nimport base64\n\n\ndef aes_encrypt(text, key):\n    iv = \"0102030405060708\"\n    pad = 16 - len(text) % 16\n    text = text + pad * chr(pad)\n    encryptor = AES.new(key, AES.MODE_CBC, iv)\n    result = encryptor.encrypt(text)\n    result_str = base64.b64encode(encrypt_text)\n    return result_str\nQQ交流群： 173318043项目地址：lmissy.cn如果本文对你有所帮助，请点个赞，这是我努力下去的无限动力，谢谢(｡･ω･｡)\n\n                ", "mainLikeNum": ["5 "], "mainBookmarkNum": "3"}