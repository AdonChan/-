{"title": "机器学习从入门到放弃K-Means聚类 - 肥兔子de碎碎语 ", "index": "机器学习,k-means,python", "content": "前言\n在本系列前面的内容中，讲述了一系列的机器学习方法。要知道机器学习算法中，比较常用的主要分成有监督学习和无监督学习（其实还有一个叫半监督学习，在这里先不作讨论），简单点来说，所谓的有监督学习,就是人类会给训练集指明label,自然的无监督学习就是不为训练集指明label。所以本系列前段时间所说的就属于有监督学习。\n站在使用者的角度来说，两种模型的使用方法大致相同，都是我将测试样本输入模型，模型输出该样本所属的类别(这里以分类问题为例)，但模型产生的方式是不同的。对于有监督学习来说，你重新训练一次样本1类还是那个1类，而对于无监督学习来说，你重新训练一次1类说不定就不是上次那个1类了，正是因为这个原因，所以在输出类别后，必要时需要输出同类别的其他样本，以作参考。\n正如当你老师跟你说了一堆三角形的例子你就知道这堂课说的就是三角形一样，没错，接下来就是为了讲述最基本的无监督学习的算法，K-Means聚类算法。\n在这篇文章中,作者举了一个例子，将近年来各国球队的战绩进行聚类，分出世界一流，二流，三流球队，那么，显然当有一只新球队需要分类时，将他的战绩扔进模型里跑一跑就ok了。\n其实聚类算法还有一个妙用就是，当数据集过于庞大，并且原始数据并不存在label信息，你又需要跑一个有监督学习的算法的时候，你想要人为的给数据打label显然是不合适的，这时先跑一次聚类，记录好聚类的情况，再直接跑有监督学习的算法就可以了。\nK-Means\n回到正题上，本文主要介绍K-Means方法，和为了弥补K-Means不足而产生的二分K-Means方法\n以下讲解以二维数据为例。\n普通的K-Means方法\n\n随机产生n个点为簇心，n的取值为用户需要的类别个数。\n计算所有样本离簇心的距离，计算方法有多种，其中包括最易理解的欧式距离sqrt((x1-y1)^2 +(x2-y2)^2)\n每一个样本都归纳到距离最近的簇心所在的类别。\n产生新的簇心，新的簇心计算方法为每一个簇内所有的样本的算术平均数。新簇心坐标（((x1+x2+……xn)/n),(y1+y2+……yn)/n)）（x,y）为同一簇内样本点的坐标\n产生新的簇心后，按照新的簇心进行分类，若分类结果不变，则结束聚类，否则重复该过程至分类结果不变或超出用户指定的迭代次数。\n\n普通K-Means有一个比较明显的缺陷，就是他的起始簇心是随机的。\n随机意味这什么呢？一切皆有可能啊！\n因为后续的质心迭代都是基于首次质心的选取，因此整体算法的结果和质心的选取极度敏感，虽然退一步来说，第一次聚类不理想，就重来算法一次好了，你可以重复运行至结果可接受位置，但这种方法显然是不能接受。于是便出现了二分K-Means算法。\n二分K-Means方法\n\n以所有样本点的中心为第一个簇心\n判断当前簇心数是否满足要求，若满足则退出算法\n若不满足，则选取划分后误差最小的点一分为二（只有一个点时则选取自身）(一分为二的操作是指对该簇进行普通的K-Means方法)\n直至簇心个数满足要求。\n\n代码实现\ngithub\n后话\n自从开始这个机器学习从入门到放弃系列后，也多了一些关注者，最近文章更新缓慢我也有些抱歉，其实在github上已有其他算法的实现，心痒的同学可以先自行学习，因文章需要知识上的梳理和总结加上一些私事，所以更新会较慢，各位关注者见谅哈。\n文章如有不足或不明白的地方，欢迎留言指教或探讨。\n\n                ", "mainLikeNum": ["5 "], "mainBookmarkNum": "8"}