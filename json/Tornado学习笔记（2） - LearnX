{"title": "Tornado学习笔记（2） - LearnX ", "index": "tornado,python", "content": "表单和模板\nimport os.path\n\nimport tornado.httpserver\nimport tornado.ioloop\nimport tornado.options\nimport tornado.web\n\nfrom tornado.options import define, options\ndefine(\"port\", default=8000, help=\"run on the given port\", type=int)\n\nclass IndexHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.render('index.html')\n\nclass PoemPageHandler(tornado.web.RequestHandler):\n    def post(self):\n        noun1 = self.get_argument('noun1')\n        noun2 = self.get_argument('noun2')\n        verb = self.get_argument('verb')\n        noun3 = self.get_argument('noun3')\n        self.render('poem.html', roads=noun1, wood=noun2, made=verb,\n                difference=noun3)\n\nif __name__ == '__main__':\n    tornado.options.parse_command_line()\n    app = tornado.web.Application(\n        handlers=[(r'/', IndexHandler), (r'/poem', PoemPageHandler)],\n        template_path=os.path.join(os.path.dirname(__file__), \"templates\")\n    )\n    http_server = tornado.httpserver.HTTPServer(app)\n    http_server.listen(options.port)\n    tornado.ioloop.IOLoop.instance().start()\n    \n    \n这个表单包括了多个文本，其中的内容在用户点击提交之后以POST请求的方式发送到/poem。Tornado为了响应这个请求会自动跳到poem.html，并且插入你在表单中填写的值。\n渲染摸板\n这和我在第一章里看到的例子差不多RequestHandler传给tornado.web.Application对象。但是还是有区别的，首先是传递了一个template_path参数。template_path参数告诉Tornado在哪里寻找模板文件。而这里的self.render()方法则是告诉Tornado来读取模板文件，并将结果返回给浏览器。然而这里的index.html并不完整，它的确是一个已经写好的HTML标记，但是一般情况下我们会输出我们所希望HTML结合程序传入给模板的值。{{}}所括起来的字符串，括起来的字符串就是占位符，我们在渲染模板的时候会希望以实际的值代替。这里还是可以通过render()函数传递所希望表达出来的关键字参数。例如这里的：\nself.render('poem.html', roads=noun1, wood=noun2, made=verb, difference=noun3)\n这里就告诉模板我们将传入的参数。这里的{{}}可以填充任意的Python表达式：\n>>> from tornado.template import Template\n>>> print Template(\"{{2+3}}\").generate()\n5\n>>> print Template({{'gogogojuststudy'[-5:]}}\").generate()\nstudy\n>>>\n同样可以在Tornado模板中使用条件和循环语句。控制语句以{% %}包围。一般以{%if condition%}。依旧可以使用for，while等条件控制语句，但是要记得以{%end %}结尾。这里有其他的一些默认提供的一些便利的函数：\nescape（） #替换字符串中的&、为他们对应的HTML字符\nurl_escape() #使用urlib。quote_plus替换字符串s中的字符为URL编码形式。\nsqueeze（） #过滤字符串，把连续的多个空白字符替换成一个空格\n模板扩展\nTornado可以方便我们扩展一个已经存在的模板，只需要在新的模板文件顶部放上{%extends “filename.html”%}这里便是使得新的HTML文件继承了父HTML文件的所有标签。这里我们就需要用到块了，block语句可以帮助我们改变一些模板元素。每个{%block %}对应一个{% end%}。\nUI模块\nUI模块是封装模板中包含的标记、样式以及行为的可复用组件。它所定义的元素通常用于多个模板交叉复 用或在同一个模板中重复使用。模块本身是一个继承自Tornado的UIModule类的简单Python类，并定义 了一个render()方法。\nimport tornado.web\nimport tornado.httpserver\nimport tornado.ioloop\nimport tornado.options\nimport os.path\n\nfrom tornado.options import define, options\ndefine(\"port\", default=8000, help=\"run on the given port\", type=int)\n\nclass HelloHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.render('hello.html')\n\nclass HelloModule(tornado.web.UIModule):\n    def render(self):\n        return '<h1>Hello, world!</h1>'\n\nif __name__ == '__main__':\n    tornado.options.parse_command_line()\n    app = tornado.web.Application(\n        handlers=[(r'/', HelloHandler)],\n        template_path=os.path.join(os.path.dirname(__file__), 'templates'),\n        ui_modules={'Hello': HelloModule}\n    )\n    server = tornado.httpserver.HTTPServer(app)\n    server.listen(options.port)\n    tornado.ioloop.IOLoop.instance().start()\n这个例子里ui_module字典里只有一项，这里把名为Hello模块的引用和定义的HELLOMODULE结合起来。当我们调用HelloHandler并渲染hello.html时，可以使用{% module Hello()%}模板标签来包含HelloModule中render()方法返回的字符串。\n例如在这里：\n<html>    \n<head>\n<title>UI Module Example</title>\n</head>    \n<body>\n {% module Hello() %}    \n</body>\n </html>\n这里通过模板标签自身的位置调用HelloModule返回的字符串进行填充。\n嵌入JavaScript和CSS\n为了给这些模块提供更高的灵活性，Tornado允许你使用embedded_css和embedded_javascript方法嵌 入其他的CSS和JavaScript文件不仅仅是可以返回一个JavaScript和CSS规则，而且更加灵活的是在闭合的标签前添加完整的HTML标记。你可以使用javascript_files()和css_files()来 包含完整的文件，不论是本地的还是外部的。\ndef css_files(self):    \nreturn \"/static/css/newreleases.css\"\n\ndef javascript_files(self):    \nreturn\"https://ajax.googleapis.com/ajax/libs/jqueryui/1.8.14/jquery-ui.min.js\"\n\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "1"}