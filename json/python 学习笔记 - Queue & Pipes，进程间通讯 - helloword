{"title": "python 学习笔记 - Queue & Pipes，进程间通讯 - helloword ", "index": "python,pipe,multiprocessing,queue", "content": "上面写了Python如何创建多个进程，但是前面文章中创建的进程都是哑巴和聋子，自己顾自己执行，不会相互交流。那么如何让进程间相互说说话呢？Python为我们提供了一个函数multiprocessing.Pipe和一个类：multiprocessing.Queue。\nmultiprocessing.Pipe()\nmultiprocessing.Pipe()即管道模式，调用Pipe()返回管道的两端的Connection。\nPython官方文档的描述：\nReturns a pair (conn1, conn2) of Connection objects representing the ends of a pipe.\n因此, Pipe仅仅适用于只有两个进程一读一写的单双工情况，也就是说信息是只向一个方向流动。例如电视、广播，看电视的人只能看，电视台是能播送电视节目。\nPipe的读写效率要高于Queue。进程间的Pipe基于fork机制建立。当主进程创建Pipe的时候，Pipe的两个Connections连接的的都是主进程。当主进程创建子进程后，Connections也被拷贝了一份。此时有了4个Connections。此后，关闭主进程的一个Out Connection，关闭一个子进程的一个In Connection。那么就建立好了一个输入在主进程，输出在子进程的管道。原理示意图如下：跟多资料可以阅读：http://www.tuicool.com/articl...\n# 示例代码\n# coding=utf-8\nfrom multiprocessing import Pipe, Process\n\n\ndef son_process(x, pipe):\n    _out_pipe, _in_pipe = pipe\n\n    # 关闭fork过来的输入端\n    _in_pipe.close()\n    while True:\n        try:\n            msg = _out_pipe.recv()\n            print msg\n        except EOFError:\n            # 当out_pipe接受不到输出的时候且输入被关闭的时候，会抛出EORFError，可以捕获并且退出子进程\n            break\n\n\nif __name__ == '__main__':\n    out_pipe, in_pipe = Pipe(True)\n    son_p = Process(target=son_process, args=(100, (out_pipe, in_pipe)))\n    son_p.start()\n\n    # 等pipe被fork 后，关闭主进程的输出端\n    # 这样，创建的Pipe一端连接着主进程的输入，一端连接着子进程的输出口\n    out_pipe.close()\n    for x in range(1000):\n        in_pipe.send(x)\n    in_pipe.close()\n    son_p.join()\n    print \"主进程也结束了\"\n总结一下：\n\n上面的代码中主要用到了pipe的send()、recv()、close()方法。当pipe的输入端被关闭，且无法接收到输入的值，那么就会抛出EOFError。\n新建一个Pipe(duplex)的时候，如果duplex为True，那么创建的管道是双向的；如果duplex为False，那么创建的管道是单向的。\n\nmultiprocessing.Queue\nQueue据官方文档也是基于pipe的实现。Queue的使用主要是一边put(),一边get().但是Queue可以是多个Process 进行put操作，也可以是多个Process进行get()操作。Demo:\n# coding=utf-8\nfrom multiprocessing import Queue, Process\nfrom Queue import Empty as QueueEmpty\nimport random\n\n\ndef getter(name, queue):\n    print 'Son process %s' % name\n    while True:\n        try:\n            value = queue.get(True, 10)\n            # block为True,就是如果队列中无数据了。\n            #   |—————— 若timeout默认是None，那么会一直等待下去。\n            #   |—————— 若timeout设置了时间，那么会等待timeout秒后才会抛出Queue.Empty异常\n            # block 为False，如果队列中无数据，就抛出Queue.Empty异常\n            print \"Process getter get: %f\" % value\n        except QueueEmpty:\n            break\n\n\ndef putter(name, queue):\n    print \"Son process %s\" % name\n    for i in range(0, 1000):\n        value = random.random()\n        queue.put(value)\n        # 放入数据 put(obj[, block[, timeout]])\n        # 若block为True，如队列是满的：\n        #  |—————— 若timeout是默认None，那么就会一直等下去\n        #  |—————— 若timeout设置了等待时间，那么会等待timeout秒后，如果还是满的，那么就抛出Queue.Full.\n        # 若block是False，如果队列满了，直接抛出Queue.Full\n        print \"Process putter put: %f\" % value\n\n\nif __name__ == '__main__':\n    queue = Queue()\n    getter_process = Process(target=getter, args=(\"Getter\", queue))\n    putter_process = Process(target=putter, args=(\"Putter\", queue))\n    getter_process.start()\n    putter_process.start()\n\nQueue的一些说明已经写在代码中了。\n\n                ", "mainLikeNum": ["5 "], "mainBookmarkNum": "12"}