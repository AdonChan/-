{"title": "Python全栈之路系列之数字数据类型 - Python全栈之路 ", "index": "python", "content": "上篇文章中我们简单的体验了Python语言基本概念与语法，那么在继续深入下去的过程中，不妨先学习几个常见的Python内置数据类型？这也是大部分Python教科书的学习目录，由浅至深，慢慢深入。\nPython常用的几种数据类型就是以下几种，其实Python内部的数据类型还是很多的，多归多但是很少有我们用到了，太多了也记不了，把常用的几个玩熟练了就OK了。\n那么接下来我们会学到那些内置的数据类型呢？\n\n虽然说我们是在学习数据类型，但其实只是在学习每一个类型所提供的API而已，你所需要的大部分功能，Python都已经帮我们封装好了，不需要担心任何效率的问题，当你熟悉了这些API之后，灵活的组合应用，因为这在开发的过程中是必不可少的，那么接下来就让我们开始漫长的数据类型API学习之旅吧。\n所有的数据类型所具备的方法都存在相对应的类里面，当创建一个类型的对象时，该对象所具备的功能都保存在相应的类中。\n数字\n在Python3中，整型、长整型、浮点数、负数、布尔值等都可以称之为数字类型。\n创建数字类型类型的对象\nint类型通常都是数字，创建数字类型的方式有两种，且在创建的时候值两边不需要加双引号或单引号。\n第一种创建整型的方式\n>>> number = 9\n>>> type(number)\n<class 'int'>\n第二种创建整型的方式\n>>> number = int(9)\n>>> type(number)\n<class 'int'>\n以上两种创建整型对象的方式都可以创建的，但是他们也是有本质上的区别，第一种方式实际上会转换成第二种方式，然后第二种方式会把括号内的数据交给__init__这个构造方法，构造方法是int类的，然后构造方法会在内存中开辟一块空间用来存放数据，但实际上我们在用时候是没有任何区别的。\n构造方法每个数据类型中都会有，这是Python内部所定义的，如下图所示：\n\n__init__\ndef __init__(self, x, base=10): # known special case of int.__init__\n可以从源码中看到，__init__的方法有两个参数，其中base=10是可选的参数，x是我们对象的值，base=10其实就是说把我们的值(默认二进制)以十进制的方式输出出来，通过下面的实例可以看到：\n>>> var=int('0b100',base=2)\n>>> var\n4\n通过int()可以将一个数字的字符串变成一个整数，并且如果你指定了第二个参数，还可以将值进制数转换为整数：\n# 将数字字符串转换为整数，数字字符串通过进制转换为整数\n>>> int('99'),int('100',8),int('40',16),int('10000000',2)\n(99, 64, 64, 128)\n# 讲进制数转换为整数\n>>> int('0x40',16),int('0b1000000',2)\n(64, 64)\n把二进制的数字4通过十进制输出出来，4的二进制就是0b100，又有一个知识点就是在类的方法中，所有以__开头，并且以__结尾的方法都是Python内部自己去调用的，我们在写代码的过程中是不需要去调用的，最简单的例子就是__init__，通过上面的流程图我们就可以很清楚的看到。\nint内部优化机制\n下图中我们可以很清楚的看到int类型在创建对象时内存所分配空间的情况\n\n首先我们知道当我们创建第一个对象var1的时候会在内存中开辟一块空间作为存放var1对象的值用的，当我们创建第二个对象var2的时候也会在内存中开辟一块空间来作为var2对象的值，那如果这样说，那是不是说对象var1和var2的值内存是否会同时开辟两块呢？我们通过下面的实例可以得到答案：\nC:\\Users\\anshe>c:\\Python35\\python.exe\n# 注意我是用的是Python3.5.1\nPython 3.5.1 (v3.5.1:37a07cee5969, Dec  6 2016, 01:54:25) [MSC v.1900 64 bit (AMD64)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n# 分别创建对象var1和var2\n>>> var1=123\n>>> var2=123\n# 我们可以看到他们的内存地址都是指向的`1502084720`\n>>> id(var1)\n1502084720\n>>> id(var2)\n1502084720\n通过上面的结果我们可以看到var1和var2的内存地址是相同的，就代表他们的值是使用的同一块空间，那么如果我把var2的值改为456呢？\n>>> var2=456\n>>> id(var1)\n1502084720\n>>> id(var2)\n2452305956816\n可以看到var2的内存地址已经改变了（废话），因为对象的值不一样了，所以他才不会改变，OK，我们可以得到一个结论就是：当两个或者多个对象的值都是同一个的时候，那么这些对象都会使用同一个内存地址，这里的值是是有范围的，默认范围是-5~257，得到这个结论之后我们继续往下看。\n\n这张图我们同样创建了两个对象，但是唯一不同的是我把第一个创建的对象的值作为第二个对象的值，这里他们肯定使用的是同一个内存地址，但是如果我把第一个对象的值改动了呢？\n>>> var1=123\n>>> var2=var1\n>>> id(var1)\n1502084720\n>>> id(var2)\n1502084720\n>>> var1=456\n>>> id(var1)\n2452305956816\n>>> id(var2)\n1502084720\n请自行思考，这里不多做解释，然后下面我们再来说说刚才的话题，说在-5~257这个范围内对象的值都会引用同一块内存地址，我们可以通过下面的实验来测试：\n>>> var1=12345\n>>> var2=12345\n>>> id(var1)\n2452305956816\n>>> id(var2)\n2452308384720\n事实证明我们的结论是完全没有问题的，注意我上面的实例都是在Python3.5上面执行的哦，var1和var2两个对象的值同样是12345，但是他们的内存地址就是不一样，这就是Python在内部做的优化，他把-5~257这个范围内我们常用道德数字多对象可引用的，OK，到此结束这个话题。\n数字类型的长度限制\n数字类型在python2.7里面是分整型和长整型这个区别的，也就是说如果你的数字大到一定的范围，那么python会把它转换为长整形，一个数字类型包含32位，可以存储从-2147483648到214483647的整数。\n一个长整(long)型会占用更多的空间，64位的可以存储-922372036854775808到922372036854775808的整数。\npython3里long型已经不存在了，而int型可以存储到任意大小的整型，甚至超过64为。\nPython内部对整数的处理分为普通整数和长整数，普通整数长度为机器位长，通常都是32位，超过这个范围的整数就自动当长整数处理，而长整数的范围几乎完全没限制，如下：\nPython2.7.x\n>>> var=123456\n>>> var\n123456\n>>> var=10**20\n>>> var\n100000000000000000000L\n>>> type(var)\n# long就是长整型\n<type 'long'>\nPython3.5.x\n>>> var=123456789\n>>> var\n123456789\n>>> var=10**20\n>>> var\n100000000000000000000\n>>> type(var)\n<class 'int'>\n请自行补脑 - - 、\n数字类型所具备的方法\nbit_length\n返回表示该数字时占用的最少位数\n>>> num=20\n>>> num.bit_length()\n5\nconjugate\n返回该复数的共轭复数，复数，比如0+2j,其中num.real,num.imag分别返回其实部和虚部，num.conjugate()，返回其共扼复数对象\n>>> num =-20\n>>> num.conjugate()\n-20\n>>> num=0+2j\n>>> num.real\n0.0\n>>> num.imag\n2.0\n>>> num.conjugate()\n-2j\nimag\n返回复数的虚数\n>>> number = 10\n>>> number.imag\n0\n>>> number = 3.1415926\n>>> number.imag\n0.0\n内置的方法还有denominator、from_bytes、numerator、real、to_bytes，实在搞不懂这有什么用，也不太理解，就不做介绍了，你可以通过help(int.numerator)查看该方法的帮助信息等。\n混合类型\n所谓混合类型就是浮点数和整数进行运算，如下所示：\n>>> 3.14159 + 10\n13.14159\n结果和我们想象中的一样，但是一个浮点数一个正整数它是怎么进行相加的呢？其实很简单，Python会把两个值转换为其中最复杂的那个对象的类型，然后再对相同类型运算。\n比如上面的例子中，会先把10转换为10.0然后再与3.14159相加。\n数字类型的复杂度\n整数比浮点数简单、浮点数比复数简单。\n布尔类型(bool)\n布尔类型其实就是数字0和1的变种而来，即真（True/0）或假（False/1），实际上就是内置的数字类型的子类而已。\n# 如果0不是真，那么就输出'0 is False.'\n>>> if not 0: print('0 is False.')\n... \n0 is False.\n# 如果1是真，那么就输出'1 is True.'\n>>> if 1: print('1 is True.')\n... \n1 is True.\n你还可以使用布尔值进行加减法，虽然从来没在任何代码中见过这种形式：\n>>> True + 1\n# 1 + 1 = 2\n2\n>>> False + 1\n# 0 + 1 = 1\n1\n集合(set)\n集合的元素是不允许重复、不可变且无序的集合，集合就像是字典舍弃了值一样，集合中的元素只能够出现一切且不能重复。\n创建set集合\n>>> s = set([11,22,33])\n>>> s\n{33, 11, 22}\n>>> type(s)\n<class 'set'>\n第二种不常用创建set集合的方式\n# 这种的创建方式，集合中的元素相当于字典中的key\n>>> s = {11,22,33}\n>>> type(s)\n<class 'set'>\n>>> s\n{33, 11, 22}\n把其它可迭代的数据类型转换为set集合\n>>> li = [\"a\",\"b\",\"c\"]\n>>> seting = set(li)\n>>> seting\n{'b', 'a', 'c'}\n>>> type(seting)\n<class 'set'>\n集合同样支持表达式操作符\n# 首先创建两个集合\n>>> x = set('abcde')\n>>> y = set('bdxyz')\n>>> x\n{'a', 'd', 'b', 'c', 'e'}\n>>> y\n{'y', 'd', 'b', 'x', 'z'}\n# 使用in进行成员检测\n>>> 'a' in x\nTrue\n# 差集\n>>> x - y\n{'a', 'e', 'c'}\n# 并集\n>>> x | y\n{'b', 'y', 'z', 'a', 'd', 'e', 'c', 'x'}\n# 交集\n>>> x & y\n{'d', 'b'}\n# 对称差\n>>> x ^ y\n{'y', 'z', 'a', 'e', 'c', 'x'}\n# 比较\n>>> x > y, x < y\n(False, False)\n集合解析\n>>> {x for x in 'abc'}\n{'a', 'b', 'c'}\n>>> {x+'b' for x in 'abc'}\n{'bb', 'cb', 'ab'}\n集合所提供的方法\nadd\n往集合内添加元素\n>>> se = { 11, 22, 33 }\n>>> se\n{33, 11, 22}\n# 元素写在小括号内\n>>> se.add(44)\n>>> se\n{33, 11, 44, 22}\n clear\n清除集合内容\n>>> se = { 11, 22, 33 }\n>>> se\n{33, 11, 22}\n>>> se.clear()\n>>> se\nset()\n copy浅拷贝\n下文介绍 difference\n寻找集合的元素var1中存在，var2中不存在的\n>>> var1 = { 11, 22, 33 }\n>>> var2 = { 22 ,55 }\n>>> var1.difference(var2)\n{33, 11}\n>>> var2.difference(var1)\n{55}\n difference_update\n寻找集合的元素var1中存在，var2中不存在的元素，并把查找出来的元素重新复制给var1\n>>> var1 = { 11, 22, 33 }\n>>> var2 = { 22 ,55 }\n>>> var1.difference_update(var2)\n>>> var1\n{33, 11}\n discard\n移除指定元素，不存在不保错\n>>> var1 = { 11, 22, 33 }\n>>> var1.discard(11)\n>>> var1\n{33, 22}\n>>> var1.discard(1123123)\n>>> var1\n{33, 22}\nremove\n移除指定元素，不存在保错\n>>> var1 = { 11, 22, 33 }\n>>> var1\n{33, 11, 22}\n>>> var1.remove(11)\n>>> var1\n{33, 22}\n>>> var1.remove(asda)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nNameError: name 'asda' is not defined\nintersection\n交集，查找元素中都存在的值\n>>> var1 = { 11, 22, 33 }\n>>> var2 = { 22, 55, \"一二\" }\n>>> var1.intersection(var2)\n{22}\n intersection_update\n取交集并更更新到A中\n>>> var1 = { 11, 22, 33 }\n>>> var2 = { 22, 55, \"一二\" }\n>>> var1.intersection_update(var2)\n>>> var1\n{22}\n isdisjoint\n判断有没有交集，如果有返回False，否则返回True\n>>> var1 = { 11, 22, 33 }\n>>> var2 = { 22, 44, 55 }\n>>> var1.isdisjoint(var2)\nFalse\n>>> var2 = { 66, 44, 55 }\n>>> var1.isdisjoint(var2)\nTrue\n issubset\n是否是子序列,也就是说如果var2的所有元素都被var1所包含了，那么var2就是var1的子序列\n>>> var1 = {11,22,33,44}\n>>> var2 = {11,22}\n>>> var2.issubset(var1)\nTrue\nissuperset\n是否是父序列\n>>> var1 = { 11, 22, 33 }\n>>> var2 = { 22, 44, 55 }\n>>> var1.issuperset(var2)\nTrue\npop\n移除一个元素，并显示移除的元素，移除时是无序的\n>>> var1 = {11,22,33,44}\n>>> var1.pop()\n33\n>>> var1\n{11, 44, 22}\nsymmetric_difference\n对称交集，把var1存在且b不存在和var2存在且var1不存在的元素合在一起\n>>> var1 = { 11, 22, 33, 44 }\n>>> var2 = { 11, 22, 77, 55 }\n>>> var1.symmetric_difference(var2)\n{33, 44, 77, 55}\nsymmetric_difference_update\n对称交集，并更新到var1中\n>>> var1 = { 11, 22, 33, 44 }\n>>> var2 = { 11, 22, 77, 55 }\n>>> var1\n{33, 11, 44, 22}\n>>> var1.symmetric_difference_update(var2)\n>>> var1\n{33, 44, 77, 55}\nunion\n并集，把两个集合中的所有元素放在一起，如果有重复的则只存放一个\n>>> var1 = { 11, 22, 33, 44 }\n>>> var2 = { 11, 22, 77, 55 }\n>>> var1.union(var2)\n{33, 11, 44, 77, 22, 55}\nupdate\n更新，把一个集合中的元素更新到另一个集合中\n>>> var1 = { 11, 22, 33, 44 }\n>>> var2 = { 11, 22, 77, 55 }\n>>> var1.update(var2)\n>>> var1\n{33, 11, 44, 77, 22, 55}\n\n原文链接\nPython全栈之路系列文章\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "7"}