{"title": "Python中self用法详解 - Python入门 ", "index": "python", "content": "在介绍Python的self用法之前，先来介绍下Python中的类和实例…… 我们知道，面向对象最重要的概念就是类（class）和实例（instance），类是抽象的模板，比如学生这个抽象的事物，可以用一个Student类来表示。而实例是根据类创建出来的一个个具体的“对象”，每一个对象都从类中继承有相同的方法，但各自的数据可能不同。 1、以Student类为例，在Python中，定义类如下：\nclass Student(object):\npass\n12（Object）表示该类从哪个类继承下来的，Object类是所有类都会继承的类。\n2、实例：定义好了类，就可以通过Student类创建出Student的实例，创建实例是通过类名+()实现：\nstudent = Student()13、由于类起到模板的作用，因此，可以在创建实例的时候，把我们认为必须绑定的属性强制填写进去。这里就用到Python当中的一个内置方法__init__方法，例如在Student类时，把name、score等属性绑上去:\nclass Student(object):\ndef __init__(self, name, score):\n    self.name = name\n    self.score = score\n1234这里注意：（1）、__init__方法的第一参数永远是self，表示创建的类实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。（2）、有了__init__方法，在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，但self不需要传，Python解释器会自己把实例变量传进去：\nstudent = Student(\"Hugh\", 99)student.name\"Hugh\"student.score9912345另外，这里self就是指类本身，self.name就是Student类的属性变量，是Student类所有。而name是外部传来的参数，不是Student类所自带的。故，self.name = name的意思就是把外部传来的参数name的值赋值给Student类自己的属性变量self.name。\n4、和普通数相比，在类中定义函数只有一点不同，就是第一参数永远是类的本身实例变量self，并且调用时，不用传递该参数。除此之外，类的方法(函数）和普通函数没啥区别，你既可以用默认参数、可变参数或者关键字参数（args是可变参数，args接收的是一个tuple，*kw是关键字参数，kw接收的是一个dict）。\n5、既然Student类实例本身就拥有这些数据，那么要访问这些数据，就没必要从外面的函数去访问，而可以直接在Student类的内部定义访问数据的函数（方法），这样，就可以把”数据”封装起来。这些封装数据的函数是和Student类本身是关联起来的，称之为类的方法：\nclass Student(obiect):\ndef __init__(self, name, score):\n    self.name = name\n    self.score = score\ndef print_score(self):\n    print \"%s: %s\" % (self.name, self.score)\n123456\nstudent = Student(\"Hugh\", 99)student.print_scoreHugh: 99123这样一来，我们从外部看Student类，就只需要知道，创建实例需要给出name和score。而如何打印，都是在Student类的内部定义的，这些数据和逻辑被封装起来了，调用很容易，但却不知道内部实现的细节。\n如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线，在Python中，实例的变量名如果以开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问，所以，我们把Student类改一改：\nclass Student(object):\ndef __init__(self, name, score):\n    self.__name = name\n    self.__score = score\ndef print_score(self):\n    print \"%s: %s\" %(self.__name,self.__score)\n1234567改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问实例变量.__name和实例变量.__score了：\nstudent = Student('Hugh', 99)student.__nameTraceback (most recent call last):  File \"<stdin>\", line 1, in <module>AttributeError: 'Student' object has no attribute '__name'12345这样就确保了外部代码不能随意修改对象内部的状态，这样通过访问限制的保护，代码更加健壮。\n但是如果外部代码要获取name和score怎么办？可以给Student类增加get_name和get_score这样的方法：\nclass Student(object):\n...\n\ndef get_name(self):\n    return self.__name\n\ndef get_score(self):\n    return self.__score\n12345678如果又要允许外部代码修改score怎么办？可以给Student类增加set_score方法：\nclass Student(object):\n...\n\ndef set_score(self, score):\n    self.__score = score\n12345需要注意的是，在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名。\n有些时候，你会看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。\n封装的另一个好处是可以随时给Student类增加新的方法，比如：get_grade:\nclass Student(object):\n...\ndef get_grade(self):\n    if self.score >= 90:\n        return 'A'\n    elif self.score >= 60:\n        return 'B'\n    else:\n        return 'C'\n123456789同样的，get_grade方法可以直接在实例变量上调用，不需要知道内部实现细节：\nstudent.get_grade()'A'126、self的仔细用法 (1)、self代表类的实例，而非类。\nclass Test:\ndef ppr(self):\n    print(self)\n    print(self.__class__)\n\nt = Test()t.ppr()执行结果：<__main__.Test object at 0x000000000284E080><class '__main__.Test'>12345678910从上面的例子中可以很明显的看出，self代表的是类的实例。而self.__class__则指向类。 注意：把self换成this，结果也一样，但Python中最好用约定俗成的self。 （2）、self可以不写吗？ 在Python解释器的内部，当我们调用t.ppr()时，实际上Python解释成Test.ppr(t)，也就是把self替换成了类的实例。\nclass Test:\ndef ppr():\n    print(self)\n\nt = Test()t.ppr()123456运行结果如下：\nTraceback (most recent call last):  File \"cl.py\", line 6, in <module>\nt.ppr()\nTypeError: ppr() takes 0 positional arguments but 1 was given1234运行时提醒错误如下：ppr在定义时没有参数，但是我们运行时强行传了一个参数。\n由于上面解释过了t.ppr()等同于Test.ppr(t)，所以程序提醒我们多传了一个参数t。\n这里实际上已经部分说明了self在定义时不可以省略。\n当然，如果我们的定义和调用时均不传类实例是可以的，这就是类方法。\nclass Test:\ndef ppr():\n    print(__class__)\n\nTest.ppr()\n运行结果：<class '__main__.Test'>12345678（3）、在继承时，传入的是哪个实例，就是那个传入的实例，而不是指定义了self的类的实例。\nclass Parent:\ndef pprt(self):\n    print(self)\n\nclass Child(Parent):\ndef cprt(self):\n    print(self)\nc = Child()c.cprt()c.pprt()p = Parent()p.pprt()123456789101112运行结果：\n<__main__.Child object at 0x0000000002A47080><__main__.Child object at 0x0000000002A47080><__main__.Parent object at 0x0000000002A47240>123解释： 运行c.cprt()时应该没有理解问题，指的是Child类的实例。 但是在运行c.pprt()时，等同于Child.pprt(c)，所以self指的依然是Child类的实例，由于self中没有定义pprt()方法，所以沿着继承树往上找，发现在父类Parent中定义了pprt()方法，所以就会成功调用。\n（4）、在描述符类中，self指的是描述符类的实例\nclass Desc:\ndef __get__(self, ins, cls):\n    print('self in Desc: %s ' % self )\n    print(self, ins, cls)\nclass Test:\nx = Desc()\ndef prt(self):\n    print('self in Test: %s' % self)\nt = Test()t.prt()t.x1234567891011运行结果如下：\nself in Test: <__main__.Test object at 0x0000000002A570B8>self in Desc: <__main__.Desc object at 0x000000000283E208><__main__.Desc object at 0x000000000283E208> <__main__.Test object at 0x0000000002A570B8> <class '__main__.Test'>123这里主要的疑问应该在：Desc类中定义的self不是应该是调用它的实例t吗？怎么变成了Desc类的实例了呢？ 因为这里调用的是t.x，也就是说是Test类的实例t的属性x，由于实例t中并没有定义属性x，所以找到了类属性x，而该属性是描述符属性，为Desc类的实例而已，所以此处并没有顶用Test的任何方法。                如果你在学习Python的过程中遇见了很多疑问和难题，可以加-q-u-n   227 -435-450里面有软件视频资料免费\n那么我们如果直接通过类来调用属性x也可以得到相同的结果。\n下面是把t.x改为Test.x运行的结果。\nself in Test: <__main__.Test object at 0x00000000022570B8>self in Desc: <__main__.Desc object at 0x000000000223E208><__main__.Desc object at 0x000000000223E208> None <class '__main__.Test'>123总结：以上是之前学习Python时的小结，，同时为pyspark中调用self遇到的问题做铺垫，后面也会对比java，未完待续…….\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}