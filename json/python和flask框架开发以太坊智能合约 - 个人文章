{"title": "python和flask框架开发以太坊智能合约 - 个人文章 ", "index": "智能合约,区块链,以太坊,flask,python", "content": "将数据存储在数据库中是任何软件应用程序不可或缺的一部分。无论如何控制该数据库都有一个该数据的主控。区块链技术将数据存储到区块链网络内的区块中。因此，只要某个节点与网络同步，它们就会获得区块中数据的副本。因此，该技术中没有特定的数据主控。\n在本教程中，我们将编写一份智能合约（我将进一步解释），以便在区块链上保留用户数据。我们将使用python web3（web3的python库）来开发和部署智能合约。一旦我们在区块链上部署了智能合约。我们将使用flask API与智能合约进行交互以存储一些数据/信息。我们将它存储在区块链上，它是不可变的。\n\n环境要求\nPython 3.6\n安装\n1.创建一个python虚拟环境。\nVirtualenv将你的Python软件包本地化保存在你项目的虚拟环境中，而不是强迫你在系统范围内安装软件包。\n$ virtualenv -p /usr/bin/python3.6 venv\n$ source venv/bin/activate\n2.现在我们需要Ganache那样的以太坊测试链。\nGanache是以太坊开发的个人区块链，可用于部署合约，开发应用程序和运行测试。\n$ npm install -g ganache-cli\n3.安装python web3\nWeb3.py是一个用于与以太坊交互的python库。它的API源自Web3.js Javascript API，对于使用过web3.js的人来说应该很熟悉。\n$ pip3 install web3\n4.Flask\nFlask是一个python轻量级框架。\n$ pip3 install flask\n5.Flask Restful\nFlask-RESTful是Flask的扩展，增加了对快速构建REST API的支持。\n$ pip3 install flask-restful\nFlask Marshmallow\nFlask marshmallow是一个对象序列化/反序列化库。\n$ pip3 install flask-marshmallow\n启动以太坊测试区块链服务器\n要部署智能合约，我们应该启动测试以太坊服务器。我们正在使用ganache进行测试。在终端中键入以下命令：\n$ ganache-cli\n\nGanache为我们提供了10个默认测试帐户，每个帐户中有100个假ether，用于交易。我们将使用这些帐户在合约中部署和设置各种值。\n\n我们可以看到gas价格和限制以及部署ganache的host:port。我们在部署合约时需要这个。\n创建user.sol文件\n现在我们将用Solidity编写智能合约。Solidity是在ethereum上编写智能合约的语言。智能合约包括我们将在区块链上存储的数据，数据和getter方法的可选验证函数，访问数据的setter方法。\n例如，要在区块链上进行考勤注册，你将拥有一组用户对象。它将可以访问用户的getter，setter方法。由于每个用户每天只能标记一次出勤，因此你需要一个验证功能来检查，智能合约与我们通常用其他任何语言开发的应用程序非常相似。\n在下面的文件中，我们使用getter，setter函数构建简单的用户合约。\n1.在.sol文件中声明solidity编译器版本。\npragma solidity ^ 0.4.21;\n了解使用的编译器版本。\n$ solidity — version\n2.导入库文件Import library。我们应该将库用于常用的实用程序函数。库可以只编译一次并反复使用（点击这里获取一些好的库资源）。\nimport“stringUtils.sol”;\n3.为用户声明合约\ncontract userRecords {}\n4.现在，对于基本演示，我们将存储有关用户的名称和性别信息。因此，使用struct和enum数据类型初始化这两个变量。\n//枚举类型变量来存储用户性别\nenum genderType { male, female } \n//我们将存储在以太坊合约中的实际用户对象\nstruct user{ \n    string name; genderType gender; \n}\n5.现在我们将声明user(struct)类型的用户对象。也可以将其声明为public，以便从合约外部访问它（有关可见范围，请单击此处）。\nuser user_obj;\n6.现在为用户对象添加getter，setter方法。我们将在区块链上保留每个用户的信息。我们应该始终公开此方法，因为我们将从合约外部访问它们。\n//设置用户公共功能\n//这类似于db中的持久对象。\nfunction setUser(string name, string gender) public {\n    genderType gender_type = getGenderFromString(gender);\n    user_obj = user({name:name, gender: gender_type});\n}\n//获取用户公共功能\n//这类似于从db获取对象。\nfunction getUser() public returns (string, string) { \n    return (user_obj.name, getGenderToString(user_obj.gender));\n}\n7.请注意，我们使用了两个内部函数getGenderFromString()和getGenderToString()。让我们添加这个内部函数。将它们声明为内部，因为我们不会在外面使用它们。\n//用于从string中转换genderType枚举的内部函数\nfunction getGenderFromString(string gender) internal returns(genderType) {\n    if(StringUtils.equal(gender, \"male\")) {\n        return genderType.male;\n    } else {\n        return genderType.female;\n    }\n}\n//将genderType枚举转换为字符串的内部函数\n(string) {\n    if(gender == genderType.male) {\n        return \"male\";\n    } else {\n        return \"female\";\n    }\n}\n我们正在使用stringUtils.equal()库函数。由于此版本的solidity不支持使用（==）进行字符串比较。\n8.现在我们的user.sol文件合约如下所示：\npragma solidity ^0.4.21;\n// import library file\nimport \"stringUtils.sol\";\ncontract userRecords {\n  // enum type variable to store user gender\n  enum genderType { male, female };\n  // Actual user object which we will store\n  struct user{\n    string name;\n    genderType gender;\n  }\n  // user object\n  user user_obj;\n  //Internal function to conver genderType enum from string\n  function getGenderFromString(string gender) internal returns   (genderType) {\n    if(StringUtils.equal(gender, \"male\")) {\n      return genderType.male;\n    } else {\n      return genderType.female;\n    }\n  }\n  //Internal function to convert genderType enum to string\n  function getGenderToString(genderType gender) internal returns (string) {\n    if(gender == genderType.male) {\n      return \"male\";\n    } else {\n      return \"female\";\n    }\n  }\n  // set user public function\n  // This is similar to persisting object in db.\n  function setUser(string name, string gender) public {\n    genderType gender_type = getGenderFromString(gender);\n    user_obj = user({name:name, gender: gender_type});\n  }\n  \n  // get user public function\n  // This is similar to getting object from db.\n  function getUser() public returns (string, string) {\n    return (user_obj.name, getGenderToString(user_obj.gender));\n  }\n}\n使用python脚本编译和部署solidity文件。\n1.在下面的python脚本中，我们需要实例化python-web3测试以太坊节点。我们将设置ganche url为测试以太坊节点。我们将使用下面的w3对象来部署合约。\nfrom web3 import Web3\n# web3.py instance\nw3 = Web3(Web3.HTTPProvider(\"http://127.0.0.1:8545\"))\n2.现在我们将编译solidity代码。为了编译solidity代码，我们使用py-solc，它是用于solidity编译器的python扩展。\nfrom solc import compile_files\n# 编译所有合约文件\ncontracts = compile_files(['user.sol', 'stringUtils.sol'])\n# 单独的主文件和链接文件\nmain_contract = contracts.pop(\"user.sol:userRecords\")\nlibrary_link = contracts.pop(\"stringUtils.sol:StringUtils\")\n3.每当使用import语句编译.sol文件时。我们还需要链接导入文件的部署地址以及主合约。 因此，对于部署所有链接首先通过编译它（如果已经部署然后保存地址）请参见下图主合约的bin。\n\n当你编译主合约时，如果你看到它的bin部分，你将找到我们正在导入的库的_stringUtils.sol:StringUtils ___________（它也可以用于合约）。 这部分我们应该通过在部署合约之前的库地址来替换它。\n4.然后我们将库地址与主合约相关联。\nfrom solc import link_code\ndef deploy_contract(contract_interface):\n    #实例化和部署合约\n    contract = w3.eth.contract(\n        abi=contract_interface['abi'],\n        bytecode=contract_interface['bin']\n    )\n    #从已部署的合约中获取交易哈希\n    tx_hash = contract.deploy(\n        transaction={'from': w3.eth.accounts[1]}\n    )\n    #获取tx收据以获取合约地址\n    tx_receipt = w3.eth.getTransactionReceipt(tx_hash)\n    return tx_receipt['contractAddress']\nlibrary_address = {\n    \"stringUtils.sol:StringUtils\": deploy_contract(library_link)\n}\nmain_contract['bin'] = link_code(\n    main_contract['bin'], library_address\n)\n链接后主合约bin的见下图：\n\n你将看到导入库的bin已添加。\n5.现在使用我们的w3对象部署主合约。使用ethereum account {'from':w3.eth.accounts [1]}的默认地址进行部署。\ndef deploy_contract(contract_interface):\n    # 实例化和部署合约\n    contract = w3.eth.contract(\n        abi=contract_interface['abi'],\n        bytecode=contract_interface['bin']\n    )\n    # 从部署的合约中获取交易哈希\n    tx_hash = contract.deploy(\n        transaction={'from': w3.eth.accounts[1]}\n    )\n    # 获取tx收据以获取合同地址\n    tx_receipt = w3.eth.getTransactionReceipt(tx_hash)\n    return tx_receipt['contractAddress']\ncontract_address = deploy_contract(main_contract)\n你将在运行ganache测试服务器的选项卡中看到以下这行：\n\n这与合约部署后在tx_receipt中获得的信息相同。\n6.现在将abi和contract_address存储在json文件中。这样我们以后可以在flask api中使用它来存储合约中的用户对象。\n# 在json文件中添加abi（应用程序二进制接口）和交易收据\nwith open('data.json', 'w') as outfile:\n    data = {\n       \"abi\": main_contract['abi'],\n       \"contract_address\": deploy_contract(main_contract)\n    }\n    json.dump(data, outfile, indent=4, sort_keys=True)\n7.现在我们的完整脚本如下所示：\nimport json\nfrom web3 import Web3\nfrom solc import compile_files, link_code, compile_source\n# web3.py instance\nw3 = Web3(Web3.HTTPProvider(\"http://127.0.0.1:8545\"))\ndef deploy_contract(contract_interface):\n    # Instantiate and deploy contract\n    contract = w3.eth.contract(\n        abi=contract_interface['abi'],\n        bytecode=contract_interface['bin']\n    )\n    # Get transaction hash from deployed contract\n    tx_hash =contract.deploy(transaction{'from':w3.eth.accounts[1]})\n    # Get tx receipt to get contract address\n    tx_receipt = w3.eth.getTransactionReceipt(tx_hash)\n    return tx_receipt['contractAddress']\n# compile all contract files\ncontracts = compile_files(['user.sol', 'stringUtils.sol'])\n# separate main file and link file\nmain_contract = contracts.pop(\"user.sol:userRecords\")\nlibrary_link = contracts.pop(\"stringUtils.sol:StringUtils\")\n# print bin part in  console you will see 'stringUtils' in that we need to link library address in that bin code.\n# to that we have to deploy library code first then link it\nlibrary_address = {\n    \"stringUtils.sol:StringUtils\": deploy_contract(library_link)\n}\nmain_contract['bin'] = link_code(\n    main_contract['bin'], library_address)\n# add abi(application binary interface) and transaction reciept in json file\nwith open('data.json', 'w') as outfile:\n    data = {\n        \"abi\": main_contract['abi'],\n        \"contract_address\": deploy_contract(main_contract)\n    }\n    json.dump(data, outfile, indent=4, sort_keys=True)\n创建flask api以为用户存储不同的值\n你只需部署一次合约。但是使用它的地址，你会一次又一次地存储数据。同样，在db的世界中，你只需定义一次模型/模式，但你将在db中添加不同的行/文档。\n我们将使用flask post api来获取用户的用户信息并返回成功。\nfrom flask import Flask, Response, request, jsonify\nfrom marshmallow import Schema, fields, ValidationError\ndef check_gender(data):\n    valid_list = [\"male\", \"female\"]\n    if data not in valid_list:\n        raise ValidationError(\n            'Invalid gender. Valid choices are'+ valid_list\n        )\n#For api validations\nclass UserSchema(Schema):\n    name = fields.String(required=True)\n    gender = fields.String(required=True, validate=check_gender)\n# Initializing flask app\napp = Flask(__name__)\n# api to set new user every api call\n@app.route(\"/blockchain/user\", methods=['POST'])\ndef user():\n    body = request.get_json()\n    result, error = UserSchema().load(body)\n    if error:\n        return jsonify(error), 422\n    return jsonify({\"data\": result}), 200\n由于这不是flask教程，我不会详细说明这一点，如果flask不熟悉可以看这个flask教程学习下。我们的API用户将从客户端获取数据（curl请求）并对其进行验证将其返回给客户端（curl请求）\n2.现在我们将初始化web3对象以与已部署的用户合约进行通信。\nfrom web3 import Web3\n# web3.py instance\nw3 = Web3(Web3.HTTPProvider(\"http://127.0.0.1:8545\"))\n3.现在我们将获得之前存储在data.json文件中的abi和合约地址。\nwith open(\"data.json\", 'r') as f:\n     datastore = json.load(f)\n     abi = datastore[\"abi\"]\n     contract_address = datastore[\"contract_address\"]\n4.选择交易的默认帐户地址。每次在合约中为用户设置新值。你会从钱包里拿出一些gas。\nw3.eth.defaultAccount = w3.eth.accounts[1]\n5.最后，你将在以太坊合约中设置api调用用户对象时获得的值。\n@app.route(\"/blockchain/user\", methods=['POST'])\ndef user():\n    # Create the contract instance with the newly-deployed address\n    user = w3.eth.contract(address=contract_address, abi=abi)\n    body = request.get_json()\n    result, error = UserSchema().load(body)\n    if error:\n        return jsonify(error), 422\n    tx_hash = user.functions.setUser(\n        result['name'],result['gender']\n    )\n    tx_hash = tx_hash.transact()\n    # Wait for transaction to be mined...\n    w3.eth.waitForTransactionReceipt(tx_hash)\n    user_data = user.functions.getUser().call()\n    return jsonify({\"data\": user_data}), 200\n我们首先使用abi和contract_address获得部署合约。\nuser = w3.eth.contract(address=contract_address, abi=abi)\n然后我们可以使用合约实例调用任何合约公共函数。在为用户设置值之后，我们将使用transact方法将其公之于众。这将在以太坊区块中添加新的用户值。\ntx_hash = user.functions.setUser(\n    result['name'],result['gender']\n).transact()\n现在我们可以使用call方法获得已在合约中设置的值，这将调用合约函数而不在区块链中添加任何区块。\nuser_data = user.functions.getUser().call()\n我们的api文件的最终代码如下所示。将其另存为app.py。\nimport json\nfrom flask import Flask, Response, request, jsonify\nfrom marshmallow import Schema, fields, ValidationError\nfrom web3 import Web3\n# web3.py instance\nw3 = Web3(Web3.HTTPProvider(\"http://127.0.0.1:8545\"))\nw3.eth.defaultAccount = w3.eth.accounts[1]\n# Get stored abi and contract_address\nwith open(\"data.json\", 'r') as f:\n    datastore = json.load(f)\n    abi = datastore[\"abi\"]\n    contract_address = datastore[\"contract_address\"]\ndef check_gender(data):\n    valid_list = [\"male\", \"female\"]\n    if data not in valid_list:\n        raise ValidationError(\n            'Invalid gender. Valid choices are'+ valid_list\n        )\n#For api validations\nclass UserSchema(Schema):\n    name = fields.String(required=True)\n    gender = fields.String(required=True, validate=check_gender)\n# Initializing flask app\napp = Flask(__name__)\n# api to set new user every api call\n@app.route(\"/blockchain/user\", methods=['POST'])\ndef user():\n    # Create the contract instance with the newly-deployed address\n    user = w3.eth.contract(address=contract_address, abi=abi)\n    body = request.get_json()\n    result, error = UserSchema().load(body)\n    if error:\n        return jsonify(error), 422\n    tx_hash = user.functions.setUser(\n        result['name'],result['gender']\n    ).transact()\n    # Wait for transaction to be mined...\n    receipt = w3.eth.waitForTransactionReceipt(tx_hash)\n    user_data = user.functions.getUser().call()\n    return jsonify({\"data\": user_data}), 200\n运行以下命令以启动服务器。\n$ FLASK_APP=app.py flask run\n用curl调用api\n$ curl -H \"Content-Type: application/json\" --request POST -d '{\"name\":\"John Doe\",\"gender\":\"male\"}' http://localhost:5000/blockchain/user\n你也可以在这里找到完整代码。\npython用web3.py库开发以太坊来说非常的方便，有兴趣的用户可以关注我们的python以太坊教程，主要是针对python工程师使用web3.py进行区块链以太坊开发的详解。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}