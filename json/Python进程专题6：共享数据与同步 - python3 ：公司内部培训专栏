{"title": "Python进程专题6：共享数据与同步 - python3 ：公司内部培训专栏 ", "index": "python", "content": "上一篇文章：Python进程专题5：进程间通信下一篇文章：Python进程专题7：托管对象\n\n我们现在知道，进程之间彼此是孤立的，唯一通信的方式是队列或管道，但要让这两种方式完成进程间通信，底层离不开共享内容，这就是今天的主角：共享内存。\n创建共享值得方法\nValue\nv=Value(typecode,arg1,...,argN,lock):\ntypecode:要么是包含array模块使用的相同类型代码（如'i'、'd'等）的字符串，要么是来自ctypes模块的类型对象\n（例如：ctypes.c_int,ctypes.c_double等）。\narg1,...,argN:传递给构造函数的参数。\nlock：只能使用关键字传入的参数，默认为True：将创建一个新锁来保护对值的访问。如果传入一个现有锁，该锁将用于进行同步。\n\n访问底层的值：v.value\nRawValue\nr=RawValue(typecode,arg1,...,argN):同Value对象，唯一区别是不存在lock\nArray\na=Array(typecode,initializer,lock):在共享内存中创建ctypes数组。\ninitializer：要么是设置数组初始大小的整数，要么是项序列，其值和大小用于初始化数组。\n可以使用标准的Python索引、切片、迭代操作访问它，其中每项操作均→锁进程同步，\n对于字节字符串，a还具有a.value属性，可以把整个数组当做一个字符串进行访问。\nRawArray\nr=RawArray(typcode,initlizer):同Array，单不存在锁。当所编写的程序必须一次性操作大量的数组项时，\n如果同时使用这种数据类型和用于同步的单独大的锁，性能将极大提升。\n同步原语\n除了使用上面方法创建共享值，multiprocess模块还提供了一下同步原语的共享版本。\n\n\n原语\n描述\n\n\n\nLock\n互斥锁\n\n\nRLock\n可重入的互斥锁（同一个进程可以多吃获得它，同时不会造成阻塞）\n\n\nSemaphore\n信号量\n\n\nBoundedSemaphore\n有边界的信号量\n\n\nEvent\n事件\n\n\nCondition\n条件变量\n\n\n\n实例：使用共享数组代替管道，将一个由浮点数组成的Python队列发送给另外一个进程。\n代码：\n#使用共享数组代替管道，将一个由浮点数组成的Python列表发送给另外一个进程\nimport multiprocessing\n\nclass FloatChannel(object):\n    def __init__(self,maxsize):\n        #在共享内存中创建一个试数组\n        self.buffer=multiprocessing.RawArray('d',maxsize)\n        #在共享内存中创建ctypes对象\n        self.buffer_len=multiprocessing.Value('i')\n        #定义一个信号量1代表：empty\n        self.empty=multiprocessing.Semaphore(1)\n        #定义一个信号量0代表：full\n        self.full=multiprocessing.Semaphore(0)\n\n    def send(self,values):\n        #只在缓存为null时继续\n        #acquire()会阻塞线程，直到release被调用\n        self.empty.acquire()\n        nitems=len(values)\n        print(\"保存内容的长度\",nitems)\n        #设置缓冲区大小\n        self.buffer_len.value=nitems\n        #将值复制到缓冲区中\n        self.buffer[:nitems]=values\n        print(self.buffer[:nitems])\n        #发信号通知缓冲区已满\n        self.full.release()\n\n    def recv(self):\n        #只在缓冲区已满时继续\n        self.full.acquire()\n        #复制值\n        values=self.buffer[:self.buffer_len.value]\n        #发送信号，通知缓冲区为空\n        self.empty.release()\n        return values\n\n#性能测试，接受多条消息\ndef consume_test(count,ch):\n    #for i in range(count):\n        values=ch.recv()\n        print(\"接收到的值：\",values)\n\n#性能测试，发送多条消息\ndef produce_test(count,values,ch):\n    #for i in range(count):\n        print(\"发送：\",values)\n        ch.send(values)\n\n\nif __name__==\"__main__\":\n    ch=FloatChannel(10000)\n    p=multiprocessing.Process(target=consume_test,args=(1000,ch))\n\n    p.start()\n\n    values=[float(x) for x in range(10)]\n\n    produce_test(10,values,ch)\n\n    print(\"done\")\n\n    p.join()\n\n结果：\n发送： [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]\n保存内容的长度 10\n[0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]\ndone\n接收到的值： [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}