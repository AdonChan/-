{"title": "Python 弱引用 学习 - nummy的专栏 ", "index": "python", "content": "参考 1.weakref – Garbage-collectable references to objects2.Python弱引用介绍\n和许多其它的高级语言一样，Python使用了垃圾回收器来自动销毁那些不再使用的对象。每个对象都有一个引用计数，当这个引用计数为0时Python能够安全地销毁这个对象。\n引用计数会记录给定对象的引用个数，并在引用个数为零时收集该对象。由于一次仅能有一个对象被回收，引用计数无法回收循环引用的对象。\n一组相互引用的对象若没有被其它对象直接引用，并且不可访问，则会永久存活下来。一个应用程序如果持续地产生这种不可访问的对象群组，就会发生内存泄漏。\n在对象群组内部使用弱引用（即不会在引用计数中被计数的引用）有时能避免出现引用环，因此弱引用可用于解决循环引用的问题。\n在计算机程序设计中，弱引用，与强引用相对，是指不能确保其引用的对象不会被垃圾回收器回收的引用。一个对象若只被弱引用所引用，则可能在任何时刻被回收。弱引用的主要作用就是减少循环引用，减少内存中不必要的对象存在的数量。\n使用weakref模块，你可以创建到对象的弱引用，Python在对象的引用计数为0或只存在对象的弱引用时将回收这个对象。\n创建弱引用\n你可以通过调用weakref模块的ref(obj[,callback])来创建一个弱引用，obj是你想弱引用的对象，callback是一个可选的函数，当因没有引用导致Python要销毁这个对象时调用。回调函数callback要求单个参数（弱引用的对象）。\n一旦你有了一个对象的弱引用，你就能通过调用弱引用来获取被弱引用的对象。\n>>>>　import　sys\n>>>　import　weakref\n>>>　class　Man:\n　　def　__init__(self,name):\n　　　　print　self.name = name\n　　　　\n>>>　o　=　Man('Jim')\n>>>　sys.getrefcount(o)   \n2\n>>>　r　=　weakref.ref(o)　#　创建一个弱引用\n>>>　sys.getrefcount(o)　#　引用计数并没有改变\n2\n>>>　r\n<weakref　at　00D3B3F0;　to　'instance'　at　00D37A30>　#　弱引用所指向的对象信息\n>>>　o2　=　r()　#　获取弱引用所指向的对象\n>>>　o　is　o2\nTrue\n>>>　sys.getrefcount(o)\n3\n>>>　o　=　None\n>>>　o2　=　None\n>>>　r　#　当对象引用计数为零时，弱引用失效。\n<weakref　at　00D3B3F0;　dead>de>\n上面的代码中，我们使用sys包中的getrefcount()来查看某个对象的引用计数。需要注意的是，当使用某个引用作为参数，传递给getrefcount()时，参数实际上创建了一个临时的引用。因此，getrefcount()所得到的结果，会比期望的多1。\n一旦没有了对这个对象的其它的引用，调用弱引用将返回None，因为Python已经销毁了这个对象。 注意：大部分的对象不能通过弱引用来访问。\nweakref模块中的getweakrefcount(obj)和getweakrefs(obj)分别返回弱引用数和关于所给对象的引用列表。\n弱引用对于创建对象(这些对象很费资源)的缓存是有用的。\n创建代理对象\n代理对象是弱引用对象，它们的行为就像它们所引用的对象，这就便于你不必首先调用弱引用来访问背后的对象。通过weakref模块的proxy(obj[,callback])函数来创建代理对象。使用代理对象就如同使用对象本身一样：\nimport weakref\n\nclass Man:\n    def __init__(self, name):\n        self.name = name\n    def test(self):\n        print \"this is a test!\"\n\ndef callback(self):\n    print \"callback\"\n    \no = Man('Jim')\np = weakref.proxy(o, callback)\np.test()\no=None\np.test()\ncallback参数的作用和ref函数中callback一样。在Python删除了一个引用的对象之后，使用代理将会导致一个weakref.ReferenceError错误。\n循环引用\n前面说过，使用弱引用，可以解决循环引用不能被垃圾回收的问题。首先我们看下常规的循环引用，先创建一个简单的Graph类，然后创建三个Graph实例：\n# -*- coding:utf-8 -*-\nimport weakref\nimport gc\nfrom pprint import pprint\n\n\nclass Graph(object):\n    def __init__(self, name):\n        self.name = name\n        self.other = None\n\n    def set_next(self, other):\n        print \"%s.set_next(%r)\" % (self.name, other)\n        self.other = other\n\n    def all_nodes(self):\n        yield self\n        n = self.other\n        while n and n.name !=self.name:\n            yield n\n            n = n.other\n        if n is self:\n            yield n\n        return\n\n    def __str__(self):\n        return \"->\".join(n.name for n in self.all_nodes())\n\n    def __repr__(self):\n        return \"<%s at 0x%x name=%s>\" % (self.__class__.__name__, id(self), self.name)\n\n    def __del__(self):\n        print \"(Deleting %s)\" % self.name\n\ndef collect_and_show_garbage():\n    print \"Collecting...\"\n    n = gc.collect()\n    print \"unreachable objects:\", n\n    print \"garbage:\",\n    pprint(gc.garbage)\n\n\ndef demo(graph_factory):\n    print \"Set up graph:\"\n    one = graph_factory(\"one\")\n    two = graph_factory(\"two\")\n    three = graph_factory(\"three\")\n    one.set_next(two)\n    two.set_next(three)\n    three.set_next(one)\n\n    print\n    print \"Graph:\"\n    print str(one)\n    collect_and_show_garbage()\n\n    print\n    three = None\n    two = None\n    print \"After 2 references removed\"\n    print str(one)\n    collect_and_show_garbage()\n\n    print\n    print \"removeing last reference\"\n    one = None\n    collect_and_show_garbage()\n\n\ngc.set_debug(gc.DEBUG_LEAK)\nprint \"Setting up the cycle\"\nprint \ndemo(Graph)\nprint\nprint \"breaking the cycle and cleaning up garbage\"\nprint\ngc.garbage[0].set_next(None)\nwhile gc.garbage:\n    del gc.garbage[0]\nprint collect_and_show_garbage()\n这里使用了python的gc库的几个方法， 解释如下：\n\ngc.collect()  收集垃圾\ngc.garbage    获取垃圾列表\ngc.set_debug(gc.DBEUG_LEAK) 打印无法看到的对象信息\n\n运行结果如下：\nSetting up the cycle\n\nSet up graph:\none.set_next(<Graph at 0x25c9e70 name=two>)\ntwo.set_next(<Graph at 0x25c9e90 name=three>)\nthree.set_next(<Graph at 0x25c9e50 name=one>)\n\nGraph:\none->two->three->one\nCollecting...\nunreachable objects:g 0\ngarbage:[]\n\nAfter 2 references removed\none->two->three->one\nCollecting...\nunreachable objects: 0\ngarbage:[]\n\nremoveing last reference\nCollecting...\nunreachable objects: 6\ngarbage:[<Graph at 0x25c9e50 name=one>,\n <Graph at 0x25c9e70 name=two>,\n <Graph at 0x25c9e90 name=three>,\n {'name': 'one', 'other': <Graph at 0x25c9e70 name=two>},\n {'name': 'two', 'other': <Graph at 0x25c9e90 name=three>},\n {'name': 'three', 'other': <Graph at 0x25c9e50 name=one>}]\n\nbreaking the cycle and cleaning up garbage\n\none.set_next(None)\n(Deleting two)\n(Deleting three)\n(Deleting one)\nCollecting...\nunreachable objects: 0\ngarbage:[]\nNone\n[Finished in 0.4s]c: uncollectable <Graph 025C9E50>\ngc: uncollectable <Graph 025C9E70>\ngc: uncollectable <Graph 025C9E90>\ngc: uncollectable <dict 025D3030>\ngc: uncollectable <dict 025D30C0>\ngc: uncollectable <dict 025C1F60>\n从结果中我们可以看出，即使我们删除了Graph实例的本地引用，它依然存在垃圾列表中，不能回收。接下来创建使弱引用的WeakGraph类：\nclass WeakGraph(Graph):\n    def set_next(self, other):\n        if other is not None:\n            if self in other.all_nodes():\n                other = weakref.proxy(other)\n        super(WeakGraph, self).set_next(other)\n        return\ndemo(WeakGraph)\n结果如下：\nSetting up the cycle\n\nSet up graph:\none.set_next(<WeakGraph at 0x23f9ef0 name=two>)\ntwo.set_next(<WeakGraph at 0x23f9f10 name=three>)\nthree.set_next(<weakproxy at 023F8810 to WeakGraph at 023F9ED0>)\n\nGraph:\none->two->three\nCollecting...\nunreachable objects:Traceback (most recent call last):\n  File \"D:\\apps\\platform\\demo\\demo.py\", line 87, in <module>\n    gc.garbage[0].set_next(None)\nIndexError: list index out of range\n 0\ngarbage:[]\n\nAfter 2 references removed\none->two->three\nCollecting...\nunreachable objects: 0\ngarbage:[]\n\nremoveing last reference\n(Deleting one)\n(Deleting two)\n(Deleting three)\nCollecting...\nunreachable objects: 0\ngarbage:[]\n\nbreaking the cycle and cleaning up garbage\n\n[Finished in 0.4s with exit code 1]\n上面的类中，使用代理来指示已看到的对象，随着demo()删除了对象的所有本地引用，循环会断开，这样垃圾回收期就可以将这些对象删除。\n因此我们我们在实际工作中如果需要用到循环引用的话，尽量采用弱引用来实现。\n缓存对象\nref和proxy都只可用与维护单个对象的弱引用，如果想同时创建多个对象的弱引用咋办？这时可以使用WeakKeyDictionary和WeakValueDictionary来实现。\nWeakValueDictionary类，顾名思义，本质上还是个字典类型，只是它的值类型是弱引用。当这些值引用的对象不再被其他非弱引用对象引用时，那么这些引用的对象就可以通过垃圾回收器进行回收。下面的例子说明了常规字典与WeakValueDictionary的区别。\n# -*- coding:utf-8 -*-\nimport weakref\nimport gc\nfrom pprint import pprint\n\ngc.set_debug(gc.DEBUG_LEAK)\n\n\nclass Man(object):\n    def __init__(self, name):\n        self.name = name\n\n    def __repr__(self):\n        return '<Man name=%s>' % self.name\n\n    def __del__(self):\n        print \"deleting %s\" % self\n\n\ndef demo(cache_factory):\n    all_refs = {}\n    print \"cache type:\", cache_factory\n    cache = cache_factory()\n    for name in [\"Jim\", 'Tom', 'Green']:\n        man = Man(name)\n        cache[name] = man\n        all_refs[name] = man\n        del man\n    print \"all_refs=\",\n    pprint(all_refs)\n    print\n    print \"before, cache contains:\", cache.keys()\n    for name, value in cache.items():\n        print \"%s = %s\" % (name, value)\n    print \"\\ncleanup\"\n    del all_refs\n    gc.collect()\n\n    print\n    print \"after, cache contains:\", cache.keys()\n    for name, value in cache.items():\n        print \"%s = %s\" % (name, value)\n    print \"demo returning\"\n    return\n\ndemo(dict)\nprint\n\ndemo(weakref.WeakValueDictionary)\n\n结果如下所示：\ncache type: <type 'dict'>\nall_refs={'Green': <Man name=Green>, 'Jim': <Man name=Jim>, 'Tom': <Man name=Tom>}\n\nbefore, cache contains: ['Jim', 'Green', 'Tom']\nJim = <Man name=Jim>\nGreen = <Man name=Green>\nTom = <Man name=Tom>\n\ncleanup\n\nafter, cache contains: ['Jim', 'Green', 'Tom']\nJim = <Man name=Jim>\nGreen = <Man name=Green>\nTom = <Man name=Tom>\ndemo returning\ndeleting <Man name=Jim>\ndeleting <Man name=Green>\ndeleting <Man name=Tom>\n\ncache type: weakref.WeakValueDictionary\nall_refs={'Green': <Man name=Green>, 'Jim': <Man name=Jim>, 'Tom': <Man name=Tom>}\n\nbefore, cache contains: ['Jim', 'Green', 'Tom']\nJim = <Man name=Jim>\nGreen = <Man name=Green>\nTom = <Man name=Tom>\n\ncleanup\ndeleting <Man name=Jim>\ndeleting <Man name=Green>\n\nafter, cache contains: []\ndemo returning\n\n[Finished in 0.3s]\n\n                ", "mainLikeNum": ["4 "], "mainBookmarkNum": "8"}