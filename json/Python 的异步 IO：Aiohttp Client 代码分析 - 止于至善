{"title": "Python 的异步 IO：Aiohttp Client 代码分析 - 止于至善 ", "index": "http,asyncio,python", "content": "Python 的异步 IO：Aiohttp Client 代码分析\nAiohttp 是 Python 的一个 HTTP 框架，基于 asyncio，所以叫 Aiohttp。\n我主要是看源码，想理解它的设计，所以附上了类图与时序图。不可避免的，可读性会比较差。想找教程的话，请移步 官方教程，写得还是挺不错的。\n一个例子\n下面这个例子，通过 HTTP GET 列出 GitHub 的 public events：\nimport asyncio\nimport aiohttp\n\nasync def main():\n    async with aiohttp.ClientSession() as session:\n        async with session.get('https://api.github.com/events') as resp:\n            print(resp.status)\n            print(await resp.text())\n\nloop = asyncio.get_event_loop()\nloop.run_until_complete(main())\nResponse 是一个 JSON 格式的文本：\n[\n  {\n    \"id\": \"6888907432\",\n    \"type\": \"PushEvent\",\n    \"actor\": {\n      \"id\": 3956266,\n      \"login\": \"sekineh\",\n      \"display_login\": \"sekineh\",\n      \"gravatar_id\": \"\",\n      \"url\": \"https://api.github.com/users/sekineh\",\n      \"avatar_url\": \"https://avatars.githubusercontent.com/u/3956266?\"\n    },\n    ...\n]\nClientSession 是一个 Asynchronous Context Manager，所以搭配 async with 语句一起使用。像下面这样应该也是可以的：\nasync def main():\n    session = aiohttp.ClientSession()\n    ...\n    await session.close()\n不过肯定是不推荐的，就当是帮助理解吧。\nClientSession.get() 返回一个 ClientResponse 对象，通过 text() 方法，可以拿到  response 的文本：\nprint(await resp.text())\n当然，text() 是一个协程：\n    @asyncio.coroutine\n    def text(self, encoding=None, errors='strict'):\n        \"\"\"Read response payload and decode.\"\"\"\n        ...\nConnector\nClientSession  依赖 Connector 来创建连接，缺省为 TCPConnector，它继承自 BaseConnector，此外还有 UnixConnector（应该是 Unix Domain Socket）。\nConnector 的接口比较简单，主要提供了 connect() 方法（也是协程）：\n    @asyncio.coroutine\n    def connect(self, req):\n        \"\"\"Get from pool or create new connection.\"\"\"\n        ...\n以及 close() 方法：\n    def close(self):\n        \"\"\"Close all opened transports.\"\"\"\n        ...\nConnectionKey\nClientRequest 有个属性 connection_key：\nclass ClientRequest:\n    @property\n    def connection_key(self):\n        return ConnectionKey(self.host, self.port, self.ssl)\n它是一个 namedtuple：\nConnectionKey = namedtuple('ConnectionKey', ['host', 'port', 'ssl'])\n由 host，port 和 ssl 三个元素组成，这三个元素可以唯一定义一个连接，所以叫 ConnectionKey。文章开头的那个例子中，ConnectionKey 为：\nConnectionKey(host='api.github.com', port=443, ssl=True)\n全局函数 request()\nAiohttp 为 Client 程序提供了一个全局函数 request()，用法如下：\nasync def main():\n    resp = await aiohttp.request('GET', 'http://python.org/')\n    print(resp)\n    \nloop = asyncio.get_event_loop()\nloop.run_until_complete(main())\n可见 request() 只是 ClientSession 的一个简单封装，其步骤大致为：\n\n创建 TCPConnector；\n创建 ClientSession；\n调用 ClientSession._request()。\n\n建议不要直接使用 request()，而只把它当成 ClientSession 的一个样例。因为 Aiohttp 官方文档是 这样说的：\nDon’t create a session per request. Most likely you need a session per application which performs all requests altogether.A session contains a connection pool inside, connection reusage and keep-alives (both are on by default) may speed up total performance.\n\n即，一个 request 用一个 session，太浪费；通常是一个 application 用一个 session。\n一些小问题\n我经常发现一个变量，明明可以是局部变量，却被当成了成员变量。\nRequest 里放了一个 response？\nclass ClientRequest:\n    def send(self, conn):\n        ...\n        self.response = self.response_class(\n            self.method, self.original_url,\n            writer=self._writer, ...\n        )\n\n        self.response._post_init(self.loop, self._session)\n        return self.response\nself.response 在 ClientRequest 其他地方并没有用到，是否可以改成局部变量？\nClientResponse.start() 里的 _protocol 应该用局部变量吧？\nclass ClientResponse:\n   @asyncio.coroutine\n    def start(self, connection, read_until_eof=False):\n        \"\"\"Start response processing.\"\"\"\n        self._closed = False\n        self._protocol = connection.protocol\n类图\n\n时序图\n\nThe End\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "1"}