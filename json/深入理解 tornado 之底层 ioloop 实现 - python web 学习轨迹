{"title": "深入理解 tornado 之底层 ioloop 实现 - python web 学习轨迹 ", "index": "python,tornado", "content": "最近打算学习 tornado 的源码，所以就建立一个系列主题 “深入理解 tornado”。 在此记录学习经历及个人见解与大家分享。文中一定会出现理解不到位或理解错误的地方，还请大家多多指教 \n进入正题：\ntornado 优秀的大并发处理能力得益于它的 web server 从底层开始就自己实现了一整套基于 epoll 的单线程异步架构（其他 python web 框架的自带 server 基本是基于 wsgi 写的简单服务器，并没有自己实现底层结构。 关于 wsgi 详见之前的文章： 自己写一个 wsgi 服务器运行 Django 、Tornado 应用）。 那么 tornado.ioloop 就是 tornado web server 最底层的实现。\n看 ioloop 之前，我们需要了解一些预备知识，有助于我们理解 ioloop。\nepoll\nioloop 的实现基于 epoll ，那么什么是 epoll？ epoll 是Linux内核为处理大批量文件描述符而作了改进的 poll 。那么什么又是 poll ？ 首先，我们回顾一下， socket 通信时的服务端，当它接受（ accept ）一个连接并建立通信后（ connection ）就进行通信，而此时我们并不知道连接的客户端有没有信息发完。 这时候我们有两种选择：\n\n一直在这里等着直到收发数据结束；\n每隔一定时间来看看这里有没有数据；\n\n第二种办法要比第一种好一些，多个连接可以统一在一定时间内轮流看一遍里面有没有数据要读写，看上去我们可以处理多个连接了，这个方式就是 poll / select 的解决方案。 看起来似乎解决了问题，但实际上，随着连接越来越多，轮询所花费的时间将越来越长，而服务器连接的 socket 大多不是活跃的，所以轮询所花费的大部分时间将是无用的。为了解决这个问题， epoll 被创造出来，它的概念和 poll 类似，不过每次轮询时，他只会把有数据活跃的 socket 挑出来轮询，这样在有大量连接时轮询就节省了大量时间。\n对于 epoll 的操作，其实也很简单，只要 4 个 API 就可以完全操作它。\nepoll_create\n用来创建一个 epoll 描述符（ 就是创建了一个 epoll ）\nepoll_ctl\n操作 epoll 中的 event；可用参数有：\n\n\n参数\n含义\n\n\n\nEPOLL_CTL_ADD\n添加一个新的epoll事件\n\n\nEPOLL_CTL_DEL\n删除一个epoll事件\n\n\nEPOLL_CTL_MOD\n改变一个事件的监听方式\n\n\n\n而事件的监听方式有七种，而我们只需要关心其中的三种：\n\n\n宏定义\n含义\n\n\n\nEPOLLIN\n缓冲区满，有数据可读\n\n\nEPOLLOUT\n缓冲区空，可写数据\n\n\nEPOLLERR\n发生错误\n\n\n\nepoll_wait\n就是让 epoll 开始工作，里面有个参数 timeout，当设置为非 0 正整数时，会监听（阻塞） timeout 秒；设置为 0 时立即返回，设置为 -1 时一直监听。\n在监听时有数据活跃的连接时其返回活跃的文件句柄列表（此处为 socket 文件句柄）。\nclose\n关闭 epoll\n现在了解了 epoll 后，我们就可以来看 ioloop 了 （如果对 epoll 还有疑问可以看这两篇资料： epoll 的原理是什么、百度百科：epoll）\ntornado.ioloop\n很多初学者一定好奇 tornado 运行服务器最后那一句 tornado.ioloop.IOLoop.current().start() 到底是干什么的。 我们先不解释作用，来看看这一句代码背后到底都在干什么。\n先贴 ioloop 代码：\nfrom __future__ import absolute_import, division, print_function, with_statement\n\nimport datetime\nimport errno\nimport functools\nimport heapq       # 最小堆\nimport itertools\nimport logging\nimport numbers\nimport os\nimport select\nimport sys\nimport threading\nimport time\nimport traceback\nimport math\n\nfrom tornado.concurrent import TracebackFuture, is_future\nfrom tornado.log import app_log, gen_log\nfrom tornado.platform.auto import set_close_exec, Waker\nfrom tornado import stack_context\nfrom tornado.util import PY3, Configurable, errno_from_exception, timedelta_to_seconds\n\ntry:\n    import signal\nexcept ImportError:\n    signal = None\n\n\nif PY3:\n    import _thread as thread\nelse:\n    import thread\n\n\n_POLL_TIMEOUT = 3600.0\n\n\nclass TimeoutError(Exception):\n    pass\n\n\nclass IOLoop(Configurable):\n    _EPOLLIN = 0x001\n    _EPOLLPRI = 0x002\n    _EPOLLOUT = 0x004\n    _EPOLLERR = 0x008\n    _EPOLLHUP = 0x010\n    _EPOLLRDHUP = 0x2000\n    _EPOLLONESHOT = (1 << 30)\n    _EPOLLET = (1 << 31)\n\n    # Our events map exactly to the epoll events\n    NONE = 0\n    READ = _EPOLLIN\n    WRITE = _EPOLLOUT\n    ERROR = _EPOLLERR | _EPOLLHUP\n\n    # Global lock for creating global IOLoop instance\n    _instance_lock = threading.Lock()\n\n    _current = threading.local()\n\n    @staticmethod\n    def instance():\n        if not hasattr(IOLoop, \"_instance\"):\n            with IOLoop._instance_lock:\n                if not hasattr(IOLoop, \"_instance\"):\n                    # New instance after double check\n                    IOLoop._instance = IOLoop()\n        return IOLoop._instance\n\n    @staticmethod\n    def initialized():\n        \"\"\"Returns true if the singleton instance has been created.\"\"\"\n        return hasattr(IOLoop, \"_instance\")\n\n    def install(self):\n        assert not IOLoop.initialized()\n        IOLoop._instance = self\n\n    @staticmethod\n    def clear_instance():\n        \"\"\"Clear the global `IOLoop` instance.\n        .. versionadded:: 4.0\n        \"\"\"\n        if hasattr(IOLoop, \"_instance\"):\n            del IOLoop._instance\n\n    @staticmethod\n    def current(instance=True):\n        current = getattr(IOLoop._current, \"instance\", None)\n        if current is None and instance:\n            return IOLoop.instance()\n        return current\n\n    def make_current(self):\n        IOLoop._current.instance = self\n\n    @staticmethod\n    def clear_current():\n        IOLoop._current.instance = None\n\n    @classmethod\n    def configurable_base(cls):\n        return IOLoop\n\n    @classmethod\n    def configurable_default(cls):\n        if hasattr(select, \"epoll\"):\n            from tornado.platform.epoll import EPollIOLoop\n            return EPollIOLoop\n        if hasattr(select, \"kqueue\"):\n            # Python 2.6+ on BSD or Mac\n            from tornado.platform.kqueue import KQueueIOLoop\n            return KQueueIOLoop\n        from tornado.platform.select import SelectIOLoop\n        return SelectIOLoop\n\n    def initialize(self, make_current=None):\n        if make_current is None:\n            if IOLoop.current(instance=False) is None:\n                self.make_current()\n        elif make_current:\n            if IOLoop.current(instance=False) is not None:\n                raise RuntimeError(\"current IOLoop already exists\")\n            self.make_current()\n\n    def close(self, all_fds=False):\n        raise NotImplementedError()\n\n    def add_handler(self, fd, handler, events):\n        raise NotImplementedError()\n\n    def update_handler(self, fd, events):\n        raise NotImplementedError()\n\n    def remove_handler(self, fd):\n        raise NotImplementedError()\n\n    def set_blocking_signal_threshold(self, seconds, action):\n        raise NotImplementedError()\n\n    def set_blocking_log_threshold(self, seconds):\n        self.set_blocking_signal_threshold(seconds, self.log_stack)\n\n    def log_stack(self, signal, frame):\n        gen_log.warning('IOLoop blocked for %f seconds in\\n%s',\n                        self._blocking_signal_threshold,\n                        ''.join(traceback.format_stack(frame)))\n\n    def start(self):\n        raise NotImplementedError()\n\n    def _setup_logging(self):\n        if not any([logging.getLogger().handlers,\n                    logging.getLogger('tornado').handlers,\n                    logging.getLogger('tornado.application').handlers]):\n            logging.basicConfig()\n\n    def stop(self):\n        raise NotImplementedError()\n\n    def run_sync(self, func, timeout=None):\n        future_cell = [None]\n\n        def run():\n            try:\n                result = func()\n                if result is not None:\n                    from tornado.gen import convert_yielded\n                    result = convert_yielded(result)\n            except Exception:\n                future_cell[0] = TracebackFuture()\n                future_cell[0].set_exc_info(sys.exc_info())\n            else:\n                if is_future(result):\n                    future_cell[0] = result\n                else:\n                    future_cell[0] = TracebackFuture()\n                    future_cell[0].set_result(result)\n            self.add_future(future_cell[0], lambda future: self.stop())\n        self.add_callback(run)\n        if timeout is not None:\n            timeout_handle = self.add_timeout(self.time() + timeout, self.stop)\n        self.start()\n        if timeout is not None:\n            self.remove_timeout(timeout_handle)\n        if not future_cell[0].done():\n            raise TimeoutError('Operation timed out after %s seconds' % timeout)\n        return future_cell[0].result()\n\n    def time(self):\n        return time.time()\n...\nIOLoop 类首先声明了 epoll 监听事件的宏定义，当然，如前文所说，我们只要关心其中的 EPOLLIN 、 EPOLLOUT 、 EPOLLERR 就行。\n类中的方法有很多，看起来有点晕，但其实我们只要关心 IOLoop 核心功能的方法即可，其他的方法在明白核心功能后也就不难理解了。所以接下来我们着重分析核心代码。\ninstance 、 initialized、 install、 clear_instance、 current、 make_current、 clear_current 这些方法不用在意细节，总之现在记住它们都是为了让 IOLoop 类变成一个单例，保证从全局上调用的都是同一个 IOLoop 就好。\n你一定疑惑 IOLoop 为何没有 __init__， 其实是因为要初始化成为单例，IOLoop 的 new 函数已经被改写了，同时指定了 initialize 做为它的初始化方法，所以此处没有 __init__ 。 说到这，ioloop 的代码里好像没有看到 new 方法，这又是什么情况？ 我们先暂时记住这里。\n接着我们来看这个初始化方法：\ndef initialize(self, make_current=None):\n        if make_current is None:\n            if IOLoop.current(instance=False) is None:\n                self.make_current()\n        elif make_current:\n            if IOLoop.current(instance=False) is None:\n                raise RuntimeError(\"current IOLoop already exists\")\n            self.make_current()\n\n    def make_current(self):\n        IOLoop._current.instance = self\nwhat? 里面只是判断了是否第一次初始化或者调用 self.make_current（） 初始化，而 make_current()  里也仅仅是把实例指定为自己，那么初始化到底去哪了？\n然后再看看 start() 、 run() 、 close() 这些关键的方法都成了返回 NotImplementedError 错误，全部未定义？！跟网上搜到的源码分析完全不一样啊。 这时候看下 IOLoop 的继承关系，原来问题出在这里，之前的 tornado.ioloop 继承自 object 所以所有的一切都自己实现，而现在版本的 tornado.ioloop 则继承自 Configurable 看起来现在的 IOLoop 已经成为了一个基类，只定义了接口。 所以接着看 Configurable 代码：\ntornado.util.Configurable\nclass Configurable(object):\n    __impl_class = None\n    __impl_kwargs = None\n\n    def __new__(cls, *args, **kwargs):\n        base = cls.configurable_base()\n        init_kwargs = {}\n        if cls is base:\n            impl = cls.configured_class()\n            if base.__impl_kwargs:\n                init_kwargs.update(base.__impl_kwargs)\n        else:\n            impl = cls\n        init_kwargs.update(kwargs)\n        instance = super(Configurable, cls).__new__(impl)\n        # initialize vs __init__ chosen for compatibility with AsyncHTTPClient\n        # singleton magic.  If we get rid of that we can switch to __init__\n        # here too.\n        instance.initialize(*args, **init_kwargs)\n        return instance\n\n    @classmethod\n    def configurable_base(cls):\n        \"\"\"Returns the base class of a configurable hierarchy.\n\n        This will normally return the class in which it is defined.\n        (which is *not* necessarily the same as the cls classmethod parameter).\n        \"\"\"\n        raise NotImplementedError()\n\n    @classmethod\n    def configurable_default(cls):\n        \"\"\"Returns the implementation class to be used if none is configured.\"\"\"\n        raise NotImplementedError()\n\n    def initialize(self):\n        \"\"\"Initialize a `Configurable` subclass instance.\n\n        Configurable classes should use `initialize` instead of ``__init__``.\n\n        .. versionchanged:: 4.2\n           Now accepts positional arguments in addition to keyword arguments.\n        \"\"\"\n\n    @classmethod\n    def configure(cls, impl, **kwargs):\n        \"\"\"Sets the class to use when the base class is instantiated.\n\n        Keyword arguments will be saved and added to the arguments passed\n        to the constructor.  This can be used to set global defaults for\n        some parameters.\n        \"\"\"\n        base = cls.configurable_base()\n        if isinstance(impl, (unicode_type, bytes)):\n            impl = import_object(impl)\n        if impl is not None and not issubclass(impl, cls):\n            raise ValueError(\"Invalid subclass of %s\" % cls)\n        base.__impl_class = impl\n        base.__impl_kwargs = kwargs\n\n    @classmethod\n    def configured_class(cls):\n        \"\"\"Returns the currently configured class.\"\"\"\n        base = cls.configurable_base()\n        if cls.__impl_class is None:\n            base.__impl_class = cls.configurable_default()\n        return base.__impl_class\n\n    @classmethod\n    def _save_configuration(cls):\n        base = cls.configurable_base()\n        return (base.__impl_class, base.__impl_kwargs)\n\n    @classmethod\n    def _restore_configuration(cls, saved):\n        base = cls.configurable_base()\n        base.__impl_class = saved[0]\n        base.__impl_kwargs = saved[1]\n之前我们寻找的 __new__ 出现了！ 注意其中这句： impl = cls.configured_class() impl 在这里就是 epoll ，它的生成函数是 configured_class()， 而其方法里又有 base.__impl_class = cls.configurable_default() ，调用了 configurable_default() 。而 Configurable 的 configurable_default():\ndef configurable_default(cls):\n        \"\"\"Returns the implementation class to be used if none is configured.\"\"\"\n        raise NotImplementedError()\n显然也是个接口，那么我们再回头看 ioloop 的 configurable_default():\ndef configurable_default(cls):\n        if hasattr(select, \"epoll\"):\n            from tornado.platform.epoll import EPollIOLoop\n            return EPollIOLoop\n        if hasattr(select, \"kqueue\"):\n            # Python 2.6+ on BSD or Mac\n            from tornado.platform.kqueue import KQueueIOLoop\n            return KQueueIOLoop\n        from tornado.platform.select import SelectIOLoop\n        return SelectIOLoop\n原来这是个工厂函数，根据不同的操作系统返回不同的事件池（linux 就是 epoll， mac 返回 kqueue，其他就返回普通的 select。 kqueue 基本等同于 epoll， 只是不同系统对其的不同实现）\n现在线索转移到了 tornado.platform.epoll.EPollIOLoop 上，我们再来看看 EPollIOLoop:\ntornado.platform.epoll.EPollIOLoop\nimport select\n\nfrom tornado.ioloop import PollIOLoop\n\n\nclass EPollIOLoop(PollIOLoop):\n    def initialize(self, **kwargs):\n        super(EPollIOLoop, self).initialize(impl=select.epoll(), **kwargs)\nEPollIOLoop 完全继承自 PollIOLoop （注意这里是 PollIOLoop 不是 IOLoop）并只是在初始化时指定了 impl 是 epoll，所以看起来我们用 IOLoop 初始化最后初始化的其实就是这个 PollIOLoop，所以接下来，我们真正需要理解和阅读的内容应该都在这里：\ntornado.ioloop.PollIOLoop\nclass PollIOLoop(IOLoop):\n    \"\"\"Base class for IOLoops built around a select-like function.\n\n    For concrete implementations, see `tornado.platform.epoll.EPollIOLoop`\n    (Linux), `tornado.platform.kqueue.KQueueIOLoop` (BSD and Mac), or\n    `tornado.platform.select.SelectIOLoop` (all platforms).\n    \"\"\"\n    def initialize(self, impl, time_func=None, **kwargs):\n        super(PollIOLoop, self).initialize(**kwargs)\n        self._impl = impl\n        if hasattr(self._impl, 'fileno'):\n            set_close_exec(self._impl.fileno())\n        self.time_func = time_func or time.time\n        self._handlers = {}\n        self._events = {}\n        self._callbacks = []\n        self._callback_lock = threading.Lock()\n        self._timeouts = []\n        self._cancellations = 0\n        self._running = False\n        self._stopped = False\n        self._closing = False\n        self._thread_ident = None\n        self._blocking_signal_threshold = None\n        self._timeout_counter = itertools.count()\n\n        # Create a pipe that we send bogus data to when we want to wake\n        # the I/O loop when it is idle\n        self._waker = Waker()\n        self.add_handler(self._waker.fileno(),\n                         lambda fd, events: self._waker.consume(),\n                         self.READ)\n\n    def close(self, all_fds=False):\n        with self._callback_lock:\n            self._closing = True\n        self.remove_handler(self._waker.fileno())\n        if all_fds:\n            for fd, handler in self._handlers.values():\n                self.close_fd(fd)\n        self._waker.close()\n        self._impl.close()\n        self._callbacks = None\n        self._timeouts = None\n\n    def add_handler(self, fd, handler, events):\n        fd, obj = self.split_fd(fd)\n        self._handlers[fd] = (obj, stack_context.wrap(handler))\n        self._impl.register(fd, events | self.ERROR)\n\n    def update_handler(self, fd, events):\n        fd, obj = self.split_fd(fd)\n        self._impl.modify(fd, events | self.ERROR)\n\n    def remove_handler(self, fd):\n        fd, obj = self.split_fd(fd)\n        self._handlers.pop(fd, None)\n        self._events.pop(fd, None)\n        try:\n            self._impl.unregister(fd)\n        except Exception:\n            gen_log.debug(\"Error deleting fd from IOLoop\", exc_info=True)\n\n    def set_blocking_signal_threshold(self, seconds, action):\n        if not hasattr(signal, \"setitimer\"):\n            gen_log.error(\"set_blocking_signal_threshold requires a signal module \"\n                          \"with the setitimer method\")\n            return\n        self._blocking_signal_threshold = seconds\n        if seconds is not None:\n            signal.signal(signal.SIGALRM,\n                          action if action is not None else signal.SIG_DFL)\n\n    def start(self):\n        ...\n\n        try:\n            while True:\n                # Prevent IO event starvation by delaying new callbacks\n                # to the next iteration of the event loop.\n                with self._callback_lock:\n                    callbacks = self._callbacks\n                    self._callbacks = []\n\n                # Add any timeouts that have come due to the callback list.\n                # Do not run anything until we have determined which ones\n                # are ready, so timeouts that call add_timeout cannot\n                # schedule anything in this iteration.\n                due_timeouts = []\n                if self._timeouts:\n                    now = self.time()\n                    while self._timeouts:\n                        if self._timeouts[0].callback is None:\n                            # The timeout was cancelled.  Note that the\n                            # cancellation check is repeated below for timeouts\n                            # that are cancelled by another timeout or callback.\n                            heapq.heappop(self._timeouts)\n                            self._cancellations -= 1\n                        elif self._timeouts[0].deadline <= now:\n                            due_timeouts.append(heapq.heappop(self._timeouts))\n                        else:\n                            break\n                    if (self._cancellations > 512\n                            and self._cancellations > (len(self._timeouts) >> 1)):\n                        # Clean up the timeout queue when it gets large and it's\n                        # more than half cancellations.\n                        self._cancellations = 0\n                        self._timeouts = [x for x in self._timeouts\n                                          if x.callback is not None]\n                        heapq.heapify(self._timeouts)\n\n                for callback in callbacks:\n                    self._run_callback(callback)\n                for timeout in due_timeouts:\n                    if timeout.callback is not None:\n                        self._run_callback(timeout.callback)\n                # Closures may be holding on to a lot of memory, so allow\n                # them to be freed before we go into our poll wait.\n                callbacks = callback = due_timeouts = timeout = None\n\n                if self._callbacks:\n                    # If any callbacks or timeouts called add_callback,\n                    # we don't want to wait in poll() before we run them.\n                    poll_timeout = 0.0\n                elif self._timeouts:\n                    # If there are any timeouts, schedule the first one.\n                    # Use self.time() instead of 'now' to account for time\n                    # spent running callbacks.\n                    poll_timeout = self._timeouts[0].deadline - self.time()\n                    poll_timeout = max(0, min(poll_timeout, _POLL_TIMEOUT))\n                else:\n                    # No timeouts and no callbacks, so use the default.\n                    poll_timeout = _POLL_TIMEOUT\n\n                if not self._running:\n                    break\n\n                if self._blocking_signal_threshold is not None:\n                    # clear alarm so it doesn't fire while poll is waiting for\n                    # events.\n                    signal.setitimer(signal.ITIMER_REAL, 0, 0)\n\n                try:\n                    event_pairs = self._impl.poll(poll_timeout)\n                except Exception as e:\n                    # Depending on python version and IOLoop implementation,\n                    # different exception types may be thrown and there are\n                    # two ways EINTR might be signaled:\n                    # * e.errno == errno.EINTR\n                    # * e.args is like (errno.EINTR, 'Interrupted system call')\n                    if errno_from_exception(e) == errno.EINTR:\n                        continue\n                    else:\n                        raise\n\n                if self._blocking_signal_threshold is not None:\n                    signal.setitimer(signal.ITIMER_REAL,\n                                     self._blocking_signal_threshold, 0)\n\n                # Pop one fd at a time from the set of pending fds and run\n                # its handler. Since that handler may perform actions on\n                # other file descriptors, there may be reentrant calls to\n                # this IOLoop that update self._events\n                self._events.update(event_pairs)\n                while self._events:\n                    fd, events = self._events.popitem()\n                    try:\n                        fd_obj, handler_func = self._handlers[fd]\n                        handler_func(fd_obj, events)\n                    except (OSError, IOError) as e:\n                        if errno_from_exception(e) == errno.EPIPE:\n                            # Happens when the client closes the connection\n                            pass\n                        else:\n                            self.handle_callback_exception(self._handlers.get(fd))\n                    except Exception:\n                        self.handle_callback_exception(self._handlers.get(fd))\n                fd_obj = handler_func = None\n\n        finally:\n            # reset the stopped flag so another start/stop pair can be issued\n            self._stopped = False\n            if self._blocking_signal_threshold is not None:\n                signal.setitimer(signal.ITIMER_REAL, 0, 0)\n            IOLoop._current.instance = old_current\n            if old_wakeup_fd is not None:\n                signal.set_wakeup_fd(old_wakeup_fd)\n\n    def stop(self):\n        self._running = False\n        self._stopped = True\n        self._waker.wake()\n\n    def time(self):\n        return self.time_func()\n\n    def call_at(self, deadline, callback, *args, **kwargs):\n        timeout = _Timeout(\n            deadline,\n            functools.partial(stack_context.wrap(callback), *args, **kwargs),\n            self)\n        heapq.heappush(self._timeouts, timeout)\n        return timeout\n\n    def remove_timeout(self, timeout):\n        # Removing from a heap is complicated, so just leave the defunct\n        # timeout object in the queue (see discussion in\n        # http://docs.python.org/library/heapq.html).\n        # If this turns out to be a problem, we could add a garbage\n        # collection pass whenever there are too many dead timeouts.\n        timeout.callback = None\n        self._cancellations += 1\n\n    def add_callback(self, callback, *args, **kwargs):\n        with self._callback_lock:\n            if self._closing:\n                raise RuntimeError(\"IOLoop is closing\")\n            list_empty = not self._callbacks\n            self._callbacks.append(functools.partial(\n                stack_context.wrap(callback), *args, **kwargs))\n            if list_empty and thread.get_ident() != self._thread_ident:\n                # If we're in the IOLoop's thread, we know it's not currently\n                # polling.  If we're not, and we added the first callback to an\n                # empty list, we may need to wake it up (it may wake up on its\n                # own, but an occasional extra wake is harmless).  Waking\n                # up a polling IOLoop is relatively expensive, so we try to\n                # avoid it when we can.\n                self._waker.wake()\n\n    def add_callback_from_signal(self, callback, *args, **kwargs):\n        with stack_context.NullContext():\n            if thread.get_ident() != self._thread_ident:\n                # if the signal is handled on another thread, we can add\n                # it normally (modulo the NullContext)\n                self.add_callback(callback, *args, **kwargs)\n            else:\n                # If we're on the IOLoop's thread, we cannot use\n                # the regular add_callback because it may deadlock on\n                # _callback_lock.  Blindly insert into self._callbacks.\n                # This is safe because the GIL makes list.append atomic.\n                # One subtlety is that if the signal interrupted the\n                # _callback_lock block in IOLoop.start, we may modify\n                # either the old or new version of self._callbacks,\n                # but either way will work.\n                self._callbacks.append(functools.partial(\n                    stack_context.wrap(callback), *args, **kwargs))\n果然， PollIOLoop 继承自 IOLoop 并实现了它的所有接口，现在我们终于可以进入真正的正题了\nioloop 分析\n首先要看的是关于 epoll 操作的方法，还记得前文说过的 epoll 只需要四个 api 就能完全操作嘛？ 我们来看 PollIOLoop 的实现：\nepoll 操作\ndef add_handler(self, fd, handler, events):\n    fd, obj = self.split_fd(fd)\n    self._handlers[fd] = (obj, stack_context.wrap(handler))\n    self._impl.register(fd, events | self.ERROR)\n\ndef update_handler(self, fd, events):\n    fd, obj = self.split_fd(fd)\n    self._impl.modify(fd, events | self.ERROR)\n\ndef remove_handler(self, fd):\n    fd, obj = self.split_fd(fd)\n    self._handlers.pop(fd, None)\n    self._events.pop(fd, None)\n    try:\n        self._impl.unregister(fd)\n        except Exception:\n            gen_log.debug(\"Error deleting fd from IOLoop\", exc_info=True)\nepoll_ctl：这个三个方法分别对应 epoll_ctl 中的 add 、 modify 、 del 参数。 所以这三个方法实现了 epoll 的 epoll_ctl 。\nepoll_create：然后 epoll 的生成在前文 EPollIOLoop 的初始化中就已经完成了：super(EPollIOLoop, self).initialize(impl=select.epoll(), **kwargs)。 这个相当于 epoll_create 。\nepoll_wait：epoll_wait 操作则在 start() 中：event_pairs = self._impl.poll(poll_timeout)\nepoll_close：而 epoll 的 close 则在 PollIOLoop 中的 close 方法内调用： self._impl.close() 完成。\ninitialize\n接下来看 PollIOLoop 的初始化方法中作了什么：\ndef initialize(self, impl, time_func=None, **kwargs):\n        super(PollIOLoop, self).initialize(**kwargs)\n        self._impl = impl                         # 指定 epoll\n        if hasattr(self._impl, 'fileno'):\n            set_close_exec(self._impl.fileno())   # fork 后关闭无用文件描述符\n        self.time_func = time_func or time.time   # 指定获取当前时间的函数\n        self._handlers = {}                       # handler 的字典，储存被 epoll 监听的 handler，与打开它的文件描述符 ( file descriptor 简称 fd ) 一一对应\n        self._events = {}                         # event 的字典，储存 epoll 返回的活跃的 fd event pairs\n        self._callbacks = []                      # 储存各个 fd 回调函数的列表\n        self._callback_lock = threading.Lock()    # 指定进程锁\n        self._timeouts = []                       # 将是一个最小堆结构，按照超时时间从小到大排列的 fd 的任务堆（ 通常这个任务都会包含一个 callback ）\n        self._cancellations = 0                   # 关于 timeout 的计数器\n        self._running = False                     # ioloop 是否在运行\n        self._stopped = False                     # ioloop 是否停止\n        self._closing = False                     # ioloop 是否关闭\n        self._thread_ident = None                 #  当前线程堆标识符 （ thread identify ）\n        self._blocking_signal_threshold = None    # 系统信号， 主要用来在 epoll_wait 时判断是否会有 signal alarm 打断 epoll\n        self._timeout_counter = itertools.count() # 超时计数器 ( 暂时不是很明白具体作用，好像和前面的 _cancellations 有关系？ 请大神讲讲)\n        self._waker = Waker()                     # 一个 waker 类，主要是对于管道 pipe 的操作，因为 ioloop 属于底层的数据操作，这里 epoll 监听的是 pipe\n        self.add_handler(self._waker.fileno(),\n                         lambda fd, events: self._waker.consume(),\n                         self.READ)               # 将管道加入 epoll 监听，对于 web server 初始化时只需要关心 READ 事件\n除了注释中的解释，还有几点补充：\n\nclose_exec 的作用： 子进程在fork出来的时候，使用了写时复制（COW，Copy-On-Write）方式获得父进程的数据空间、 堆和栈副本，这其中也包括文件描述符。刚刚fork成功时，父子进程中相同的文件描述符指向系统文件表中的同一项，接着，一般我们会调用exec执行另一个程序，此时会用全新的程序替换子进程的正文，数据，堆和栈等。此时保存文件描述符的变量当然也不存在了，我们就无法关闭无用的文件描述符了。所以通常我们会fork子进程后在子进程中直接执行close关掉无用的文件描述符，然后再执行exec。 所以 close_exec 执行的其实就是 关闭 ＋ 执行的作用。 详情可以查看： 关于linux进程间的close-on-exec机制\n\nWaker()： Waker 封装了对于管道 pipe 的操作：\ndef set_close_exec(fd):\n    flags = fcntl.fcntl(fd, fcntl.F_GETFD)\n    fcntl.fcntl(fd, fcntl.F_SETFD, flags | fcntl.FD_CLOEXEC)\n    \ndef _set_nonblocking(fd):\n    flags = fcntl.fcntl(fd, fcntl.F_GETFL)\n    fcntl.fcntl(fd, fcntl.F_SETFL, flags | os.O_NONBLOCK)\n\nclass Waker(interface.Waker):\n    def __init__(self):\n        r, w = os.pipe()\n        _set_nonblocking(r)\n        _set_nonblocking(w)\n        set_close_exec(r)\n        set_close_exec(w)\n        self.reader = os.fdopen(r, \"rb\", 0)\n        self.writer = os.fdopen(w, \"wb\", 0)\n\n    def fileno(self):\n        return self.reader.fileno()\n\n    def write_fileno(self):\n        return self.writer.fileno()\n\n    def wake(self):\n        try:\n            self.writer.write(b\"x\")\n        except IOError:\n            pass\n\n    def consume(self):\n        try:\n            while True:\n                result = self.reader.read()\n                if not result:\n                    break\n        except IOError:\n            pass\n\n    def close(self):\n        self.reader.close()\n        self.writer.close()\n可以看到 waker 把 pipe 分为读、 写两个管道并都设置了非阻塞和 close_exec。 注意wake(self)方法中：self.writer.write(b\"x\") 直接向管道中写入随意字符从而释放管道。\n\n\nstart\nioloop 最核心的部分：\ndef start(self):\n        if self._running:       # 判断是否已经运行\n            raise RuntimeError(\"IOLoop is already running\")\n        self._setup_logging()\n        if self._stopped:\n            self._stopped = False  # 设置停止为假\n            return\n        old_current = getattr(IOLoop._current, \"instance\", None)\n        IOLoop._current.instance = self\n        self._thread_ident = thread.get_ident()  # 获得当前线程标识符\n        self._running = True # 设置运行\n\n        old_wakeup_fd = None\n        if hasattr(signal, 'set_wakeup_fd') and os.name == 'posix':\n            try:\n                old_wakeup_fd = signal.set_wakeup_fd(self._waker.write_fileno())\n                if old_wakeup_fd != -1:\n                    signal.set_wakeup_fd(old_wakeup_fd)\n                    old_wakeup_fd = None\n            except ValueError:\n                old_wakeup_fd = None\n\n        try:\n            while True:  # 服务器进程正式开始，类似于其他服务器的 serve_forever\n                with self._callback_lock: # 加锁，_callbacks 做为临界区不加锁进行读写会产生脏数据\n                    callbacks = self._callbacks # 读取 _callbacks\n                    self._callbacks = []. # 清空 _callbacks\n                due_timeouts = [] # 用于存放这个周期内已过期（ 已超时 ）的任务\n                if self._timeouts: # 判断 _timeouts 里是否有数据\n                    now = self.time() # 获取当前时间，用来判断 _timeouts 里的任务有没有超时\n                    while self._timeouts: # _timeouts 有数据时一直循环, _timeouts 是个最小堆，第一个数据永远是最小的， 这里第一个数据永远是最接近超时或已超时的\n                        if self._timeouts[0].callback is None: # 超时任务无回调\n                            heapq.heappop(self._timeouts) # 直接弹出\n                            self._cancellations -= 1 # 超时计数器 －1\n                        elif self._timeouts[0].deadline <= now: # 判断最小的数据是否超时\n                            due_timeouts.append(heapq.heappop(self._timeouts)) # 超时就加到已超时列表里。\n                        else:\n                            break # 因为最小堆，如果没超时就直接退出循环（ 后面的数据必定未超时 ）\n                    if (self._cancellations > 512\n                            and self._cancellations > (len(self._timeouts) >> 1)):  # 当超时计数器大于 512 并且 大于 _timeouts 长度一半（ >> 为右移运算， 相当于十进制数据被除 2 ）时，清零计数器，并剔除 _timeouts 中无 callbacks 的任务\n                        self._cancellations = 0\n                        self._timeouts = [x for x in self._timeouts\n                                          if x.callback is not None]\n                        heapq.heapify(self._timeouts) # 进行 _timeouts 最小堆化\n\n                for callback in callbacks:\n                    self._run_callback(callback) # 运行 callbacks 里所有的 calllback\n                for timeout in due_timeouts:\n                    if timeout.callback is not None:\n                        self._run_callback(timeout.callback) # 运行所有已过期任务的 callback\n                callbacks = callback = due_timeouts = timeout = None # 释放内存\n\n                if self._callbacks: # _callbacks 里有数据时\n                    poll_timeout = 0.0 # 设置 epoll_wait 时间为0（ 立即返回 ）\n                elif self._timeouts: # _timeouts 里有数据时\n                    poll_timeout = self._timeouts[0].deadline - self.time() \n                    # 取最小过期时间当 epoll_wait 等待时间，这样当第一个任务过期时立即返回\n                    poll_timeout = max(0, min(poll_timeout, _POLL_TIMEOUT))\n                    # 如果最小过期时间大于默认等待时间 _POLL_TIMEOUT ＝ 3600，则用 3600，如果最小过期时间小于0 就设置为0 立即返回。\n                else:\n                    poll_timeout = _POLL_TIMEOUT # 默认 3600 s 等待时间\n\n                if not self._running: # 检查是否有系统信号中断运行，有则中断，无则继续\n                    break\n\n                if self._blocking_signal_threshold is not None:\n                    signal.setitimer(signal.ITIMER_REAL, 0, 0) # 开始 epoll_wait 之前确保 signal alarm 都被清空（ 这样在 epoll_wait 过程中不会被 signal alarm 打断 ）\n\n                try:\n                    event_pairs = self._impl.poll(poll_timeout) # 获取返回的活跃事件队\n                except Exception as e:\n                    if errno_from_exception(e) == errno.EINTR:\n                        continue\n                    else:\n                        raise\n\n                if self._blocking_signal_threshold is not None:\n                    signal.setitimer(signal.ITIMER_REAL,\n                                     self._blocking_signal_threshold, 0) #  epoll_wait 结束， 再设置 signal alarm\n                self._events.update(event_pairs) # 将活跃事件加入 _events\n                while self._events:\n                    fd, events = self._events.popitem() # 循环弹出事件\n                    try:\n                        fd_obj, handler_func = self._handlers[fd] # 处理事件\n                        handler_func(fd_obj, events)\n                    except (OSError, IOError) as e:\n                        if errno_from_exception(e) == errno.EPIPE:\n                            pass\n                        else:\n                            self.handle_callback_exception(self._handlers.get(fd))\n                    except Exception:\n                        self.handle_callback_exception(self._handlers.get(fd))\n                fd_obj = handler_func = None\n\n        finally:\n            self._stopped = False # 确保发生异常也继续运行\n            if self._blocking_signal_threshold is not None:\n                signal.setitimer(signal.ITIMER_REAL, 0, 0) # 清空 signal alarm\n            IOLoop._current.instance = old_current \n            if old_wakeup_fd is not None:\n                signal.set_wakeup_fd(old_wakeup_fd)   # 和 start 开头部分对应，但是不是很清楚作用，求老司机带带路\nstop\ndef stop(self):\n    self._running = False\n    self._stopped = True\n    self._waker.wake()\n这个很简单，设置判断条件，然后调用 self._waker.wake() 向 pipe 写入随意字符唤醒 ioloop 事件循环。 over！\n总结\n噗，写了这么长，终于写完了。 经过分析，我们可以看到， ioloop 实际上是对 epoll 的封装，并加入了一些对上层事件的处理和 server 相关的底层处理。\n最后，感谢大家不辞辛苦看到这，文中理解有误的地方还请多多指教！\n原文地址作者：rapospectre\n\n                ", "mainLikeNum": ["6 "], "mainBookmarkNum": "30"}