{"title": "Python入门细节 - 个人文章 ", "index": "python", "content": "python入门细节\n相除后的类型\ntype(2/2)\nfloat\ntype(2//2)\nint\n双斜杠是整除，出来的类型是int。单斜杠的出来的是float类型。\n进制表示和转换\n进制表示：\n\n二进制：0b\n八进制：0o\n十六进制：0x\n\n进制转换：\n\n转换为二进制：bin()\n转换为八进制：oct()\n转换为十进制：int()\n转换为十六进制：hex()\n转换为布尔类型：bool()\n\n布尔类型\n布尔类型转换：bool()\n\n布尔类型属于数字这个基本数据类型里面\n只要是非零的数字，bool类型的值为True\n对于字符串，布尔类型为True，除了空字符串\nbool值为False:\n\n\nbool(0)\nbool('') 中间没有空格\nbool([])\nbool({})\nbool(None)\nbool(NoneType)\nbool(set{})\n\n多行字符串\n三个引号可以再IDLE下回车不会执行换行。print函数可以输出n这样的反义字符。单个引号想回车换行可以再前面加上字符即可。\n'''\nsadasdj\nadas\n'''\nOut[1]: '\\nsadasdj\\nadas\\n'\n\n'asda\n  File \"<ipython-input-2-6af9d7d5e65d>\", line 1\n    'asda\n         ^\nSyntaxError: EOL while scanning string literal\n\n\n'asdd\\\nadsad\\\nsad'\nOut[3]: 'asddadsadsad'\n\nprint('asda\\nsada\\n')\nasda\nsada\n\n\n'''\nasda\\n\n'''\nOut[5]: '\\nasda\\n\\n'\n原始字符串\n原始字符串在print时只是输出里面的字符，不考虑反义之类的，小心r大写R都没有关系。\nprint(r'c:\\nsda\\nsds')\nc:\\nsda\\nsds\n\nprint(r'let's go')\n  File \"<ipython-input-3-a81b31c0c433>\", line 1\n    print(r'let's go')\n                ^\nSyntaxError: invalid syntax\n字符串的运算\n1.字符串的'+'和'*'\n\"hello\"+\"world\"\nOut[1]: 'helloworld'\n\n\"hello\"*3\nOut[2]: 'hellohellohello'\n2.获取字符串里的字符\n\"hello world\"[0]\nOut[3]: 'h'\n\n\"hello world\"[-1]\nOut[4]: 'd'\n\n# 包括左面但是不包括右面\n\"hello world\"[0:4]\nOut[5]: 'hell'\n\n\"hello world\"[0:-1]\nOut[6]: 'hello worl'\n\n# 超出长度时会按字符串最大的长度进行截取\n\"hello world\"[0:20]\nOut[7]: 'hello world'\n# 没有右边的值的时候，表示直接输出到末尾\n\"hello world\"[6:]\nOut[8]: 'world'\n# 负数在冒号前面的时候\n\"hello world\"[-4:]\nOut[9]: 'orld'\npython表示序列的方式\n1.列表(list)\n\n列表中的元素可以是任意类型的组合，比如列表的嵌套，布尔类型，字符串等等。\n1.1 基本操作1.1.1 基本选取(切片）\n[\"新月打击\",\"苍白之瀑\",\"月之降临\",\"月神冲刺\"]\nOut[10]: ['新月打击', '苍白之瀑', '月之降临', '月神冲刺']\n\n[\"新月打击\",\"苍白之瀑\",\"月之降临\",\"月神冲刺\"][0]\nOut[11]: '新月打击'\n\n[\"新月打击\",\"苍白之瀑\",\"月之降临\",\"月神冲刺\"][0:2]\nOut[12]: ['新月打击', '苍白之瀑']\n\n[\"新月打击\",\"苍白之瀑\",\"月之降临\",\"月神冲刺\"][-1:]\nOut[13]: ['月神冲刺']\n\n\na = [1,2,3,4,5,6,7,8]\nprint(a[0:3])\nprint(a[0:len(a):2])\nprint(a[len(a):0:-2])\n\n[1, 2, 3]\n[1, 3, 5, 7]\n[8, 6, 4, 2]\n\n#可以看到，切片操作很简单，第二个冒号后面的数字可以看作是步长。注意负数时的用法。\n可以看到，当没有冒号的时候，单个选取出的是元素的类型。但是当有冒号的时候，选取出的是序列的类型。这里需要注意\n1.1.2 列表的相加和乘法\n[\"新月打击\",\"苍白之瀑\",\"月之降临\",\"月神冲刺\"]+['虚弱','点燃']\nOut[14]: ['新月打击', '苍白之瀑', '月之降临', '月神冲刺', '虚弱', '点燃']\n\n['虚弱','点燃']*3\nOut[15]: ['虚弱', '点燃', '虚弱', '点燃', '虚弱', '点燃']\n1.1.3 判断元素是否存在\n运用in和not in即可\n3 in [1,2,3,4]\nOut[21]: True\n\n3 not in [1,2,3,4]\nOut[22]: False\n1.1.4 计算长度，最大小值\nlen([1,2,3])\nOut[23]: 3\n\nlen(\"hesadad\")\nOut[24]: 7\n\nmax([1,2,3,4,5,6])\nOut[25]: 6\n\nmin([1,2,3,4])\nOut[26]: 1\n1.1.5 append()可以向列表中追加元素。\na = [1,2,3,4]\n\na.append('5')\n\nOut[22]: [1, 2, 3, 4, '5']\n2.元组(tuple)\n\n\n元组的操作，包括访问，加，乘，in等操作和列表是相同的。\n需要注意一点是：\n\ntype((1))\nOut[16]: int\n\ntype(('sd'))\nOut[17]: str\n\ntype((1,2,3))\nOut[18]: tuple\n如果括号里有一个元素，默认为是一个运算，不会认为是元组的括号。如果要定义只有一个元素的元组的：\ntype((1,))\nOut[19]: tuple\n# 括号里面什么都没有表示一个空元组\ntype(())\nOut[20]: tuple\n元组是序列，不可变类型，但是如果元组里包含了列表，比如：\na = (1,2,3,[4,5])\n\na[3][1] = '2'\n\nprint(a)\n(1, 2, 3, [4, '2'])\n我们可以看到元组里的列表可以改变\n3.字符串(str)\n\n\n字符串和元组都是不可变的类型\n序列包括了字符串，列表和元组，序列都可以用下标索引和切片的方式。\n\nset集合\n\nset集合里的元素是无序的，不重复的。\nin,not in,len,max,min,但是没有加，乘这种操作。\n集合有相减，交集，并集等操作\n\n{1,2,3,4,5,6} - {1,2}\nOut[1]: {3, 4, 5, 6}\n\n{1,2,3,4,5,6} & {1,2}\nOut[2]: {1, 2}\n\n{1,2,3,4,5,6} | {1,2,7}\nOut[3]: {1, 2, 3, 4, 5, 6, 7}\n定义一个空集合的方法：set()\ntype({})\nOut[8]: dict\n\ntype(set())\nOut[9]: set\n\nlen(set())\nOut[10]: 0\n字典(dict)\n\n字典和集合类型(set)有些类似，里面是无序的，所以字典不是序列。\n字典中可以value可以使任意类型；但是key是可以的，key必须是不可变的类型，比如Int,str,tuple等，例如list就是不可以的。\n字典的访问：{'key1':'value1,'key2':'value2'}['key1']，字典的访问通过key来进行\n字典里，key值是不可以重复的，如果定义有重复虽然不会报错，但是会自动选择其中一个。\n\n序列，集合和字典属于组，是Python的基本数据类型。\n变量\n\n变量的定义时，首字母不能是数字，但可以是下划线。字母，数组，下划线可以组成变量。\nPython 变量名区分大小写。定义变量的时候不用指明类型，和C++不一样。\n\n值类型和引用类型：\n\na = 1\n\nb = a\n\na = 3\n\nprint(b)\n1\n\na = [1,2,3,4]\n\nb = a\n\na[0] = '1'\n\nprint(b)\n['1', 2, 3, 4]\n值类型：int str tuple（不可改变），在重新定义的时候，因为不可改变会生成一个新的对象，这个时候b仍然指向原对象，a指向了一个新对象引用类型:list,set,dict（可以改变），在定义一个新对象的时候，会在原对象的基础上进行改变而不产生新对象，所以无论是a还是b都会指向已经改变的原对象，所以a和b的值都会变化。\n再进一步的，可以看以下代码:\na = 'hello'\n\nid(a)\nOut[15]: 1510080259608\n\na = a + 's'\n\nid(a)\nOut[17]: 1510081716832\n\na[0] = 's'\nTraceback (most recent call last):\n\n  File \"<ipython-input-18-02436d67df37>\", line 1, in <module>\n    a[0] = 's'\n\nTypeError: 'str' object does not support item assignment\nid()是查询在计算机中的内存位置，我们可以看到发生了变化。所以a = a + 's'是可以的。但是对字符串的赋值操作，是不可以的，因为str是不可变的类型。\n运算符\n\npython中是没有自增和自减这种操作的。\n表示“等于”是'==',“不等于”是'!='\n字符串相比较的时候，把字符串中每一个字符拿出来相比较，比较AscII码值\n比较两个列表，和字符串是相同的。元组也可以进行比较，和列表和字符串是相同的。\n非bool类型在参与逻辑运算的时候，比如int,float,str等类型，在参与and,or,not的时候，遵循的规则和c++中类似。\n\n0 and 1\nOut[1]: 0\n\n1 and 2\nOut[2]: 2\n\n1 and 0\nOut[3]: 0\n\n1 or 2\nOut[4]: 1\n\n0 or 1\nOut[5]: 1\n由上面的例子我们可以看出and和or的逻辑判断规则和c++一致。空字符串，0等判断为空，在上面的笔记中有记载。\n\n成员运算符: in, not in\n成员运算符表示一个元素是否在一个组里；成员运算符返回值类型是bool类型。在字典中，是判断key值。\na = 1\n\na in {1:'1'}\nOut[7]: True\n\na = '1'\n\na in {1:'1'}\nOut[9]: False\n身份运算符\nis, is not身份运算符比较的是身份而不是值，简单来说就是内存地址。和关系运算符“==”不一样。\na = 1\n\nb = 1\n\na is b\nOut[12]: True\n\nid(a)\nOut[13]: 1438837200\n\nid(b)\nOut[14]: 1438837200\n\nb = 1.0\n\na is b\nOut[16]: False\n\nid(b)\nOut[17]: 2197963106536\n\na ==b\nOut[18]: True\n\na = {1,2,3}\n\nb = {2,1,3}\n\na==b\nOut[21]: True\n\na is b\nOut[22]: False\n\nc = (1,2,3)\n\nd = (2,1,3)\n\nc ==d\nOut[25]: False\n\nc is d\nOut[26]: False\n\nid(a)\nOut[27]: 2197907160424\n\nid(b)\nOut[28]: 2197990760232\n我们可以看到，在无序的set集合中，元素顺序不一样在内存中位置不同，虽然值相同但是身份仍然不一样。\n位运算符\n&, |, ^, ~, <<, >>以上都是把数字当作二进制进行运算。把数字按照二进制进行换算，以&举例，相同位1，不同为0。然后再把二进制数转换成数字原来的进制。eg: 2&3 == 2\n判断变量的类型\npython中一切都是对象，对象有三大特征，值(value), 身份(id), 类型(type)。判断变量的类型，可以使用isinstance()这个函数。\na = 'sds'\n\nisinstance(a,str)\nOut[30]: True\n\nisinstance(a,(str,int,float))\nOut[31]: True\n\nisinstance(a,int)\nOut[32]: False\nisinstance可以判断对象中的子类是否满足条件，所以比较好。\nvscode python 基本操作\n+　单行注释：＃　快捷键：ctrl + /+　多行注释：\"\"\" \"\"\" 快捷键：alt + shift + a\npylint\n\n每个文件（模块）需要有开篇的注释来说明作用。\npython中不存在常量（constant）一说，但是对于形式上的常量，一般以全部大写来表示\nPython变量中两个名字的衔接用下划线，eg:test_account.\n\npython包和模块\n注意事项\n\n包和模块是不会被重复导入的。\n尽量避免循环引入。\n导入一个模块的时候，会执行这个模块里面的代码。\n\n\n\npython中的普通模块必须有一个包，当想要把一个可执行文件当作一个普通模块运行时，可以使用-m参数，如：python -m 命名空间.模块名注意：此处若当作普通模块，必须包括包名/命名空间。python中可执行文件没有所属包。此外，当使用-m参数后，顶级包也相对改变。\ndir函数\n用来查看模块或者类内部的变量，包括系统内置变量。\nimport sys\ninfos = dir(sys)\nprint(infos)\n\n\n['__displayhook__', '__doc__', '__excepthook__', '__interactivehook__', '__loader__', '__name__', '__package__', '__spec__', '__stderr__', '__stdin__', '__stdout__', '_clear_type_cache', '_current_frames', '_debugmallocstats', '_enablelegacywindowsfsencoding',......]\n\n# 可见打出了许多的变量，是sys模块内部的变量。下面的代码中也有应用，只不过没有参数。\n__name__的应用技巧\nif __name__ == '__main__':\n    pass\n\n#来判断模块是否被当作入口文件被调用，如果被当做模块就不会打印if条件成立执行的语句，如果被当做入口文件才会执行\n1.模块导入的方法\n# 由父包引入子包或者同级别引入的情况\n\nimport module  # 只能引入同一个包（不包括子包）里的模块。注意这里不能直接引入模块的变量。\n\nimport module as name  # 使用的时候name.变量/函数等。\n\nfrom packet import module # 可以父包里的子包引入模块。\n\nfrom packet.module import module.变量/函数等 \n\nfrom module import *  # 引入module内__all__指定的变量/函数等。\n\nfrom module import module.变量1, module.变量2,......  # 引入多个变量可用逗号隔开\n\n\n2.__init__.py\n该文件，可以在导入一个包，或者导入包中的函数的时候，系统会首先执行该文件。\nfrom packet import *  # 这行代码会引入被引入包中__init__.py中__all__指定的模块。\n3.模块内置变量\na = 2\nb = 1\ninfos = dir()\nprint(infos)\n\n['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'a', 'b']\n\n# 上方除了'a','b'都是系统内置的变量。\n下面介绍几个比较重要的内置变量，利用import一个模块的时候会执行该模块里面的内容的机制。对于入口文件和模块文件，内置变量的值有所不同。\n\n模块文件：\n'''\nthis is a c3 doc\n'''\nprint(\"name: \"+__name__)\nprint(\"package: \"+__package__)\nprint(\"doc: \"+__doc__)\nprint(\"flie: \"+__file__)\n\nimport sub11.c3\n\nPS D:\\pycode\\sub1> python c2.py\nname: sub11.c3\npackage: sub11\ndoc:\nthis is a c3 doc\n\nflie: D:\\pycode\\sub1\\sub11\\c3.py\n\n# __doc__记录的是该模块的开头注释\n\n# __name__记录该模块的名字\n\n# __package__记录该模块属于的包\n\n# __file__记录该模块的文件的绝对路径\n\n入口文件\n如果一个.py文件被当做一个应用程序的入口：①它的名称不再是本身的模块名称，而是被强制更改为__main__ ②它不属于任何包③file内置变量不会像普通模块一样显示绝对路径，它所显示的值也不是确定值，和执行命令所在目录有关注：python入口文件和普通导入的模块文件是有差异的。\n'''\nthis is a c3 doc\n'''\nprint(\"name: \"+__name__)\nprint(\"package: \"+ ( __package__ or \"当前模块不属于任何包\"))\nprint(\"doc: \"+__doc__)\nprint(\"flie: \"+__file__)\n\n\n\nname: __main__\npackage: 当前模块不属于任何包\ndoc:\nthis is a c3 doc\n\nflie: c3.py\n\n# 该文件属于sub11包（有__init__.py这个文件），但是我们是直接执行的c3.py文件，可见此时如果在c3.py中打印内置变量，__name__被强制定位__main__，而且package上也不会显示出所属于的包，file路径也发生了变化。\n4.绝对导入和相对导入\n导入机制：\n\n\npython模块导入时的搜索路径：\n\n程序主目录，执行程序是包含执行代码文件的目录，交互模式下为当前工作目录,优先级最高\nPYTHONPATH中的目录\n标准链接库目录，就是python的安装目录，源码在里面\n3.x 中可以用.pth 文件\n\n\n以上这些构成了sys.path。你写的模块存储路径在sys.path 里面就可以import。\n绝对导入是指从入口文件引入执行文件所在的文件夹的包中的模块的时候，需要进行绝对导入。from ... import...中如果没有出现.模块名,也是绝对导入。\n相对导入指从模块引入父级的模块时，需要进行相对导入。在入口文件切记不能使用相对导入，即带.号。比如你单独运行某个模块，但是在这个模块里你用了相对导入，那么就会报错。但是你在外面引入这个模块的时候是不存在问题的。\n注意在模块下面，最好不要有和模块名重名的文件。\n\n\n顶级包与入口文件main.py的位置有关，与main.py同级的包就是该包下所有模块的顶级包。而对于入口文件来说不存在包的概念。\n绝对导入/绝对路径：从顶级包到被导入模块名称的完整路径。注意一定是完整的路径。\n相对导入,一个'.'表示当前包,两个'..'表示上一级包.'...'上上级包,以此类推。\n\n注意:\n\nimport不支持相对导入，只能使用from import格式实现相对导入。\n入口文件中不能使用相对导入，因为它没有包的概念。\n使用相对导入不要超出顶级包，和入口文件同级都不能使用相对导入\npycharm中，你打开一个工程，你的入口文件处的sys.path中会自动添加该工程中的目录，所以假设你在模块a中相对引入其他模块b，模块b所在的位置超过了你现在所运行的文件（入口文件）所在的位置，但是只要不超过当前的工程目录所在的位置，仍然可以进行相对导入。\n\n函数\n注意事项\npython默认有一个递归次数限制来防止无限递归调用，但可以设置递归最大次数：\nimport sys\nsys.setrecursionlimit(10000)\n# 可以设置最大迭代10000次。不过理论上虽然设置这么多，但实际上仍然达不到允许迭代这么多次。\n\npython中for循环内定义的变量可以在外部使用，这点和c和java不相同。\n若函数体中没有返回值，则认为返回None。\n\n1.return 返回多个值，链式赋值和序列解包\npython函数返回多个值直接在return后面用逗号分隔要返回的值即可，返回结果是tuple元组类型。比较好的接收函数返回的多个值的方法不是用一个变量接收元组然后用序号访问它的元素，而是直接用多个值接收然后分别使用这些变量，如：\ndef damage(skill1, skill2)\n    damage1 = skll1 * 3\n    damage2 = skill2 * 3 + 10\n    return damage1, damage2\n    \nskill1_damage, skill2_damage = damage(3, 6)\nprint(skill1_danage, skill2_damage)\n上面的接受参数的方式叫做序列解包。\n链式赋值和序列解包\nd = 1, 2, 3\nprint(type(d))\na, b, c = d\nprint(a, b, c)\nprint('----------------')\na = b = c = 1\nprint(a, b, c)\n\n<class 'tuple'>\n1 2 3\n----------------\n1 1 1\n因为是序列解包，所以可以不是元组，列表也是可以的。最后如果多个变量取同一个值，那么可以用上面的方法来进行赋值。\n2.函数参数\n函数参数有：\n\n必须参数：形参和实参。\n关键字参数\n默认参数\n可变参数\n可变参数可以解开可变，并且可以进行可变关键字参数。定义可变参数后，传值的时候可以什么都不传，这个时候是空元组或者空字典。\n\ndef demo(*param):\n    print(param)\n    print(type(param))\n\ndemo(1,2,3,[4,5,6])\n\n(1, 2, 3, [4, 5, 6])\n<class 'tuple'>\n\n# 传入可变参数，会定义为元组。\n\ndef demo(*param):\n    print(param)\n    print(type(param))\n\na = 1,2,3\ndemo(a)\ndemo(*a)\n\n((1, 2, 3),)\n<class 'tuple'>\n(1, 2, 3)\n<class 'tuple'>\n\n# *可以解包。\n\ndef demo(**param):\n    print(param)\n    print(type(param))\n\ndemo(q='万能牌', w='切牌', e='占卜')\n\n{'q': '万能牌', 'w': '切牌', 'e': '占卜'}\n<class 'dict'>\n\n# 可见传进来以后是一个字典，很方便。这就是关键字可变参数。\n\ndef demo(**param):\n    print(param)\n    print(type(param))\n    for key,value in param.items():\n        print(key,':',value,end='|| ')\n\ndemo(q='万能牌', w='切牌', e='占卜')\n\n{'q': '万能牌', 'w': '切牌', 'e': '占卜'}\n<class 'dict'>\nq : 万能牌|| w : 切牌|| e : 占卜||\n\n# 传入字典时可以采用上面的方式取出键值和内容。\n\ndef demo(**param):\n    print(param)\n    print(type(param))\n    for key,value in param.items():\n        print(key,':',value,end='|| ')\n\na = {'q':'万能牌', 'w':'切牌', 'e':'占卜'}\ndemo(**a)\n\n{'q': '万能牌', 'w': '切牌', 'e': '占卜'}\n<class 'dict'>\nq : 万能牌|| w : 切牌|| e : 占卜||\n\n# 和传入元组一样，解序列可以传入两个*。\n\n形参是定义函数的时候定义的参数，实参是调用函数的时候传递的参数。\n关键字参数通过指定形参来进行参数赋值。\n可变参数在必须参数之后，默认参数之前，否则会出现赋值的错误\n\ndef demo(param1,param2 = 2,*param3):\n    print(param1)\n    print(param2)\n    print(param3)\n    \ndemo('a', 1,2,3)\n\na\n1\n(2, 3)\n\n# 可见如果默认参数在可变参数之前，会发生错误，和预想的（1,2,3）赋值给param3有区别。\n\n---------------------------------------------------------------------------\n\n# 调整一下顺序可以得到想要的结果\n\ndef f1(name1, *args, name2='2', **kw):\n    print(name1)\n    print(name2)\n    print(args)\n    print(kw)\nf1('1','3','4',a='1',b='2')\n\n\n1\n2\n('3', '4')\n{'a': '1', 'b': '2'}\n类\n注意事项\n\n类名最好不要用下划线，有多个单词的时候可以采用大写首字母的方法。\n类的最基本作用就是封装。定义类，实例化对象\n类只负责定义和刻画，并不负责去执行代码。所以在类里面去执行方法是不正确的。\n在一个模块里面，不要既定义类，又去实例化类执行代码。\n不要把类和模块搞混，类里面有自己的规则\n\n1.构造函数\n\n构造函数即__init__(self):\n实例化类的时候构造函数被自动执行\n\n构造函数返回值为None ，不能人为return更改。\n可以通过类名.__init__()来执行构造函数。\n\n2.类变量和实例变量\n\n类变量是定义在类内但是不在__init__()中；实例变量是定义在___init__()中的。换句话说，实例变量是对象的，类变量是类的，二者不能混淆。\npython中，类与对象的变量查找是有顺序的。\n\nclass Student():\n    name = 'Catherian'\n    age = 0\n    high = 170\n    def __init__(self, name, age, high):\n        self.name = name\n        self.age = age\n        high = high\n        # 注意这里的身高没有用self.high来定义\n    \n    def doHomework(self):\n        print('doHomework')\n\nstudent1 = Student('呵呵哒', 18, 180)\nstudent2 = Student('ojbk', 16, 175)\nprint(student1.name, student1.age, student1.high)\nprint(student2.name, student2.age, student2.high)\nprint(Student.name, Student.age, Student.high)\nprint(student1.__dict__)\nprint(Student.__dict__)\n\n\n\n呵呵哒 18 170 \n\nojbk 16 170\n\nCatherian 0 170  # 这里打印出的才是类变量\n\n# 可以看到，尽管我们在实例化student1,student2的时候传入了身高high这个数据，但是打印的时候我们发现输出的是类变量high，并不是实例变量。\n\n{'name': '呵呵哒', 'age': 18}\n\n# __dict__对与对象，打印出的是对象的实例变量。可见里面并没有high。所以实例变量是用 self. 来定义的。类的__dict__是打印出对象里面的内容，包括数据成员和方法，下面即是\n\n{'__module__': '__main__', 'name': 'Catherian', 'age': 0, 'high': 170, '__init__': <function Student.__init__ at 0x000001F06B70F9D8>, 'doHomework': <function Student.doHomework at 0x000001F06B70FA60>, '__dict__': <attribute '__dict__' of 'Student' objects>, '__weakref__': <attribute '__weakref__' of 'Student' objects>, '__doc__': None}\n\n虽然我们在实例化对象时传入了数据，但是我们发现high是类变量不是实例变量，但是仍然sudent1.high打印出了变量，这是类变量而不是实例变量。这是因为，python中的查找机制：当查找实例变量不存在的时候，会继续向上查找类中相对应的类变量，如果子类中没有父类中有（出现继承）时，会查找到父类。所以我们打印出了类变量。\n3.实例方法\n\npython中，实例方法的参数里必须要显式的定义出self，但在外部调用的时候不需要给出self。self指的就是你在外部实例化的对象。所以self.给出的是实例变量。\n\n在实例方法中调用实例变量最好用self.的形式来进行调用。因为你传入的是形参.\n在实例方法中调用类变量有两种方法：类名.类变量和self.__class__.类变量\n\n4.类方法\n定义类方法：\nclass Student\n    sum = 0\n    @classmethod\n    def student_sum(cls):\n        pass\n    \n# cls可以更换，函数上面是一个装饰器，表示了这是一个类方法。cls换成self或者其他任意的都是可以的，和实例方法中self可以任意替换别的字符是一样的。\n对于类方法，调用类变量：cls.类变量 即可。所以cls代表的就是所属于的类。在调用类方法的时候，可以 Student.studen_sum 也可以通过对象来调用，即：student1.student_sum。但是建议用类名来调用比较好。\n5.静态方法\n定义静态方法：\nclass Student\n    sum = 0\n    @staticmethod\n    def add(x,y)\n        pass\n静态方法上同样要有装饰器来修饰，但是函数中不用显式的传入self或者cls，更像是一个普通的函数。在类方法和静态方法中都不能调用实例变量。一般不建议用静态方法，类方法更方便。\n6.成员可见性\n在python中，实际上没有什么是不能访问的。成员可见性更像是一种标志，一切全靠自觉。定义私有变量或者方法的时候，只需要在变量或者方法前面加上双下划线就代表了私有（注意不要同时在后面再加上双下划线）。\n# 我们定义一个学生类\n\nclass Student():\n    name = 'Catherian'\n    age = 0\n    __high = 170\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n        self.__score = 0\n    \n    def __doHomework(self):\n        print('doHomework')\n        \n\nstudent1 = Student('呵呵哒', 18)\nprint(student1.__score)\n\nTraceback (most recent call last):\n  File \"c1.py\", line 15, in <module>\n    print(student1.__score)\nAttributeError: 'Student' object has no attribute '__score'\n# 可以看到不能这样访问。\n---------------------------------------------------------------------\n\n# 如果我们再加上一句再执行：\n\nstudent1 = Student('呵呵哒', 18)\nstudent1.__score = -1\nprint(student1.__score)\n\n-1\n\n# 我们发现竟然可以成功赋值并且访问的。这是因为 studen1.__score = -1 这个操作其实是又定义了一个新的实例变量。我们可以打印看一下\n\nstudent1 = Student('okk', 18)\nstudent1.__score = -1\n# print(student1.__score)\nprint(student1.__dict__)\n\n\n{'name': 'okk', 'age': 18, '_Student__score': 0, '__score': -1}\n\n# 我们可以看到，我们再里面定义的__score变量被定义成了_Student__score变量，__score变量是我们根据Python动态特性新定义出的实例变量。所以要访问私有变量也很简单：\n\nprint(student1._Student__score)\n\n0\n\n# 所以这个真的全靠自觉，python中没什么是不能访问的。\n7.继承性\npython中可以单继承也可以多继承。\n\n子类继承父类，会继承父类中的变量（类变量和实例变量都会继承）和父类中的方法。\n在子类内部，如果有和父类重名的变量，会按照我们在类变量和实例变量中说明的搜索规则进行。\n如果有重名的方法，想在子类内部进行调用，可以采用super(子类名, self)进行调用父类重名函数。\n在python中，可以用类名调用实例方法。很奇怪但是是可以的。\n在子类构造函数中，通过传入多个参数，调用父类构造函数即可完成初始化。\n多继承容易出现BUG。\n\n# 定义一个Human父类\nclass Human():\n    sum = 0\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n        self.__class__.sum += 1\n    def get_name(self):\n        print(self.name)\n    def do_Homework(self):   # 重名的方法\n        print(\"this is a parent method\")\n        \n# 定义一个子类Student\n\nfrom c2 import Human\nclass Student(Human):\n    sum = 0  # 和父类重名的类变量\n    def __init__(self, name, age, score):  # 父类还有两个参数，所以这里有三个参数\n       Human.__init__(self, name, age)  # 这里注意通过类名调用方法，不能不加self\n       self.score = score \n       self.__class__.sum += 1\n    def do_Homework(self):  # 和父类重名的方法。\n        super(Student, self).do_Homework()\n        print('doHomework')\n\nstudent1 = Student('okk', 18, 61)\nprint(student1.sum)\nprint(Student.sum)\nprint(student1.get_name())\nprint(student1.do_Homework())\n\n\n2   # 可见通过父类方法里对sum的操作，继承到子类中时，对于重名变量仍然可以操作子类中的重名变量。\n2  # 根据搜索机制，实例变量里没有找到子类里的类变量，再没有找父类。\nokk\nNone\nthis is a parent method # 可见调用了父类中的方法。\ndoHomework\nNone\n\n枚举\npython中的枚举类型其实是一个类。\nfrom enum import Enum\n\nclass diamond(Enum):  # 必须要继承父类Enum\n    YELLOW = 1\n    BLUE = 2\n    GREEN = 3\n    RED = 4\nprint(diamond.YELLOW)\n\n\ndiamond.YELLOW\n\n# 可见打印出的就是diamend.YELLOW\n在枚举类型中，每个类型有不同的值，不允许出现相同类型赋不同值，值可以是任意类型的。如果出现了两个枚举类型的值相同，下面的枚举类型会被当成是上面枚举类型的别名。\nfrom enum import Enum\n\nclass diamond(Enum):\n    YELLOW = 1\n    BLUE = 1\n    GREEN = 3\n    RED = 4\n    \nprint(diamond.BLUE)\nprint(diamond.__members__.items()) # items()可以不需要。打印出所有的枚举类型。\n\n\ndiamond.YELLOW # 可打印的是BLUE出来的是YEELOW。\nodict_items([('YELLOW', <diamond.YELLOW: 1>), ('BLUE', <diamond.YELLOW: 1>), ('GREEN', <diamond.GREEN: 3>), ('RED', <diamond.RED: 4>)])\n\n\n\n不能在类的外部修改类型的值，比如diamond.YELLOW = 5是会报错的。\n类型最好用大写表示，表示为常量不能修改。\n枚举类型，枚举名称，枚举的值，代码如下：\n\nfrom enum import Enum\n\nclass diamond(Enum):\n    YELLOW = 1\n    BLUE = 2\n    GREEN = 3\n    RED = 4\nprint(\"枚举类型为：\", type(diamond.GREEN), diamond.GREEN)\nprint(\"枚举的名称为\", type(diamond.GREEN.name), diamond.GREEN.name)\nprint(\"枚举的值为：\", diamond.GREEN.value)\n\n枚举类型为： <enum 'diamond'> diamond.GREEN\n枚举的名称为 <class 'str'> GREEN\n枚举的值为： 3\n可以采用for循环获得枚举类型等：\nfor i in diamond:\n    print(i)\n    \ndiamond.YELLOW\ndiamond.BLUE\ndiamond.GREEN\ndiamond.RED\n\n枚举类型之间不能做大小的比较，可以做等值的比较；枚举类型和枚举值之间不能做等值的比较；枚举类型可以做身份（is）的比较。不同枚举类之间的枚举类型不能比较。\n从枚举值获得枚举类型：\n\nclass diamond(Enum):\n    YELLOW = 1\n    BLUE = 2\n    GREEN = 3\n    RED = 4\na = 1\nprint(diamond(a))\n\n\ndiamond.YELLOW\n# 从一个具体的值获得相应的枚举类型。很有用。\n\n如果想要每个枚举类型的值都是int类型，可以引入from enum import IntEnum，在枚举类的括号里为IntEnum。\n如果不想出现两个枚举类型出现同一个值（会报错），可以引入一个装饰器：\n\nfrom enum import Enum\nfrom enum import IntEnum, unique\n\n@unique # 装饰器\nclass diamond(IntEnum):\n    YELLOW = 1\n    BLUE = 2\n    GREEN = 3\n    RED = 4\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "5"}