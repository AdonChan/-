{"title": "交互式的开发环境 - ipython - pythoner ", "index": "python", "content": "本文介绍如何使用ipython进行快速的实验和调试，闲话免谈，直接通过demo进入主题。\n与操作系统交互\n!cmd\n在系统shell中执行cmd\nIn [35]: !ls\nGemfile        Gemfile.lock    README.md    Rakefile    bin        config        db        log        src\n%cd directory\n将系统目录更改为directory\nIn [36]: %cd -\n/private/tmp\n调试器\n%debug\n在执行完代码，如果出现错误，立即执行%debug命令后将会进入调试器。在接触%debug之前，笔者都是使用的是pdb.set_trace来调试程序，这样的硬编码非常之不方便。\nIn [45]: !touch a.py\nIn [46]: !vim a.py\nIn [47]: !cat a.py\ndef divide():\n    assert(1 == 0)\n\ndivide()\nIn [56]: %run a.py\n---------------------------------------------------------------------------\nAssertionError                      Traceback (most recent call last)\n/private/tmp/a.py in <module>()\n      2     assert(1 == 0)\n      3\n----> 4 divide()\n\n/private/tmp/a.py in divide()\n      1 def divide():\n----> 2     assert(1 == 0)\n      3\n      4 divide()\n\nAssertionError:\n\nIn [57]: %debug\n> /private/tmp/a.py(2)divide()\n      1 def divide():\n----> 2     assert(1 == 0)\n      3\n      4 divide()\n%run -d xxx.py\n同样立即进入调试器。\n性能分析\n%timeit\n用来测试各个部分或者函数的执行时间，它会自动多次执行以产生一个非常精确的平均执行时间。\nIn [12]: strings = ['foo', 'foobar', 'baz','qux', '123 ffd'] * 100000\nIn [13]: %timeit method1 = [x for x in strings if x.startswith('foo')]\n10 loops, best of 3: 93.4 ms per loop\nIn [14]: %timeit method2 = [x for x in strings if x[:3] == 'foo']\n10 loops, best of 3: 36.4 ms per loop\nmethod2 比 method1 的性能要快两倍以上。\n%run -p\npython的主要性能分析工具是cProfile模块，它会记录各个函数的耗费时间，在命令行中，可以通过如下命令来进行性能分析：\npython -m cProfile xxx.py\n而在ipython中，会使用下面的命令来运行一个文件\n%run -p -s cumulative xxx.py\n%prun\n如果想要运行一个函数或语句，请使用如下命令：\n%prun -l 7 -s cumulative run()\n待测函数：\nIn [17]: from numpy.random import randn\nIn [18]: x = randn(3000, 3000)\nIn [19]: y = randn(3000, 3000)\nIn [20]: def add_and_sum(x,y):\n    ...:     added = x + y\n    ...:     summed = added.sum(axis=1)\n    ...:     return summed\n    ...:\n使用prun的结果如下：\nIn [21]: %prun add_and_sum(x, y)\n         6 function calls in 0.340 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n        1    0.310    0.310    0.335    0.335 <ipython-input-16-fbadffca33af>:1(add_and_sum)\n        1    0.025    0.025    0.025    0.025 {method 'reduce' of 'numpy.ufunc' objects}\n        1    0.005    0.005    0.340    0.340 <string>:1(<module>)\n        1    0.000    0.000    0.025    0.025 {method 'sum' of 'numpy.ndarray' objects}\n        1    0.000    0.000    0.025    0.025 _methods.py:31(_sum)\n        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}\n上面的结果不是很好理解，笔者更喜欢用line_profiler库来分析。\n%lprun\n使用一个库line_profiler，这个库的输出结果简单易理解。这个库不是内建的，需要手动安装，安装命令：\npip install line_profiler\n然后在ipython中手动load lprun：\nIn [2]: %load_ext line_profiler\nIn [3]: %lprun\nTimer unit: 1e-06 s\n待测函数：\nIn [17]: from numpy.random import randn\nIn [18]: x = randn(3000, 3000)\nIn [19]: y = randn(3000, 3000)\nIn [20]: def add_and_sum(x,y):\n    ...:     added = x + y\n    ...:     summed = added.sum(axis=1)\n    ...:     return summed\n    ...:\nIn [21]: def call_function():\n    ...:     x = randn(1000, 1000)\n    ...:     y = randn(1000, 1000)\n    ...:     return add_and_sum(x, y)\n使用lprun后的结果如下：\nIn [23]: %lprun -f add_and_sum  -f call_function call_function()\nTimer unit: 1e-06 s\n\nTotal time: 0.004438 s\nFile: <ipython-input-16-fbadffca33af>\nFunction: add_and_sum at line 1\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n     1                                           def add_and_sum(x,y):\n     2         1         3929   3929.0     88.5      added = x + y\n     3         1          508    508.0     11.4      summed = added.sum(axis=1)\n     4         1            1      1.0      0.0      return summed\n\nTotal time: 0.062512 s\nFile: <ipython-input-17-b03b81a6d2ba>\nFunction: call_function at line 1\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n     1                                           def call_function():\n     2         1        29193  29193.0     46.7      x = randn(1000, 1000)\n     3         1        28449  28449.0     45.5      y = randn(1000, 1000)\n     4         1         4870   4870.0      7.8      return add_and_sum(x, y)\n通常，会使用%prun(cProfile)做“宏观”性能分析，而用%lprun(line_profiler)做“微观”性能分析。使用line_profiler必须要指定待测的函数，是因为这个库要跟踪每一行代码的执行时间。\n基本名令\n内省\n在一个变量的前面或后面加上问号？，可以显示该变量的基本信息\nIn [23]: a=1\n\nIn [24]: a?\nType:        int\nString form: 1\nDocstring:\nint(x=0) -> int or long\nint(x, base=10) -> int or long\n>>> int('0b100', base=0)\n4\n如果这个变量是函数的话，一个问号?来显示docstring，两个问号来显示该函数的源码\n%timeit\n检测python语句的执行时间\nIn [16]: %timeit  sum(i*i for i in xrange(1000))\n10000 loops, best of 3: 68.6 µs per loop\n%logstart\n执行这个命令，开始记录控制台会话，这样可以将整个过程保存起来\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "2"}