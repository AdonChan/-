{"title": "深入理解Python中的ThreadLocal变量（下） - Just For Fun ", "index": "thread,python", "content": "在上篇我们看到了 ThreadLocal 变量的简单使用，中篇对python中 ThreadLocal 的实现进行了分析，但故事还没有结束。本篇我们一起来看下Werkzeug中ThreadLocal的设计。\nWerkzeug 作为一个 WSGI 工具库，由于一些方面的考虑，并没有直接使用python内置的ThreadLocal类，而是自己实现了一系列Local类。包括简单的Local，以及在此基础上实现的LocalStack，LocalManager 和 LocalProxy。接下来我们一起来看看这些类的使用方式，设计的初衷，以及具体的实现技巧。\nLocal 类的设计\nWerkzeug 的设计者认为python自带的ThreadLocal并不能满足需求，主要因为下面两个原因：\n\nWerkzeug 主要用“ThreadLocal”来满足并发的要求，python 自带的ThreadLocal只能实现基于线程的并发。而python中还有其他许多并发方式，比如常见的协程（greenlet），因此需要实现一种能够支持协程的Local对象。\nWSGI不保证每次都会产生一个新的线程来处理请求，也就是说线程是可以复用的（可以维护一个线程池来处理请求）。这样如果werkzeug 使用python自带的ThreadLocal，一个“不干净（存有之前处理过的请求的相关数据）”的线程会被用来处理新的请求。\n\n为了解决这两个问题，werkzeug 中实现了Local类。Local对象可以做到线程和协程之间数据的隔离，此外，还要支持清理某个线程或者协程下的数据（这样就可以在处理一个请求之后，清理相应的数据，然后等待下一个请求的到来）。\n具体怎么实现的呢，思想其实特别简单，我们在深入理解Python中的ThreadLocal变量（上） 一文的最后有提起过，就是创建一个全局字典，然后将线程（或者协程）标识符作为key，相应线程（或协程）的局部数据作为 value。这里 werkzeug 就是按照上面思路进行实现，不过利用了python的一些黑魔法，最后提供给用户一个清晰、简单的接口。\n具体实现\nLocal 类的实现在 werkzeug.local 中，以 8a84b62 版本的代码进行分析。通过前两篇对ThreadLocal的了解，我们已经知道了Local对象的特点和使用方法。所以这里不再给出Local对象的使用例子，我们直接看代码。\nclass Local(object):\n    __slots__ = ('__storage__', '__ident_func__')\n    \n    def __init__(self):\n        object.__setattr__(self, '__storage__', {})\n        object.__setattr__(self, '__ident_func__', get_ident)\n    ...\n由于可能有大量的Local对象，为了节省Local对象占用的空间，这里使用 __slots__ 写死了Local可以拥有的属性：\n\n__storage__： 值为一个字典，用来保存实际的数据，初始化为空；\n__ident_func__：值为一个函数，用来找到当前线程或者协程的标志符。\n\n由于Local对象实际的数据保存在__storage__中，所以对Local属性的操作其实是对__storage__的操作。对于获取属性而言，这里用魔术方法__getattr__拦截__storage__ 和 __ident_func__以外的属性获取，将其导向__storage__存储的当前线程或协程的数据。而对于属性值的set或者del，则分别用__setattr__和__setattr__来实现（这些魔术方法的介绍见属性控制）。关键代码如下所示：\ndef __getattr__(self, name):\n    try:\n        return self.__storage__[self.__ident_func__()][name]\n    except KeyError:\n        raise AttributeError(name)\n\ndef __setattr__(self, name, value):\n    ident = self.__ident_func__()\n    storage = self.__storage__\n    try:\n        storage[ident][name] = value\n    except KeyError:\n        storage[ident] = {name: value}\n\ndef __delattr__(self, name):\n    try:\n        del self.__storage__[self.__ident_func__()][name]\n    except KeyError:\n        raise AttributeError(name)\n假设我们有ID为1，2， ... ， N 的N个线程或者协程，每个都用Local对象保存有自己的一些局部数据，那么Local对象的内容如下图所示：\n\n此外，Local类还提供了__release_local__方法，用来释放当前线程或者协程保存的数据。\nLocal 扩展接口\nWerkzeug 在 Local 的基础上实现了 LocalStack 和 LocalManager，用来提供更加友好的接口支持。\nLocalStack\nLocalStack通过封装Local从而实现了一个线程（或者协程）独立的栈结构，注释里面有具体的使用方法，一个简单的使用例子如下：\nls = LocalStack()\nls.push(12)\nprint ls.top    # 12\nprint ls._local.__storage__\n# {140735190843392: {'stack': [12]}}\nLocalStack 的实现比较有意思，它将一个Local对象作为自己的属性_local，然后定义接口push, pop 和 top 方法进行相应的栈操作。这里用 _local.__storage__._local.__ident_func__() 这个list来模拟栈结构。在接口push, pop和top中，通过操作这个list来模拟栈的操作，需要注意的是在接口函数内部获取这个list时，不用像上面黑体那么复杂，可以直接用_local的getattr()方法即可。以 push 函数为例，实现如下：\ndef push(self, obj):\n    \"\"\"Pushes a new item to the stack\"\"\"\n    rv = getattr(self._local, 'stack', None)\n    if rv is None:\n        self._local.stack = rv = []\n    rv.append(obj)\n    return rv\npop 和 top 的实现和一般栈类似，都是对 stack = getattr(self._local, 'stack', None) 这个列表进行相应的操作。此外，LocalStack还允许我们自定义__ident_func__，这里用 内置函数 property 生成了描述器，封装了__ident_func__的get和set操作，提供了一个属性值__ident_func__作为接口，具体代码如下：\ndef _get__ident_func__(self):\n    return self._local.__ident_func__\n\ndef _set__ident_func__(self, value):\n    object.__setattr__(self._local, '__ident_func__', value)\n__ident_func__ = property(_get__ident_func__, _set__ident_func__)\ndel _get__ident_func__, _set__ident_func__\nLocalManager\nLocal 和 LocalStack 都是线程或者协程独立的单个对象，很多时候我们需要一个线程或者协程独立的容器，来组织多个Local或者LocalStack对象（就像我们用一个list来组织多个int或者string类型一样）。\nWerkzeug实现了LocalManager，它通过一个list类型的属性locals来存储所管理的Local或者LocalStack对象，还提供cleanup方法来释放所有的Local对象。Werkzeug中LocalManager最主要的接口就是装饰器方法make_middleware，代码如下：\ndef make_middleware(self, app):\n    \"\"\"Wrap a WSGI application so that cleaning up happens after\n    request end.\n    \"\"\"\n    def application(environ, start_response):\n        return ClosingIterator(app(environ, start_response), self.cleanup)\n    return application\n这个装饰器注册了回调函数cleanup，当一个线程（或者协程）处理完请求之后，就会调用cleanup清理它所管理的Local或者LocalStack 对象（ClosingIterator 的实现在 werkzeug.wsgi中）。下面是一个使用 LocalManager 的简单例子：\nfrom werkzeug.local import Local, LocalManager\n\nlocal = Local()\nlocal_2 = Local()\nlocal_manager = LocalManager([local, local2])\n\ndef application(environ, start_response):\n    local.request = request = Request(environ)\n    ...\n\n# application 处理完毕后，会自动清理local_manager 的内容\napplication = local_manager.make_middleware(application)\n通过LocalManager的make_middleware我们可以在某个线程（协程）处理完一个请求后，清空所有的Local或者LocalStack对象，这样这个线程又可以处理另一个请求了。至此，文章开始时提到的第二个问题就可以解决了。Werkzeug.local 里面还实现了一个 LocalProxy 用来作为Local对象的代理，也非常值得去学习。\n通过这三篇文章，相信对 ThreadLocal 有了一个初步的了解。Python标准库和Werkzeug在实现中都用到了很多python的黑魔法，不过最终提供给用户的都是非常友好的接口。Werkzeug作为WSGI 工具集，为了解决Web开发中的特定使用问题，提供了一个改进版本，并且进行了一系列封装，便于使用。不得不说，werkzeug的代码可读性非常好，注释也是写的非常棒，建议去阅读源码。\n本文由selfboot 发表于个人博客，采用署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议。非商业转载请注明作者及出处。商业转载请联系作者本人本文标题为：深入理解Python中的ThreadLocal变量（下）本文链接为：http://selfboot.cn/2016/11/03...\n更多阅读\nContext Locals   Private Variables and Class-local References   How does the @property decorator work?  How do the Proxy, Decorator, Adapter, and Bridge Patterns differ?  \nFlask源码剖析  Werkzeug.locals 模块解读   Charming Python: 从Flask的request说起  How to remove a key from a python dictionary?  werkzeug源码分析(local.py)\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "6"}