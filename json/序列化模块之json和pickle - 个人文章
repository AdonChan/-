{"title": "序列化模块之json和pickle - 个人文章 ", "index": "python", "content": "什么叫序列化?\n将原本的字典、列表或者类的实例对象等内容转换成一个字符串的过程就叫做序列化。\n为什么要序列化？\n1、以某种存储形式使对象(例如dict，object)持久化，例如存储到数据库中\n2、将对象从一个地方（网络）传递到另一个地方\n\n用于序列化的两个模块：json，用于字符串 和 python数据类型间进行转换pickle，用于python特有的类型 和 python的数据类型间进行转换\n一.json\n首先明确一点：json本质上就是字符串\n\npython对象->json使用json.dumps(python对象)\n\njson->python对象使用json.loads(json字符串)\n\njson字符串中的值必须用双引号，见下例\n\n在python中。只有基本的数据类型才能转换成json格式的字符串，也即：int,float,str,list,tuple,dict\n小技巧：如何记忆dumps和loads呢？我们mysql，redis经常使用到dumps来持久化，也就是将mysql里的数据以字符串或二进制的形式存储到硬盘，所以对应到json中的dumps，将抽象的数据内容（python对象）转成字符串。\n将python对象dumps成json字符串\nimport json\npesron = [{'user':'zs','age':10},\n          {'user': 'ls', 'age':20}]\nx = 10\ny = {'user':'zs','age':10}\njson_str1 = json.dumps(pesron)\njson_str2 = json.dumps(x)\njson_str3 = json.dumps(y)\nprint(type(json_str1),type(x),type(y))\nprint(json_str1,json_str2,json_str3)\n输出\n<class 'str'> <class 'int'> <class 'dict'>\n[{\"user\": \"zs\", \"age\": 10}, {\"user\": \"ls\", \"age\": 20}] 10 {\"user\": \"zs\", \"age\": 10}\n\n如果我们要想把序列化的内容写到文件中，可以直接使用json.dump\nimport json\ndic = {1:\"a\",2:\"b\"}\nf = open('myfile','w',encoding='utf-8')\njson.dump(dic,f)\nf.close()\n使用json.dumps和json.dump的时候，只能存放ascii的字符，因此会将中文进行转义，这时候我们可以做使用ensure_ascii=False关闭这个特性。\n将json字符串loads成python对象\nimport json\n#json_str = \"[{'user':'zs','age':10},{'user': 'ls', 'age':20}]\"  错误，必须用双引号\njson_str1 = \"\"\"[{\"user\":\"zs\",\"age\":10},{\"user\": \"ls\", \"age\":20}]\"\"\"\njson_str2 = \"\"\"{\"user\":\"zs\",\"age\":10}\"\"\"\njson_str3 = \"\"\"12\"\"\"\n\nperson = json.loads(json_str1)\nx = json.loads(json_str2)\ny = json.loads(json_str3)\nprint(type(person),type(x),type(y))\nprint(person,x,y)\n输出\n<class 'list'> <class 'dict'> <class 'int'>\n[{'user': 'zs', 'age': 10}, {'user': 'ls', 'age': 20}] {'user': 'zs', 'age': 10} 12\n二.pickle\npickle可以序列化任意的数据类型，包括集合和类的对象实例\nimport pickle\n\nclass ABC:\n    a = 10\n\n    def __init__(self,m,n):\n        self.m = m\n        self.n = n\n\nabc = ABC(1,2)\nres = pickle.dumps(abc)\nback_res = pickle.loads(res)\nprint(res)\nprint(back_res)\nprint(back_res.a)\n输出结果\nb'\\x80\\x03c__main__\\nABC\\nq\\x00)\\x81q\\x01}q\\x02(X\\x01\\x00\\x00\\x00mq\\x03K\\x01X\\x01\\x00\\x00\\x00nq\\x04K\\x02ub.'\n<__main__.ABC object at 0x10999fba8>\n10\n注意：将pickle.dumps的数据写到文件的时候，文件必须使用rb的模式打开后wb的模式写入\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}