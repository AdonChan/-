{"title": "基于 oracle 的 flask 项目（五）——报表下载 - 藕丝空间 ", "index": "python,flask,flask-sqlalchemy,oracle", "content": "在国企，很多领导是按部就班的晋升上来的，他们的年龄及经历使他们至今还没有掌握电脑的基础知识，因此，纸质报表是他们掌握全局的依据，必备的工具。将报表下载下来，然后能稍许进行修饰，这是必须的。\n项目描述\n将页面原始呈现的数据及搜索后的数据以 excel 报表的形式下载下来。\n知识难点\n单一的 url 页面中会呈现出不同的数据，需要能够把不同的数据下载下来，只需要用到 ajax 的知识，在同一个页面中以 json 的形式传递数据。\n实现页面模板\n不再赘述，仅仅是在页面上加载一个下载按钮，详情看源码。\n实现下载功能的试图函数\nviews.py 的内容如下：\n...\n...\nimport os\nfrom collections import OrderedDict\nfrom config import basedir\nfrom pyexcel_xls import save_data, get_data\n...\n...\n\n\n\n@show.route('/<path:filename>', methods=['GET', 'POST'])\ndef download_xls(filename):\n    data = OrderedDict()\n    data_path = os.path.join(excel_path, filename)\n\n    num = 0\n    if '01.xls' in filename:\n        header_data = ['序号', '部门', '角色', '员工', '电话', '客户', '月份',\n                       '本月资产余额    ', '上月资产余额', '新增余额']\n        body_data = [header_data]\n        for t in json.loads(request.get_data()):\n            num += 1\n            body_data.append([num, t[\"department\"], t[\"role\"], t[\"staff_name\"], t[\"phone\"], t[\"guest_name\"],\n                              t[\"month\"], t[\"balance\"], t[\"last_balance\"],\n                              float('%.2f' % t[\"balance\"]) - float('%.2f' % t[\"last_balance\"])])\n        data.update({'01报表': body_data})\n\n    if '02.xls' in filename:\n        header_data = ['序号', '部门', '角色', '员工', '电话', '月份', '管户数'\n                       '本月资产余额    ', '上月资产余额', '新增余额']\n        body_data = [header_data]\n        for t in json.loads(request.get_data()):\n            num += 1\n            body_data.append([num, t[\"department\"], t[\"role\"], t[\"staff_name\"], t[\"staff_phone\"],\n                              t[\"month\"], t[\"balance\"], t[\"last_balance\"],\n                              float('%.2f' % t[\"balance\"]) - float('%.2f' % t[\"last_balance\"])])\n        data.update({'02报表': body_data})\n    save_data(data_path, data)\n    return jsonify({\"data\": \"ok\"})\n\n很明显，通过 return 返回的 jsonify 数据，大家应该知道，我这是要用 json 了。\n而其中的两个 filename 的判断，我是因为要做两个页面的下载链接，所以对 filename 进行了一个判断。\n代码中使用了 collections 的有序字典 OrderedDict， pyexcel_xls的相关模块，同时也设置了要生成的 xls 文件的生成路径及文件名——data_path = os.path.join(excel_path, filename)。\n\n实现 ajax 功能\n既然是 ajax 那就是 javascript 咯，还得返回 html 模板。在 flask 项目中，模板的变量都是封装在 jinja2 中，我们写 javascript 的时候，不能单独再建立一个 js 文件，导入到模板中，因为，无法获得 Jinja2 变量。还得直接在 html 中写 javasript。\n\n01.html 中实现 ajax 下载\n{% block js %}\n    {{ super() }} <!-- 继承 block js 里的原始 js 文件 -->\n    <script>\n        $SCRIPT_ROOT = {{ request.script_root|tojson|safe }}; <!-- flask ajax 需要进行该项设置 -->\n        function downloadxls() { <!-- 创建 downloadxls 函数，页面上的导出报表按钮需要调用这个函数 -->\n            var database = new Object();\n            database = {{ database|safe }}; <!-- 调用 jinja2 中的变量，使用 safe ，防止出现多重冒号。 -->\n            var data = JSON.stringify(database);\n            $.ajax({\n                type: \"POST\",\n                url: \"{{ url_for('show.download_xls', filename='%s_01.xls' % current_user.phone) }}\",<!-- 生成 xls 文件的 url 链接 -->\n                contentType: \"application/json; charset=utf-8\",\n                data: data, <!-- 返回到后台的 json 数据 -->\n                success: function (msg) {\n                    if (msg.data === 'ok'){ <!-- 后台送来的 'ok' 数据 -->\n                        //window.open(\"{{ url_for('show.static', filename='excel_files/%s_01.xls' % current_user.phone) }}\");<!-- 用 js 打开 xls 文件，可以进行下载，但是会出现页面闪现的现象，界面不算友好。 -->\n                        var $eleForm = $(\"<form method='get'></form>\");<!-- 使用 form 表单的形式进行文件下载，不会出现页面闪现的现象。 -->\n                        $eleForm.attr(\"action\", \"{{ url_for('show.static', filename='excel_files/%s_01.xls' % current_user.phone) }}\");\n                        $(document.body).append($eleForm);\n                        //提交表单，实现下载\n                        $eleForm.submit();\n                    }\n                }\n            })\n        }\n    </script>\n{% endblock %}\n详情请看注释。\n\n02.html 中实现 ajax 下载\n不在赘述，基本上是和 02.html 页面一样。\n至此，你可以实验一下，你的项目是否可以实现报表下载了。\n很不幸，我们忘了一个重要的事情，那就是 js 中 database 是继承自 jinja2 变量，它是否是你所想的那种 json 数据呢。答案是否定的。结果是这样的：\n\n那么我们需要继续工作咯。\n使 sqlalchemy 数据 json 化\nmodels.py 中建立一个类：\nclass AlchemyJsonEncoder(json.JSONEncoder):\n    def default(self, obj):\n        # 判断是否是Query\n        if isinstance(obj, Query):\n            # 定义一个字典数组\n            fields = []\n            # 检索结果集的行记录\n            for rec in obj:\n                # 定义一个字典对象\n                record = {}\n                # 检索记录中的成员\n                for field in [x for x in dir(rec) if\n                              # 过滤属性\n                              not x.startswith('_')\n                              # 过滤掉方法属性\n                              and hasattr(rec.__getattribute__(x), '__call__') == False\n                              # 过滤掉不需要的属性\n                              and x != 'metadata']:\n                    try:\n                        record[field] = rec.__getattribute__(field)\n                    except TypeError:\n                        record[field] = None\n                fields.append(record)\n            # 返回字典数组\n            return fields\n        # 其他类型的数据按照默认的方式序列化成JSON\n        return json.JSONEncoder.default(self, obj)\n详细功能请看注释。\n在 01 ， 02 两个 url 链接的试图函数中，加入如下内容：\nviews.py 中增加\nreturn render_template('show/01.html', data=data, searchForm=search_form, database=json.dumps(database, cls=AlchemyJsonEncoder))\n此时，在查看我们要传输的 json 数据：\n\n至此，你可以使用下载功能了，不管你的页面中的数据如何变化，你下载的报表都会显示你当前页面的数据。\n源码下载\n\n提示： 让这么多的数据在页面中使用明文传输，是一种极其不安全的行为，这是网络爬虫的肥沃矿场。当然，如果你使用的环境是我这样的内部 web 环境，那就另当别论。不过如果你有更好的解决方法，那么可以告诉我，不胜感激。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}