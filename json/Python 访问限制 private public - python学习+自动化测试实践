{"title": "Python 访问限制 private public - python学习+自动化测试实践 ", "index": "python", "content": "\n一、知识点\n在一个模块中，我们可能会定义很多函数和变量。但有的函数和变量我们希望能给别人使用，有的函数和变量我们希望仅仅在模块内部使用，so?我们可以通过定义该函数、变量是公开的还是私有的来达到该目的。在Python中，是通过下划线“_”前缀来实现的。\n\n\npublic：公开的。正常的函数和变量名为此类型，可以被直接引用。比如变量abc、PI等；\n\n特殊变量：格式为__xxx__ ，以__开头、以__结尾。可以直接被引用，但是有特殊用途。比如 __author__ 、__name__就是特殊变量。一般自己定义的变量不要用这种变量名。\n\nprivate：私有的、非公开的，格式类似于_xxx_ 和__xxx，例如__num。 不应该被直接引用，只有内部可以访问，外部不能访问。 不能随意修改对象内部的状态，这样通过访问限制的保护，代码更加健壮。\n\n二、举例说明\n在Class类内部，可以有属性和方法。而外部代码可以通过直接调用实例变量的方法来操作数据，隐藏了内部复杂逻辑。但是，外部代码还是可以自由地修改一个实例的属性。例如：\n>>>b.score\n99\n>>>b.score = 59\n>>>b.score\n59\n如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线“__”，变成私有变量，如下：\nclass Student(object):     \n    def __init__(self, name, score):         \n        self.__name = name         \n        self.__score = score     \n        \n    def print_score(self):         \n        print('%s: %s' % (self.__name, self.__score))\n尝试在外部对属性进行访问，发现会报错，因为私有变量，不能被外部访问。\n>>> bart = Student('Bart Simpson', 98) \n>>> bart.__name  # 私有变量：不能被外部访问\nTraceback (most recent call last):   \nFile \"<stdin>\", line 1, in <module> \nAttributeError: 'Student' object has no attribute '__name'\n但是，如果外部代码要获取name和score怎么办？给Student类增加获取属性的方法：get_name()和get_score()，如下：\nclass Student(object):\n    ...\n    def get_name(self):          \n        return self.__name      \n    def get_score(self):          \n        return self.__score \n如果外部代码修改score怎么办？可以再给Student类增加设置方法：set_score()：\n...\ndef set_score(self, score):  \n    # 避免传入无效参数  \n    if 0 <= score <= 100:  \n        self.__score = score \n    else:              \n        raise ValueError('bad score')  \n那作为双下划线开头的私有实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以仍然可以通过_Student__name来访问__name变量。\n>>> bart = Student('Bart Simpson', 98)\n>>> bart.get_name() \n'Bart Simpson' \n>>> bart.__name = 'New Name'  # 给bart新增的__name变量 \n>>> bart.__name               # ！与class内部的__name变量不是一个变量！\n'New Name'  \n>>> bart.get_name()           # get_name()内部返回self.__name (_Student__name)\n'Bart Simpson'    \n表面上看，外部代码“成功”地设置了__name变量，但实际上这个__name变量和class内部的__name变量不是一个变量！内部的__name变量已经被Python解释器自动改成了_Student__name，而外部代码给bart新增了一个__name变量。\n所以python并没有一种方法可以完全限制访问private的函数或变量，所以不是“不能被直接引用”，从编程的习惯上不应该引用private函数或变量。那他们的用处呢？例如：\ndef _private_1 (name):\n    return 'hello,%s ' % name\ndef _private_2 (name):\n    return 'hi , %s ' % name\ndef greeting(name):\n    if len(name) > 3:\n        return _private_1 (name)\n    else:\n        return _private_2 (name)\n在模块里公开greeting()函数，而把内部逻辑用private函数隐藏起来了。这样，调用greeting()函数不用关心内部的私有函数的细节。这是一种非常有用的代码封装和抽象的方法，即：外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。\n三、完整代码\nclass Student(object):     \n    def __init__(self, name, score):         \n        self.__name = name         \n        self.__score = score     \n        \n    def print_score(self):         \n        print('%s: %s' % (self.__name, self.__score))\n    \n    def get_name(self):          \n        return self.__name      \n    \n    def get_score(self):          \n        return self.__score\n        \n    def set_score(self, score):  \n        # 避免传入无效参数  \n        if 0 <= score <= 100:  \n            self.__score = score \n        else:              \n            raise ValueError('bad score')   \n            \n    def _private_1 (name):\n        return 'hello,%s ' % name\n    def _private_2 (name):\n        return 'hi , %s ' % name\n    def greeting(name):\n        if len(name) > 3:\n            return _private_1 (name)\n        else:\n            return _private_2 (name)\n\n❤ thanks for watching, keep on updating...点个赞再走吧\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}