{"title": "流畅的python读书笔记-第十四章-可迭代的对象、迭代器和生成器 - 个人文章 ", "index": "python", "content": "可迭代的对象、迭代器和生成器\n理念\n迭代是数据处理的基石。扫描内存中放不下的数据集时，我们要找到一种惰性获取数据项的方式，即按需一次获取一个数据项。这就是迭代器模式（Iterator pattern）。\n看个例子\nimport re\nimport reprlib\n\nRE_WORD = re.compile('\\w+')\n\n\nclass Sentence:\n    def __init__(self, text):\n        self.text = text\n        self.words = RE_WORD.findall(text)\n\n    def __getitem__(self, index):\n        return self.words[index]\n\n    def __len__(self):\n        return len(self.words)\n\n    def __repr__(self):\n        return 'Sentence(%s)' % reprlib.repr(self.text)\n\n\ns = Sentence('\"The time has come,\" the Walrus said,')\nprint(s)\n\nfor world in s:\n    print(world)\nfor 循环就是 用到了index, index在__getitem__被用到了\n序列可以迭代的原因 iter函数\n解释器需要迭代对象 x 时，会自动调用 iter(x)。\n内置的 iter 函数有以下作用。\n\n(1) 检查对象是否实现了 iter 方法，如果实现了就调用它，获取一个迭代器。\n(2) 如果没有实现 iter 方法，但是实现了 getitem 方法，Python 会创建一个迭代器，尝试按顺序（从索引 0 开始）获取元素。\n(3) 如果尝试失败，Python 抛出 TypeError 异常，通常会提示“C object is not iterable”（C对象不可迭代），其中 C 是目标对象所属的类。\n\n可迭代的对象与迭代器的对比\nPython 从可迭代的对象中获取迭代器\n标准的迭代器接口有两个方法。\nnext　　返回下一个可用的元素，如果没有元素了，抛出 StopIteration 异常。iter　　返回 self，以便在应该使用可迭代对象的地方使用迭代器，例如在 for 循环中。\n\nabc.Iterator 类\nfrom  abc import abstractmethod\n\nclass Iterator(Iterable):\n    __slots__ = ()\n\n    @abstractmethod\n    def __next__(self):\n        'Return the next item from the iterator. When exhausted, raise StopIteration'\n        raise StopIteration\n\n    def __iter__(self):\n\n        return self\n\n    @classmethod\n    def __subclasshook__(cls, C):\n\n        if cls is Iterator:\n            if (any(\"__next__\" in B.__dict__ for B in C.__mro__) and\n                    any(\"__iter__\" in B.__dict__ for B in C.__mro__)):\n                return True\n\n        return NotImplemented\n\n如何使用 next(...) 函数使用迭代器\nimport re\nimport reprlib\n\nRE_WORD = re.compile('\\w+')\n\n\nclass Sentence:\n    def __init__(self, text):\n        self.text = text\n        self.words = RE_WORD.findall(text)\n\n    def __getitem__(self, index):\n        return self.words[index]\n\n    def __len__(self):\n        return len(self.words)\n\n    def __repr__(self):\n        return 'Sentence(%s)' % reprlib.repr(self.text)\n\n\n# s = Sentence('\"The time has come,\" the Walrus said,')\n# print(s)\n#\n# for world in s:\n#     print(world)\n\n## it就是构造后的迭代器\n## iter(s3) 就是构建迭代器的可迭代对象。\ns3 = Sentence('Pig and Pepper')\nit = iter(s3)\n\nprint(next(it))\nprint(next(it))\nprint(next(it))\n\n# 报错 StopIteration\n# print(next(it))\n\nprint(list(it))\n\nprint(list(iter(s3)))\nprint(list(iter(s3)))\n\n\n因为迭代器只需 next 和 iter 两个方法，所以除了调用 next() 方法，以及捕获 StopIteration 异常之外，没有办法检查是否还有遗留的元素。\n此外，也没有办法“还原”迭代器。\n如果想再次迭代，那就要调用 iter(...)，传入之前构建迭代器的可迭代对象。\n传入迭代器本身没用，因为前面说过 Iterator.__iter__ 方法的实现方式是返回实例本身，所以传入迭代器无法还原已经耗尽的迭代器。\n典型的迭代器\nimport re\nimport reprlib\n\nRE_WORD = re.compile('\\w+')\n\n\nclass Sentence:\n    def __init__(self, text):\n        self.text = text\n        self.words = RE_WORD.findall(text)\n\n    def __repr__(self):\n        return 'Sentence(%s)' % reprlib.repr(self.text)\n\n    def __iter__(self):\n        return SentenceIterator(self.words)\n\n\nclass SentenceIterator:\n    def __init__(self, words):\n        self.words = words\n        self.index = 0\n\n    def __next__(self):\n        try:\n            word = self.words[self.index]\n        except IndexError:\n            raise StopIteration()\n\n        self.index += 1\n        return word\n\n    def __iter__(self):\n        return self\n\ns = Sentence('\"The time has come,\" the Walrus said,')\nfor word in s:\n    print(word)\n\n❶ 与前一版相比，这里只多了一个 iter 方法。这一版没有 getitem 方法，为的是明确表明这个类可以迭代，因为实现了 iter 方法。❷ 根据可迭代协议，__iter__ 方法实例化并返回一个迭代器。\nSentence 类中，__iter__ 方法调用 SentenceIterator 类的构造方法创建一个迭代器并将其返回。\n为什么 不写在一起\n把Sentence变成迭代器：坏主意\n构建可迭代的对象和迭代器时经常会出现错误，原因是混淆了二者。\n要知道，可迭代的对象有个 iter 方法，每次都实例化一个新的迭代器；而迭代器要实现 next 方法，返回单个元素，此外还要实现 iter 方法，返回迭代器本身。\n因此，迭代器可以迭代，但是可迭代的对象不是迭代器。\n除了 iter 方法之外，你可能还想在 Sentence 类中实现 next 方法，让Sentence 实例既是可迭代的对象，也是自身的迭代器。\n可是，这种想法非常糟糕。根据有大量 Python 代码审查经验的 Alex Martelli 所说，这也是常见的反模式。\npython的正确解决之道\n生成器函数\nimport re\nimport reprlib\n\nRE_WORD = re.compile('\\w+')\n\n\nclass Sentence:\n    def __init__(self, text):\n        self.text = text\n        self.words = RE_WORD.findall(text)\n\n    def __repr__(self):\n        return 'Sentence(%s)' % reprlib.repr(self.text)\n\n    def __iter__(self):\n        for word in self.words:\n            yield word\n        return\n\n\ns = Sentence('\"The time has come,\" the Walrus said,')\nfor word in s:\n    print(word)\n❸ 这个 return 语句不是必要的；这个函数可以直接“落空”，自动返回。不管有没有return 语句，生成器函数都不会抛出 StopIteration 异常，而是在生成完全部值之后会直接退出。❹ 不用再单独定义一个迭代器类！\n迭代器其实是生成器对象，每次调用 iter 方法都会自动创建，因为这里的 iter 方法是生成器函数。\n生成器函数的工作原理\n只要 Python 函数的定义体中有 yield 关键字，该函数就是生成器函数。调用生成器函数时，会返回一个生成器对象。也就是说，生成器函数是生成器工厂\ndef gen_123():  # ➊\n    yield 1  # ➋\n    yield 2\n    yield 3\n\nprint(gen_123)\n\nprint(gen_123())\n\nfor i in gen_123():  # ➎\n    print(i)\n\ng = gen_123()  # ➏\nprint(next(g))\nprint(next(g))\nprint(next(g))\n\n## 报错 StopIteration\n# print(next(g))\n❸ 仔细看，gen_123 是函数对象。❻ 为了仔细检查，我们把生成器对象赋值给 g。❽ 生成器函数的定义体执行完毕后，生成器对象会抛出 StopIteration 异常。\n把生成器传给next(...) 函数时，生成器函数会向前，执行函数定义体中的下一个 yield 语句，返回产出的值，并在函数定义体的当前位置暂停。\n最终，函数的定义体返回时，外层的生成器对象会抛出 StopIteration 异常——这一点与迭代器协议一致。\n惰性实现\nimport re\nimport reprlib\n\nRE_WORD = re.compile('\\w+')\n\n\nclass Sentence:\n    def __init__(self, text):\n        self.text = text\n\n    def __repr__(self):\n        return 'Sentence(%s)' % reprlib.repr(self.text)\n\n    def __iter__(self):\n        # 返回一个迭代器\n        for match in RE_WORD.finditer(self.text):\n            yield match.group()\n\nre.finditer 函数是 re.findall 函数的惰性版本，返回的不是列表，而是一个生成器，按需生成 re.MatchObject 实例。\n如果有很多匹配，re.finditer 函数能节省大量内存。我们要使用这个函数让第 4 版 Sentence 类变得懒惰，即只在需要时才生成下一个单词。\n❶ 不再需要 words 列表。❷ finditer 函数构建一个迭代器，包含 self.text 中匹配 RE_WORD 的单词，产出MatchObject 实例。❸ match.group() 方法从 MatchObject 实例中提取匹配正则表达式的具体文本。\n生成器表达式\n生成器表达式可以理解为列表推导的惰性版本：不会迫切地构建列表，而是返回一个生成器，按需惰性生成元素。\ndef gen_AB():  # ➊\n    print('start')\n    yield 'A'\n    print('continue')\n    yield 'B'\n    print('end.')\n\n\nres1 = [x * 3 for x in gen_AB()]\n\nfor i in res1:  # ➌\n    print('-->', i)\n\nres2 = (x * 3 for x in gen_AB())  # ➍\nprint(res2)  # ➎\n\nfor i in res2:  # ➏\n    print('-->', i)\n\n❷ 列表推导迫切地迭代 gen_AB() 函数生成的生成器对象产出的元素：'A' 和 'B'。注意，下面的输出是 start、continue 和 end.。\n❸ 这个 for 循环迭代列表推导生成的 res1 列表。\n❹ 把生成器表达式返回的值赋值给 res2。只需调用 gen_AB() 函数，虽然调用时会返回一个生成器，但是这里并不使用。\n❺ res2 是一个生成器对象。❻ 只有 for 循环迭代 res2 时，gen_AB 函数的定义体才会真正执行。for 循环每次迭代时会隐式调用 next(res2)，前进到 gen_AB 函数中的下一个yield 语句。\n注意，gen_AB 函数的输出与 for 循环中 print 函数的输出夹杂在一起。\n何时使用生成器表达式\n根据我的经验，选择使用哪种句法很容易判断：如果生成器表达式要分成多行写，我倾向于定义生成器函数，以便提高可读性。此外，生成器函数有名称，因此可以重用。\n8　另一个示例：等差数列生成器\nclass ArithmeticProgression:\n    def __init__(self, begin, step, end=None):  # ➊\n        self.begin = begin\n        self.step = step\n        self.end = end  # None -> 无穷数列\n\n\ndef __iter__(self):\n    result = type(self.begin + self.step)(self.begin)  # ➋\n    forever = self.end is None  # ➌\n    index = 0\n    while forever or result < self.end:  # ➍\n        yield result  # ➎\n    index += 1\n    result = self.begin + self.step * index  # ➏\n\n❸ 为了提高可读性，我们创建了 forever 变量，如果 self.end 属性的值是 None那么forever 的值是 True，因此生成的是无穷数列。❹ 这个循环要么一直执行下去，要么当 result 大于或等于 self.end 时结束。如果循环退出了，那么这个函数也随之退出。\n在示例 14-11 中的最后一行，我没有直接使用 self.step 不断地增加 result，\n而是选择使用 index 变量，把 self.begin 与 self.step 和 index 的乘积加，计算 result 的各个值，\n以此降低处理浮点数时累积效应致错的风险。\n标准库里有大量的生成器轮子 page408\n深入分析iter函数\n可是，iter 函数还有一个鲜为人知的用法：传入两个参数，使用常规的函数或任何可调用的对象创建迭代器。\n这样使用时，第一个参数必须是可调用的对象，用于不断调用（没有参数），产出各个值；\n第二个值是哨符，这是个标记值，当可调用的对象返回这个值时，触发迭代器抛出 StopIteration 异常，而不产出哨符。\niter 函数掷骰子，直到掷出 1 点为止\nfrom random import randint\n\ndef d6():\n    return randint(1, 6)\n\nd6_iter = iter(d6, 1)\n\nprint(d6_iter)\n\nfor roll in d6_iter:\n    print(roll)\n\n总结\n\n迭代器 都有 iter这个方法(函数), (每个都调用__getitem__做兼容) next()到底.\nfor每次迭代都是next()\n对付大文件,大内存. 先返回迭代器对象, 在执行迭代器的具体 操作\npython 用yield 作为生成器的特征\nsend可以发送给 那个状态的生成器\niter别的用法  有两个参数   第二个是哨符 (遇到就停了)\n\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "0"}