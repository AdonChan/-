{"title": "Find Minimum in Rotated Sorted Array - 个人文章 ", "index": "算法,python", "content": "题目\nhttp://www.lintcode.com/en/pr...\nSuppose a sorted array is rotated at some pivot unknown to you beforehand.\n(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).\nFind the minimum element.\n思路\n个人觉得这是一道值得回味的二分法题目。与给出target的二分法搜索比，这道题目的target是未知的，并且array是rotated。我个人是从观察给出的例子入手的。通过观察这个例子，我们发现以下特征：\n\n最小值是唯一一个比它左右相邻数字都小的数字\n当中位数比start 和 end 都大的时候，最小值在右边\n当中位数比start 和 end 都小的时候，最小值在左边\n当中位数比start大，比end小的时候，我们进入了sorted的array，最小值也是在左边\n\n那么我们做这道题目的目的，就是通过2，3这两步，进入最小值所在的sorted的array，从而进行第4步。我本人走的弯路是，过于专注于1，从而逻辑变得复杂。其实2，3，和4步就可以帮助我们顺利找到最小值。\n代码\nclass Solution:\n    # @param nums: a rotated sorted array\n    # @return: the minimum number in the array\n    def findMin(self, nums):\n        # write your code here\n        if nums is None or len(nums) == 0:\n            return -1\n        start = 0\n        end = len(nums) - 1\n        while start + 1 < end:\n            mid = start + (end - start) / 2\n            if nums[mid] > nums[end]:\n                start = mid\n            elif nums[mid] < nums[start] or (nums[mid] < nums[end] and nums[mid] > nums[start]):\n                end = mid\n        return nums[start] if nums[start] < nums[end] else nums[end]\n体会\n这道题目的个人体会就是如果用二分法处理sorted array，核心逻辑在于把已知input分为左右两部分，再从中入手。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}