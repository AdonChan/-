{"title": "三对角线性方程组(tridiagonal systems of equations)的求解 - 个人文章 ", "index": "python", "content": "三对角线性方程组(tridiagonal systems of equations)\n  三对角线性方程组,对于熟悉数值分析的同学来说，并不陌生，它经常出现在微分方程的数值求解和三次样条函数的插值问题中。三对角线性方程组可描述为以下方程组：$$a_{i}x_{i-1}+b_{i}x_{i}+c_{i}x_{i+1}=d_{i}$$其中$1\\leq i \\leq n, a_{1}=0, c_{n}=0.$ 以上方程组写成矩阵形式为$Ax=d$，即：\n$$\n{\\begin{bmatrix}\n{b_{1}}&{c_{1}}&{}&{}&{0}\\\\\n{a_{2}}&{b_{2}}&{c_{2}}&{}&{}\\\\\n{}&{a_{3}}&{b_{3}}&\\ddots &{}\\\\\n{}&{}&\\ddots &\\ddots &{c_{n-1}}\\\\\n{0}&&&{a_{n}}&{b_{n}}\\\\\n\\end{bmatrix}}\n{\\begin{bmatrix}{x_{1}}\\\\{x_{2}}\\\\{x_{3}}\\\\\\vdots \\\\{x_{n}}\\\\\\end{bmatrix}}={\\begin{bmatrix}{d_{1}}\\\\{d_{2}}\\\\{d_{3}}\\\\\\vdots \\\\{d_{n}}\\\\\\end{bmatrix}}\n$$\n  三对角线性方程组的求解采用追赶法或者Thomas算法，它是Gauss消去法在三对角线性方程组这种特殊情形下的应用，因此，主要思想还是Gauss消去法，只是会更加简单些。我们将在下面的算法详述中给出该算法的具体求解过程。  当然，该算法并不总是稳定的，但当系数矩阵$A$为严格对角占优矩阵（Strictly D iagonally Dominant, SDD）或对称正定矩阵（Symmetric Positive Definite, SPD）时，该算法稳定。对于不熟悉SDD或者SPD的读者，也不必担心，我们还会在我们的博客中介绍这类矩阵。现在，我们只要记住，该算法对于部分系数矩阵$A$是可以求解的。\n算法详述\n  追赶法或者Thomas算法的具体步骤如下：\n1.创建新系数$c_{i}^{*}$和$d_{i}^{*}$来代替原先的$a_{i},b_{i},c_{i}$,公式如下：\n$$\nc^{*}_i = \\left\\{\n     \\begin{array}{lr}\n       \\frac{c_1}{b_1} & ; i = 1\\\\\n       \\frac{c_i}{b_i -  a_i c^{*}_{i-1}} & ; i = 2,3,...,n-1\n     \\end{array}\n   \\right.\\\\\nd^{*}_i = \\left\\{\n     \\begin{array}{lr}\n       \\frac{d_1}{b_1} & ; i = 1\\\\\n       \\frac{d_i-  a_i d^{*}_{i-1}}{b_i -  a_i c^{*}_{i-1}} & ; i = 2,3,...,n-1\n     \\end{array}\n   \\right.\n$$\n2.改写原先的方程组$Ax=d$如下：\n$$\n\\begin{bmatrix}  \n1 & c^{*}_1 & 0 & 0 & ... & 0 \\\\ \n0 & 1 & c^{*}_2 & 0 & ... & 0 \\\\ \n0 & 0 & 1 & c^{*}_3 & 0 & 0 \\\\ \n. & . &  &  &  & . \\\\ \n. & . &  &  &  & . \\\\ \n. & . &  &  &  & c^{*}_{n-1} \\\\ \n0 & 0 & 0 & 0 & 0 & 1 \\\\ \n\\end{bmatrix} \\begin{bmatrix}  \nx_1 \\\\ \nx_2 \\\\ \nx_3 \\\\ \n.\\\\ \n.\\\\ \n.\\\\ \nx_k \\\\ \n\\end{bmatrix} = \\begin{bmatrix} \nd^{*}_1 \\\\ \nd^{*}_2 \\\\ \nd^{*}_3 \\\\ \n.\\\\ \n.\\\\ \n.\\\\ \nd^{*}_n \\\\ \n\\end{bmatrix}\n$$\n3.计算解向量$x$，如下：$$ x_n = d^{*}_n, \\qquad x_i = d^{*}_i - c^{*}_i x_{i+1}, \\qquad i = n-1, n-2, ... ,2,1$$\n  以上算法得到的解向量$x$即为原方程$Ax=d$的解。  下面，我们来证明该算法的正确性，只需要证明该算法保持原方程组的形式不变。  首先，当$i=1$时，$$1*x_{1}+c_{1}^{*}x_{2}=d_{1}^{*} \\Leftrightarrow 1*x_{1}+\\frac{c_{1}}{b_{1}}x_{2}=\\frac{d_{1}}{b_{1}}\\Leftrightarrow b_{1}*x_{1}+c_{1}x_{2}=d_{1}$$  当$i>1$时，\n$$\n1*x_{i}+c_{i}^{*}x_{i+1}=d_{i}^{*} \\Leftrightarrow 1*x_{i}+\\frac{c_{i}}{b_{i} -  a_{i} c^{*}_{i-1}}x_{i+1}=\\frac{d_{i}-  a_{i} d^{*}_{i-1}}{b_{i} -  a_{i} c^{*}_{i-1}} \\Leftrightarrow\n(b_{i} -  a_{i} c^{*}_{i-1})x_{i}+c_{i}x_{i+1}=d_{i}-  a_{i} d^{*}_{i-1}\n$$\n结合$a_{i}x_{i-1}+b_{i}x_{i}+c_{i}x_{i+1}=d_{i}$，只需要证明$x_{i-1}+c_{i-1}^{*}x_{i}=d_{i-1}^{*}$,而这已经在该算法的第（3）步的中的计算$x_{i-1}$中给出。证明完毕。\nPython实现\n  我们将要求解的线性方程组如下：\n$$\n{\\begin{bmatrix}\n4&1&{0}&{0}&{0}\\\\\n{1}&{4}&{1}&{0}&{0}\\\\\n{0}&{1}&{4}&{1}&{0}\\\\\n{0}&{0}&{1}&{4}&{1}\\\\\n{0}&{0}&{0}&{1}&{4}\\\\\n\\end{bmatrix}}\n{\\begin{bmatrix}{x_{1}}\\\\{x_{2}}\\\\{x_{3}}\\\\{x_{4}} \\\\{x_{5}}\\\\\\end{bmatrix}}={\\begin{bmatrix}{1\\\\0.5\\\\ -1\\\\3\\\\2}\\\\\\end{bmatrix}}\n$$\n  接下来，我们将用Python来实现该算法，函数为TDMA，输入参数为列表a,b,c,d, 输出为解向量x，代码如下：\n# use Thomas Method to solve tridiagonal linear equation\n# algorithm reference: https://en.wikipedia.org/wiki/Tridiagonal_matrix_algorithm\n\nimport numpy as np\n\n# parameter: a,b,c,d are list-like of same length\n# tridiagonal linear equation: Ax=d\n# b: main diagonal of matrix A\n# a: main diagonal below of matrix A\n# c: main diagonal upper of matrix A\n# d: Ax=d\n# return: x(type=list), the solution of Ax=d\ndef TDMA(a,b,c,d):\n\n    try:\n        n = len(d)    # order of tridiagonal square matrix\n\n        # use a,b,c to create matrix A, which is not necessary in the algorithm\n        A = np.array([[0]*n]*n, dtype='float64')\n\n        for i in range(n):\n            A[i,i] = b[i]\n            if i > 0:\n                A[i, i-1] = a[i]\n            if i < n-1:\n                A[i, i+1] = c[i]\n\n        # new list of modified coefficients\n        c_1 = [0]*n\n        d_1 = [0]*n\n\n        for i in range(n):\n            if not i:\n                c_1[i] = c[i]/b[i]\n                d_1[i] = d[i] / b[i]\n            else:\n                c_1[i] = c[i]/(b[i]-c_1[i-1]*a[i])\n                d_1[i] = (d[i]-d_1[i-1]*a[i])/(b[i]-c_1[i-1] * a[i])\n\n        # x: solution of Ax=d\n        x = [0]*n\n\n        for i in range(n-1, -1, -1):\n            if i == n-1:\n                x[i] = d_1[i]\n            else:\n                x[i] = d_1[i]-c_1[i]*x[i+1]\n\n        x = [round(_, 4) for _ in x]\n\n        return x\n\n    except Exception as e:\n        return e\n\ndef main():\n\n    a = [0, 1, 1, 1, 1]\n    b = [4, 4, 4, 4, 4]\n    c = [1, 1, 1, 1, 0]\n    d = [1, 0.5, -1, 3, 2]\n\n    '''\n    a = [0, 2, 1, 3]\n    b = [1, 1, 2, 1]\n    c = [2, 3, 0.5, 0]\n    d = [2, -1, 1, 3]\n    '''\n\n    x = TDMA(a, b, c, d)\n    print('The solution is %s'%x)\n\nmain()\n运行该程序，输出结果为：\nThe solution is [0.2, 0.2, -0.5, 0.8, 0.3]\n  本算法的Github地址为： https://github.com/percent4/N... .  最后再次声明，追赶法或者Thomas算法并不是对所有的三对角矩阵都是有效的，只是部分三对角矩阵可行。\n参考文献\n\nhttps://www.quantstart.com/ar...\nhttps://en.wikipedia.org/wiki...\nhttps://wenku.baidu.com/view/...\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}