{"title": "Python “黑魔法” 之 Encoding & Decoding - Thoughts of hsfzxjy ", "index": "python,codecs", "content": "首发于我的博客，转载请注明出处\n写在前面\n\n本文为科普文\n本文中的例子在 Ubuntu 14.04 / Python 2.7.11 下运行成功，Python 3+ 的接口有些许不同，需要读者自行转换\n\n引子\n先看一段代码：\nexample.py：\n# -*- coding=yi -*-\n\n从 math 导入 sin, pi\n\n打印 'sin(pi) =', sin(pi)\n这是什么？！是 Python 吗？可以运行吗？——想必你会问。\n我可以明确告诉你：这不是 Python，但它可以用 Python 解释器运行。当然，如果你愿意，可以叫它 “Yython” （易语言 + Python）。\n\n怎么做到的？也许你已经注意到第一行的奇怪注释——没错，秘密全在这里。\n这种黑魔法，还要从 PEP 263 说起。\n古老的 PEP 263\n我相信 99% 的中国 Python 开发者都曾经为一个问题而头疼——字符编码。那是每个初学者的梦靥。\n还记得那天吗？当你试图用代码向它示好：\nprint '你好'\n它却给你当头一棒：\nSyntaxError: Non-ASCII character '\\xe4' in file chi.py on line 1, but no encoding declared\n【一脸懵逼】\n于是，你上网查找解决方案。很快，你便有了答案：\n# -*- coding=utf-8 -*-\n\nprint '你好'\n其中第一行的注释用于指定解析该文件的编码。\n这个特新来自 2001 年的 PEP 263 -- Defining Python Source Code Encodings，它的出现是为了解决一个反响广泛的问题：\nIn Python 2.1, Unicode literals can only be written using the Latin-1 based encoding \"unicode-escape\". This makes the programming environment rather unfriendly to Python users who live and work in non-Latin-1 locales such as many of the Asian countries. Programmers can write their 8-bit strings using the favorite encoding, but are bound to the \"unicode-escape\" encoding for Unicode literals.\nPython 默认用 ASCII 编码解析文件，给 15 年前的非英文世界开发者造成了不小的困扰——看来 Guido 老爹有些个人主义，设计时只考虑到了英文世界。\n提案者设想：使用一种特殊的文件首注释，用于指定代码的编码。这个注释的正则原型是这样的：\n^[ \\t\\v]*#.*?coding[:=][ \\t]*([-_.a-zA-Z0-9]+)\n也就是说 # -*- coding=utf-8 -*- 并不是唯一的写法，只是 Emacs 推荐写法而已。诸如 # coding=utf-8、# encoding: utf-8 都是合法的——因此你不必惊讶于他人编码声明与你不同。\n正则的捕获组 ([-_.a-zA-Z0-9]+) 将会被用作查找编码的名称，查找到的编码信息会被用于解码文件。也就是说，import example 背后其实相当于有如下转换过程：\nwith open('example.py', 'r') as f:\n    content = f.read()\n    encoding = extract_encoding_info(content) # 解析首注释\n    exec(content.decode(encoding))\n问题其实又回到我们常用的 str.encode 和 str.decode 上来了。\n可 Python 怎么这么强大？！几乎所有编码它都认得！这是怎么做到的？是标准库？还是内置于解释器中？\n一切，都是 codecs 模块在起作用。\ncodecs\ncodecs 算是较为冷门的一个模块，更为常用的是 str 的 encode/decode 的方法——但它们本质都是对 codecs 的调用。\n打开 /path/to/your/python/lib/encodings/ 目录，你会发现有许多以编码名称命名的 .py 文件，如 utf_8.py、latin_1.py。这些都是系统预定义的编码系统，实现了应对各种编码的逻辑——也就是说：编码系统其实也是普通的模块。\n除了内置的编码，用户也可以 自行定义编码系统。codecs 暴露了一个 register 函数，用于注册自定义编码。register 签名如下：\n\ncodecs.register(search_function)Register a codec search function. Search functions are expected to take one argument, the encoding name in all lower case letters, and return a CodecInfo object having the following attributes:\n\nname: The name of the encoding;\nencode: The stateless encoding function;\ndecode: The stateless decoding function;\nincrementalencoder: An incremental encoder class or factory function;\nincrementaldecoder: An incremental decoder class or factory function;\nstreamwriter: A stream writer class or factory function;\nstreamreader: A stream reader class or factory function.\n\n\nencode 和 decode 是无状态的编码/解码的函数，简单说就是：前一个被编解码的字符串与后一个没有关联。如果你想用 codecs 系统进行语法树解析，解析逻辑最好不要写在这里，因为代码的连续性无法被保证；incremental* 则是有状态的解析类，能弥补 encode、decode 的不足；stream* 是流相关的解析类，行为通常与 encode/decode 相同。\n关于这六个对象的具体写法，可以参考 /path/to/your/python/lib/encodings/rot_13.py，该文件实现了一个简单的密码系统。\n那么，是时候揭开真相了。\n所谓的 “Yython”\n黑魔法其实并不神秘，照猫画虎定义好相应的接口即可。作为例子，这里只处理用到的关键字：\nyi.py：\n# encoding=utf8\n\nimport codecs\n\nyi_map = {\n    u'从': 'from',\n    u'导入': 'import',\n    u'打印': 'print'\n}\n\n\ndef encode(input):\n    for key, value in yi_map.items():\n        input = input.replace(value, key)\n\n    return input.encode('utf8')\n\n\ndef decode(input):\n    input = input.decode('utf8')\n    for key, value in yi_map.items():\n        input = input.replace(key, value)\n\n    return input\n\n\nclass Codec(codecs.Codec):\n\n    def encode(self, input, errors=\"strict\"):\n        input = encode(input)\n\n        return (input, len(input))\n\n    def decode(self, input, errors=\"strict\"):\n        input = decode(input)\n\n        return (input, len(input))\n\n\nclass IncrementalEncoder(codecs.IncrementalEncoder):\n    def encode(self, input, final=False):\n        return encode(input)\n\n\nclass IncrementalDecoder(codecs.IncrementalDecoder):\n    def decode(self, input, final=False):\n        return decode(input)\n\n\nclass StreamWriter(Codec, codecs.StreamWriter):\n    pass\n\n\nclass StreamReader(Codec, codecs.StreamReader):\n    pass\n\n\ndef register_entry(encoding):\n    return codecs.CodecInfo(\n        name='yi',\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamwriter=StreamWriter,\n        streamreader=StreamReader\n    ) if encoding == 'yi' else None\n在命令行里注册一下，就可以看到激动人心的结果了：\n>>> import codecs, yi\n>>> codecs.register(yi.register_entry)\n>>> import example\nsin(pi) = 1.22464679915e-16\n结语\n有时，对习以为常的东西深入了解一下，说不定会有惊人的发现。\nReferences\ncodecs - Codec registry and base classes\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "26"}