{"title": "Python基础之正确重载运算符 - 个人文章 ", "index": "python", "content": "导语：本文章记录了本人在学习Python基础之面向对象篇的重点知识及个人心得，打算入门Python的朋友们可以来一起学习并交流。\n本文重点：\n1、掌握运算符重载的定义和作用，以及Python对其的内部限制；2、掌握一元运算符重载设计思路；3、理解中缀运算符重载过程中鸭子类型和白鹅类型思想的运用并掌握。\n一、运算符重载基础\n运算符重载：对已有的运算符进行重新定义，赋予其另一种功能，以适应不同的数据类型。重载的作用：令用户定义的对象能够使用中缀运算符（如 + 和 | ）或一元运算符（如 - 和 ~ ）等运算符。为了做好灵活性、可用性和安全性方面的平衡，Python对运算符重载施加了一些限制：\n\n\n不能重载内置类型的运算符；\n\n能新建运算符，只能重载现有运算符；\n\n某些运算符不能重载，如is、and、or和not（不过位运算符&、| 和 ~可以）。\n\n二、一元运算符\n1、常见的一元运算符\n\n-（__neg__），一元取负算术运算符。例：若 x 是 -2，则 -x==2。\n+（__pos__），一元取正算术运算符。通常x==+x。\n~（__invert__），对整数按位取反，~x== -(x+1)。例：若 x 是 -2，则 ~x==1。\n\n另外，Python语言参考手册将内置的abs()函数列为一元运算符，它对应的特殊方法是__abs__。\n2、重载一元运算符\n重载一元运算符只需实现相应的特殊方法，这些特殊方法只有self一个参数。重载应遵循运算符的一个基本规则：始终返回一个新对象。即，不能修改self，要创建并返回合适类型的新实例。\n下面我们以第10章的多维向量类为例重载一元运算符：\nimport math\nclass Vector:\n#排版需要省略中间代码\n    def __abs__(self):\n        return math.sqrt(sum(x*x for x in self))\n    \n    def __neg__(self):\n        return Vector(-x for x in self)\n    \n    def __pos__(self):\n        return Vector(self)\n\n    def __invert__(self):\n        return Vector(-x-1 for x in self)\n3、x和+x不相等的情况\n算术运算上下文的精度变化可能导致 x 不等于 +x\nPython 3.4 为 Decimal 算术运算设定的默认精度是28，这里因为+x使用上下文的精度导致相等性判断返回False。\ncounter实例不含零值和负值计算器\n通过上面的实例能够看到counter实例ct经过零值和负值的赋值之后，再经过+x运算后发现ct实例中的非负数对象均消失了。事实上一元运算符 + 等同于加上一个空 Counter。当Counter相加时，Python解释器从实用性角度出发会把负值和零值的计数从结果中剔除。\n三、中缀运算符\n1、重载加法__add__\n现在我们仍以第10章的多维向量为例进行中缀运算符加号“+”的重载。重载加法的目标分析：\n\n\n当多维向量类是操作数时，多维向量应支持与同类向量的加法；\n\n同时多维向量类还应支持与可迭代对象的加法；\n\n此外当可迭代对象是操作数的时候，多维对象应具备__radd__如此来调用多维向量类中的__add__方法。\n\n重载加法的流程图设计：设计的重点在于采用鸭子类型思想。当多维向量类与非数值类相加时，多维向量类无法处理异类加法运算可以将加法运算交给右操作数的类处理。因为右操作数存在可以处理这种异类加法的可能。\n重载加法的代码实现：\nfrom itertools import zip_longest\nclass Vector:\n#排版需要省略中间代码\n    def __add__(self, other):\n        try:\n            return Vector(a+b for a,b in zip_longest(self,other,fillvalue=0))\n        except TypeError:\n            return NotImplemented\n    def __radd__(self, other):\n        return self+other\n2、重载乘法__mul__重载加法的目标分析：\n\n\n当多维向量类是操作数时，多维向量应支持与同类向量的乘法；\n\n同时多维向量类还应支持与可迭代对象的加法；\n\n此外当可迭代对象是操作数的时候，多维对象应具备__rmul__如此来调用多维向量类中的__mul__方法。\n\n注意：我们对多维向量重载的乘法是针对数论中的实数类型进行运算，此时可以采用白鹅类型显式检查对象的抽象基类是否为numbers.Real，代码实现如下：\nimport numbers \nclass Vector:\n#排版需要省略中间代码\n    def __mul__(self, other):\n        if isinstance(other,numbers.Real):\n                return Vector(x*other for x in self)\n        else:\n            return NotImplemented\n    def __rmul__(self, other):\n        return self*other\nTips:一般来说只有当处理与self不同类型的操作数时，需要创建反向方法处理。否则没有必要创建反向方法。\n四、比较运算符\nPython 解释器对众多比较运算符（==、 !=、 >、 <、 >=、 <=） 的处理与前文类似， 不过在两个方面有重大区别。\n\n正向和反向调用使用的是同一系列方法。这方面的规则如下表所示。例如，对 == 来说，正向和反向调用都是 _eq_ 方法，只是把参数对调了；而正向的 _gt_ 方法调用的是反向的 __lt__方法， 并把参数对调。\n对 == 和 != 来说，如果反向调用失败，Python 会比较对象的 ID，而不抛出 TypeError。\n\n\n1、重载等号__eq__\n现在我们仍以第10章的多维向量为例进行中缀运算符等号“=”的重载。重载等号的返回为True的条件：\n\n\n等号两端对象为同类对象；\n\n等号两端对象中的每个元素都必须对应相等。\n\n注意：若Vector处理等号不为True，应该返回NotImplemented交由Python处理。如果反向调用返回 NotImplemented，Python 会使用后备机制比较对象的 ID，作最后一搏。\n重载等号的代码实现如下：\nclass Vector:\n#排版需要省略中间代码\n    def __eq__(self, other):\n        if isinstance(other,Vector):\n            return len(self)==len(other) and all(x==y for x,y in zip(self,other))\n        else:\n            return NotImplemented\n2、了解object中__ne__的实现\ndef __ne__(self, other):\n    eq_result = self == other\n    if eq_result is NotImplemented:\n        return NotImplemented\n    else:\n        return not eq_result\n五、增量赋值运算符\n1、重载加等于__iadd__\n现在我们仍以第10章的多维向量为例进行中缀运算符加等于“+=”的重载。重载加等于设计要求：\n\n\n加等于右侧的对象与左侧的Vector类是同类对象或可迭代对象；\n\n否则抛出TypeError，显示无法进行加等于计算。\n\n下面以BingoCage的子类AddableBingoCage为例实现__iadd__，大家不必在意这个子类，重点在于理解__iadd__实现的思路：\nimport itertools \nfrom tombola import Tombola\nfrom bingo import BingoCage\nclass AddableBingoCage(BingoCage): \n    def __add__(self, other):\n        if isinstance(other, Tombola): \n            return AddableBingoCage(self.inspect() + other.inspect()) \n            #self.inspect()继承自BingoCage,返回当前元素组成的有序元组。\n        else:\n            return NotImplemented\n    def __iadd__(self, other):\n        if isinstance(other, Tombola):\n            other_iterable = other.inspect() \n        else:\n            try:\n                other_iterable = iter(other)\n            except TypeError: \n                self_cls = type(self).__name__\n                msg = \"right operand in += must be {!r} or an iterable\"\n                raise TypeError(msg.format(self_cls))\n        self.load(other_iterable) \n        return self \n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}