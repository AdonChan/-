{"title": "Python_基础 - MAY ", "index": "python3.x,python", "content": "Run\n源代码\nPython源代码的文件以\"py\"为扩展名，由Python程序解释，不需要编译\n命令：python 文件\n字节代码\nPython源文件经过编译后生成的扩展名为\"pyc\"的文件编译方法：\nimport py_compile\npy_compile.compile(\"url\") # url编译的文件的路径\n编译后的文件为：xxx.cpython-36.pyc\n优化代码\n经过优化的源文件，扩展名为\".pyo\"命令：pyhont -O -m py_comile 编译的文件\n编译后的文件为：xxx.cpython-36.opt-1.pyc\nType\nint, float, str, bool, NoneType\n\ntuple, list, dict, set\nLists\nlist = []\nlist[i:j]  # 返回列表的子集\nlist[-1]   # 访问的最后一个元素\nlist[:-1]  # 只返回最后一个元素\n\nlist[i] = val\nlist[i:j] = otherlist  # replace ith to jth element with otherlist\ndel list[i:j]\n\nlist.append(item)\nlist.extend(list)\nlist.insert(0, item)\nlist.pop()\nlist.remove(i)\nlist1 + list2     # 结合两个列表\nset(list)         # 从列表中删除重复元素\n\nlist.reverse()\nlist.count(item)\nsum(list)\n\nlist.sort()\n\nzip(list1, list2)\nsorted(list)\n\",\".join(list)\nDict\ndict.keys()\ndict.values()\n\"key\" in dict\ndict[\"key\"]   # throws KeyError\ndict.get(\"key\")\ndict.setdefault(\"key\", 1)\nIteration\nfor item in [\"a\", \"b\", \"c\"]:\nfor i in range(4):     # 0 到 3\nfor i in range(4, 8):  # 4 到 7\nfor key, val in dict.items():\nString\nstr[0:4]\nlen(str)\n\nstring.replace(\"-\", \" \")\n\",\".join(list)\n\"hi {0}\".format('j')\nstr.find(\",\")\nstr.index(\",\") \nstr.count(\",\")\nstr.split(\",\")\n\nstr.lower()\nstr.upper()\nstr.title()\n\nstr.lstrip()\nstr.rstrip()\nstr.strip()\n\nstr.islower()\n\nlen() # 求序列长度\n+ # 连接2个序列\n* # 重复序列元素\nin # 判断元素是否在序列中\nmax() # 返回最大值\nmin() # 返回最小值\nSet\n集合Set于列表，元组类似，可以存储多个数据，但是，这些数据是不重复的。\n集合对象支持union(联合), intersection(交集), difference(差集)和sysmmetric_difference(对称差集)等数学运算\n>>> x = set('abcd')\n>>> x\n{'c', 'a', 'b', 'd'}\n>>> type(x)\n<class 'set'>\n>>> y = set(['h','e','l','l','o'])\n>>> y\n{'h', 'e', 'o', 'l'}\n>>> z = set('spam')\n>>> z\n{'s', 'a', 'm', 'p'}\n>>> y&z # 交集\nset()\n>>> x&z # 交集\n{'a'}\n>>> x|y # 并集\n{'a', 'e', 'd', 'l', 'c', 'h', 'o', 'b'}\n>>> x-y # 差集\n{'c', 'a', 'b', 'd'}\n>>> x^z # 对称差集(在x或z中，但不会同时出现在二者中)\n{'m', 'd', 's', 'c', 'b', 'p'}\nCasting\nint(str)\nfloat(str)\nstr(int)\nstr(float)\nbool(1)\nComprehensions\n[fn(i) for i in list]            # .map\nmap(fn, list)                    # .map, 返回的迭代\n\nfilter(fn, list)                 # .filter, 返回的迭代\n[fn(i) for i in list if i > 0]   # .filter.map\nRegex\nimport re\n\nre.match(r'^[aeiou]', str)\nre.sub(r'^[aeiou]', '?', str)\nre.sub(r'(xyz)', r'\\1', str)\n\nexpr = re.compile(r'^...$')\nexpr.match(...)\nexpr.sub(...)\nFunction\n定义函数\n使用关键字:def。 依次写出函数名, 括号, 参数, 语句结束符 :。然后，在缩进块中编写函数体，函数的返回值用return语句返回\ndef my_abs (x):\n    if x >= 0:\n        return x\n    else:\n        return -x    \n空函数\n定义一个什么也不做的空函数，使用pass语句\ndef nop ()\n    pass\n空函数的作用：提供占位符\n参数\n默认参数一定要用不可变对象(基本变量类型和tuple), 如果是可变对象，程序运行时会有逻辑错误。\n定义可变参数和关键字参数的使用：\n\n\n*args是可变参数，args接收的是一个tuple\n\n\n**kw是关键字参数，kw接收的是一个dict\n\n\n调用函数时如何传入可变参数和关键字参数：\n\n可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过*args传入：func(*(1, 2, 3))；\n关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过**kw传入：func(**{'a': 1, 'b': 2})。\n\n使用*args和**kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。\n命名的关键字参数作用：为了限制调用者可以传入的参数名，同时可以提供默认值。\n定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数\n返回值\n函数执行完毕也没有return语句时，自动return None函数可以同时返回多个值，但其实就是一个tuple\n匿名函数\nlamdba 参数:函数体\n匿名函数自动具有返回值\nCharacteristic\n\n区分大小写\n语句结尾使用:\n\n\nTab符\n\nif的各种假\nFlase: '', None, 0, [], {}, Flase\n\n==与is\n\nis是比较两个引用是否指向了同一个对象(引用比较)==是比较两个对象是否相等\na = 2\nb = 2\n\na is b # True, 为True的原因是[-5, 256]\n\nc = 500\nd = 500\nc is d # False\npython解释器为了优化速度，会把[-5, 256]之间的数据提前存放到小整数对象池中，程序中要使用到[-5, 256]之间范围的数据，就不会重新创建一份，都是指向对象池中的同一份数据，除了这个区间之外的数据，每次使用时解释器都会重新申请一块内存，用来存储数据。\n深拷贝和浅拷贝\n浅拷贝：对于一个对象的顶层拷贝(拷贝了引用，并没有拷贝内容)深拷贝：重新申请内存存储复制的数据.\nimport copy\na = [1, 2, 3]\n\nb = a # 浅拷贝\nc = copy.deepcopy(a) # 深拷贝\n区别copy和deepcopy:deepcopy：所有的内容都重新申请内存，依次拷贝copy: 外层重新申请内存\n拷贝元组的特点：都是相同引用地址(元组是不可变类型,拷贝之后还是相同地址)\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}