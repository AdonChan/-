{"title": "Redis-py官方文档翻译 - 倚楼听风雨 ", "index": "redis,python", "content": "官网：https://github.com/andymccurd...当前版本：2.10.5注：这不是完整翻译，只提取了关键信息。省略了部分内容，如lua脚本支持。\npip install redis\npip install hiredis（解析器，可选。windows下好像不行。）\n\n>>> import redis\n>>> r = redis.StrictRedis(host='localhost', port=6379, db=0)\n>>> r.set('foo', 'bar')\nTrue\n>>> r.get('foo')\n'bar'\n\nredis-py采取两种client class实现redis命令：其一、StrictRedis类尽量坚持官方语法，但是以下除外：\n\nSELECT: 没有实现，应该是线程安全的原因。\nDEL: 由于del是python语法关键字，所用delete来代替。\nCONFIG GET|SET: 分开用 config_get or config_set来代替\nMULTI/EXEC: 事务作为Pipeline类的其中一部分的实现。Pipeline默认保证了MULTI,EXEC声明。但是你可以指定transaction=False来禁用这一行为。\nSUBSCRIBE/LISTEN:PubSub作为一个独立的类来实现发布订阅机制。\nSCAN/SSCAN/HSCAN/ZSCAN:每个命令都对应一个等价的迭代器方法scan_iter/sscan_iter/hscan_iter/zscan_iter methods for this behavior.\n\n其二、Redis类是StrictRedis的子类，提供redis-py版本向后的兼容性。\n关于StrictRedis与Redis的区别：(官方推荐使用StrictRedis.)以下几个方法在StrictRedis和Redis类中的参数顺序不同。LREM: Order of 'num' and 'value' arguments reversed such that 'num' can provide a default value of zero.在Redis类中是这样的：lrem(self, name, value, num=0)在StrictRedis类中是这样的：lrem(self, name, count, value)\nZADD: Redis specifies the 'score' argument before 'value'. These were swapped accidentally when being implemented and not discovered until after people were already using it. The Redis class expects *args in the form of: name1, score1, name2, score2, ...在Redis类中是这样的：redis.zadd('my-key', 'name1', 1.1, 'name2', 2.2, name3=3.3, name4=4.4)在StrictRedis中是这样的：redis.zadd('my-key', 1.1, 'name1', 2.2, 'name2', name3=3.3, name4=4.4)\nSETEX: Order of 'time' and 'value' arguments reversed.在Redis类中是这样的：setex(self, name, value, time)而在StrictRedis中是这样的：setex(self, name, time, value)\n连接池\n>>> pool = redis.ConnectionPool(host='localhost', port=6379, db=0)\n>>> r = redis.Redis(connection_pool=pool)\n\nConnections：redis-py提供两种类型的连接：基于TCP端口的，基于Unix socket文件的（需要redis服务器开启配置）。\n>>> r = redis.Redis(unix_socket_path='/tmp/redis.sock')\n\n如果你需要，自定义连接类，需要告知连接池。\n>>> pool = redis.ConnectionPool(connection_class=YourConnectionClass,\n                                your_arg='...', ...)\n\n释放连接回到连接池：可以使用Redis类的reset()方法，或者使用with上下文管理语法。\n解析器：解析器控制如何解析Redis-server的响应内容，redis-py提供两种方式的解析器类支持：PythonParser和HiredisParser(需要单独安装)。它优先选用HiredisParser,如果不存在，则选用PythonParser. Hiredis是redis核心团队开发的一个高性能c库，能够提高10x的解析速度。\n响应回调：The client class使用一系列的callbacks来完成响应到对应python类型的映射。这些响应回调，定义在 Redis client class中的RESPONSE_CALLBACKS字典中。你可以使用set_response_callback 方法来添加自定义回调类。这个方法接受两个参数：一个命令名字，一个回调类。回调类接受至少一个参数：响应内容，关键字参数作为命令调用时的参数。\n线程安全性：\nRedis client instances是线程安全的。由于线程安全原因，不提供select实现，因为它会导致数据库的切换。在不同线程间传递PubSub or Pipeline对象也是不安全的。\nPipelines\nPipelines是Redis类的一个子类，支持缓存多个命令，然后作为单个请求发送。通过减少TCP请求次数来达到提供性能的目的。\n>>> r = redis.Redis(...)\n>>> r.set('bing', 'baz')\n>>> # Use the pipeline() method to create a pipeline instance\n>>> pipe = r.pipeline()\n>>> # The following SET commands are buffered\n>>> pipe.set('foo', 'bar')\n>>> pipe.get('bing')\n>>> # the EXECUTE call sends all buffered commands to the server, returning\n>>> # a list of responses, one for each command.\n>>> pipe.execute()\n[True, 'baz']\n\nPipelines的实现采用流式API，故而你可以采用以下链式调用的方式：\n>>> pipe.set('foo', 'bar').sadd('faz', 'baz').incr('auto_number').execute()\n[True, True, 6]\n\nPipelines默认以原子性(事务)的形式执行所有缓存的命令,你也可以禁用这一行为：\n>>> pipe = r.pipeline(transaction=False)\n\nWATCH命令提供了在事务之前检测一个或多个key值的变化。一旦在事务执行之前，某个值发生了变化，那么事务将被取消然后抛出WatchError 异常。利用watch我们可以实现client-side incr命令：\n>>> with r.pipeline() as pipe:\n...     while 1:\n...         try:\n...             # put a WATCH on the key that holds our sequence value\n...             pipe.watch('OUR-SEQUENCE-KEY')\n...             # after WATCHing, the pipeline is put into immediate execution\n...             # mode until we tell it to start buffering commands again.\n...             # this allows us to get the current value of our sequence\n...             current_value = pipe.get('OUR-SEQUENCE-KEY')\n...             next_value = int(current_value) + 1\n...             # now we can put the pipeline back into buffered mode with MULTI\n...             pipe.multi()\n...             pipe.set('OUR-SEQUENCE-KEY', next_value)\n...             # and finally, execute the pipeline (the set command)\n...             pipe.execute()\n...             # if a WatchError wasn't raised during execution, everything\n...             # we just did happened atomically.\n...             break\n...        except WatchError:\n...             # another client must have changed 'OUR-SEQUENCE-KEY' between\n...             # the time we started WATCHing it and the pipeline's execution.\n...             # our best bet is to just retry.\n...             continue\n\n不过你可以使用transaction方法来简化这一操作：它包含handling and retrying watch errors的样板代码。第一参数为callable(这个callable只能接受一个Pipeline参数),及多个需要被WATCH的keys\n>>> def client_side_incr(pipe):\n...     current_value = pipe.get('OUR-SEQUENCE-KEY')\n...     next_value = int(current_value) + 1\n...     pipe.multi()\n...     pipe.set('OUR-SEQUENCE-KEY', next_value)\n>>>\n>>> r.transaction(client_side_incr, 'OUR-SEQUENCE-KEY')\n[True]\n\nPublish / Subscribe\nPubSub对象subscribes to channels and listens for new messages。\n>>> r = redis.StrictRedis(...)\n>>> p = r.pubsub()\n\n>>> p.subscribe('my-first-channel', 'my-second-channel', ...)\n>>> p.psubscribe('my-*', ...)\n\n>>> p.get_message()\n{'pattern': None, 'type': 'subscribe', 'channel': 'my-second-channel', 'data': 1L}\n>>> p.get_message()\n{'pattern': None, 'type': 'subscribe', 'channel': 'my-first-channel', 'data': 2L}\n>>> p.get_message()\n{'pattern': None, 'type': 'psubscribe', 'channel': 'my-*', 'data': 3L}\n\n通过PubSub获取消息时返回的是一个字典，字典key有如下几个：type:其中一个， 'subscribe', 'unsubscribe', 'psubscribe', 'punsubscribe', 'message', 'pmessage'channel: The channel [un]subscribed to or the channel a message was published topattern: The pattern that matched a published message's channel. Will be None in all cases except for 'pmessage' types.data: The message data. With [un]subscribe messages, this value will be the number of channels and patterns the connection is currently subscribed to. With [p]message messages, this value will be the actual published message.现在来发布消息：\n# the publish method returns the number matching channel and pattern\n# subscriptions. 'my-first-channel' matches both the 'my-first-channel'\n# subscription and the 'my-*' pattern subscription, so this message will\n# be delivered to 2 channels/patterns\n>>> r.publish('my-first-channel', 'some data')\n2\n>>> p.get_message()\n{'channel': 'my-first-channel', 'data': 'some data', 'pattern': None, 'type': 'message'}\n>>> p.get_message()\n{'channel': 'my-first-channel', 'data': 'some data', 'pattern': 'my-*', 'type': 'pmessage'}\n\n取消订阅：如果没有传递任何参数，那么这个PubSub订阅的所有的channels or patterns都会被取消。\n>>> p.unsubscribe()\n>>> p.punsubscribe('my-*')\n>>> p.get_message()\n{'channel': 'my-second-channel', 'data': 2L, 'pattern': None, 'type': 'unsubscribe'}\n>>> p.get_message()\n{'channel': 'my-first-channel', 'data': 1L, 'pattern': None, 'type': 'unsubscribe'}\n>>> p.get_message()\n{'channel': 'my-*', 'data': 0L, 'pattern': None, 'type': 'punsubscribe'}\n\n回调的方式处理发布的消息\nredis-py还允许你通过回调的方式处理发布的消息。Message handlers接受一个参数，the message,是一个字典对象。just like the examples above. 以回调形式订阅：subscribe接受关键字参数，键为channels or patterns,值为回调函数。\n>>> def my_handler(message):\n...     print 'MY HANDLER: ', message['data']\n>>> p.subscribe(**{'my-channel': my_handler})\n\n在你注册了回调处理的情况下， get_message()会返回None。\n默认情况下除了发布消息之外，还会传递 subscribe/unsubscribe成功的确认消息，如果你不想接收它们：ignore_subscribe_messages=True\n>>> p = r.pubsub(ignore_subscribe_messages=True)\n>>> p.subscribe('my-channel')\n>>> p.get_message()  # hides the subscribe message and returns None\n>>> r.publish('my-channel')\n1\n>>> p.get_message()\n{'channel': 'my-channel', 'data': 'my data', 'pattern': None, 'type': 'message'}\n\n三种读取消息的方式\n第一种：无限循环通过PubSub对象的get_message()读取消息\n>>> while True:\n>>>     message = p.get_message()\n>>>     if message:\n>>>         # do something with the message\n>>>     time.sleep(0.001)  # be nice to the system :)\n\n第二种，通过阻塞方法listen()来读取：p.listen()返回一个generator，阻塞直到有消息可获取。\n>>> for message in p.listen():\n...     # do something with the message\n\n第三种，开启一个事件循环线程pubsub.run_in_thread()方法 creates a new thread and starts the event loop. 并返回线程对象。但是需要注意的是：如果你没有注册消息处理函数，那么调用run_in_thread()将会抛出异常redis.exceptions.PubSubError\n>>> p.subscribe(**{'my-channel': my_handler})\n>>> thread = p.run_in_thread(sleep_time=0.001)\n# the event loop is now running in the background processing messages\n# when it's time to shut it down...\n>>> thread.stop()\n\n关于字符编码：\n默认情况下，publish的消息会被编码，当你获取消息时得到的是编码后的字节，如果你需要它自动解码，创建Redis client实例时需要指定decode_responses=True,(译者注：不建议使用该选项，因为当存在pickle序列化的值时，client.get(key)时会出现解码失败的错误UnicodeDecodeError)\n关闭释放资源：\nPubSub.close() method to shutdown the connection.\n>>> p = r.pubsub()\n>>> ...\n>>> p.close()\n\nLUA Scripting支持：\n略。\nSentinel support与节点发现：\nRedis Sentinel用于发现Redis节点。请确保至少一个Sentinel daemon 进程在运行。你可以使用Sentinel connection to discover the master and slaves network addresses:\n>>> from redis.sentinel import Sentinel\n>>> sentinel = Sentinel([('localhost', 26379)], socket_timeout=0.1)\n>>> sentinel.discover_master('mymaster')\n('127.0.0.1', 6379)\n>>> sentinel.discover_slaves('mymaster')\n[('127.0.0.1', 6380)]\n\n>>> master = sentinel.master_for('mymaster', socket_timeout=0.1)\n>>> slave = sentinel.slave_for('mymaster', socket_timeout=0.1)\n>>> master.set('foo', 'bar')\n>>> slave.get('foo')\n'bar'\n\n上面的master and slave对象就是一个普通的StrictRedis对象实例。如果Sentinel配置了连接池的话，它们还会使用这个连接池。可能抛出的异常：MasterNotFoundError ，SlaveNotFoundError 它们都是ConnectionError的子类\nScan Iterators\nRedis 2.8之后有了*SCAN命令。redis-py also exposes the following methods that return Python iterators for convenience: scan_iter, hscan_iter, sscan_iter and zscan_iter.\n>>> for key, value in (('A', '1'), ('B', '2'), ('C', '3')):\n...     r.set(key, value)\n>>> for key in r.scan_iter():\n...     print key, r.get(key)\nA 1\nB 2\nC 3\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "2"}