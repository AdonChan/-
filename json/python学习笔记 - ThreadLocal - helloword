{"title": "python学习笔记 - ThreadLocal - helloword ", "index": "python", "content": "我们在编写多线程程序的时候，往往会遇到两种类型的变量。\n\n一种是全局变量，多个线程共享。为了避免改乱为，我们在前面已经提到说要加锁。\n一种是局部变量。仅供一个线程使用，线程间相互不影响。\n\n例如下列程序中task()函数中定义的count变量就是局部变量。即使我们创建了两个线程，两者的count递增也不会相互影响，因为count是在task中定义的。\nimport threading\n\n\ndef task():\n    count = 0\n    for i in range(1000):\n        count += 1\n        print count\n\n\nif __name__ == '__main__':\n    t1 = threading.Thread(target=task)\n    t1.start()\n    t2 = threading.Thread(target=task)\n    t2.start()\n\n那么，这么处理是不是就完美了呢？其实还不是。以上的例子我们举的是一个非常简单的例子，但是我们遇到一个比较复杂的业务逻辑的时候，比如多个局部变量，函数多重调用等，这么定义局部变量就会变得不简洁，麻烦。函数多重调用是指，例如：我们定义了函数，methodA(),这个方法体内调用了methodB(), methodB()方法体中又调用了methodC()...如果我们在某一个线程中调用了methodA()并且使用了一个变量attr，那么我们就需要将attr一层一层地传递给后续的函数。\n有没有一种方法，能让我们在线程中定义一个变量后，那么这个线程中的函数就都能调用，如此才叫简洁明了？Python为我们做到了，那就是ThreadLocal.ThreadLocal的用法只需要三步：\n\n定义一个对象 threading.local\n在线程内给该对象绑定参数。所有绑定的参数都是线程隔离的。\n在线程内调用。\n\n下面展示一下代码：\n# coding=utf-8\nimport threading\n\nlocal = threading.local() # 创建一个全局的对象\n\n\ndef task():\n    local.count = 0  # 初始化一个线程内变量，该变量线程间互不影响。\n    for i in range(1000):\n        count_plus()\n\n\ndef count_plus():\n    local.count += 1\n    print threading.current_thread().name, local.count\n\n\nif __name__ == '__main__':\n    t1 = threading.Thread(target=task)\n    t1.start()\n    t2 = threading.Thread(target=task)\n    t2.start()\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}