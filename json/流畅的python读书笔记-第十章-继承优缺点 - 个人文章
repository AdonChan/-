{"title": "流畅的python读书笔记-第十章-继承优缺点 - 个人文章 ", "index": "python", "content": "继承的优缺点\n推出继承的初衷是让新手顺利使用只有专家才能设计出来的框架。——Alan Kay\n子类化内置类型很麻烦 (如 list 或 dict）) ,别搞这种\n\n直接子类化内置类型（如 dict、list 或 str）容易出错，因为内置类型的 方法通常会忽略用户覆盖的方法。\n不要子类化内置类型，用户自己定义的类应该继承 collections 模块的类，\n例如UserDict、UserList 和 UserString，这些类做了特殊设计，因此易于扩展。\n\nimport collections\n\nclass DoppelDict2(collections.UserDict):\n    def __setitem__(self, key, value):\n        super().__setitem__(key, [value] * 2)\n\ndd = DoppelDict2(one=1)\nprint(dd)\n\n\ndd['two'] = 2\nprint(dd)\n\n\ndd.update(three=3)\nprint(dd)\n\n\n\n\nclass AnswerDict2(collections.UserDict):\n    def __getitem__(self, key):\n        return 42\n\nad = AnswerDict2(a='foo')\n\nprint(ad[\"a\"])\n\n\n\n\n综上，本节所述的问题只发生在 C 语言实现的内置类型内部的方法委托上，而且只影响 直接继承内置类型的用户自定义类。\n如果子类化使用 Python 编写的类，如 UserDict 或 MutableMapping，就不会受此影响。\n\n多重继承和方法解析顺序\nclass A:\n    def ping(self):\n        print('ping:', self)\n\n\nclass B(A):\n    def pong(self):\n        print('pong:', self)\n\n\nclass C(A):\n    def pong(self):\n        print('PONG:', self)\n\n\nclass D(B, C):\n    def ping(self):\n        super().ping()\n        print('post-ping:', self)\n\n    def pingpong(self):\n        self.ping()\n        super().ping()\n        self.pong()\n        super().pong()\n        C.pong(self)\n\n\nd = D()\nd.pong()\n\nC.pong(d)\n\n#看继承关系\nprint(D.__mro__)\n\n直接调用 d.pong() 运行的是 B 类中的版本。\nPython 能区分 d.pong() 调用的是哪个方法，是因为 Python 会按照特定的顺序遍历继承图。这个顺序叫方法解析顺序（Method Resolution Order，MRO）。类都有一个名为__mro__ 的属性，它的值是一个元组，按照方法解析顺序列出各个超类，从当前类一直向上，直到 object 类。D\n然而，使用 super() 最安全，也不易过时。调用框架或不受自己控制的类层次结构中的方法时，尤其适合使用 super()。\n多重继承的真实应用\n1 多重继承能发挥积极作用。2 《设计模式：可复用面向对象软件的基础》一书中的适配器模式用的就是多重继承，因此使用多重继承肯定没有错3（那本书中的其他 22 个设计模式都使用单继承，因此多重继承显然不是灵丹妙药）\n处理多重继承\n下面是避免把类图搅乱的一些建议。\n01. 把接口继承和实现继承区分开\n使用多重继承时，一定要明确一开始为什么创建子类。主要原因可能有：\n继承接口，创建子类型，实现“是什么”关系继承实现，通过重用避免代码重复\n其实这两条经常同时出现，不过只要可能，一定要明确意图。通过继承重用代码是实现细节，通常可以换用组合和委托模式。而接口继承则是框架的支柱。\n02. 使用抽象基类显式表示接口\n现代的 Python 中，如果类的作用是定义接口，应该明确把它定义为抽象基类。Python3.4 及以上的版本中，我们要创建 abc.ABC 或其他抽象基类的子类\npython没有interface这种定义\n03. 通过混入重用代码\n\n一个类的作用是为多个不相关的子类提供方法实现\n应该把那个类明确地定义为混入类（mixin class）\n从概念上讲，混入不定义新类型，只是打包方法，便于重用。\n混入类绝对不能实例化，而且具体类不能只继承混入类。\n混入类应该提供某方面的特定行为，只实现少量关系非常紧密的方法。\n\n04. 在名称中明确指明混入\n\n因为在 Python 中没有把类声明为混入的正规方式，所以强烈推荐在名称中加入...Mixin 后缀。\nTkinter 没有采纳这个建议，如果采纳的话，XView 会变成XViewMixin，Pack 会变成 PackMixin\n\n05. 为用户提供聚合类\nclass Widget(BaseWidget, Pack, Place, Grid):\n \"\"\"Internal class.\n Base class for a widget which can be positioned with the\n geometry managers Pack, Place or Grid.\"\"\"\n pass\nWidget 类的定义体是空的，但是这个类提供了有用的服务：\n把四个超类结合在一起，这样需要创建新小组件的用户无需记住全部混入，也不用担心声明 class 语句时有没有遵守特定的顺序。\n08. “优先使用对象组合，而不是类继承”\n这句话引自《设计模式：可复用面向对象软件的基础》一书， 这是我能提供的最佳建议。\n熟悉继承之后，就太容易过度使用它了。出于对秩序的诉求，我们喜欢按整洁的层次结构放置物品，程序员更是乐此不疲。\n即便是单继承，这个原则也能提升灵活性，因为子类化是一种紧耦合，而且较高的继承树容易倒。\n继承在Django的应用\npage 417 这里有些复杂,等我牛掰了再来看\n总结\ncollections.abc 模块中相应的抽象基类多重继承这把双刃剑。首先，我们说明了 mro 类属性中蕴藏的方法解析顺序，有了这一机制，继承方法的名称不再会发生冲突不要子类化内置类型，用户自己定义的类应该继承 collections 模块的类\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}