{"title": "量化交易之股票买卖因子——N日趋势突破 - Python量化交易 ", "index": "python", "content": "前言\n《海龟交易法则》是量化经典书籍中的经典作品，其中介绍了一种N日趋势突破策略，即当天收盘价超过N1天内最高价认为上升趋势成立，作为买入信号；当天收盘价低于N2天内最低价格认为下跌趋势成立，作为卖出信号。\n通俗的说，N日趋势突破买入即为N日创新高买入，股价创出阶段性新高或历史新高后，一方面说明该股有资金在运作，相对比较强势，更容易顺势而上，另一方面创新高后近期买入的投资者都有获利，上档的套牢盘比较少，股价上冲的阻力也较小，更容易继续上涨。反之N日趋势跌破卖出亦然。\n\nN日参数选取\n此处侧重中短线操作，选择N1参数为22天，N2参数为11天，N1大于N2的原因是为了打造一个非均衡胜负收益及非均衡胜负比例环境，因为量化的目标即是要赢钱比亏钱要多。\n\n策略实现\n（1）计算N1日最高值。由于需要从第N1天开始计算最大价格值，因此前N1个数值都为nan。此处从收盘价序列第一个数据开始依次寻找目前出现过的最大值填充前N1个nan。N2日最低值计算类似。\nstock_df['N1_High'] = pd.rolling_max(stock_df.High,window=N1)#计算最近N1个交易日最高价      \nexpan_max = pd.expanding_max(stock_df.Close)\nstock_df['N1_High'].fillna(value=expan_max,inplace=True)\n\nstock_df['N2_Low'] = pd.rolling_max(stock_df.Low,window=N2)#计算最近N2个交易日最低价      \nexpan_min = pd.expanding_max(stock_df.Close)\nstock_df['N2_Low'].fillna(value=expan_min,inplace=True)#目前出现过的最小值填充前N2个nan\n\n（2）根据突破定义构建买卖信号。当天的收盘价超过N1天内最高价作为买入信号买入股票。当天的收盘价超过N2天内最低价作为卖出信号卖出股票。shift(1)的目的是获取昨天为止的最高价格。寻找符合买入条件的时间序列buy_index，构建signal序列将买入当天的signal值设置为1，代表买入。同理卖出信号将signal设置为0。\n\"\"\" 收盘价超过N1最高价 买入股票持有\"\"\"\nbuy_index = stock_df[stock_df.Close > stock_df.N1_High.shift(1)].index\nstock_df.loc[buy_index,'signal'] = 1  \n\"\"\" 收盘价超过N2最低价 卖出股票持有\"\"\"\nsell_index = stock_df[stock_df.Close < stock_df.N2_Low.shift(1)].index\nstock_df.loc[sell_index,'signal'] = 0\n\n注：上述添加的新列signal代表信号将要触发的操作，一旦信号触发则全仓操作，第一个信号成交后，由于全仓买入或全仓卖出，即使后续仍有信号发出也不执行，因此连续的信号只有第一个有实际的操作意义。\n（3）将操作信号转化为持股状态，即1代表买入持有，0代表卖出空仓，得到keep序列。由于收盘价格在收盘后确定，第二天执行操作信号，shift(1)更接近真实情况。keep序列含有nan值，此时可理解为一旦状态被设置为1（买入持有），只有遇到0（卖出空仓）时keep状态才会改变，因此fillna将所有nan值与前面元素值保持一致。\nstock_df['keep'] = stock_df.signal.shift(1)\nstock_df['keep'].fillna(method = 'ffill',inplace = True)\n\n注：shift(1)是在index不变的情况下对序列的值向后移动一个单位。   \n（4）计算基准收益与使用策略收益进行对比。基准收益为时间序列第一天开始持有股票直到时间序列最后一天的收益情况。Keep可理解为01的滤波器，与基准收益相乘可过滤掉Keep为0的收益，即空仓保持资金，同时可获取keep为1的收益。\n\"\"\" 计算基准收益 \"\"\"\nstock_df['benchmark_profit'] = np.log(stock_df.Close/stock_df.Close.shift(1))\n\"\"\" 计算趋势突破策略收益 \"\"\"\nstock_df['trend_profit'] = stock_df.keep*stock_df.benchmark_profit  \n\n注：np.log计算的是对数收益率，公式原型为r = ln ( Cn/Cn-1 ) （Cn为今日收盘价，Cn-1为昨日收盘价），即求以e为底(Cn/Cn-1)的对数，对应的指数公式原型为Cn =Cn-1 e^r，公式推导由于平台对数学表达式格式兼容问题，可微信关注私信获取。*\n\n效果显示\n（1）对数收益率可线性叠加，因此将序列值累加形成基准收益曲线和策略收益曲线。Pandas整合了matplotlib的相关功能实现了基于DataFrame的一些作图功能，ax参数设置可选择图形显示的子图。\np1 = plt.subplot(2,1,2)\nstock_df[['benchmark_profit','trend_profit']].cumsum().plot(grid=True,ax = p1)\n\n（2）收益曲线显示。图1红色为盈利操作，绿色为亏损操作，实现可参考买卖区间图形化一章介绍。从图2中可以看出该策略避免了两次大幅下跌的时期（绿色框），在上涨期间获利并未最大化（红色框），整体应用策略的收益远远大于基准收益。\n注：示例并未考虑到风险因素、设定止损机制，并且也忽略了手续费，仅作为入门研究参考\n更多python量化交易内容互动请加微信公众号：PythonQT-YuanXiao\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "2"}