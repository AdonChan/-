{"title": "Python标准库学习之urllib - 倚楼听风雨 ", "index": "urllib,python", "content": "本系列以python3.4为基础urllib是Python3的标准网络请求库。包含了网络数据请求，处理cookie,改变请求头和用户代理，重定向，认证等的函数。urllib与urllib2?:python2.x用urllib2,而python3改名为urllib,被分成一些子模块：urllib.request,urllib.parse,urllib.error,urllib.robotparser.尽管函数名称大多和原来一样，但是使用新的urllib库时需要注意哪些函数被移动到子模块里了。\nHTTP版本：HTTP/1.1，包含Connection:close 头\n特别常用的函数:urllib.request.urlopen()\n同类型开源库推荐:requests\nurllib:用来处理网络请求和操作url。有以下子模块\n\nurllib.request 打开后读取url内容\nurllib.error 包含由urllib.request抛出的异常类\nurllib.parse 解析URL\nurllib.robotparser 解析robots.txt files\n\n简单的例子\nfrom urllib.request import urlopen\nhtml=urlopen('https://www.baidu.com')\nprint(html.geturl(),html.info(),html.getcode(),sep='\\n')\nprint(html.read().decode('UTF-8'))\n\nfrom urllib import request\nwith request.urlopen('https://api.douban.com/v2/book/2129650') as f:\n    data = f.read()\n    print('Status:', f.status, f.reason)\n    for k, v in f.getheaders():\n        print('%s: %s' % (k, v))\n    print('Data:', data.decode('utf-8'))\n\nfrom urllib import request\nreq = request.Request('http://www.douban.com/') #设置请求头\nreq.add_header('User-Agent', 'Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25')\nwith request.urlopen(req) as f:\n    print('Status:', f.status, f.reason)\n    for k, v in f.getheaders():\n        print('%s: %s' % (k, v))\n    print('Data:', f.read().decode('utf-8'))\nimport urllib.request\ndata = parse.urlencode([ #进行url编码参数\n    ('username', 'xby')]\nreq = urllib.request.Request(url='https://www.baidu.com',\n                     data=data)\nwith urllib.request.urlopen(req) as f:\n    print(f.read().decode('utf-8'))\nfrom urllib import request, parse\nprint('Login to weibo.cn...')\nemail = input('Email: ')\npasswd = input('Password: ')\nlogin_data = parse.urlencode([ #进行url编码参数\n    ('username', email),\n    ('password', passwd),\n    ('entry', 'mweibo'),\n    ('client_id', ''),\n    ('savestate', '1'),\n    ('ec', ''),\n    ('pagerefer', 'https://passport.weibo.cn/signin/welcome?entry=mweibo&r=http%3A%2F%2Fm.weibo.cn%2F')\n])\nreq = request.Request('https://passport.weibo.cn/sso/login') \nreq.add_header('Origin', 'https://passport.weibo.cn')\nreq.add_header('User-Agent', 'Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25')\nreq.add_header('Referer', 'https://passport.weibo.cn/signin/login?entry=mweibo&res=wel&wm=3349&r=http%3A%2F%2Fm.weibo.cn%2F')\nwith request.urlopen(req, data=login_data.encode('utf-8')) as f:\n    print('Status:', f.status, f.reason)\n    for k, v in f.getheaders():\n        print('%s: %s' % (k, v))\n    print('Data:', f.read().decode('utf-8'))\nurllib.request\nurllib.request.urlopen(url, data=None, [timeout, ]*, cafile=None, capath=None, cadefault=False, context=None)\n\n\nurl参数可以是字符串或者urllib.request.Request对象\ndata参数必须是字节形式。可以通过from urllib import parse parse.urlencode()来处理得到。如果没有提供dat参数则为GET请求，否则为POST请求。\n[tomeout,]超时单位为秒\ncontext参数必须是ssl.SSLContext的实例\n\n返回值：返回一个可以作为contextmanager的对象。它有一些方法和属性：geturl()info()-元数据信息，比如headersgetcode()-http响应码，比如200read()-获取内容，字节形式statusreason\n对于Http(s)请求，返回的一个http.client.HTTPResponse对象。常用方法getheaders(),read()对于ftp,file请求，返回一个urllib.response.addinfourl对象\n可能抛出的异常urllib.error.URLError,urllib.error.HTTPError\nclass urllib.request.Request(url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None) 通过这个对象我们可以设置请求数据，添加请求头，同时可以获取一些url信息：比如协议类型，主机。也可以设置代理Request.set_proxy(host, type)\nclass urllib.request.OpenerDirector以及关联的urllib.request.install_opener(opener),urllib.request.build_opener([handler, …]) 方法：OpenerDirector.add_handler(handler) ，这个handler对象必须继承urllib.request.BaseHandler，常见的有urllib.request.BaseHandler -基类urllib.request.HTTPDefaultErrorHandler urllib.request.HTTPRedirectHandler urllib.request.HTTPCookieProcessorurllib.request.ProxyHandlerurllib.request.HTTPBasicAuthHandlerurllib.request.HTTPSHandler例子：\nimport urllib.request\n# Create an OpenerDirector with support for Basic HTTP Authentication...\nauth_handler = urllib.request.HTTPBasicAuthHandler()\nauth_handler.add_password(realm='PDQ Application',\n                          uri='https://mahler:8092/site-updates.py',\n                          user='klem',\n                          passwd='kadidd!ehopper')\nopener = urllib.request.build_opener(auth_handler)\n# ...and install it globally so it can be used with urlopen.\nurllib.request.install_opener(opener)\nurllib.request.urlopen('http://www.example.com/login.html')\n\nproxy_handler = urllib.request.ProxyHandler({'http': 'http://www.example.com:3128/'})\nproxy_auth_handler = urllib.request.ProxyBasicAuthHandler()\nproxy_auth_handler.add_password('realm', 'host', 'username', 'password')\n \nopener = urllib.request.build_opener(proxy_handler, proxy_auth_handler)\n# This time, rather than install the OpenerDirector, we use it directly:\nopener.open('http://www.example.com/login.html')\n\n异常处理\n可能抛出的异常urllib.error.URLError,urllib.error.HTTPErrorexception urllib.error.URLError :有以下属性：reasonexception urllib.error.HTTPError 它是URLError的一个子类，有以下属性：codereasonheaders\nfrom urllib.request import Request, urlopen\nfrom urllib.error import URLError, HTTPError\nreq = Request(\"http://www.baidu.com/\")\ntry:\n    response = urlopen(req)\nexcept HTTPError as e:\n    print('Error code: ', e.code)\nexcept URLError as e:\n    print('We failed to reach a server.')\n    print('Reason: ', e.reason)\nelse:\n    print(\"good!\")\nprint(response.read().decode(\"utf8\"))\n\nurllib.parse\nurllib.parse.urlparse函数会将一个普通的url解析为6个部分，返回的数据类型为ParseResult对象，通过访问其属性可以获取对应的值。同时，它还可以将已经分解后的url再组合成一个url地址（通过urlunparse(parts)）。返回的6个部分，分别是：scheme(机制)、netloc(网络位置)、path(路径)、params(路径段参数)、query(查询)、fragment(片段)。\nurllib.parse.urlencode(query, doseq=False, safe=' ', encoding=None, errors=None),注意：query参数是一个序列对象\n通过urllib.request.urlretrieve下载文件\nurllib.request.urlretrieve(url,savefilepath)\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "6"}