{"title": "流畅的python读书笔记-第11章-接口：从协议到抽象基类 - 个人文章 ", "index": "python", "content": "抽象基类\n抽象基类的常见用途：\n\n实现接口时作为超类使用。\n然后，说明抽象基类如何检查具体子类是否符合接口定义，以及如何使用注册机制声明一个类实现了某个接口，而不进行子类化操作。\n如何让抽象基类自动“识别”任何符合接口的类——不进行子类化或注册。\n\n接口在动态类型语言中是怎么运作的呢？\n\n按照定义，受保护的属性和私有属性不在接口中：\n即便“受保护的”属性也只是采用命名约定实现的（单个前导下划线）\n私有属性可以轻松地访问（参见 9.7 节），原因也是如此。 不要违背这些约定。\n不要觉得把公开数据属性放入对象的接口中不妥，\n因为如果需要，总能实现读值方法和设值方法，把数据属性变成特性，使用 obj.attr 句法的客户代码不会受到影响。\n\nPython喜欢序列\n\n协议是接口，但不是正式的（只由文档和约定定义），\n因此协议不能像正式接口那样施加限制（本章后面会说明抽象基类对接口一致性的强制）。\n一个类可能只实现部分接口，这是允许的。\n\n看看示例 11-3 中的 Foo 类。它没有继承 abc.Sequence，而且只实现了序列协议的一个方法： getitem （没有实现 len 方法）\n定义 getitem 方法，只实现序列协议的一部分，这样足够访问元素、迭代和使用 in 运算符了\n>>> class Foo:\n... def __getitem__(self, pos):\n... return range(0, 30, 10)[pos]\n...\n>>> f = Foo()\n>>> f[1]\n10\n>>> for i in f: print(i)\n...\n0\n10\n20\n>>> 20 in f\nTrue\n>>> 15 in f\nFalse\n综上，鉴于序列协议的重要性，如果没有 iter 和 contains 方法，Python 会调用 getitem 方法，设法让迭代和 in 运算符可用。\n使用猴子补丁在运行时实现协议\nrandom.shuffle 函数打乱 FrenchDeck 实例\n为FrenchDeck 打猴子补丁，把它变成可变的，让 random.shuffle 函数能处理\ndef set_card(deck, position, card): ➊\n... deck._cards[position] = card\n>>> FrenchDeck.__setitem__ = set_card ➋\n>>> shuffle(deck) ➌\n>>> deck[:5]\n[Card(rank='3', suit='hearts'), Card(rank='4', suit='diamonds'), Card(rank='4',\nsuit='clubs'), Card(rank='7', suit='hearts'), Card(rank='9', suit='spades')]\n❶ 定义一个函数，它的参数为 deck、position 和 card。❷ 把那个函数赋值给 FrenchDeck 类的 setitem 属性。❸ 现在可以打乱 deck 了，因为 FrenchDeck 实现了可变序列协议所需的方法。\n这里的关键是，set_card 函数要知道 deck 对象有一个名为 _cards 的属性，而且_cards 的值必须是可变序列。然后，我们把 set_card 函数赋值给特殊方法__setitem__，从而把它依附到 FrenchDeck 类上。这种技术叫猴子补丁：在运行时修改类或模块，而不改动源码。\n协议是动态的\n\nrandom.shuffle 函数不关心参数的类型，只要那个对象实现了部分可变序列协议即可。\n即便对象一开始没有所需的方法也没关系，后来再提供也行\n\n抽象基类使用姿势\n有时，为了让抽象基类识别子类，甚至不用注册。其实，抽象基类的本质就是几个特殊方法。\n>>> class Struggle:\n... def __len__(self): return 23\n...\n>>> from collections import abc\n>>> isinstance(Struggle(), abc.Sized)\nTrue\n可以看出，无需注册，abc.Sized 也能把 Struggle 识别为自己的子类，只要实现了特殊方法 len 即可（要使用正确的句法和语义实现，前者要求没有参数，后者要求返回一个非负整数，指明对象的长度；\n作者建议\n如果实现的类体现了 numbers、collections.abc 或其他框架中抽象基类的概念，要么继承相应的抽象基类（必要时），要么把类注册到相应的抽象基类中。开始开发程序时，不要使用提供注册功能的库或框架，要自己动手注册\n一句话:1.要么继承基类2.要么自己把类注册到相应的抽象基类中 ,别使用自动注册\nisinstance 检查使用姿势\n然而，即便是抽象基类，也不能滥用 isinstance 检查，用得多了可能导致代码异味，即表明面向对象设计得不好。\n在一连串 if/elif/elif 中使用 isinstance 做检查，然后根据对象的类型执行不同的操作，通常是不好的做法；\n此时应该使用多态，即采用一定的方式定义类，让解释器把调用分派给正确的方法，而不使用 if/elif/elif 块硬编码分派逻辑。\n鸭子类型 和 类型检查\n在框架之外，鸭子类型通常比类型检查更简单，也更灵活。\n\n本书有几个示例要使用序列，把它当成列表处理。\n我没有检查参数的类型是不是list，而是直接接受参数，立即使用它构建一个列表。\n这样，我就可以接受任何可迭代对象；\n如果参数不是可迭代对象，调用立即失败，并且提供非常清晰的错误消息。\n\n一句话:看起来像鸭子(如序列),直接用序列的特性方法,(如果爆错就是类型不对),如果可以就是通过\n这种做法省去了,用isinstance 做检查的痛苦(有时不知道什么类型)\n标准库中的抽象基类急顺序  page 375  376\n定义并使用一个抽象基类\n重点来了\n想象一下这个场景：\n你要在网站或移动应用中显示随机广告，但是在整个广告清单轮转一遍之前，不重复显示广告。\n假设我们在构建一个广告管理框架，名为 ADAM。\n它的职责之一是，支持用户提供随机挑选的无重复类。 \n为了让 ADAM 的用户明确理解“随机挑选的无重复”组件是什么意思，我们将定义一个抽象基类。\n我将使用现实世界中的物品命名这个抽象基类：宾果机和彩票机是随机从有限的集合中挑选物品的机器，选出的物品没有重复，直到选完为止\nTombola 抽象基类有四个方法，其中两个是抽象方法。\n\n.load(...)：把元素放入容器。\n.pick()：从容器中随机拿出一个元素，返回选中的元素。\n\n另外两个是具体方法。\n\n.loaded()：如果容器中至少有一个元素，返回 True。\n.inspect()：返回一个有序元组，由容器中的现有元素构成，不会修改容器的内容 （内部的顺序不保留）。\n\n\n代码:\nimport abc\n\n\nclass Tombola(abc.ABC):\n    @abc.abstractmethod\n    def load(self, iterable):\n        \"\"\"从可迭代对象中添加元素。\"\"\"\n\n    @abc.abstractmethod\n    def pick(self):\n        \"\"\"随机删除元素，然后将其返回。\n        如果实例为空，这个方法应该抛出`LookupError`。\n        \"\"\"\n\n    def loaded(self):\n        \"\"\"如果至少有一个元素，返回`True`，否则返回`False`。\"\"\"\n        return bool(self.inspect())\n\n    def inspect(self):\n        \"\"\"返回一个有序元组，由当前元素构成。\"\"\"\n        items = []\n        while True:\n            try:\n                items.append(self.pick())\n            except LookupError:\n                break\n        self.load(items)\n        return tuple(sorted(items))\n\n\n\n自己定义的抽象基类要继承 abc.ABC。根据文档字符串，如果没有元素可选，应该抛出 LookupError。❹ 抽象基类可以包含具体方法。❻ 我们不知道具体子类如何存储元素，不过为了得到 inspect 的结果，我们可以不断调用 .pick() 方法，把 Tombola 清空……❼ ……然后再使用 .load(...) 把所有元素放回去。\n其实，抽象方法可以有实现代码。即便实现了，子类也必须覆盖抽象方法，但是在子类中可以使用 super() 函数调用抽象方法，为它添加功能，而不是从头开始实现。\n定义Tombola抽象基类的子类\nBingoCage 类是在示例 5-8 的基础上修改的，使用了更好的随机发生器。BingoCage 实现了所需的抽象方法 load 和 pick，从 Tombola 中继承了 loaded 方法，覆盖了 inspect 方法，还增加了 call 方法。\nimport abc\n\n\nclass Tombola(abc.ABC):\n    @abc.abstractmethod\n    def load(self, iterable):\n        \"\"\"从可迭代对象中添加元素。\"\"\"\n\n    @abc.abstractmethod\n    def pick(self):\n        \"\"\"随机删除元素，然后将其返回。\n        如果实例为空，这个方法应该抛出`LookupError`。\n        \"\"\"\n\n    def loaded(self):\n        \"\"\"如果至少有一个元素，返回`True`，否则返回`False`。\"\"\"\n        return bool(self.inspect())\n\n    def inspect(self):\n        \"\"\"返回一个有序元组，由当前元素构成。\"\"\"\n        items = []\n        while True:\n            try:\n                items.append(self.pick())\n            except LookupError:\n                break\n        self.load(items)\n        return tuple(sorted(items))\n\n\nimport random\n\nclass BingoCage(Tombola):\n    def __init__(self, items):\n        self._randomizer = random.SystemRandom()\n        self._items = []\n        self.load(items)\n\n    def load(self, items):\n        self._items.extend(items)\n        self._randomizer.shuffle(self._items)\n\n    def pick(self):\n        try:\n            return self._items.pop()\n        except IndexError:\n            raise LookupError('pick from empty BingoCage')\n\n    def __call__(self):\n        self.pick()\n\n❹ 没有使用 random.shuffle() 函数，而是使用 SystemRandom 实例的 .shuffle() 方法。这里想表达的观点是：我们可以偷懒，直接从抽象基类中继承不是那么理想的具体方法。\n从 Tombola 中继承的方法没有BingoCage 自己定义的那么快，不过只要 Tombola 的子类正确实现 pick 和 load 方法，就能提供正确的结果。\nLotteryBlower 打乱“数字球”后没有取出最后一个，而是取出一个随机位置上的\n球。\n❷ 如果范围为空，random.randrange(...) 函数抛出 ValueError，为了兼容Tombola，我们捕获它，抛出 LookupError。\n❹ 覆盖 loaded 方法，避免调用 inspect 方法（示例 11-9 中的 Tombola.loaded 方法是这么做的）。我们可以直接处理 self._balls 而不必构建整个有序元组，从而提升速度。\n有个习惯做法值得指出：\n\n在 init 方法中，self._balls 保存的是list(iterable)，而不是 iterable 的引用（即没有直接把iterable 赋值给self._balls）。\n前面说过， 这样做使得 LotteryBlower 更灵活，因为 iterable 参数可以是任何可迭代的类型。\n把元素存入列表中还确保能取出元素。\n就算 iterable 参数始终传入列表，list(iterable)  会创建参数的副本，这依然是好的做法，因为我们要从中删除元素，而客户可能不希望自己提供的列表被修改。\n\nTombola的虚拟子类\n\n注册虚拟子类的方式是在抽象基类上调用 register 方法。这么做之后，注册的类会变成抽象基类的虚拟子类，\n而且 issubclass 和 isinstance 等函数都能识别，但是注册的类不会从抽象基类中继承任何方法或属性。\n\n3.虚拟子类不会继承注册的抽象基类,为了避免运行时错误，虚拟子类要实现所需的全部方法。\nimport abc\n\n\nclass Tombola(abc.ABC):\n    @abc.abstractmethod\n    def load(self, iterable):\n        \"\"\"从可迭代对象中添加元素。\"\"\"\n\n    @abc.abstractmethod\n    def pick(self):\n        \"\"\"随机删除元素，然后将其返回。\n        如果实例为空，这个方法应该抛出`LookupError`。\n        \"\"\"\n\n    def loaded(self):\n        \"\"\"如果至少有一个元素，返回`True`，否则返回`False`。\"\"\"\n        return bool(self.inspect())\n\n    def inspect(self):\n        \"\"\"返回一个有序元组，由当前元素构成。\"\"\"\n        items = []\n        while True:\n            try:\n                items.append(self.pick())\n            except LookupError:\n                break\n        self.load(items)\n        return tuple(sorted(items))\n\n\nimport random\n\n\nclass BingoCage(Tombola):\n    def __init__(self, items):\n        self._randomizer = random.SystemRandom()\n        self._items = []\n        self.load(items)\n\n    def load(self, items):\n        self._items.extend(items)\n        self._randomizer.shuffle(self._items)\n\n    def pick(self):\n        try:\n            return self._items.pop()\n        except IndexError:\n            raise LookupError('pick from empty BingoCage')\n\n    def __call__(self):\n        self.pick()\n\n\nclass LotteryBlower(Tombola):\n    def __init__(self, iterable):\n        self._balls = list(iterable)\n\n    def load(self, iterable):\n        self._balls.extend(iterable)\n\n    def pick(self):\n        try:\n            position = random.randrange(len(self._balls))\n        except ValueError:\n            raise LookupError('pick from empty lotteryBlower')\n\n    def loaded(self):\n        return bool(self._balls)\n\n    def inspect(self):\n        return tuple(sorted(self._balls))\n\n\nfrom random import randrange\n\n\n@Tombola.register\nclass TomboList(list):\n    def pick(self):\n        if self:\n            position = randrange(len(self))\n            return self.pop(position)\n        else:\n            raise LookupError('pop from empty TomboList')\n\n    load = list.extend\n\n    def loaded(self):\n        return bool(self)\n\n    def inspect(self):\n        return tuple(sorted(self))\n\n\n# Tombola.register(TomboList)\n把 Tombolist 注册为 Tombola 的虚拟子类。❸ Tombolist 从 list 中继承 bool 方法，列表不为空时返回 True。❹ pick 调用继承自 list 的 self.pop 方法，传入一个随机的元素索引。\n注册之后，可以使用 issubclass 和 isinstance 函数判断 TomboList 是不是Tombola的子类：\n>>> from tombola import Tombola\n>>> from tombolist import TomboList\n>>> issubclass(TomboList, Tombola)\nTrue\n>>> t = TomboList(range(100))\n>>> isinstance(t, Tombola)\nTrue\nTombola子类的测试方法\n__subclasses__()　　这个方法返回类的直接子类列表，不含虚拟子类。_abc_registry　　只有抽象基类有这个数据属性，其值是一个 WeakSet 对象，即抽象类注册的虚拟子类的弱引用。\nPython使用register的方式\nTombola.register 当作类装饰器使用。在 Python 3.3 之前的版本中不能这样使用 register\n虽然现在可以把 register 当作装饰器使用了，但更常见的做法还是把它当作函数使用，用于注册其他地方定义的类。\n即便不注册，抽象基类也能把一个类识别为虚拟子类\n>>> class Struggle:\n... def __len__(self): return 23\n...\n>>> from collections import abc\n>>> isinstance(Struggle(), abc.Sized)\nTrue\n>>> issubclass(Struggle, abc.Sized)\nTrue\n\nissubclass 函数确认（isinstance 函数也会得出相同的结论）\nStruggle 是abc.Sized 的子类，\n这是因为 abc.Sized 实现了一个特殊的类方法，名为__subclasshook__。\n\nSized 类的源码:\nclass Sized(metaclass=ABCMeta):\n __slots__ = ()\n @abstractmethod\n def __len__(self):\n return 0\n @classmethod\n def __subclasshook__(cls, C):\n if cls is Sized:\n if any(\"__len__\" in B.__dict__ for B in C.__mro__): # ➊\n return True # ➋\n return NotImplemented # ➌\n对 C.__mro__ （即 C 及其超类）中所列的类来说，如果类的 dict 属性中有名为len 的属性……\n小结\n1.抽象基类的使用姿势2.定义一个随机抽象基类3.虚拟子类 只是注册就行,(没继承),必须实现所有方法4.Tombola 这个自定义的抽象基类多写几次\n其他:\n非正式接口（称为协议）的高度动态本性，以及使用 subclasshook 方法动态识别子类。\n我们发现 Python 对序列协议的支持十分深入。如果一个类实现了__getitem__ 方法，此外什么也没做，那么 Python 会设法迭代它，而且 in 运算符也随之可以使用。\n显式继承抽象基类的优缺点。继承abc.MutableSequence 后，必须实现 insert 和 delitem 方法，而我们并不需要这两个方法。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}