{"title": "Python Closure - 个人文章 ", "index": "python3.x,python", "content": "在计算机科学中，闭包 又称 词法闭包 或 函数闭包，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。闭包被广泛应用于函数式语言中。\n从上面这段话中可以看出闭包的两个重要条件是引用自由变量和函数，与闭包这个名称结合起来看，这个函数就像是一个包，而这个函数所引用的变量就好比函数这个包中封闭起来的东西，包中的东西被紧紧封闭在包中，函数所引用的变量也被与这个函数所绑定。\n首先来看两个概念 Nonlocal variable 和 Nested function\nNonlocal variable & Nested function\nNonlocal variable是相对于某个函数来说的，指的是这个函数所调用的在本函数作用域之外的变量，Nested function指的被定义在一个函数(outer enclosing function)中的函数，这个nested function可以调用包围它的作用域中的变量。\n看一个例子\ndef print_msg(msg):\n    # outer enclosing function\n\n    def printer():\n        # nested function\n        print(msg)\n\n    printer()\n\n>>> print_msg(\"Hello\")\nHello\n在这个例子中函数printer就是一个nested function，而变量msg就是一个nonlocal variable。这里需要注意的是，printer虽然可以访问msg，但是不可以改变它，如果尝试更改会出现UnboundLocalError: local variable 'msg' referenced before assignment。\ndef print_msg(msg):\n    def printer():\n        msg += 'a'\n        print(msg)\n    printer()\n\n>>> print_msg(\"Hello\")\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"<stdin>\", line 5, in print_msg\n  File \"<stdin>\", line 3, in printer\nUnboundLocalError: local variable 'msg' referenced before assignment\nlocal variable 'msg' referenced before assignment\n如果必须要更改这个变量的值，在Python3中新引入的nonlocal语句可以解决。\ndef print_msg(msg):\n    def printer():\n        nonlocal msg\n        msg += 'a'\n        print(msg)\n    printer()\n\n>>> print_msg(\"Hello\")\nHelloa\n在Python2中使用global也可解决，但是global会直接查找全局变量，而nonlocal则是按优先级从本地-->全局进行搜索。\n闭包函数\n下面使外层函数(outer enclosing function)返回一个函数\ndef print_msg(msg):\n    def printer():\n        print(msg)\n    return printer\n\n>>> another = print_msg(\"Hello\")\n>>> another()\nHello\n将print_msg(\"Hello\")返回的函数赋值给another，再调用another函数时，发现已经离开了print_msg函数的作用域，但是\"Hello\"已经被绑定给another,所以仍然能够正常调用，这就是Python中的闭包。删除print_msg之后，another仍然能够正常调用。\n>>> del print_msg\n>>> print_msg(\"Hello\")\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nNameError: name 'print_msg' is not defined\nname 'print_msg' is not defined\n\n>>> another()\nHello\n闭包的应用\n当符合下面几个条件时就形成了闭包：\n\n有一个Nested function\n这个Nested function访问了父函数作用域中的变量\n父函数返回了这个Nested function\n\n闭包主要运用在需要讲父函数作用域中的变量绑定到子函数的场景之中，在释放掉父函数之后子函数也不会受到影响。运用闭包可以避免对全局变量的使用。对于一个只有需要实现少数方法的类我们也可以用闭包来替代，这样做可以减少资源的使用。\n下面需要用类定义不同动物的叫声\nclass Animal:\n    def __init__(self, animal):\n        self.animal = animal\n    def sing(self, voice):\n        return \"{} sings {}\".format(self.animal, voice)\n\n>>> dog = Animal(\"dog\")\n>>> cow = Animal(\"cow\")\n>>> dog.sing(\"wong\")\n'dog sings wong'\n>>> cow.sing(\"mow\")\ncow sings mow'\n用闭包替代\ndef make_sing(animal):\n    def make_voice(voice):\n        return \"{} sings {}\".format(animal, voice)\n    return make_voice\n\n>>> dog = make_sing(\"dog\")\n>>> dog(\"wong\")\n'dog sings wong'\n>>> cow = make_sing(\"cow\")\n>>> cow(\"mow\")\n'cow sings mow'\n闭包与装饰器\n闭包通常用来实现一个通用的功能，Python中的装饰器就是对闭包的一种应用，只不过装饰器中父函数的参数是一个函数,下面这个例子通过装饰器实现了在子函数执行前后输出提示信息。\ndef make_wrap(func):\n    def wrapper(*args):\n        print(\"before function\")\n        func(*args)\n        print(\"after function\")\n    return wrapper\n\n@make_wrap\ndef print_msg(msg):\n    print(msg)\n\n>>> print_msg(\"Hello\")\nbefore function\nHello\nafter function\n装饰器也可以进行叠加\ndef make_another(func):\n    def wrapper(*args):\n        print(\"another begin\")\n        func(*args)\n        print(\"another end\")\n    return wrapper\n\n@make_another\n@make_wrap\ndef print_msg(msg):\n    print(msg)\n\n>>> print_msg(\"Hello\")\nanother begin\nbefore function\nHello\nafter function\nanother end\n闭包的内部实现\nCode Object\n为了了解闭包的内部实现，需要用compile命令得出相应的code object\n>>> code_obj = compile(\"print_msg('Hello')\", \"\", \"single\")\n这里第一个参数是一个可以被exec或    eval解析的模块、语句或者表达式；第二个参数是用来存放运行时错误的文件;第三个选择single模式，与前面第一个参数填写的表达式相匹配，如果第一个参数是表达式则需要用eval模式，如果是模块则应该用exec模式。\n下面通过dis讲code_obj反编译成助记符\n>>> dis.dis(code_obj)\n  1           0 LOAD_NAME                0 (print_msg)\n              2 LOAD_CONST               0 ('Hello')\n              4 CALL_FUNCTION            1\n              6 PRINT_EXPR\n              8 LOAD_CONST               1 (None)\n             10 RETURN_VALUE\nPython3中通过__code__访问函数的code object(Python2中为func_code)\n>>> print_msg.__code__\n<code object print_msg at 0x10d5c7300, file \"<stdin>\", line 1>\nCell Object\ncell object用来存储被多个作用域所引用的变量。\n比如下面函数中msg被print_msg所引用，也被printer所引用，所以msg会被存在一个cell object中\ndef print_msg(msg):\n    def printer():\n        print(msg)\n    return printer\n查看其__closure__属性可以验证我们的想法\n>>> print_msg(\"Hello\").__closure__\n(<cell at 0x10d121d38: str object at 0x10d4a6f48>,)\n尽管这两个引用都被存在同意个cell object，但是他们仍然只在各自的作用域下作用。\n闭包分析\n首先反编译print_msg\n>>> dis.dis(print_msg)\n  2           0 LOAD_CLOSURE             0 (msg)\n              2 BUILD_TUPLE              1\n              4 LOAD_CONST               1 (<code object printer at 0x10d5c7780, file \"<stdin>\", line 2>)\n              6 LOAD_CONST               2 ('print_msg.<locals>.printer')\n              8 MAKE_FUNCTION            8\n             10 STORE_FAST               1 (printer)\n\n  4          12 LOAD_FAST                1 (printer)\n             14 RETURN_VALUE\n\nLOAD_CLOSURE 0 (msg)将变量msg进栈。\nBUILD_TUPLE  1 将栈顶的元素取出，创建元组，并将该元组push进栈。\nLOAD_CONST  1从print_msg.__code__.co_consts[1]中取出，为printer的code object的地址，将其push进栈。\nLOAD_CONST  2从print_msg.__code__.co_consts[2]中取出，将其push进栈。\nSTORE_FAST  1从栈顶取出之前创建的函数对象的地址信息赋给局部变量printer(局部变量名记录在__code__.co_varnames中)__code__.co_varnames的内容为('msg','printer')\n\n将变量msg(记录在__code__.co_cellvars[0])绑定栈顶的函数对象地址。\n\nLOAD_FAST 1将msg的值压入栈。\nRETURN_VALUE返回栈顶。\n\n可以看到在STORE_FAST 1中将变量msg绑定到了printer函数，从而达到了闭包中内部函数访问外部函数变量的效果。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "3"}