{"title": "Python 3.7 将引入 dataclass 装饰器 - 极光推送 ", "index": "python", "content": "简评：Python 3.7 将于今年夏天发布，Python 3.7 中将会有许多新东西，最激动人心的新功能之一是 dataclass 装饰器。\n什么是 Data Class\n大多数 Python 开发人员编写过很多像下面这样的类：\n\ndataclass 可以为简单的情况自动生成方法，例如，一个init接受这些参数并将其分配给自己，之前的小例子可以重写为：\n\n那么通过一个例子来看看如何使用吧\n星球大战 API\n可以使用 requests 从星球大战 API 获取资源：\n\n让我们来看看 dictionary （简化过）的结果：\n\n封装 API 为了正确地封装一个 API，我们应该创建一个用户可以在其应用程序中使用的对象，因此，在Python 3.6 中定义一个对象来包含requests对 /films/endpoint的响应：\nclass StarWarsMovie:\n    \ndef __init__(self,\n            title: str,\n            episode_id: int,\n            opening_crawl: str,\n                        director: str,\n            producer: str,\n            release_date: datetime,\n            characters: List[str],\n            planets: List[str],\n            starships: List[str],\n            vehicles: List[str],\n            species: List[str],\n            created: datetime,\n            edited: datetime,\n            url: str            \n            ):\n    \nself.title = title\nself.episode_id = episode_id\nself.opening_crawl= opening_crawl\nself.director = director\nself.producer = producer\nself.release_date = release_date\nself.characters = characters\nself.planets = planets\nself.starships = starships\nself.vehicles = vehicles\nself.species = species    \nself.created = created    \nself.edited = edited    \nself.url = url\n    \nif type(self.release_date) is str:\n       self.release_date = dateutil.parser.parse(self.release_date)\n    \nif type(self.created) is str:\n       self.created = dateutil.parser.parse(self.created)\n    \nif type(self.edited) is str:\n       self.edited = dateutil.parser.parse(self.edited)\n仔细的读者可能已经注意到这里有一些重复的代码。\n这是使用 dataclass 装饰器的经典案例，我们需要创建一个主要用来保存数据的类，只需一点验证，所以让我们来看看我们需要修改什么。\n首先，data class 自动生成一些 dunder 方法，如果我们没有为 data class 装饰器指定任何选项，则生成的方法有：init，eq和repr，如果你已经定义了repr但没定义str，默认情况下 Python（不仅仅是 data class）将实现返回repr的输出str方法。因此，只需将代码更改为以下代码即可实现四种 dunder 方法：\n\n我们去掉了init方法，以确保 data class 装饰器可以添加它生成的对应方法。不过，我们在这个过程中失去了一些功能，我们的 Python 3.6 构造函数不仅定义了所有的值，还试图解析日期，我们怎样才能用 data class 来做到这一点呢？\n如果要覆盖 init，我们将失去 data class 的优势，因此，如果要处理任何附加功能可以使用新的 dunder 方法：postinit，让我们看看postinit方法对于我们的包装类来说是什么样子的：\n\n就是这样！ 我们可以使用 data class 装饰器在用三分之二的代码量实现我们的类。\n更多好东西\n通过使用装饰器的选项，可以为用例进一步定制 data class，默认选项是：\n\ninit决定是否生成init dunder 方法 repr决定是否生成repr dunder方法 eq对eq dunder 方法也是如此，它决定相等性检查的行为（yourclassinstance == another_instance） order 实际上创建了四种 dunder 方法，它们确定所有检查小于，and/or，大于的行为，如果将其设置为 true，则可以对对象列表进行排序。 最后两个选项确定对象是否可以被哈希化，如果你想使用你的 class 的对象作为字典键的话，这是必要的。\n更多信息请参考：PEP 557 -- Data Classes\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}