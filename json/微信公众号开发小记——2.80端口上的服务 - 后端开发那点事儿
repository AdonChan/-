{"title": "微信公众号开发小记——2.80端口上的服务 - 后端开发那点事儿 ", "index": "微信开发,python", "content": "描述\n微信公众号开发基本分为2大种类型\n1.用户直接做了某些操作（回复信息、订阅、扫码、发语音、点按钮等），此时这些信息微信会发送到微信服务器的80端口，这是一种开发类型；2.通过连接（按钮、文章）引导用户到另一个网站，网站通过oauth实现微信的三方登录做到用户打通，然后提供更多服务\n注意第二种类型的其他网站可以跟第一种类型（只提供80端口服务）的网站是一个server\n80端口的服务开发\n代码位置weixin_server tag:80-port-20160415\nwechat对象以及缓存access_token\nwechat sdk操作都需要一个wechat的东西，生成这玩意儿需要加载一个wechat_config，config里面包含了你的appid，appsecret，以及你消息加密解密的配置，为了简少根据加密方式造成的代码变更，我在配置里面添加了settings.WEIXIN_ENCRYPT_MODE,这样直接填写你的加密模式，就可以在任何用到wechat的地方直接import一个wechat变量,之所以要用get_wechat的方式实时生成是为了做access_token的缓存，下面会讲。\nfrom .wechat import get_wechat\n\nwechat = get_wechat()\n\n微信在做一些操作是需要用到access_token(生成二维码等),而每天access_token接口的调用上限为2000，需要自己做缓存, sdk文档讲了几种方式，我觉得放在cache中拿比较妥当。\n代码我不贴了，这是位置weixin/config.pyweixin/wechat.py\nhandler各种微信post到80的事件\n微信会在用户对公众号交互时像我们的服务器80端口post一些事件，sdk文档 message源码,大体看了下我写了个mixin\n# -*- coding: utf-8 -*-\nfrom weixin.wechat import get_wechat\nfrom wechat_sdk.messages import MESSAGE_TYPES, EventMessage\n\nwechat = get_wechat()\n\nREVERSED_MESSAGE_TYPES = {value:key for key, value in MESSAGE_TYPES.iteritems()}\n\nclass WeixinDispatchMixin(object):\n\n    def dispatch_weixin(self, request, *args, **kwargs):\n        content = request.body\n        signature = request.GET.get('signature', '')\n        msg_signature = request.GET.get('msg_signature', '')\n        timestamp = request.GET.get('timestamp', '')\n        nonce = request.GET.get('nonce', '')\n        try:\n            wechat.parse_data(\n                    content,\n                    msg_signature=msg_signature,\n                    timestamp=timestamp,\n                    nonce=nonce)\n        except ParseError:\n            return HttpResponse('Invalid Body Text')\n        handler_name = self.get_weixin_handler_name(request, wechat, *args, **kwargs)\n        handler = getattr(self, handler_name, self.http_method_not_allowed)\n        return handler(request, wechat, *args, **kwargs)\n\n    def get_weixin_handler_name(self, request, parsed_wechat, *args, **kwargs):\n        message = parsed_wechat.message\n        if isinstance(message, EventMessage):\n            event_name = REVERSED_MESSAGE_TYPES[type(message)]\n            event_detail_name = 'weixin_handler_{}_{}'.format(event_name, message.type)\n            if hasattr(self, event_detail_name):\n                event_name = event_detail_name\n                return event_name\n        return u'weixin_handler_{}'.format(REVERSED_MESSAGE_TYPES.get(type(message), 'unsupport'))\n        \nmixin参考django的dispatch，这样在继承的类里面直接实现weixin_handler_xxx方法即可，然而event有更多的类型，如果是通用处理则直接实现weixin_handler_event,如果要更加细化，例如扫码的event，则实现weixin_handler_event_scan方法，可以参考weixin_server/views.py\n菜单儿\n菜单可以直接在admin定制，由于菜单类似一种配置，同一时间最多且只有1个，我就把edx的config_model拿过来了，自己定制了下admin，这样你可以直接在admin里面修改菜单，微信会生效。微信菜单会缓存5分钟，你可以取消关注，然后在关注查看菜单变化效果。\n菜单这块儿的代码有点意思，感兴趣的可以看下。\nweixin/models.pyweixin/admin.py\n生成二维码\n二维码的逻辑略有不同（相对于sdk的其他response_xxx),所以我写了个qrcode.py封装了一下，注意永久二维码只能生产10万张，业务场景不要乱用，二维码的这些id、url都是需要做本地存储的，我没接model就丢到缓存里了。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "5"}