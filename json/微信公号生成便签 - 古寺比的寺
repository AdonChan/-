{"title": "微信公号生成便签 - 古寺比的寺 ", "index": "微信公众平台,微信,python3.x,python", "content": "最近有文字转图片的需求，但是不太想下载 APP，就使用 Python Pillow 实现了一个，效果如下：\n\nPIL 提供了 PIL.ImageDraw.ImageDraw.text 方法，可以方便的把文字写到图片上，简单示例如下：\nfrom PIL import Image, ImageDraw, ImageFont\n# get an image\nbase = Image.open('Pillow/Tests/images/hopper.png').convert('RGBA')\n\n# make a blank image for the text, initialized to transparent text color\ntxt = Image.new('RGBA', base.size, (255,255,255,0))\n\n# get a font\nfnt = ImageFont.truetype('Pillow/Tests/fonts/FreeMono.ttf', 40)\n# get a drawing context\nd = ImageDraw.Draw(txt)\n\n# draw text, half opacity\nd.text((10,10), \"Hello\", font=fnt, fill=(255,255,255,128))\n# draw text, full opacity\nd.text((10,60), \"World\", font=fnt, fill=(255,255,255,255))\n\nout = Image.alpha_composite(base, txt)\n\nout.show()\n为什么要计算文字的宽高呢？把文字直接写到背景图不可以么？\nPillow PIL.ImageDraw.ImageDraw.text写文字是按换行符\\n换行的，如果一句话特别长，文字就会超出背景图的宽度，所以第一步我们需要先把文本按固定的宽度计算出高度。\n像图上写的这样，文字转图片分三步：\n\n计算文字宽高\n生成响应尺寸背景图\n把文字写到图片上\n\n计算文字宽高\n这里背景图宽度是固定的，所以文字的宽可以不用计算。PIL.ImageDraw.ImageDraw.text 是通过\\n来换行的，那我们只需要在文字合适的位置加上\\n就可以了。\n第一个想到的是 textwrap 方法，textwrap 可以实现通过调整换行符的位置来格式化文本。但 textwrap 还有一个问题就是它是根据字符长度来分隔的，但文本中的字符并不是等宽的，通过textwrap格式化后的文字写到图片上效果可能是这样的：\n\n使用这种方式，如果我们要调整字体大小，每一行的长度都还需要再重新调整。\n为了保证每一行宽度尽可能的一致，这里使用 PIL.ImageDraw.ImageDraw.textsize 获取字符宽高，然后按约定宽度把长文本分隔成文本列表，然后把列表每行文字写到图片上。\ndef get_paragraph(text, note_width):\n    # 把每段文字按约定宽度分隔成几行\n    txt = Image.new('RGBA', (100, 100), (255, 255, 255, 0))\n    # get a drawing context\n    draw = ImageDraw.Draw(txt)\n    paragraph, sum_width = '', 0\n    line_numbers, line_height = 1, 0\n    for char in text:\n        w, h = draw.textsize(char, font)\n        sum_width += w\n        if sum_width > note_width:\n            line_numbers += 1\n            sum_width = 0\n            paragraph += '\\n'\n        paragraph += char\n        line_height = max(h, line_height)\n    if not paragraph.endswith('\\n'):\n        paragraph += '\\n'\n    return paragraph, line_height, line_numbers\n\n\ndef split_text(text):\n    # 将文本按规定宽度分组\n    max_line_height, total_lines = 0, 0\n    paragraphs = []\n    for t in text.split('\\n'):\n        # 先按 \\n 把文本分段\n        paragraph, line_height, line_numbers = get_paragraph(t)\n        max_line_height = max(line_height, max_line_height)\n        total_lines += line_numbers\n        paragraphs.append((paragraph, line_numbers))\n    line_height = max_line_height\n    total_height = total_lines * line_height\n    # 这里返回分好的段，文本总高度以及行高\n    return paragraphs, total_height, line_height\n这是按字符宽度分隔文本写到图片的效果：\n\n由于文本长度不固定，生成得到的文本高度也不固定，背景图我们也需要动态生成\n根据文本高度生成背景图\n\n通过图片我们可以看到，头部和尾部是固定的，变化的是文字部分，那么背景图片的高度计算公式为\n背景图片高度=头部高度+尾部高度+文本高度\n实现代码如下：\nNOTE_HEADER_IMG = path.normpath(path.join(\n    path.dirname(__file__), 'note_header_660.png'))\nNOTE_BODY_IMG = path.normpath(path.join(\n    path.dirname(__file__), 'note_body_660.png'))\nNOTE_FOOTER_IMG = path.normpath(path.join(\n    path.dirname(__file__), 'note_footer_660.png'))\nNOTE_WIDTH = 660\nNOTE_TEXT_WIDTH = 460\nbody_height = NOTE_BODY_HEIGHT = 206\nheader_height = NOTE_HEADER_HEIGHT = 89\nfooter_height = NOTE_FOOTER_HEIGHT = 145\nfont = ImageFont.truetype(NOTE_OTF, 24)\n\n\n\ndef get_images(note_height):\n    numbers = note_height // body_height + 1\n    images = [(NOTE_HEADER_IMG, header_height)]\n    images.extend([(NOTE_BODY_IMG, body_height)] * numbers)\n    images.append((NOTE_FOOTER_IMG, footer_height))\n    return images\n\n\ndef make_backgroud():\n    # 将图片拼接到一起\n    images = get_images()\n    total_height = sum([height for _, height in images])\n    # 最终拼接完成后的图片\n    backgroud = Image.new('RGB', (body_width, total_height))\n    left, right = 0, 0\n    background_img = '/tmp/%s_backgroud.png' % total_height\n    # 判断背景图是否存在\n    if path.exists(background_img):\n        return background_img\n    for image_file, height in images:\n        image = Image.open(image_file)\n        # (0, left, self.body_width, right+height)\n        # 分别为 左上角坐标 0, left\n        # 右下角坐标 self.body_width, right+height\n        backgroud.paste(image, (0, left, body_width, right+height))\n        left += height  # 从上往下拼接，左上角的纵坐标递增\n        right += height  # 左下角的纵坐标也递增\n    backgroud.save(background_img, quality=85)\n    return background_img\n将文字写到图片\n现在我们得到了背景图以及分隔好的文本，就可以直接将文本写到图片上了\ndef draw_text(paragraphs, height):\n    background_img = make_backgroud()\n    note_img = Image.open(background_img).convert(\"RGBA\")\n    draw = ImageDraw.Draw(note_img)\n    # 文字开始位置坐标，需要根据背景图的大小做调整\n    x, y = 80, 100\n    for paragraph, line_numbers in paragraphs:\n        for line in paragraph.split('\\n')[:-1]:\n            draw.text((x, y), line, fill=(110, 99, 87), font=font)\n            y += line_height\n        # draw.text((x, y), paragraph, fill=(110, 99, 87), font=font)\n        # y += self.line_height * line_numbers\n    note_img.save(filename, \"png\", quality=1, optimize=True)\n    return filename\n完整版代码请查看 https://github.com/gusibi/mom...\n执行后效果如图：\n\n遇到的问题\n为了能方便使用，我把这个做成了公号的一个功能，然后遇到了一个严重问题，太慢了！\n使用 line_profiler 分析可以发现，大部分时间都消耗在了图片保存这一步，\nnote_img.save(filename, \"png\", quality=1, optimize=True)\n性能分析工具也会占用时间，测试完成后需要关闭分析\n解决这个问题可能的方法：\n\n减小背景图片大小\n减小字体大小\n\n通过测试，发现把背景图宽度从990减到660，字体大小从40px 调整到24px，生成的图片大小体积缩小了接近1倍，生成速度也比原来快了2/5。\n\n相同代码，相同文本，使用 python3 只用了2.3s，而 Python2 用时却是5.3 s，还从来没在其它功能上遇到过 Python2 和 Python3 有这么大的差别。\n具体差异可以使用源码测试一下\n\n还是有问题\n优化完图片生成速度后，发现在长文本状态下，公号还是会超时报错。经过检查发现是图片上传到公众平台太慢了（服务器只有1M 带宽，没有办法.）。\n解决方法，把图片上传到腾讯云（文件上传使用的是内网带宽，不受限制），返回图片 url。\n\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "3"}