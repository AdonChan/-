{"title": "Python黑魔法之描述符 - ziwenxie ", "index": "python", "content": "引言\nDescriptors(描述符)是Python语言中一个深奥但很重要的一个黑魔法，它被广泛应用于Python语言的内核，熟练掌握描述符将会为Python程序员的工具箱添加一个额外的技巧。本文我将讲述描述符的定义以及一些常见的场景，并且在文末会补充一下__getattr__，__getattribute__, __getitem__这三个同样涉及到属性访问的魔术方法。\n描述符的定义\ndescr__get__(self, obj, objtype=None) --> value\n\ndescr.__set__(self, obj, value) --> None\n\ndescr.__delete__(self, obj) --> None\n只要一个object attribute(对象属性)定义了上面三个方法中的任意一个，那么这个类就可以被称为描述符类。\n描述符基础\n下面这个例子中我们创建了一个RevealAcess类，并且实现了__get__方法，现在这个类可以被称为一个描述符类。\nclass RevealAccess(object):\n    def __get__(self, obj, objtype):\n        print('self in RevealAccess: {}'.format(self))\n        print('self: {}\\nobj: {}\\nobjtype: {}'.format(self, obj, objtype))\n\n\nclass MyClass(object):\n    x = RevealAccess()\n    def test(self):\n        print('self in MyClass: {}'.format(self))\nEX1实例属性\n接下来我们来看一下__get__方法的各个参数的含义，在下面这个例子中，self即RevealAccess类的实例x，obj即MyClass类的实例m，objtype顾名思义就是MyClass类自身。从输出语句可以看出，m.x访问描述符x会调用__get__方法。\n>>> m = MyClass()\n>>> m.test()\nself in MyClass: <__main__.MyClass object at 0x7f19d4e42160>\n\n>>> m.x\nself in RevealAccess: <__main__.RevealAccess object at 0x7f19d4e420f0>\nself: <__main__.RevealAccess object at 0x7f19d4e420f0>\nobj: <__main__.MyClass object at 0x7f19d4e42160>\nobjtype: <class '__main__.MyClass'>\nEX2类属性\n如果通过类直接访问属性x，那么obj接直接为None，这还是比较好理解，因为不存在MyClass的实例。\n>>> MyClass.x\nself in RevealAccess: <__main__.RevealAccess object at 0x7f53651070f0>\nself: <__main__.RevealAccess object at 0x7f53651070f0>\nobj: None\nobjtype: <class '__main__.MyClass'>\n描述符的原理\n描述符触发\n上面这个例子中，我们分别从实例属性和类属性的角度列举了描述符的用法，下面我们来仔细分析一下内部的原理：\n\n如果是对实例属性进行访问，相当于调用了object.__getattribute__()，它将obj.d转译成了type(obj).__dict__['d'].__get__(obj, type(obj))。\n如果是对类属性进行访问，相当于调用了type.__getattribute__()，它将cls.d转译成了cls.__dict__['d'].__get__(None, cls)，转换成Python代码就是：\n\ndef __getattribute__(self, key):\n    \"Emulate type_getattro() in Objects/typeobject.c\"\n    v = object.__getattribute__(self, key)\n    if hasattr(v, '__get__'):\n        return v.__get__(None, self)\n    return v\n简单讲一下__getattribute__魔术方法，这个方法在我们访问一个对象的属性的时候会被无条件调用，详细的细节比如和__getattr, __getitem__的区别我会在文章的末尾做一个额外的补充，我们暂时并不深究。\n描述符优先级\n首先，描述符分为两种:\n\n如果一个对象同时定义了__get__()和__set__()方法，则这个描述符被称为data descriptor。\n如果一个对象只定义了__get__()方法，则这个描述符被称为non-data descriptor。\n\n我们对属性进行访问的时候存在下面四种情况：\n\ndata descriptor\ninstance dict\nnon-data descriptor\n__getattr__()\n\n它们的优先级大小是：\ndata descriptor > instance dict > non-data descriptor > __getattr__()\n这是什么意思呢？就是说如果实例对象obj中出现了同名的data descriptor->d 和 instance attribute->d，obj.d对属性d进行访问的时候，由于data descriptor具有更高的优先级，Python便会调用type(obj).__dict__['d'].__get__(obj, type(obj))而不是调用obj.__dict__['d']。但是如果描述符是个non-data descriptor，Python则会调用obj.__dict__['d']。\nProperty\n每次使用描述符的时候都定义一个描述符类，这样看起来非常繁琐。Python提供了一种简洁的方式用来向属性添加数据描述符。\nproperty(fget=None, fset=None, fdel=None, doc=None) -> property attribute\nfget、fset和fdel分别是类的getter、setter和deleter方法。我们通过下面的一个示例来说明如何使用Property：\nclass Account(object):\n\n    def __init__(self):\n        self._acct_num = None\n\n    def get_acct_num(self):\n        return self._acct_num\n\n    def set_acct_num(self, value):\n        self._acct_num = value\n\n    def del_acct_num(self):\n        del self._acct_num\n\n    acct_num = property(get_acct_num, set_acct_num, del_acct_num, '_acct_num property.')\n如果acct是Account的一个实例，acct.acct_num将会调用getter，acct.acct_num = value将调用setter，del acct_num.acct_num将调用deleter。\n>>> acct = Account()\n>>> acct.acct_num = 1000\n>>> acct.acct_num\n1000\nPython也提供了@property装饰器，对于简单的应用场景可以使用它来创建属性。一个属性对象拥有getter,setter和deleter装饰器方法，可以使用它们通过对应的被装饰函数的accessor函数创建属性的拷贝。\nclass Account(object):\n\n    def __init__(self):\n        self._acct_num = None\n\n    @property\n     # the _acct_num property. the decorator creates a read-only property\n    def acct_num(self):\n        return self._acct_num\n\n    @acct_num.setter\n    # the _acct_num property setter makes the property writeable\n    def set_acct_num(self, value):\n        self._acct_num = value\n\n    @acct_num.deleter\n    def del_acct_num(self):\n        del self._acct_num\n如果想让属性只读，只需要去掉setter方法。\n在运行时创建描述符\n我们可以在运行时添加property属性：\nclass Person(object):\n\n    def addProperty(self, attribute):\n        # create local setter and getter with a particular attribute name\n        getter = lambda self: self._getProperty(attribute)\n        setter = lambda self, value: self._setProperty(attribute, value)\n\n        # construct property attribute and add it to the class\n        setattr(self.__class__, attribute, property(fget=getter, \\\n                                                    fset=setter, \\\n                                                    doc=\"Auto-generated method\"))\n\n    def _setProperty(self, attribute, value):\n        print(\"Setting: {} = {}\".format(attribute, value))\n        setattr(self, '_' + attribute, value.title())\n\n    def _getProperty(self, attribute):\n        print(\"Getting: {}\".format(attribute))\n        return getattr(self, '_' + attribute)\n>>> user = Person()\n>>> user.addProperty('name')\n>>> user.addProperty('phone')\n>>> user.name = 'john smith'\nSetting: name = john smith\n>>> user.phone = '12345'\nSetting: phone = 12345\n>>> user.name\nGetting: name\n'John Smith'\n>>> user.__dict__\n{'_phone': '12345', '_name': 'John Smith'}\n静态方法和类方法\n我们可以使用描述符来模拟Python中的@staticmethod和@classmethod的实现。我们首先来浏览一下下面这张表：\n\n静态方法\n对于静态方法f。c.f和C.f是等价的，都是直接查询object.__getattribute__(c, ‘f’)或者object.__getattribute__(C, ’f‘)。静态方法一个明显的特征就是没有self变量。\n静态方法有什么用呢？假设有一个处理专门数据的容器类，它提供了一些方法来求平均数，中位数等统计数据方式，这些方法都是要依赖于相应的数据的。但是类中可能还有一些方法，并不依赖这些数据，这个时候我们可以将这些方法声明为静态方法，同时这也可以提高代码的可读性。\n使用非数据描述符来模拟一下静态方法的实现：\nclass StaticMethod(object):\n    def __init__(self, f):\n        self.f = f\n\n    def __get__(self, obj, objtype=None):\n        return self.f\n我们来应用一下：\nclass MyClass(object):\n    @StaticMethod\n    def get_x(x):\n        return x\n\nprint(MyClass.get_x(100))  # output: 100\n类方法\nPython的@classmethod和@staticmethod的用法有些类似，但是还是有些不同，当某些方法只需要得到类的引用而不关心类中的相应的数据的时候就需要使用classmethod了。\n使用非数据描述符来模拟一下类方法的实现：\nclass ClassMethod(object):\n    def __init__(self, f):\n        self.f = f\n\n    def __get__(self, obj, klass=None):\n        if klass is None:\n            klass = type(obj)\n        def newfunc(*args):\n            return self.f(klass, *args)\n        return newfunc\n其他的魔术方法\n首次接触Python魔术方法的时候，我也被__get__, __getattribute__, __getattr__, __getitem__之间的区别困扰到了，它们都是和属性访问相关的魔术方法，其中重写__getattr__，__getitem__来构造一个自己的集合类非常的常用，下面我们就通过一些例子来看一下它们的应用。\n__getattr__\nPython默认访问类/实例的某个属性都是通过__getattribute__来调用的，__getattribute__会被无条件调用，没有找到的话就会调用__getattr__。如果我们要定制某个类，通常情况下我们不应该重写__getattribute__，而是应该重写__getattr__，很少看见重写__getattribute__的情况。\n从下面的输出可以看出，当一个属性通过__getattribute__无法找到的时候会调用__getattr__。\nIn [1]: class Test(object):\n    ...:     def __getattribute__(self, item):\n    ...:         print('call __getattribute__')\n    ...:         return super(Test, self).__getattribute__(item)\n    ...:     def __getattr__(self, item):\n    ...:         return 'call __getattr__'\n    ...:\n\nIn [2]: Test().a\ncall __getattribute__\nOut[2]: 'call __getattr__'\n应用\n对于默认的字典，Python只支持以obj['foo']形式来访问，不支持obj.foo的形式，我们可以通过重写__getattr__让字典也支持obj['foo']的访问形式，这是一个非常经典常用的用法：\nclass Storage(dict):\n    \"\"\"\n    A Storage object is like a dictionary except `obj.foo` can be used\n    in addition to `obj['foo']`.\n    \"\"\"\n\n    def __getattr__(self, key):\n        try:\n            return self[key]\n        except KeyError as k:\n            raise AttributeError(k)\n\n    def __setattr__(self, key, value):\n        self[key] = value\n\n    def __delattr__(self, key):\n        try:\n            del self[key]\n        except KeyError as k:\n            raise AttributeError(k)\n\n    def __repr__(self):\n        return '<Storage ' + dict.__repr__(self) + '>'\n我们来使用一下我们自定义的加强版字典：\n>>> s = Storage(a=1)\n>>> s['a']\n1\n>>> s.a\n1\n>>> s.a = 2\n>>> s['a']\n2\n>>> del s.a\n>>> s.a\n...\nAttributeError: 'a'\n__getitem__\ngetitem用于通过下标[]的形式来获取对象中的元素，下面我们通过重写__getitem__来实现一个自己的list。\nclass MyList(object):\n    def __init__(self, *args):\n        self.numbers = args\n\n    def __getitem__(self, item):\n        return self.numbers[item]\n\n\nmy_list = MyList(1, 2, 3, 4, 6, 5, 3)\nprint my_list[2]\n这个实现非常的简陋，不支持slice和step等功能，请读者自行改进，这里我就不重复了。\n应用\n下面是参考requests库中对于__getitem__的一个使用，我们定制了一个忽略属性大小写的字典类。\n程序有些复杂，我稍微解释一下：由于这里比较简单，没有使用描述符的需求，所以使用了@property装饰器来代替，lower_keys的功能是将实例字典中的键全部转换成小写并且存储在字典self._lower_keys中。重写了__getitem__方法，以后我们访问某个属性首先会将键转换为小写的方式，然后并不会直接访问实例字典，而是会访问字典self._lower_keys去查找。赋值/删除操作的时候由于实例字典会进行变更，为了保持self._lower_keys和实例字典同步，首先清除self._lower_keys的内容，以后我们重新查找键的时候再调用__getitem__的时候会重新新建一个self._lower_keys。\nclass CaseInsensitiveDict(dict):\n\n    @property\n    def lower_keys(self):\n        if not hasattr(self, '_lower_keys') or not self._lower_keys:\n            self._lower_keys = dict((k.lower(), k) for k in self.keys())\n        return self._lower_keys\n\n    def _clear_lower_keys(self):\n        if hasattr(self, '_lower_keys'):\n            self._lower_keys.clear()\n\n    def __contains__(self, key):\n        return key.lower() in self.lower_keys\n\n    def __getitem__(self, key):\n        if key in self:\n            return dict.__getitem__(self, self.lower_keys[key.lower()])\n\n    def __setitem__(self, key, value):\n        dict.__setitem__(self, key, value)\n        self._clear_lower_keys()\n\n    def __delitem__(self, key):\n        dict.__delitem__(self, key)\n        self._lower_keys.clear()\n\n    def get(self, key, default=None):\n        if key in self:\n            return self[key]\n        else:\n            return default\n我们来调用一下这个类：\n>>> d = CaseInsensitiveDict()\n>>> d['ziwenxie'] = 'ziwenxie'\n>>> d['ZiWenXie'] = 'ZiWenXie'\n\n>>> print(d)\n{'ZiWenXie': 'ziwenxie', 'ziwenxie': 'ziwenxie'}\n>>> print(d['ziwenxie'])\nziwenxie\n\n# d['ZiWenXie'] => d['ziwenxie']\n>>> print(d['ZiWenXie'])\nziwenxie\nReferences\nHOWTO-GUIDEDOCUMENTATIONIBM-DEVELOPWORKSZHIHUREQUESTSWEBPY\nContact\nGitHub: https://github.com/ziwenxieBlog: https://www.ziwenxie.site\n本文为作者原创，转载请于文章开头明显处声明博客出处:)\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "7"}