{"title": "绕过前端加密进行爆破 - 个人文章 ", "index": "安全,javascript,python", "content": "1.概述\n现在很多web 在登陆的过程中会用 js 对账号密码进行加密之后再进行传输，我们利用代理工具抓到的包看到账号密码是密文而非明文，这样对批量爆破或者撞库进行传参就会产生障碍，所以这片文章对遇到这类问题如何解决思路的一个分析。\n\n2.思路\n一般有两种思路，其一对 js 进行分析，拆解js 的加密算法，利用自己熟悉的语言进行重写，这里使用 python；其二是利用相应的工具或者模块执行该 js 文件，拿到输出结果即可，这里使用 python 自带的execjs。现在举一个例子加以说明。\n2.1 分析加密算法\n这里刚好有个 js 文件\n/**\n *@param username\n *@param passwordOrgin\n *@return encrypt password for $username who use orign password $passwordOrgin\n *\n **/\n\nfunction encrypt(username, passwordOrgin) {\n    return hex_sha1(username+hex_sha1(passwordOrgin));\n}\n\n\n\nfunction hex_sha1(s, hexcase) {\n    if (!(arguments) || !(arguments.length) || arguments.length < 1) {\n        return binb2hex(core_sha1(AlignSHA1(\"aiact@163.com\")), true);\n    } else {\n        if (arguments.length == 1) {\n            return binb2hex(core_sha1(AlignSHA1(arguments[0])), true);\n        } else {\n            return binb2hex(core_sha1(AlignSHA1(arguments[0])), arguments[1]);\n        }\n    }\n   // return binb2hex(core_sha1(AlignSHA1(s)),hexcase);\n}\n/**/\n/*\n * Perform a simple self-test to see if the VM is working\n */\nfunction sha1_vm_test() {\n    return hex_sha1(\"abc\",false) == \"a9993e364706816aba3e25717850c26c9cd0d89d\";\n}\n/**/\n/*\n * Calculate the SHA-1 of an array of big-endian words, and a bit length\n */\nfunction core_sha1(blockArray) {\n    var x = blockArray;  //append padding\n    var w = Array(80);\n    var a = 1732584193;\n    var b = -271733879;\n    var c = -1732584194;\n    var d = 271733878;\n    var e = -1009589776;\n    for (var i = 0; i < x.length; i += 16) {  //每次处理512位 16*32\n        var olda = a;\n        var oldb = b;\n        var oldc = c;\n        var oldd = d;\n        var olde = e;\n        for (var j = 0; j < 80; j += 1) {  //对每个512位进行80步操作\n            if (j < 16) {\n                w[j] = x[i + j];\n            } else {\n                w[j] = rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);\n            }\n            var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)), safe_add(safe_add(e, w[j]), sha1_kt(j)));\n            e = d;\n            d = c;\n            c = rol(b, 30);\n            b = a;\n            a = t;\n        }\n        a = safe_add(a, olda);\n        b = safe_add(b, oldb);\n        c = safe_add(c, oldc);\n        d = safe_add(d, oldd);\n        e = safe_add(e, olde);\n    }\n    return new Array(a, b, c, d, e);\n}\n/**/\n/*\n * Perform the appropriate triplet combination function for the current iteration\n * 返回对应F函数的值\n */\nfunction sha1_ft(t, b, c, d) {\n    if (t < 20) {\n        return (b & c) | ((~b) & d);\n    }\n    if (t < 40) {\n        return b ^ c ^ d;\n    }\n    if (t < 60) {\n        return (b & c) | (b & d) | (c & d);\n    }\n    return b ^ c ^ d;  //t<80\n}\n/**/\n/*\n\n * Determine the appropriate additive constant for the current iteration\n * 返回对应的Kt值\n */\nfunction sha1_kt(t) {\n    return (t < 20) ? 1518500249 : (t < 40) ? 1859775393 : (t < 60) ? -1894007588 : -899497514;\n}\n/**/\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n * 将32位数拆成高16位和低16位分别进行相加，从而实现 MOD 2^32 的加法\n */\nfunction safe_add(x, y) {\n    var lsw = (x & 65535) + (y & 65535);\n    var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n    return (msw << 16) | (lsw & 65535);\n}\n/**/\n/*\n * Bitwise rotate a 32-bit number to the left.\n * 32位二进制数循环左移\n */\nfunction rol(num, cnt) {\n    return (num << cnt) | (num >>> (32 - cnt));\n}\n/**/\n/*\n\n * The standard SHA1 needs the input string to fit into a block\n\n * This function align the input string to meet the requirement\n\n */\nfunction AlignSHA1(str) {\n    var nblk = ((str.length + 8) >> 6) + 1, blks = new Array(nblk * 16);\n    for (var i = 0; i < nblk * 16; i += 1) {\n        blks[i] = 0;\n    }\n    for (i = 0; i < str.length; i += 1) {\n        blks[i >> 2] |= str.charCodeAt(i) << (24 - (i & 3) * 8);\n    }\n    blks[i >> 2] |= 128 << (24 - (i & 3) * 8);\n    blks[nblk * 16 - 1] = str.length * 8;\n    return blks;\n}\n/**/\n/*\n * Convert an array of big-endian words to a hex string.\n */\nfunction binb2hex(binarray, hexcase) {\n    var hex_tab = hexcase ? \"0123456789ABCDEF\" : \"0123456789abcdef\";\n    var str = \"\";\n    for (var i = 0; i < binarray.length * 4; i += 1) {\n        str += hex_tab.charAt((binarray[i >> 2] >> ((3 - i % 4) * 8 + 4)) & 15) + hex_tab.charAt((binarray[i >> 2] >> ((3 - i % 4) * 8)) & 15);\n    }\n    return str;\n}\n\n进过加密的密码的密文如图所示\n\nfunction encrypt(username, passwordOrgin) {\n    return hex_sha1(username+hex_sha1(passwordOrgin));\n}\n对代码的分析中我们得出该加密就是一个标准的 sha1加密，Password的密文是先对password明文进行 sha1再组合用户名，然后再进行一次 sha1产生。只是通过具体的代码分析，每次 sha1之后会对字符串所有的小写字母进行大写转换。因为有两次 sha1，所有有两次小写字母转换成大写字母。\n分析清楚之后利用 python 重新写python 有自带的 sha1模块\nimport hashlib\n\ndef encrypt(username, passwordOrgin):\n    return hex_sha1(username + hex_sha1(passwordOrgin))\n\n\ndef hex_sha1(src):\n    sha = hashlib.sha1(src)\n    encrypts = sha.hexdigest()\n    return encrypts.upper()\n\nprint encrypt('admin','admin')\n\n结果为：EDB811C7CBEEEE8DB436AB8441750044C893C222，跟图片中结果一致\n\n2.2 执行 js，不关心 js 具体的加密过程\n先安装 execjs\n$ pip install PyExecJS\nor\n$ easy_install PyExecJS\n将 js 保存到本地\n#coding:utf-8\nfrom selenium import webdriver\nimport  execjs\n\nwith open ('test.js','r') as jj:\n    source = jj.read()\n    phantom = execjs.get('PhantomJS')\n    getpass = phantom.compile(source)\n    mypass = getpass.call('encrypt', 'admin','admin')\n    print mypass\n    \n    \n结果为：EDB811C7CBEEEE8DB436AB8441750044C893C222，跟图片中结果一致\n3. note\n一下链接中还有其他方式，可以参考http://www.freebuf.com/articl...\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "3"}