{"title": "【Leetcode】62. 不同路径 - LeetCode题解 ", "index": "mysql,redis,spring,java,python", "content": "作者: 码蹄疾毕业于哈尔滨工业大学。 小米广告第三代广告引擎的设计者、开发者；负责小米应用商店、日历、开屏广告业务线研发；主导小米广告引擎多个模块重构；关注推荐、搜索、广告领域相关知识;\n题目\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。\n问总共有多少条不同的路径？\n\n例如，上图是一个7 x 3 的网格。有多少可能的路径？\n说明：m 和 n 的值均不超过 100。\n示例 1:\n输入: m = 3, n = 2\n输出: 3\n解释:\n从左上角开始，总共有 3 条路径可以到达右下角。\n1. 向右 -> 向右 -> 向下\n2. 向右 -> 向下 -> 向右\n3. 向下 -> 向右 -> 向右\n示例 2:\n输入: m = 7, n = 3\n输出: 28\n题解\n这道题拿到题目我觉得大家的第一反应都是这应该是递归的题目,因为我们可以转化为子问题，但是这样暴力肯定会超时,就不用尝试了。其实在该题递归的方法就是从上面到下面不断的去尝试,如果我们能记住之前的结果,就对我们下一步有帮助,所以想到了DP的方法。格子中的数字代表当前的方法.\n初始状态\n\n当前这个状态只和左边和上边的格子有关系.\n\n依次求解\n\n于是我们可以得到状态转移方程：\nways[i][j] = ways[i-1][j] + ways[i][j-1];\njava代码\npublic class Solution {\n    public int uniquePaths(int m, int n) {\n        int[][] ways = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == 0 || j == 0) ways[i][j] = 1;\n                else ways[i][j] = ways[i-1][j] + ways[i][j-1];\n            }\n        }\n        return ways[m-1][n-1];\n    }\n}\n优化\n上面图3我们在求解的时候,我们是一行一行求解的,实际上我们只需要记录遍历到(i, j)这个位置的时候当前行有几种路径,如果遍历到(i, m-1)的时候,替换掉这一行对应列的路径即可，于是状态转移方程编程:res[j] = res[j] + res[j-1]\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        if (m <= 0 || n <= 0) {\n            return 0;\n        }\n        int[] res = new int[n];\n        res[0] = 1;\n        for (int i = 0; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                res[j] += res[j - 1];\n                System.out.println(\"i=\" + i + \"_\" + \"j=\" + j + \":\" + Arrays.toString(res));\n            }\n        }\n        return res[n - 1];\n    }\n}\n有的同学可能还是不理解,我在代码里面打印了一些信息方便理解：\ni=0_j=1:[1, 1, 0, 0, 0, 0, 0]\ni=0_j=2:[1, 1, 1, 0, 0, 0, 0]\ni=0_j=3:[1, 1, 1, 1, 0, 0, 0]\ni=0_j=4:[1, 1, 1, 1, 1, 0, 0]\ni=0_j=5:[1, 1, 1, 1, 1, 1, 0]\ni=0_j=6:[1, 1, 1, 1, 1, 1, 1] //只记录到这一行的信息\ni=1_j=1:[1, 2, 1, 1, 1, 1, 1]\ni=1_j=2:[1, 2, 3, 1, 1, 1, 1]\ni=1_j=3:[1, 2, 3, 4, 1, 1, 1]\ni=1_j=4:[1, 2, 3, 4, 5, 1, 1]\ni=1_j=5:[1, 2, 3, 4, 5, 6, 1]\ni=1_j=6:[1, 2, 3, 4, 5, 6, 7] //只记录到这一行的信息\ni=2_j=1:[1, 3, 3, 4, 5, 6, 7]\ni=2_j=2:[1, 3, 6, 4, 5, 6, 7]\ni=2_j=3:[1, 3, 6, 10, 5, 6, 7]\ni=2_j=4:[1, 3, 6, 10, 15, 6, 7]\ni=2_j=5:[1, 3, 6, 10, 15, 21, 7]\ni=2_j=6:[1, 3, 6, 10, 15, 21, 28] //只记录到这一行的信息\ni=3_j=1:[1, 4, 6, 10, 15, 21, 28]\ni=3_j=2:[1, 4, 10, 10, 15, 21, 28]\ni=3_j=3:[1, 4, 10, 20, 15, 21, 28]\ni=3_j=4:[1, 4, 10, 20, 35, 21, 28]\ni=3_j=5:[1, 4, 10, 20, 35, 56, 28]\ni=3_j=6:[1, 4, 10, 20, 35, 56, 84] //只记录到这一行的信息\nMath\n这个题其实可以用排列组合的方式来做。这其实是最开始想到的方法。以模拟的[4, 7]的例子,每一条路径：\n\n向右的肯定有6步;\n向左的肯定有3步;\n\n问题即为:c(9,3) = (9  8  7) / (1  2  3) = 84\n组合数公式：c(m,n) = m! / (n! * (m - n)!)\njava代码\njava直接套用公式会越界,下面结果我用long存储:\n1!=1\n2!=2\n3!=6\n4!=24\n5!=120\n6!=720\n7!=5040\n8!=40320\n9!=362880\n10!=3628800\n11!=39916800\n12!=479001600\n13!=6227020800\n14!=87178291200\n15!=1307674368000\n16!=20922789888000\n17!=355687428096000\n18!=6402373705728000\n19!=121645100408832000\n20!=2432902008176640000\n21!=-4249290049419214848\n22!=-1250660718674968576\n23!=8128291617894825984\n24!=-7835185981329244160\n需要稍微化简一下,化简的过程就是我求解c(9,3)的第二步骤。\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        double dom = 1;\n        double dedom = 1;\n        int small = m < n ? m - 1 : n - 1;\n        int big = m < n ? n - 1 : m - 1;\n        for (int i = 1; i <= small; i++) {\n            dedom *= i;\n            dom *= small + big + 1 - i;\n        }\n        return (int) (dom / dedom);\n    }\n}\npython代码\npython代码就比较凶残了,一行代码搞定:\nclass Solution:\n    def uniquePaths(self, m, n):\n        return int(math.factorial(m + n - 2) / math.factorial(m -1) / math.factorial(n-1))\n贴一下DP版本的代码\nclass Solution:\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if m <= 0 or n <= 0:\n            return 0\n        res = [0 for _ in range(0, n)]\n        res[0] = 1\n        for i in range(0, m):\n            for j in range(1, n):\n                res[j] += res[j-1]\n        return res[n-1]\n热门阅读\n\n【Leetcode】61.旋转链表\n【Leetcode】60. 第k个排列\n\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}