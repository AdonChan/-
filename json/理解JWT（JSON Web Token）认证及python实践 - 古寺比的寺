{"title": "理解JWT（JSON Web Token）认证及python实践 - 古寺比的寺 ", "index": "jwt,oauth2.0,python", "content": "最近想做个小程序，需要用到授权认证流程。以前项目都是用的 OAuth2 认证，但是Sanic 使用OAuth2 不太方便，就想试一下 JWT 的认证方式。这一篇主要内容是 JWT 的认证原理，以及python 使用 jwt 认识的实践。\n几种常用的认证机制\nHTTP Basic Auth\nHTTP Basic Auth 在HTTP中，基本认证是一种用来允许Web浏览器或其他客户端程序在请求时提供用户名和口令形式的身份凭证的一种登录验证方式，通常用户名和明码会通过HTTP头传递。\n在发送之前是以用户名追加一个冒号然后串接上口令，并将得出的结果字符串再用Base64算法编码。例如，提供的用户名是Aladdin、口令是open sesame，则拼接后的结果就是Aladdin:open sesame，然后再将其用Base64编码，得到QWxhZGRpbjpvcGVuIHNlc2FtZQ==。最终将Base64编码的字符串发送出去，由接收者解码得到一个由冒号分隔的用户名和口令的字符串。\n优点\n基本认证的一个优点是基本上所有流行的网页浏览器都支持基本认证。\n缺点\n由于用户名和密码都是Base64编码的，而Base64编码是可逆的，所以用户名和密码可以认为是明文。所以只有在客户端和服务器主机之间的连接是安全可信的前提下才可以使用。\n接下来我们看一个更加安全也适用范围更大的认证方式 OAuth。\nOAuth\nOAuth 是一个关于授权（authorization）的开放网络标准。允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。现在的版本是2.0版。\n严格来说，OAuth2不是一个标准协议，而是一个安全的授权框架。它详细描述了系统中不同角色、用户、服务前端应用（比如API），以及客户端（比如网站或移动App）之间怎么实现相互认证。\n名词定义\n\nThird-party application: 第三方应用程序，又称\"客户端\"（client）\nHTTP service：HTTP服务提供商\nResource Owner：资源所有者，通常称\"用户\"（user）。\nUser Agent：用户代理，比如浏览器。\nAuthorization server：认证服务器，即服务提供商专门用来处理认证的服务器。\nResource server：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。\n\nOAuth 2.0 运行流程如图：\n\n（A）用户打开客户端以后，客户端要求用户给予授权。（B）用户同意给予客户端授权。（C）客户端使用上一步获得的授权，向认证服务器申请令牌。（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。（E）客户端使用令牌，向资源服务器申请获取资源。（F）资源服务器确认令牌无误，同意向客户端开放资源。\n优点\n快速开发实施代码量小维护工作减少如果设计的API要被不同的App使用，并且每个App使用的方式也不一样，使用OAuth2是个不错的选择。\n缺点：OAuth2是一个安全框架，描述了在各种不同场景下，多个应用之间的授权问题。有海量的资料需要学习，要完全理解需要花费大量时间。OAuth2不是一个严格的标准协议，因此在实施过程中更容易出错。\n了解了以上两种方式后，现在终于到了本篇的重点，JWT 认证。\nJWT 认证\nJson web token (JWT), 根据官网的定义，是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。\nJWT 特点\n\n体积小，因而传输速度快\n传输方式多样，可以通过URL/POST参数/HTTP头部等方式传输\n严格的结构化。它自身（在 payload 中）就包含了所有与用户相关的验证消息，如用户可访问路由、访问有效期等信息，服务器无需再去连接数据库验证信息的有效性，并且 payload 支持为你的应用而定制化。\n支持跨域验证，可以应用于单点登录。\n\nJWT原理\nJWT是Auth0提出的通过对JSON进行加密签名来实现授权验证的方案，编码之后的JWT看起来是这样的一串字符：\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ  \n由 . 分为三段，通过解码可以得到：\n1. 头部（Header）\n// 包括类别（typ）、加密算法（alg）；\n{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\"\n}\njwt的头部包含两部分信息：\n\n声明类型，这里是jwt\n声明加密的算法 通常直接使用 HMAC SHA256\n\n然后将头部进行base64加密（该加密是可以对称解密的)，构成了第一部分。\neyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9\n2. 载荷（payload）\n载荷就是存放有效信息的地方。这些有效信息包含三个部分：\n\n标准中注册声明\n公共的声名\n私有的声明\n\n公共的声明 ：公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密。\n私有的声明 ：私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。\n下面是一个例子：\n// 包括需要传递的用户信息；\n{ \"iss\": \"Online JWT Builder\", \n  \"iat\": 1416797419, \n  \"exp\": 1448333419, \n  \"aud\": \"www.gusibi.com\", \n  \"sub\": \"uid\", \n  \"nickname\": \"goodspeed\", \n  \"username\": \"goodspeed\", \n  \"scopes\": [ \"admin\", \"user\" ] \n}\n\niss: 该JWT的签发者，是否使用是可选的；\nsub: 该JWT所面向的用户，是否使用是可选的；\naud: 接收该JWT的一方，是否使用是可选的；\nexp(expires): 什么时候过期，这里是一个Unix时间戳，是否使用是可选的；\niat(issued at): 在什么时候签发的(UNIX时间)，是否使用是可选的；\n\n其他还有：\n\nnbf (Not Before)：如果当前时间在nbf里的时间之前，则Token不被接受；一般都会留一些余地，比如几分钟；，是否使用是可选的；\njti: jwt的唯一身份标识，主要用来作为一次性token，从而回避重放攻击。\n\n将上面的JSON对象进行base64编码可以得到下面的字符串。这个字符串我们将它称作JWT的Payload（载荷）。\neyJpc3MiOiJPbmxpbmUgSldUIEJ1aWxkZXIiLCJpYXQiOjE0MTY3OTc0MTksImV4cCI6MTQ0ODMzMzQxOSwiYXVkIjoid3d3Lmd1c2liaS5jb20iLCJzdWIiOiIwMTIzNDU2Nzg5Iiwibmlja25hbWUiOiJnb29kc3BlZWQiLCJ1c2VybmFtZSI6Imdvb2RzcGVlZCIsInNjb3BlcyI6WyJhZG1pbiIsInVzZXIiXX0\n信息会暴露：由于这里用的是可逆的base64 编码，所以第二部分的数据实际上是明文的。我们应该避免在这里存放不能公开的隐私信息。\n3. 签名（signature）\n// 根据alg算法与私有秘钥进行加密得到的签名字串；\n// 这一段是最重要的敏感信息，只能在服务端解密；\nHMACSHA256(  \n    base64UrlEncode(header) + \".\" +\n    base64UrlEncode(payload),\n    SECREATE_KEY\n)\njwt的第三部分是一个签证信息，这个签证信息由三部分组成：\n\nheader (base64后的)\npayload (base64后的)\nsecret\n\n将上面的两个编码后的字符串都用句号.连接在一起（头部在前），就形成了:\neyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJKb2huIFd1IEpXVCIsImlhdCI6MTQ0MTU5MzUwMiwiZXhwIjoxNDQxNTk0NzIyLCJhdWQiOiJ3d3cuZXhhbXBsZS5jb20iLCJzdWIiOiJqcm9ja2V0QGV4YW1wbGUuY29tIiwiZnJvbV91c2VyIjoiQiIsInRhcmdldF91c2VyIjoiQSJ9\n最后，我们将上面拼接完的字符串用HS256算法进行加密。在加密的时候，我们还需要提供一个密钥（secret）。如果我们用 secret 作为密钥的话，那么就可以得到我们加密后的内容:\npq5IDv-yaktw6XEa5GEv07SzS9ehe6AcVSdTj0Ini4o\n将这三部分用.连接成一个完整的字符串,构成了最终的jwt:\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJPbmxpbmUgSldUIEJ1aWxkZXIiLCJpYXQiOjE0MTY3OTc0MTksImV4cCI6MTQ0ODMzMzQxOSwiYXVkIjoid3d3Lmd1c2liaS5jb20iLCJzdWIiOiIwMTIzNDU2Nzg5Iiwibmlja25hbWUiOiJnb29kc3BlZWQiLCJ1c2VybmFtZSI6Imdvb2RzcGVlZCIsInNjb3BlcyI6WyJhZG1pbiIsInVzZXIiXX0.pq5IDv-yaktw6XEa5GEv07SzS9ehe6AcVSdTj0Ini4o\n签名的目的：签名实际上是对头部以及载荷内容进行签名。所以，如果有人对头部以及载荷的内容解码之后进行修改，再进行编码的话，那么新的头部和载荷的签名和之前的签名就将是不一样的。而且，如果不知道服务器加密的时候用的密钥的话，得出来的签名也一定会是不一样的。这样就能保证token不会被篡改。\ntoken 生成好之后，接下来就可以用token来和服务器进行通讯了。\n下图是client 使用 JWT 与server 交互过程:\n\n这里在第三步我们得到 JWT 之后，需要将JWT存放在 client，之后的每次需要认证的请求都要把JWT发送过来。（请求时可以放到 header 的 Authorization ）\nJWT 使用场景\nJWT的主要优势在于使用无状态、可扩展的方式处理应用中的用户会话。服务端可以通过内嵌的声明信息，很容易地获取用户的会话信息，而不需要去访问用户或会话的数据库。在一个分布式的面向服务的框架中，这一点非常有用。\n但是，如果系统中需要使用黑名单实现长期有效的token刷新机制，这种无状态的优势就不明显了。\n优点\n快速开发不需要cookieJSON在移动端的广泛应用不依赖于社交登录相对简单的概念理解\n缺点\nToken有长度限制Token不能撤销需要token有失效时间限制(exp)\npython 使用JWT实践\n我基本是使用 python 作为服务端语言，我们可以使用 pyjwt：https://github.com/jpadilla/pyjwt/\n使用比较方便，下边是我在应用中使用的例子：\nimport jwt\nimport time\n\n# 使用 sanic 作为restful api 框架 \ndef create_token(request):\n    grant_type = request.json.get('grant_type')\n    username = request.json['username']\n    password = request.json['password']\n    if grant_type == 'password':\n        account = verify_password(username, password)\n    elif grant_type == 'wxapp':\n        account = verify_wxapp(username, password)\n    if not account:\n        return {}\n    payload = {\n        \"iss\": \"gusibi.com\",\n         \"iat\": int(time.time()),\n         \"exp\": int(time.time()) + 86400 * 7,\n         \"aud\": \"www.gusibi.com\",\n         \"sub\": account['_id'],\n         \"username\": account['username'],\n         \"scopes\": ['open']\n    }\n    token = jwt.encode(payload, 'secret', algorithm='HS256')\n    return True, {'access_token': token, 'account_id': account['_id']}\n    \n\ndef verify_bearer_token(token):\n    #  如果在生成token的时候使用了aud参数，那么校验的时候也需要添加此参数\n    payload = jwt.decode(token, 'secret', audience='www.gusibi.com', algorithms=['HS256'])\n    if payload:\n        return True, token\n    return False, token\n这里，我们可以使用 jwt 直接生成 token，不用手动base64加密和拼接。\n详细代码可以参考 gusibi/Metis: 一个测试类小程序（包含前后端代码）。\n这个项目中，api 使用 python sanic，文档使用 swagger-py-codegen 生成，提供 swagger ui。\n现在可以使用 swagger ui 来测试jwt。\n\n总结\n这一篇主要介绍了 jwt 的原理、验证步骤，最后是使用 pyjwt 包演示 生成token以及校验token的方法。\n以上提到的包可以在公号回复关键字获取地址\n预告，下一篇是介绍小程序中使用 JWT 的认证流程及实现。\n参考链接\n\nHTTP基本认证\n访问需要HTTP Basic Authentication认证的资源的各种语言的实现\n理解OAuth 2.0\nOAuth 2和JWT - 如何设计安全的API？\nSecuring RESTful Web Services with OAuth2\nServer 端的认证——拥抱 \nJSON Web Token - 在Web应用间安全地传递信息\n八幅漫画理解使用JSON Web\n基于Token的WEB后台认证机制\n什么是 JWT -- JSON WEB TOKEN\n\n\n最后，感谢女朋友支持。\n\n\n欢迎关注(April_Louisa)\n请我喝芬达\n\n\n\n\n\n\n\n                ", "mainLikeNum": ["24 "], "mainBookmarkNum": "175"}