{"title": "当我们调用yield，它究竟做了什么 - 小杰控的清水道场 ", "index": "python", "content": "显然，要理解yield，首先要了解迭代器（iterator），接着了解什么是生成器(generator)。\n迭代器\n通俗的讲，迭代器就是可以逐个访问的容器，而逐个逐步访问的过程成为迭代。\niterator = [item for item in range(5)]\nfor i in iterator:\n    print(i)\n0\n1\n2\n3\n4\n\n生成器\n上述代码中，iterator就是一个迭代器，for循环部分就是迭代过程。生成器同样也是可供迭代访问的容器，与迭代器不同的是，生成器中的元素不会一次性存入内润中，而是一边迭代一边生成。\ngenerator = (item for item in range(5))\nfor i in generator:\n    print(i)\n0\n1\n2\n3\n4\n\n迭代器和生成器的执行效率\n因为生成器边迭代边生成，所以占用内存极少，执行效率也更高。\ndef go_thru_iterator(item_len):\n    iterator = [item for item in range(item_len)]\n    for i in iterator:\n        pass\ndef go_thru_generator(item_len):\n    generator = (item for item in range(item_len))\n    for i in generator:\n        pass\n%time go_thru_iterator(100000000)\nCPU times: user 12 s, sys: 11.8 s, total: 23.8 s\nWall time: 23.8 s\n\n\n\n%time go_thru_generator(100000000)\nCPU times: user 12.7 s, sys: 0 ns, total: 12.7 s\nWall time: 12.6 s\n\n\nyield\nyield的使用和return的使用没有什么区别，只是yield会返回一个生成器。当代码执行到yield时，该函数会返回yield之后的值，并在原地等待下一次迭代；当执行到下一次迭代时，代码接着上一次等待的地方执行：\n\n若使用生成器的send方法，则yield语句的返回值send中的参数\n若使用next函数迭代，则在yield的返回值为None\n\n注： next相当于mgen.send(None)，但mgen.send在生成器第一次迭代时不可调用\ndef create_generator():\n    mylist = range(3)\n    for i in mylist:\n        ret = yield i * i\n        print('ret:', ret)\nmgen = create_generator()\nnext(mgen)\n0\n\nnext(mgen)\nret: None\n1\n\nmgen.send('The yield return value.')\nret: The yield return value.\n4\n\ntry:\n    next(mgen)\nexcept StopIteration:\n    print('Already arrive the end of the generator element.')\nret: None\nAlready arrive the end of the generator element.\n\n原文地址：github:jasonTu/python-material-collection 当我们调用yield，它究竟做了什么\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}