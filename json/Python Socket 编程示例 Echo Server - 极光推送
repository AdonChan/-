{"title": "Python Socket 编程示例 Echo Server - 极光推送 ", "index": "python", "content": "简评：我们已经从「Python Socket 编程概览」了解了 socket API 的概述以及客户端和服务器的通信方式，接下来让我们创建第一个客户端和服务器，我们将从一个简单的实现开始，服务器将简单地回显它接收到客户端的任何内容。本文将详细解释服务器部分的代码。\n下面是服务器代码保存到 echo-server.py文件:\n#!/usr/bin/env python3\n\nimport socket\n\nHOST = '127.0.0.1'  # Standard loopback interface address (localhost)\nPORT = 65432        # Port to listen on (non-privileged ports are > 1023)\n\nwith socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n    s.bind((HOST, PORT))\n    s.listen()\n    conn, addr = s.accept()\n    with conn:\n        print('Connected by', addr)\n        while True:\n            data = conn.recv(1024)\n            if not data:\n                break\n            conn.sendall(data)\nsocket.socket()创建一个支持上下文管理器类型的 socket 对象，因此可以在 with 语句中使用它，没有必要去调用 s.close()：\nwith socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n    pass  # Use the socket object without calling s.close().\n传递给socket()的参数指定地址族和 socket 类型。 AF_INET 指的是 IPv4 的网络地址。 SOCK_STREAM是 TCP 的 socket 类型，TCP 用于在网络中传输消息。\n\nbind()用于将 socket 与特定网络接口和端口号相关联：\nHOST = '127.0.0.1'  # Standard loopback interface address (localhost)\nPORT = 65432        # Port to listen on (non-privileged ports are > 1023)\n\n# ...\n\ns.bind((HOST, PORT))\n传递给bind()的值取决于 socket 的地址族。在这个例子中，我们使用的是socket.AF_INET(IPv4)所以它接受一个(host, port)元组。\nhost 可以是主机名、IP 地址或空字符串。如果使用 IP 地址，则主机应为 IPv4 格式的地址字符串，127.0.0.1 是环回接口的标准 IPv4 地址，因此只有主机上的进程才能连接到服务器。如果传递空字符串，则服务器将接受所有可用 IPv4 接口上的连接。\nport 应为 1-65535 之间的整数（0 被保留），它是接受来自客户端连接的 TCP 端口号，如果端口号 <1024，某些系统可能需要超级用户权限。\nlisten()使服务器能够 accept()连接，这使它成为一个「listening」socket：\ns.listen()\nconn, addr = s.accept()\naccept()阻塞并等待传入请求连接。当客户端连接时，它返回一个表示连接的 socket 对象和一个保存客户端地址的元组，该元组包含用于 IPv4 连接的(host, port)或用于 IPv6的(host, port, flowinfo, scopeid)。\n必须要理解的一件事是我们现在有一个来自accept()的新 socket 对象，这很重要，因为它是用于与客户端通信的 socket，它与服务器用于接受新连接的侦听 socket 不同：\nconn, addr = s.accept()\nwith conn:\n    print('Connected by', addr)\n    while True:\n        data = conn.recv(1024)\n        if not data:\n            break\n        conn.sendall(data)\n从accept()获取客户端 socket 对象conn后，使用无限循环来循环阻塞对 conn.recv()的调用。这将读取客户端发送的任何数据，并使用 conn.sendall()将其回送回来。\n如果conn.recv()返回一个空字节对象b''，则客户端关闭连接并终止循环。 with 语句与 conn 一起使用以自动关闭块末尾的 socket。\n原文：Socket Programming in Python (Guide) – Real Python\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}