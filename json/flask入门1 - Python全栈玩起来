{"title": "flask入门1 - Python全栈玩起来 ", "index": "python,flask", "content": "flask\n每天的内容\n\nflask跑起来\n模板引擎\nflask表单\n文件上传邮件发送\nflask-sqlalchemy\n\n一、web框架的简介\nM   模型 负责数据的操作\nV    视图      负责数据的展示\nC    控制器   控制你的M的操作以及视图模板的渲染\n在python中叫做MVT\nM   模型 负责数据的操作\nV      控制你的M的操作以及视图模板的渲染  业务逻辑的操作\nT      templates  模板 负责数据的展示\n二、架构\nBS  browser-》server\nCS  client-》server\n三、FLASK\n概念： flask是一个非常小的web框架     被称为微型框架   只提供了一个强健的核心 其它的都是通过第三方扩展库来实现\n组成：\n\n调试 路由 WSGI\n模板引擎 jinja2  (就是由flask核心人员开发的模板引擎)\n\n使用：\n安装  pip install flask\n实例\nfrom flask import Flask\n\napp = Flask(__name__) #实例化flask\n\n#路由地址 根据用户不同的url进行处理\n@app.route('/')\ndef index():#处理当前请求的函数\n    return 'Hello Flask'\n\nif __name__ == '__main__':\n    app.run() #运行当前的flask\n四、视图函数\n(1) 无参路由\n#路由地址和视图函数名称 是否同名没有关系\n#http://127.0.0.1:5000/test/\n@app.route('/test/') #路由地址末尾的/建议加上\ndef test():\n    return '我是测试使用的视图函数'\n(2) 带一个参数的路由\nhttp://127.0.0.1:5000/page/10/\n@app.route('/page/<pagenum>/') #参数的语法格式 /路由名称/<形参名>/\ndef page(pagenum):\n    return '当前的页码为{}'.format(pagenum)\n(3) 带多个参数\n#带多个参数\n# http://127.0.0.1:5000/arg/10/zhansgan/\n@app.route('/arg/<age>/<name>/')\ndef getarg(age,name):\n    return '我叫{} 我见年{}岁了'.format(name,age)\n# http://127.0.0.1:5000/arg/zhansgan_10/\n@app.route('/arg/<name>_<age>/')\ndef getarg(age,name):\n    return '我叫{} 我见年{}岁了'.format(name,age)\n(4) 限制参数的类型\n#参数类型\n# @app.route('/argtype/<arg>/')\n# @app.route('/argtype/<int:arg>/') #限定参数类型为int\n# @app.route('/argtype/<float:arg>/') #限定参数类型为float\n# @app.route('/argtype/<string:arg>/') #限定参数类型为string 默认就是字符串\n@app.route('/argtype/<path:arg>/') #其实path就是string 但是path会将路由地址后面的所有的路由或者值都认为是一个值 /不在作为分隔符来使用\ndef argtype(arg):\n    print(type(arg))\n    print(arg)\n    return '获取参数类型的视图函数'\n注意\n\n路由地址末尾的/建议加上  因为如果输入的时候没有加默认的/浏览器会自动帮你加上\n形参名字写在路由的<> 中间\n参数默认类型都为string​\n\n\n五、视图函数的响应\n(1) return 字符串进行响应\n@app.route('/response/')\ndef res():\n    return '我是响应',404 #响应一个指定标准的状态码\n(2) 通过make_response构造响应\n导入：\nfrom flask import  make_response\n@app.route('/make_response/')\ndef makeResponse():\n    res = make_response('我是响应的内容')\n    # res = make_response('我是响应的内容',404)\n    return res\n六、重定向 redirect\n作用： 从一个地址跳向另外一个地址\n导入\nfrom flask import redirect\n实例\n@app.route('/')\ndef index():#处理当前请求的函数\n    return 'Hello Flask'\n\n#重定向\n@app.route('/redirect/')\ndef redirect_index():\n    return redirect('/') #参数为路由地址\n    return redirect('/argtype/redirect_index/') #带参数路由地址的重定向\nurl_for  通过视图函数名称 反向构造出路由地址\n导入\nfrom flask import redirect,url_for\n实例\n@app.route('/redirect/')\ndef redirect_index():\n    url = url_for('test')\n    url = url_for('getarg',name='zhangsan',age=18) #带多个参数\n      #@app.route('/arg/<name>_<age>/')\n      #def getarg(age,name):\n    return url #/test/\n注意：\n如果给定的视图函数名称不存在 则抛出异常\nurl_for 和 redirect 组合使用\n@app.route('/redirect/')\ndef redirect_index():\n    return redirect(url_for('test'))\n    return redirect(url_for('getarg',name='zhangsan',age=18)) #带多个参数\n七、abort 终止\n概念：\n在视图函数中处理的时候 可以使用abort抛出指定状态码的错误  下面代码不在执行  \n需要抛出标准http的状态码\nfrom flask import abort\n实例\n@app.route('/abort/')\ndef my_abort():\n    # abort(404)\n    # abort(500)\n    return '抛出状态码'\n#捕获500的错误\n@app.errorhandler(500)\ndef server_error(e):\n    return '现在能看到了吗{}'.format(e)\n\n#捕获404的错误信息\n@app.errorhandler(404)\ndef server_error(e):\n    return '您访问的页面被外星人劫持走了！！！'\n八、app.run() 参数说明\n\n\n参数\n参数说明\n默认值\n\n\n\nhost\n主机名\n127.0.0.1\n\n\nport\n端口号\n5000\n\n\ndebug\n调试\nFalse\n\n\nthreaded\n多线程\nFalse\n\n\n\n实例\nif __name__ == '__main__':\n    # app.run(debug=True) #开启调试模式\n    app.run(host='0.0.0.0',port=5001,debug=True,threaded=True)\n十、请求 request\n说明：\nrequest是由flask框架为我们提供好的对象 使用时 只要导入即可\n用户在请求的时候 框架会为当前请求的用户 创建一个request（请求的对象） 包含当前用户请求的所有信息\n导入\nfrom flask import request\n\nurl 用户请求的完整的url\nbase_url  去除get传参后的url\nhost_url   只有主机和端口号的url\npath          获取请求的路由地址\nmethod    请求的方法\nargs           获取get传参\nform          获取表单传递过来的数据\nfiles            获取文件上传过来的数据\nheaders     获取用户请求过来的头信息\ncookies      获取用户请求过来的所有cookie\njson            获取用户请求过来的json数据\n\n实例\n@app.route('/request/')\ndef get_request():\n    print('用户请求的完整的url',request.url)\n    print('去除get传参后的url',request.base_url)\n    print('只有主机和端口号的url',request.host_url)\n    print('获取请求的路由地址',request.path)\n    print(' 请求的方法',request.method)\n    print('获取拼凑的get传参',request.args)\n    print('获取拼凑的get传参',request.args.get('name'))\n    print('获取拼凑的get传参',request.args.get('age'))\n    print('获取表单传递过来的数据',request.form)\n    print('获取文件上传过来的数据',request.files)\n    print('获取用户请求过来的头信息',request.headers)\n    print('获取用户请求过来的所有cookie',request.cookies)\n    print('获取用户请求过来的json数据',request.json)\n    return 'request对象'\n十一、会话控制 cookie和session\ncookie\n设置cookie\nresponse.set_cookie(\n    key,  #设置键\n    value，#设置值\n    max_age=None, #过期时间\n    path = '/' #当前cookie的存储路径\n)\n获取cookie\n@app.route('/get_cookie/')\ndef get_cookie():\n    print(request.cookies)\n    return request.cookies.get('name','default默认值')\n删除cookie\n#清除cookie\n@app.route('/del_cookie/')\ndef del_cookie():\n    res = make_response('清除cookie')\n    res.delete_cookie('name')\n    return res\ncookie存储值为明文存储  安全性低\ncookie存在客户端（浏览器中）\ncookie默认存活时间为 当前浏览结束（关闭当前的浏览器）\nsession\nsession的使用 需要一个secret_key 来进行加密产生加密的字符串\napp.config['SECRET_KEY'] = 'secretkey'\n会给cookie设置一个唯一的标识符 sessionId 服务器端会通过cookie携带着唯一的sessionId来区分是哪一个用户的请求  如果客户端的cookie被禁用了 那么服务器端的session将无法使用  session基于cookie\n设置session\n#设置session\n@app.route('/set_session/')\ndef set_session():\n     默认存活当前浏览器结束\n    session['username'] = '张三'\n    return '设置session'\n设置session 及过期时间\n#设置session\n@app.route('/set_session/')\ndef set_session():\n    session.permanent = True #设置session持久化存储\n    #设置当前session的存活时间60秒 如果当前设置失败 那么存活时间为1月\n    app.permanent_session_lifetime = timedelta(seconds=60)\n    session['username'] = '张三'\n    return '设置session'\n获取session\n#获取session\n@app.route('/get_session/')\ndef get_session():\n    return session.get('username','default默认值')\n删除session\n@app.route('/del_session/')\ndef del_session():\n    #删除 key为username的session\n    session.pop('username')\n    #删除所有session\n    # session.clear()\n    return '删除session'\n十二、flask-script扩展\n简介：\n就是一个flask终端运行的解析器  通过不同参数 来设置flask的启动项\n安装\nsudo pip3 install flask-script\n使用\nfrom flask_script import Manager #导入终端运行的解析器\napp = Flask(__name__)\nmanager = Manager(app)\n...\nif __name__ == '__main__':\n    manager.run()\n启动参数\n\n\n-h\n主机\n\n\n\n-p\n端口号\n\n\n-d\n调试\n\n\n-r\n重新加载\n\n\n-threaded\n多线程\n\n\n\npython manage.py runserver -hpython manage.py runserver -h0.0.0.0 -p5000  -d -r --threaded\npython manage.py runserver -d -r\n\n十三、蓝本蓝图 Blueprint\n概述\n当所有代码越爱越多的时候 在manage.py中 很明显是不合理的 我们需要将不同功能的视图函数 存放在不同的文件中  使用我们的项目的目录结构更加的清晰\n使用\nuser.py 用户的处理\nfrom flask import Blueprint\n\nuser = Blueprint('user',__name__)\n\n@user.route('/login/')\ndef login():\n    return '登录'\nmanage.py中\nfrom mysession import mysession\nfrom user import user\n#http://127.0.0.1:5000/login/\napp.register_blueprint(user) #注册蓝本\n#http://127.0.0.1:5000/user/login/\napp.register_blueprint(user,url_prefix='/user') #注册蓝本并添加前缀\n蓝本中的重定向\n@app.route('/')\ndef index():\n    # return '首页'\n    return redirect('/user/login/')\n    return redirect(url_for('user.login')) #使用url_for反向构造出路由的时候 需要指定当前的视图函数 是哪一个蓝本对象的\n十四、请求钩子函数\n在manage文件中使用\n\n\n钩子函数\n功能描述\n\n\n\nbefore_first_request\n第一次请求之前\n\n\nbefore_request\n每次请求之前\n\n\nafter_request\n每次请求之后  没有异常\n\n\nteardown_request\n每次请求之后  即使有异常出现\n\n\n\n实例\n@app.before_first_request\ndef before_first_request():\n    print('before_first_request')\n\n@app.before_request\ndef before_request():\n    print('before_request')\n    if request.method == 'GET' and request.path == '/form/':\n        abort(500)\n\n@app.after_request\ndef before_request(r):\n    print('before_request',r)\n    return r\n\n@app.teardown_request\ndef teardown_request(r):\n    print('teardown_request')\n    return r\n在蓝本中使用\n\n\n钩子函数\n功能描述\n\n\n\nbefore_app_first_request\n第一次请求之前\n\n\nbefore_app_request\n每次请求之前\n\n\nafter_app_request\n每次请求之后  没有异常\n\n\nteardown_app_request\n每次请求之后  即使有异常出现\n\n\n\n实例\n@user.before_app_first_request\ndef before_first_request():\n    print('before_first_request')\n\n@user.before_app_request\ndef before_request():\n    print('before_request')\n    if request.method == 'GET' and request.path == '/form/':\n        abort(500)\n\n@user.after_app_request\ndef after_request(r):\n    print('after_request',r)\n    return r\n\n@user.teardown_app_request\ndef teardown_request(r):\n    print('teardown_request')\n    return r\n注意:\n钩子函数写在蓝本或者启动文件中 都可以捕获到所有的请求和响应（一样）一个flask中只需要写一个钩子函数而不需要重复写钩子函数\nflask入门2-模板引擎\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "3"}