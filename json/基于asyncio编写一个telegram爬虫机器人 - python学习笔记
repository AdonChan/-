{"title": "基于asyncio编写一个telegram爬虫机器人 - python学习笔记 ", "index": "网页爬虫,telegram,asyncio,python", "content": "原文链接\n前言\naiotg 可以通过异步调用telegram api的方式来构建bot，因为决定开发一个爬虫功能的bot，所以网络请求阻塞是比较严重的性能障碍。而asyncio的异步非阻塞特性能够完美的解决这一问题。这篇文章在记录如何使用aiotg进行telegram开发的同时，也会说明一些aiohttp的使用方法,这里是项目源码。如果你觉得不错可以帮忙点一下star\nhttps://t.me/fpicturebot 点击链接可以体验一下这个bot的功能。\n如果读者之前对telegram的bot没有了解，可以查看这篇写给开发者的telegram-bots介绍文档\naiotg简单教程\n1.一个最简单的bot\n你可以先学习如何新建一个机器人\nfrom aiotg import Bot, Chat\n\nconfig = {\n    \"api_token\": \"***********\",\n    \"proxy\": \"http://127.0.0.1:8118\"\n}\n\nbot = Bot(**config)\n\n@bot.command(r\"/echo (.+)\")\ndef echo(chat: Chat, match):\n    return chat.reply(match.group(1))\n\nbot.run()\n\n上面是一个简单的回复机器人，当你使用指令 /echo+内容时，机器人会自动回复给你发送的内容。这里要注意一点，在我这里没有采用使用  pipenv  ( pip ) 安装aiotg的方法，因为pip平台上安装的是master分支的包，aiotg通过使用aiohttp来调用telegram bot api，在创建一个bot的时候没有提供proxy选项为aiohttp设置代理，在本地开发的时候会因为国内网络抽搐出现网络连接错误，所以在这里我使用了aiotg的prxoy分支，直接从github上下载的代码。在创建Bot对象的时候加入proxy选项就能使用本地代理来进行开发调试了。\n后来我在aiotg telegram群里建议作者将proxy合并到主分支，后来作者表示他也有这样的想法，同时他也吐槽了一下俄罗斯的网络也有很多审查和限制，现在在aiotg里已经没有proxy分支了，在aiotg-0.9.9版本中提供proxy选项，所以大家可以继续使用pipenv下载aiotg包。\n2.aiotg异步特性\n既然用到aiotg来开发就是看中了他的异步特性，下面就列出一个简单的例子\nimport aiohttp\nimport json\nfrom aiotg import Bot, Chat\n\nwith open('token.conf') as f:\n    token = json.loads(f.read())\n\nbot = Bot(**token)\n\n@bot.command(\"/fetch\")\nasync def async_fecth(chat: Chat, match):\n    url = \"http://www.gamersky.com/ent/111/\"\n    async with aiohttp.ClientSession() as sesssion:\n        async with sesssion.get(url) as resp:\n            info = ' version: {}\\n status :{}\\n method: {}\\n url: {}\\n'.format(\n                resp.version, resp.status, resp.method, resp.url)\n            await chat.send_text(info)\n\nbot.run(debug=True)\n\n\n3. 自定义键盘\n关于自定义键盘的内容可以点击链接查看官方解释，这里是简单的中文描述。\ncategory.json\n[\n    {\n        \"name\": \"dynamic\",\n        \"title\": \"动态图\",\n        \"url\": \"http://www.gamersky.com/ent/111/\"\n    },\n    {\n        \"name\": \"oops\",\n        \"title\": \"囧图\",\n        \"url\": \"http://www.gamersky.com/ent/147/\"\n    },\n    {\n        \"name\": \"beauty\",\n        \"title\": \"福利图\",\n        \"url\": \"http://tag.gamersky.com/news/66.html\"\n    },\n    {\n        \"name\": \"easy-moment\",\n        \"title\": \"轻松一刻\",\n        \"url\": \"http://www.gamersky.com/ent/20503/\"\n    },\n    {\n        \"name\": \"trivia\",\n        \"title\": \"冷知识\",\n        \"url\": \"http://www.gamersky.com/ent/198/\"\n    },\n    {\n        \"name\": \"cold-tucao\",\n        \"title\": \"冷吐槽\",\n        \"url\": \"http://www.gamersky.com/ent/20108/\"\n    }\n]\nmain.py\nimport aiohttp\nimport json\nfrom aiotg import Bot, Chat\n\nwith open('token.json') as t, open('category.json') as c:\n    token = json.loads(t.read())\n    category = json.loads(c.read())\n\nbot = Bot(**token)\n\n@bot.command(\"/reply\")\nasync def resply(chat: Chat, match):\n    kb = [[item['title']] for item in category]\n    keyboard = {\n        \"keyboard\": kb,\n        \"resize_keyboard\": True\n    }\n    await chat.send_text(text=\"看看你的键盘\", reply_markup=json.dumps(keyboard))\n\nbot.run(debug=True)\n\n只需要在调用chat的发送消息函数中，指定 reply_markup 参数，你就能个性化的设定用户键盘， reply_markup 参数需要一个json对象，官方指定为ReplyKeyboardMarkup类型，其中keyboard需要传递一个KeyboardButton的数组。\n每个keyboard的成员代表着键盘中的行，你可以通过修改每行中KeyboardButton的个数来排列你的键盘，比如我们让键盘每行显示两个KeyboardButton，如下所示\n@bot.command(\"/reply\")\nasync def reply(chat: Chat, match):\n    # kb = [[item['title']] for item in category]\n    kb, row = [], -1\n    for idx, item in enumerate(category):\n        if idx % 2 == 0:\n            kb.append([])\n            row += 1\n        kb[row].append(item['title'])\n    keyboard = {\n        \"keyboard\": kb,\n        \"resize_keyboard\": True\n    }\n    await chat.send_text(text=\"看看你的键盘\", reply_markup=json.dumps(keyboard))\n\n4. 内联键盘和消息更新\n内联键盘的意思就是附着在消息上的键盘，内联键盘由内联按钮组成，每个按钮会附带一个回调数据，每次点击按钮之后会有对应的回调函数处理。\n@bot.command(\"/inline\")\nasync def inlinekeyboard(chat: Chat, match):\n\n    inlinekeyboardmarkup = {\n            'type': 'InlineKeyboardMarkup',\n            'inline_keyboard': [\n                [{'type': 'InlineKeyboardButton',\n                  'text': '上一页',\n                  'callback_data': 'page-pre'},\n                 {'type': 'InlineKeyboardButton',\n                  'text': '下一页',\n                  'callback_data': 'page-next'}]\n                ]\n            }\n\n    await chat.send_text('请翻页', reply_markup=json.dumps(inlinekeyboardmarkup))\n\n@bot.callback(r'page-(\\w+)')\nasync def buttonclick(chat, cq, match):\n    await chat.send_text('You clicked {}'.format(match.group(1)))\n\n有时候我们想修改之前已经发送过的消息内容，例如当用户点击了内联键盘，而键盘的功能是进行翻页更新消息的内容。这时候我们可以使用 editMessageText 功能。例如点击上面内联键盘中的上一页按钮，你可以看到消息的内容被更改了。\n@bot.callback(r'page-(\\w+)')\nasync def buttonclick(chat, cq, match):\n    await chat.edit_text(message_id=chat.message['message_id'], text=\"消息被修改了\")\n\n5.内联请求模式\n内联请求模式感觉更适合在群组中使用，在讨论组中输入@botname + 特定指令，输入框的上方就会显示查询内容，你可以返回给用户文章类型、图片类型或者其他类型的查询信息。官网有更详细的内容。\n@bot.inline\nasync def inlinemode(iq):\n    results = [{\n            'type': 'article',\n            'id': str(index),\n            'title': article['title'],\n            'input_message_content': { 'message_text': article['title']},\n            'description': f\"这里是{article['title']}\"\n        } for index, article in enumerate(category)]\n    await iq.answer(results)\n<img src=\"http://ww1.sinaimg.cn/large/0...; style=\"width: 350px; height: 630px\">\n我们设定当用户输入内联指令时，bot返回可以选择的图片种类，返回结果的类型是article类型，官方还提供了语音，图片，gif，视频，音频。表情等类型，你可以根据自己的需要进行选择。\n爬虫机器人功能实现\n我使用aiotg编写的机器人是用来抓取来自游民星空的图片。\n1. 爬虫功能\n爬虫功能的实现是用aiohttp发送web请求，使用beautifulsoup进行html解析，核心代码如下\nimport re\nimport aiohttp\nfrom bs4 import BeautifulSoup\n\n\ndef aioget(url):\n    return aiohttp.request('GET', url)\n\n\ndef filter_img(tag):\n    if tag.name != 'p':\n        return False\n    try:\n        if tag.attrs['align'] == 'center':\n            for child in tag.contents:\n                if child.name == 'img' or child.name == 'a':\n                    return True\n        return False\n    except KeyError:\n        if 'style' in tag.attrs:\n            return True\n        else:\n            return False\n            \n            \nasync def fetch_img(url):\n    async with aioget(url) as resp:\n        resp_text = await resp.text()\n        content = BeautifulSoup(resp_text, \"lxml\")\n        imgs = content.find(class_=\"Mid2L_con\").findAll(filter_img)\n        results = []\n        for img in imgs:\n            try:\n                results.append({\n                    'src':  img.find('img').attrs['src'],\n                    'desc': '\\n'.join(list(img.stripped_strings))\n                })\n            except AttributeError:\n                continue\n        return results\n我将aiohttp的get请求稍微包装了一下，简洁一些。html中元素的提取就不在赘述，就是找找html中的规律\n2. 指令功能\n指令功能实现需要使用aiotg.bot.command装饰器进行命令注册，下面列出 /start的功能实现\n@bot.command(r\"/start\")\nasync def list_category(chat: Chat, match):\n    kb, row = [], -1\n    for idx, item in enumerate(category[\"name\"]):\n        if idx % 2 == 0:\n            kb.append([])\n            row += 1\n        kb[row].append(item)\n    keyboard = {\n        \"keyboard\": kb,\n        \"resize_keyboard\": True\n    }\n    await chat.send_text(text=\"请选择你喜欢的图片类型\", reply_markup=json.dumps(keyboard))\n关于自定义键盘部分在上文中已经讲过，读者可以自己编码实现\n3. callback功能\n\n读者可以看到在消息上附有页面切换按钮，每个按钮会带着一个callbackdata，当点击按钮会调用相应的callback函数进行处理，这里点击下一页时会进行翻页。\n\n看页面更新了，关于更新页面的实现在上面也讲到了如何进行消息更新。\n@bot.callback(r\"page-(?P<name>\\w+)-(?P<page>\\d+)\")\nasync def change_lists(chat: Chat, cq, match):\n    req_name = match.group('name')\n    page = match.group('page')\n    url = category[req_name]\n    text, markup = await format_message(req_name, url, page)\n    await chat.edit_text(message_id=chat.message['message_id'], text=text, markup=markup)\n也是使用装饰器进行回调函数注册，使用chat.edit_text进行消息更新。\ncallback功能也用在了图片的更新。点击下一页更新图片。\n\n4.内联请求模式功能\n当用户在输入框中输入@botusername+指令时，会在输入框上显示查询内容。\n\n当没有指令时，会显示一些能够查看的图片类型。\n\n当输入对应类型汉字的前几个字时，bot会匹配你想看的图片列表，并罗列出来\n@bot.inline(r\"([\\u4e00-\\u9fa5]+)\")\nasync def inline_name(iq, match):\n    req = match.group(1)\n    req_name = match_category(req.strip(), category['name'])\n    ptype = 'G' if req_name == \"dynamic\" else 'P'\n    if req_name is None:\n        return\n    results, _ = await fetch_lists(category[req_name])\n    c_results = [{\n            'type': 'article',\n            'id': str(index),\n            'title': item['title'],\n            'input_message_content': {\n                'message_text': '/' + ptype + item['date'] + '_' + item['key']\n            },\n            'description': item['desc']\n        } for index, item in enumerate(results)]\n    await iq.answer(c_results)\nredis缓存\n当发送给用户图片时，telegram会返回一个和图片对应的file_id, 当再次发送相同的图片时，只需要在调用send_photo时，将photo参数赋值为file_id即可，所以每次使用爬虫进行抓取图片时，将图片的fild_id存在redis中，用户请求图片时，如果图片之前已经抓取过，这时候只要从redis中取出file_id，再调用send_photo即可。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "2"}