{"title": "Bottle源码阅读（一） - 学无止境 ", "index": "bottle,python", "content": "在初识bottle（一）中，我们了解了bottle框架的基本用法。在本篇文章中，我们通过源码来探究一些基本原理。\n\n1. run的实现\n所有的框架请求响应都基于一个原理http请求 --> wsgi服务器 --> wsgi接口(实际就是框架中自定义实现的函数经过底层封装) --> 响应可以参考廖雪峰的教程中关于wsgi接口的讲解\n下我们先看看bottle是如何实现服务器运行时自动重新加载\ndef run(app=None,\n        server='wsgiref',\n        host='127.0.0.1',\n        port=8080,\n        interval=1,\n        reloader=False,\n        quiet=False,\n        plugins=None,\n        debug=None,\n        config=None, **kargs):\n    \"\"\" Start a server instance. This method blocks until the server terminates.\n\n        :param app: WSGI application or target string supported by\n               :func:`load_app`. (default: :func:`default_app`)\n        :param server: Server adapter to use. See :data:`server_names` keys\n               for valid names or pass a :class:`ServerAdapter` subclass.\n               (default: `wsgiref`)\n        :param host: Server address to bind to. Pass ``0.0.0.0`` to listens on\n               all interfaces including the external one. (default: 127.0.0.1)\n        :param port: Server port to bind to. Values below 1024 require root\n               privileges. (default: 8080)\n        :param reloader: Start auto-reloading server? (default: False)\n        :param interval: Auto-reloader interval in seconds (default: 1)\n        :param quiet: Suppress output to stdout and stderr? (default: False)\n        :param options: Options passed to the server adapter.\n     \"\"\"\n    if NORUN: return\n    # 自动重载\n    if reloader and not os.environ.get('BOTTLE_CHILD'):\n        import subprocess\n        lockfile = None\n        try:\n            # tempfile 临时文件操作模块https://docs.python.org/2/library/tempfile.html\n            # 第一个相当于执行os.open()函数返回文件handler，第二个表示绝对路径\n            fd, lockfile = tempfile.mkstemp(prefix='bottle.', suffix='.lock')\n            os.close(fd)  # We only need this file to exist. We never write to it\n            # sys.executable 是获取当前python解释器的路径\n            while os.path.exists(lockfile):\n                args = [sys.executable] + sys.argv\n                environ = os.environ.copy()\n                environ['BOTTLE_CHILD'] = 'true'\n                environ['BOTTLE_LOCKFILE'] = lockfile\n\n                # 创建一个子进程实例\n                p = subprocess.Popen(args, env=environ)\n                # 如果返回None表示子进程未结束\n                while p.poll() is None:  # Busy wait...\n                    # 临时文件设置为当前时间\n                    os.utime(lockfile, None)  # I am alive!\n                    time.sleep(interval)\n                # linux 系统的信号机制http://www.cppblog.com/sleepwom/archive/2010/12/27/137564.html\n                # 3表示按下退出键\n                # 非正常退出时\n                if p.poll() != 3:\n                    # os.unlink 相当于去除remove()\n                    if os.path.exists(lockfile): os.unlink(lockfile)\n                    sys.exit(p.poll())\n        except KeyboardInterrupt:\n            pass\n        finally:\n            if os.path.exists(lockfile):\n                os.unlink(lockfile)\n        return\n首先第一次运行时，开启一个新的进程，确保运行server时的进程和python解释器一致不影响主进程的继续运行\n    try:\n        # 这一部分主要是app的相关设置\n        if debug is not None: _debug(debug)\n        app = app or default_app()\n        if isinstance(app, basestring):\n            app = load_app(app)\n        if not callable(app):\n            raise ValueError(\"Application is not callable: %r\" % app)\n\n        for plugin in plugins or []:\n            if isinstance(plugin, basestring):\n                plugin = load(plugin)\n            app.install(plugin)\n\n        if config:\n            app.config.update(config)\n\n        if server in server_names:\n            server = server_names.get(server)\n        if isinstance(server, basestring):\n            server = load(server)\n        if isinstance(server, type):\n            server = server(host=host, port=port, **kargs)\n        if not isinstance(server, ServerAdapter):\n            raise ValueError(\"Unknown or unsupported server: %r\" % server)\n\n        server.quiet = server.quiet or quiet\n        if not server.quiet:\n            _stderr(\"Bottle v%s server starting up (using %s)...\\n\" %\n                    (__version__, repr(server)))\n            _stderr(\"Listening on http://%s:%d/\\n\" %\n                    (server.host, server.port))\n            _stderr(\"Hit Ctrl-C to quit.\\n\\n\")\n        \n        # 当选择自动重载时，如果解释器进程已经启动\n        # 则只需要检测应用相关内容有没有变化,如果有变化终止主线程并重新实现异常捕获\n        if reloader:\n            lockfile = os.environ.get('BOTTLE_LOCKFILE')\n            bgcheck = FileCheckerThread(lockfile, interval)\n            # 开启新线程检测文件修改，如果修改终止当前主线程，抛出异常\n            with bgcheck:\n                # 主线程监听请求\n                server.run(app)\n            if bgcheck.status == 'reload':\n                sys.exit(3)\n        else:\n            server.run(app)\n    except KeyboardInterrupt:\n        pass\n\n    except (SystemExit, MemoryError):\n        raise\n    except:\n        if not reloader: raise\n        if not getattr(server, 'quiet', quiet):\n            print_exc()\n        time.sleep(interval)\n        sys.exit(3)\nFileCheckerThread会对应用相关文件内容变化进行检测server加载app，由server接收请求并执行相应的应用函数在此之前，我们先了解FileCheckerThread\n2. 应用修改后的自动重载\n这是一个上下文管理器，当__enter__时开启一个新的线程，这个线程的任务就是检测应用相关模块文件的变化，决定是否终止主线程，当__exit__时，如果返回True则重现异常，否则正常执行后续代码\nclass FileCheckerThread(threading.Thread):\n    \"\"\" Interrupt main-thread as soon as a changed module file is detected,\n        the lockfile gets deleted or gets too old. \"\"\"\n\n    def __init__(self, lockfile, interval):\n        threading.Thread.__init__(self)\n        self.daemon = True\n        self.lockfile, self.interval = lockfile, interval\n        #: Is one of 'reload', 'error' or 'exit'\n        self.status = None\n\n    def run(self):\n        exists = os.path.exists\n        mtime = lambda p: os.stat(p).st_mtime\n        files = dict()\n\n        for module in list(sys.modules.values()):\n            path = getattr(module, '__file__', '')\n            if path[-4:] in ('.pyo', '.pyc'): path = path[:-1]\n            if path and exists(path): files[path] = mtime(path)\n\n        while not self.status:\n            if not exists(self.lockfile)\\\n            or mtime(self.lockfile) < time.time() - self.interval - 5:\n                self.status = 'error'\n                thread.interrupt_main()\n            for path, lmtime in list(files.items()):\n                if not exists(path) or mtime(path) > lmtime:\n                    self.status = 'reload'\n                    thread.interrupt_main()\n                    break\n            time.sleep(self.interval)\n\n    def __enter__(self):\n        self.start()\n    \n    # 这个地方是重新载入更新后模块的关键\n    # 当检测到文件变化时，终止主线程使监听请求停止，退出上下文管理器时，如果返回True则重现异常捕获\n    def __exit__(self, exc_type, *_):\n        if not self.status: self.status = 'exit'  # silent exit\n        self.join()\n        return exc_type is not None and issubclass(exc_type, KeyboardInterrupt)\n3. server调用应用函数\nbottle提供了一个ServerAdapter的适配器类，重写run方法就能使bottle可以使用多种框架提供的server。\nclass ServerAdapter(object):\n    quiet = False\n\n    def __init__(self, host='127.0.0.1', port=8080, **options):\n        self.options = options\n        self.host = host\n        self.port = int(port)\n\n    def run(self, handler):  # pragma: no cover\n        pass\n\n    def __repr__(self):\n        args = ', '.join(['%s=%s' % (k, repr(v))\n                          for k, v in self.options.items()])\n        return \"%s(%s)\" % (self.__class__.__name__, args)\n默认使用了python自带的wsgiref， 从代码中我们可以看到其中主要由三部分组成：接收请求模块,处理请求模块，组装模块\nclass WSGIRefServer(ServerAdapter):\n    def run(self, app):  # pragma: no cover\n        from wsgiref.simple_server import make_server\n        from wsgiref.simple_server import WSGIRequestHandler, WSGIServer\n        import socket\n\n        class FixedHandler(WSGIRequestHandler):\n            def address_string(self):  # Prevent reverse DNS lookups please.\n                return self.client_address[0]\n\n            def log_request(*args, **kw):\n                if not self.quiet:\n                    return WSGIRequestHandler.log_request(*args, **kw)\n\n        handler_cls = self.options.get('handler_class', FixedHandler)\n        server_cls = self.options.get('server_class', WSGIServer)\n\n        if ':' in self.host:  # Fix wsgiref for IPv6 addresses.\n            if getattr(server_cls, 'address_family') == socket.AF_INET:\n\n                class server_cls(server_cls):\n                    address_family = socket.AF_INET6\n\n        self.srv = make_server(self.host, self.port, app, server_cls,\n                               handler_cls)\n        self.port = self.srv.server_port  # update port actual port (0 means random)\n        try:\n            self.srv.serve_forever()\n        except KeyboardInterrupt:\n            self.srv.server_close()  # Prevent ResourceWarning: unclosed socket\n            raise\n４．WSGIServer\n4.1 寻根到底，我们现研究一下WSGIServer 的基类BaseServer 主要实现线程上的控制，实现一些供上层调用的接口，例如\nserver_activate\nserve_forever\nshutdown\nhandle_request\nverify_request\nhandle_error\nTCPServer　继承BaseServer, 实现bind，listen，accept, close等函数的封装\n    def server_bind(self):\n        \"\"\"Called by constructor to bind the socket.\n\n        May be overridden.\n\n        \"\"\"\n        if self.allow_reuse_address:\n            self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        self.socket.bind(self.server_address)\n        self.server_address = self.socket.getsockname()\n\n    def server_activate(self):\n        \"\"\"Called by constructor to activate the server.\n\n        May be overridden.\n\n        \"\"\"\n        self.socket.listen(self.request_queue_size)\n\n    def server_close(self):\n        \"\"\"Called to clean-up the server.\n\n        May be overridden.\n\n        \"\"\"\n        self.socket.close()\nHttpServer 继承TCPServer, 添加了host和port两个属性WSGIServer 继承HttpServer, 设置了环境变量，提供了获取应用和设置应用的接口\nclass WSGIServer(HTTPServer):\n\n    \"\"\"BaseHTTPServer that implements the Python WSGI protocol\"\"\"\n\n    application = None\n\n    def server_bind(self):\n        \"\"\"Override server_bind to store the server name.\"\"\"\n        HTTPServer.server_bind(self)\n        self.setup_environ()\n\n    def setup_environ(self):\n        # Set up base environment\n        env = self.base_environ = {}\n        env['SERVER_NAME'] = self.server_name\n        env['GATEWAY_INTERFACE'] = 'CGI/1.1'\n        env['SERVER_PORT'] = str(self.server_port)\n        env['REMOTE_HOST']=''\n        env['CONTENT_LENGTH']=''\n        env['SCRIPT_NAME'] = ''\n\n    def get_app(self):\n        return self.application\n\n    def set_app(self,application):\n        self.application = application\n4.2 WSGIRequestHandler的实现最底层的BaseRequestHandler：处理请求的基类，定义了处理请求的流程StreamRequestHandler：　继承BaseRequestHandler，提供了处理请求前rfile和wfile属性，使处理请求时能通过类似文件读写获取请求和返回响应\nclass StreamRequestHandler(BaseRequestHandler):\n\n    \"\"\"Define self.rfile and self.wfile for stream sockets.\"\"\"\n\n    # Default buffer sizes for rfile, wfile.\n    # We default rfile to buffered because otherwise it could be\n    # really slow for large data (a getc() call per byte); we make\n    # wfile unbuffered because (a) often after a write() we want to\n    # read and we need to flush the line; (b) big writes to unbuffered\n    # files are typically optimized by stdio even when big reads\n    # aren't.\n    rbufsize = -1\n    wbufsize = 0\n\n    # A timeout to apply to the request socket, if not None.\n    timeout = None\n\n    # Disable nagle algorithm for this socket, if True.\n    # Use only when wbufsize != 0, to avoid small packets.\n    disable_nagle_algorithm = False\n\n    def setup(self):\n        self.connection = self.request\n        if self.timeout is not None:\n            self.connection.settimeout(self.timeout)\n        if self.disable_nagle_algorithm:\n            self.connection.setsockopt(socket.IPPROTO_TCP,\n                                       socket.TCP_NODELAY, True)\n        self.rfile = self.connection.makefile('rb', self.rbufsize)\n        self.wfile = self.connection.makefile('wb', self.wbufsize)\n\n    def finish(self):\n        if not self.wfile.closed:\n            try:\n                self.wfile.flush()\n            except socket.error:\n                # A final socket error may have occurred here, such as\n                # the local error ECONNABORTED.\n                pass\n        self.wfile.close()\n        self.rfile.close()\nBaseHTTPRequestHandler：继承StreamRequestHandler，handle处理一个请求，轮询直到收到一个明确关闭连接；parse_request解析请求requestline，如果一切正常，继续处理请求\nWSGIRequestHandler:继承了BaseHTTPRequestHandler， 添加get_environ获取环境变量， 重写了handle方法。当requestline >65536时返回414， 实例化一个ServerHandler实例\n    def handle(self):\n        \"\"\"Handle a single HTTP request\"\"\"\n\n        self.raw_requestline = self.rfile.readline(65537)\n        if len(self.raw_requestline) > 65536:\n            self.requestline = ''\n            self.request_version = ''\n            self.command = ''\n            self.send_error(414)\n            return\n\n        if not self.parse_request(): # An error code has been sent, just exit\n            return\n\n        handler = ServerHandler(\n            self.rfile, self.wfile, self.get_stderr(), self.get_environ()\n        )\n        handler.request_handler = self      # backpointer for logging\n        handler.run(self.server.get_app())\nhandler.run(self.server.get_app())实现了从请求到应用函数执行，并把执行后的结果写入wfile返回我们再看wsgiref.handlers中BaseHandler中，是如何实现的。\n    def run(self, application):\n        \"\"\"Invoke the application\"\"\"\n        # Note to self: don't move the close()!  Asynchronous servers shouldn't\n        # call close() from finish_response(), so if you close() anywhere but\n        # the double-error branch here, you'll break asynchronous servers by\n        # prematurely closing.  Async servers must return from 'run()' without\n        # closing if there might still be output to iterate over.\n        try:\n            self.setup_environ()\n            self.result = application(self.environ, self.start_response)\n            self.finish_response()\n        except:\n            try:\n                self.handle_error()\n            except:\n                # If we get an error handling an error, just give up already!\n                self.close()\n                raise   # ...and let the actual server figure it out.\n                \n    def start_response(self, status, headers,exc_info=None):\n        \"\"\"'start_response()' callable as specified by PEP 333\"\"\"\n\n        if exc_info:\n            try:\n                if self.headers_sent:\n                    # Re-raise original exception if headers sent\n                    raise exc_info[0], exc_info[1], exc_info[2]\n            finally:\n                exc_info = None        # avoid dangling circular ref\n        elif self.headers is not None:\n            raise AssertionError(\"Headers already set!\")\n\n        assert type(status) is StringType,\"Status must be a string\"\n        assert len(status)>=4,\"Status must be at least 4 characters\"\n        assert int(status[:3]),\"Status message must begin w/3-digit code\"\n        assert status[3]==\" \", \"Status message must have a space after code\"\n        if __debug__:\n            for name,val in headers:\n                assert type(name) is StringType,\"Header names must be strings\"\n                assert type(val) is StringType,\"Header values must be strings\"\n                assert not is_hop_by_hop(name),\"Hop-by-hop headers not allowed\"\n        self.status = status\n        self.headers = self.headers_class(headers)\n        return self.write\napplication接受了两个参数，一个envrion， 和一个start_response的方法。因此下一步就是研究我们写的应用函数是如何被封装成适配的application\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "2"}