{"title": "python标准库学习之pickle模块 - Happen's Memo ", "index": "tutorial,python", "content": "对象存在于程序运行时的内存中，当程序不再运行时或断电关机时，这些对象便不再存在。我现在想把对象保存下来，方便以后使用，这就是持久化技术。利用 python标准库中的的pickle模块可以将对象转换为一种可以传输或存储的格式。\n如果希望透明地存储 python 对象，而不丢失其身份和类型等信息，则需要某种形式的对象序列化：它是一个将任意复杂的对象转成对象的文本或二进制表示的过程。\n主要方法\npickle模块中有两个主要函数，它们是dump()和load()。\ndump()方法\n该方法的作用是实现python 对象的序列化，将 obj 保存到 file 中。具体语法如下：\npickle.dump(obj, file[, protocol])\nobj：要持久化保存的对象；file： 将对象序列化后保存到的类文件对象;它必须有一个可以接受单字符串作为入参的write() 方法。这个对象可以是一个以写模式打开的文件对象或者一个 StringIO 对象，或者其他任意满足条件的接口；protocol: 可选的参数，默认为 0。0表示所序列化的对象使用可打印的ASCII码表示；1或True 表示使用老式的二进制协议；2表示使用python2.3版本引入的新二进制协议，比以前的高效；负值表示将使用可用的最高协议版本。如果 protocol>=1，那么文件对象需要以二进制形式打开。\ndumps()\n具体语法为：\npickle.dumps(obj[, protocol])\n返回一个字符串，而不是存入文件中。\nload()\n该方法用于反序列化，即将序列化的对象重新恢复成python对象。具体语法如下：\npickle.load(file)\n这个 file 必须是一个拥有一个能接收单整数为参数的 read() 方法以及一个不接收任何参数的 readline() 方法，并且这两个方法的返回值都应该是字符串。这可以是一个打开为读的文件对象、StringIO 对象或其他任何满足条件的对象。\nloads()\npickle.loads(string)\n从字符串中恢复对象。\nPickler()\nclass pickle.Pickler(file[, protocol])\n可以使用该对象调用dunmp 和 load 等方法。\nclear_memo()\n对于相同的对象，如果不使用clear_memo()方法，那么python只会pickle一次\ncPickle 模块\ncPickle 是 pickle的优化版， cPickle是 C 编写的因此它可以比pickle快 1000倍。但是它不支持使用子类化的Pickler()和Unpickler()类，因为在cPickle中，这些都是不是类的功能。大多数应用程序不需要此功能，并可以受益于cPickle的改进性能。除此之外，这两个模块的接口是几乎完全相同。\n用例\nIn [2]: try:\n   ...:     import cPickle as pickle\n   ...: except:\n   ...:     import pickle\n   ...:\n\nIn [3]: info = [1, 2, 3, 'hello']\nIn [4]: data1 = pickle.dumps(info)\nIn [5]: print data1\n(lp1\nI1\naI2\naI3\naS'hello'\np2\na.\n\nIn [6]: data2 = pickle.loads(data1)\nIn [7]: print data2\n[1, 2, 3, 'hello']\n\nIn [8]: type(data1)\nOut[8]: str\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "4"}