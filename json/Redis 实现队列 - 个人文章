{"title": "Redis 实现队列 - 个人文章 ", "index": "java,python,redis,php", "content": "场景说明：\n\n用于处理比较耗时的请求，例如批量发送邮件，如果直接在网页触发执行发送，程序会出现超时\n高并发场景，当某个时刻请求瞬间增加时，可以把请求写入到队列，后台在去处理这些请求\n抢购场景，先入先出的模式\n\n命令：\nrpush + blpop 或 lpush + brpop\nrpush : 往列表右侧推入数据  blpop : 客户端阻塞直到队列有值输出\n简单队列：\nsimple.php\n$stmt = $pdo->prepare('select id, cid, name from zc_goods limit 200000');\n$stmt->execute();\nwhile ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {\n    $redis->rPush('goods:task', json_encode($row));\n}\n\n$redis->close();\n获取20000万个商品，并把json化后的数据推入goods:task队列\nqueueBlpop.php\n// 出队\nwhile (true) {\n    // 阻塞设置超时时间为3秒\n    $task = $redis->blPop(array('goods:task'), 3);\n    if ($task) {\n        $redis->rPush('goods:success:task', $task[1]);\n        $task = json_decode($task[1], true);\n        echo $task['id'] . ':' . $task['cid'] . ':' . 'handle success';\n        echo PHP_EOL;\n    } else {\n        echo 'nothing' . PHP_EOL;\n        sleep(5);\n    }\n}\n设置blpop阻塞时间为3秒，当有数据出队时保存到goods:success:task表示执行成功，当队列没有数据时，程序睡眠10秒重新检查goods:task是否有数据出队\ncli 模式执行命令：\nphp simple.php\nphp queueBlpop.php\n优先级队列\n思路：\nblpop 有多个键时，blpop会从左至右遍历键，一旦一个键能弹出元素，客户端立即返回。例如：\nblpop key1 key2 key3 key4\n从key1到key4遍历，如果哪个key有值，则弹出这个值，若多个key同时有值时，优先弹出排在左边的key。\npriority.php\n// 设置优先级队列\n$high = 'goods:high:task';\n$mid = 'goods:mid:task';\n$low = 'goods:low:task';\n\n$stmt = $pdo->prepare('select id, cid, name from zc_goods limit 200000');\n$stmt->execute();\nwhile ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {\n    // cid 小于100放在低级队列\n    if ($row['cid'] < 100) {\n        $redis->rPush($low, json_encode($row));\n    }\n    // cid 100到600之间放在中级队列\n    elseif ($row['cid'] > 100 && $row['cid'] < 600) {\n        $redis->rPush($mid, json_encode($row));\n    }\n    // cid 大于600放在高级队列 \n    else {\n        $redis->rPush($high, json_encode($row));\n    }\n}\n$redis->close();\npriorityBlop.php\n// 优先级队列\n$high = 'goods:high:task';\n$mid = 'goods:mid:task';\n$low = 'goods:low:task';\n\n// 出队\nwhile(true){\n    // 优先级高的队列放在左侧\n    $task = $redis->blPop(array($high, $mid, $low), 3);\n    if ($task) {\n        $task = json_decode($task[1], true);\n        echo $task['id'] . ':' . $task['cid'] . ':' . 'handle success';\n        echo PHP_EOL;\n    } else {\n        echo 'nothing' . PHP_EOL;\n        sleep(5);\n    }\n}\n优先级高的队列放在blpop命令左侧，依次排序，blpop命令会依次弹出high, mid, low队列的值\ncli 模式执行命令：\nphp priority.php\nphp priorityBlpop.php\n延迟队列\n思路：\n可以用一个有序集合来保存延迟任务，member保存任务内容，score保存（当前时间 + 延时时间）。用时间作为score。程序只要用有序集合的第一条任务的score和当前时间做比较，如果当前时间比score小，说明有序集合的所有任务还没到执行时间。\ndelay.php\n$stmt = $pdo->prepare('select id, cid, name from zc_goods limit 200000');\n$stmt->execute();\nwhile ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {\n    $redis->zAdd('goods:delay:task', time() + rand(1, 300), json_encode($row));\n}\n将20万条任务导入有序集合goods:delay:task，所有任务延迟到之后的1秒到300秒内执行\ndelayHandle.php\nwhile (true) {\n    // 因为是有序集合，只要判断第一条记录的延时时间，例如第一条未到执行时间\n    // 相对说明集合的其他任务未到执行时间\n    $rs = $redis->zRange('goods:delay:task', 0, 0, true);\n    // 集合没有任务，睡眠时间设置为5秒\n    if (empty($rs)) {\n        echo 'no tasks , sleep 5 seconds' . PHP_EOL;\n        sleep(5);\n        continue;\n    }\n\n    $taskJson = key($rs);\n    $delay = $rs[$taskJson];\n    $task = json_decode($taskJson, true);\n    $now = time();\n\n    // 到时间执行延时任务\n    if ($delay <= $now) {\n        // 对当前任务加锁，避免移动移动延时任务到任务队列时被其他客户端修改\n        if (!($identifier = acquireLock($task['id']))) {\n            continue;\n        }\n\n        // 移动延时任务到任务队列\n        $redis->zRem('goods:delay:task', $taskJson);\n        $redis->rPush('goods:task', $taskJson);\n        echo $task['id'] . ' run ' . PHP_EOL;\n\n        // 释放锁\n        releaseLock($task['id'], $identifier);\n    } else {\n        // 延时任务未到执行时间\n        $sleep = $delay - $now;\n        // 最大值设置为2秒，保证如果有新的任务（延时时间1秒）进入集合时能够及时的被处理\n//        $sleep = $sleep > 2 ? 2 :$sleep;\n        echo 'wait ' . $sleep . ' seconds ' . PHP_EOL;\n        sleep($sleep);\n    }\n}\n这个文件对有序集合内的延迟任务做处理，如果延迟任务到了执行时间，则把延迟任务移动到任务队列中\nqueueBlpop.php\n// 出队\nwhile (true) {\n    // 阻塞设置超时时间为3秒\n    $task = $redis->blPop(array('goods:task'), 3);\n    if ($task) {\n        $redis->rPush('goods:success:task', $task[1]);\n        $task = json_decode($task[1], true);\n        echo $task['id'] . ':' . $task['cid'] . ':' . 'handle success';\n        echo PHP_EOL;\n    } else {\n        echo 'nothing' . PHP_EOL;\n        sleep(5);\n    }\n}\n处理任务队列中的任务\ncli模式下执行命令：\nphp delay.php\nphp delayHanlde.php\nphp queueBlpop.php\n完整代码：https://github.com/wuzhc/demo...\n\n                ", "mainLikeNum": ["8 "], "mainBookmarkNum": "69"}