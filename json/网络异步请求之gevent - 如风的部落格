{"title": "网络异步请求之gevent - 如风的部落格 ", "index": "异步,io,requests,python,gevent", "content": "我们知道对于网络请求这种IO bound的场景来说，最怕的就是某个请求阻塞了其余的操作，让并发性大大降低。今天就来介绍一款python下的并发库-gevent。\n首先看一下他自己的介绍：\ngevent是一个基于libev的并发库。它为各种并发和网络相关的任务提供了整洁的API。\n嗯，确实很简洁，很易使用。待会我们就见识到了。\n同步IO\n首先我们来看看传统的IO请求。比如我们请求：http://httpbin.org/ip 发个http get请求会得到我们的ip地址，如：\n{\n  \"origin\": \"183.240.202.14\"\n}\n我们来写个脚本连续发50个get请求到这个地址，以模拟多个请求。(脚本命名为get.py)\nimport requests\n\nurl = 'http://httpbin.org/ip'\n\nfor i in range(50):\n    print(\"{}: {}\".format(i, requests.get(url).text))\n\n统计一下运行时间：\n$ time python3 get.py\n\n(输出略...)\npython3 get.py  0.56s user 0.06s system 1% cpu 35.606 total\n大概花费35s钟，当然不同网络环境可能结果不同。而且打印出来的结果是按照1, 2, 3...50这样的顺序来的，说明整个请求是同步的，一个请求结束再发下一个请求。\n使用gevent\n我们再来写一个gevent版的get.py，命名为gevent_get.py\nimport requests\nimport gevent\nimport gevent.monkey\n# 这里将socket变成异步\ngevent.monkey.patch_socket()\n\nurl = 'http://httpbin.org/ip'\n\n\ndef hello(i):\n    print(\"{}: {}\".format(i, requests.get(url).text))\n\n\ntasks = [gevent.spawn(hello, i) for i in range(50)]\ngevent.joinall(tasks)\n\n再来看看运行时间：\n$ time python3 gevent_get.py\n\n(输出略...)\npython3 gevent_get.py  0.49s user 0.06s system 39% cpu 1.403 total\n我的天！才1.4秒左右，而且打印出来的结果没有按照1, 2, 3...50这样排列，而是按照随机顺序排列的，说明整个请求是异步非阻塞的。\n结论\n我又多试了几次，gevent的效率确实牛，远远高于同步io请求。最近在我的一个爬虫小项目里面用进程池 + gevent，爬取80个页面，大概花费40s左右，每个页面只要0.5s，而且还包括DOM解析的时间，而用同步请求则花费大概300s左右。\ngevent的更多用法请参考其官方文档。这么简单又好用的库赶紧试试吧。^_^\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "4"}