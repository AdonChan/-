{"title": "用 docker 部署 mosquitto 并编译 mosquitto-auth-plug - 个人文章 ", "index": "部署,c,python,mosquitto-负载均衡,docker", "content": "mosquitto 的简介\nmosquitto 是一个开源的轻量级消息代理服务, 支持 MQTT-3.1 和 MQTT-3.1.1, 采用发布订阅模式. mosquitto 目前广泛用于手机设备, 底端传感器, 嵌入式计算机的消息通信, 是一个成熟的物联网通信服务方案. 作为一个用 C 编写的应用服务, mosquiitto 项目同样提供了 C library 便于 MQTT 服务的拓展, 比如有名的 mosquitto-auth-plug.\nmosquitto 的部署\n这里我们打算部署在 docker 容器内.\n在 docker 内构建\n参考 eclipse-mosquitto docker hub构建目录 /mosquitto目录结构是:\n- mosquitto\n    - config\n        - mosquitto.conf\n    - data\n    - log\n其中 mosquitto.conf 的内容是:\npersistence true\npersistence_location /mosquitto/data/\nlog_dest file /mosquitto/log/mosquitto.log\n在 docker 内启动\n启动命令:\n$ docker run -d -p 1883:1883 -p 9001:9001 -v mosquitto/:/mosquitto/ eclipse-mosquitto\n编译 mosquitto-auth-plug\n参考: https://www.loraserver.io/gui...\n准备工作\n注意: 在 docker 内部构建编译环境的时候(尤其是在 alpine 环境中)会经常出现:\ntemporary error (try again later)\n这是因为在获取像openssl,build-base之类包的时候, 需要从一些官方的镜像库中获取, 而由于国内的\"某些\"网络原因, DNS 往往不能直接解析到官方镜像库. 参考这篇文章:彻底解决docker build时安装软件失败问题, 可以用tcpdump观察这一现象. 所以我们最好先安排一下宿主机的 DNS.\n查看本机 nameserver\n根据阿里云ECS启动Docker容器无法访问外网这篇文章, 我们可以这样来获取本机 nameserver:\n$ cat /etc/resolv.conf\nnameserver 10.143.xx.xxx\nnameserver 10.143.xx.xxy\noptions timeout:2 attempts:3 rotate single-request-reopen\n这里我们可以看到有可能有多个域名解析服务地址, 这是一种容灾措施, 如果其中一个解析失败了, 在若干次尝试后会使用另外一个服务器去解析. 我们选取其中一个就好.\n然后修改/etc/docker/daemon.json, 添加:\n\"dns\": [\"10.143.xx.xxx\"]\n重启守护进程:\n$ sudo systemctl daemon-reload\n// 最好也重启一下docker\n$ sudo systemctl restart docker\n当然, 如果网络环境足够好(比如在国外), 可以不需要配置 DNS. 即使不配置 DNS, 也有一定的几率安装软件都成功.\n修改软件源为国内加速镜像\n现在发现单纯改 DNS 还是经常会下载软件失败, 只好修改容器的软件源了. 在 Dockerfile 中将 aliyun 的软件源写入 /etc/apk/repositores:\nRUN echo \"http://mirrors.aliyun.com/alpine/v3.4/main/\" > /etc/apk/repositories\n创建宿主机文件目录结构\n目录结构如下:\n- mosquitto\n    - Dockerfile\n    - config\n        - mosquitto.conf\n        - config.mk\n    - data\n    - log\n    - src\n- postgres\n    - Dockerfile\n- docker-compose.yml\n其中config放置 mosquitto 的启动配置mosquitto.conf和 mosquitto-auth-plug 的编译配置config.mk. data, log分别作为 mosquitto 的数据存储目录和日志存储目录, src用于放置编译需要的源文件.\n配置 mosquitto.conf\nmosquitto.conf 应该声明 mosquitto-auth-plug 插件编译之后生产的 auth-plug.so的位置, 并说明 postgres 数据库的连接用户, 连接端口, 连接密码, 以及处理权限和读写的 sql 语句. 参考:Setting up ACL in Mosquitto using Postgres, 和MQTT authentication & authorization, 和mosquitto-auth-plug 在 github 上的 README.下面是一个可供参考和使用的 mosquitto.conf:\npersistence true\npersistence_location /mosquitto/data/\nlog_dest file /mosquitto/log/mosquitto.log\n\nallow_anonymous false\n\nauth_plugin /mosquitto/src/mosquitto-auth-plug/auth-plug.so\nauth_opt_backends postgres\n\nauth_opt_host pgsql_db\nauth_opt_port 5432\nauth_opt_dbname mosquitto\nauth_opt_user root\nauth_opt_pass root_password\n\nauth_opt_userquery SELECT password FROM account WHERE username = $1 limit 1\nauth_opt_superquery SELECT COALESCE(COUNT(*), 0) FROM account WHERE username = $1 AND super = 1\nauth_opt_aclquery SELECT topic FROM acls WHERE (username = $1) AND rw >= $2\n配置 config.mk\n这里我们打算将 postgres 作为验证后端, 因此 config.mk 应该是这样的:\nBACKEND_CDB ?= no\nBACKEND_MYSQL ?= no\nBACKEND_SQLITE ?= no\nBACKEND_REDIS ?= no\nBACKEND_POSTGRES ?= yes \nBACKEND_LDAP ?= no\nBACKEND_HTTP ?= no\nBACKEND_JWT ?= no\nBACKEND_MONGO ?= no\nBACKEND_FILES ?= no\nBACKEND_MEMCACHED ?= no\n\nMOSQUITTO_SRC = /mosquitto/src/mosquitto/src\nOPENSSLDIR = /usr/lib\nSUPPORT_DJANGO_HASHERS ?= no\nCFG_LDFLAGS =\nCFG_CFLAGS =\nOPENSSLDIR 指定为 /usr/lib,MOSQUITTO_SRC 指定为/mosquitto/src/mosquitto/src, 也可以不需要指定, 因为在容器中已经安装了 mosquitto, 编辑脚本可以从环境中获取源码地址, 这样甚至后面我们都不需要用 git 从 github 上拉取 mosquitto 的源码了.\n编写 Dockerfile\n镜像的源来自 eclipse mosquitto 的 Docker Hub, 基于 alpine linux.这是我根据编译经验写的Dockerfile:\nFROM eclipse-mosquitto\nWORKDIR /mosquitto\nADD mosquitto/config /mosquitto/config\n\nRUN apk update && \\\n    apk add git && \\\n    apk add mosquitto-dev && \\\n    apk add postgresql-dev && \\\n    apk add openssl && \\\n    apk add build-base && \\\n    git clone https://github.com/eclipse/mosquitto /mosquitto/src/mosquitto && \\\n    git clone https://github.com/jpmens/mosquitto-auth-plug /mosquitto/src/mosquitto-auth-plug && \\\n    mv /mosquitto/config/config.mk /mosquitto/src/mosquitto-auth-plug/config.mk && \\\n    cd /mosquitto/src/mosquitto-auth-plug && \\\n    make clean && make\n\nEXPOSE 1881 9001\n可以看到这里我们安装了以 postgresql 为后端编译 auth-plug 需要的依赖: mosquitto-dev, postgresql-dev, openssl, 和 C 语言的 GCC 编译环境build-base. 用 git 拉取了 mosquitto 和 mosqtuitto-auth-plug 的源码. 最后使用自定义的 config.mk 进行 make 编译.\n编写 docker-compose.yml\n打算用容器编排工具 docker-compose 运行编译了 mosquitto-auth-plug 的 mosquitto 容器, 下面是一个可供使用和参考的 docker-compose.yml:\nversion: '3'\nservices:\n  mosquitto:\n    build: ./Dockerfile_mosquitto\n    volumes:\n      - ./mosquitto/config/mosquitto.conf:/mosquitto/config/mosquitto.conf\n    command: ['mosquitto', '-c', '/mosquitto/config/mosquitto.conf']\n    ports:\n      - '1881:1881'\n      - '9001:9001'\n部署 postgres 后端\n前面已经把 mosquitto 部署成功, 但是由于这里我们打算让 mosquitto 的权限认证和读写认证交给 postgres(不然为什么我们要花那么费劲去编译 mosquitto-auth-plug?), 所以我们还要部署一个 mosquitto 可以访问的 postgres 后端或者在已有的 postgres 上创建相关的表结构. 注意 postgres 后端的用户, 密码等应该和 mosquitto.conf 上配置的一致.\n编写 postgres 的 docker-compose.yml\n直接在原有的 docker-compose.yml 上加一个 service:\nservices:\n  ...\n  postgres_db:\n    image: postgres\n    environment:\n      POSTGRES_DB: mosquitto\n      POSTGRES_USER: root\n      POSTGRES_PASSWORD: root_password\n这里我们不暴露 postgres 的 5432 端口, 因为 docker 内部的同一个网络可以直接通过容器名字来访问对应的容器, 而且我们不希望容器外的其他人可以访问数据库. 注意这里的POSTGERS_USER应该和 mosquitto.conf 中的auth_opt_user对应, 类似的也有POSTGRES_DB, POSTGRES_PASSWORD. 而容器名字postgres_db可以成为auth_opt_host的值, docker 会为这个 host 做 DNS 解析.\n然后我们就可以直接运行 postgres 容器:\n$ docker-compose up -d\n初始化 postgres\n为了满足 mosquitto-auth-plug 的业务需求, 需要为 postgres 生成对应的表, 可以参考mosquitto-auth-plug/examples/mysql.sql\nCREATE TABLE account(\nid SERIAL,\nusername TEXT NOT NULL,\npassword TEXT,\nsuper smallint DEFAULT 0 NOT NULL,\nPRIMARY KEY (id)\n);\n\nCREATE INDEX account_username ON account (username);\n\nCREATE TABLE acls (\nid SERIAL,\nusername TEXT NOT NULL,\ntopic TEXT NOT NULL,\nrw INTEGER NOT NULL DEFAULT 0,\nPRIMARY KEY (id)\n);\n\nCREATE UNIQUE INDEX acls_user_topic ON acls (username, topic);\n这些 SQL 语句也可以写在 Dockerfile 里面作为第一次构建时就执行的.接着就可以插入几条测试数据了. 用户的密码生成需要使用 mosquitto-auth-plug 提供的密码生成器, 它是以 PBKDF2 的形式储存在数据库后端的.\n比如我们 进入 mosquitto 容器内:\n$ docker exec -it <mosquitto_auth_container_id> /bin/sh\n为用户生成一个明文为123456的密码:\n$ /mosquitto/src/mosquitto-auth-plug/np\nEnter password:\nRe-enter same password:\nPBKDF2$sha256$901$Yf1FSeMi1j7OjWdW$u1MqFR7iIZj+m6P7vKDvuMx+oDDJW4ub\n之后为 account 表内为test_user添加一条记录:\n> INSERT INTO account(username, pasword, super) values (\n    'test_user', \n    'PBKDF2$sha256$901$Yf1FSeMi1j7OjWdW$u1MqFR7iIZj+m6P7vKDvuMx+oDDJW4ub',\n    0)\n并设定test_user对于 topic /topic1为可读可写:\n> INSERT INTO acls(username, topic, rw) values (\n    'test_user',\n    '/topic1',\n    2)\n现在数据库内的记录是:\n id | username |                              password                               | super \n----+----------+---------------------------------------------------------------------+-------\n  1 | test_user | PBKDF2$sha256$901$S55aebUoogFy6XSf$E6PbQWDFQ06KLFlqqR3x+NBjg6ixjwez |     0\n\n\n id | username |   topic    | rw \n----+----------+------------+----\n  1 | test_user| /topic1    | 2\n意味着用户 test_user 可以用密码123456向 topic topic1 发布主题和订阅主题.\n搭建应用环境进行测试\n我们这里用 python 中同样实现了 mqtt 协议的 paho-mqtt 进行测试, 如果生产环境是使用 python 的话, 也可以直接使用这个库作为连接库.安装很简单的:\n$ pip install paho-mqtt\n搭建一个 python-alpine 容器:\n应用程序代码就放在 python-alpine 容器里好了. 下面是一个可供参考和使用的 docker-compose.yml:\nservices:\n  mqtt_server:\n    image: python-alpine\n    command: ['tail']\n用 docker-compose up mqtt_server -d 使得该容器挂起, 然后用docker exec -it <container_id> /bin/sh黑魔法进入容器. 编写一个测试用的订阅者(client.py):\nimport paho.mqtt.client as mqtt\nimport time\n\nHOST = 'mosquitto'\nPORT = 1883\n\ndef client_loop():\n    client_id = time.strftime('%Y%m%d%H%M%S', time.localtime(time.time()))\n    client = mqtt.Client(\n        client_id=client_id, clean_session=True)\n    client.username_pw_set('test_user', '123456')\n    client.on_connect = on_connect \n    client.on_message = on_message\n    client.connect(HOST, PORT, 60)\n    client.loop_forever()\n\ndef on_connect(client, userdata, flags, rc):\n    print('Connected with result code ' + str(rc))\n    client.subscribe('/topic1')\n\ndef on_message(client, userdata, msg):\n    print(msg.topic + ' ' + msg.payload.decode('utf-8'))\n\nif __name__ == '__main__':\n    client_loop()\n然后编写一个测试用的发布者(publish.py):\nimport paho.mqtt.publish as publish\nimport time\n\nHOST = 'mosquitto'\nPORT = 1883\n\nif __name__ == '__main__':\n    client_id = time.strftime('%Y%m%d%H%M%S', time.localtime(time.time()))\n    publish.single('topic1', 'hello mqtt', qos=2, hostname=HOST, port=PORT,\n            client_id=client_id, auth={'username': 'test_user', 'password': '123456'})\n当运行 client.py 之后, client 陷入监听 mosquitto 的状态, 等待收到发送在 topic topic1 的消息。 再运行一次 publish.py, 它往 topic1发送了一个消息, 我们可以看到 client.py 就已经收到了.\n总结\n我们成功地搭建了一个 mosquitto 的消息代理服务, 并为它编译了 mosquitto-auth-plug, 可以供后续后端消息业务的开发. 详细代码也可以参考已经上传到 github 的 example.\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "1"}