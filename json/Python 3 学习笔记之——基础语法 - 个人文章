{"title": "Python 3 学习笔记之——基础语法 - 个人文章 ", "index": "python", "content": "1. a, b = a, a + b\n先计算右边表达式，然后再同时赋值给左边。\n2. 条件控制和循环语句\n条件控制\nif condition_1:\n    statement_block_1\nelif condition_2:\n    statement_block_2\nelse:\n    statement_block_3\nwhile 循环\nwhile condition:\n    statement_block\nelse:  # 可有可无\n    statement_block\nfor 循环\nfor <variable> in <sequence>:\n    <statements>\nelse:\n    <statements>\nrange() 函数\n>>> a = list(range(3))\n>>> a\n[0, 1, 2]\n>>> a = list(range(1, 5, 2))\n>>> a\n[1, 3]\n\nbreak 语句可以跳出 for 和 while 的循环体。如果你从 for 或 while 循环中终止，任何对应的循环 else 块将不执行。\npass是空语句，是为了保持程序结构的完整性。pass 不做任何事情，一般用做占位语句。\n\n3. 迭代器和生成器\n字符串，列表或元组对象都可用于创建迭代器。\n>>> a = [1, 2, 3, 4]\n>>> it = iter(a)\n>>> next(it)\n1\n>>> next(it)\n2\n>>> next(it)\n3\n>>> next(it)\n4\n>>> next(it)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nStopIteration\n\n>>> it = iter(a)\n>>> for i in it:\n...     print(i)\n... \n1\n2\n3\n4\n>>>\n创建自己的迭代器，需要在类中实现实现两个方法 __iter__() 与 __next__() 。__iter__() 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 __next__() 方法并通过 StopIteration 异常标识迭代的完成。\nclass MyNumbers:\n    def __iter__(self):\n        self.a = 1\n        return self\n \n    def __next__(self):\n        if self.a <= 5:\n            x = self.a\n            self.a += 1\n            return x\n        else:\n            raise StopIteration\n\n\nmyclass = MyNumbers()\nmyiter = iter(myclass)\n\nfor i in range(5):\n    print(next(myiter))\n\nfor x in myiter:\n    print(x)\n\n>>>\n1\n2\n3\n4\n5\n在 Python 中，使用了 yield 的函数被称为生成器（generator）。跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。\nimport sys\n\n\ndef fibonacci(n):  # 生成器函数 - 斐波那契\n    a, b, counter = 0, 1, 0\n    while True:\n        if counter > n:\n            return\n        yield a\n        a, b = b, a + b\n        counter += 1\n\n\nf = fibonacci(10)  # f 是一个迭代器，由生成器返回生成\n\nwhile True:\n    try:\n        print(next(f), end=\" \")\n    except StopIteration:\n        sys.exit()\n\n>>> 0 1 1 2 3 5 8 13 21 34 55 \n4. 函数\nPython 定义函数使用 def 关键字，一般格式如下：\ndef function_name(args1, args2):\n    statement\n    return\n\nreturn [表达式]  结束函数，选择性地返回一个值给调用方。不带表达式的 return 相当于返回 None。\n可更改(mutable)与不可更改(immutable)对象\n\n在 Python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list, dict 等则是可以修改的对象。\n\n不可变类型：变量赋值 a = 5 后再赋值 a = 10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变 a 的值，相当于新生成了 a 。\n可变类型：变量赋值 la = [1,2,3,4] 后再赋值 la[2] = 5 则是将 list la 的第三个元素值更改，本身 la 没有动，只是其内部的一部分值被修改了。\n\n\nPython 函数的参数传递：\n不可变类型：类似 c++ 的值传递，如整数、字符串、元组。如 fun(a)，传递的只是 a 的值，没有影响 a 对象本身。比如在 fun(a) 内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。\n可变类型：类似 c++ 的引用传递，如列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响。\nPython 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。\n\n参数\n\n\n必需参数。必需参数须以正确的顺序传入函数，调用时的数量必须和声明时的一样。\n\n关键字参数 。关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。\n\n默认参数。调用函数时，如果没有传递参数，则会使用默认参数。\n\n不定长参数。你可能需要一个函数能处理比当初声明时更多的参数，这些参数叫做不定长参数，它们在声明时不会命名。\n\ndef functionname([formal_args,] *var_args_tuple ):\n    \"函数_文档字符串\"\n    function_suite\n    return [expression]\n\n\n加了星号 * 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数。如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。\ndef functionname([formal_args,] **var_args_dict ):\n    \"函数_文档字符串\"\n    function_suite\n    return [expression]\n\n加了两个星号 ** 的参数会以字典的形式导入。\n\n匿名函数\n\n所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。\nlambda 只是一个表达式，函数体比 def 简单很多。\nlambda 的主体是一个表达式，而不是一个代码块。仅仅能在 lambda 表达式中封装有限的逻辑进去。\nlambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。\n虽然 lambda 函数看起来只能写一行，却不等同于 C 或 C++ 的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。\n\n   sum = lambda arg1, arg2: arg1 + arg2\n   print (\"相加后的值为 : \", sum( 10, 20 ))\n   print (\"相加后的值为 : \", sum( 20, 20 ))\n  \n   >>>\n  相加后的值为 :  30\n  相加后的值为 :  40\n\n\n5. 列表推导式\nvec = [2, 4, 6]\n[3 * x for x in vec if x > 3] \n>>>\n[12, 18]\n\nmatrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ]\n[[row[i] for row in matrix] for i in range(4)]\n>>>\n[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\n6. 遍历技巧\n\n在序列中遍历时，索引位置和对应值可以使用 enumerate() 函数同时得到。\n同时遍历两个或更多的序列，可以使用 zip() 组合。\n要反向遍历一个序列，首先指定这个序列，然后调用 reversed() 函数。\n要按顺序遍历一个序列，使用 sorted() 函数返回一个已排序的序列，并不修改原值。\n\na = [2, 4, 6]\nfor i, v in enumerate(a):\n    print(i, v)\n>>>\n0 2\n1 4\n2 6\n\n>>> b = ['sen', 'ius', 'en']\n>>> for i, j in zip(a, b):\n...     print(i, j)\n... \n2 sen\n4 ius\n6 en\n\n>>> for i in reversed(a):\n...     print(i)\n... \n6\n4\n2\n>>> for i in sorted(b):\n...     print(i)\n... \nen\nius\nsen\n>>> \n\n参考资料 菜鸟教程\n获取更多精彩，请关注「seniusen」! \n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}