{"title": "NetworkX能做什么0？ - 我们俩 ", "index": "networkx,python", "content": "对complex network 进行分析\n\n1. 建立图\n\n无向图\n\ng=networkx.Graph()\ng.add_edge(\"nodename1\",\"nodename2\")\ng.add_node(\"nodename1\")\n\n\n有向图\n\ng=networkx.DiGraph()\ng.add_edges_from([(\"nodename1\",\"nodename2\"),(\"nodename3\",\"nodename1\")])\n\n\n从文件读图\n可支持.edges(Edge List Format)与.txt(Ajacency List Format)详情见博客另一篇日志权重图\n\ng.add_edge(\"nodename1\",\"nodename2\",weight = Value)\n\n\n增加点的属性\n\ng.add_node(\"nodename1\")\ng.add_node(\"nodename1\"，\"attribute1\",\"attribute2\")\n\n\n如何选出边的权重超过一个阈值的边\n\nestrong = [(u,v) for (u,v,d) in g.edges(data = True) if d[\"weigth\"] >THESHOLD]\n\n\n2. 基本分析\n\n边数与点数\n\nprint g.number_of_nodes()\nprint g.number_of_edges()\n\n\n度\n分析某个顶点的度(无向图)\n\ng.degree(\"nodename\")\n\n\n分析某个顶点的入度\\出度(有向图)\n\ng.in_degree(\"nodename\")\ng.out_degree(\"nodename\")\n\n\n图的度，将每个顶点的度列出\n\ng.degree() #无向图\ng.in_degree(with_labels = True)#有向图\ng.out_degree(with_labels = True)\ng.degree(\"nodename\",weigted = False)#权重图\n**g.degree(\"nodename\",weighed = True)** 可以用做计算点强度\n\n\n邻居节点\n\ng.neighbors(\"nodename\")\n\n\n有向图convert无向图\n\nug = g.to_undirected()\n\n\n图的连通性\n\nprint networkx.is_connnected(g) #判断是否是连通图\nprint networkx.number_connected_components(g)#判断有几个连通子图\ncomps = networkx.number_connected_components_subgraphs(g)\ncomps[0].nodes() #分别列出\ncomps[1].nodes() \n...\n\n\n3. 分析图的局部性质\n\ng = network.read_adjlist(\"test.adj\")\nego = \"nodename\"\nnodes = set[ego]\nnodes.update(g.neighbors(ego))\negonet = g.subgraph(nodes)\n\n\n\n\n4. 二分网络\n\n建立二分网络\n\nimport networkx\nfrom network.algorithm import bipartite\ng.add_edges_from([(\"nodename1\",\"nodename2\"),(\"nodename3\",\"nodename1\")])\n\n\n判断是否是二分网络\n\nprint  bi_partite.is_bipartite(g)\n\n\n得到两端网络\n\nNSet = nx.bipartite.sets(g) \nNet1 = nx.project(g,NSet[0])\nNet2 = nx.project(g,Nset[1])\n\n\n(PS,谁能告诉我当原始网络g顶点少和顶点多的时候Net1,Net2得到的结果是颠倒的，这是为什么...)\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}