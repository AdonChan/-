{"title": "Python-标准库 - 个人文章 ", "index": "python", "content": "Python-标准库\n一译\nhttp://python.usyiyi.cn\n廖雪峰\nhttps://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386820066616a77f826d876b46b9ac34cb5f34374f7a000\n[TOC]\n\n1 内建函数\nThe Python interpreter has a number of functions built into it that are always available.\n内建函数 http://python.usyiyi.cn/trans...\n\n\n\n内\n建\n函\n数\n..\n\n\n\nabs()\ndivmod()\ninput()\nopen()\nstaticmethod()\n\n\nall()\nenumerate()\nint()\nord()\nstr()\n\n\nany()\neval()\nisinstance()\npow()\nsum()\n\n\nbasestring()\nexecfile()\nissubclass()\nprint()\nsuper()\n\n\nbin()\nfile()\niter()\nproperty()\ntuple()\n\n\nbool()\nfilter()\nlen()\nrange()\ntype()\n\n\nbytearray()\nfloat()\nlist()\nraw_input()\nunichr()\n\n\ncallable()\nformat()\nlocals()\nreduce()\nunicode()\n\n\nchr()\nfrozenset()\nlong()\nreload()\nvars()\n\n\nclassmethod()\ngetattr()\nmap()\nrepr()\nxrange()\n\n\ncmp()\nglobals()\nmax()\nreversed()\nzip()\n\n\ncompile()\nhasattr()\nmemoryview()\nround()\n__import__()\n\n\ncomplex()\nhash()\nmin()\nset()\napply()\n\n\ndelattr()\nhelp()\nnext()\nsetattr()\nbuffer()\n\n\ndict()\nhex()\nobject()\nslice()\ncoerce()\n\n\ndir()\nid()\noct()\nsorted()\nintern()\n\n\n\n2 内置类型\n2.1. 真值的测试\n下面的值被视为假：\nNone\nFalse\n任何数值类型的零，例如，0、 0L、0.0、 0j。\n任何空的序列，例如， ''、 ()、 []。\n任何空的映射，例如，{}。\n用户定义的类的实例，如果该类定义一个__nonzero__()或__len__()的方法，在该方法返回整数零或布尔值False时。[1]\n2.2. 布尔操作 — and, or, not\nand or not\n2.3. 比较操作\n\n\n操作\n含义\n注\n\n\n\n<\n严格地小于\n\n\n<=\n小于或等于\n\n\n\n|严格地大于| =|大于或等于| ==|等于| != or <>|不等于|is|对象的ID| is not|不同的对象ID|类的非同一个实例比较时通常不相等，除非该类定义__eq__()或__cmp__()方法。\n一个类的实例通常不能与同一个类的其它实例或者其他类型的对象排序，除非该类定义足够丰富的比较方法（__ge__()、__le__()、__gt__()、__lt__()）或__cmp__()方法。\n\n2.4. 数值类型 — int, float, long, complex\n\n有四种不同的数值类型：普通整数、长整数、浮点数和复数。此外，布尔值是普通整数的一个子类型。普通整数（或者简称整数）使用C中的long实现，其精度至少为32位（sys.maxint始终设置为当前平台最大的普通整数值，最小值是-sys.maxint - 1)。长整数具有无限的精度。浮点数字通常使用C中的double实现；有关你的程序所运行的机器上的浮点数精度及其内部表示形式的信息在sys.float_info中可以获得。复数有实部和虚部，各是一个浮点数。若要从复数z中提取这些部分，请使用z.real和z.imag。（标准库包括额外的数值类型，fractions支持有理数，decimal支持用户自定义精度的浮点数。）\n数值通过数字字面值或内建的函数和操作的结果创建。普通的整数字面值（包括二进制、十六进制和八进制数字）产生普通整数，除非它们指定的值太大以致不能用一个普通的整数表示，在这种情况下它们产生一个长整型。带有'L'或'l'后缀的整数字面值产生长整数（偏向使用'L'，因为1l看起来太像十一）。包含小数点或指数符号的数字字面值产生浮点数。将'j'或'J'附加到数字字面值的尾部产生实部为零的复数。复数字面值是实部和虚部的和。\nPython完全支持混合的算法：当二元算术运算符的操作数是不同的数值类型时，“较窄”类型的操作数会拓宽成另外一个操作数的类型，其中整数窄于长整数窄于浮点数窄于复数。比较混合型数字之间使用相同的规则。[2]构造函数int()、long()、float()和complex()可用于产生的一种特定类型的数值。\n\n\n\n操作\n含义\n注\n\n\n\nx + y\nx与y和\n\n\nx - y\nx与y的差\n\n\nx * y\nx与y的积\n\n\nx / y\nx与y的商\n(1)\n\n\nx // y\nx与y的（整除）商\n(4)(5)\n\n\nx % y\nx / y的余数\n(4)\n\n\n-x\n负x\n\n\n+x\nx保持不变\n\n\nabs(x)\nx的绝对值或大小\n(3)\n\n\nint(x)\nx转换成整数\n(2)\n\n\nlong(x)\nx转换成长整数\n(2)\n\n\nfloat(x)\nx转换成浮点数\n(6)\n\n\ncomplex(re,im)\n实部为re，虚部为im的一个复数。im默认为零。\n\n\nc.conjugate()\n复数c的共轭。（用实数表示）\n\n\ndivmod(x, y)\n元组(x // y, x % y)\n(3)(4)\n\n\npow(x, y)\nx的y次方\n(3)(7)\n\n\nx ** y\nx的y次方\n(7)\n\n\n\n注：\n\n1 对于（普通或长）整数除法，结果是一个整数。结果总是向负无穷舍入：1/2是0，(-1)/2是-1，1/(-2)是-1，（-1)/(-2)是0。请注意如果任何一个操作数是长整数，结果都会是一个长整数，与值大小无关。\n\n2 使用int()或long()函数转换浮点数会向零截断，类似相关的函数math.trunc()函数。使用函数math.floor()以向下取整和math.ceil()以向上取整。\n\n3 完整的说明请参阅内置函数。\n\n4 从2.3版开始弃用：整除运算符、取模运算符和divmod()函数不再为复数定义。相反，如果合适，可以使用abs()函数转换为浮点数。\n\n5 也被称为整数除法。结果是一个整数，但其类型不一定是int型。\n\n6 浮点数还接受可带有可选前缀 \"+\"或\"-\"的字符串\"nan\"和\"inf\"来表示非数字（NaN)）和正/负无穷。\n\n7 在2.6版中新增。\n\n8 Python定义pow(0,0)和0 ** 0为1，这对于编程语言很常见。\n2.4.1 整数类型的位操作\n\n按位运算只有对整数才有意义。负数被视为它们2的补值（这假定操作过程中有足够多的位数而没有发生溢出）。\n二元位运算的优先级都低于数值操作，但高于比较操作；一元操作~具有和其它的一元数值操作（+和-）相同的优先级。\n下表按优先级升序排列列出位运算（在同一格中的操作具有相同的优先级）：\n\n\n\n操作\n含义\n注\n\n\n\nx\ny\nx和y的按位或\n\n\nx ^ y\nx和y的按位异或\n\n\nx & y\nx和y的按位与\n\n\nx << n\nx左移n位\n(1)(2)\n\n\nx >> n\nx右移n位\n(1)(3)\n\n\n~x\n反转x的各个位\n\n\n\n注\n负的移位数目是非法的并导致引发一个ValueError。\n左移n等同于乘以pow(2, n)。如果结果超过普通整数的范围则返回一个长整数。\n右移n位等同于除以pow(2, n)。\n2.4.2 整数类型其他方法\nlong.bit_length()返回以二进制表示一个整数必须的位数，不包括符号和前导零：\n>>> n = -37\n>>> bin(n)\n'-0b100101'\n>>> n.bit_length()\n6\n2.4.3 浮点数的其它方法\n<font color=#0099ff size=3 face=\"楷体\">float.is_integer() : 如果浮点数实例仅有整数，则返回True，否则返回False\nfloat.hex()\nfloat.fromhex(s)</font>\n2.5. 迭代器类型\nPython支持容器上迭代的概念。这种实现使用两种截然不同的方法；它们都用于允许用户定义的类支持迭代。下面有更多细节描述的序列始终支持迭代方法。\n容器对象需要定义一种方法以支持迭代：\ncontainer.__iter__()返回迭代器对象。该对象必须支持如下所述的迭代器协议。如果一个容器支持不同类型的迭代，可以提供额外的方法来为这些迭代类型要求特定的迭代器。（对象支持多种迭代形式的一个示例是支持广度和深度优先遍历的树结构）。此方法对应于Python/C API中Python对象的类型结构的tp_iter 部分。\n迭代器对象本身需要支持以下两种方法，它们组合在一起形成迭代器协议：\niterator.__iter__()返回迭代器对象本身。这允许容器和迭代器都可以在for和in语句中使用。此方法对应于Python/C API中Python对象的类型结构的tp_iter slot。\niterator.next()从容器中返回下一个元素。如果没有元素，引发StopIteration异常。此方法对应于Python/C API中Python对象的类型结构的tp_iternext slot。\nPython定义了几个迭代器对象以支持在通用和特定的序列类型、字典以及其他更多特殊形式上的迭代。相比迭代器协议的实现，具体的类型并不重要。\n该协议的意图是一旦迭代器的next()方法引发StopIteration，后续调用将继续这样的行为。不遵守此性质的实现被认为是有问题的。（此约束在Python 2.3中添加；在Python 2.2中，有多个迭代器违背了此规则）。\n2.5.1  生成器类型\nPython的生成器提供一种方便的方法来实现迭代器协议。如果容器对象的__iter__()方法实现为一个生成器，它将自动返回一个提供__iter__()和next()方法的迭代器对象（从技术上讲，是生成器对象）。生成器的更多信息可以在yield表达式的文档中找到。\n2.6. 序列类型 — str, unicode, list, tuple, bytearray, buffer, xrange\n其他容器请参阅内建的dict和set类，以及collections模块。\n字符串常量写在单引号或双引号中：'xyzzy'，\"frobozz\"。字符串字面值的更多信息请参阅字符串字面值。Unicode字符串与字符串非常相似，但是使用特殊的语法即一个前导的字符'u'指定：u'abc'，u\"def\"。除了这里描述的功能之外，字符串还有特定的方法在字符串方法一节中描述。列表使用方括号构造，元素以逗号分隔：[a, b, c]。元组通过逗号操作符构造（不在方括号中）， 带或者不带圆括号，但是空元组必须具有圆括号，例如a, b, c或()。单个元素的元组必须含有一个尾部的逗号，例如(d,)。\n字节数组对象使用内置函数bytearray()来创建。\nPython语法不直接支持缓冲区对象，但可以通过调用内置函数buffer()创建。它们不支持连接或重复。\nxrange类型的对象类似于缓冲区，没有特定的语法来创建它们，而是使用xrange()函数创建它们。它们不支持切片、 连接或重复，在它们上使用in，not in、 min()或max()效率较低。\n大多数的序列类型支持以下操作。in和not in操作具有与比较操作相同的优先级。+和*的操作具有与相应的数值操作相同的优先级。[3]可变序列类型还提供其他的方法。\n下标按优先级升序排列序列的操作（在相同格子中的操作具有相同的优先级）。在表中，s和t是类型相同的序列；n、i和j是整数：\n\n\n操作\n含义\n注\n\n\n\nx in s\nTrue if an item of s is equal to x, else False\n(1)\n\n\nx not in s\nFalse if an item of s is equal to x, else True\n(1)\n\n\ns + t\nthe concatenation of s and t\n(6)\n\n\ns  n, n  s\nn shallow copies of s concatenated\n(2)\n\n\ns[i]\nith item of s, origin 0\n(3)\n\n\ns[i:j]\nslice of s from i to j\n(3)(4)\n\n\ns[i:j:k]\nslice of s from i to j with step k\n(3)(5)\n\n\nlen(s)\nlength of s\n\n\nmin(s)\nsmallest item of s\n\n\nmax(s)\nlargest item of s\n\n\ns.index(x)\nindex of the first occurrence of x in s\n\n\ns.count(x)\ntotal number of occurrences of x in s\n\n\n\n2.6.1. 字符串的方法\n#!C:/Python27/python\n# -*- coding: utf8 -*-\nimport os\nimport sys\n\n# str function\n\nstr1=\"test_string_str\"\nstr11='胡畔'\n## 返回字符串的副本，该副本第一个字符大写，其余字符小写\nprint(str1.capitalize())\n##返回长度为width的字符串，并使得自身居中。使用指定的fillchar（默认为一个空格）做填充。\nstr2=str1.center(10,'-')\nprint(str2)\n##返回在[start, end]范围内的子串sub非重叠出现的次数。可选参数start和end都以切片表示法解释。\nstr2=str1.count(\"str\")\nprint(str2)\n##使用 encoding 中注册的编解码器，对字符串进行解码。\nstr2=str11.decode('gbk')\nprint(str2)\n## 返回该字符串编码后的版本\nstr2=str2.encode('gbk')\nprint(str2)\n## 如果字符串以指定的suffix结尾则返回True，否则返回False\nstr2=str1.endswith('str')\nprint(str2)\n\n## 返回在字符串中找到的子字符串sub的最低索引，使得sub包含在切片s[start:end]中\nstr2=str1.find('str')\nprint(str2)\n\n## 执行字符串格式化操作。调用此方法的字符串可以包含文本字面值或由花括号{}分隔的替换字段\nprint(\"The sum of 1 + 2 is {0}\".format(1+2))\n\n## 类似find()，但未找到子字符串时引发ValueError\nstr2=str1.index('str')\nprint(str2)\n\n## 如果字符串中的所有字符都是数字或者字母，并且至少有一个字符，则返回true，否则返回false。\nstr2=str1.isalnum()\nprint(str2)\n\n## 字符串至少有一个字符并且都是字母，则返回true，否则返回false\nstr2=str1.isalpha()\nprint(str2)\n\n## 如果在字符串中的所有字符都是数字并且至少一个字符，则返回 true。否则返回false。\nstr1.isdigit()\n\n## 如果在字符串中的所有套管井的字符[4]都小写，还有套管井的至少一个字符虚假否则返回 true。\nstr1.islower()\n\n## 返回一个字符串，为iterable可迭代对象中字符串的连接。元素之间的分隔符是提供该方法的字符串。\npath1='/home/ap'\nfile1='log.log'\nprint('/'.join([path1,file1]))\n\n## 返回删除前导字符的字符串的副本。Chars参数是一个字符串，指定要移除的字符集。如果省略或没有 chars参数默认为删除空格\nprint('/home/ap/'.lstrip('/'))\nprint('www.example.com'.lstrip('cmowz.'))\n\n## 在分隔符首次出现位置拆分字符串，并返回包含分隔符之前部分、分隔符本身和分隔符之后部分的3元组\nprint('/home/ap/cos/log.log'.partition('/'))\n\n## 返回字符串的一个拷贝，其中所有的子串old通过new替换。如果指定了可选参数count，则只有前面的count个出现被替换。\nprint('str_str_123'.replace('str','haha'))\n\n##如果给出maxsplit，则至多拆分maxsplit次（因此，列表中将最多有maxsplit+1个元素）。如果没有指定maxsplit或为-1，那么分割的数量没有限制（进行所有可能的分割）\nprint('/home/ap/cos/log.log'.rsplit('/',1))\n2.6.2. 字符串的格式化操作\n单独掌握\n2.6.3. XRange Type\nxrange类型是不可变的序列，通常用于循环。xrange类型的好处是xrange对象始终占用相同数量的内存，无论它表示的范围的大小。但它没有始终一致的性能优势\n2.6.4. 列表\n\n\n操作\n含义\n注\n\n\n\ns[i] = x\nitem i of s is replaced by x\n\n\ns[i:j] = t\nslice of s from i to j is replaced by the contents of the iterable t\n\n\ndel s[i:j]\nsame as s[i:j] = []\n\n\ns[i:j:k] = t\nthe elements of s[i:j:k] are replaced by those of t\n(1)\n\n\ndel s[i:j:k]\nremoves the elements of s[i:j:k] from the list\n\n\ns.append(x)\nsame as s[len(s):len(s)] = [x]\n(2)\n\n\ns.extend(x)\nsame as s[len(s):len(s)] = x\n(3)\n\n\ns.count(x)\nreturn number of i‘s for which s[i] == x\n\n\ns.index(x[, i[, j]])\nreturn smallest k such that s[k] == x and i <= k < j\n(4)\n\n\ns.insert(i, x)\nsame as s[i:i] = [x]\n(5)\n\n\ns.pop([i])\nsame as x = s[i]; del s[i]; return x\n(6)\n\n\ns.remove(x)\nsame as del s[s.index(x)]\n(4)\n\n\ns.reverse()\nreverses the items of s in place\n(7)\n\n\ns.sort([cmp[, key[, reverse]]])\nsort the items of s in place\n(7)(8)(9)(10)\n\n\n\n2.7. 集合类型 — set, frozenset\n集合对象是一个不同可哈希对象组成的无序集合。常见的使用包括成员测试、从序列中删除重复项和计算数学运算（如交、并、差和对称差）。（其它容器请参阅内建的字典、列表和元组类和collections模块。）\n类似其它容器，集合支持x in set、 len(set)以及for x in set。作为一个无序的集合，集合不记录元素位置和插入顺序。因此，集合不支持索引、 切片、 或其它类似于序列的行为。\n目前有两个内置的集合类型，set和frozenset。\n2.8. 映射类型 — dict\n2.9. 文件对象\n文件对象使用C的stdio包实现并可以用内置的open()函数创建。文件对象也会由一些其它内置的函数和方法返回，如os.popen()和os.fdopen()以及套接字对象的makefile()方法。临时文件可以通过tempfile模块创建，高级的文件操作如复制、移动和删除文件和目录可以通过shutil模块完成。\n2.9.1 简单文件打开\nf=open(r\"C:\\Users\\lynn\\Desktop\\123 .txt\")\ntry:\n    for line in f:\n        print(line.decode('utf-8'))\nfinally:\n    f.close()\n当with代码块退出时，下面的代码将自动关闭f\nfrom __future__ import with_statement # This isn't required in Python 2.6\n\nwith open(\"hello.txt\") as f:\n    for line in f:\n        print line,\n注 Python中不是所有的\"类文件式\"类型支持用作with语句的上下文管理器。如果你的代码是用于处理任何类似文件的对象，你可以使用函数contextlib.closing()而不是直接使用对象。\n如果每次都这么手动转换编码嫌麻烦（写程序怕麻烦是好事，不怕麻烦就会写出又长又难懂又没法维护的代码），Python还提供了一个codecs模块帮我们在读文件时自动转换编码，直接读出unicode：\nimport codecs\nwith codecs.open('/Users/michael/gbk.txt', 'r', 'gbk') as f:\n    f.read() # u'\\u6d4b\\u8bd5'\n2.10. memoryview 类型\n2.11. 上下文管理器类型\n2.12. 其他的内建类型\n2.13. 特殊的属性\n3 函数式编程\n既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。\n3.1 函数及变量\n>>> abs = 10\n>>> abs(-10)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: 'int' object is not callable\n3.2 传入函数\ndef add(x, y, f):\n    return f(x) + f(y)\nmap() reduce() filter()\nmap()函数接收两个参数，一个是函数，一个是序列，map将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回。\n>>> def f(x):\n...     return x * x\n...\n>>> map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])\n[1, 4, 9, 16, 25, 36, 49, 64, 81]\nreduce把一个函数作用在一个序列[x1, x2, x3...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：\nreduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)\n\n>>> def add(x, y):\n...     return x + y\n...\n>>> reduce(add, [1, 3, 5, 7, 9])\n25\n\n>>> def fn(x, y):\n...     return x * 10 + y\n...\n>>> reduce(fn, [1, 3, 5, 7, 9])\n13579\n\n>>> def fn(x, y):\n...     return x * 10 + y\n...\n>>> def char2num(s):\n...     return {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}[s]\n...\n>>> reduce(fn, map(char2num, '13579'))\n13579\nfilter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。\ndef is_odd(n):\n    return n % 2 == 1\n\nfilter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15])\n# 结果: [1, 5, 9, 15]\n\ndef not_empty(s):\n    return s and s.strip()\n\nfilter(not_empty, ['A', '', 'B', None, 'C', '  '])\n# 结果: ['A', 'B', 'C']\nsorted:Python内置的sorted()函数就可以对list进行排序,此外，sorted()函数也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序。比如，如果要倒序排序，我们就可以自定义一个reversed_cmp函数：\ndef reversed_cmp(x, y):\n    if x > y:\n        return -1\n    if x < y:\n        return 1\n    return 0\n\n>>> sorted([36, 5, 12, 9, 21], reversed_cmp)\n[36, 21, 12, 9, 5]\n\n3.3 返回函数\ndef lazy_sum(*args):\n    def sum():\n        ax = 0\n        for n in args:\n            ax = ax + n\n        return ax\n    return sum\n---------------------------\n>>> f = lazy_sum(1, 3, 5, 7, 9)\n>>> f\n<function sum at 0x10452f668>\n\n当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数：\n注意到返回的函数在其定义内部引用了局部变量args，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行\n3.4 匿名函数\nmap(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9])\n[1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n----------------------\ndef f(x):\n    return x * x\n    \n3.5 装饰器\n\ndef log(func):\n    @functools.wraps(func)\n    def warpper(*args,**kw):\n        print \"call %s()\" % func.__name__\n        return func(*args,**kw)\n    return warpper\n\n@log\ndef now():\n    print '2013-12-25'\n\nnow()\nprint(now.__name__)\n\n3.6 偏函数\nfunctools.partial就是帮助我们创建一个偏函数的，不需要我们自己定义int2()，可以直接使用下面的代码创建一个新的函数int2：\n>>> import functools\n>>> int2 = functools.partial(int, base=2)\n>>> int2('1000000')\n64\n>>> int2('1010101')\n85\n4 模块\n4.1 别名\n导入模块时，还可以使用别名，这样，可以在运行时根据当前环境选择最合适的模块。比如Python标准库一般会提供StringIO和cStringIO两个库，这两个库的接口和功能是一样的，但是cStringIO是C写的，速度更快，所以，你会经常看到这样的写法：\ntry:\n    import cStringIO as StringIO\nexcept ImportError: # 导入失败会捕获到ImportError\n    import StringIO\n4.2 作用域\n\n类似__xxx__这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的__author__，__name__就是特殊变量，hello模块定义的文档注释也可以用特殊变量__doc__访问，我们自己的变量一般不要用这种变量名；\n类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用，比如_abc，__abc等；\n之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。\n\ndef _private_1(name):\n    return 'Hello, %s' % name\n\ndef _private_2(name):\n    return 'Hi, %s' % name\n\ndef greeting(name):\n    if len(name) > 3:\n        return _private_1(name)\n    else:\n        return _private_2(name)\n4.3 第三方模块使用(安装)\npip install module_name  (在线安装)\npip search  module_name\nCommands:\n  install                     Install packages.\n  download                    Download packages.\n  uninstall                   Uninstall packages.\n  freeze                      Output installed packages in requirements format.\n  list                        List installed packages.\n  show                        Show information about installed packages.\n  check                       Verify installed packages have compatible dependencies.\n  search                      Search PyPI for packages.\n  wheel                       Build wheels from your requirements.\n  hash                        Compute hashes of package archives.\n  completion                  A helper command used for command completion.\n  help                        Show help for commands.\n\nGeneral Options:\n  -h, --help                  Show help.\n  --isolated                  Run pip in an isolated mode, ignoring environment variables and user configuration.\n  -v, --verbose               Give more output. Option is additive, and can be used up to 3 times.\n  -V, --version               Show version and exit.\n  -q, --quiet                 Give less output. Option is additive, and can be used up to 3 times (corresponding to WARNING, ERROR, and CRITICAL logging levels).\n  --log <path>                Path to a verbose appending log.\n  --proxy <proxy>             Specify a proxy in the form [user:passwd@]proxy.server:port.\n  --retries <retries>         Maximum number of retries each connection should attempt (default 5 times).\n  --timeout <sec>             Set the socket timeout (default 15 seconds).\n  --exists-action <action>    Default action when a path already exists: (s)witch, (i)gnore, (w)ipe, (b)ackup, (a)bort.\n  --trusted-host <hostname>   Mark this host as trusted, even though it does not have valid or any HTTPS.\n  --cert <path>               Path to alternate CA bundle.\n  --client-cert <path>        Path to SSL client certificate, a single file containing the private key and the certificate in PEM format.\n  --cache-dir <dir>           Store the cache data in <dir>.\n  --no-cache-dir              Disable the cache.\n  --disable-pip-version-check\n                              Don't periodically check PyPI to determine whether a new version of pip is available for download. Implied with --no-index.\npip download module_name  (离线安装)\nhttps://segmentfault.com/a/11...\n1.在可以联网的开发机器上安装好需要的包\n1.下载指定的包到指定文件夹\npip install --download d:\\python27\\packages -r requirements.txt \n2 安装指定的离线包\npip install --no-index --find-index=d:\\python27\\packages -r requirements.txt\npip install --no-index --find-links=/home/ap/hupan Pillow\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}