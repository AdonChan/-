{"title": "Tensorflow快餐教程(12) - 用机器写莎士比亚的戏剧 - 个人文章 ", "index": "path,python", "content": "摘要： 如何用TFLearn，Keras等高层框架来学习自动生成莎翁的戏剧或者尼采的哲学文章\n高层框架：TFLearn和Keras\n上一节我们学习了Tensorflow的高层API封装，可以通过简单的几步就生成一个DNN分类器来解决MNIST手写识别问题。\n尽管Tensorflow也在不断推进Estimator API。但是，这并不是工具的全部。在Tensorflow官方的API方外，我们还有强大的工具，比如TFLearn和Keras。\n这节我们就做一个武器库的展示，看看专门为Tensorflow做的高层框架TFLearn和跨Tensorflow和CNTK几种后端的Keras为我们做了哪些强大的功能封装。\n机器来写莎士比亚的戏剧\n之前我们简单介绍了强大的用于处理序列数据的RNN。RNN比起其它网络的重要优点是可以学习了序列数据之后进行自生成。比如，学习《唐诗三百首》可以写诗，学习了Linux Kernel源代码就能写C代码（虽然基本上编译不过）。\n我们首先来一个自动写莎士比亚戏剧的例子吧。在看代码之前我先唠叨几句。深度学习对于数据量的要求还是比较高的，像训练自动生成的这种，一般得几百万到几千万量级的训练数据下才能有好的效果。比如只用几篇小说来训练肯定生成不知所云的小说。就算是人类也做不到只学几首诗就会写诗么。另外一点就是，训练数据量上来了，对于时间和算力的要求也是指数级提高的。比如我们用莎翁的戏剧来训练，虽然数据量也不是特别的大，也就16万多行，但是在CPU上训练的话也不是一两个小时能搞定的，大约是天为单位。后面我们举图像或视频的例子，在CPU上训，论月也是并不意外的。\n那么，这个需要训一天左右的例子，代码会多复杂呢？答案是核心代码不过10几行，总共加上数据处理和测试代码也不过50行左右。\nfrom __future__ import absolute_import, division, print_function\n\nimport os\nimport pickle\nfrom six.moves import urllib\n\nimport tflearn\nfrom tflearn.data_utils import *\n\npath = \"shakespeare_input.txt\"\nchar_idx_file = 'char_idx.pickle'\n\nif not os.path.isfile(path):\n    urllib.request.urlretrieve(\"https://raw.githubusercontent.com/tflearn/tflearn.github.io/master/resources/shakespeare_input.txt\", path)\n\nmaxlen = 25\n\nchar_idx = None\nif os.path.isfile(char_idx_file):\n  print('Loading previous char_idx')\n  char_idx = pickle.load(open(char_idx_file, 'rb'))\n\nX, Y, char_idx = \\\n    textfile_to_semi_redundant_sequences(path, seq_maxlen=maxlen, redun_step=3,\n                                         pre_defined_char_idx=char_idx)\n\npickle.dump(char_idx, open(char_idx_file,'wb'))\n\ng = tflearn.input_data([None, maxlen, len(char_idx)])\ng = tflearn.lstm(g, 512, return_seq=True)\ng = tflearn.dropout(g, 0.5)\ng = tflearn.lstm(g, 512, return_seq=True)\ng = tflearn.dropout(g, 0.5)\ng = tflearn.lstm(g, 512)\ng = tflearn.dropout(g, 0.5)\ng = tflearn.fully_connected(g, len(char_idx), activation='softmax')\ng = tflearn.regression(g, optimizer='adam', loss='categorical_crossentropy',\n                       learning_rate=0.001)\n\nm = tflearn.SequenceGenerator(g, dictionary=char_idx,\n                              seq_maxlen=maxlen,\n                              clip_gradients=5.0,\n                              checkpoint_path='model_shakespeare')\n\nfor i in range(50):\n    seed = random_sequence_from_textfile(path, maxlen)\n    m.fit(X, Y, validation_set=0.1, batch_size=128,\n          n_epoch=1, run_id='shakespeare')\n    print(\"-- TESTING...\")\n    print(\"-- Test with temperature of 1.0 --\")\n    print(m.generate(600, temperature=1.0, seq_seed=seed))\n    print(\"-- Test with temperature of 0.5 --\")\n    print(m.generate(600, temperature=0.5, seq_seed=seed))\n\n上面的例子需要使用TFLearn框架，可以通过\npip install tflearn\n\n来安装。\nTFLearn是专门为Tensorflow开发的高层次API框架。用TFLearn API的主要好处是可读性更好，比如刚才的核心代码：\ng = tflearn.input_data([None, maxlen, len(char_idx)])\ng = tflearn.lstm(g, 512, return_seq=True)\ng = tflearn.dropout(g, 0.5)\ng = tflearn.lstm(g, 512, return_seq=True)\ng = tflearn.dropout(g, 0.5)\ng = tflearn.lstm(g, 512)\ng = tflearn.dropout(g, 0.5)\ng = tflearn.fully_connected(g, len(char_idx), activation='softmax')\ng = tflearn.regression(g, optimizer='adam', loss='categorical_crossentropy',\n                       learning_rate=0.001)\n\nm = tflearn.SequenceGenerator(g, dictionary=char_idx,\n                              seq_maxlen=maxlen,\n                              clip_gradients=5.0,\n                              checkpoint_path='model_shakespeare')\n\n从输入数据，三层LSTM，三层Dropout，最后是一个softmax的全连接层。\n我们再来看一个预测泰坦尼克号幸存概率的网络的结构：\n# Build neural network\nnet = tflearn.input_data(shape=[None, 6])\nnet = tflearn.fully_connected(net, 32)\nnet = tflearn.fully_connected(net, 32)\nnet = tflearn.fully_connected(net, 2, activation='softmax')\nnet = tflearn.regression(net)\n\n# Define model\nmodel = tflearn.DNN(net)\n# Start training (apply gradient descent algorithm)\nmodel.fit(data, labels, n_epoch=10, batch_size=16, show_metric=True)\n\n从生成城市名字说起\n大家的莎士比亚模型应该正在训练过程中吧，咱们闲着也是闲着，不如从一个更简单的例子来看看这个生成过程。我们还是取TFLearn的官方例子，通过读取美国主要城市名字列表来生成一些新的城市名字。\n我们以Z开头的城市为例：\nZachary\nZafra\nZag\nZahl\nZaleski\nZalma\nZama\nZanesfield\nZanesville\nZap\nZapata\nZarah\nZavalla\nZearing\nZebina\nZebulon\nZeeland\nZeigler\nZela\nZelienople\nZell\nZellwood\nZemple\nZena\nZenda\nZenith\nZephyr\nZephyr Cove\nZephyrhills\nZia Pueblo\nZillah\nZilwaukee\nZim\nZimmerman\nZinc\nZion\nZionsville\nZita\nZoar\nZolfo Springs\nZona\nZumbro Falls\nZumbrota\nZuni\nZurich\nZwingle\nZwolle\n\n一共20580个城市。这个训练就快多了，在纯CPU上训练，大约5到6分钟可以训练一轮。\n代码如下，跟上面写莎翁的戏剧的如出一辙：\nfrom __future__ import absolute_import, division, print_function\n\nimport os\nfrom six import moves\nimport ssl\n\nimport tflearn\nfrom tflearn.data_utils import *\n\npath = \"US_Cities.txt\"\nif not os.path.isfile(path):\n    context = ssl._create_unverified_context()\n    moves.urllib.request.urlretrieve(\"https://raw.githubusercontent.com/tflearn/tflearn.github.io/master/resources/US_Cities.txt\", path, context=context)\n\nmaxlen = 20\n\nstring_utf8 = open(path, \"r\").read().decode('utf-8')\nX, Y, char_idx = \\\n    string_to_semi_redundant_sequences(string_utf8, seq_maxlen=maxlen, redun_step=3)\n\ng = tflearn.input_data(shape=[None, maxlen, len(char_idx)])\ng = tflearn.lstm(g, 512, return_seq=True)\ng = tflearn.dropout(g, 0.5)\ng = tflearn.lstm(g, 512)\ng = tflearn.dropout(g, 0.5)\ng = tflearn.fully_connected(g, len(char_idx), activation='softmax')\ng = tflearn.regression(g, optimizer='adam', loss='categorical_crossentropy',\n                       learning_rate=0.001)\n\nm = tflearn.SequenceGenerator(g, dictionary=char_idx,\n                              seq_maxlen=maxlen,\n                              clip_gradients=5.0,\n                              checkpoint_path='model_us_cities')\n\nfor i in range(40):\n    seed = random_sequence_from_string(string_utf8, maxlen)\n    m.fit(X, Y, validation_set=0.1, batch_size=128,\n          n_epoch=1, run_id='us_cities')\n    print(\"-- TESTING...\")\n    print(\"-- Test with temperature of 1.2 --\")\n    print(m.generate(30, temperature=1.2, seq_seed=seed).encode('utf-8'))\n    print(\"-- Test with temperature of 1.0 --\")\n    print(m.generate(30, temperature=1.0, seq_seed=seed).encode('utf-8'))\n    print(\"-- Test with temperature of 0.5 --\")\n    print(m.generate(30, temperature=0.5, seq_seed=seed).encode('utf-8'))\n\n我们看下第一轮训练完生成的城市名：\nt and Shoot\nCuthbertd\nLettfrecv\nEl\nCeoneel Sutd\nSa\n\n第二轮：\nstle\nFinchford\nFinch Dasthond\nmadloogd\nWlaycoyarfw\n\n第三轮：\naveral\nCape Carteret\nAcbiropa Heowar Sor Dittoy\nDo\n\n第十轮：\nhoenchen\nSchofield\nStcojos\nSchabell\nStcaKnerum Cri\n\n跨后端高层API - Keras，生成尼采的文章\nKeras是可以跨Tensorflow，微软的CNTK等多种后端的API。可以通过\npip install keras\n\n来安装keras。我们安装了Tensorflow之后，Keras会选用Tensorflow来做它的后端。\n我们也看下Keras上文本生成的例子。官方例子是用来生成尼采的句子。\n核心语句就6句话：\nmodel = Sequential()\nmodel.add(LSTM(128, input_shape=(maxlen, len(chars))))\nmodel.add(Dense(len(chars)))\nmodel.add(Activation('softmax'))\n\noptimizer = RMSprop(lr=0.01)\nmodel.compile(loss='categorical_crossentropy', optimizer=optimizer)\n\n下面是完整的代码，大家跑来玩玩吧。如果对尼采不感兴趣，也可以换成别的文章。不过请注意，正如注释中所说的，文本随便换，但是要保持在10万字符以上。最好是100万字符以上。\n'''Example script to generate text from Nietzsche's writings.\nAt least 20 epochs are required before the generated text\nstarts sounding coherent.\nIt is recommended to run this script on GPU, as recurrent\nnetworks are quite computationally intensive.\nIf you try this script on new data, make sure your corpus\nhas at least ~100k characters. ~1M is better.\n'''\n\nfrom __future__ import print_function\nfrom keras.callbacks import LambdaCallback\nfrom keras.models import Sequential\nfrom keras.layers import Dense, Activation\nfrom keras.layers import LSTM\nfrom keras.optimizers import RMSprop\nfrom keras.utils.data_utils import get_file\nimport numpy as np\nimport random\nimport sys\nimport io\n\npath = get_file('nietzsche.txt', origin='https://s3.amazonaws.com/text-datasets/nietzsche.txt')\nwith io.open(path, encoding='utf-8') as f:\n    text = f.read().lower()\nprint('corpus length:', len(text))\n\nchars = sorted(list(set(text)))\nprint('total chars:', len(chars))\nchar_indices = dict((c, i) for i, c in enumerate(chars))\nindices_char = dict((i, c) for i, c in enumerate(chars))\n\n# cut the text in semi-redundant sequences of maxlen characters\nmaxlen = 40\nstep = 3\nsentences = []\nnext_chars = []\nfor i in range(0, len(text) - maxlen, step):\n    sentences.append(text[i: i + maxlen])\n    next_chars.append(text[i + maxlen])\nprint('nb sequences:', len(sentences))\n\nprint('Vectorization...')\nx = np.zeros((len(sentences), maxlen, len(chars)), dtype=np.bool)\ny = np.zeros((len(sentences), len(chars)), dtype=np.bool)\nfor i, sentence in enumerate(sentences):\n    for t, char in enumerate(sentence):\n        x[i, t, char_indices[char]] = 1\n    y[i, char_indices[next_chars[i]]] = 1\n\n\n# build the model: a single LSTM\nprint('Build model...')\nmodel = Sequential()\nmodel.add(LSTM(128, input_shape=(maxlen, len(chars))))\nmodel.add(Dense(len(chars)))\nmodel.add(Activation('softmax'))\n\noptimizer = RMSprop(lr=0.01)\nmodel.compile(loss='categorical_crossentropy', optimizer=optimizer)\n\n\ndef sample(preds, temperature=1.0):\n    # helper function to sample an index from a probability array\n    preds = np.asarray(preds).astype('float64')\n    preds = np.log(preds) / temperature\n    exp_preds = np.exp(preds)\n    preds = exp_preds / np.sum(exp_preds)\n    probas = np.random.multinomial(1, preds, 1)\n    return np.argmax(probas)\n\n\ndef on_epoch_end(epoch, logs):\n    # Function invoked at end of each epoch. Prints generated text.\n    print()\n    print('----- Generating text after Epoch: %d' % epoch)\n\n    start_index = random.randint(0, len(text) - maxlen - 1)\n    for diversity in [0.2, 0.5, 1.0, 1.2]:\n        print('----- diversity:', diversity)\n\n        generated = ''\n        sentence = text[start_index: start_index + maxlen]\n        generated += sentence\n        print('----- Generating with seed: \"' + sentence + '\"')\n        sys.stdout.write(generated)\n\n        for i in range(400):\n            x_pred = np.zeros((1, maxlen, len(chars)))\n            for t, char in enumerate(sentence):\n                x_pred[0, t, char_indices[char]] = 1.\n\n            preds = model.predict(x_pred, verbose=0)[0]\n            next_index = sample(preds, diversity)\n            next_char = indices_char[next_index]\n\n            generated += next_char\n            sentence = sentence[1:] + next_char\n\n            sys.stdout.write(next_char)\n            sys.stdout.flush()\n        print()\n\nprint_callback = LambdaCallback(on_epoch_end=on_epoch_end)\n\nmodel.fit(x, y,\n          batch_size=128,\n          epochs=60,\n          callbacks=[print_callback])\n          \n本文作者：lusing\n阅读原文\n本文为云栖社区原创内容，未经允许不得转载。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}