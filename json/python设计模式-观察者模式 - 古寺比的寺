{"title": "python设计模式-观察者模式 - 古寺比的寺 ", "index": "python,设计模式", "content": "\n题目：现在你有一个数字，默认格式化程序是以十进制格式展示此数值，但需要提供一个功能，这个程序要支持添加/注册更多的格式化程序（比如：添加一个十六进制格式化程序和一个二进制格式化程序）。每次数值更新时，已注册的程序就会收到通知，并显示更新后的值。\n我们看下需求：\n\nNumberFormatter 有一个 number 属性\n当 number 值修改时，相关的格式化方式展示结果要改变\n此系统必须可扩展已适应其他格式化方式的使用。\n\n一个错误的实现可能是这样的：\nclass NumberFormatter(object):\n    def __init__(self, number):\n        self.number = number\n        \n    def show_data(self):\n        self.default_formatter()\n        self.hex_formatter()\n        self.binary_formatter()\n        \n    def default_formatter(self):\n        pass\n        \n    def hex_formatter(self):\n        pass\n        \n    def binary_formatter(self):\n        pass\n我们可以这么使用：\nnumber = NumberFormatter(10)\nnumber.show_data()\n但是这样会有一个问题：这种针对实现的编程会导致我们在增加或者删除需要格式化方式时必须修改代码。比如我们现在不再需要十六进制数字格式的显示，就需要把 hex_formatter 相关的代码删除或者注释掉。\n要解决这个问题，就可以用到我们这次要介绍的观察者模式了。\n什么是观察者模式\n认识观察者模式\n我们先看看报纸和杂志的订阅是怎么回事：\n\n报社的业务就是出版报纸\n向某家报社订阅报纸，只要他们有新报纸，就会给你送来，只要你是他们的订户，你就会一直受到新报纸。\n当你不再想看的时候，取消订阅，他们就不会在送新报纸给你\n只要报社还在运营，就会一直有人向他们订阅报纸或取消订阅。\n\n我们用图表示一下，这里出版者 改称为主题(Subject)，订阅者改称为观察者(Observer)：\n1. 开始的时候，鸭子对象不是观察者2. 鸭子对象过来告诉主题，它想当一个观察者（鸭子其实想说的是：我对你的数据改变感兴趣，一有变化请通知我）3. 鸭子对象已经是观察者了（鸭子静候通知，一旦接到通知，就会得到一个整数）。4. 主题有了新的数据（现在鸭子和其他所有观察者都会受到通知：主题已经改变）5. 老鼠对象要求从观察者中把自己除名（老鼠已经观察次主题太久，决定不再当观察者了）。6. 老鼠离开了（主题知道老鼠的请求后，把它从观察者中移除了）。7. 主题有了一个新的整数（除了老鼠之外，每个观察者都会收到通知，如果老鼠又想当观察者了，它还可以再回来）\n定义观察者模式\n当你试图勾勒观察者模式时，可以利用报纸订阅服务，以及出版这和订阅者比你这一切。在程序设计中，观察者模式通常被定义为：\n\n观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态是，它的所有依赖者都会收到通知并自动更新。\n我们和之前的例子做个对比：\n\n主题和观察者定义了一对多的关系。观察者依赖于此主题，只要主题状态一有变化，观察者就会被通知。根据通知的风格，观察者可能因此新值而更新。\n现在你可能有疑问，这和一对多的关系有何关联？\n利用观察者模式，主题是具有状态的对象，并且可以控制这些状态。也就是说，有一个具有状态的主题。另一方面，观察者使用这些状态，虽然这些状态不属于他们。有许多观察者，依赖主题告诉他们状态何时改变了。这就产生了一个关系：一个主题对多个观察者的关系。\n观察者和主题之间的依赖关系是如何产生的？\n主题是真正拥有数据的人，观察者是主题的依赖者，在数据变化时更新，这样比起让许多对象控制同一份数据来，可以得到更干净的 OO 设计。\n观察者模式的应用案例\n观察者模式在实际应用中有许多的案例，比如信息的聚合。无论格式为 RSS、Atom 还是其它，思想多事一样的：你追随某个信息源，当它每次更新时，你都会收到关于更新的通知。事件驱动系统是一个可以使用观察者模式的例子。在这种系统中，监听者被用于监听特定的事件。监听者的事件被创建出来时就会触发它们。这个事件可以使键入某个特定的键、移动鼠标或者其他。事件扮演发布者的角色，监听者则扮演观察者的角色。\nPython 实现\n现在，让我们回到文章开始的那个问题。\n这里我们可以实现一个基类 Publisher，包括添加、删除及通知观察者这些公用功能。DefaultFormatter 类继承自 Publisher，并添加格式化程序特定的功能。\n\nPublisher 的代码如下：\nimport itertools\n\n'''\n观察者模式实现\n'''\n\nclass Publisher:\n\n    def __init__(self):\n        self.observers = set()\n\n    def add(self, observer, *observers):\n        for observer in itertools.chain((observer, ), observers):\n            self.observers.add(observer)\n            observer.update(self)\n\n    def remove(self, observer):\n        try:\n            self.observers.discard(observer)\n        except ValueError:\n            print('Failed to remove: {}'.format(observer))\n\n    def notify(self):\n        [observer.update(self) for observer in self.observers]\n\n现在，打算使用观察者模式的模型或类都应该继承 Publisher 类。该类用 set 来保存观察者对象。当用户向 Publisher 注册新的观察者对象时，观察者的 update() 方法会执行，这使得它能够用模型当前的状态初始化自己。模型状态发生变化时，应该调用继承而来的 notify() 方法，这样的话，就会执行每个观察者对象的 update() 方法，以确保他们都能反映出模型的最新状态。\n\nadd() 方法的写法值得注意，这里是为了支持可以接受一个或多个观察者对象。这里我们采用了itertools.chain() 方法，它可以接受任意数量的  iterable，并返回单个iterable。遍历这个 iterable，也就相当于依次遍历参数里的那些 iterable。\n接下来是 DefaultFomatter 类。__init__() 做的第一件事就是调用基类的__init__() 方法，因为这在 Python 中没法自动完成。DefaultFormatter 实例有自己的名字，这样便于我们跟踪其状态。对于_data 变量，我们使用了名称改编来声明不能直接访问该变量。DefaultFormatter 把_data 变量用作一个整数，默认值为0。\nclass DefaultFormatter(Publisher):\n\n    def __init__(self, name):\n        Publisher.__init__(self)\n        self.name = name\n        self._data = 0\n\n    def __str__(self):\n        return \"{}: '{}' has data = {}\".format(type(self).__name__, self.name, self._data)\n\n    @property\n    def data(self):\n        return self._data\n\n    @data.setter\n    def data(self, new_value):\n        try:\n            self._data = int(new_value)\n        except ValueError as e:\n            print('Error: {}'.format(e))\n        else:\n            self.notify()\n\n\n__str__() 方法返回关于发布者名称和 _data 值的信息。type(self).__name 是一种获取类名的方便技巧，避免硬编码类名。（不过这会降低代码的可读性）\n\ndata() 方法有两个，第一个使用了 @property 装饰器来提供_data 变量的读访问方式。这样，我们就能使用 object.data 来代替 object._data。第二个 data() 方法使用了@setter 装饰器，改装饰器会在每次使用赋值操作符(=)为_data 变量赋值时被调用。该方法也会尝试把新值强制转换为一个整数，并在转换失败时处理异常。\n\n接下来是添加观察者。HexFormatter 和 BinaryFormatter 功能基本相似。唯一的不同在于如何格式化从发布者那获取到的数据值，即十六进制和二进制格式化。\nclass HexFormatter:\n\n    def update(self, publisher):\n        print(\"{}: '{}' has now hex data= {}\".format(type(self).__name__,\n                                                     publisher.name, hex(publisher.data)))\n\nclass BinaryFormatter:\n\n    def update(self, publisher):\n        print(\"{}: '{}' has now bin data= {}\".format(type(self).__name__,\n                                                     publisher.name, bin(publisher.data)))\n接下来我们添加一下测试数据，运行代码观察一下结果：\ndef main():\n    df = DefaultFormatter('test1')\n    print(df)\n\n    print()\n    hf = HexFormatter()\n    df.add(hf)\n    df.data = 3\n    print(df)\n\n    print()\n    bf = BinaryFormatter()\n    df.add(bf)\n    df.data = 21\n    print(df)\n\n    print()\n    df.remove(hf)\n    df.data = 40\n    print(df)\n\n    print()\n    df.remove(hf)\n    df.add(bf)\n\n    df.data = 'hello'\n    print(df)\n\n    print()\n    df.data = 4.2\n    print(df)\n\n\nif __name__ == '__main__':\n    main()\n\n完整代码参考：https://gist.github.com/gusibi/93a000c79f3d943dd58dcd39c4b547f1\n运行代码：\npython observer.py    \n## output\nDefaultFormatter: 'test1' has data = 0\n\nHexFormatter: 'test1' has now hex data= 0x0\nHexFormatter: 'test1' has now hex data= 0x3\nDefaultFormatter: 'test1' has data = 3\n\nBinaryFormatter: 'test1' has now bin data= 0b11\nBinaryFormatter: 'test1' has now bin data= 0b10101\nHexFormatter: 'test1' has now hex data= 0x15\nDefaultFormatter: 'test1' has data = 21\n\nBinaryFormatter: 'test1' has now bin data= 0b101000\nDefaultFormatter: 'test1' has data = 40\n\nBinaryFormatter: 'test1' has now bin data= 0b101000\nError: invalid literal for int() with base 10: 'hello'\nDefaultFormatter: 'test1' has data = 40\n\nBinaryFormatter: 'test1' has now bin data= 0b100\nDefaultFormatter: 'test1' has data = 4\n\n在输出中我们看到，添加额外的观察者，就会出现更多的输出；一个观察者被删除后就不再被通知到。\n总结\n这一篇我们介绍了观察者模式的原理以及 Python 代码的实现。在实际的项目开发中，观察者模式广泛的运用于 GUI 编程，而且在仿真及服务器等其他时间处理架构中也能用到，比如：数据库触发器、Django 的信号系统、Qt GUI 应用程序框架的信号（signal）与槽（slot）机智以及WebSocket的许多用例。\n参考链接\n\nThe 10 Minute Guide to the Observer Pattern in Python\nObserver\n\n\n最后，感谢女朋友支持。\n\n\n欢迎关注(April_Louisa)\n请我喝芬达\n\n\n\n\n\n\n\n                ", "mainLikeNum": ["5 "], "mainBookmarkNum": "19"}