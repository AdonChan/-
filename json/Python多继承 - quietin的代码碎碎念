{"title": "Python多继承 - quietin的代码碎碎念 ", "index": "python", "content": "python中使用多继承，会涉及到查找顺序（MRO）、重复调用（钻石继承，也叫菱形继承问题）等\nMRO\nMRO即method resolution order，用于判断子类调用的属性来自于哪个父类。在Python2.3之前，MRO是基于深度优先算法的，自2.3开始使用C3算法，定义类时需要继承object，这样的类称为新式类，否则为旧式类\n\n从图中可以看出，旧式类查找属性时是深度优先搜索，新式类则是广度优先搜索C3算法最早被提出是用于Lisp的，应用在Python中是为了解决原来基于深度优先搜索算法不满足本地优先级，和单调性的问题。\n\n本地优先级：指声明时父类的顺序，比如C(A,B)，如果访问C类对象属性时，应该根据声明顺序，优先查找A类，然后再查找B类。\n单调性：如果在C的解析顺序中，A排在B的前面，那么在C的所有子类里，也必须满足这个顺序\n\n示例\n看下面的例子\nclass X(object):\n    def f(self):\n        print 'x'\n\n\nclass A(X):\n    def f(self):\n        print 'a'\n\n    def extral(self):\n        print 'extral a'\n\n\nclass B(X):\n    def f(self):\n        print 'b'\n\n    def extral(self):\n        print 'extral b'\n\n\nclass C(A, B, X):\n    def f(self):\n        super(C, self).f()\n        print 'c'\n\n\nprint C.mro()\n\nc = C()\nc.f()\nc.extral()\n根据广度搜索原则最先搜索到A，所以结果很明显，如下所示\n\n类C没有extral函数，调用的是子类的该函数。这种类的部分行为由父类来提供的行为，叫做抽象超类.\n关于super\n从mro就能知道，super指的是 MRO 中的下一个类，而不是父类。super所做的事如下面代码所示：\ndef super(cls, inst):\n    mro = inst.__class__.mro()\n    return mro[mro.index(cls) + 1]\n对于在子类中调用父类方法，要么直接使用父类名来调用方法，要么在子类中用super，保持一致，最好不要混用\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "13"}