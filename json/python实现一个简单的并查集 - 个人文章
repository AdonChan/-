{"title": "python实现一个简单的并查集 - 个人文章 ", "index": "python", "content": "并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题。常常在使用中以森林来表示。\n并查集有三种基本操作，获得根节点，判断两节点是否连通，以及将两不连通的节点相连（相当于将两节点各自的集合合并）\n用UnionFind类来表示一个并查集，在构造函数中，初始化一个数组parent，parent[i]表示的含义为，索引为i的节点，它的直接父节点为parent[i]。初始化时各个节点都不相连，因此初始化parent[i]=i，让自己成为自己的父节点，从而实现各节点不互连。\n    def __init__(self, n):\n        self.parent = list(range(n))\n由于parent[i]仅表示自己的直接父节点，查询两个节点是否相交需要比较它们的根节点是否相同。因此要封装一个查询自己根节点的方法。\n    def get_root(self, i):\n        while i != self.parent[i]:\n            i = self.parent[i]\n\n        return i\n接下来可以通过来比较根节点是否相同来判断两节点是否连通。\n    def is_connected(self, i, j):\n        return self.get_root(i) == self.get_root(j)\n当要连通两个节点时，我们要将其中一个节点的根节点的parent，设置为另一个节点的根节点。注意，连通两个节点并非仅仅让两节点自身相连，实际上是让它们所属的集合实现合并。\n    def union(self, i, j):\n        i_root = self.get_root(i)\n        j_root = self.get_root(j)\n        self.parent[i_root] = j_root\n接下来我们做两个小优化。由于调用get_root时需要通过不断找自己的直接父节点，来寻找根节点，如果这棵树的层级过深，会导致性能受到严重影响。因此我们需要在union时，尽可能的减小合并后的树的高度。在构造函数中新建一个数组rank，rank[i]表示节点i所在的集合的树的高度。\n因此，当合并树时，分别获得节点i和节点j的root i_root和j_root之后，我们通过访问rank[i_root]和rank[j_root]来比较两棵树的高度，将高度较小的那棵连到高度较高的那棵上。如果高度相等，则可以随便，并将rank值加一。\n    def union(self, i, j):\n        i_root = self.get_root(i)\n        j_root = self.get_root(j)\n\n        if self.rank[i_root] == self.rank[j_root]:\n            self.parent[i_root] = j_root\n            self.rank[j_root] += 1\n        elif self.rank[i_root] > self.rank[j_root]:\n            self.parent[j_root] = i_root\n        else:\n            self.parent[i_root] = j_root\n通过对union操作的改良可以防止树的高度过高。我们还可以对get_root操作本身进行优化。当前每次执行get_root时，需要一层一层的找到自己的父节点，很费时。由于根节点没有父节点，并且文章开始处提到过如果一个节点没有父节点，那么它的父节点就是自己，因此可以说只有根节点的父节点是自己本身。现在我们加上一个判断，判断当前节点的父节点是否为根节点，如果不为根节点，就递归地将自己的父节点设置为根节点，最后返回自己的父节点。\n    def get_root(self, i):\n        if self.parent[i] != self.parent[self.parent[i]]:\n            self.parent[i] = self.get_root(self.parent[i])\n        return self.parent[i]\n以上是python实现一个简单的并查集的方式。\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}