{"title": "Python 外部函数调用库ctypes简介 - Python提高班 ", "index": "python", "content": "参考资料\n\n\nhttps://docs.python.org/2.7/l...\nhttp://www.ibm.com/developerw...\n\nctypes简介\n\n一直对不同语言间的交互感兴趣，python和C语言又深有渊源，所以对python和c语言交互产生了兴趣。最近了解了python提供的一个外部函数库 ctypes, 它提供了C语言兼容的几种数据类型，并且可以允许调用C编译好的库。这里是阅读相关资料的一个记录，内容大部分来自官方文档。\n数据类型\n\nctypes 提供了一些原始的C语言兼容的数据类型，参见下表,其中第一列是在ctypes库中定义的变量类型，第二列是C语言定义的变量类型，第三列是Python语言在不使用ctypes时定义的变量类型。\n| ctypes type  | C type                                 | Python type                |\n|--------------+----------------------------------------+----------------------------|\n| c_bool       | _Bool                                  | bool (1)                   |\n| c_char       | char                                   | 1-character string         |\n| c_wchar      | wchar_t                                | 1-character unicode string |\n| c_byte       | char                                   | int/long                   |\n| c_ubyte      | unsigned char                          | int/long                   |\n| c_short      | short                                  | int/long                   |\n| c_ushort     | unsigned short                         | int/long                   |\n| c_int        | int                                    | int/long                   |\n| c_uint       | unsigned int                           | int/long                   |\n| c_long       | long                                   | int/long                   |\n| c_ulong      | unsigned long                          | int/long                   |\n| c_longlong   | __int64 or long long                   | int/long                   |\n| c_ulonglong  | unsigned __int64 or unsigned long long | int/long                   |\n| c_float      | float                                  | float                      |\n| c_double     | double                                 | float                      |\n| c_longdouble | long double                            | float                      |\n| c_char_p     | char * (NUL terminated)                | string or None             |\n| c_wchar_p    | wchar_t * (NUL terminated)             | unicode or None            |\n| c_void_p     | void *                                 | int/long or None           |\n\n创建简单的ctypes类型如下:\n>>> c_int()\nc_long(0)\n>>> c_char_p(\"Hello, World\")\nc_char_p('Hello, World')\n>>> c_ushort(-3)\nc_ushort(65533)\n>>>\n\n使用 .value 访问和改变值:\n>>> i = c_int(42)\n>>> print i\nc_long(42)\n>>> print i.value\n42\n>>> i.value = -99\n>>> print i.value\n-99\n>>>\n\n改变指针类型的变量值:\n>>> s = \"Hello, World\"\n>>> c_s = c_char_p(s)\n>>> print c_s\nc_char_p('Hello, World')\n>>> c_s.value = \"Hi, there\"\n>>> print c_s\nc_char_p('Hi, there')\n>>> print s                 # 一开始赋值的字符串并不会改变， 因为这里指针的实例改变的是指向的内存地址，不是直接改变内存里的内容\nHello, World\n>>>\n\n如果需要直接操作内存地址的数据类型：\n>>> from ctypes import *\n>>> p = create_string_buffer(3)      # create a 3 byte buffer, initialized to NUL bytes\n>>> print sizeof(p), repr(p.raw)\n3 '\\x00\\x00\\x00'\n>>> p = create_string_buffer(\"Hello\")      # create a buffer containing a NUL terminated string\n>>> print sizeof(p), repr(p.raw)          # .raw 访问内存里存储的内容\n6 'Hello\\x00'\n>>> print repr(p.value)                   # .value 访问值\n'Hello'\n>>> p = create_string_buffer(\"Hello\", 10)  # create a 10 byte buffer\n>>> print sizeof(p), repr(p.raw)\n10 'Hello\\x00\\x00\\x00\\x00\\x00'\n>>> p.value = \"Hi\"\n>>> print sizeof(p), repr(p.raw)\n10 'Hi\\x00lo\\x00\\x00\\x00\\x00\\x00'\n>>>\n\n下面的例子演示了使用C的数组和结构体:\n>>> class POINT(Structure):                 # 定义一个结构，内含两个成员变量 x，y，均为 int 型\n...     _fields_ = [(\"x\", c_int),\n...                 (\"y\", c_int)]\n...\n>>> point = POINT(2,5)                            # 定义一个 POINT 类型的变量，初始值为 x=2, y=5\n>>> print point.x, point.y                     # 打印变量\n2 5\n>>> point = POINT(y=5)                                  # 重新定义一个 POINT 类型变量，x 取默认值\n>>> print point.x, point.y                     # 打印变量\n0 5\n>>> POINT_ARRAY = POINT * 3                    # 定义 POINT_ARRAY 为 POINT 的数组类型\n# 定义一个 POINT 数组，内含三个 POINT 变量\n>>> pa = POINT_ARRAY(POINT(7, 7), POINT(8, 8), POINT(9, 9))\n>>> for p in pa: print p.x, p.y                # 打印 POINT 数组中每个成员的值\n...\n7 7\n8 8\n9 9\n\n创建指针实例\n>>> from ctypes import *\n>>> i = c_int(42)\n>>> pi = pointer(i)\n>>>\n\n>>> pi.contents\nc_long(42)\n>>>\n\n使用cast()类型转换\n>>> class Bar(Structure):\n...     _fields_ = [(\"count\", c_int), (\"values\", POINTER(c_int))]\n...\n>>> bar = Bar()\n>>> bar.values = (c_int * 3)(1, 2, 3)\n>>> bar.count = 3\n>>> for i in range(bar.count):\n...     print bar.values[i]\n...\n1\n2\n3\n>>>\n\n\n>>> bar = Bar()\n>>> bar.values = cast((c_byte * 4)(), POINTER(c_int))   # 这里转成需要的类型\n>>> print bar.values[0]\n0\n>>>\n\n类似于C语言定义函数时，会先定义返回类型，然后具体实现再定义，当遇到下面这种情况时，也需要这么干:\n>>> class cell(Structure):\n...     _fields_ = [(\"name\", c_char_p),\n...                 (\"next\", POINTER(cell))]\n...\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in ?\n  File \"<stdin>\", line 2, in cell\nNameError: name 'cell' is not defined\n>>>\n\n# 不能调用自己，所以得像下面这样\n>>> from ctypes import *\n>>> class cell(Structure):\n...     pass\n...\n>>> cell._fields_ = [(\"name\", c_char_p),\n...                  (\"next\", POINTER(cell))]\n>>>\n\n调用.so/.dll\n\n可以简单地将\"so\"和\"dll\"理解成Linux和windows上动态链接库的指代，这里我们以Linux为例。注意，ctypes提供的接口会在不同系统上有出入，比如为了加载动态链接库， 在Linux上提供的是 cdll, 而在Windows上提供的是 windll 和 oledll 。\n加载动态链接库\n\nfrom ctypes import *\n>>> cdll.LoadLibrary(\"libc.so.6\")\n<CDLL 'libc.so.6', handle ... at ...>\n>>> libc = CDLL(\"libc.so.6\")\n>>> libc\n<CDLL 'libc.so.6', handle ... at ...>\n>>>\n\n调用加载的函数\n\n>>> print libc.time(None)\n1150640792\n>>> print hex(windll.kernel32.GetModuleHandleA(None))\n0x1d000000\n>>>\n\n设置个性化参数\n\nctypes会寻找 _as_paramter_ 属性来用作调用函数的参数传入，这样就可以传入自己定义的类作为参数，示例如下:\n>>> class Bottles(object):\n...     def __init__(self, number):\n...         self._as_parameter_ = number\n...\n>>> bottles = Bottles(42)\n>>> printf(\"%d bottles of beer\\n\", bottles)\n42 bottles of beer\n19\n>>>\n\n指定函数需要参数类型和返回类型\n\n用 argtypes 和 restype 来指定调用的函数返回类型。\n>>> printf.argtypes = [c_char_p, c_char_p, c_int, c_double]\n>>> printf(\"String '%s', Int %d, Double %f\\n\", \"Hi\", 10, 2.2)\nString 'Hi', Int 10, Double 2.200000\n37\n>>>\n\n\n\n>>> strchr = libc.strchr\n>>> strchr(\"abcdef\", ord(\"d\"))\n8059983\n>>> strchr.restype = c_char_p   # c_char_p is a pointer to a string\n>>> strchr(\"abcdef\", ord(\"d\"))\n'def'\n>>> print strchr(\"abcdef\", ord(\"x\"))\nNone\n>>>\n\n这里我只是列出了 ctypes 最基础的部分，还有很多细节请参考官方文档。\n题外话\n\n这两天文章没有写，先是早出晚归出去玩了一整天，然后加班到凌晨3点左右，一天一篇计划划水得严重啊…\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "6"}