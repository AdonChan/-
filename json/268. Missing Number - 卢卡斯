{"title": "268. Missing Number - 卢卡斯 ", "index": "leetcode,python", "content": "题目链接：Missing Number\n思路：方法1: 排序我们很自然的可以想到，如果数组是排好序的，那么可以很容易的找到缺少的数字。之后我们可以查看头尾两个数字是否符合要求。如果不符合我们可以直接返回结果。最后，我们查从1到n-1个数字。\n方法2: Bit Manipulation利用“XOR”的特点。比如 1 XOR 1 = 0，但1 XOR 1 XOR 2 = 2。所以只要把数组中的数字和数组中的index全部XOR，那么缺少的那个肯定是我们需要的数字。\n方法3: HashSet放数组的数字放到HashSet里面，然后遍历这个HashSet。如果数字不在就说明这是我们要找的数字。\n方法4: 求和根据高斯定理，从1到n的和为 ((1+n) * n)/2。所以把数组的所有数字求和，然后与从1到n的和相减所得数字，就是我们需要的数字。\n时间复杂度：方法1:\n时间：O(nlogn) \n空间：O(1) if we sort the numbers in place\n方法2:\n时间：O(n)\n空间：O(1)\n方法3:\n时间：O(n)\n空间：O(n)\n方法4:\n时间：O(n)\n空间：O(1)\n\n代码：\n方法1：\nclass Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        if nums[0] != 0:\n            return 0\n        if nums[-1] != len(nums):\n            return len(nums)\n        \n        for i in range(1, len(nums)):\n            exp_val = nums[i-1] + 1\n            if nums[i] != exp_val:\n                return exp_val\n\n方法2:\nclass Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        res = len(nums)\n        for i, num in enumerate(nums):\n            res ^= i ^ num\n        return res\n\n方法3:\nclass Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums = set(nums)\n        n = len(nums) + 1\n        for i in range(n):\n            if i not in nums:\n                return i\n\n方法4:\nclass Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        exp_sum = len(nums) * (len(nums) + 1) // 2\n        sum_n = sum(nums)\n        return exp_sum - sum_n\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}