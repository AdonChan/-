{"title": "python学习笔记- 多线程 - helloword ", "index": "python,线程", "content": "该文章参考了http://www.liaoxuefeng.com/wi... 廖雪峰的教程。\n一个进程至少有一个线程。Python也提供多线程支持，而且Python中的线程并非是模拟出来的多线程，而是系统级别的Posix Thread.\nPython标准库提供了两个模块thread和threading。前者是低级库，后者是高级库。高级库是对低级库的封装。通常情况下，我们只需要使用threading高级库就可以了。\n如何创建Thread\n我们只需要创建threading.Thread类，并传入一个需要线程执行的函数作为target即可。\nimport threading\n\nimport time\n\n\ndef loop():\n    count = 1\n    while count < 4:\n        print \"Hello\"\n        time.sleep(1)\n        count += 1\n\n\nif __name__ == '__main__':\n    thread = threading.Thread(target=loop, name=\"LoopThread\")\n    thread.start()\n    thread.join()\n    current_thread = threading.current_thread()\n    print current_thread.getName()\n    print \"LoopThread Ended\"\n上述代码主进程默认会创建一个主线程。上面的代码中，我们用到了多个函数。\n\njoin()函数：即让主线程序等待子线程完成后继续。\ncurrent_thread()函数：获取当前线程的实例。\n\nLock 锁\n同一个变量，进程会拷贝一份存于各个进程中，互不影响。同一个变量，线程则会互相共享。这就会带来一些问题。因为cpu对线程是随意切换的。那么如果一个线程对某一个变量进行多步cpu操作的时候，如果不加锁，那么可能会在线程进行到一半的时候，会被切换到其他线程，从而使得操作变乱。一个典型的例子是“一存一取”的场景。例如多个线程对银行中的某一个账户进行操作。一个线程需要对账户进行一存一取某一个金额的操作才会让账户平衡。但是多个线程对该账户进行操作的时候，且它们操作的金额经常是不一样的，那么最终的账户很可能是不平衡的。\nthread 1: -100\nthread 1: +100\n\nthread 1: -100\nthread 1: +100\n\nthread 2: -200\nthread 2: +200\n\nthread 2: -200\nthread 2: +200\n上述描述了两个线程按顺序互补干扰地对某一个账户进行操作。但是实际情况是cpu随意切换线程。上述操作是打乱的，例如\nthread 1: -100\nthread 2: -200\nthread 2: +200\n...\n此时，我们发现账户并不是平衡的。如果解决呢？我们需要对每一个thread的一存一取操作加一把锁。即改账户变量必须是让一个线程先进行完整的一存一取操作后，才能被其他线程所操作。\n我们可以将要上锁的代码包裹起来，即：\n    lock.acquire()\n    num = num + n\n    num = num - n\n    print num\n    lock.release()\n当然，lock可以对资源的获取和释放，那么我们也可以用with关键字。\nwith lock:\n    num = num + n\n    num = num - n\n    print num\n死锁 deadlock\n死锁的发生往往是两个线程各自占用了对方所需要用到的资源而都在等待对方释放资源而造成的。遇见死锁后，程序则会一直暂停在那里。直到系统将它们关闭。\nGIL\n说到Python的多线程编程，就会绕不过GIL。那么GIL又是什么鬼呢？GIL据说是Python中hardest的问题，想要彻底了解GIL，必须要对操作系统设计、多线程编程、C语言、解释器设计和CPython解释器的实现有着非常彻底的理解。\n据廖雪峰中的教程中描述：\nPython中的线程虽然是真正的线程，但是解释器执行代码的时候，会有一个GIL锁(Global Interpreter Lock). 任何Python线程执行前，必须先获得GIL锁。然后，每执行100条字节码，解释器就会自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁。因此，多线程在Python中只能交替进行，即使100个线程跑在100核CPU上，也只能用到1个核心。\nGIL是Python解释器设计的历史遗留问题，通常我们用的解释器是官方实现彻底CPython。\n更多关于GIL设计的历史渊源，可以阅读：\n\nhttp://cenalulu.github.io/pyt...\nhttp://www.oschina.net/transl...\n\n那么是不是Python就是不能利用多核处理器任务了呢？我们之前学到过多进程编程，每一个进程都有一个独立的GIL锁，各进程互不影响。\n\n                ", "mainLikeNum": ["4 "], "mainBookmarkNum": "9"}