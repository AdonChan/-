{"title": "如何用Java与python代码解释IO模型 - tEngSHe789的小站 ", "index": "python,java", "content": "前天刚好看了点《UNIX网络编程》，比较头大。现在我来整理一下所学所得，并用于个人备忘。如果有不对，请批评。\n想要解锁更多新姿势？请访问https://blog.tengshe789.tech/\nIO模型介绍\nIO模型是什么？很多书籍或者百度百度百科，都没有给出明确的解释，我也不敢乱下定义。以我愚见，IO模型，是通过根据前人主观意识的思考而构成客观阐述IO复杂操作逻辑的物件。\n要知道，应用程序使用系统资源的一个过程，进程无法直接操作IO设备的，因为用户进程不能直接访问磁盘，所以要通过内核的系统调用读取，这个内核读取的过程就是用户进程等待的过程，等待内核读取后将数据从内核内存复制到进程内存。因此操作系统设立一个IO模型进行规范，就非常有必要了。\n\n为了更好地了解IO模型，我们需要事先回顾下：同步、异步、阻塞、非阻塞\n同步与异步：描述的是用户线程与内核的交互方式，同步指用户线程发起IO请求后需要等待或者轮询内核IO操作完成后才能继续执行；而异步是指用户线程发起IO请求后仍然继续执行，当内核IO操作完成后会通知用户线程，或者调用用户线程注册的回调函数。\n阻塞与非阻塞：描述是用户线程调用内核IO操作的方式，阻塞是指IO操作需要彻底完成后才返回到用户空间；而非阻塞是指IO操作被调用后立即返回给用户一个状态值，无需等到IO操作彻底完成。\nIO模型一共有5类：\n\nblocking-IO           BIO（阻塞IO）\nnon-blocking IO      NIO（非阻塞IO）\nIO multiplexing      IO多路复用\nsignal driven IO     信号驱动IO\nasynchronous IO    AIO（异步IO）由于signal driven IO（信号驱动IO）在实际中并不常用，所以主要介绍其余四种IO Model。\n\n\nBIO（blocking io）\n先来看看读操作流程\n\n从图中可以看出，用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。\n对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。\n而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。\n也就是说，blocking IO的特点就是在IO执行的两个阶段（等待数据和拷贝数据两个阶段）都被block了。\nJAVA 阻塞 demo\n下面的例子主要使用Socket通道进行编程。服务端如下：\n/**\n * @program: socketTest\n * @description: one thread demo for bio version\n * @author: tEngSHe789\n * @create: 2018-08-26 21:17\n **/\npublic class Server {\n    public static void main(String[] args) {\n        try {\n            ServerSocket serverSocket=new ServerSocket(8888);\n            System.out.println(\"服务端Start....\");\n            //等待客户端就绪 -> 堵塞\n            while (true){\n                Socket socket = serverSocket.accept();\n                System.out.println(\"发现客户端连接\");\n                InputStream is=socket.getInputStream();\n                byte[] b =new byte[1024];\n                //等待客户端发送请求 -> 堵塞\n                while (true) {\n                    int data = is.read(b);\n                    String info=null;\n                    if (data!=-1){\n                        info=new String(b,0,data,\"GBK\");\n                    }\n                    System.out.println(info);\n                }\n\n            }\n        } catch (IOException e) {\n        }\n    }\n}\n客户端\n/**\n * @program: socketTest\n * @description: one thread demo for bio version\n * @author: tEngSHe789\n **/\npublic class Client {\n    public static void main(String[] args) {\n        try {\n            Socket socket=new Socket(\"127.0.0.1\",8888);\n            OutputStream os = socket.getOutputStream();\n            System.out.println(\"正在发送数据\");\n            os.write(\"这是来自客户端的信息\".getBytes());\n            os.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\nPY 阻塞 demo\n服务端\nimport socket\n\ns = socket.socket()\ns.bind(('127.0.0.1',8888))\nprint('服务端启动....')\n# 等待客户端就绪 -> 堵塞\ns.listen()\n# 等待客户端发送请求 -> 堵塞\nconn,addr = s.accept()\nmsg = conn.recv(1024).decode('utf-8')\nprint(msg)\nconn.close()\ns.close()\n\n客户端\nimport socket\n\ns = socket.socket()\ns.connect(('127.0.0.1',8888))\nprint('客户端已启动....')\ns.send('正在发送数据'.encode('utf-8'))\ns.close()\nNIO（non blocking io）\nNIO就不一样了，recvform系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error。进程在返回之后，可以干点别的事情，然后再发起recvform系统调用。重复上面的过程，循环往复的进行recvform系统调用。这个过程通常被称之为轮询。\n轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。\n\nJAVA 与NIO\nJava NIO(New IO)是一个可以替代标准Java IO API的IO API（从Java 1.4开始)，Java NIO提供了与标准IO不同的IO工作方式。\n在java中，标准的IO基于字节流和字符流进行操作的，而NIO是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。\n我们先看看Buffer类\nBuffer类\nJava NIO中的Buffer主要用于与NIO通道进行交互，数据是从通道读入到缓冲区，从缓冲区写入通道中的。概念上，缓冲区可以看成包在一个对象内的数组，下面看一个图\n\n这是一个新创建的容量为10的ByteBuffer逻辑图，他有四个属性来提供关于其包含的数据元素信息，分别是：\n1）容量（capacity）：表示Buffer最大数据容量，缓冲区容量不能为负，并且建立后不能修改。\n2）限制（limit）：也叫上界。第一个不应该读取或者写入的数据的索引，即位于limit后的数据不可以读写。缓冲区的限制不能为负，并且不能大于其容量（capacity）。\n3）位置（position）：下一个要读取或写入的数据的索引。缓冲区的位置不能为负，并且不能大于其限制（limit）。\n4）标记（mark）与重置（reset）：标记是一个索引，通过Buffer中的mark()方法指定Buffer中一个特定的position，之后可以通过调用reset()方法恢复到这个position。\n从这幅图可以看到，他的容量（capacity）和限制（limit）设置为10，位置设置为0，每个缓冲区容量是固定的，标记是未定义的，其他三个属性可以通过使用缓冲区解决。\n缓冲区存储数据支持的数据类型\n支持七种数据类型，他们是：1.byteBuffer2.charBuffer3.shortBuffer4.IntBuffer5.LongBuffer6.FloatBuffer7.DubooBuffer\n基本用法\n使用Buffer读写数据一般遵循以下四个步骤：\n(1) 写入数据到Buffer，一般有可以从Channel读取到缓冲区中，也可以调用put方法写入。\n(2) 调用flip()方法，切换数据模式。\n(3) 从Buffer中读取数据，一般从缓冲区读取数据写入到通道中，也可以调用get方法读取。\n(4) 调用clear()方法或者compact()方法。\n缓冲区API\n首先，用allocate 指定缓冲区大小1024\nByteBuffer byteBuffer=ByteBuffer.allocate(1024);\n存储或填充\n我们可以用put 存入数据到缓冲区\nbyteBuffer.put(\"tengshe789\".getBytes());\n当调用put时，会指出下一个元素应当被插入的位置，位置（position）指向的是下一个元素。如果指向的位置超过限制（limit），则抛出BufferOverFlowException异常。\n翻转\nFlip将一个能够继续添加数据元素的填充状态的缓冲区翻转成一个准备读出元素的释放状态\nbyteBuffer.flip();\n具体有什么用呢？\n对于已经写满了缓冲区，如果将缓冲区内容传递给一个通道，以使内容能被全部写出。\n但如果通道现在在缓冲区上执行get，那么它将从我们刚刚插入的有用数据之外取出未定义数据。通过翻转将位置值重新设为 0，通道就会从正确位置开始获取。\n例如我们定义了一个容量是10的buffer，并填入hello，如下图所示  \n\n翻转后如下图所示 \n\n重读\nRewind与 flip相似，但不影响上界属性。它只是将位置值设回 0。可以使用 rewind()后退，重读已经被翻转的缓冲区中的数据。\nbyteBuffer.rewind();\n获取\n翻转完了，就可以用get获取缓冲区数据了\nbyte[] b= new byte[byteBuffer.limit()];\nbyteBuffer.get(b);\n当调用get时，会指出下一个元素应当被索引的位置，位置（position）返回时会+1s。如果指向的位置超过限制（limit），则抛出BufferUnderFlowException异常。如果提供的索引超过范围，也会抛出IndexOutOfBoundsException异常\n释放\nremaining可以告诉你从当前位置（position）到限制（limit）还剩的元素数目\nint count = byteBuffer.remaining();\nclear将缓冲区重置为空状态\nbyteBuffer.clear();\n压缩\n如果我们只想从缓冲区中释放一部分数据，而不是全部，然后重新填充。为了实现这一点，未读的数据元素需要下移以使第一个元素索引为 0。尽管重复这样做会效率低下，但这有时非常必要，而 API 对此为您提供了一个 compact()函数。\nbyteBuffer.compact();\n标记与重置\n标记是一个索引，通过Buffer中的mark()方法指定Buffer中一个特定的position，之后可以通过调用reset()方法恢复到这个position。要知道缓冲区的标记在mark()函数被调用前时未定义的，如果标记未定义，调用reset()会导致InvalidMarkException异常\nbyteBuffer.position(2).mark().position(4).reset();\n要注意，java.nio中的类特意被设计为支持级联调用，优雅的使用级联调用，可以产生优美易读的代码。\n直接缓冲区与非直接缓冲区\n非直接缓冲区\n上面我们说了ByteBuffer，也就是缓冲区的用法，譬如用allocate() 方法指定缓冲区大小，然后进行填充或翻转操作等等等。我们所创建的缓冲区，都属于直接缓冲区。他们都是在JVM中内存中创建，在每次调用基础操作系统的一个本机IO之前或者之后，虚拟机都会将缓冲区的内容复制到中间缓冲区（或者从中间缓冲区复制内容），缓冲区的内容驻留在JVM内，因此销毁容易，但是占用JVM内存开销，处理过程中有复制操作。 \n非直接缓冲区写入步骤：\n1.创建一个临时的直接ByteBuffer对象。2.将非直接缓冲区的内容复制到临时缓冲中。3.使用临时缓冲区执行低层次I/O操作。4.临时缓冲区对象离开作用域，并最终成为被回收的无用数据。\n/**\n * @program: UndirectBuffer\n * @description: 利用通道完成文件的复制(非直接缓冲区)\n * @author: tEngSHe789\n **/\npublic class UndirectBuffer {\n    public static void main(String[] args) throws IOException {\n        // 创建流\n        FileInputStream fis = new FileInputStream(\"d://blog.md\");\n        FileOutputStream fos = new FileOutputStream(\"d://blog.md\");\n        //获取管道\n        FileChannel in = fis.getChannel();\n        FileChannel out = fos.getChannel();\n        // 分配指定大小的缓冲区\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        while (in.read(buffer) !=-1){\n            buffer.flip();// 准备读数据了\n            out.write(buffer);\n            buffer.clear();\n        }\n        out.close();\n        in.close();\n        fis.close();\n        fos.close();\n    }\n}\n直接缓冲区\n直接缓冲区，是通过 allocateDirect() 方法在JVM内存外开辟内存，在每次调用基础操作系统的一个本机IO之前或者之后，虚拟机都会避免将缓冲区的内容复制到中间缓冲区（或者从中间缓冲区复制内容），缓冲区的内容驻留在物理内存内，会少一次复制过程，如果需要循环使用缓冲区，用直接缓冲区可以很大地提高性能。\n虽然直接缓冲区使JVM可以进行高效的I/O操作，但它使用的内存是操作系统分配的，绕过了JVM堆栈，建立和销毁比堆栈上的缓冲区要更大的开销。\n/**\n * @program: DirectBuffer\n * @description: 使用直接缓冲区完成文件的复制(内存映射文件)\n * @author: tEngSHe789\n **/\npublic class DirectBuffer {\n    public static void main(String[] args) throws IOException {\n        //创建管道\n        FileChannel in=FileChannel.open(Paths.get(\"d://blog.md\"),StandardOpenOption.READ);\n        FileChannel out=FileChannel.open(Paths.get(\"d://blog.md\"),StandardOpenOption.WRITE\n                        ,StandardOpenOption.READ,StandardOpenOption.CREATE);\n        // 拿到将管道内容映射到内存的直接缓冲区映射文件（一个位置在硬盘的基于内存的缓冲区）\n        MappedByteBuffer inMappedByteBuffer = in.map(FileChannel.MapMode.READ_ONLY, 0, in.size());\n        MappedByteBuffer outMappedByteBuffer = out.map(FileChannel.MapMode.READ_WRITE, 0, in.size());\n        // 对直接缓冲区进行数据读写操作\n        byte[] bytes=new byte[inMappedByteBuffer.limit()];\n        inMappedByteBuffer.get(bytes);\n        outMappedByteBuffer.put(bytes);\n        in.close();\n        out.close();\n    }\n}\n直接缓冲区与非直接缓冲区的区别\n\n字节缓冲区要么是直接的，要么是非直接的。如果为直接字节缓冲区，则 Java 虚拟机会尽最大努力直接在此缓冲区上执行本机 I/O 操作。也就是说，在每次调用基础操作系统的一个本机 I/O 操作之前（或之后），虚拟机都会尽量避免将缓冲区的内容复制到中间缓冲区中（或从中间缓冲区中复制内容）。\n直接字节缓冲区可以通过调用此类的 allocateDirect() 工厂方法来创建。此方法返回的缓冲区进行分配和取消分配所需成本通常高于非直接缓冲区。直接缓冲区的内容可以驻留在常规的垃圾回收堆之外，因此，它们对应用程序的内存需求量造成的影响可能并不明显。所以，建议将直接缓冲区主要分配给那些易受基础系统的本机 I/O 操作影响的大型、持久的缓冲区。一般情况下，最好仅在直接缓冲区能在程序性能方面带来明显好处时分配它们。\n直接字节缓冲区还可以通过 FileChannel 的 map() 方法 将文件区域直接映射到内存中来创建。该方法返回MappedByteBuffer 。 Java 平台的实现有助于通过 JNI 从本机代码创建直接字节缓冲区。如果以上这些缓冲区中的某个缓冲区实例指的是不可访问的内存区域，则试图访问该区域不会更改该缓冲区的内容，并且将会在访问期间或稍后的某个时间导致抛出不确定的异常。\n字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其 isDirect() 方法来确定。提供此方法是为了能够在性能关键型代码中执行显式缓冲区管理。\n\nChannel\n通道是java.nio的第二个创新，表示提供 IO 设备(例如：文件、套接字)的直接连接。\n若需要使用 NIO 系统，需要获取用于连接 IO 设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理。这其中，Channel负责传输， Buffer 负责存储。\n通道是由java.nio.channels 包定义的，Channel 表示 IO 源与目标打开的连接。Channel 类似于传统的“流”。只不过 Channel本身不能直接访问数据， Channel 只能与Buffer 进行交互。\n接口\njava.nio.channels.Channel 接口：\n\nFileChannel\nSocketChannel\nServerSocketChannel\nDatagramChannel\n\n与缓冲区不同，通道API主要由接口指定，不同操作系统上通道的实现会不一样\n实现\n直接缓冲区与非直接缓冲区的栗子\n分散读取与聚集写入\n通道可以有选择地实现两个新的接口： ScatteringByteChannel 和 GatheringByteChannel。\n\nScatteringByteChannel 有2个read方法，我们都叫她分散读取(scattering Reads)，分散读取中，通道依次填充每个缓冲区。填满一个缓冲区后，它就开始填充下一个。在某种意义上，缓冲区数组就像一个大缓冲区。\n\nGatheringByteChannel中有2个wirte方法，我们都叫她聚集写入(gathering Writes)，他可以将多个缓冲区的数据聚集到通道中\n分散读取与聚集写入的应用\n分散读取/聚集写入对于将数据划分为几个部分很有用。例如，您可能在编写一个使用消息对象的网络应用程序，每一个消息被划分为固定长度的头部和固定长度的正文。您可以创建一个刚好可以容纳头部的缓冲区和另一个刚好可以容难正文的缓冲区。当您将它们放入一个数组中并使用分散读取来向它们读入消息时，头部和正文将整齐地划分到这两个缓冲区中。\n我们从缓冲区所得到的方便性对于缓冲区数组同样有效。因为每一个缓冲区都跟踪自己还可以接受多少数据，所以分散读取会自动找到有空间接受数据的第一个缓冲区。在这个缓冲区填满后，它就会移动到下一个缓冲区。\nPython与NIO\n服务端（具体见注释）\nfrom socket import *\nimport time\ns=socket(AF_INET,SOCK_STREAM)\ns.bind(('127.0.0.1',8888))\ns.listen(5)\ns.setblocking(False) #设置socket的接口为非阻塞\nconn_l=[] # 存储和server的连接 的 连接\ndel_l=[] # 存储和和server的断开 的 连接\nwhile True:\n    try:\n        # 这个过程是不阻塞的\n        conn,addr=s.accept() # 当没人连接的时候会报错，走exception（<- py中是except）\n        conn_l.append(conn)\n    except BlockingIOError:\n        print(conn_l)\n        for conn in conn_l:\n            try:\n                data=conn.recv(1024)\n                if not data:\n                    del_l.append(conn)\n                # 这个过程是不阻塞的\n                data=conn.recv(1024) # 不阻塞\n                if not data: # 如果拿不到data\n                    del_l.append(conn) # 在废弃列表中添加conn\n                    continue\n                conn.send(data.upper())\n            except BlockingIOError:\n                pass\n            except ConnectionResetError:\n                del_l.append(conn)\n\n        for conn in del_l:\n            conn_l.remove(conn)\n            conn.close()\n        del_l=[]\n客户端\nfrom socket import *\nc=socket(AF_INET,SOCK_STREAM)\nc.connect(('127.0.0.1',8888))\n\nwhile True:\n    msg=input('>>: ')\n    if not msg:continue\n    c.send(msg.encode('utf-8'))\n    data=c.recv(1024)\n    print(data.decode('utf-8'))\nIO复用(IO multiplexing)\nI/O多路复用实际上就是用select, poll, epoll监听多个io对象，当io对象有变化（有数据）的时候就通知用户进程。有些地方也称这种IO方式为事件驱动IO(event driven IO)。与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。当然具体的可以看看这篇博客，现在先来看下I/O多路复用的流程：\n\n（1）当用户进程调用了select，那么整个进程会被block；\n（2）而同时，kernel会“监视”所有select负责的socket；\n（3）当任何一个socket中的数据准备好了，select就会返回；\n（4）这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。\n这个图和BIO的图其实并没有太大的不同，事实上还更差一些。因为这里需要使用两个系统调用(select和recvfrom)，而BIO只调用了一个系统调用(recvfrom)。但是，用select的优势在于它可以同时处理多个connection。\nJAVA实现IO复用\n这里我们使用的是java.nio下模块来完成I/O多路复用的例子。我用到的Selector（选择器），是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接。\nSelector的使用\nSelector的创建\nSelector selector = Selector.open();\n向Selector注册通道\n为了将Channel和Selector配合使用，必须将channel注册到selector上。通过SelectableChannel.register()方法来实现，如下：\nchannel.configureBlocking(false);\nSelectionKey key = channel.register(selector,Selectionkey.OP_READ);\nregister()方法的第二个参数是一个“interest集合”，意思是在通过Selector监听Channel时对什么事件感兴趣。可以监听四种不同类型的事件：Connect、Accept、Read、Write\n通道触发了一个事件意思是该事件已经就绪。所以，某个channel成功连接到另一个服务器称为“连接就绪”。一个server socket channel准备好接收新进入的连接称为“接收就绪”。一个有数据可读的通道可以说是“读就绪”。等待写数据的通道可以说是“写就绪”。\n这四种事件用SelectionKey的四个常量来表示：\n\nSelectionKey.OP_CONNECT可连接\nSelectionKey.OP_ACCEPT可接受连接\nSelectionKey.OP_READ可读\nSelectionKey.OP_WRITE可写\n\nSelectionKey\n当向Selector注册Channel时，register()方法会返回一个SelectionKey对象。它包含了：\n\ninterest集合\nready集合\nChannel\nSelector\n附加的对象（可选）\n\ninterest集合\ninterest集合是你所选择的感兴趣的事件集合。可以通过SelectionKey读写interest集合，像这样：\nint interestSet = selectionKey.interestOps();\n\nboolean isInterestedInAccept  = (interestSet & SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT；\nboolean isInterestedInConnect = interestSet & SelectionKey.OP_CONNECT;\nboolean isInterestedInRead    = interestSet & SelectionKey.OP_READ;\nboolean isInterestedInWrite   = interestSet & SelectionKey.OP_WRITE;\n可以看到，用“位与”操作interest 集合和给定的SelectionKey常量，可以确定某个确定的事件是否在interest 集合中。\nready集合\nready 集合是通道已经准备就绪的操作的集合。在一次选择(Selection)之后，你会首先访问这个ready set。Selection将在下一小节进行解释。可以这样访问ready集合：\nint readySet = selectionKey.readyOps();\n可以用像检测interest集合那样的方法，来检测channel中什么事件或操作已经就绪。但是，也可以使用以下四个方法，它们都会返回一个布尔类型：\nselectionKey.isAcceptable();\nselectionKey.isConnectable();\nselectionKey.isReadable();\nselectionKey.isWritable();\n从SelectionKey访问Channel和Selector\nChannel  channel  = selectionKey.channel();\nSelector selector = selectionKey.selector();\njava代码\n/**\n * @program: NIOServer\n * @description: 服务端\n * @author: tEngSHe789\n **/\npublic class NIOServer {\n    public static void main(String[] args) throws IOException {\n        System.out.println(\"服务端Start....\");\n        // 创建通道\n        ServerSocketChannel serverSocketChannel=ServerSocketChannel.open();\n        // 设置非阻塞\n        serverSocketChannel.configureBlocking(false);\n        // 绑定连接\n        serverSocketChannel.bind(new InetSocketAddress(8888));\n        // 获取选择器\n        Selector selector=Selector.open();\n        // 将通道注册到选择器\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n        // 轮调式获取选择“已经准备就绪”的事件\n        while (selector.select() > 0){\n            // 获取当前选择器的左右已经准备就绪的监听事件（选择key）\n            Iterator<SelectionKey> iterator=selector.selectedKeys().iterator();\n            while (iterator.hasNext()){\n                // 获取准备就绪事件\n                SelectionKey selectionKey=iterator.next();\n                // 判断具体是什么事件\n                if (selectionKey.isAcceptable()){//如果是“接受就绪”\n                    SocketChannel socketChannel=serverSocketChannel.accept();// 获取连接\n                    socketChannel.configureBlocking(false); // 设置非阻塞\n                    //将该通道注册到服务器上\n                    socketChannel.register(selector, SelectionKey.OP_READ);\n                }else if (selectionKey.isReadable()){//如是“已经就绪”\n                    SocketChannel socketChannel= (SocketChannel) selectionKey.channel();//获取连接\n                    //读数据\n                    ByteBuffer buffer=ByteBuffer.allocate(1024);\n                    int len = 0;\n                    //分散读取\n                    len=socketChannel.read(buffer);\n                    while (len > 0){\n                        buffer.flip();\n                        System.out.println(new String(buffer.array(),0,len));\n                        buffer.clear();\n                    }\n                }\n                iterator.remove();\n            }\n        }\n    }\n}\n客户端：\n/**\n * @program: NIOClient\n * @description: 客户端\n * @author: tEngSHe789\n **/\npublic class NIOClient {\n    public static void main(String[] args) throws IOException {\n        System.out.println(\"客户端Start....\");\n        // 创建通道\n        SocketChannel socketChannel=SocketChannel.open(new InetSocketAddress(\"127.0.0.1\",8888));\n        // 设置SocketChannel接口为非阻塞\n        socketChannel.configureBlocking(false);\n        //指定缓冲区大小\n        ByteBuffer buffer=ByteBuffer.allocate(1024);\n        Scanner scanner=new Scanner(System.in);\n        while (scanner.hasNext()){\n            String msg = scanner.next();\n            // 存储\n            buffer.put((new Date().toString()+\"\\n\"+msg).getBytes());\n            // 翻转\n            buffer.flip();\n            // 聚集写入\n            socketChannel.write(buffer);\n            // 释放\n            buffer.clear();\n        }\n        socketChannel.close();\n    }\n}\npython实现IO复用\n对比java用的是Selector，可以帮我们在默认操作系统下选择最合适的select, poll, epoll这三种多路复合模型，python是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。\n服务端\nfrom socket import *\nimport select\n\ns=socket(AF_INET,SOCK_STREAM)\ns.setsockopt(SOL_SOCKET,SO_REUSEADDR,1)\ns.bind(('127.0.0.1',8888))\ns.listen(5)\ns.setblocking(False) #设置socket的接口为非阻塞\nread_l=[s,] # 数据可读通道的列表\nwhile True:\n    # 监听的read_l中的socket对象内部如果有变化，那么这个对象就会在r_l\n    # 第二个参数里有什么对象，w_l中就有什么对象\n    # 第三个参数 如果这里的对象内部出错，那会把这些对象加到x_l中\n    # 1 是超时时间\n    r_l,w_l,x_l=select.select(read_l,[],[],1)\n    print(r_l)\n    for ready_obj in r_l:\n        if ready_obj == s:\n            conn,addr=ready_obj.accept() #此时的ready_obj等于s\n            read_l.append(conn)\n        else:\n            try:\n                data=ready_obj.recv(1024) #此时的ready_obj等于conn\n                if not data:\n                    ready_obj.close()\n                    read_l.remove(ready_obj)\n                    raise Exception('连接断开')\n                ready_obj.send(data.upper())\n            except ConnectionResetError:\n                ready_obj.close()\n                read_l.remove(ready_obj)\n客户端\nfrom socket import *\nc=socket(AF_INET,SOCK_STREAM)\nc.connect(('127.0.0.1',8888))\n\nwhile True:\n    msg=input('>>>: ')\n    if not msg:continue\n    c.send(msg.encode('utf-8'))\n    data=c.recv(1024)\n    print(data.decode('utf-8'))\nAIO（asynchronous io）\n真正的异步I/O很牛逼，流程大概如下：\n\n（1）用户进程发起read操作之后，立刻就可以开始去做其它的事。\n（2）而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。\n（3）然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。\nJava\nJava中使用AIO需要用到java.nio.channels.AsynchronousChannelGroup和java.nio.channels.AsynchronousServerSocketChannel的包，由于实际项目鲜有人用，就不演示了\n总结\n回顾一下各个IO Model的比较，如图所示：\n\n\nblocking io ：阻塞型io，再熟悉不过，处理accept、read、write都会阻塞用户进程\nnon blocking io：当通过系统调用的时候，如果没有连接或者数据到达就直接返回一个错误，用户进程不阻塞但是不断的轮询。注意这个不是java nio框架中对应的网络模型\nio multiplexing：io多路复用才是nio对应的网络io模型。该模型对于用户进程也是阻塞的，优点是可以同时支持多个connetciotn。前三种都属于同步模式，既然都是同步的，如果要做到看似非阻塞，那么就需要轮询机制。相对于上一种模型，这种只是将轮询从用户进程转移到了操作系统内核，通过调用select函数，不断轮询多个connection是否ready，如果有一种ready好的，就通过事件通知用户进程，用户进程再通过事件来处理。所以在java的nio中会看到一大堆事件处理。这种模型的阻塞不是在socket层面的阻塞，而是在调动select函数的阻塞。而且相对于blocking io，还多了一次select的系统调用，其实性能会更低，所以在低吞吐量下，这种io不见得比bio+线程池的模型优越。\nsign driven：极少使用，不知道\nasync io ：java7时候开始升级，也成为nio2。实现了异步的io。前三种都是通过用户进程在主动获取（bio的阻塞，nbio的轮询和iomult的按事件获取），而aio交互很简单，用户进程调用后立即返回，用户进程不阻塞，内核当完成网络io和数据复制后，主动通知用户进程。前面说到的系统内核做的操作，除了等待网络io就绪数据到达内核，还有从系统内核复制用户空间去的过程，异步io这两者对于用户进程而言都是非阻塞的，而前三种，在数据从内核复制到用户空间这个过程，都是阻塞的。\n\n参考资料\n前言说的那本书\nRon Hitchens于2002年 著的《java nio》\nfindumars\n冬瓜蔡\n彼岸船夫 \nNIO的/分散读取和聚集写入\n并发编程网\n感谢\n续1s时间\n全片结束，觉得我写的不错？想要了解更多精彩新姿势？赶快打开我的👉个人博客 👈吧！\n本文地址https://blog.tengshe789.tech/...，部分觉得比较用心的会同步到掘金，简书，谢谢你那么可爱，还一直关注着我~❤😝\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}