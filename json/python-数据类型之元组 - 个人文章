{"title": "python-数据类型之元组 - 个人文章 ", "index": "元组,python", "content": "元组是不可以改变的序列，如果元组的元素包含列表、字典是支持修改操作的。因为不可变所以元素的修改会报错：\n>>> tt=(3,4,5)\n>>> type(tt)\n<type 'tuple'>\n>>> tt[2]=4\nTraceback (most recent call last):   File \"<stdin>\", line 1, in <module>   TypeError: 'tuple' object does not support item assignment（#元素修改报错）\n（一）元组（1）定义元组： 创建一个元组并给他赋值实际上跟创建一个列表并给它赋值完全一样,除了一点,只有一个元素的元组需要在元组分割符里面加一个逗号(,)用以防止跟普通的分组操作符混淆.不要忘了它是一个工厂方法\n>>> a=()\n>>> a=(1,)                 #如果不加,就表示a=(1)等价于1\n>>> a     \n(1,)\n>>> a=2,3\n>>> type(a)\n<type 'tuple'>\n>>> a\n(2, 3)\n>>> tuple(\"bar\")        #工厂方法定义无组\n('b', 'a', 'r')\n>>> def f():           #函数的返回值是一个元组\n>>>     return 2,3\n>>> f()\n(2, 3)\n\n元组的成员：包括字典、列表、数字、字符：\n>>> tuple22=(None,5,6,6,'ab',[1,2,3])\n>>> a=(1,2,\"a\",[\"b\",3],{1:2})\n>>> type(a)\n<type 'tuple'>\n>>> for i in a:\n...     print i\n...\n1\n2\na\n['b', 3]\n{1: 2}\n>>> a[3][0]=\"x\"\n>>> print a\n(1, 2, 'a', ['x', 3], {1: 2})\n>>> a[4][1]=\"x\"\n>>> print a\n(1, 2, 'a', ['x', 3], {1: 'x'})\n\n（2）访问元组：元组的切片操作跟列表一样,用方括号作为切片操符([]),里面写上索引值或者索引范围.\n>>> aTuple = (123, 'abc', 4.56, ['inner', 'tuple'], 7-9j)\n>>> aTuple[1:4]\n('abc', 4.56, ['inner', 'tuple'])\n>>> aTuple[:3]\n(123, 'abc', 4.56)\n>>> aTuple[3][1]\n'tuple'\n\n（3）更新元组：跟数字和字符串一样,元组也是不可变类型,就是说你不能更新或者改变元组的元素,我们是通过现有字符串的片段再构造一个新字符串的方式解决的,对元组同样需要这样.\n>>> aTuple = aTuple[0], aTuple[1], aTuple[-1]\n>>> aTuple\n(123, 'abc', (7-9j))\n>>> tup1=(12,34.56)\n>>> tup2=(\"abc\",\"xyz\")\n>>> tup3=tup1+tup2\n>>> tup3\n(12, 34.56, 'abc', 'xyz')\n\n（4）元组的删除：删除一个单独的元组元素是不可能的，删除一整个元组是可以的。\n>>> a=(1,[2,3],{4:5,5:6})\n>>> del a[0]\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: 'tuple' object doesn't support item deletion\n>>> del a[1][1]\n>>> print a\n(1, [2], {4: 5, 5: 6})\n>>> del a[2][4]\n>>> print a\n(1, [2], {5: 6})\n\n（二）元组：标准类型操作符,序列类型操作符和内建函数（1）创建,重复,连接操作\n>>> t = (['xyz', 123], 23, -103.4)\n>>> t\n(['xyz', 123], 23, -103.4)\n>>> t*2\n(['xyz', 123], 23, -103.4, ['xyz', 123], 23, -103.4)\n>>> t=t+(\"free\",\"easy\")\n>>> t\n(['xyz', 123], 23, -103.4, 'free', 'easy')\n\n(2)成员关系操作,切片操作\n>>> 23 in t\nTrue\n>>> 123 in t\nFalse\n>>> t[0][1]\n123\n>>> t[1:]\n(23, -103.4, 'free', 'easy')\n\n(3)内建函数\n>>> str(t)\n\"(['xyz', 123], 23, -103.4, 'free', 'easy')\"\n>>> len(t)\n5\n>>> max(t)\n'free'\n>>> min(t)\n-103.4\n>>> cmp(t,(['xyz', 123], 23, -103.4, 'free', 'easy'))\n0\n>>> list(t)\n[['xyz', 123], 23, -103.4, 'free', 'easy']\n\n(4)操作符\n>>> (4,2)<(3,5)\nFalse\n>>> (2,4)<(3,-1)\nTrue\n>>> (2,4)==(3,-1)\nFalse\n>>> (2,4)==(2,4)\nTrue\n\n（三）元组类型操作符和内建函数,内建方法：元组的特殊性（1）所有的多对象的，逗号分隔的，没有明确用符号定义的，比如说像用方括号表示列表和用圆括号表示元组一样，等等这些集合默认的类型都是元组：\n>>> 'abc', -4.24e93, 18+6.6j, 'xyz'\n('abc', -4.24e+93, (18+6.6j), 'xyz')\n>>> x,y=1,2\n>>> x,y\n(1, 2)\n\n所有函数返回的多对象（不包括有符号封装的）都是元组类型。注意，有符号封装的多对象集合其实是返回的一个单一的容器对象：\n>>> def foo(x,y):\n...     return x,y\n>>> foo(4,5)\n(4, 5)\n\n>>> def foo1(x,y):\n...     return (x,y)\n>>> foo1(5,6)\n(5, 6)\n\n（2）作为字典的关键字不可变对象的值是不可改变的。这就意味着它们通过 hash 算法得到的值总是一个值。这是作为字典键值的一个必备条件。\n>>> dic={(3,4):\"welcome\",\"a\":333}\n>>> dic\n{'a': 333, (3, 4): 'welcome'}\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}