{"title": "Python 中使用 C 代码：以 Numpy 为例 - SegmentFault 业界资讯 ", "index": "numpy,cython,c,python", "content": "这个章节包含许多在python代码中支持c/c++本机代码的许多不同方法， 通常这个过程叫作包裹(wrapping)。本章的目的是让您大致知道有那些技术和它们分别的优缺点是什么，于是您能够为您自己的特定需要选择何时的技术。在任何情况下，一旦您开始包裹，您几乎一定将想要查阅您所选技术各自的文档。\n\n简介\n\n本章节包含以下技术：\n\n\nPython-C-Api\nCtypes\nSWIG(简单包裹和接口生成)\nCython\n\n这四种方法大概是最著名的，其中Cython可能是最高级且应该优先使用的。如果您想从其它角度理解包裹问题，其它方法也很重要。已经说过，虽然还有其它方法，但是理解以上基本方法，您将能评估您自己的选择看是否符合自己的需要。\n\n以下标准在评估一项技术时也许有用：\n\n\n是否需要额外的库？\n代码是否是自动生成的？\n需要编译吗？\n和Numpy数组进行交互方便吗？\n支持C++吗？\n\n首先，您应该考虑你的用例。当用本机代码接口时，通常有两个用例：\n\n\n存在需要充分利用的C/C++代码，或者那些代码已经存在，或者那些代码更快。\nPython代码慢爆了，将内循环交给本机代码处理\n\n每个技术通过包裹math.h中的cos函数实现。尽管这是微不足道的例子，它将很好的展示基本的包裹问题。因为每个技术也包括某种形式的Numpy支持，这也通过使用一个余弦函数被在某种数组上计算的例子来展示。\n\n最后但重要的是两个小警告：\n\n\n所有这些技术都可能造成Python解释器崩溃(段错误)，这(通常)是C代码的Bug。\n所有例子在linux上完成，也应该能在其它操作系统上实现\n大多数例子中你需要一个C编译器\n\nPython-C-Api\n\nPython-C-API是标准Python解释器(就是所谓的CPython)的支柱。使用这个API可以用C或C++语言编写Python扩展。显然这些扩展模块可以凭借语言兼容性，调用任何C或C++写成的函数。\n\n当使用Python-C-API时，人们通常写许多样板代码，先解析传递给函数的参数，然后构建并返回类型。\n\n优点\n\n\n无需额外的库\n许多低级的控制\n完全可以用C++\n\n劣势\n\n\n可能需要大量工作\n代码中的大量开销\n必须编译\n高额的维护代价\n当跨Python版本时若C-Api变化没有后向兼容性\n\n注意：以下Python-C-Api示例主要为了展示需要。因为大多其它技术实际上依赖这个，所以最好对它如何工作有个高层次的了解。在99%的用例中你最好使用其它技术。\n\n示例\n\n以下C扩展模块，让标准数学库中的cos函数在Python中可用：\n\n/*  Example of wrapping cos function from math.h with the Python-C-API. */\n\n#include <Python.h>\n#include <math.h>\n\n/*  wrapped cosine function */\nstatic PyObject* cos_func(PyObject* self, PyObject* args)\n{\n    double value;\n    double answer;\n\n    /*  parse the input, from python float to c double */\n    if (!PyArg_ParseTuple(args, \"d\", &value))\n        return NULL;\n    /* if the above function returns -1, an appropriate Python exception will\n     * have been set, and the function simply returns NULL\n     */\n\n    /* call cos from libm */\n    answer = cos(value);\n\n    /*  construct the output from cos, from c double to python float */\n    return Py_BuildValue(\"f\", answer);\n}\n\n/*  define functions in module */\nstatic PyMethodDef CosMethods[] =\n{\n     {\"cos_func\", cos_func, METH_VARARGS, \"evaluate the cosine\"},\n     {NULL, NULL, 0, NULL}\n};\n\n/* module initialization */\nPyMODINIT_FUNC\n\ninitcos_module(void)\n{\n     (void) Py_InitModule(\"cos_module\", CosMethods);\n}\n\n\n如您所见，所有对参数处理、返回类型和模块初始化都相当样板化。然而有些被摊销了，当扩展增长时，样板需要每个函数保留。\n\n标准python构建系统distutils支持从setup.py编译C扩展，这相当方便。\n\nfrom distutils.core import setup, Extension\n\n# define the extension module\ncos_module = Extension('cos_module', sources=['cos_module.c'])\n\n# run the setup\nsetup(ext_modules=[cos_module])\n\n\n这能被编译：\n\n ~/Work/scipy-lecture-notes/interfacing-with-c $ls\ncos_module.c  setup.py\n ~/Work/scipy-lecture-notes/interfacing-with-c $python setup.py build_ext --inplace\nrunning build_ext\nbuilding 'cos_module' extension\nx86_64-pc-linux-gnu-gcc -pthread -fPIC -I/usr/include/python2.7 -c cos_module.c -o build/temp.linux-x86_64-2.7/cos_module.o\nx86_64-pc-linux-gnu-gcc -pthread -shared build/temp.linux-x86_64-2.7/cos_module.o -L/usr/lib64 -lpython2.7 -o /home/lyy/Work/scipy-lecture-notes/interfacing-with-c/cos_module.so\n ~/Work/scipy-lecture-notes/interfacing-with-c $ls\nbuild  cos_module.c  cos_module.so  setup.py\n\n\n\n\nbuild_ext是用来构建扩展模块的\n\n--inplace将编译好的扩展模块输出到当前文件夹\n\n文件cos_module.so包含编译的扩展，我们能将它加载到IPython解释器中：\n\nIn [1]: import cos_module\n\nIn [2]: cos_module?\nType:       module\nString Form:<module 'cos_module' from 'cos_module.so'>\nFile:       /home/lyy/Work/scipy-lecture-notes/interfacing-with-c/cos_module.so\nDocstring:  <no docstring>\n\nIn [3]: dir(cos_module)\nOut[3]: ['__doc__', '__file__', '__name__', '__package__', 'cos_func']\n\nIn [4]: cos_module.cos_func(1.0)\nOut[4]: 0.5403023058681398\n\nIn [5]: cos_module.cos_func(0.0)\nOut[5]: 1.0\n\nIn [6]: cos_module.cos_func(3.14159265359)\nOut[6]: -1.0\n\n\n现在让我们看看它有多健壮：\n\nIn [7]: cos_module.cos_func('foo')\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n<ipython-input-7-11bee483665d> in <module>()\n----> 1 cos_module.cos_func('foo')\n\nTypeError: a float is required\n\n\nNumpy支持\n\n类似于Python-C-API,Numpu自身作为C扩展实现也有Numpy-C-API。这个API可以在写自定的C扩展时，被用来从C创建和操作Numpy数组。参见高级Numpy\n\n以下例子展示了如何将Numpy数组作为参数传递给函数，如何使用(老的)Numpy-C-API遍历整个Numpy数组。它仅仅将数组作为参数，运用来自math.h中的余弦函数，并且返回一个新的结果数组。\n\n/*  Example of wrapping the cos function from math.h using the Numpy-C-API. */\n\n#include <Python.h>\n#include <numpy/arrayobject.h>\n#include <math.h>\n\n/*  wrapped cosine function */\nstatic PyObject* cos_func_np(PyObject* self, PyObject* args)\n{\n\n    PyArrayObject *in_array;\n    PyObject      *out_array;\n    PyArrayIterObject *in_iter;\n    PyArrayIterObject *out_iter;\n\n    /*  parse single numpy array argument */\n    if (!PyArg_ParseTuple(args, \"O!\", &PyArray_Type, &in_array))\n        return NULL;\n\n    /*  construct the output array, like the input array */\n    out_array = PyArray_NewLikeArray(in_array, NPY_ANYORDER, NULL, 0);\n    if (out_array == NULL)\n        return NULL;\n\n    /*  create the iterators */\n    /* TODO: this iterator API is deprecated since 1.6\n     *       replace in favour of the new NpyIter API */\n    in_iter  = (PyArrayIterObject *)PyArray_IterNew((PyObject*)in_array);\n    out_iter = (PyArrayIterObject *)PyArray_IterNew(out_array);\n    if (in_iter == NULL || out_iter == NULL)\n        goto fail;\n\n    /*  iterate over the arrays */\n    while (in_iter->index < in_iter->size\n            && out_iter->index < out_iter->size) {\n        /* get the datapointers */\n        double * in_dataptr = (double *)in_iter->dataptr;\n        double * out_dataptr = (double *)out_iter->dataptr;\n        /* cosine of input into output */\n        *out_dataptr = cos(*in_dataptr);\n        /* update the iterator */\n        PyArray_ITER_NEXT(in_iter);\n        PyArray_ITER_NEXT(out_iter);\n    }\n\n    /*  clean up and return the result */\n    Py_DECREF(in_iter);\n    Py_DECREF(out_iter);\n    Py_INCREF(out_array);\n    return out_array;\n\n    /*  in case bad things happen */\n    fail:\n        Py_XDECREF(out_array);\n        Py_XDECREF(in_iter);\n        Py_XDECREF(out_iter);\n        return NULL;\n}\n\n/*  define functions in module */\nstatic PyMethodDef CosMethods[] =\n{\n     {\"cos_func_np\", cos_func_np, METH_VARARGS,\n         \"evaluate the cosine on a numpy array\"},\n     {NULL, NULL, 0, NULL}\n};\n\n/* module initialization */\nPyMODINIT_FUNC\n\ninitcos_module_np(void)\n{\n     (void) Py_InitModule(\"cos_module_np\", CosMethods);\n     /* IMPORTANT: this must be called */\n     import_array();\n}\n\n\n我们仍可使用distutils编译这个。然而，我们必须通过使用numpy.get_include()保证包含了Numpy头文件。\n\nfrom distutils.core import setup, Extension\nimport numpy\n\n# define the extension module\ncos_module_np = Extension('cos_module_np', sources=['cos_module_np.c'],\n                          include_dirs=[numpy.get_include()])\n\n# run the setup\nsetup(ext_modules=[cos_module_np])\n\n\n为确信它确实能用我们做以下测试脚本：\n\nimport cos_module_np\nimport numpy as np\nimport pylab\n\nx = np.arange(0, 2 * np.pi, 0.1)\ny = cos_module_np.cos_func_np(x)\npylab.plot(x, y)\npylab.show()\n\n\n结果将如下图\n\n\n\nCtypes\n\nCtypes是一个Python的外部函数库。它提供了兼容C的数据类型。并且允许调用DLL或共享库中的函数。它能够被用来将这些库用纯Python包裹。\n\n优势\n\n\nPython标准库的一部分\n不必编译\n完全用Python包裹代码\n\n劣势\n\n\n需要将代码包裹作为共享库获得(粗略地说就是Windows中的*.dll、Linux下的*.so和Mac OSX的*.dylib)\n对C++支持不好\n\n示例\n\n如上所述，包裹的代码是纯Python的。\n\n\"\"\" Example of wrapping cos function from math.h using ctypes. \"\"\"\n\nimport ctypes\nfrom ctypes.util import find_library\n\n# find and load the library\nlibm = ctypes.cdll.LoadLibrary(find_library('m'))\n# set the argument type\nlibm.cos.argtypes = [ctypes.c_double]\n# set the return type\nlibm.cos.restype = ctypes.c_double\n\n\ndef cos_func(arg):\n    ''' Wrapper for cos from math.h '''\n    return libm.cos(arg)\n\n\n\n寻找和加载库可能依赖于不同的操作系统，检查文档获取细节。\n这稍微有点虚幻，因为在系统上已经存在编译好的数学库。如果你将包裹一个在自己的库，你将不得不先编译它。这也许需要也许不需要额外的工作。\n\n我们现在如前述那样使用它：\n\nIn [1]: import cos_module\n\nIn [2]: cos_module?\nType:       module\nString Form:<module 'cos_module' from 'cos_module.py'>\nFile:       /home/esc/git-working/scipy-lecture-notes/advanced/interfacing_with_c/ctypes/cos_module.py\nDocstring:  <no docstring>\n\nIn [3]: dir(cos_module)\nOut[3]:\n['__builtins__',\n '__doc__',\n '__file__',\n '__name__',\n '__package__',\n 'cos_func',\n 'ctypes',\n 'find_library',\n 'libm']\n\nIn [4]: cos_module.cos_func(1.0)\nOut[4]: 0.5403023058681398\n\nIn [5]: cos_module.cos_func(0.0)\nOut[5]: 1.0\n\nIn [6]: cos_module.cos_func(3.14159265359)\nOut[6]: -1.0\n\n\n正如之前的例子，这个代码稍微健壮一些。尽管错误信息不怎么有用，因它并没告诉我们应该是什么类型。\n\nIn [7]: cos_module.cos_func('foo')\n---------------------------------------------------------------------------\nArgumentError                             Traceback (most recent call last)\n<ipython-input-7-11bee483665d> in <module>()\n----> 1 cos_module.cos_func('foo')\n\n/home/esc/git-working/scipy-lecture-notes/advanced/interfacing_with_c/ctypes/cos_module.py in cos_func(arg)\n     12 def cos_func(arg):\n     13     ''' Wrapper for cos from math.h '''\n---> 14     return libm.cos(arg)\n\nArgumentError: argument 1: <type 'exceptions.TypeError'>: wrong type\n\n\nNumpy支持\n\nNumpy包含一些对ctypes接口的支持。特别是有导出Numpy数组作为ctypes数据类型的某一属性的支持，并且有将C数组和Numpy数组互相转化的函数。\n\n更多信息参考Numpy Cookbook中相应章节和numpy.ndarray.ctypes和numpy.ctypeslib的API文档。\n\n在以下例子中，让我们考虑一个库中的C函数，这个函数接受一个数组作为输入并输出一个数组，计算输入数组的正弦值并将结果存储在输出数组中。\n\n这个库包含以下头文件(尽管就这个例子不严格需要，为完整性需要我们列出它)：\n\nvoid cos_doubles(double * in_array, double * out_array, int size);\n\n\n这个实现在C源码中如下：\n\n#include <math.h>\n\n/*  Compute the cosine of each element in in_array, storing the result in\n *  out_array. */\nvoid cos_doubles(double * in_array, double * out_array, int size){\n    int i;\n    for(i=0;i<size;i++){\n        out_array[i] = cos(in_array[i]);\n    }\n}\n\n\n因为这个库是纯C的，我们不能使用distutils来编译它。必须同时使用make和gcc:\n\nm.PHONY : clean\n\nlibcos_doubles.so : cos_doubles.o\n    gcc -shared -Wl,-soname,libcos_doubles.so -o libcos_doubles.so cos_doubles.o\n\ncos_doubles.o : cos_doubles.c\n    gcc -c -fPIC cos_doubles.c -o cos_doubles.o\n\nclean :\n    -rm -vf libcos_doubles.so cos_doubles.o cos_doubles.pyc\n\n\n我们接着可以将之编译到共享库libcos_double.so中(linux下):\n\n$ ls\ncos_doubles.c  cos_doubles.h  cos_doubles.py  makefile  test_cos_doubles.py\n$ make\ngcc -c -fPIC cos_doubles.c -o cos_doubles.o\ngcc -shared -Wl,-soname,libcos_doubles.so -o libcos_doubles.so cos_doubles.o\n$ ls\ncos_doubles.c  cos_doubles.o   libcos_doubles.so*  test_cos_doubles.py\ncos_doubles.h  cos_doubles.py  makefile\n\n\n接着我们能继续通过ctypes库对(某些类型)Numpy数组的直接支持包裹这个库了：\n\n\"\"\" Example of wrapping a C library function that accepts a C double array as\n    input using the numpy.ctypeslib. \"\"\"\n\nimport numpy as np\nimport numpy.ctypeslib as npct\nfrom ctypes import c_int\n\n# input type for the cos_doubles function\n# must be a double array, with single dimension that is contiguous\narray_1d_double = npct.ndpointer(dtype=np.double, ndim=1, flags='CONTIGUOUS')\n\n# load the library, using numpy mechanisms\nlibcd = npct.load_library(\"libcos_doubles\", \".\")\n\n# setup the return typs and argument types\nlibcd.cos_doubles.restype = None\nlibcd.cos_doubles.argtypes = [array_1d_double, array_1d_double, c_int]\n\n\ndef cos_doubles_func(in_array, out_array):\n    return libcd.cos_doubles(in_array, out_array, len(in_array))\n\n\n\n注意连续单维Numpy数组的固有限制，因为C函数要求这种缓冲区。^1^\n注意输出数组必须预先分配，例如通过numpy.zeros()，这个函数将写进它的缓冲区。\n尽管cos_doubles函数的原始参数是ARRAY, ARRAY, int，最终的cos_doubles_func仅仅接受两个Numpy数组作为参数。\n\n像之前一样，我们相信它能够工作：\n\nimport numpy as np\nimport pylab\nimport cos_doubles\n\nx = np.arange(0, 2 * np.pi, 0.1)\ny = np.empty_like(x)\n\ncos_doubles.cos_doubles_func(x, y)\npylab.plot(x, y)\npylab.show()\n\n\n\n\nSWIG\n\nSWIG, 简化包裹接口生成器，是一个将不同高级编程语言包括Python链接到用C和C++写的程序上的软件开发工具。SWIG重要的功能是，它能自动为你生成包裹代码。这就开发时间来说是个优势，也可能是个负担。生成文件趋于巨大，读起来不友好，包裹过程的结果就是多个间接层，可能有点难以理解。\n\n注意：自动生成的C代码使用Python-C-Api。\n\n优势\n\n\n可以自动包裹给定头文件的整个库\n对C++工作很好\n\n劣势\n\n\n自动生成巨大的文件\n若出错难以调试\n陡峭的学习曲线\n\n示例\n\n让我们假设我们的cos函数位于用C写成的cos_module中，源代码文件为cos_module.c。\n\n#include <math.h>\n\ndouble cos_func(double arg){\n    return cos(arg);\n}\n\n\n头文件为cos_module.h：\n\ndouble cos_func(double arg);\n\n\n我们的任务是将cos_func暴露给Python。为了用SWIG实现这个，我们必须写一个包含SWIG指令的接口文件。\n\n/*  Example of wrapping cos function from math.h using SWIG. */\n\n%module cos_module\n%{\n    /* the resulting C file should be built as a python extension */\n    #define SWIG_FILE_WITH_INIT\n    /*  Includes the header in the wrapper code */\n    #include \"cos_module.h\"\n%}\n/*  Parse the header file to generate wrappers */\n%include \"cos_module.h\"\n\n\n如您所见，需要太多代码了。在这个简单的例子中在接口文件中仅仅包含头文件就足够将函数暴露给Python。然而，SWIG允许更细粒度地包含/排除头文件中的函数，查看文档获取更多细节。\n\n产生编译的包裹代码是一个两个阶段的过程：\n\n\n对接口文件运行swig生成文件cos_module_wrap.c，这是用来自动生成Python的C扩展的源代码文件。cos_module.py是自动生成的纯Python模块。\n编译cos_module_wrap.c为_cos_module.so。幸运的是，distutils知道如何处理SWIG接口文件，所以我们的setup.py很简单：\n\nfrom distutils.core import setup, Extension\n\nsetup(ext_modules=[Extension(\"_cos_module\",\n      sources=[\"cos_module.c\", \"cos_module.i\"])])\n\n$ cd advanced/interfacing_with_c/swig\n\n$ ls\ncos_module.c  cos_module.h  cos_module.i  setup.py\n\n$ python setup.py build_ext --inplace\nrunning build_ext\nbuilding '_cos_module' extension\nswigging cos_module.i to cos_module_wrap.c\nswig -python -o cos_module_wrap.c cos_module.i\ncreating build\ncreating build/temp.linux-x86_64-2.7\ngcc -pthread -fno-strict-aliasing -g -O2 -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -fPIC -I/home/esc/anaconda/include/python2.7 -c cos_module.c -o build/temp.linux-x86_64-2.7/cos_module.o\ngcc -pthread -fno-strict-aliasing -g -O2 -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -fPIC -I/home/esc/anaconda/include/python2.7 -c cos_module_wrap.c -o build/temp.linux-x86_64-2.7/cos_module_wrap.o\ngcc -pthread -shared build/temp.linux-x86_64-2.7/cos_module.o build/temp.linux-x86_64-2.7/cos_module_wrap.o -L/home/esc/anaconda/lib -lpython2.7 -o /home/esc/git-working/scipy-lecture-notes/advanced/interfacing_with_c/swig/_cos_module.so\n\n$ ls\nbuild/  cos_module.c  cos_module.h  cos_module.i  cos_module.py  _cos_module.so*  cos_module_wrap.c  setup.py\n\n\n现在我们能加载和执行cos_module，就好像我们之前做的：\n\nIn [1]: import cos_module\n\nIn [2]: cos_module?\nType:       module\nString Form:<module 'cos_module' from 'cos_module.py'>\nFile:       /home/esc/git-working/scipy-lecture-notes/advanced/interfacing_with_c/swig/cos_module.py\nDocstring:  <no docstring>\n\nIn [3]: dir(cos_module)\nOut[3]:\n['__builtins__',\n '__doc__',\n '__file__',\n '__name__',\n '__package__',\n '_cos_module',\n '_newclass',\n '_object',\n '_swig_getattr',\n '_swig_property',\n '_swig_repr',\n '_swig_setattr',\n '_swig_setattr_nondynamic',\n 'cos_func']\n\nIn [4]: cos_module.cos_func(1.0)\nOut[4]: 0.5403023058681398\n\nIn [5]: cos_module.cos_func(0.0)\nOut[5]: 1.0\n\nIn [6]: cos_module.cos_func(3.14159265359)\nOut[6]: -1.0\n\n\n我们再次检验健壮性，看到得到了更好的错误信息(然而，严格地说Python中没有double类型)：\n\nIn [7]: cos_module.cos_func('foo')\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n<ipython-input-7-11bee483665d> in <module>()\n----> 1 cos_module.cos_func('foo')\n\nTypeError: in method 'cos_func', argument 1 of type 'double'\n\n\nNumpy支持\n\nnumpy通过numpy.i文件提供了对SWIG的支持。这个接口文件定义了各种所谓的类型映射(typemaps)来转换Numpy数组和C数组。在下面的例子中我们将简略地看看这种类型映射在实际中如何起作用。\n\n我们使用在ctypes例子中相同的cos_doubles函数：\n\nvoid cos_doubles(double * in_array, double * out_array, int size);\n\n#include <math.h>\n\n/*  Compute the cosine of each element in in_array, storing the result in\n *  out_array. */\nvoid cos_doubles(double * in_array, double * out_array, int size){\n    int i;\n    for(i=0;i<size;i++){\n        out_array[i] = cos(in_array[i]);\n    }\n}\n\n\n使用SWIG接口文件将它包裹为cos_doubles_func：\n\n/*  Example of wrapping a C function that takes a C double array as input using\n *  numpy typemaps for SWIG. */\n\n%module cos_doubles\n%{\n    /* the resulting C file should be built as a python extension */\n    #define SWIG_FILE_WITH_INIT\n    /*  Includes the header in the wrapper code */\n    #include \"cos_doubles.h\"\n%}\n\n/*  include the numpy typemaps */\n%include \"numpy.i\"\n/*  need this for correct module initialization */\n%init %{\n    import_array();\n%}\n\n/*  typemaps for the two arrays, the second will be modified in-place */\n%apply (double* IN_ARRAY1, int DIM1) {(double * in_array, int size_in)}\n%apply (double* INPLACE_ARRAY1, int DIM1) {(double * out_array, int size_out)}\n\n/*  Wrapper for cos_doubles that massages the types */\n%inline %{\n    /*  takes as input two numpy arrays */\n    void cos_doubles_func(double * in_array, int size_in, double * out_array, int size_out) {\n        /*  calls the original funcion, providing only the size of the first */\n        cos_doubles(in_array, out_array, size_in);\n    }\n%}\n\n\n\n为了使用Numpy类型映射，需要numpy.i文件。\n观察import_array()的调用，我们已经在Numpy-C-Api的例子中见到过。\n因为类型映射仅仅支持参数ARRAY, SIZE我们需要包裹cos_doubles为cos_doubles_func，该函数接受两个数组包含各自大小作为输入。\n相对于简单SWIG的例子，我们不需要包含cos_doubles.h头文件，因为我们通过cos_doubles_func暴露这个功能，我们没有其它东西想暴露给Python。\n\n然后，如前述用distutils包裹它：\n\nfrom distutils.core import setup, Extension\nimport numpy\n\nsetup(ext_modules=[Extension(\"_cos_doubles\",\n      sources=[\"cos_doubles.c\", \"cos_doubles.i\"],\n      include_dirs=[numpy.get_include()])])\n\n\n显然，我们需要include_dirs指定位置。\n\n$ ls\ncos_doubles.c  cos_doubles.h  cos_doubles.i  numpy.i  setup.py  test_cos_doubles.py\n$ python setup.py build_ext -i\nrunning build_ext\nbuilding '_cos_doubles' extension\nswigging cos_doubles.i to cos_doubles_wrap.c\nswig -python -o cos_doubles_wrap.c cos_doubles.i\ncos_doubles.i:24: Warning(490): Fragment 'NumPy_Backward_Compatibility' not found.\ncos_doubles.i:24: Warning(490): Fragment 'NumPy_Backward_Compatibility' not found.\ncos_doubles.i:24: Warning(490): Fragment 'NumPy_Backward_Compatibility' not found.\ncreating build\ncreating build/temp.linux-x86_64-2.7\ngcc -pthread -fno-strict-aliasing -g -O2 -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -fPIC -I/home/esc/anaconda/lib/python2.7/site-packages/numpy/core/include -I/home/esc/anaconda/include/python2.7 -c cos_doubles.c -o build/temp.linux-x86_64-2.7/cos_doubles.o\ngcc -pthread -fno-strict-aliasing -g -O2 -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -fPIC -I/home/esc/anaconda/lib/python2.7/site-packages/numpy/core/include -I/home/esc/anaconda/include/python2.7 -c cos_doubles_wrap.c -o build/temp.linux-x86_64-2.7/cos_doubles_wrap.o\nIn file included from /home/esc/anaconda/lib/python2.7/site-packages/numpy/core/include/numpy/ndarraytypes.h:1722,\n                 from /home/esc/anaconda/lib/python2.7/site-packages/numpy/core/include/numpy/ndarrayobject.h:17,\n                 from /home/esc/anaconda/lib/python2.7/site-packages/numpy/core/include/numpy/arrayobject.h:15,\n                 from cos_doubles_wrap.c:2706:\n/home/esc/anaconda/lib/python2.7/site-packages/numpy/core/include/numpy/npy_deprecated_api.h:11:2: warning: #warning \"Using deprecated NumPy API, disable it by #defining NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION\"\ngcc -pthread -shared build/temp.linux-x86_64-2.7/cos_doubles.o build/temp.linux-x86_64-2.7/cos_doubles_wrap.o -L/home/esc/anaconda/lib -lpython2.7 -o /home/esc/git-working/scipy-lecture-notes/advanced/interfacing_with_c/swig_numpy/_cos_doubles.so\n$ ls\nbuild/         cos_doubles.h  cos_doubles.py    cos_doubles_wrap.c  setup.py\ncos_doubles.c  cos_doubles.i  _cos_doubles.so*  numpy.i             test_cos_doubles.py\n\n\n接着，确信它起作用：\n\nimport numpy as np\nimport pylab\nimport cos_doubles\n\nx = np.arange(0, 2 * np.pi, 0.1)\ny = np.empty_like(x)\n\ncos_doubles.cos_doubles_func(x, y)\npylab.plot(x, y)\npylab.show()\n\n\n\n\nCython\n\nCython不仅使用来写C扩展的Python样子的语言，而且是这个语言的一个高级编译器。Cython语言是Python的超集，包含额外的结构允许你调用C函数，将变量和类属性解释为C类型。在这个意义上可以叫它Python的一个类型。\n\n除了这些几本的包裹原生代码的用例，Cython支持一个额外的用例，即交互优化。基本上是，从纯Python代码脚本出发逐步向代码瓶颈增加Cython类型来优化那些真正值得优化的代码。\n\n在这个意义上它和SWIG非常相似，因为C代码可以自动生成，但某种意义上它也相当类似与ctypes，因为它包裹代码可以(几乎可以)用Python写成。\n\n尽管其它自动生成代码方案会很难调试(例如SWIG)，Cython带有一个GNU调试器的扩展，能帮助调试Python，Cython和C代码。\n\n注意：自动生成的C代码使用了Python-C-Api。\n\n优势\n\n\n类Python的语言来写C扩展\n自动生成代码\n支持增量优化\n包含一个GNU调试器扩展\n支持C++(自从0.13版本)\n\n劣势\n\n\n必须编译\n需要额外的库(但仅仅在编译时，这个问题可以通过传递一个生成的C文件克服)\n\n示例\n\n我们cos_module的主要的Cython代码包含在文件cos_module.pyx中：\n\n\"\"\" Example of wrapping cos function from math.h using Cython. \"\"\"\n\ncdef extern from \"math.h\":\n    double cos(double arg)\n\ndef cos_func(arg):\n    return cos(arg)\n\n\n注意额外的关键字像cdef和extern。cos_func紧接着是纯Python。\n\n我们再次使用标准distutils模块，但是这次我们需要一些来自Cython.Distutils额外的片段：\n\nfrom distutils.core import setup, Extension\nfrom Cython.Distutils import build_ext\n\nsetup(\n    cmdclass={'build_ext': build_ext},\n    ext_modules=[Extension(\"cos_module\", [\"cos_module.pyx\"])]\n)\n\n\n编译它：\n\n$ cd advanced/interfacing_with_c/cython\n$ ls\ncos_module.pyx  setup.py\n$ python setup.py build_ext --inplace\nrunning build_ext\ncythoning cos_module.pyx to cos_module.c\nbuilding 'cos_module' extension\ncreating build\ncreating build/temp.linux-x86_64-2.7\ngcc -pthread -fno-strict-aliasing -g -O2 -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -fPIC -I/home/esc/anaconda/include/python2.7 -c cos_module.c -o build/temp.linux-x86_64-2.7/cos_module.o\ngcc -pthread -shared build/temp.linux-x86_64-2.7/cos_module.o -L/home/esc/anaconda/lib -lpython2.7 -o /home/esc/git-working/scipy-lecture-notes/advanced/interfacing_with_c/cython/cos_module.so\n$ ls\nbuild/  cos_module.c  cos_module.pyx  cos_module.so*  setup.py\n\n\n然后运行它：\n\nIn [1]: import cos_module\n\nIn [2]: cos_module?\nType:       module\nString Form:<module 'cos_module' from 'cos_module.so'>\nFile:       /home/esc/git-working/scipy-lecture-notes/advanced/interfacing_with_c/cython/cos_module.so\nDocstring:  <no docstring>\n\nIn [3]: dir(cos_module)\nOut[3]:\n['__builtins__',\n '__doc__',\n '__file__',\n '__name__',\n '__package__',\n '__test__',\n 'cos_func']\n\nIn [4]: cos_module.cos_func(1.0)\nOut[4]: 0.5403023058681398\n\nIn [5]: cos_module.cos_func(0.0)\nOut[5]: 1.0\n\nIn [6]: cos_module.cos_func(3.14159265359)\nOut[6]: -1.0\n\n\n接着，测试健壮性，可以看到我们获得了很棒的错误信息：\n\nIn [7]: cos_module.cos_func('foo')\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n<ipython-input-7-11bee483665d> in <module>()\n----> 1 cos_module.cos_func('foo')\n\n/home/esc/git-working/scipy-lecture-notes/advanced/interfacing_with_c/cython/cos_module.so in cos_module.cos_func (cos_module.c:506)()\n\nTypeError: a float is required\n\n\n另外，值得注意的是Cython带有完整的C数学库声明，将之上代码简化为：\n\n\"\"\" Simpler example of wrapping cos function from math.h using Cython. \"\"\"\n\nfrom libc.math cimport cos\n\ndef cos_func(arg):\n    return cos(arg)\n\n\n在这个例子中cimport声明被用来importcos函数。\n\nNumpy支持\n\nCython通过numpy.pyx文件支持Numpy，这允许你将Numpy数组类型添加到Cython代码。例如将i指定为int类型，将变量a指定为numpy.ndarray并给定dtype。某些优化像边界检查也支持。参看Cython文档的相关章节。万一你想将Numpy数组作为C数组传递给你的Cython包裹的C代码，Cython维基中有一个章节。\n\n在以下例子中，我们将展示如何如何使用Cython包裹熟悉的cos_doubles函数。\n\nvoid cos_doubles(double * in_array, double * out_array, int size);\n\n#include <math.h>\n\n/*  Compute the cosine of each element in in_array, storing the result in\n *  out_array. */\nvoid cos_doubles(double * in_array, double * out_array, int size){\n    int i;\n    for(i=0;i<size;i++){\n        out_array[i] = cos(in_array[i]);\n    }\n}\n\n\n该函数使用以下Cython代码被包裹为cos_doubles_func：\n\n\"\"\" Example of wrapping a C function that takes C double arrays as input using\n    the Numpy declarations from Cython \"\"\"\n\n# import both numpy and the Cython declarations for numpy\nimport numpy as np\ncimport numpy as np\n\n# if you want to use the Numpy-C-API from Cython\n# (not strictly necessary for this example)\nnp.import_array()\n\n# cdefine the signature of our c function\ncdef extern from \"cos_doubles.h\":\n    void cos_doubles (double * in_array, double * out_array, int size)\n\n# create the wrapper code, with numpy type annotations\ndef cos_doubles_func(np.ndarray[double, ndim=1, mode=\"c\"] in_array not None,\n                     np.ndarray[double, ndim=1, mode=\"c\"] out_array not None):\n    cos_doubles(<double*> np.PyArray_DATA(in_array),\n                <double*> np.PyArray_DATA(out_array),\n                in_array.shape[0])\n\n\n可以使用distutils编译：\n\nfrom distutils.core import setup, Extension\nimport numpy\nfrom Cython.Distutils import build_ext\n\nsetup(\n    cmdclass={'build_ext': build_ext},\n    ext_modules=[Extension(\"cos_doubles\",\n                 sources=[\"_cos_doubles.pyx\", \"cos_doubles.c\"],\n                 include_dirs=[numpy.get_include()])],\n)\n\n\n\n如上编译Numpy的例子，我们需要include_dirs选项。\n\n$ ls\ncos_doubles.c  cos_doubles.h  _cos_doubles.pyx  setup.py  test_cos_doubles.py\n$ python setup.py build_ext -i\nrunning build_ext\ncythoning _cos_doubles.pyx to _cos_doubles.c\nbuilding 'cos_doubles' extension\ncreating build\ncreating build/temp.linux-x86_64-2.7\ngcc -pthread -fno-strict-aliasing -g -O2 -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -fPIC -I/home/esc/anaconda/lib/python2.7/site-packages/numpy/core/include -I/home/esc/anaconda/include/python2.7 -c _cos_doubles.c -o build/temp.linux-x86_64-2.7/_cos_doubles.o\nIn file included from /home/esc/anaconda/lib/python2.7/site-packages/numpy/core/include/numpy/ndarraytypes.h:1722,\n                 from /home/esc/anaconda/lib/python2.7/site-packages/numpy/core/include/numpy/ndarrayobject.h:17,\n                 from /home/esc/anaconda/lib/python2.7/site-packages/numpy/core/include/numpy/arrayobject.h:15,\n                 from _cos_doubles.c:253:\n/home/esc/anaconda/lib/python2.7/site-packages/numpy/core/include/numpy/npy_deprecated_api.h:11:2: warning: #warning \"Using deprecated NumPy API, disable it by #defining NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION\"\n/home/esc/anaconda/lib/python2.7/site-packages/numpy/core/include/numpy/__ufunc_api.h:236: warning: ‘_import_umath’ defined but not used\ngcc -pthread -fno-strict-aliasing -g -O2 -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -fPIC -I/home/esc/anaconda/lib/python2.7/site-packages/numpy/core/include -I/home/esc/anaconda/include/python2.7 -c cos_doubles.c -o build/temp.linux-x86_64-2.7/cos_doubles.o\ngcc -pthread -shared build/temp.linux-x86_64-2.7/_cos_doubles.o build/temp.linux-x86_64-2.7/cos_doubles.o -L/home/esc/anaconda/lib -lpython2.7 -o /home/esc/git-working/scipy-lecture-notes/advanced/interfacing_with_c/cython_numpy/cos_doubles.so\n$ ls\nbuild/  _cos_doubles.c  cos_doubles.c  cos_doubles.h  _cos_doubles.pyx  cos_doubles.so*  setup.py  test_cos_doubles.py\n\n\n如前述确保它能起作用：\n\nimport numpy as np\nimport pylab\nimport cos_doubles\n\nx = np.arange(0, 2 * np.pi, 0.1)\ny = np.empty_like(x)\n\ncos_doubles.cos_doubles_func(x, y)\npylab.plot(x, y)\npylab.show()\n\n\n\n\n总结\n\n这个章节中四种不同和本地代码接口技术被呈现在您面前。这个表格简要的总结了这些技术的某些方面。\n\n  x              Part of CPython   Compiled   Autogenerated   Numpy Support\n  -------------- ----------------- ---------- --------------- ---------------\n  Python-C-Api   True              True       False           True\n  Ctypes         True              False      False           True\n  Swig           False             True       True            True\n  Cython         False             True       True            True\n\n\n相比所有技术中，Cython是最现代最高级的了。特别是，通过向Python代码中添加类型增量优化代码的能力是独一无二的。\n\n更多阅读和参考\n\n\n\nGaël Varoquaux的关于避免复制数据的博文对于如何聪明的处理内存管理提供了一些深刻的见解。如果你曾经碰到过大数据集的问题，这是一个可以激发灵感的参考。\n\n练习\n\n因这是一个全新的章节，这些练习更可视为是接下来看什么的指针。所以选择您最感兴趣的那个。如果你对此有更多好的想法，请联系我们！\n\n\n下载每个练习的源码并在你的机器上编译运行。\n对每个例子做小的修改确信它能起作用。(像将cos改成sin)\n\n大多数例子，特别是涉及Numpy的例子可能仍然对错误输入很脆弱、并且返回模糊的消息。寻找使这些例子出问题的方法，指出问题是什么并且设计潜在的解决方案。这有一些提示：\n\n\n数值溢出\n输入输出数组长度不同\n多维数组\n空数组\n非double型数组\n\n\n使用IPython中的magic%timeit来测量不同方案的执行时间。\n\nPython-C-Api\n\n\n更改Numpy的例子让函数接受两个输入参数，第二个参数是预分配的输出数组，让它像其它Numpy例子。\n更改例子让函数仅仅接受一个输入数组并且原地修改。\n尝试使用Numpy迭代协议修正例子，如果你设法获取了一个工作的解决方案，请在github上发布一个拉取请求(pull-request)。\n你也许注意到了，Numpy-C-API例子是唯一不包裹cos_double但是直接将cos应用到Numpy数组的元素的Numpy例子。这相对于其它技术有什么优势？\n你能仅仅使用NJumpy-C-API包裹cos_doubles吗？你可能需要确保数组是正确的类型，并且在内存中一维连续。\n\nCtypes\n\n\n更改像cos_double_func的Numpy例子为你处理预分配，使之更像Numpy-C-Api例子。\n\nSWIG\n\n\n查看SWIG自动生成的代码，你能理解多少？\n更改Numpy的例子像cos_double_func处理预分配，让它更像Numpy-C-API的例子。\n更改C函数cos_doubles让它返回一个分配的数组。你能用SWIG类型映射包裹它？如果不能，为何不行？有没有特定条件的变通方案。(提示：你知道输出数组的大小，所以可能从返回的double *构建一个Numpy数组。)\n\nCython\n\n\n查看Cython自动生成的代码。仔细看看Cython插入的一些注释。你看到了什么？\n查看Cython文档的章节Working with\nNumpy去学习使用Numpy如何增量优化纯python代码。\n更改Numpy例子比如cos_doubles_func处理预分配，使之更像Numpy-C-Api例子。\n\n\n原文 scipy lecture notes: Interfacing with C\n翻译 reverland\nunder GNU Free Documentation License 1.2.\n\n                ", "mainLikeNum": ["5 "], "mainBookmarkNum": "23"}