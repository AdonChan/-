{"title": "Python全栈之路系列之函数 - Python全栈之路 ", "index": "python", "content": "函数\n函数是Python为了代码最大程度的重用和最小化代码冗余而提供的最基本的程序结构。\n\n函数式：将某功能代码封装到函数中，日后便无需重复编写，仅调用函数即可\n面向对象：对函数进行分类和封装，让开发“更快更好更强...”\n\n函数式编程最重要的是增强代码的重用性和可读性\n创建的函数语法\ndef 函数名(参数):\n    ...\n    函数体\n    ...\n    返回值\n简单的实例\n# x为函数的参数\n>>> def num(x):\n...  print(x)\n...\n# 123456等于x\n>>> num(\"123456\")\n123456\n函数的返回值\n函数的返回值需要使用到return这个关键字，返回值主要是用来接受函数的执行结果\n>>> def re():\n...   if 1==1:\n...     return True\n...   else:\n...     return False\n...\n>>> re()\nTrue\n函数return后面是什么值，re就返回什么值，如果没有指定return返回值，那么会返回一个默认的参数None\n在函数中，当return执行完成之后，return后面的代码是不会被执行的\n>>> def ret():\n...  print(\"123\")\n...  return True\n...  print(\"abc\")\n...\n>>> ret()\n123\nTrue\n位置参数\n传入参数的值是按照顺序依次赋值过去的。\n代码\n# x==形式参数，形式参数有几个，那么实际参数就要传几个，默认参数除外\ndef ret(x):\n    print(x)\n# \"Hello Word\"实际参数\nprint(ret(\"Hello Word\"))\n执行结果\nHello Word\n如图所示:\nret小括号内的值会被传入到函数ret里面都能做x的值，结果差不多就是print(\"Hello Word\")\n函数的普通参数实例：发送邮件\ndef email(mail):\n    import smtplib\n    from email.mime.text import MIMEText\n    from email.utils import formataddr\n\n    msg = MIMEText('邮件内容', 'plain', 'utf-8')\n    msg['From'] = formataddr([\"测试\",'asdasd@126.com'])\n    msg['To'] = formataddr([\"走人\",'asdasdasd@163.com'])\n    msg['Subject'] = \"主题\"\n\n    server = smtplib.SMTP(\"smtp.126.com\", 25)\n    server.login(\"wdfgfghfgh@126.com\", \"123456\")\n    server.sendmail('asdasdas@126.com', [mail,], msg.as_string())\n    server.quit()\n\nemail(\"6087414@qq.com\")\n当执行这个脚本的时候会给邮箱6087414@qq.com发送邮件。\n注：上面的邮箱地址等都是随便写的，请自行更改\n指定参数\n>>> def ret(a,b,c):\n...  print(a,\"a\")\n...  print(b,\"b\")\n...  print(c,\"c\")\n...\n>>> ret(b=\"bbb\",a=\"aaa\",c=\"ccc\")\naaa a\nbbb b\nccc c\n默认情况在再函数ret括号内如果要输入函数参数的值，是要按照顺序来的，但是如果在ret括号内制定的参数的值，那么就不需要按照顺序来了。\n默认参数\n如果我们在创建函数的时候给函数定义了值，那么在调用函数的时候如果不填写值程序就会报错：\n>>> def ret(x):\n...  print(x)\n...\n>>> ret()\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: ret() missing 1 required positional argument: 'x'\n如果要解决这个问题就可以给函数的值指定一个默认值，指定函数的默认值需要在def这一行指定，制定之后，当调用这个函数的时候就不需要输入函数值了。\n>>> def ret(x=\"Hello Word\"):\n...  print(x)\n...\n>>> ret()\nHello Word\n# 如果值指定默认值，那么实际参数替换掉形式参数\n>>> ret(\"Pythoner\")\nPythoner\n如果给函数创建了默认值，那么有默认值的这个参数必须在最后面定义，不能够在没有默认参数的值的前面。\n动态参数\n动态参数把接收过来的实际参数当作一个元组，每一个参数都是元组中的一个元素。\n第一种动态参数\n定义第一种动态参数需要在参数前面加上一个*号\n>>> def ret(*args):\n...  print(args,type(args))\n...\n>>> ret(11,22,33)\n(11, 22, 33) <class 'tuple'>\n第二种动态参数\n定义第二种动态参数需要在参数前面加上两个*号，给参数传参的时候是一个key对应一个value的，相当于一个字典的键值对，而且返回的类型就是字典类型。\n使用两个星号可以将参数收集到一个字典中，参数的名字是字典的键，对应参数的值是字典的值。\n>>> def ret(**kwargs):\n...  print(kwargs,type(kwargs))\n...\n>>> ret(k1=123,k2=456)\n{'k1': 123, 'k2': 456} <class 'dict'>\n第三种动态参数\n第三种又称为万能的动态参数，如下实例：\n>>> def ret(*args,**kwargs):\n...  print(args,type(args))\n...  print(kwargs,type(kwargs))\n...\n>>> ret(11,222,333,k1=111,k2=222)\n(11, 222, 333) <class 'tuple'>\n{'k1': 111, 'k2': 222} <class 'dict'>\n字典小例子：\n>>> def arg(**kwargs):\n...  print(kwargs,type(kwargs))\n...\n>>> dic = {\"k1\":123,\"k2\":456}\n>>> arg(k1=dic)\n{'k1': {'k1': 123, 'k2': 456}} <class 'dict'>\n>>> arg(**dic)\n{'k1': 123, 'k2': 456} <class 'dict'>\n避免可变参数的修改\n如果不想在函数内部修改参数值而影响到外部对象的值，我们可以使用切片的方式进行参数的传递：\n#!/use/bin/env python\n\nL = ['a', 'b']\ndef changer(L):\n    L[0] = 0\nprint(L)\nchanger(L)\n\"\"\"\n['a', 'b']\n[0, 'b']\n\"\"\"\n# changer(L[:])\n\"\"\"\n['a', 'b']\n['a', 'b']\n\"\"\"\nprint(L)\n参数解包\nIn [2]: def f(a, b, c, d): print(a, b, c, d)\n\nIn [3]: args = (1, 2)\n\nIn [4]: args += (3, 4)\n\nIn [5]: f(*args)\n1 2 3 4\n又或者使用\ndef f(a, b, c, d): print(a, b, c, d)\nargs = {'a': 1, 'b': 2, 'c': 3, 'd': 4}\nf(**args)\n参数书写位置\n在函数调用中： 位置参数 --》 关键字参数 --》元组形式--》字典形式在函数头部： 一般参数--》默认参数--》元组形式--》字典形式\ndef func(name, age=None, *args, **kwargs):\n    print(name, age, args, kwargs)\n\nfunc('ansheng', 18, *(1, 2, 3), **{'blog': 'blog.ansheng.me'})\n全局变量和局部变量\n简单的理解全局变量和变量，全局变量可以理解为在当前这个文件内定义的变量，局部变量则是在函数内定义的变量，如下例：\n# qa\n# 全局变量\nn1 = 1\ndef num():\n    # 局部变量\n    n2 = 2\n    print(n1)\n    print(n2)\nnum()\n输出的结果\nC:\\Python35\\python.exe F:/Python_code/sublime/Day05/def.py\n1\n2\n定义的全局变量都可以在函数内调用，但是不能再函数内修改，局部变量在也不能够直接调用，如果要在函数内修改全局变量，那么就需要用到关键字``\nn1 = 1\ndef num():\n    n2 = 2\n    global n1\n    n1 = 3\n    print(n1)\n    print(n2)\nnum()\n执行结果\nC:\\Python35\\python.exe F:/Python_code/sublime/Day05/def.py\n3\n2\nnonlocal语句\nnonlocal是用来修改嵌套作用域中的变量，类似于global一样，只需要在嵌套函数中声明变量名即可，但是这个变量名是必须已经存在的否则就会报错，如果要修改的变量在作用域中查找不到，那么不会继续到全局或内置作用域中查找。\nIn [1]: def func1(arg1):\n   ...:     n = arg1\n   ...:     print(n)\n   ...:     def func2():\n   ...:         nonlocal n\n   ...:         n += 1\n   ...:     func2()\n   ...:     print(n)\n   ...:     \n\nIn [2]: func1(10)\n10\n11\nLambda表达式\nLambda（Lambda expressions）表达式是用lambda关键字创建的匿名函数，Lambda函数可以用于任何需要函数对象的地方，在语法上，它们被局限于只能有一个单独的表达式。\n使用Lambda表达式创建函数\n>>> f = lambda x,y : x + y\n>>> f(1,2)\n3\n使用def创建函数\n>>> def f(x,y):\n...  return x + y\n...\n>>> f(1,2)\n3\n对于比较简单的函数我们就可以通过lambda来创建，它的的好处是缩短行数。\nlambda创建的函数和def创建的函数对应关系如图所示：\n\n嵌套lambda和作用域\ndef action(x):\n    return (lambda y: x + y)\n\nact = action(99)\nprint(act)\nresult = act(2)\nprint(result)\n输出为：\n<function action.<locals>.<lambda> at 0x1021e6400>\n101\nlambda也能够获取到任意上层lambda中的变量名：\naction = lambda x: (lambda y: x + y)\nact = action(99)\nprint(act)\nresult = act(3)\nprint(result)\n输出为：\n<function <lambda>.<locals>.<lambda> at 0x1029e6400>\n102\n测试题\n第一题\n简述普通参数、指定参数、默认参数、动态参数的区别\n普通参数即是用户在调用函数是填入的参数，且参数位置必须与参数保持一致。\n指定参数即在用户调用函数的时候不需要按照函数中参数的位置中所填写，指定参数是需要制定参数对应的值。\n默认参数可以写在定义参数的后面，如果用户调用函数是没有制定参数，那么就会用默认参数，如果用户指定了参数，那么用户指定的参数就会代替默认参数。\n动态参数可以接受用户输入的任何参数，包括字典、列表、元组等数据类型。\n第二题\n计算传入字符串中数字、字母、空格以及其他的个数\ndef var(s):\n    all_num = 0\n    spance_num = 0\n    digit_num = 0\n    others_num = 0\n    for i in s:\n        # 检测数字\n        if i.isdigit():\n            digit_num += 1\n        # 检测空格\n        elif i.isspace():\n            spance_num += 1\n        # 检测字母\n        elif i.isalpha():\n            all_num += 1\n        else:\n            # 其他\n            others_num += 1\n    return (\"字母：\",all_num,\"空格：\",spance_num,\"数字\",digit_num,\"其他字符\",others_num)\nnum = var(\"21323 asd*%^*^% &*213asdasdasda sdasdasd\")\nprint(num)\n执行结果\nC:\\Python35\\python.exe F:/Python_code/sublime/operation/Day05/c.py\n('字母：', 21, '空格：', 3, '数字', 8, '其他字符', 8)\n第三题\n写函数，判断用户传入的对象（字符串、列表、元组）长度是否大于5，如果大于5就返回True，如果小于5就返回False\n# 定义一个函数num\ndef num(x):\n    # 判断函数的值如果长度大于5就返回True\n    if len(x) > 5:\n        return True\n    # 否则就返回False\n    else:\n        return False\n\nret = num([\"asd\",\"asdasd\",\"asdasd\",\"asdasd\"])\nprint(ret)\nret = num(\"asdasdasd\")\nprint(ret)\n第四题\n写函数，检查用户传入的对象（字符串、列表、元组）的每一个元素是否含有空内容，如果有空就返回False\n# 定义一个函数num\ndef num(x):\n    # 循环输出num内的所有内容\n    for n in x:\n        # 数据类型转换为字符串\n        n = str(n)\n        # 如果有空格就返回False\n        if n.isspace():\n            return False\n\nret = num(\" \")\nprint(ret)\n\nret = num(\"asdasd\")\nprint(ret)\n\nret = num([\"asd\",\"312\",123,\" \"])\nprint(ret)\n第五题\n写函数，检查传入列表的长度，如果大于2，那么仅保留前两个长度的内容，并将新内容返回给调用者。\ndef num(x):\n    # 如果列表中的长度大于2,那么就输出列表前两个内容，否则就返回一个空\n    if len(x) > 2:\n        return x[:2]\n    else:\n        return \"\"\nprint(num([\"11\",\"22\",\"33\"]))\n\nprint(num([\"33\"]))\n第六题\n写函数，检查获取传入列表或元组对象的所有奇数位索引对应的元素，并将其作为新列表返回给调用者。\ndef num(x):\n    # 定义一个空列表用于接收奇数位的元素\n    resule = []\n    # 循环输出列表中的所有元素值\n    for n in range(len(x)):\n        # 如果列表中的位置为奇数就把值添加到resule列表中\n        if n % 2 == 1:\n            resule.append(x[n])\n    # 然会resule列表中的内容\n    return resule\n\nret = num([11,22,33,44,55,66])\nprint(ret)\n第七题\n写函数，检查传入字典的每一个value的长度,如果大于2，那么仅保留前两个长度的内容，并将新内容返回给调用者。\ndic = {\"k1\": \"v1v1\", \"k2\": [1111,22,33,44]}\nPS:字典中的value只能是字符串或列表\n代码\ndef dictt(x):\n    # 循环字典中所有的key\n    for k in x.keys():\n        # 如果字典中k对应的元素是字符串类型就下面的判断\n        if type(x[k]) == str:\n            # 如果元素的长度大于2\n            if len(x[k]) > 2:\n                # 那么就让这个元素重新赋值，新的值只保留原来值的前两个\n                x[k]=x[k][0:2]\n        # 如果字典中k对应的元素类型是列表，就进入下面的判断\n        elif type(x[k]) == list:\n            # 先把列表中的值全部for循环\n            for i in x[k]:\n                # 把元素转换为字符串\n                string = str(i)\n                # 如果元素的长度大于2\n                if len(string) > 2:\n                    # 获取元素的索引值\n                    num = x[k].index(i)\n                    # 先把这个元素给删除\n                    x[k].pop(x[k].index(i))\n                    # 然后再添加一个新的元素，新元素的只保留原来元素的前两个\n                    x[k].insert(num,string[:2])\n    # 把结果return出来\n    return dic\nret = dictt(dic)\nprint(ret)\n执行结果\nC:\\Python35\\python.exe F:/Python_code/sublime/operation/Day05/h.py\n{'k1': 'v1', 'k2': ['11', 22, 33, 44]}\n\n原文链接\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "2"}