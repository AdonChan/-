{"title": "【generator101】 - yield from - taowen ", "index": "generator,python", "content": "在python 3.3里，generator新增了一个语法 yield from\n这个yield from的作用是什么？看下面两段对比的代码：\n\ndef zero_to_nine():\n    for i in range(10):\n        yield i\n\ndef wrap_generator():\n    for i in zero_to_nine():\n        yield i\n\nprint(list(zero_to_nine()))\nprint(list(wrap_generator()))\n\n\n可以看到一个问题，如果一个函数内部调用了一个generator，它自身如果还希望是以generator的形式返回值的话，就需要用for循环重新yield一次。\n使用yield from可以简化这个委托给子generator的过程\n\ndef zero_to_nine():\n    for i in range(10):\n        yield i\n\ndef wrap_generator():\n    yield from zero_to_nine()\n\nprint(list(zero_to_nine()))\nprint(list(wrap_generator()))\n\n\n如果只是这么一点写法上的区别的话，也就不劳烦BDFL添加新的语法了。我们可以看一下wrap_generator的bytecode\n\n              0 LOAD_GLOBAL              0 (zero_to_nine) \n              3 CALL_FUNCTION            0 (0 positional, 0 keyword pair) \n              6 GET_ITER             \n              7 LOAD_CONST               0 (None) \n             10 YIELD_FROM           \n             11 POP_TOP              \n             12 LOAD_CONST               0 (None) \n             15 RETURN_VALUE         \n\n\n可见YIELD FROM是由cPython内部支持的，其实现原理上就避免了栈进栈出的消耗，直接由最内层的frame返回（yield）值。\n另外YIELD FROM可以实现外部直接向最内层的generator传递值，比如\n\ndef i_yield_whatever_input_is():\n    input = None\n    while True:\n        input = yield input\n\ndef wrap_generator():\n    yield from i_yield_whatever_input_is()\n\ngen = wrap_generator()\nprint(gen.send(None))\nprint(gen.send(1))\nprint(gen.send(2))\nprint(gen.send(3))\n\n\n这段代码的输出是\n\nNone\n1\n2\n3\n\n\n这样send传值的方式，在用for循环重新yield的模式下是无法实现的。这也就是tulip必须使用yield from，而不能使用yield的原因。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "2"}