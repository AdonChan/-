{"title": "PyTips 0x16 -  Python 迭代器工具 - PyTips ", "index": "pytips,python3.5,python", "content": "项目地址：https://git.io/pytips\n0x01 介绍了迭代器的概念，即定义了 __iter__() 和 __next__() 方法的对象，或者通过 yield 简化定义的“可迭代对象”，而在一些函数式编程语言（见 0x02 Python 中的函数式编程）中，类似的迭代器常被用于产生特定格式的列表（或序列），这时的迭代器更像是一种数据结构而非函数（当然在一些函数式编程语言中，这两者并无本质差异）。Python 借鉴了 APL, Haskell, and SML 中的某些迭代器的构造方法，并在 itertools 中实现（该模块是通过 C 实现，源代码：/Modules/itertoolsmodule.c）。\nitertools 模块提供了如下三类迭代器构建工具：\n\n无限迭代\n整合两序列迭代\n组合生成器\n\n1. 无限迭代\n所谓无限（infinite）是指如果你通过 for...in... 的语法对其进行迭代，将陷入无限循环，包括：\n\ncount(start, [step])\ncycle(p)\nrepeat(elem [,n])\n\n从名字大概可以猜出它们的用法，既然说是无限迭代，我们自然不会想要将其所有元素依次迭代取出，而通常是结合 map/zip 等方法，将其作为一个取之不尽的数据仓库，与有限长度的可迭代对象进行组合操作：\nfrom itertools import cycle, count, repeat\nprint(count.__doc__)\ncount(start=0, step=1) --> count object\n\nReturn a count object whose .__next__() method returns consecutive values.\nEquivalent to:\n\n    def count(firstval=0, step=1):\n        x = firstval\n        while 1:\n            yield x\n            x += step\n\n\ncounter = count()\nprint(next(counter))\nprint(next(counter))\nprint(list(map(lambda x, y: x+y, range(10), counter)))\n\nodd_counter = map(lambda x: 'Odd#{}'.format(x), count(1, 2))\nprint(next(odd_counter))\nprint(next(odd_counter))\n0\n1\n[2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\nOdd#1\nOdd#3\n\nprint(cycle.__doc__)\ncycle(iterable) --> cycle object\n\nReturn elements from the iterable until it is exhausted.\nThen repeat the sequence indefinitely.\n\ncyc = cycle(range(5))\nprint(list(zip(range(6), cyc)))\nprint(next(cyc))\nprint(next(cyc))\n[(0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 0)]\n1\n2\n\nprint(repeat.__doc__)\nrepeat(object [,times]) -> create an iterator which returns the object\nfor the specified number of times.  If not specified, returns the object\nendlessly.\n\nprint(list(repeat('Py', 3)))\nrep = repeat('p')\nprint(list(zip(rep, 'y'*3)))\n['Py', 'Py', 'Py']\n[('p', 'y'), ('p', 'y'), ('p', 'y')]\n\n2. 整合两序列迭代\n所谓整合两序列，是指以两个有限序列为输入，将其整合操作之后返回为一个迭代器，最为常见的 zip 函数就属于这一类别，只不过 zip 是内置函数。这一类别完整的方法包括：\n\naccumulate()\nchain()/chain.from_iterable()\ncompress()\ndropwhile()/filterfalse()/takewhile()\ngroupby()\nislice()\nstarmap()\ntee()\nzip_longest()\n\n这里就不对所有的方法一一举例说明了，如果想要知道某个方法的用法，基本通过 print(method.__doc__) 就可以了解，毕竟 itertools 模块只是提供了一种快捷方式，并没有隐含什么深奥的算法。这里只对下面几个我觉得比较有趣的方法进行举例说明。\nfrom itertools import cycle, compress, islice, takewhile, count\n\n# 这三个方法（如果使用恰当）可以限定无限迭代\n# print(compress.__doc__)\nprint(list(compress(cycle('PY'), [1, 0, 1, 0])))\n\n# 像操作列表 l[start:stop:step] 一样操作其它序列\n# print(islice.__doc__)\nprint(list(islice(cycle('PY'), 0, 2)))\n\n# 限制版的 filter\n# print(takewhile.__doc__)\nprint(list(takewhile(lambda x: x < 5, count())))\n['P', 'P']\n['P', 'Y']\n[0, 1, 2, 3, 4]\n\nfrom itertools import groupby\nfrom operator import itemgetter\nprint(groupby.__doc__)\n\nfor k, g in groupby('AABBC'):\n    print(k, list(g))\ndb = [dict(name='python', script=True),\n      dict(name='c', script=False),\n      dict(name='c++', script=False),\n      dict(name='ruby', script=True)]\nkeyfunc = itemgetter('script')\n\ndb2 = sorted(db, key=keyfunc) # sorted by `script'\nfor isScript, langs in groupby(db2, keyfunc):\n    print(', '.join(map(itemgetter('name'), langs)))\ngroupby(iterable[, keyfunc]) -> create an iterator which returns\n(key, sub-iterator) grouped by each value of key(value).\n\nA ['A', 'A']\nB ['B', 'B']\nC ['C']\nc, c++\npython, ruby\n\nfrom itertools import zip_longest\n\n# 内置函数 zip 以较短序列为基准进行合并，\n# zip_longest 则以最长序列为基准，并提供补足参数 fillvalue\n# Python 2.7 中名为 izip_longest\n\nprint(list(zip_longest('ABCD', '123', fillvalue=0)))\n[('A', '1'), ('B', '2'), ('C', '3'), ('D', 0)]\n\n3. 组合生成器\n关于生成器的排列组合：\n\nproduct(*iterables, repeat=1)：两输入序列的笛卡尔乘积\npermutations(iterable, r=None)：对输入序列的完全排列组合\ncombinations(iterable, r)：有序版的排列组合\ncombinations_with_replacement(iterable, r)：有序版的笛卡尔乘积\n\nfrom itertools import product, permutations, combinations, combinations_with_replacement\nprint(list(product(range(2), range(2))))\nprint(list(product('AB', repeat=2)))\n[(0, 0), (0, 1), (1, 0), (1, 1)]\n[('A', 'A'), ('A', 'B'), ('B', 'A'), ('B', 'B')]\n\nprint(list(combinations_with_replacement('AB', 2)))\n[('A', 'A'), ('A', 'B'), ('B', 'B')]\n\n# 赛马问题：4匹马前2名的排列组合（A^4_2）\nprint(list(permutations('ABCDE', 2)))\n[('A', 'B'), ('A', 'C'), ('A', 'D'), ('A', 'E'), ('B', 'A'), ('B', 'C'), ('B', 'D'), ('B', 'E'), ('C', 'A'), ('C', 'B'), ('C', 'D'), ('C', 'E'), ('D', 'A'), ('D', 'B'), ('D', 'C'), ('D', 'E'), ('E', 'A'), ('E', 'B'), ('E', 'C'), ('E', 'D')]\n\n# 彩球问题：4种颜色的球任意抽出2个的颜色组合（C^4_2）\nprint(list(combinations('ABCD', 2)))\n[('A', 'B'), ('A', 'C'), ('A', 'D'), ('B', 'C'), ('B', 'D'), ('C', 'D')]\n\n总结\n迭代器工具在产生数据的时候将会显得非常便捷、高效，掌握了这些基本的方法之后，通过简单的组合就可以获得更多迭代器工具。\n\n欢迎关注公众号 PyHub 每日推送\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "2"}