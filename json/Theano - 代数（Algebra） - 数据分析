{"title": "Theano - 代数（Algebra） - 数据分析 ", "index": "python3.x,python", "content": "两个标量的加法\n为了让我们开始使用Theano，以及感受theano是如何工作的。接下来，我们构造一个简单的函数：加法。\n　两个标量的加法\nimport numpy\nimport theano.tensor as T\nimport theano\nfrom theano import function\n\n# 定义两个符号（变量）x, y来表示你想实施加法的数。\n# 换句话说， x,y,z均为变量对象。\n# 在Theano中，所有的符号必须定义类型。\n# T.dscalar: 表示双精度（doubles)的0维数组（标量），他是Theano中的类型(Type)\nx = T.dscalar('x')\ny = T.dscalar('y')\nz = x + y\n# dscalar不是一个类(class)。因此，事实上x,y都不是dscalr的实例。\n# 它们是TensorVariable的实例。\n# 然而，x,y被赋值为theano的dscalar类型。\ntype(x)  # theano.tensor.var.TensorVariable\nx.type  # TensorType(float64, scalar)\nT.dscalar   # TensorType(float64, scalar)\nx.type is T.dscalar # True\n\n# 在你运行f时，你会注意到有些延迟\n# 因为f正在被编译为C代码\nf = function([x, y], z)\nf(2, 3)\nnumpy.allclose(f(16.3, 12.1), 28.4)\nnumpy.allcolse(z.eval({x: 16.3, y: 12.1}), 28.4)\n两个矩阵的加法\nx = T.dmatrix('x')\ny = T.dmatrix('y')\nz = x + y\nf = function([x, y], z)\nf([[1, 2], [3, 4]], [[10, 20], [30, 40]])\n可以用到的类型(type)：\n\nbyte: bscalar, bvector, bmatrix, brow, bcol, btensor3, btensor4, btensro5\n16-bit intergers: wscalar, wvector, wmatrix, wrow, wcol, wtensor3, wtensor4, wtensor5\n32-bit intergers: iscalar, ivector, imatrix, irow, icol, itensor3, itensor4, itensor5\n64-bit intergers: lscalar, lvector, lmatrix, lrow, lcol, ltensor3, ltensor4, ltensor5\nfloat: fscalar, fvector, fmatrix, frow, fcol, ftensor3, ftensor4, ftensor5\ndouble: dscalar, dvector, dmatrix, drow, dcol, dtensor3, dtensor4, dtensor5\ncomplex: cscalar, cvector, cmatrix, crow, ccol, ctensor3, ctensor4, ctensor5\n\n练习\na = theano.tensor.vector()  # 声明一个变量\nout = a + a ** 10   # 构造一个符号表达式\nf = theano.function([a], out)   # 编译一个函数\nprint(f([0, 1, 2]))\n修正并执行上面的代码，使得其能够计算：a ^ 2 + b ^ 2 + 2ab\na = theano.tensor.vector()\nb = theano.tensor.vector()\nout1 = a ** 2 + b ** 2 + 2 * a * b\nout2 = (a + b) ** 2\nf1 = theano.function([a, b], out1)\nf2 = theano.function([a, b], out2)\nprint(f1([0, 1], [1, 2]))\nprint(f2([0, 1], [1, 2]))\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}