{"title": "浅析 Python 的类、继承和多态 - 止于至善 ", "index": "c++,python", "content": "类的定义\n假如要定义一个类 Point，表示二维的坐标点：\n# point.py\nclass Point:\n    def __init__(self, x=0, y=0):\n        self.x, self.y = x, y\n最最基本的就是 __init__ 方法，相当于 C++ / Java 的构造函数。带双下划线 __ 的方法都是特殊方法，除了 __init__ 还有很多，后面会有介绍。\n参数 self 相当于 C++ 的 this，表示当前实例，所有方法都有这个参数，但是调用时并不需要指定。\n>>> from point import *\n>>> p = Point(10, 10)  # __init__ 被调用\n>>> type(p)\n<class 'point.Point'>\n>>> p.x, p.y\n(10, 10)\n几乎所有的特殊方法（包括 __init__）都是隐式调用的（不直接调用）。\n对一切皆对象的 Python 来说，类自己当然也是对象：\n>>> type(Point)\n<class 'type'>\n>>> dir(Point)\n['__class__', '__delattr__', '__dict__', ..., '__init__', ...]\n>>> Point.__class__\n<class 'type'>\nPoint 是 type 的一个实例，这和 p 是 Point 的一个实例是一回事。\n现添加方法 set：\nclass Point:\n    ...\n    def set(self, x, y):\n        self.x, self.y = x, y\n>>> p = Point(10, 10)\n>>> p.set(0, 0)\n>>> p.x, p.y\n(0, 0)\np.set(...) 其实只是一个语法糖，你也可以写成 Point.set(p, ...)，这样就能明显看出 p 就是 self 参数了：\n>>> Point.set(p, 0, 0)\n>>> p.x, p.y\n(0, 0)\n值得注意的是，self 并不是关键字，甚至可以用其它名字替代，比如 this：\nclass Point:\n    ...\n    def set(this, x, y):\n        this.x, this.y = x, y\n与 C++ 不同的是，“成员变量”必须要加 self. 前缀，否则就变成类的属性（相当于 C++ 静态成员），而不是对象的属性了。\n访问控制\nPython 没有 public / protected / private 这样的访问控制，如果你非要表示“私有”，习惯是加双下划线前缀。\nclass Point:\n    def __init__(self, x=0, y=0):\n        self.__x, self.__y = x, y\n\n    def set(self, x, y):\n        self.__x, self.__y = x, y\n\n    def __f(self):\n        pass\n__x、__y 和 __f 就相当于私有了：\n>>> p = Point(10, 10)\n>>> p.__x\n...\nAttributeError: 'Point' object has no attribute '__x'\n>>> p.__f()\n...\nAttributeError: 'Point' object has no attribute '__f'\n__repr__\n尝试打印 Point 实例：\n>>> p = Point(10, 10)\n>>> p\n<point.Point object at 0x000000000272AA20>\n通常，这并不是我们想要的输出，我们想要的是：\n>>> p\nPoint(10, 10)\n添加特殊方法 __repr__ 即可实现：\nclass Point:\n    def __repr__(self):\n        return 'Point({}, {})'.format(self.__x, self.__y)\n不难看出，交互模式在打印 p 时其实是调用了 repr(p)：\n>>> repr(p)\n'Point(10, 10)'\n__str__\n如果没有提供 __str__，str() 缺省使用 repr() 的结果。这两者都是对象的字符串形式的表示，但还是有点差别的。简单来说，repr() 的结果面向的是解释器，通常都是合法的 Python 代码，比如 Point(10, 10)；而 str() 的结果面向用户，更简洁，比如 (10, 10)。\n按照这个原则，我们为 Point 提供 __str__ 的定义如下：\nclass Point:\n    def __str__(self):\n        return '({}, {})'.format(self.__x, self.__y)\n__add__\n两个坐标点相加是个很合理的需求。\n>>> p1 = Point(10, 10)\n>>> p2 = Point(10, 10)\n>>> p3 = p1 + p2\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: unsupported operand type(s) for +: 'Point' and 'Point'\n添加特殊方法 __add__ 即可做到：\nclass Point:\n    def __add__(self, other):\n        return Point(self.__x + other.__x, self.__y + other.__y)\n>>> p3 = p1 + p2\n>>> p3\nPoint(20, 20)\n这就像 C++ 里的操作符重载一样。Python 的内建类型，比如字符串、列表，都“重载”了 + 操作符。\n特殊方法还有很多，这里就不逐一介绍了。\n继承\n举一个教科书中最常见的例子。Circle 和 Rectangle 继承自 Shape，不同的图形，面积（area）计算方式不同。\n# shape.py\n\nclass Shape:\n    def area(self):\n        return 0.0\n        \nclass Circle(Shape):\n    def __init__(self, r=0.0):\n        self.r = r\n\n    def area(self):\n        return math.pi * self.r * self.r\n\nclass Rectangle(Shape):\n    def __init__(self, a, b):\n        self.a, self.b = a, b\n\n    def area(self):\n        return self.a * self.b\n用法比较直接：\n>>> from shape import *\n>>> circle = Circle(3.0)\n>>> circle.area()\n28.274333882308138\n>>> rectangle = Rectangle(2.0, 3.0)\n>>> rectangle.area()\n6.0\n如果 Circle 没有定义自己的 area：\nclass Circle(Shape):\n    pass\n那么它将继承父类 Shape 的 area：\n>>> Shape.area is Circle.area\nTrue\n一旦 Circle 定义了自己的 area，从 Shape 继承而来的那个 area 就被重写（overwrite）了：\n>>> from shape import *\n>>> Shape.area is Circle.area\nFalse\n通过类的字典更能明显地看清这一点：\n>>> Shape.__dict__['area']\n<function Shape.area at 0x0000000001FDB9D8>\n>>> Circle.__dict__['area']\n<function Circle.area at 0x0000000001FDBB70>\n所以，子类重写父类的方法，其实只是把相同的属性名绑定到了不同的函数对象。可见 Python 是没有覆写（override）的概念的。\n同理，即使 Shape 没有定义 area 也是可以的，Shape 作为“接口”，并不能得到语法的保证。\n甚至可以动态的添加方法：\nclass Circle(Shape):\n    ...\n    #  def area(self):\n        #  return math.pi * self.r * self.r\n\n# 为 Circle 添加 area 方法。\nCircle.area = lambda self: math.pi * self.r * self.r\n动态语言一般都是这么灵活，Python 也不例外。\nPython 官方教程「9. Classes」第一句就是：\nCompared with other programming languages, Python’s class mechanism adds classes with a minimum of new syntax and semantics.\nPython 以最少的新的语法和语义实现了类机制，这一点确实让人惊叹，但是也让 C++ / Java 程序员感到颇为不适。\n多态\n如前所述，Python 没有覆写（override）的概念。严格来讲，Python 并不支持「多态」。\n为了解决继承结构中接口和实现的问题，或者说为了更好的用 Python 面向接口编程（设计模式所提倡的），我们需要人为的设一些规范。\n请考虑 Shape.area() 除了简单的返回 0.0，有没有更好的实现？\n以内建模块 asyncio 为例，AbstractEventLoop 原则上是一个接口，类似于 Java 中的接口或 C++ 中的纯虚类，但是 Python 并没有语法去保证这一点，为了尽量体现 AbstractEventLoop 是一个接口，首先在名字上标志它是抽象的（Abstract），然后让每个方法都抛出异常 NotImplementedError。\nclass AbstractEventLoop:\n    def run_forever(self):\n        raise NotImplementedError\n    ...\n纵然如此，你是无法禁止用户实例化 AbstractEventLoop 的：\nloop = asyncio.AbstractEventLoop()\ntry:\n    loop.run_forever()\nexcept NotImplementedError:\n    pass\nC++ 可以通过纯虚函数或设构造函数为 protected 来避免接口被实例化，Java 就更不用说了，接口就是接口，有完整的语法支持。\n你也无法强制子类必须实现“接口”中定义的每一个方法，C++ 的纯虚函数可以强制这一点（Java 更不必说）。\n就算子类「自以为」实现了“接口”中的方法，也不能保证方法的名字没有写错，C++ 的 override 关键字可以保证这一点（Java 更不必说）。\n静态类型的缺失，让 Python 很难实现 C++ / Java 那样严格的多态检查机制。所以面向接口的编程，对 Python 来说，更多的要依靠程序员的素养。\n回到 Shape 的例子，仿照 asyncio，我们把“接口”改成这样：\nclass AbstractShape:\n    def area(self):\n        raise NotImplementedError\n这样，它才更像一个接口。\nsuper\n有时候，需要在子类中调用父类的方法。\n比如图形都有颜色这个属性，所以不妨加一个参数 color 到 __init__：\nclass AbstractShape:\n    def __init__(self, color):\n        self.color = color\n那么子类的 __init__() 势必也要跟着改动：\nclass Circle(AbstractShape):\n    def __init__(self, color, r=0.0):\n        super().__init__(color)\n        self.r = r\n通过 super 把 color 传给父类的 __init__()。其实不用 super 也行：\nclass Circle(AbstractShape):\n    def __init__(self, color, r=0.0):\n        AbstractShape.__init__(self, color)\n        self.r = r\n但是 super 是推荐的做法，因为它避免了硬编码，也能处理多继承的情况。\n\n                ", "mainLikeNum": ["5 "], "mainBookmarkNum": "13"}