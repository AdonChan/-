{"title": "通过demo学习OpenStack开发所需的基础知识 -- API服务(3) - Coffee, Coke and Code ", "index": "python,openstack", "content": "上一篇文章我们了解了一个巨啰嗦的框架：Paste + PasteDeploy + Routes + WebOb。后来OpenStack社区的人受不了这么啰嗦的代码了，决定换一个框架，他们最终选中了Pecan。Pecan框架相比上一篇文章的啰嗦框架有如下好处：\n\n不用自己写WSGI application了\n请求路由很容易就可以实现了\n\n总的来说，用上Pecan框架以后，很多重复的代码不用写了，开发人员可以专注于业务，也就是实现每个API的功能。\nPecan\nPecan框架的目标是实现一个采用对象分发方式进行URL路由的轻量级Web框架。它非常专注于自己的目标，它的大部分功能都和URL路由以及请求和响应的处理相关，而不去实现模板、安全以及数据库层，这些东西都可以通过其他的库来实现。关于Pecan的更多信息，可以查看文档：https://pecan.readthedocs.org/en/latest/index.html。本文以OpenStack的magnum项目为例来说明Pecan项目在实际中的应用，但是本文不会详细讲解Pecan的各个方面，一些细节请读者阅读Pecan的文档。\n项目中的代码结构\n使用Pecan框架时，OpenStack项目一般会把API服务的实现都放在一个api目录下，比如magnum项目是这样的：\n➜ ~/openstack/env/p/magnum git:(master) $ tree magnum/api\nmagnum/api\n├── app.py\n├── auth.py\n├── config.py\n├── controllers\n│   ├── base.py\n│   ├── __init__.py\n│   ├── link.py\n│   ├── root.py\n│   └── v1\n│       ├── base.py\n│       ├── baymodel.py\n│       ├── bay.py\n│       ├── certificate.py\n│       ├── collection.py\n│       ├── container.py\n│       ├── __init__.py\n│       ├── magnum_services.py\n│       ├── node.py\n│       ├── pod.py\n│       ├── replicationcontroller.py\n│       ├── service.py\n│       ├── types.py\n│       ├── utils.py\n│       └── x509keypair.py\n├── expose.py\n├── hooks.py\n├── __init__.py\n├── middleware\n│   ├── auth_token.py\n│   ├── __init__.py\n│   └── parsable_error.py\n├── servicegroup.py\n└── validation.py\n你也可以在Ceilometer项目中看到类似的结构。介绍一下几个主要的文件，这样你以后看到一个使用Pecan的OpenStack项目时就会比较容易找到入口。\n\napp.py  一般包含了Pecan应用的入口，包含应用初始化代码\nconfig.py  包含Pecan的应用配置，会被app.py使用\ncontrollers/  这个目录会包含所有的控制器，也就是API具体逻辑的地方\ncontrollers/root.py  这个包含根路径对应的控制器\ncontrollers/v1/   这个目录对应v1版本的API的控制器。如果有多个版本的API，你一般能看到v2等目录。\n\n代码变少了：application的配置\nPecan的配置很容易，通过一个Python源码式的配置文件就可以完成基本的配置。这个配置的主要目的是指定应用程序的root，然后用于生成WSGI application。我们来看Magnum项目的例子。Magnum项目有个API服务是用Pecan实现的，在magnum/api/config.py文件中可以找到这个文件，主要内容如下：\napp = {\n    'root': 'magnum.api.controllers.root.RootController',\n    'modules': ['magnum.api'],\n    'debug': False,\n    'hooks': [\n        hooks.ContextHook(),\n        hooks.RPCHook(),\n        hooks.NoExceptionTracebackHook(),\n    ],\n    'acl_public_routes': [\n        '/'\n    ],\n}\n上面这个app对象就是Pecan的配置，每个Pecan应用都需要有这么一个名为app的配置。app配置中最主要的就是root的值，这个值表示了应用程序的入口，也就是从哪个地方开始解析HTTP的根path：/。hooks对应的配置是一些Pecan的hook，作用类似于WSGI Middleware。\n有了app配置后，就可以让Pecan生成一个WSGI application。在Magnum项目中，magnum/api/app.py文件就是生成WSGI application的地方，我们来看一下这个的主要内容：\ndef get_pecan_config():\n    # Set up the pecan configuration\n    filename = api_config.__file__.replace('.pyc', '.py')\n    return pecan.configuration.conf_from_file(filename)\n\n\ndef setup_app(config=None):\n    if not config:\n        config = get_pecan_config()\n\n    app_conf = dict(config.app)\n\n    app = pecan.make_app(\n        app_conf.pop('root'),\n        logging=getattr(config, 'logging', {}),\n        wrap_app=middleware.ParsableErrorMiddleware,\n        **app_conf\n    )\n\n    return auth.install(app, CONF, config.app.acl_public_routes)\nget_pecan_config()方法读取我们上面提到的config.py文件，然后返回一个pecan.configuration.Config对象。setup_app()函数首先调用get_pecan_config()函数获取application的配置，然后调用pecan.make_app()函数创建了一个WSGI application，最后调用了 auth.install()函数（也就是magnum.api.auth.install()函数）为刚刚生成的WSGI application加上Keystone的认证中间件（确保所有的请求都会通过Keystone认证）。\n到这边为止，一个Pecan的WSGI application就已经准备好了，只要调用这个setup_app()函数就能获得。至于如何部署这个WSGI application，请参考WSGI简介这篇文章。\n从Magnum这个实际的例子可以看出，使用了Pecan之后，我们不再需要自己写那些冗余的WSGI application代码了，直接调用Pecan的make_app()函数就能完成这些工作。另外，对于之前使用PasteDeploy时用到的很多WSGI中间件，可以选择使用Pecan的hooks机制来实现，也选择使用WSGI中间件的方式来实现。在Magnum的API服务就同时使用了这两种方式。其实，Pecan还可以和PasteDeploy一起使用，Ceilometer项目就是这么做的，大家可以看看。\n确定路由变得容易了：对象分发式的路由\nPecan不仅缩减了生成WSGI application的代码，而且也让开发人员更容易的指定一个application的路由。Pecan采用了一种对象分发风格（object-dispatch style）的路由模式。我们直接通过例子来解释这种路由模式，还是以Magnum项目为例。\n上面提到了，Magnum的API服务的root是magnum.api.controllers.root.RootController。这里的RootController的是一个类，我们来看它的代码：\nclass RootController(rest.RestController):\n\n    _versions = ['v1']\n    \"\"\"All supported API versions\"\"\"\n\n    _default_version = 'v1'\n    \"\"\"The default API version\"\"\"\n\n    v1 = v1.Controller()\n\n    @expose.expose(Root)\n    def get(self):\n        # NOTE: The reason why convert() it's being called for every\n        #       request is because we need to get the host url from\n        #       the request object to make the links.\n        return Root.convert()\n\n    @pecan.expose()\n    def _route(self, args):\n        \"\"\"Overrides the default routing behavior.\n\n        It redirects the request to the default version of the magnum API\n        if the version number is not specified in the url.\n        \"\"\"\n\n        if args[0] and args[0] not in self._versions:\n            args = [self._default_version] + args\n        return super(RootController, self)._route(args)\n别看这个类这么长，我来解释一下你就懂了。首先，你可以先忽略掉_route()函数，这个函数是用来覆盖Pecan的默认路由实现的，在这里去掉它不妨碍我们理解Pecan（这里的_route()函数的作用把所有请求重定向到默认的API版本去）。去掉_route()和其他的东西后，整个类就变成这么短：\nclass RootController(rest.RestController):\n    v1 = v1.Controller()\n\n    @expose.expose(Root)\n    def get(self):\n        return Root.convert()\n\n首先，你要记住，这个RootController对应的是URL中根路径，也就是path中最左边的/。\nRootController继承自rest.RestController，是Pecan实现的RESTful控制器。这里的get()函数表示，当访问的是GET /时，由该函数处理。get()函数会返回一个WSME对象，表示一个形式化的HTTP Response，这个下面再讲。get()函数上面的expose装饰器是Pecan实现路由控制的一个方式，被expose的函数才会被路由处理。\n这里的v1 = v1.Controller()表示，当访问的是GET /v1或者GET /v1/...时，请求由一个v1.Controller实例来处理。\n\n为了加深大家的理解，我们再来看下v1.Controller的实现：\nclass Controller(rest.RestController):\n    \"\"\"Version 1 API controller root.\"\"\"\n\n    bays = bay.BaysController()\n    baymodels = baymodel.BayModelsController()\n    containers = container.ContainersController()\n    nodes = node.NodesController()\n    pods = pod.PodsController()\n    rcs = rc.ReplicationControllersController()\n    services = service.ServicesController()\n    x509keypairs = x509keypair.X509KeyPairController()\n    certificates = certificate.CertificateController()\n\n    @expose.expose(V1)\n    def get(self):\n        return V1.convert()\n\n    ...\n上面这个Controller也是继承自rest.RestController。所以它的get函数表示，当访问的是GET /v1的时候，要做的处理。然后，它还有很多类属性，这些属性分别表示不同URL路径的控制器：\n\n/v1/bays 由bays处理\n/v1/baymodels 由baymodels处理\n/v1/containers 由containers处理\n\n其他的都是类似的。我们再继续看bay.BaysController的代码：\nclass BaysController(rest.RestController):\n    \"\"\"REST controller for Bays.\"\"\"\n    def __init__(self):\n        super(BaysController, self).__init__()\n\n    _custom_actions = {\n        'detail': ['GET'],\n    }\n\n    def get_all(...):\n    \n    def detail(...):\n    \n    def get_one(...):\n    \n    def post(...):\n    \n    def patch(...):\n\n    def delete(...):\n这个controller中只有函数，没有任何类属性，而且没有实现任何特殊方法，所以/v1/bays开头的URL处理都在这个controller中终结。这个类会处理如下请求：\n\nGET /v1/bays\nGET /v1/bays/{UUID}\nPOST /v1/bays\nPATCH /v1/bays/{UUID}\nDELETE /v1/bays/{UUID}\nGET /v1/bays/detail/{UUID}\n\n看了上面的3个controller之后，你应该能大概明白Pecan是如何对URL进行路由的。这种路由方式就是对象分发：根据类属性，包括数据属性和方法属性来决定如何路由一个HTTP请求。Pecan的文档中对请求的路由有专门的描述，要想掌握Pecan的路由还是要完整的看一下官方文档。\n内置RESTful支持\n我们上面举例的controller都是继承自pecan.rest.RestController，这种controller称为RESTful controller，专门用于实现RESTful API的，因此在OpenStack中使用特别多。Pecan还支持普通的controller，称为Generic controller。Generic controller继承自object对象，默认没有实现对RESTful请求的方法。简单的说，RESTful controller帮我们规定好了get_one(), get_all(), get(), post()等方法对应的HTTP请求，而Generic controller则没有。关于这两种controller的区别，可以看官方文档Writing RESTful Web Services with Generic Controllers，有很清楚的示例。\n对于RestController中没有预先定义好的方法，我们可以通过控制器的_custom_actions属性来指定其能处理的方法。\nclass RootController(rest.RestController):\n    _custom_actions = {\n        'test': ['GET'],\n    }\n\n    @expose()\n    def test(self):\n        return 'hello'\n上面这个控制器是一个根控制器，指定了/test路径支持GET方法，效果如下：\n $ curl http://localhost:8080/test\nhello% \n那么HTTP请求和HTTP响应呢？\n上面讲了这么多，我们都没有说明在Pecan中如何处理请求和如何返回响应。这个将在下一章中说明，同时我们会引入一个新的库WSME。\nWSME\nPecan对请求和响应的处理\n在开始提到WSME之前，我们先来看下Pecan自己对HTTP请求和响应的处理。这样你能更好的理解为什么会再引入一个WSME库。\nPecan框架为每个线程维护了单独的请求和响应对象，你可以直接在请求处理函数中访问。pecan.request和pecan.response分别代表当前需要处理的请求和响应对象。你可以直接操作这两个对象，比如指定响应的状态码，就像下面这个例子一样（例子来自官方文档）：\n@pecan.expose()\ndef login(self):\n    assert pecan.request.path == '/login'\n    username = pecan.request.POST.get('username')\n    password = pecan.request.POST.get('password')\n\n    pecan.response.status = 403\n    pecan.response.text = 'Bad Login!'\n这个例子演示了访问POST请求的参数以及返回403。你也可以重新构造一个pecan.Response对象作为返回值（例子来自官方文档）：\nfrom pecan import expose, Response\n\nclass RootController(object):\n\n    @expose()\n    def hello(self):\n        return Response('Hello, World!', 202)\n另外，HTTP请求的参数也会可以作为控制器方法的参数，还是来看几个官方文档的例子：\nclass RootController(object):\n    @expose()\n    def index(self, arg):\n        return arg\n\n    @expose()\n    def kwargs(self, **kwargs):\n        return str(kwargs)\n这个控制器中的方法直接返回了参数，演示了对GET请求参数的处理，效果是这样的：\n$ curl http://localhost:8080/?arg=foo\nfoo\n$ curl http://localhost:8080/kwargs?a=1&b=2&c=3\n{u'a': u'1', u'c': u'3', u'b': u'2'}\n有时候，参数也可能是URL的一部分，比如最后的一段path作为参数，就像下面这样：\nclass RootController(object):\n    @expose()\n    def args(self, *args):\n        return ','.join(args)\n效果是这样的：\n$ curl http://localhost:8080/args/one/two/three\none,two,three\n另外，我们还要看一下POST方法的参数如何处理（例子来自官方文档）：\nclass RootController(object):\n    @expose()\n    def index(self, arg):\n        return arg\n效果如下，就是把HTTP body解析成了控制器方法的参数：\n$ curl -X POST \"http://localhost:8080/\" -H \"Content-Type: application/x-www-form-urlencoded\" -d \"arg=foo\"\nfoo\n返回JSON还是HTML？\n如果你不是明确的返回一个Response对象，那么Pecan中方法的返回内容类型就是由expose()装饰器决定的。默认情况下，控制器的方法返回的content-type是HTML。\nclass RootController(rest.RestController):\n    _custom_actions = {\n        'test': ['GET'],\n    }\n\n    @expose()\n    def test(self):\n        return 'hello'\n效果如下：\n $ curl -v http://localhost:8080/test\n* Hostname was NOT found in DNS cache\n*   Trying 127.0.0.1...\n* Connected to localhost (127.0.0.1) port 8080 (#0)\n> GET /test HTTP/1.1\n> User-Agent: curl/7.38.0\n> Host: localhost:8080\n> Accept: */*\n>\n* HTTP 1.0, assume close after body\n< HTTP/1.0 200 OK\n< Date: Tue, 15 Sep 2015 14:31:28 GMT\n< Server: WSGIServer/0.1 Python/2.7.9\n< Content-Length: 5\n< Content-Type: text/html; charset=UTF-8\n<\n* Closing connection 0\nhello% \n也可以让它返回JSON：\nclass RootController(rest.RestController):\n    _custom_actions = {\n        'test': ['GET'],\n    }\n\n    @expose('json')\n    def test(self):\n        return 'hello'\n效果如下：\n curl -v http://localhost:8080/test\n* Hostname was NOT found in DNS cache\n*   Trying 127.0.0.1...\n* Connected to localhost (127.0.0.1) port 8080 (#0)\n> GET /test HTTP/1.1\n> User-Agent: curl/7.38.0\n> Host: localhost:8080\n> Accept: */*\n>\n* HTTP 1.0, assume close after body\n< HTTP/1.0 200 OK\n< Date: Tue, 15 Sep 2015 14:33:27 GMT\n< Server: WSGIServer/0.1 Python/2.7.9\n< Content-Length: 18\n< Content-Type: application/json; charset=UTF-8\n<\n* Closing connection 0\n{\"hello\": \"world\"}% \n甚至，你还可以让一个控制器方法根据URL path的来决定是返回HTML还是JSON：\nclass RootController(rest.RestController):\n    _custom_actions = {\n        'test': ['GET'],\n    }\n\n    @expose()\n    @expose('json')\n    def test(self):\n        return json.dumps({'hello': 'world'})\n返回JSON：\n $ curl -v http://localhost:8080/test.json\n* Hostname was NOT found in DNS cache\n*   Trying 127.0.0.1...\n* Connected to localhost (127.0.0.1) port 8080 (#0)\n> GET /test.json HTTP/1.1\n> User-Agent: curl/7.38.0\n> Host: localhost:8080\n> Accept: */*\n>\n* HTTP 1.0, assume close after body\n< HTTP/1.0 200 OK\n< Date: Wed, 16 Sep 2015 14:26:27 GMT\n< Server: WSGIServer/0.1 Python/2.7.9\n< Content-Length: 24\n< Content-Type: application/json; charset=UTF-8\n<\n* Closing connection 0\n\"{\\\"hello\\\": \\\"world\\\"}\"% \n返回HTML：\n $ curl -v http://localhost:8080/test.html\n* Hostname was NOT found in DNS cache\n*   Trying 127.0.0.1...\n* Connected to localhost (127.0.0.1) port 8080 (#0)\n> GET /test.html HTTP/1.1\n> User-Agent: curl/7.38.0\n> Host: localhost:8080\n> Accept: */*\n>\n* HTTP 1.0, assume close after body\n< HTTP/1.0 200 OK\n< Date: Wed, 16 Sep 2015 14:26:24 GMT\n< Server: WSGIServer/0.1 Python/2.7.9\n< Content-Length: 18\n< Content-Type: text/html; charset=UTF-8\n<\n* Closing connection 0\n{\"hello\": \"world\"}% \n这里要注意一下：\n\n同一个字符串作为JSON返回和作为HTML返回是不一样的，仔细看一下HTTP响应的内容。\n我们的例子中在URL的最后加上了.html后缀或者.json后缀，请尝试一下不加后缀的化是返回什么？然后，调换一下两个expose()的顺序再试一下。\n\n从上面的例子可以看出，决定响应类型的主要是传递给expose()函数的参数，我们看下expose()函数的完整声明：\npecan.decorators.expose(template=None,\n                        content_type='text/html',\n                        generic=False)\n\ntemplate参数用来指定返回值的模板，如果是'json'就会返回JSON内容，这里可以指定一个HTML文件，或者指定一个mako模板。\ncontent_type指定响应的content-type，默认值是'text/html'。\ngeneric参数表明该方法是一个“泛型”方法，可以指定多个不同的函数对应同一个路径的不同的HTTP方法。\n\n看过参数的解释后，你应该能大概了解expose()函数是如何控制HTTP响应的内容和类型的。\n用WSME来做什么？\n上面两节已经说明了Pecan可以比较好的处理HTTP请求中的参数以及控制HTTP返回值。那么为什么我们还需要WSME呢？因为Pecan在做下面这个事情的时候比较麻烦：请求参数和响应内容的类型检查（英文简称就是typing）。当然，做是可以做的，不过你需要自己访问pecan.request和pecan.response，然后检查指定的值的类型。WSME就是为解决这个问题而生的，而且适用场景就是RESTful API。\nWSME简介\nWSME的全称是Web Service Made Easy，是专门用于实现REST服务的typing库，让你不需要直接操作请求和响应，而且刚好和Pecan结合得非常好，所以OpenStack的很多项目都使用了Pecan + WSME的组合来实现API（好吧，我看过的项目，用了Pecan的都用了WSME）。WSME的理念是：在大部分情况下，Web服务的输入和输出对数据类型的要求都是严格的。所以它就专门解决了这个事情，然后把其他事情都交给其他框架去实现。因此，一般WSME都是和其他框架配合使用的，支持Pecan、Flask等。WSME的文档地址是http://wsme.readthedocs.org/en/latest/index.html。\nWSME的使用\n用了WSME后的好处是什么呢？WSME会自动帮你检查HTTP请求和响应中的数据是否符合预先设定好的要求。WSME的主要方式是通过装饰器来控制controller方法的输入和输出。WSME中主要使用两个控制器：\n\n@signature: 这个装饰器用来描述一个函数的输入和输出。\n@wsexpose: 这个装饰器包含@signature的功能，同时会把函数的路由信息暴露给Web框架，效果就像Pecan的expose装饰器。\n\n这里我们结合Pecan来讲解WSME的使用。先来看一个原始类型的例子：\nfrom wsmeext.pecan import wsexpose\n\nclass RootController(rest.RestController):\n    _custom_actions = {\n        'test': ['GET'],\n    }\n\n    @wsexpose(int, int)\n    def test(self, number):\n        return number\n如果不提供参数，访问会失败：\n$ curl http://localhost:8080/test\n{\"debuginfo\": null, \"faultcode\": \"Client\", \"faultstring\": \"Missing argument: \\\"number\\\"\"}% \n如果提供的参数不是整型，访问也会失败：\n$ curl http://localhost:8080/test\\?number\\=a\n{\"debuginfo\": null, \"faultcode\": \"Client\", \"faultstring\": \"Invalid input for field/attribute number. Value: 'a'. unable to convert to int\"}% \n上面这些错误信息都是由WSME框架直接返回的，还没有执行到你写的方法。如果请求正确，那么会是这样的：\n$ curl -v http://localhost:8080/test\\?number\\=1\n* Hostname was NOT found in DNS cache\n*   Trying 127.0.0.1...\n* Connected to localhost (127.0.0.1) port 8080 (#0)\n> GET /test?number=1 HTTP/1.1\n> User-Agent: curl/7.38.0\n> Host: localhost:8080\n> Accept: */*\n>\n* HTTP 1.0, assume close after body\n< HTTP/1.0 200 OK\n< Date: Wed, 16 Sep 2015 15:06:35 GMT\n< Server: WSGIServer/0.1 Python/2.7.9\n< Content-Length: 1\n< Content-Type: application/json; charset=UTF-8\n<\n* Closing connection 0\n1% \n请注意返回的content-type,这里返回JSON是因为我们使用的wsexpose设置的返回类型是XML和JSON，并且JSON是默认值。上面这个例子就是WSME最简单的应用了。\n那么现在有下面这些问题需要思考一下：\n\n如果想用POST的方式来传递参数，要怎么做呢？提示：要阅读WSME中@signature装饰器的文档。\n如果我希望使用/test/1这种方式来传递参数要怎么做呢？提示：要阅读Pecan文档中关于路由的部分。\nWSME中支持对哪些类型的检查呢？WSME支持整型、浮点型、字符串、布尔型、日期时间等，甚至还支持用户自定义类型。提示：要阅读WSME文档中关于类型的部分。\nWSME支持数组类型么？支持。\n\n上面的问题其实也是很多人使用WSME的时候经常问的问题。我们将在下一篇文章中使用Pecan + WSME来继续开发我们的demo，并且用代码来回答上面所有的问题。\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "25"}