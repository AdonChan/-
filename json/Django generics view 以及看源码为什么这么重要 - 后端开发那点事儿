{"title": "Django generics view 以及看源码为什么这么重要 - 后端开发那点事儿 ", "index": "django,python", "content": "关于阅读代码\n我们知道，得益于python的语言特性，python的源码是直接可以看的到的，而django是一种大而全的东东，虽然django的文档看似全面，但实际上有些模块写的确实不怎么样，而且平时遇到的需求也是多变的，有的时候你需要实现某种诡异的功能，当然我们可以用google或者做github的搬运工，但是有的时候框架已经给你做了很多事情，你只需要在多做那么一丢丢就能实现某种需求，这个时候看代码比去扒github是快的多的。\n先稍微扯一下Django generics view\n这玩意儿通常你百度或者google的时候，大部分时间会跟你讲这是Class-based views。\n第一次接触的时候，我觉得他牛逼的地方在于只要在子类里面定义get post方法，就不需要写类似这种东西了\n    if request.method.lower() == 'get':\n        do_something()\n    else:\n        do_otherthing()\n其实与普通的method view不同的是，他的父类定义了一堆有用的方法，当你知道这些的时候你可以少些超多的代码来做一些屌屌的事情。\n来看下使用示例\n防止文件被删除，贴几段过来\nclass BaseMixin(object):\n    \n    def get_context_data(self,*args,**kwargs):\n        context = super(BaseMixin,self).get_context_data(**kwargs)\n        try:\n            #热门文章\n            context['hot_article_list'] = Article.objects.order_by(\"-view_times\")[0:10]\n            #导航条\n            context['nav_list'] =  Nav.objects.filter(status=0)\n            #最新评论\n            context['latest_comment_list'] = Comment.objects.order_by(\"-create_time\")[0:10]\n\n        except Exception as e:\n            logger.error(u'[BaseMixin]加载基本信息出错')\n\n        return context\n\n\nclass IndexView(BaseMixin,ListView):\n    template_name = 'blog/index.html'\n    context_object_name = 'article_list'\n    paginate_by = PAGE_NUM #分页--每页的数目\n    \n    def get_context_data(self,**kwargs):\n        #轮播\n        kwargs['carousel_page_list'] = Carousel.objects.all()\n        return super(IndexView,self).get_context_data(**kwargs)\n\n    def get_queryset(self):\n        article_list = Article.objects.filter(status=0)\n        return article_list\n这是项目原来的地址\n如果你之前只写过method的view，你可能会觉得很诡异，为毛这段代码定义了几个属性，重写了几个方法就实现了我之前写的那么一大坨长长的代码？这种时候就必须看源码了，比文档来的直观。\ngeneric view代码讲解\nOK先贴一波源码，django的generic view有很多，就讲下最常见的list。\n这是 base.py里面的东东\nclass View(object):\n    \"\"\"\n    Intentionally simple parent class for all views. Only implements\n    dispatch-by-method and simple sanity checking.\n    \"\"\"\n\n    http_method_names = ['get', 'post', 'put', 'delete', 'head', 'options', 'trace']\n\n    def __init__(self, **kwargs):\n        \"\"\"\n        Constructor. Called in the URLconf; can contain helpful extra\n        keyword arguments, and other things.\n        \"\"\"\n        # Go through keyword arguments, and either save their values to our\n        # instance, or raise an error.\n        for key, value in kwargs.iteritems():\n            setattr(self, key, value)\n\n    @classonlymethod\n    def as_view(cls, **initkwargs):\n        \"\"\"\n        Main entry point for a request-response process.\n        \"\"\"\n        # sanitize keyword arguments\n        for key in initkwargs:\n            if key in cls.http_method_names:\n                raise TypeError(u\"You tried to pass in the %s method name as a \"\n                                u\"keyword argument to %s(). Don't do that.\"\n                                % (key, cls.__name__))\n            if not hasattr(cls, key):\n                raise TypeError(u\"%s() received an invalid keyword %r\" % (\n                    cls.__name__, key))\n\n        def view(request, *args, **kwargs):\n            self = cls(**initkwargs)\n            if hasattr(self, 'get') and not hasattr(self, 'head'):\n                self.head = self.get\n            return self.dispatch(request, *args, **kwargs)\n\n        # take name and docstring from class\n        update_wrapper(view, cls, updated=())\n\n        # and possible attributes set by decorators\n        # like csrf_exempt from dispatch\n        update_wrapper(view, cls.dispatch, assigned=())\n        return view\n\n    def dispatch(self, request, *args, **kwargs):\n        # Try to dispatch to the right method; if a method doesn't exist,\n        # defer to the error handler. Also defer to the error handler if the\n        # request method isn't on the approved list.\n        if request.method.lower() in self.http_method_names:\n            handler = getattr(self, request.method.lower(), self.http_method_not_allowed)\n        else:\n            handler = self.http_method_not_allowed\n        self.request = request\n        self.args = args\n        self.kwargs = kwargs\n        return handler(request, *args, **kwargs)\n\n    def http_method_not_allowed(self, request, *args, **kwargs):\n        allowed_methods = [m for m in self.http_method_names if hasattr(self, m)]\n        logger.warning('Method Not Allowed (%s): %s', request.method, request.path,\n            extra={\n                'status_code': 405,\n                'request': self.request\n            }\n        )\n        return http.HttpResponseNotAllowed(allowed_methods)\n这是list.py里面的东东\nclass MultipleObjectMixin(object):\n    allow_empty = True\n    queryset = None\n    model = None\n    paginate_by = None\n    context_object_name = None\n    paginator_class = Paginator\n\n    def get_queryset(self):\n        \"\"\"\n        Get the list of items for this view. This must be an interable, and may\n        be a queryset (in which qs-specific behavior will be enabled).\n        \"\"\"\n        if self.queryset is not None:\n            queryset = self.queryset\n            if hasattr(queryset, '_clone'):\n                queryset = queryset._clone()\n        elif self.model is not None:\n            queryset = self.model._default_manager.all()\n        else:\n            raise ImproperlyConfigured(u\"'%s' must define 'queryset' or 'model'\"\n                                       % self.__class__.__name__)\n        return queryset\n\n    def paginate_queryset(self, queryset, page_size):\n        \"\"\"\n        Paginate the queryset, if needed.\n        \"\"\"\n        paginator = self.get_paginator(queryset, page_size, allow_empty_first_page=self.get_allow_empty())\n        page = self.kwargs.get('page') or self.request.GET.get('page') or 1\n        try:\n            page_number = int(page)\n        except ValueError:\n            if page == 'last':\n                page_number = paginator.num_pages\n            else:\n                raise Http404(_(u\"Page is not 'last', nor can it be converted to an int.\"))\n        try:\n            page = paginator.page(page_number)\n            return (paginator, page, page.object_list, page.has_other_pages())\n        except InvalidPage:\n            raise Http404(_(u'Invalid page (%(page_number)s)') % {\n                                'page_number': page_number\n            })\n\n    def get_paginate_by(self, queryset):\n        \"\"\"\n        Get the number of items to paginate by, or ``None`` for no pagination.\n        \"\"\"\n        return self.paginate_by\n\n    def get_paginator(self, queryset, per_page, orphans=0, allow_empty_first_page=True):\n        \"\"\"\n        Return an instance of the paginator for this view.\n        \"\"\"\n        return self.paginator_class(queryset, per_page, orphans=orphans, allow_empty_first_page=allow_empty_first_page)\n\n    def get_allow_empty(self):\n        \"\"\"\n        Returns ``True`` if the view should display empty lists, and ``False``\n        if a 404 should be raised instead.\n        \"\"\"\n        return self.allow_empty\n\n    def get_context_object_name(self, object_list):\n        \"\"\"\n        Get the name of the item to be used in the context.\n        \"\"\"\n        if self.context_object_name:\n            return self.context_object_name\n        elif hasattr(object_list, 'model'):\n            return smart_str('%s_list' % object_list.model._meta.object_name.lower())\n        else:\n            return None\n\n    def get_context_data(self, **kwargs):\n        \"\"\"\n        Get the context for this view.\n        \"\"\"\n        queryset = kwargs.pop('object_list')\n        page_size = self.get_paginate_by(queryset)\n        context_object_name = self.get_context_object_name(queryset)\n        if page_size:\n            paginator, page, queryset, is_paginated = self.paginate_queryset(queryset, page_size)\n            context = {\n                'paginator': paginator,\n                'page_obj': page,\n                'is_paginated': is_paginated,\n                'object_list': queryset\n            }\n        else:\n            context = {\n                'paginator': None,\n                'page_obj': None,\n                'is_paginated': False,\n                'object_list': queryset\n            }\n        context.update(kwargs)\n        if context_object_name is not None:\n            context[context_object_name] = queryset\n        return context\n\n\nclass BaseListView(MultipleObjectMixin, View):\n    def get(self, request, *args, **kwargs):\n        self.object_list = self.get_queryset()\n        allow_empty = self.get_allow_empty()\n        if not allow_empty and len(self.object_list) == 0:\n            raise Http404(_(u\"Empty list and '%(class_name)s.allow_empty' is False.\")\n                          % {'class_name': self.__class__.__name__})\n        context = self.get_context_data(object_list=self.object_list)\n        return self.render_to_response(context)\n首先是为什么不需要写if else判断，而在子类里面定义get post即可，可以看到是下面的dispatch方法做了通用的处理。\n    def dispatch(self, request, *args, **kwargs):\n        # Try to dispatch to the right method; if a method doesn't exist,\n        # defer to the error handler. Also defer to the error handler if the\n        # request method isn't on the approved list.\n        if request.method.lower() in self.http_method_names:\n            handler = getattr(self, request.method.lower(), self.http_method_not_allowed)\n        else:\n            handler = self.http_method_not_allowed\n        self.request = request\n        self.args = args\n        self.kwargs = kwargs\n        return handler(request, *args, **kwargs)\n而通用的listview实际上就是一个父类实现了get方法，其中的MultipleObjectMixin实现了超多的方法供你重写，基本上大部分时间我们重写MultipleObjectMixin里面的对应方法以及设置合适的属性就可以完成大部分的业务逻辑。\nBaseListView首先通过 self.get_queryset() 方法拿到了你需要list的对象，中间一坨是分页的东东，下面的context则是最后需要render_to_response时传的参数，这样看就跟以前自己通过method view写的东西一一对应了。而我们只需要根据不同的业务逻辑实现里面的覆盖实现里面的方法即可，有些连覆盖都不需要是要在设置合适的属性，到这里我就不需要根据具体的方法具体讲解了，大家自己看。\nclass BaseListView(MultipleObjectMixin, View):\n    def get(self, request, *args, **kwargs):\n        self.object_list = self.get_queryset()\n        allow_empty = self.get_allow_empty()\n        if not allow_empty and len(self.object_list) == 0:\n            raise Http404(_(u\"Empty list and '%(class_name)s.allow_empty' is False.\")\n                          % {'class_name': self.__class__.__name__})\n        context = self.get_context_data(object_list=self.object_list)\n        return self.render_to_response(context)\n一个现实中的例子\n上面仅仅是如何使用django默认的各种generic view，但是有时候默认的机制并不能实现你的需求，例如现在在移动端的大潮下，html配饰移动端一般有两种方案：1.响应式；2.两套页面完全分开。两种方案各有利弊，如果我们需要根据根据user agent来做不同终端的页面渲染，甚至是不同的逻辑（web和移动端逻辑不同这很正常），这种时候很容易想到重写dispatch方法，来做到一种通用的处理方式。\nfrom django.views.generic import View as DjangoView\n\nclass View(DjangoView):\n\n    def _get_handler(self, request):\n        ''' \n        根据ua获取handler\n        '''\n        handler_name = request.method.lower()\n        if handler_name in self.http_method_names:\n            handler = getattr(self, handler_name)\n            if not handler:\n                return self.http_method_not_allowed\n\n        user_agent = request.META.get('HTTP_USER_AGENT', '').lower()\n        handler = getattr(self, handler_name, self.http_method_not_allowed)\n        user_agents = ['ipad', 'iphone', 'ipod', 'androidtv', 'android']\n        for ua in user_agents:\n            if ua in user_agent:\n                handler_name = '{}_{}'.format(handler_name, ua) \n                break\n        return getattr(self, handler_name) or handler\n        \n    def dispatch(self, request, *args, **kwargs):\n        # Try to dispatch to the right method; if a method doesn't exist,\n        # defer to the error handler. Also defer to the error handler if the\n        # request method isn't on the approved list.\n        # 支持user agent跳转\n        # 如果实现了对应的方法，则直接使用对应ua的规则\n        # 例如method=get, ua为iphone的ua，子类实现 get_iphone, 则使用get_iphone进行render\n        handler = self._get_handler(request)\n        self.request = request\n        self.args = args\n        self.kwargs = kwargs\n        return handler(request, *args, **kwargs)                \n\n                ", "mainLikeNum": ["5 "], "mainBookmarkNum": "12"}