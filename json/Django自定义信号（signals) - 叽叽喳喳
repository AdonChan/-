{"title": "Django自定义信号（signals) - 叽叽喳喳 ", "index": "web,django,python", "content": "django中自定义了一些singals，用于监听一些操作，并发出通知\n官方解释：\n    Django 提供一个“信号分发器”，允许解耦的应用在框架的其它地方发生操作时会被通知到。\n    简单来说，信号允许特定的sender通知一组receiver某些操作已经发生。这在多处代码和同一事件有关联的情况下很有用。\ndjango中已经内置了一些singals，在django/db/models/signal.py中，如\nModel signals\n    pre_init                    # django的modal执行其构造方法前，自动触发\n    post_init                   # django的modal执行其构造方法后，自动触发\n    pre_save                    # django的modal对象保存前，自动触发\n    post_save                   # django的modal对象保存后，自动触发\n    pre_delete                  # django的modal对象删除前，自动触发\n    post_delete                 # django的modal对象删除后，自动触发\n    m2m_changed                 # django的modal中使用m2m字段操作第三张（add,remove,clear）前后，自动触发\n    class_prepared              # 程序启动时，检测已注册的app中modal类，对于每一个类，自动触发\n    \nManagement signals\n    pre_migrate                 # 执行migrate命令前，自动触发\n    post_migrate                # 执行migrate命令后，自动触发\n    \nRequest/response signals\n    request_started             # 请求到来前，自动触发\n    request_finished            # 请求结束后，自动触发\n    got_request_exception       # 请求异常后，自动触发\n    \nTest signals\n    setting_changed             # 使用test测试修改配置文件时，自动触发\n    template_rendered           # 使用test测试渲染模板时，自动触发\n    \nDatabase Wrappers\n    connection_created          # 创建数据库连接时，自动触发\n用法：\n利用这几个singals可以实现model中的一些联动操作，比如，要想更改通过model更新记录时，记下操作者的日志，可以直接在操作的地方使用post_save装饰器，\n或者改写post_save，使其记录相关信息，一劳永逸。或者在request请求时，记录请求信息。\nfrom django.core.signals import request_finished\nfrom django.dispatch import receiver\n\n@receiver(request_finished)\ndef my_callback(sender, **kwargs):\n    print(\"Request finished!\")\n    \n如何自定义singals？\na. 定义singal文件\nimport django.dispatch\npizza_done = django.dispatch.Signal(providing_args=[\"toppings\", \"size\"])\n\nb. 注册singal\ndef callback(sender, **kwargs):\n    print(\"callback\")\n    print(sender,kwargs)\n    pizza_done.connect(callback)\n    \nc. 触发信号\nfrom 路径 import pizza_done\npizza_done.send(sender='seven',toppings=123, size=456)\n\n需求场景：\n项目中有一个需求，当model(即库的数据)被修改或者删除时，自动触发一个redis的同步任务(后来发现这个需求没有意义....)，model的保存有post_save，删除有post_delete，唯独没有update，而代码中使用update的场景蛮多的，就搜了下为什么就是没有update的singals。\n看到：https://code.djangoproject.co...\n其实很早就有人给django官方提过这种方式，为什么不在官方版本中添加，具体这个pr为什么没有被接受，可以看下里面的讨论，反正当时的django1.9仍然不支持，只能自己先写一个用用，有问题了再撤掉好了。\n解决方式：\nsingals.py文件\n# coding:utf-8\nfrom django.dispatch import Signal\npost_update = Signal(providing_args=[\"user\"])\n\nmodels.py文件\n-----------针对某个model，重写其queryset中的update方法-----------\n//引入自定义的signal文件\nfrom tools  import signals \n\nclass MyCustomQuerySet(models.query.QuerySet):\n    def update(self, **kwargs):\n        super(MyCustomQuerySet, self).update(**kwargs)\n        //update被调用时， 发送该singalsignals\n        signals.post_update.send(sender=self.model, user=\"xxx\")\n        print(\"finished!\")\n\nclass MyCustomManager(models.Manager):\n    def get_queryset(self):\n        return MyCustomQuerySet(self.model, using=self._db)\n\nclass crontab_ping(models.Model):\n    name = models.CharField(max_length=64, blank=True, null=True)\n    objects = MyCustomManager()\ncallback.py文件：\n-------接收signal，触发操作----------\nfrom tools.signals import post_update\n\n@receiver(post_update)\ndef post_update_callback(sender, **kwargs):\n    print(kwargs['user'])\n    print(\"post_update_success\")\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}