{"title": "文件操作 - 个人文章 ", "index": "python", "content": "一 介绍\n计算机系统分为：计算机硬件，操作系统，应用程序三部分。   我们用python或其他语言编写的应用程序若想要把数据永久保存下来，必须要保存于硬盘中，这就涉及到应用程序要操作硬件，众所周知，应用程序是无法直接操作硬件的，这就用到了操作系统。操作系统把复杂的硬件操作封装成简单的接口给用户/应用程序使用，其中文件就是操作系统提供给应用程序来操作硬盘虚拟概念，用户或应用程序通过操作文件，可以将自己的数据永久保存下来。文件路径：相对路径：Linux和os x中用/，Windows中用，该位置相对于当前程序所在目录绝对路径：同上，读取系统任何地方文件，由于在Python中是转义符建议路径前加上r有了文件的概念，我们无需再去考虑操作硬盘的细节，只需要关注操作文件的流程：1、打开文件，得到文件句柄并赋值给一个变量\nf=open('a.txt','r',encoding='utf-8')  # 默认打开模式就为r\n2、通过句柄对文件进行操作\ndata=f.read()\n3、关闭文件\nf.close()  #操作过程存储在内存与缓存中，在程序结束或者close之后写入磁盘\n上下文与回收打开一个文件包含两部分资源：操作系统级打开的文件+应用程序的变量。在操作完毕一个文件时，必须把与该文件的这两部分资源一个不落地回收，回收方法为：1、f.close()   #回收操作系统级打开的文件2、del f       #回收应用程序级的变量注意：其中del f一定要发生在f.close()之后，否则就会导致操作系统打开的文件还没有关闭，白白占用资源，而python自动的垃圾回收机制决定了我们无需考虑del f，这就要求我们，在操作完毕文件后，一定要记住f.close()。如果程序存在bug，导致close()未执行，文件不会关闭。\nwhit管理上下文：\nwith open('a.txt','w') as f:\n    pass \nwith open('a.txt','r') as read_f,open('b.txt','w') as write_f:\n    data=read_f.read()\n    write_f.write(data)\n注意：当with代码块执行完毕时，内部会自动关闭并释放文件资源。open()返回的文件对象只在with内可用，如果要在外部访问需将with内创建列表，再从外部使用文件编码\nf=open(...)是由操作系统打开文件，那么如果我们没有为open指定编码，操作系统会用自己的默认编码去打开文件，在windows下是gbk，在linux下是utf-8。\nf=open('a.txt','r',encoding='utf-8')\n二 文件操作\n操作文件时，一般需要经历如下步骤：1、打开文件文件句柄 = file('文件路径', '模式')注：python中打开文件有两种方式，即：open(...) 和  file(...) ，本质上前者在内部会调用后者来进行文件操作，推荐使用 open。\n打开文件的模式有：\n打开文件的模式有(默认为文本模式):\n\nr :只读模式【默认模式，文件必须存在，不存在则抛出异常】\nw :只写模式【不可读；不存在则创建；存在则清空原内容写入新内容】\na :追加写模式【不可读；不存在则创建；存在则在光标位置追加内容】\n\n非文本文件，我们只能使用b模式，\"b\"表示以字节的方式操作(无需考虑文本、图片、视频的格式):\n\nrb :只读模式\nwb :修改并读取\nab :追加字节\n\n注意：以b方式打开时，读取到的内容是字节类型，写入时也需要提供字节类型，不能指定编码\n其他模式\n\n\"+\" :表示可以同时读写某个文件\nr+ :读写【可读，可写】#追加写，文件光标位置处，默认在开始位置\nw+ :写读【可读，可写】#清除覆盖原有内容，默认光标位置在开始，用seek读\na+ :写读【可读，可写】#不清空在最后位置追加，用seek读。\nx :只写模式【不可读】#不存在则创建，存在则报错\nx+ :写读【可读，可写】\n\n\"U\" :表示在读取时,将 r n rn自动转换成 n (与r或r+模式同使用)\n   rU     r+U\n\n\n操作文件方法\nimport sys       #系统函数\nprint(f.tell())  #返回光标位置\nf.read()         #从光标初读取所有内容,并移动到末尾返回空字符串即空行\nf.read(3)        #文本模式读三个字符，b模式读取3个字节\nf.readline()     #读取一行内容,光标移动到第二行首部\nf.readlines()    #读取所有行内容,存放于列表中，在循环迭代时获取\nf.xreadlines()   #可用于逐行读取文件，非全部\nf.readinto()     #读取到缓冲区，不要用，将被遗弃\nf.seek(0)        #指定文件中指针位置，0代表开始位置，不同于read。\nf.seek(3,2)      #从第三个字节开始打印，seek应用，如断点续传\nf.tell()         #获取当前指针位置\nf.truncate()     #截断文件，保留指定之前的数据。注意：文件的打开方式必须可写，不能用w或w+等方式打开，因为那样直接清空文件了，所以truncate要在r+或a或a+等模式下测试效果.\nf.write(“xx”)    #文本模式写入缓存，b模式需要加.encode('utf-8')\nf.flush()        #立刻从内存刷到磁盘中及屏幕上\nf.time.sleep(100)#100秒后写入磁盘\nf.close()        #写入磁盘或程序结束后写入磁盘\nf.stdout.write(“xx”)   #向屏幕输出内容，代表文件写、输出，先进了缓存\nf.write('1111n222n') #针对文本模式的写,需要自己写换行符\nf.write('1111n222n'.encode('utf-8')) #针对b模式的写,需要自己写换行符\nf.writelines(['333n','444n'])   #文件模式，字符串写入文件\nf.writelines([bytes('333n',encoding='utf8'),'444n'.encode('utf-8')])        #b模式\nf.readable()     #文件是否可读\nf.writable()     #文件是否可写\nf.close()       #关闭文件\nf.closed         #文件是否关闭\nf.encoding      #如果文件打开模式为b,否则没有该属性\nf.fileno()      #文件描述符\nf.isatty()      #判断文件是否是同意tty设备\nf.next()        #获取下一行数据，不存在时报错\n练习：\n打印一首诗f 读取一行，执行完后被回收，优化内存\n利用b模式，编写一个cp工具，要求如下：\n　　1. 既可以拷贝文本又可以拷贝视频，图片等文件　　2. 用户一旦参数错误，打印命令的正确使用方法，如usage:cp source_file target_file\n请输入代码\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}