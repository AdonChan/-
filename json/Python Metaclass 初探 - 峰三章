{"title": "Python Metaclass 初探 - 峰三章 ", "index": "metaclass,python", "content": "先以一个大牛的一段关于Python Metapgramming的著名的话来做开头：\nMetaclasses are deeper magic than 99% of users should ever worry about. If you wonder whether you need them, you don’t (the people who actually need them know with certainty that they need them, and don’t need an explanation about why). – Tim Peters\n翻译一下：Metaclasses是99%的用户都无需费神的黑科技。如果你还在纠结你是不是需要它的话，答案是NO （真正需要的人根本不需要解释） - Tim Peters\n这是什么鬼话？道可道，非常道吗？\nMeta?\n好，装B已毕。这确实是一个冷僻的，不常用的话题。一篇短文肯定讲不完。 所以叫做初探。\n英文meta这个词其实是从希腊语里面借来的。wikipedia上的解释是：\nindicate a concept which is an abstraction behind another concept, used to complete or add to the latter\n不看还好，其实看了更晕。好在后面的解释有一句“更高一层的抽象”，可以帮助理解。 其实我们可以这样理解。meta的意思就是“关于什么的什么”：比如metadata可以理解为“关于数据的数据”，metaprogramming可以理解为“关于编程的编程”。这就和“更高一层的抽象” 比较契合了。同时又隐隐和编程中的另一个永恒主题-recursion联系在了一起。\n另外，meta这个词天朝这边翻译成“元”，海峡对岸翻译成“后设”。其实我都不大理解从何而来。\n实例\n聚焦到我们今天的主题，metaprogramming就是编写用来生成代码的代码。\n假设我们写了一个NB的函数，用来计算一个任意复杂的算数表达式的值：像1+2, 3*6+10, 什么的都可以交给它去计算。这样的函数的算法不是我们的主题，所以我们请出python自带的大招eval()，一行就可以搞定了：\ndef calc(expression):\n    return eval(expression)\n\n因为输入的可能性是无限的，所以我们肯定要好好测试一下这个函数了。假定我们想了 上百个test case。又假定我们是用unittest这个module来做测试的。这样的测试程序一般会长成这样：\nimport unittest\n\nclass TestStringMethods(unittest.TestCase):\n\n    def test_upper(self):\n        self.assertEqual('foo'.upper(), 'FOO')\n\n    def test_isupper(self):\n        self.assertTrue('FOO'.isupper())\n        self.assertFalse('Foo'.isupper())\n\n    def test_split(self):\n        s = 'hello world'\n        self.assertEqual(s.split(), ['hello', 'world'])\n        # check that s.split fails when the separator is not a string\n        with self.assertRaises(TypeError):\n            s.split(2)\n\nif __name__ == '__main__':\n    unittest.main()\n\n所以我们的目的就是用metaprogramming的方式来自动产生类似上面的测试类。\n先上程序后解释：\n#!/usr/bin/python3\nimport unittest\n\ndef calc(expression):\n    return eval(expression)\n\ndef add_test(name, asserts):\n    def test_method(asserts):\n        def fn(self):\n            left, right = asserts.split('=')\n            expected = str(calc(left))\n            self.assertEqual(expected, right)\n        return fn\n\n    d = {'test1': test_method(asserts)}\n    cls = type(name, (unittest.TestCase,), d)\n    globals()[name] = cls\n\nif __name__ == '__main__':\n    for i, t in enumerate([\n            \"1+2=3\",\n            \"3*5*6=90\"]):\n        add_test(\"Test%d\" % i, t)\n    unittest.main()\n\nNB的calc()函数我们解释过了。main这段也比较简单：我们用声明的方式定义了一组测试，然后通过unittest来执行。\n有点复杂的是add_test()。我们先来看看最内层的fn(self)这个方法。逻辑上，它就是把输入的测试用例分成两份，一份是calc()的输入，一份是我们期待的结果；然后调用calc(), 接着用assertEqual()来测试。\n但是这个self有点奇怪 - 这里没有类，哪里来的self? 其实fn(self)确实是一个类的方法，只不过这个类是我们通过代码动态生成的。也就是下面这一行：\ncls = type(name, (unittest.TestCase,), d)\n\n这里的type()就是通常我们用来检查某个变量的类型的那个函数。只不过它还有另外一种不大为人知的形式：\nclass type(name, bases, dict)\n\n这第二种形式，就会产生一个新的类型。以我们的程序为例，就是以unit.TestCase为baseclass, 产生了一个名为TestN的新类型，改类型的实现由d给出，而d就包含了通过closure返回的fn(self)这个方法。只不过在这个新类里面，它的名字叫做 test1()。\n最后，我们把这个新产生的类加入到当前全局符号表里面，也就相当于上面给出的unittest的例子。\n所以，总结一下。当我们运行这个脚本的时候，这段比较短的代码会针对每一个测试的表达式产生一个新的测试类，并动态生成测试的方法加载到该类里面。unitest从globals中找到这些类并一一执行测试。\n上面的例子中，其实一行一行手打calc(1+2) == 3也没什么大不了的。但是当你要表达的逻辑比较复杂的时候，metaprogramming的强大就体现出来了。\n总结\n那么，看完这篇文章，我们也成为Tim所说的1%的程序猿了！其实，也许他的意思是，99%的编程工作都用不到这样技巧。在一些特殊的场合，比如编写某种框架的时候，metaprogramming会做到事半功倍。祝你在实践中碰到这样的机会。\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "4"}