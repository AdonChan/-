{"title": "LeetCode-singleNumber-只出现一次的数字 - 个人文章 ", "index": "算法,leetcode,python", "content": "描述：\n给定一个整数数组，除了某个元素外其余元素均出现两次。请找出这个只出现一次的元素。\n备注：\n你的算法应该是一个线性时间复杂度。 你可以不用额外空间来实现它吗？\n实现：\n#我的实现方法:利用count找出元素的个数，如果个数为1的就是要找的\nclass Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        for i in nums:\n            n  = nums.count(i)\n            if n ==1:\n                return i\n但是这个方法的时间超时了，达不到题目的性能要求\n可以利用Counter,可以将list转化成，list里面的value对应个数的字典例如：numss = [2,2,1,1,1,3]{1: 3, 2: 2, 3: 1}\nfrom collections import Counter\n\n\nclass Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        dict_nums = dict(Counter(nums))\n        nums_list = dict_nums.keys()\n        for i in nums_list:\n            if dict_nums[i]==1:\n                return i\n楼下回复大神提示说可以先对list进行排序：想到一种方法：排序之后进行比较：\nclass Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        \n        if len(nums)==1:\n            return nums[0]\n        else:  \n            if nums[0] != nums[1]:\n                return nums[0]\n\n            elif nums[len(nums) - 1] != nums[len(nums) - 2]:\n                return nums[len(nums) - 1]\n\n\n\n            else:\n                for n in range(len(nums)):\n                    if nums[n + 2] != nums[n + 1] and nums[n+2] != nums[n+3]:\n                        return nums[n + 2]\n根据大牛提示的每个元素异或的方式：由于A XOR A = 0 且 ((A^A) ^ (B^B) ^ (C^C) ^ (D^D) ^ E) = ((0^ 0 ^ 0 ^ 0 ^ E) =E直接把整个数组异或运算，最后的出来的就是只出现一次的数字了。\nclass Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ss = 0\n        for i in nums:\n            ss = ss^i\n        return ss\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "0"}