{"title": "Python 3 中的 super 和 __class__ - SegmentFault 业界资讯 ", "index": "oop,类,python", "content": "子类里访问父类的同名属性，而又不想直接引用父类的名字，因为说不定什么时候会去修改它，所以数据还是只保留一份的好。其实呢，还有更好的理由不去直接引用父类的名字，参见 Python’s super() considered super! | Deep Thoughts by Raymond Hettinger。\n\n\n\n这时候就该super()登场啦——\n\nclass A:\n  def m(self):\n    print('A')\n\nclass B(A):\n  def m(self):\n    print('B')\n    super().m()\n\nB().m()\n\n\n当然 Python 2 里super() 是一定要参数的，所以得这么写：\n\nclass B(A):\n  def m(self):\n    print('B')\n    super(B, self).m()\n\n\n需要提到自己的名字。这个名字也是动态查找的，在这种情况下替换第三方库中的类会出问题。\n\n`super()`` 很好地解决了访问父类中的方法的问题。那么，如果要访问父类的父类（准确地说，是方法解析顺序（MRO）中位于第三的类）的属性呢？\n\n比如，B 类是继承 A 的，它重写了 A 的 m 方法。现在我们需要一个 C 类，它需要 B 类的一些方法，但是不要 B 的 m 方法，而改用 A 的。怎么间接地引用到 A 的 m 方法呢？使用self.__class__肯定是不行的，因为 C 还可能被进一步继承。\n\n从文档中我注意到，super 的实现是通过插入一个名为 __class__ 的名字来实现的（super 会从调用栈里去查找这个 __class__ 名字）。所以，就像文档里暗示的，其实可以直接在定义方法时访问 __class__\n名字，它总是该方法被定义的类。继续我们的单字母类：\n\nclass C(B):\n  def m(self):\n    print('C')\n    # see the difference!\n    print(__class__.__mro__)\n    print(self.__class__.__mro__)\n    __class__.__mro__[2].m(self)\n\nclass D(C):\n  def m(self):\n    print('D')\n    super().m()\n\no = D()\no.m()\n\n\n会得到：\n\nD\nC\n(<class 't.C'>, <class 't.B'>, <class 't.A'>, <class 'object'>)\n(<class 't.D'>, <class 't.C'>, <class 't.B'>, <class 't.A'>, <class 'object'>)\nA\n\n\n不过，PyPy 并不支持这个 __class__ 名字。\n\n\nvia lilydjwg.is-programmer.com\n\n                ", "mainLikeNum": ["3 "], "mainBookmarkNum": "5"}