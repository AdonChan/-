{"title": "探索php和python下对象的深拷贝和浅拷贝 - 一个phper的成长之路 ", "index": "php,python", "content": "一、深拷贝与浅拷贝\n  深拷贝：赋值时值完全复制，完全的copy，对其中一个作出改变，不会影响另一个\n  浅拷贝：赋值时，引用赋值，相当于取了一个别名。对其中一个修改，会影响另一个\n  对于PHP而言，= 赋值时，普通对象是深拷贝，但对对象来说，是浅拷贝，即引用赋值。当对象作为参数传递时，无论参数前是否有&引用符号，都将被看做是赋值引用。\n  对于python而言，情况可能会有点小复杂，因为python一切皆为对象，所以python的普通赋值、深拷贝和浅拷贝之间都是有细微区别的。\n二、php下的他们\n  在php5中，对象的 = 赋值和传递都是引用。要想实现拷贝副本，php提供了clone函数实现。clone完全copy了一份副本。但是clone时，我们可能不希望copy源对象的所有内容，那我们可以利用__clone来操作。请看如下代码段：\n<?php\n//普通对象赋值，深拷贝，完全值复制\n$m = 1;\n$n = $m;\n$n = 2;\necho $m;//值复制，对新对象的改变不会对m作出改变，输出 1.深拷贝\necho PHP_EOL;\n/*==================*/\n \n//对象赋值，浅拷贝，引用赋值\nclass Test{\n    public $a=1;\n}\n$m = new Test();\n$n = $m;//引用赋值\n$m->a = 2;//修改m，n也随之改变\necho $n->a;//输出2，浅拷贝\necho PHP_EOL;\n?>\n  由于对象的赋值时引用，要想实现值复制，php提供了clone函数来实现复制对象。但是clone函数存在这么一个问题，克隆对象时，原对象的普通属性能值复制，但是源对象的对象属性赋值时还是引用赋值，浅拷贝。\n<?php\nclass Test{\n    public $a=1;\n}\n \nclass TestOne{\n    public $b=1;\n    public $obj;\n    //包含了一个对象属性，clone时，它会是浅拷贝\n    public function __construct(){\n        $this->obj = new Test();\n    }\n}\n$m = new TestOne();\n$n = $m;//这是完全的浅拷贝，无论普通属性还是对象属性\n \n$p = clone $m;\n \n//普通属性实现了深拷贝，改变普通属性b，不会对源对象有影响\n$p->b = 2;\necho $m->b;//输出原来的1\necho PHP_EOL;\n \n//对象属性是浅拷贝，改变对象属性中的a，源对象m中的对象属性中a也改变\n \n$p->obj->a = 3;\necho $m->obj->a;//输出3，随新对象改变\n?>\n  要想实现对象真正的深拷贝，有以下两种方法：\n1、利用序列化反序列化实现\n<?php\nclass Test{\n    public $a=1;\n}\n \nclass TestOne{\n    public $b=1;\n    public $obj;\n    //包含了一个对象属性，clone时，它会是浅拷贝\n    public function __construct(){\n        $this->obj = new Test();\n    }\n     \n}\n \n$m = new TestOne();\n//方法二，序列化反序列化实现对象深拷贝\n$n = serialize($m);\n$n = unserialize($n);\n \n$n->b = 2;\necho $m->b;//输出原来的1\necho PHP_EOL;\n//可以看到，普通属性实现了深拷贝，改变普通属性b，不会对源对象有影响\n \n \n$n->obj->a = 3;\necho $m->obj->a;//输出1，不随新对象改变，还是保持了原来的属性,可以看到，序列化和反序列化可以实现对象的深拷贝\n \n?>\n2、写clone函数\n<?php\nclass Test{\n    public $a=1;\n}\n \nclass TestOne{\n    public $b=1;\n    public $obj;\n    //包含了一个对象属性，clone时，它会是浅拷贝\n    public function __construct(){\n        $this->obj = new Test();\n    }\n     \n    //方法一：重写clone函数\n    public function __clone(){\n        $this->obj = clone $this->obj;\n    }\n}\n \n$m = new TestOne();\n$n = clone $m;\n \n$n->b = 2;\necho $m->b;//输出原来的1\necho PHP_EOL;\n//可以看到，普通属性实现了深拷贝，改变普通属性b，不会对源对象有影响\n \n//由于改写了clone函数，现在对象属性也实现了真正的深拷贝，对新对象的改变，不会影响源对象\n$n->obj->a = 3;\necho $m->obj->a;//输出1，不随新对象改变，还是保持了原来的属性\n \n?>\n三、python下的他们\n  “对一个对象进行浅拷贝其实是新创建了一个类型和原来对象一样，但是内容是原来对象元素的引用。换句话说，这个拷贝的对象本身是新的，但是它的内容不是”，摘自《Python核心编程》。\n  这是我个人对python下浅拷贝和深拷贝的理解：\n赋值：简单地拷贝对象的引用，两个对象的id相同。浅拷贝：创建一个新的组合对象，这个新对象与原对象共享内存中的子对象。深拷贝：创建一个新的组合对象，同时递归地拷贝所有子对象，新的组合对象与原对象没有任何关联。虽然实际上会共享不可变的子对象，但不影响它们的相互独立性。\n  浅拷贝和深拷贝的不同仅仅是对组合对象来说，所谓的组合对象就是包含了其它对象的可变对象，如列表，类实例。而对于数字、字符串以及其它“原子”类型，没有拷贝一说，产生的都是原对象的引用。下面的代码希望能对你有进一步的帮助；\n#! /usr/bin/python\n# -*- coding:UTF-8 -*-\n\nimport copy\n\n# 浅拷贝\n\na = [1, \"a\", 3, [4, 5, 6], [[7, 8, 9]]]\n\nb = a\n\nc = list(a)\n\nd = copy.deepcopy(a)\nprint \"原地址&&&\"\nprint id(a)\nprint \"赋值地址&&&\"\nprint id(b)\nprint \"浅拷贝地址&&&\"\nprint id(c)\nprint \"深拷贝地址&&&\"\nprint id(d)\n\nprint \"赋值地址###\"\nfor i, j in zip(a, b):\n    print id(i), id(j)\nprint \"浅拷贝地址###\"\nfor i, j in zip(a, c):\n    print id(i), id(j)\nprint \"深拷贝地址###\"\nfor i, j in zip(a, d):\n    print id(i), id(j)\nprint \"######\"\n\na[0] = 2\na[3][0] = 14\nprint \"原值变化为 %d, %d\" % (a[0], a[3][0])\nprint \"*******\"\nprint \"赋值变化\"\nprint b[0], b[3][0]\nprint \"浅拷贝变化\"\nprint c[0], c[3][0]\nprint \"深拷贝变化\"\nprint d[0], d[3][0]\nprint \"**##$$\"\nprint a\n输出如下：\n\n参考博文\nhttp://www.cnblogs.com/taijun...http://blog.csdn.net/u0115085...http://www.cnblogs.com/zxlove...\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "10"}