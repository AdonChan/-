{"title": "Pandas库基础分析——数据规整化处理 - Python量化交易 ", "index": "python", "content": "前言\n在数据分析和建模之前需要审查数据是否满足数据处理应用的要求，以及对数据进行清洗，转化，合并，重塑等一系列规整化处理。pandas标准库提供了高级灵活的方法，能够轻松地将数据规整化为正确的形式，本文通过例程介绍使用pandas库从获取数据到最终数据重塑的方法。\n数据文件获取\nPandas库提供专门处理csv文件的方法read_csv()，具体可参考《Pandas库基础分析——CSV文件加载和存储》中的Pandas库读写CSV文件章节。\n数据信息查看\n当数据量较大时，将数据所有信息输出到控制台中会显得过于冗杂，可通过查看部分数据信息，简要了解数据的特性。\n（1）查看数据前5行和尾部倒数5行数据，列名和索引信息，数据行列形状\nprint df_csvload.head()#查看前几行   \nprint df_csvload.tail()#查看后几行\nprint df_csvload.columns#查看列名\nprint df_csvload.index#查看索引\nprint df_csvload.shape#查看形状\n\n（2）查看各列数据描述性统计信息，如最小值、最大值、均值、标准差等\nprint df_csvload.describe()#查看各列数据描述性统计\n\n（3）查看数据是否有缺失及每列数据的类型\nprint df_csvload.info()#查看缺失及每列数据类型\n\n缺失值处理\n对Pandas做数据时不可避免会因为一些原因出现缺失值NaN（Not a number），比如两个DataFrame对象进行运算时对于无法匹配的位置就会出现缺失值。通过数据信息查看可知数据中存在缺失值，比如dataA、dataC、dataE各存在2个NaN，dataB、dataD、各存在1个NaN。\n（1）Pandas包中isnull()和notnull()方法用于判断数据是否为缺失值，若是缺失值则isnull()返回值为True，notnull()返回值为False。\nprint df_csvload.isnull()#判断数据缺失值\n\n\n（2）由于isnull()和notnull()方法判断缺失值生成的是所有数据的True/False矩阵，对于庞大的Dataframe数据，很难一眼看出缺失值位置，可在df_csvload.isnull()矩阵基础上结合数据转置方法.T和筛选满足True值条件列方法.any()，查找出含有NaN值所在的行。\nprint df_csvload[df_csvload.isnull().T.any().T]#查看NAN值所在行\n\n\n（3）对缺失值的处理的方法有删除和填充，此处通过DataFrame.dropna()方法将所有值都为缺失值的行删除，DataFrame.fillna()方法在列方向上对缺失值前值填充。\ndf_csvload = df_csvload.dropna(axis=0,how='all')#NAN值删除 行所有为NAN删除\ndf_csvload.fillna(method='ffill',axis=0,inplace=True)#NAN值填充 列方向前值填充\nprint df_csvload[df_csvload.isnull().values==True]#查看NAN值删除填充后值\n\n\n特殊值处理\n（1）查看各列数据描述性统计信息时发现“Flow”列最小值为0值，查找出0值具体位置后用“Flow”列通过中位值填充0值\n注：loc为通过行和列的标签名提取相应数据，iloc为通过位置提取特定的数据，而ix为标签和位置索引混合的方式切片数据\nprint df_csvload[df_csvload.values==0]#查看所有0值的元素\nprint df_csvload[df_csvload.Flow.isin([0])]#查看指定列0值\ndf_csvload.loc[df_csvload.loc[:,'Flow']==0,'Flow'] = df_csvload.Flow.median()#中位值替换0值\n\n\n（2）查看各列数据值时发现“dateE”列数据精度保留了6位小数，而“Flow”列数据精度保留了1位小数，此处将“dateE”列数据的精度更改为2位小数，将“Flow”列数据转化为整数，以便于显示和运算。\ndf_csvload = df_csvload.round(2)#保留2位小数\ndf_csvload.Flow = df_csvload.Flow.astype(int)#转换为整数\n\n\n数据运算转化\n（1）筛选出“Flow”列值大于该列均值的行，并只提取出所需的“date”列数据用于后续的运算。（可使用&、|符号实现多条件筛选）\nnew_df = df_csvload[['dataA','dataB','dataC','dataD']][(df_csvload.Flow>df_csvload.Flow.mean())]\n\n\n（2）通过apply()方法作用于DataFrame的行，计算出new_df每行数值最大与最小值之差，以及每行数值与平均值之差。\nmax_min_df = new_df.apply((lambda x:x.max() - x.min()),axis = 1)#计算横轴最大最小值之差\nerr_mean_df = new_df.apply((lambda x:x-x.mean()),axis = 1)#计算横轴数值与平均值之差\n\n\n也可分别计算new_df中每列数值与mean_df均值的误差。Pandas中Series与Series之间通过index匹配运算（加减乘除），同理Series与DataFrame之间是Series的index与DataFrame的columns之间匹配，运算的方式是将DataFrame每一行都与Series进行匹配运算，DataFrame之间则同时对index与columns进行匹配成功的元素进行运算，当以上类型出现无法匹配时用NaN进行填充。\nmean_df = new_df.apply((lambda x:x.mean()),axis = 1)#计算横轴平均值\ndataA_df = new_df.dataA - mean_df#计算误差\ndataB_df = new_df.dataB - mean_df#计算误差\ndataC_df = new_df.dataC - mean_df#计算误差\ndataD_df = new_df.dataD - mean_df#计算误差\n\n（3）applymap()方法作用于DataFrame元素级，此处将err_mean_df数值转换为真值矩阵\nerr_mean_df = err_mean_df.applymap(lambda x: True if(x>0) else False)# 大于零为True 小于零为False\n\n数据合并及连接\npandas提供了三种方式实现数据的合并，pandas.merge根据一个或多个键将不同的DataFrame中的行连接起来；pandas.concat沿着一条轴将多个对象堆叠到一起；combine_first将重复数据编接在一起，用一个对象中的值填充另外一个对象中的缺失值。此处使用pd.concat将数据按列方向合并，即axis为1，设置keys值用于形成连接轴上的层次化索引。\nmer_df = pd.DataFrame({'max_min':max_min_df,'mean':mean_df})\nresult =pd.concat([mer_df, err_mean_df],axis=1,keys=['diff_para','diff_err'])\n\n\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "0"}