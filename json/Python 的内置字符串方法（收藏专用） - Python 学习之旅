{"title": "Python 的内置字符串方法（收藏专用） - Python 学习之旅 ", "index": "method,字符串,string,python3.x,python", "content": "字符串处理是非常常用的技能，但 Python 内置字符串方法太多，常常遗忘，为了便于快速参考，特地依据 Python 3.5.1 给每个内置方法写了示例并进行了归类，便于大家索引。PS: 可以点击概览内的绿色标题进入相应分类或者通过右侧边栏文章目录快速索引相应方法。\n概览\n字符串大小写转换\n\nstr.capitalize()\nstr.lower()\nstr.casefold()\nstr.swapcase()\nstr.title()\nstr.upper()\n\n字符串格式输出\n\nstr.center(width[, fillchar])\nstr.ljust(width[, fillchar]); str.rjust(width[, fillchar])\nstr.zfill(width)\nstr.expandtabs(tabsize=8)\nstr.format(^args, ^^kwargs)\nstr.format_map(mapping)\n\n字符串搜索定位与替换\n\nstr.count(sub[, start[, end]])\nstr.find(sub[, start[, end]]); str.rfind(sub[, start[, end]])\nstr.index(sub[, start[, end]]); str.rindex(sub[, start[, end]])\nstr.replace(old, new[, count])\nstr.lstrip([chars]); str.rstrip([chars]); str.strip([chars])\nstatic str.maketrans(x[, y[, z]]); str.translate(table)\n\n字符串的联合与分割\n\nstr.join(iterable)\nstr.partition(sep); str.rpartition(sep)\nstr.split(sep=None, maxsplit=-1); str.rsplit(sep=None, maxsplit=-1)\nstr.splitlines([keepends])\n\n字符串条件判断\n\nstr.endswith(suffix[, start[, end]]); str.startswith(prefix[, start[, end]])\nstr.isalnum()\nstr.isalpha()\nstr.isdecimal(); str.isdigit(); str.isnumeric()\nstr.isidentifier()\nstr.islower()\nstr.isprintable()\nstr.isspace()\nstr.istitle()\nstr.isupper()\n\n字符串编码\nstr.encode(encoding=\"utf-8\", errors=\"strict\")\n大小写转换\nstr.capitalize()\n将首字母转换成大写，需要注意的是如果首字没有大写形式，则返回原字符串。\n'adi dog'.capitalize()\n# 'Adi dog'\n\n'abcd 徐'.capitalize()\n# 'Abcd 徐'\n\n'徐 abcd'.capitalize()\n# '徐 abcd'\n\n'ß'.capitalize()\n# 'SS'\nstr.lower()\n将字符串转换成小写，其仅对 ASCII 编码的字母有效。\n'DOBI'.lower()\n# 'dobi'\n\n'ß'.lower()   # 'ß' 为德语小写字母，其有另一种小写 'ss'， lower 方法无法转换\n# 'ß'\n\n'徐 ABCD'.lower()\n# '徐 abcd'\nstr.casefold()\n将字符串转换成小写，Unicode 编码中凡是有对应的小写形式的，都会转换。\n'DOBI'.casefold()\n# 'dobi'\n\n'ß'.casefold()   #德语中小写字母 ß 等同于小写字母 ss， 其大写为 SS \n# 'ss'\nstr.swapcase()\n对字符串字母的大小写进行反转。\n'徐Dobi a123 ß'.swapcase()\n#: '徐dOBI A123 SS'    这里的 ß 被转成 SS 是一种大写\n但需要注意的是 s.swapcase().swapcase() == s 不一定为真：\nu'\\xb5'\n# 'µ'\n\nu'\\xb5'.swapcase()\n# 'Μ'\n\nu'\\xb5'.swapcase().swapcase()\n# 'μ'\n\nhex(ord(u'\\xb5'.swapcase().swapcase()))\nOut[154]: '0x3bc'\n这里 'Μ'(是 mu 不是 M) 的小写正好与 'μ' 的写法一致。\nstr.title()\n将字符串中每个“单词”首字母大写。其判断“单词”的依据则是基于空格和标点，所以应对英文撇好所有格或一些英文大写的简写时，会出错。\n'Hello world'.title()\n# 'Hello World'\n\n'中文abc def 12gh'.title()\n# '中文Abc Def 12Gh'\n\n# 但这个方法并不完美：\n\"they're bill's friends from the UK\".title()\n# \"They'Re Bill'S Friends From The Uk\"\n\nstr.upper()\n将字符串所有字母变为大写，会自动忽略不可转成大写的字符。\n'中文abc def 12gh'.upper()\n# '中文ABC DEF 12GH'\n需要注意的是 s.upper().isupper() 不一定为 True。\n字符串格式输出\nstr.center(width[, fillchar])\n将字符串按照给定的宽度居中显示，可以给定特定的字符填充多余的长度，如果指定的长度小于字符串长度，则返回原字符串。\n'12345'.center(10, '*')\n# '**12345***'\n\n'12345'.center(10)\n# '  12345   '\nstr.ljust(width[, fillchar]); str.rjust(width[, fillchar])\n返回指定长度的字符串，字符串内容居左（右）如果长度小于字符串长度，则返回原始字符串，默认填充为 ASCII 空格，可指定填充的字符串。\n'dobi'.ljust(10)\n# 'dobi      '\n\n'dobi'.ljust(10, '~')\n# 'dobi~~~~~~'\n\n'dobi'.ljust(3, '~')\n# 'dobi'\n\n'dobi'.ljust(3)\n# 'dobi'\nstr.zfill(width)\n用 '0' 填充字符串，并返回指定宽度的字符串。\n\"42\".zfill(5)\n# '00042'\n\"-42\".zfill(5)\n# '-0042'\n\n'dd'.zfill(5)\n# '000dd'\n\n'--'.zfill(5)\n# '-000-'\n\n' '.zfill(5)\n# '0000 '\n\n''.zfill(5)\n# '00000'\n\n'dddddddd'.zfill(5)\n# 'dddddddd'\nstr.expandtabs(tabsize=8)\n用指定的空格替代横向制表符，使得相邻字符串之间的间距保持在指定的空格数以内。\ntab = '1\\t23\\t456\\t7890\\t1112131415\\t161718192021'\n\ntab.expandtabs()\n# '1       23      456     7890    1112131415      161718192021'\n# '123456781234567812345678123456781234567812345678'  注意空格的计数与上面输出位置的关系\n\ntab.expandtabs(4)\n# '1   23  456 7890    1112131415  161718192021'\n# '12341234123412341234123412341234'  \nstr.format(^args, ^^kwargs)\n格式化字符串的语法比较繁多，官方文档已经有比较详细的 examples，这里就不写例子了，想了解的童鞋可以直接戳这里 Format examples.\nstr.format_map(mapping)\n类似 str.format(*args, **kwargs) ，不同的是 mapping 是一个字典对象。\nPeople = {'name':'john', 'age':56}\n\n'My name is {name},i am {age} old'.format_map(People)\n# 'My name is john,i am 56 old'\n字符串搜索定位与替换\nstr.count(sub[, start[, end]])\ntext = 'outer protective covering'\n\ntext.count('e')\n# 4\n\ntext.count('e', 5, 11)\n# 1\n\ntext.count('e', 5, 10)\n# 0\nstr.find(sub[, start[, end]]); str.rfind(sub[, start[, end]])\ntext = 'outer protective covering'\n\ntext.find('er')\n# 3\n\ntext.find('to')\n# -1\n\ntext.find('er', 3)\nOut[121]: 3\n\ntext.find('er', 4)\nOut[122]: 20\n\ntext.find('er', 4, 21)\nOut[123]: -1\n\ntext.find('er', 4, 22)\nOut[124]: 20\n\ntext.rfind('er')\nOut[125]: 20\n\ntext.rfind('er', 20)\nOut[126]: 20\n\ntext.rfind('er', 20, 21)\nOut[129]: -1\nstr.index(sub[, start[, end]]); str.rindex(sub[, start[, end]])\n与 find() rfind() 类似，不同的是如果找不到，就会引发 ValueError。\nstr.replace(old, new[, count])\n'dog wow wow jiao'.replace('wow', 'wang')\n# 'dog wang wang jiao'\n\n'dog wow wow jiao'.replace('wow', 'wang', 1)\n# 'dog wang wow jiao'\n\n'dog wow wow jiao'.replace('wow', 'wang', 0)\n# 'dog wow wow jiao'\n\n'dog wow wow jiao'.replace('wow', 'wang', 2)\n# 'dog wang wang jiao'\n\n'dog wow wow jiao'.replace('wow', 'wang', 3)\n# 'dog wang wang jiao'\nstr.lstrip([chars]); str.rstrip([chars]); str.strip([chars])\n'  dobi'.lstrip()\n# 'dobi'\n'db.kun.ac.cn'.lstrip('dbk')\n# '.kun.ac.cn'\n\n' dobi   '.rstrip()\n# ' dobi'\n'db.kun.ac.cn'.rstrip('acn')\n# 'db.kun.ac.'\n\n'   dobi   '.strip()\n# 'dobi'\n'db.kun.ac.cn'.strip('db.c')\n# 'kun.ac.cn'\n'db.kun.ac.cn'.strip('cbd.un')\n# 'kun.a'\nstatic str.maketrans(x[, y[, z]]); str.translate(table)\nmaktrans 是一个静态方法，用于生成一个对照表，以供 translate 使用。如果 maktrans 仅一个参数，则该参数必须是一个字典，字典的 key 要么是一个 Unicode 编码（一个整数），要么是一个长度为 1 的字符串，字典的 value 则可以是任意字符串、None或者 Unicode 编码。\na = 'dobi'\nord('o')\n# 111\n\nord('a')\n# 97\n\nhex(ord('狗'))\n# '0x72d7'\n\nb = {'d':'dobi', 111:' is ', 'b':97, 'i':'\\u72d7\\u72d7'}\ntable = str.maketrans(b)\n\na.translate(table)\n# 'dobi is a狗狗'\n如果 maktrans 有两个参数，则两个参数形成映射，且两个字符串必须是长度相等；如果有第三个参数，则第三个参数也必须是字符串，该字符串将自动映射到 None：\na = 'dobi is a dog'\n\ntable = str.maketrans('dobi', 'alph')\n\na.translate(table)\n# 'alph hs a alg'\n\ntable = str.maketrans('dobi', 'alph', 'o')\n\na.translate(table)\n# 'aph hs a ag'\n字符串的联合与分割\nstr.join(iterable)\n用指定的字符串，连接元素为字符串的可迭代对象。\n'-'.join(['2012', '3', '12'])\n# '2012-3-12'\n\n'-'.join([2012, 3, 12])\n# TypeError: sequence item 0: expected str instance, int found\n\n'-'.join(['2012', '3', b'12'])  #bytes 为非字符串\n# TypeError: sequence item 2: expected str instance, bytes found\n\n'-'.join(['2012'])\n# '2012'\n\n'-'.join([])\n# ''\n\n'-'.join([None])\n# TypeError: sequence item 0: expected str instance, NoneType found\n\n'-'.join([''])\n# ''\n\n','.join({'dobi':'dog', 'polly':'bird'})\n# 'dobi,polly'\n\n','.join({'dobi':'dog', 'polly':'bird'}.values())\n# 'dog,bird'\nstr.partition(sep); str.rpartition(sep)\n'dog wow wow jiao'.partition('wow')\n# ('dog ', 'wow', ' wow jiao')\n\n'dog wow wow jiao'.partition('dog')\n# ('', 'dog', ' wow wow jiao')\n\n'dog wow wow jiao'.partition('jiao')\n# ('dog wow wow ', 'jiao', '')\n\n'dog wow wow jiao'.partition('ww')\n# ('dog wow wow jiao', '', '')\n\n\n\n'dog wow wow jiao'.rpartition('wow')\nOut[131]: ('dog wow ', 'wow', ' jiao')\n\n'dog wow wow jiao'.rpartition('dog')\nOut[132]: ('', 'dog', ' wow wow jiao')\n\n'dog wow wow jiao'.rpartition('jiao')\nOut[133]: ('dog wow wow ', 'jiao', '')\n\n'dog wow wow jiao'.rpartition('ww')\nOut[135]: ('', '', 'dog wow wow jiao')\nstr.split(sep=None, maxsplit=-1); str.rsplit(sep=None, maxsplit=-1)\n'1,2,3'.split(','), '1, 2, 3'.rsplit()\n# (['1', '2', '3'], ['1,', '2,', '3'])\n\n'1,2,3'.split(',', maxsplit=1),  '1,2,3'.rsplit(',', maxsplit=1)\n# (['1', '2,3'], ['1,2', '3'])\n\n'1 2 3'.split(), '1 2 3'.rsplit()\n# (['1', '2', '3'], ['1', '2', '3'])\n\n'1 2 3'.split(maxsplit=1), '1 2 3'.rsplit(maxsplit=1)\n# (['1', '2 3'], ['1 2', '3'])\n\n'   1   2   3   '.split()\n# ['1', '2', '3']\n\n'1,2,,3,'.split(','), '1,2,,3,'.rsplit(',')\n# (['1', '2', '', '3', ''], ['1', '2', '', '3', ''])\n\n''.split()\n# []\n''.split('a')\n# ['']\n'bcd'.split('a')\n# ['bcd']\n'bcd'.split(None)\n# ['bcd']\nstr.splitlines([keepends])\n字符串以行界符为分隔符拆分为列表；当 keepends 为True，拆分后保留行界符，能被识别的行界符见官方文档。\n'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines()\n# ['ab c', '', 'de fg', 'kl']\n'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines(keepends=True)\n# ['ab c\\n', '\\n', 'de fg\\r', 'kl\\r\\n']\n\n\"\".splitlines()， ''.split('\\n')      #注意两者的区别\n# ([], [''])\n\"One line\\n\".splitlines()\n# (['One line'], ['Two lines', ''])\n字符串条件判断\nstr.endswith(suffix[, start[, end]]); str.startswith(prefix[, start[, end]])\ntext = 'outer protective covering'\n\ntext.endswith('ing')\n# True\n\ntext.endswith(('gin', 'ing'))\n# True\ntext.endswith('ter', 2, 5)\n# True\n\ntext.endswith('ter', 2, 4)\n# False\nstr.isalnum()\n字符串和数字的任意组合，即为真，简而言之：\n只要 c.isalpha(), c.isdecimal(), c.isdigit(), c.isnumeric() 中任意一个为真，则 c.isalnum() 为真。\n'dobi'.isalnum()\n# True\n\n'dobi123'.isalnum()\n# True\n\n'123'.isalnum()\n# True\n\n'徐'.isalnum()\n# True\n\n'dobi_123'.isalnum()\n# False\n\n'dobi 123'.isalnum()\n# False\n\n'%'.isalnum()\n# False\nstr.isalpha()\nUnicode 字符数据库中作为 “Letter”（这些字符一般具有 “Lm”, “Lt”, “Lu”, “Ll”, or “Lo” 等标识，不同于 Alphabetic） 的，均为真。\n'dobi'.isalpha()\n# True\n\n'do bi'.isalpha()\n# False\n\n'dobi123'.isalpha()\n# False\n\n'徐'.isalpha()\n# True\nstr.isdecimal(); str.isdigit(); str.isnumeric()\n三个方法的区别在于对 Unicode 通用标识的真值判断范围不同：\nisdecimal: Nd,isdigit:   No, Nd,isnumeric: No, Nd, Nl\ndigit 与 decimal 的区别在于有些数值字符串，是 digit 却非 decimal ，具体戳 这里\nnum = '\\u2155'\nprint(num)\n# ⅕\nnum.isdecimal(), num.isdigit(), num.isnumeric()\n# (False, False, True)\n\nnum = '\\u00B2'\nprint(num)\n# ²\nnum.isdecimal(), num.isdigit(), num.isnumeric()\n# (False, True, True)\n\nnum = \"1\"  #unicode\nnum.isdecimal(), num.isdigit(), num.isnumeric()\n# (Ture, True, True)\n\nnum = \"'Ⅶ'\" \nnum.isdecimal(), num.isdigit(), num.isnumeric()\n# (False, False, True)\n\nnum = \"十\"\nnum.isdecimal(), num.isdigit(), num.isnumeric()\n# (False, False, True)\n\nnum = b\"1\" # byte\nnum.isdigit()   # True\nnum.isdecimal() # AttributeError 'bytes' object has no attribute 'isdecimal'\nnum.isnumeric() # AttributeError 'bytes' object has no attribute 'isnumeric'\nstr.isidentifier()\n判断字符串是否可为合法的标识符。\n'def'.isidentifier()\n# True\n\n'with'.isidentifier()\n# True\n\n'false'.isidentifier()\n# True\n\n'dobi_123'.isidentifier()\n# True\n\n'dobi 123'.isidentifier()\n# False\n\n'123'.isidentifier()\n# False\nstr.islower()\n'徐'.islower()\n# False\n\n'ß'.islower()   #德语大写字母\n# False\n\n'a徐'.islower()\n# True\n\n'ss'.islower()\n# True\n\n'23'.islower()\n# False\n\n'Ab'.islower()\n# False\nstr.isprintable()\n判断字符串的所有字符都是可打印字符或字符串为空。Unicode 字符集中 “Other” “Separator” 类别的字符为不可打印的字符（但不包括 ASCII 的空格（0x20））。\n'dobi123'.isprintable()\n# True\n\n'dobi123\\n'.isprintable()\nOut[24]: False\n\n'dobi 123'.isprintable()\n# True\n\n'dobi.123'.isprintable()\n# True\n\n''.isprintable()\n# True\nstr.isspace()\n判断字符串中是否至少有一个字符，并且所有字符都是空白字符。\nIn [29]: '\\r\\n\\t'.isspace()\nOut[29]: True\n\nIn [30]: ''.isspace()\nOut[30]: False\n\nIn [31]: ' '.isspace()\nOut[31]: True\nstr.istitle()\n判断字符串中的字符是否是首字母大写，其会忽视非字母字符。\n'How Python Works'.istitle()\n# True\n\n'How Python WORKS'.istitle()\n# False\n\n'how python works'.istitle()\n# False\n\n'How Python  Works'.istitle()\n# True\n\n' '.istitle()\n# False\n\n''.istitle()\n# False\n\n'A'.istitle()\n# True\n\n'a'.istitle()\n# False\n\n'甩甩Abc Def 123'.istitle()\n# True\nstr.isupper()\n'徐'.isupper()\n# False\n\n'DOBI'.isupper()\nOut[41]: True\n\n'Dobi'.isupper()\n# False\n\n'DOBI123'.isupper()\n# True\n\n'DOBI 123'.isupper()\n# True\n\n'DOBI\\t 123'.isupper()\n# True\n\n'DOBI_123'.isupper()\n# True\n\n'_123'.isupper()\n# False\n字符串编码\nstr.encode(encoding=\"utf-8\", errors=\"strict\")\nfname = '徐'\n\nfname.encode('ascii')\n# UnicodeEncodeError: 'ascii' codec can't encode character '\\u5f90'...\n\nfname.encode('ascii', 'replace')\n# b'?'\n\nfname.encode('ascii', 'ignore')\n# b''\n\nfname.encode('ascii', 'xmlcharrefreplace')\n# b'&#24464;'\n\nfname.encode('ascii', 'backslashreplace')\n# b'\\\\u5f90'\n参考资料\nPython 内置类型字符串方法\n\n                ", "mainLikeNum": ["5 "], "mainBookmarkNum": "33"}