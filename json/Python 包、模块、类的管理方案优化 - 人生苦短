{"title": "Python 包、模块、类的管理方案优化 - 人生苦短 ", "index": "python", "content": "需要解决的问题\n在编写Python代码的过程中，为了更好的管理代码，我们会使用到包(package)、模块(module)、类(class)、函数(function)。介绍一下这几个概念：\n\n首先是模块，module可以简单理解为就是一个.py文件，这个文件里面可以包含类、变量、常量和函数等；\n然后是包，简单理解含有__init__.py的目录就算是一个包，需要明确的是在python中包其实是一种特殊的模块，但模块并不是包。原因其实很简单，sys.modules我们获取到的结果中包含包和模块，而module.__package__则会获取到包的信息；\n最后是类（函数在这里就不说了），类会写在.py文件中，一般为了控制文件的大小，通常将一个或几个有关联的类写在一个文件中。当然个人还是觉得一个类独占一个文件比较好，除非你想看见一大堆乱糟糟的代码挤在一个超大的文件里。\n\n然后再来看看我们日常使用包、模块和类的做法\n# 目录结构\n#|--demo.py\n#|--package_a\n#   |--__init__.py\n#   |--class_a.py  类ClassA\n#   |--class_b.py  类ClassB\n\n# ./demo.py\n\n# 导入方式一\nfrom package_a.class_a import ClassA\nfrom package_a.class_a import ClassB\na = ClassA()\nb = ClassB()\n\n# 导入方式二\nimport package_a.class_a as ca\nimport package_a.class_b as cb\na = ca.ClassA()\nb = cb.ClassB()\n好的，我们的问题来了，怎么样才能减少我们导入部分的代码呢？或者说怎么样才能使得一些相关联的模块不需要一个一个的进行导入呢？最终实现到下面的样子是不是会更好\n# ./demo.py\n\nfrom package_a import *\na = ClassA()\nb = ClassB()\n解决的方法\n# ./common.py\nimport sys\n\n_packet_ = {}\n# 装饰器，func是类或者函数\ndef export(func):\n    module = sys.modules[func.__module__]        # 获取func的模块对象\n    package = sys.modules[module.__package__]    # 由模块对象得到包对象\n    package.__dict__[func.__name__] = func       # 把func添加到包的__dict__里\n    # 生成所有使用该解决方案的包的__all__变量，并把导出的func添加进去\n    if not package.__name__ in _packet_:\n        _packet_[package.__name__] = []\n    _packet_[package.__name__].append(func.__name__)\n    # 原封不动地把func返回\n    return func\n\n# 在包的__init__.py里用于获取__all__\ndef packet(name):\n    if not name in _packet_:\n        _packet_[name] = []\n    return _packet_[name]\n实际使用\n# 目录结构\n#|--common.py（就是上面的装饰器文件）\n#|--demo.py\n#|--package_a\n#   |--__init__.py\n#   |--class_a.py  类ClassA\n#   |--class_b.py  类ClassB\n首先在模块中处理我们创建的类\n# ./package_a/class_a.py\n\nimport common\n\n# 使用export装饰器,装饰要导出的类或函数\n@common.export\nclass ClassB(object):\n    def __init__(self):\n        print 'This is ClassB.'\n然后在包的__init__.py中修改包自身\n# ./package_a/__init__.py\n\nimport common\n\n# 注意，这步很重要！！！导入将要导出的子模块，需要具体模块名字，此处import * 不可用\nfrom . import class_a, class_b\n\n# 用packet初始化包的__all__，主要是用于支持 \"from . import *\" 导入\n__all__ = common.packet(__name__)\n\n# 因为用__all__会影响\"from . import *\"。所以用export把__init__.py里的成员，加入__all__\n@common.export\ndef pafunc():\n    \"\"\" 这是一个包内部的函数 \"\"\"\n    print('pafunc')\n最终就可以实现我们前面所期望的导入方式了。\n# ./demo.py\n\nfrom package_a import *\na = ClassA()\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}