{"title": "Flask 源码剖析——服务启动篇 - young ", "index": "flask,python", "content": "【Flask官方文档经典示例】 hello.py\nfrom flask import Flask\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef hello():\n    return \"Hello World!\"\n\nif __name__ == \"__main__\":\n    app.run()\n输入以下命令启动应用程序：\n$ python hello.py\n * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)\n打开你的浏览器并在地址栏输入http://127.0.0.1:5000/ 。【图1-1】显示连接到应用程序后的浏览器。\n图1-1 hello.py Flask应用程序\n服务是怎么启动的\n从app.run()开始，这行代码表示启动一个服务。我们看到app是Flask一个对象，而run()是该对象的一个方法。我们先简单的认为定义了一个类，然后实例化这个类并调用该类的一个方法，如下：\n【示例1-1】example-1-1.py\nclass Flask(object):\n    def run(self):\n        pass\n\napp = Flask()\napp.run()\n如果我们运行【示例1-1】这段代码，会发现什么都没有发生。然而，【Flask官方文档经典示例】不是这样的，当你运行后它是下面这样的：\n$ python hello.py\n * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)\n很自然的可以想到，【Flask官方文档经典示例】中的app.run()不简单，我们可以看看run()方法定义，如下：\ndef run(self, host=None, port=None, debug=None, **options):\n    from werkzeug.serving import run_simple\n    ...\n    try:\n        run_simple(host, port, self, **options)\n    finally:\n        self._got_first_request = False\n在这个方法中，我们先忽略一些配置操作，重点关注run_simple()函数，发现该函数是从werkzeug.serving模块中导入的。\n到了这里我们就不得不提一下Werkzeug了，官方文档定义：Werkzeug是为Python设计的HTTP和WSGI实用程序库。至于它有什么作用，我们在这里暂且不讨论，先跟到代码里面看看它都做了什么。\n我们看到这个run_simple()函数里面还嵌套了一个inner()函数，里面有几行关键代码，如下：\nsrv = make_server(hostname, port, application, threaded, \n                  processes, request_handler, \n                  passthrough_errors, ssl_context, \n                  fd=fd)\n...\n srv.serve_forever()\n从上面的代码，我们看到在inner()函数里面调用了make_server()函数来创建一个类实例，该实例会调用serve_forever()方法让服务一直运行，等待客户端的请求。到这里我们大概找到了服务启动的入口了，想知道具体是怎么启动，我们还需要深入挖掘一下。\n因为调用run_simple()函数时参数threaded和processes给的都是默认值，分别为False和1，所以在这里make_server()函数其实是创建了一个BaseWSGIServer类实例，并调用该实例的serve_forever()方法，具体make_server()函数如下：\ndef make_server(host=None, port=None, app=None, threaded=False, processes=1,\n                request_handler=None, passthrough_errors=False,\n                ssl_context=None, fd=None):\n    if threaded and processes > 1:\n        raise ValueError(\"cannot have a multithreaded and \"\n                         \"multi process server.\")\n    elif threaded:\n        return ThreadedWSGIServer(host, port, app, request_handler,\n                                  passthrough_errors, ssl_context, fd=fd)\n    elif processes > 1:\n        return ForkingWSGIServer(host, port, app, processes, request_handler, \n                                 passthrough_errors, ssl_context, fd=fd)\n    else:\n        return BaseWSGIServer(host, port, app, request_handler, \n                              passthrough_errors, ssl_context, fd=fd)\n找到BaseWSGIServer类，如下代码：\nclass BaseWSGIServer(HTTPServer, object):\n    ...\n    def serve_forever(self):\n        self.shutdown_signal = False\n        try:\n            HTTPServer.serve_forever(self)\n        except KeyboardInterrupt:\n            pass\n        finally:\n            self.server_close()\n    ...\n【注意】接下来的代码嵌套调用比较多，所以最好是能对照着源码来看。\nsrv.serve_forever()其实是BaseWSGIServer类中的serve_forever()方法，然后我们发现BaseWSGIServer类继承了HTTPServer类，且BaseWSGIServer的serve_forever()方法中调用了HTTPServer的serve_forever()方法。找到HTTPServer类，如下代码：\nclass HTTPServer(SocketServer.TCPServer):\n    allow_reuse_address = 1\n    def server_bind(self):\n        SocketServer.TCPServer.server_bind(self)\n        host, port = self.socket.getsockname()[:2]\n        self.server_name = socket.getfqdn(host)\n        self.server_port = port\nHTTPServer类中并没有serve_forever()方法，且这个类继承了 SocketServer.TCPServer，我们再找到TCPServer类，然而它也没有serve_forever()方法，且这个类继承了BaseServer类，所以再去BaseServer里面看看，如下代码：\ndef serve_forever(self, poll_interval=0.5):\n    self.__is_shut_down.clear()\n    try:\n        while not self.__shutdown_request:\n            r, w, e = _eintr_retry(select.select, [self], [], [], poll_interval)\n            if self in r:\n                self._handle_request_noblock()\n    finally:\n        self.__shutdown_request = False\n        self.__is_shut_down.set()\n所以前面看到的srv.serve_forever()其实是调用了BaseServer里面的serve_forever()方法，它接受一个参数poll_interval，用于表示select轮询的时间。然后进入一个无限循环，调用select方式进行网络IO监听。也就是说app.run()启动的是一个BaseWSGIServer，该服务通过一层一层的继承创建socket来进行网络监听，等待客户端连接。\n至此，Flask服务是怎么启动的应该有个基本的了解了。\n整理一下相关server类的继承关系，如下：\nBaseWSGIServer-->HTTPServer-->SocketServer.TCPServer-->BaseServer\n从上面的类继承关系，我们可以很容易的理解，因为Flask是一个Web框架，所以需要一个HTTP服务，而HTTP服务是基于TCP服务的，而TCP服务最终会有一个基础服务来处理socket。这一条线都能够解释的通。但是，那个BaseWSGIServer是个什么鬼？为什么会需要一层这个服务？这也是我想要去研究的，所以我会在下一篇里面进行讲解。\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "18"}