{"title": " Python实用技法第4篇：实现优先级队列 - python3 ：公司内部培训专栏 ", "index": "python", "content": "上一篇文章：Python实用技法第3篇：找到最大或最小的N个元素下一篇文章：Python实用技法第5篇：一键多值字典\n\n1、需求🙀\n我们想要实现一个队列，它能够以给定的优先级来对元素排序，且每次pop操作时都会返回优先级最高的那个元素\n2、解决方案😸\n利用heapq模块实现\n代码：\nimport heapq\n\n#利用heapq实现一个简答的优先级队列\nclass PriorityQueue:\n    def __init__(self):\n        self._queue=[]\n        self._index=0\n    def push(self,item,priority):\n        heapq.heappush(self._queue,(-priority,self._index,item))\n        self._index+=1\n    def pop(self):\n        return heapq.heappop(self._queue)[-1]\n\nclass Item:\n    def __init__(self,name):\n        self.name=name\n\n    def __repr__(self):\n        return 'Item({!r})'.format(self.name)\n\nif __name__ == '__main__':\n    q=PriorityQueue()\n    q.push(Item('foo'),1)\n    q.push(Item('bar'),5)\n    q.push(Item('spam'),4)\n    q.push(Item('grok'),1)\n\n    print(q.pop())\n    print(q.pop())\n    #具有相同优先级的两个元素，返回的顺序同它们插入到队列时的顺序相同\n    print(q.pop())\n    print(q.pop())\n\n\n运行结果：\nItem('bar')\nItem('spam')\nItem('foo')\nItem('grok')\n上面的代码核心在于heapq模块的使用。函数heapq.heapqpush()以及heapq.heapqpop()分别实现将元素从列表_queue中插入和移除，且保证列表中第一个元素的优先级最低。heappop()方法总是返回【最小】的元素，因此这就是让队列能弹出正确元素的关键。此外，由于push和pop操作的复杂度都是O(logN),其中N代表堆中元素的数量，因此就算N的值很大，这些操作的效率也非常高。上面代码中，队列以元组(-priority ,index,item)的形式组成。把priority取负值是为了让队列能够按照元素的优先级从高到底的顺序排列。\n变量index的作用是为了将具有相同优先级的元素以适当的顺序排列。通过维护一个不断递增的索引，元素将以它们如队列时的顺序来排列。为了说明index的作用，看下面实例：\n\n代码：\nclass Item:\n    def __init__(self,name):\n        self.name=name\n\n    def __repr__(self):\n        return 'Item({!r})'.format(self.name)\n\nif __name__ == '__main__':\n    a=(1,Item('foo'))\n    b=(5,Item('bar'))\n    #下面一句打印True\n    print(a<b)\n\n\n    c=(1,Item('grok'))\n    #下面一句会报错：TypeError: '<' not supported between instances of 'Item' and 'Item'\n    print(c<a)\n\n\n    d=(1,0,Item('foo'))\n    e=(5,1,Item('bar'))\n    f=(1,2,Item('grok'))\n    #下面一句打印True\n    print(d<e)\n    #下面一句打印True\n    print(d<f)\n\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "0"}