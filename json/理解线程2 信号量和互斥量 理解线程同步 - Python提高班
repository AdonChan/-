{"title": "理解线程2 信号量和互斥量 理解线程同步 - Python提高班 ", "index": "python", "content": "线程同步\n\n了解线程信号量的基础知识，对深入理解python的线程会大有帮助。\n当两个线程同时执行时，不可避免同时操作同一个变量或者文件等，所以需要有一组机制来确保他们能正确的运行：信号量和互斥量。信号量可以分为最简单的“二进制信号量”和更通用的“计数信号量”。信号量通常用来保护一段代码，使其每次只能被一个执行线程运行，这种情况下需要用到二进制信号量。有时候希望可以允许有限数目的线程执行一段指定代码，这就需要用到计数信号量。实际上，技术信号量是一种二进制信号量的逻辑扩展，实际两者调用的函数一样。\n互斥量和信号量很相似，事实上他们可以互相通过对方来实现。但在实际应用中，对于一些情况使用其中一种更符合语义而且效果更好。\n用信号量进行同步\n\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <pthread.h>\n#include <semaphore.h>\n\nvoid *thread_function(void *arg);\nsem_t bin_sem;\n\n#define WORK_SIZE 1024\nchar work_area[WORK_SIZE];      /* 用来存放输入内容 */\n\nint main() {\n  int res;                    /* 暂存一些命令的返回结果 */\n  pthread_t a_thread;         /* 织带新建的线程 */\n  void *thread_result;       /* 存放线程处理结果 */\n\n  res = sem_init(&bin_sem, 0, 0);   /* 初始化信号量，并且设置初始值为0*/\n  if (res != 0) {\n    perror(\"Semaphore initialization failed\");\n    exit(EXIT_FAILURE);\n  }\n  res = pthread_create(&a_thread, NULL, thread_function, NULL);   /* 创建新线程 */\n  if (res != 0) {\n    perror(\"Thread creation failed\");\n    exit(EXIT_FAILURE);\n  }\n  printf(\"Inout some text, Enter 'end' to finish\\n\");\n  while(strncmp(\"end\", work_area, 3) != 0) {             /* 当工作区内不是以end开头的字符串时...*/\n    fgets(work_area, WORK_SIZE, stdin);                  /* 从标准输入获取输入到worl_area */\n    sem_post(&bin_sem);                                  /* 信号量+1 */\n  }\n  printf(\"\\nWaiting for thread to finish...\\n\");\n  res = pthread_join(a_thread, &thread_result);         /* 等待线程结束 */\n  if (res != 0) {\n    perror(\"Thread join failed\");\n    exit(EXIT_FAILURE);\n  }\n  printf(\"Thread joined\\n\");\n  sem_destroy(&bin_sem);                               /* 销毁信号量 */\n  exit(EXIT_SUCCESS);\n}\n\nvoid *thread_function(void *arg) {\n  sem_wait(&bin_sem);                                 /* 等待信号量有大于0的值然后-1 */\n  while(strncmp(\"end\", work_area, 3) != 0) {\n    printf(\"You input %ld characters\\n\", strlen(work_area)-1);   /* 获取输入字符串长度 8*/\n    sem_wait(&bin_sem);                               /* 等待信号量有大于0的值然后-1 */\n  }\n  pthread_exit(NULL);\n}\n\n用互斥量进行同步\n\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <pthread.h>\n#include <semaphore.h>\n\nvoid *thread_function(void *arg);\npthread_mutex_t work_mutex;\n\n#define WORK_SIZE 1024\nchar work_area[WORK_SIZE];\nint time_to_exit = 0;                           /* 用来控制TODO*/\n\nint main() {\n  int res;\n  pthread_t a_thread;\n  void *thread_result;\n\n  res = pthread_mutex_init(&work_mutex,NULL);    /* 初始化一个互斥锁 */\n  if (res != 0) {\n    perror(\"Mutex initialization failed\");\n    exit(EXIT_FAILURE);\n  }\n  res = pthread_create(&a_thread, NULL, thread_function, NULL);  /* 创建一个新线程 */\n  if (res != 0) {\n    perror(\"Thread creation failed\");\n    exit(EXIT_FAILURE);\n  }\n  pthread_mutex_lock(&work_mutex);                       /* 尝试对互斥量加锁 */\n  printf(\"Input some text, Enter 'end' to finish\\n\");\n  while(!time_to_exit) {                                   /* 检查是不是该退出*/\n    fgets(work_area, WORK_SIZE, stdin);                   /* 从标准输入获取输入到work_area */\n    pthread_mutex_unlock(&work_mutex);                   /* 解锁互斥量 */\n    while(1) {\n      pthread_mutex_lock(&work_mutex);\n      if (work_area[0] != '\\0') {                      /* 持续检查work_area 是否为空, 如果不为空继续等待，如果为空，则重新读取输入到work_area*/\n        pthread_mutex_unlock(&work_mutex);\n        sleep(1);\n      }\n      else {\n        break;\n      }\n    }\n  }\n  pthread_mutex_unlock(&work_mutex);\n  printf(\"\\nWaiting for thread to finish...\\n\");\n  res = pthread_join(a_thread, &thread_result);\n  if (res != 0) {\n    perror(\"Thread join failed\");\n    exit(EXIT_FAILURE);\n  }\n  printf(\"Thread joined\\n\");\n  pthread_mutex_destroy(&work_mutex);\n  exit(EXIT_SUCCESS);\n}\n\nvoid *thread_function(void *arg) {\n  sleep(1);\n  pthread_mutex_lock(&work_mutex);                     /* 尝试加锁互斥量 */\n  while(strncmp(\"end\", work_area, 3) != 0) {           /* 当work_area里的值不是以end开头时*/\n    printf(\"You input %ld characters\\n\", strlen(work_area) -1);     /* 输出输入的字符长度 */\n    work_area[0] = '\\0';                                      /* work_area设置为空 */\n    pthread_mutex_unlock(&work_mutex);\n    sleep(1);\n    pthread_mutex_lock(&work_mutex);\n    while (work_area[0] == '\\0') {              /* 持续检查work_area 直到它里面有输入值*/\n      pthread_mutex_unlock(&work_mutex);\n      sleep(1);\n      pthread_mutex_lock(&work_mutex);\n    }\n  }\n  time_to_exit = 1;                        /* 当输入end后，设置退出标志 */\n  work_area[0] = '\\0';\n  pthread_mutex_unlock(&work_mutex);\n  pthread_exit(0);\n}\n\n参考资料\n\n《Beginning Linux Programming》\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "1"}