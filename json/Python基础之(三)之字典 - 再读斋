{"title": "Python基础之(三)之字典 - 再读斋 ", "index": "python", "content": "定义\nPython中有一个叫作dictionary的对象类型，翻译过来就是“字典”，用dict表示。\n创建字典\n创建空的字典\n>>> mydict = {}\n>>> mydict\n{}\n>>> type(mydict)\n<type 'dict'>\n>>> person={\"name\":\"liu\",\"sex\":\"male\",\"age\":10}\n>>> person\n{'age': 10, 'name': 'liu', 'sex': 'male'}\n字典dict是以键值对的形式存储数据。比如\"name\":\"liu\"前面的name叫作键（key），后面的liu是前面的键所对应的值（value）。在一个字典中，键是唯一的，不能重复。值则对应于键，值可以重复。\n键值之间用冒号隔开，每一对键值之间用逗号隔开。\n添加字典\n>>> person\n{'age': 10, 'name': 'liu', 'sex': 'male'}\n>>> person[\"hobby\"]=\"reading\" #增加键值对的方法\n>>> person\n{'hobby': 'reading', 'age': 10, 'name': 'liu', 'sex': 'male'}\n修改字典\n>>> person[\"age\"]=20\n>>> person\n{'hobby': 'reading', 'age': 20, 'name': 'liu', 'sex': 'male'}\n>>> id(person)\n49368784\n>>> person[\"age\"]=30\n>>> person\n{'hobby': 'reading', 'age': 30, 'name': 'liu', 'sex': 'male'}\n>>> id(person)\n49368784\n结果可以看出，字典可以原地地修改，即它是可变的，并且不会创建新的对象。\n利用元组创建字典\n>>> name = ([\"first\",\"Google\"],[\"second\",\"Yahoo\"])\n>>> website=dict(name)\n>>> website\n{'second': 'Yahoo', 'first': 'Google'}\n>>> type(website)\n<type 'dict'>\n\n或者这样：\n\n>>> ad = dict(name=\"liu\",age= 26)\n>>> ad\n{'age': 26, 'name': 'liu'}\n>>> type(ad)\n<type 'dict'>\n使用fromkeys创建字典\n>>> website={}.fromkeys((\"third\",\"forth\"),(\"facebook\",\"amazon\"))\n>>> website\n{'forth': ('facebook', 'amazon'), 'third': ('facebook', 'amazon')}\n>>> website={}.fromkeys((\"third\",\"forth\"),\"facebook\")\n>>> website\n{'forth': 'facebook', 'third': 'facebook'}\n特别注意的是，字典中的键必须是不可变对象，值可以是任意类的对象。\n>>> dd = {(1,2):1}\n>>> dd\n{(1, 2): 1}\n>>> type(dd)\n<type 'dict'>\n\n>>> dd={[1,2]:1}\n\nTraceback (most recent call last):\n  File \"<pyshell#52>\", line 1, in <module>\n    dd={[1,2]:1}\nTypeError: unhashable type: 'list'\n访问字典的值\n字典类型的对象是以键值对的形式存储数据的，所以只要知道键就能得到值，这在本质上就是一种映射关系。\n>>> person\n{'hobby': 'reading', 'age': 30, 'name': 'liu', 'sex': 'male'}\n>>> person[\"age\"]\n30\n>>> person[\"hobby\"]\n'reading'\n基本操作\nlen(d)\n返回字典d中键值对的数量\n>>> city_code = {\"beijing\":\"010\",\"shanghai\":\"021\",\"guangzhou\":\"020\"}\n>>> len(city_code)\n3\nd[key]\n返回字典d中的键key的值\n>>> city_code\n{'beijing': '010', 'shanghai': '021', 'guangzhou': '020'}\n>>> city_code[\"beijing\"]\n'010'\nd[key] = value\n将值赋给字典d中的键key\n>>> city_code\n{'beijing': '010', 'shanghai': '021', 'guangzhou': '020'}\n>>> city_code[\"beijing\"]=\"01110\"\n>>> city_code\n{'beijing': '01110', 'shanghai': '021', 'guangzhou': '020'}\ndel d[key]\n删除字典d中的键key值对\n>>> city_code\n{'beijing': '01110', 'shanghai': '021', 'guangzhou': '020'}\n>>> del city_code[\"beijing\"]\n>>> city_code\n{'shanghai': '021', 'guangzhou': '020'}\nkey in d\n检查字典d中是否含有键为key的项\n>>> city_code\n{'shanghai': '021', 'guangzhou': '020'}\n>>> \"shanghai\" in city_code\nTrue\n>>> \"beijing\" in city_code\nFalse\n字符串格式化输出\n>>> city_code\n{'shanghai': '021', 'guangzhou': '020'}\n>>> \"Shanghai is a wonderful city,its area code is %(shanghai)s\" % city_code\n'Shanghai is a wonderful city,its area code is 021'\n相关概念\n关联数组\n在计算机科学中，关联数组又称为映射（Map）、字典（Dictionary），是一个抽象的数据结构，它包含着类似于键值的有序对。这种数据结构包含以下几种常见的操作：\n\n向关联数组添加键值对\n从关联数组内删除键值对\n修改关联数组内的键值对\n根据已知的键寻找值\n\n字典问题是设计一种能够具备关联数组特性的数据结构。解决字典问题的常用方法是散列表，但有些情况也可以直接使用有地址的数组、二叉树，或者其他结构。\n散列表\n散列表（hash table，也叫哈希表），是根据关键字而直接访问在内存存储位置的数据结构。即把键值通过一个函数的计算，映射到表中的一个位置来访问记录，加快了查找速度。这个映射函数称为散列函数，存放记录的数组称为散列表。\n字典的函数\n拷贝\n浅拷贝：Python在所执行的复制动作中，如果是基本类型的数据，就在内存中新建一个地址存储，如果不是基本类型，就不会新建一个地址，而是用标签引用原来的对象。copy()实现的是浅拷贝\n深拷贝：无论是基本数据类型还是其他类型都会新建一个地址来存储。deepcopy()实现的是深拷贝\ncopy()\n>>> ad={\"name\":\"liu\",\"age\":20}\n>>> id(ad)\n49368640\n>>> cd= ad.copy()\n>>> cd\n{'age': 20, 'name': 'liu'}\n>>> id(cd)  #与ad是不同的对象\n49225776\n>>> cd[\"age\"]=40  #修改cd没有对ad造成影响\n>>> cd\n{'age': 40, 'name': 'liu'}\n>>> ad\n{'age': 20, 'name': 'liu'}\n\n>>> x={\"name\":\"liu\",\"lang\":[\"python\",\"java\",\"c\"]}\n>>> y = x.copy()\n>>> y\n{'lang': ['python', 'java', 'c'], 'name': 'liu'}\n>>> id(x)\n49226496\n>>> id(y)\n49228800\n\n##y是从x拷贝过来的，两个在内存中是不同的对象\n\n>>> y[\"lang\"].remove(\"c\")\n>>> y\n{'lang': ['python', 'java'], 'name': 'liu'}\n>>> x\n{'lang': ['python', 'java'], 'name': 'liu'}\n>>> id(x)\n49226496\n>>> id(y)\n49228800\n\ny中删除元素“c“后，x的键lang的值也发生了变化\n\n>>> id(x[\"lang\"])\n49607424\n>>> id(y[\"lang\"])\n49607424\n\nx与y中的列表是同一个对象，但是作为字符串的那个键值对属于不同的对象。\ndeepcopy()\n>>> x\n{'lang': ['python', 'java'], 'name': 'liu'}\n>>> import copy #导入一个模块\n>>> z = copy.deepcopy(x) #深拷贝\n>>> z\n{'lang': ['python', 'java'], 'name': 'liu'}\n>>> id(x[\"lang\"])\n49607424\n>>> id(z[\"lang\"])\n49607184\n\n#此时x和z中的列表不属于同个对象\n\n>>>\n>>> x[\"lang\"].remove(\"java\")\n>>> x\n{'lang': ['python'], 'name': 'liu'}\n>>> z\n{'lang': ['python', 'java'], 'name': 'liu'}\n\n#此时，修改一个列表的值，就不会影响另外一个列表的值了。\nclear\nclear的作用是将字典清空，得到的是空字典。del是将字典删除，内存中就没有它了。\n>>> x\n{'lang': ['python'], 'name': 'liu'}\n>>> x.clear()\n>>> x\n{}\n>>> del a\n\n>>> del x\n>>> x  #x已删除\n\nTraceback (most recent call last):\n  File \"<pyshell#147>\", line 1, in <module>\n    x\nNameError: name 'x' is not defined\n>>>\n如果要清空一个字典，还能够使用x = {}这种方法，但这种方法的本质是将变量a的引用转向了{}这个对象，那么原来的对象呢？原来的对象称为了断了线的风筝，这样的东西称为在Python中称为垃圾，而且Python能够自动将这样的垃圾回收。\nget和setdefault\n得到字典中的某个值\nget\n>>> z\n{'lang': ['python', 'java'], 'name': 'liu'}\n>>> z[\"lang\"].remove(\"java\")\n>>> z\n{'lang': ['python'], 'name': 'liu'}\n>>> \n>>> z.get(\"name\")\n'liu'\n\n>>> print z.get(\"age\") #返回None\nNone\n>>> d[\"age\"]  #抛出异常\nTraceback (most recent call last):\n  File \"<pyshell#160>\", line 1, in <module>\n    d[\"age\"]\nNameError: name 'd' is not defined\n\n>>> z.get(\"age\",30) #如果age不存在，则返回默认值30\n30\n\ndict.get()和dict[key]的区别在于：如果键不在字典中，前者返回None，后者抛出异常\nsetdefault\n>>> z\n{'lang': ['python'], 'name': 'liu'}\n>>> z.setdefault(\"age\",30)  #如果age不存在，则返回默认值30，同时将这对键值对添加到字典中\n30\n>>> z\n{'lang': ['python'], 'age': 30, 'name': 'liu'}\n\n>>> z.setdefault(\"web\")\n>>> z\n{'lang': ['python'], 'web': None, 'age': 30, 'name': 'liu'}\nitems/iteritems,keys/iterkeys,values/itervalues\n>>> dd = {\"name\":\"liu\",\"age\":40,\"websit\":\"www.liuguoquan.com\"}\n>>> dd_kv = dd.items()\n>>> dd_kv\n[('websit', 'www.liuguoquan.com'), ('age', 40), ('name', 'liu')]\n>>> type(dd_kv)\n<type 'list'>\n>>> list(dd_kv)\n[('websit', 'www.liuguoquan.com'), ('age', 40), ('name', 'liu')]\n\n>>> dd_iter=dd.iteritems()\n>>> type(dd_iter)\n<type 'dictionary-itemiterator'>\n>>> dd_iter\n<dictionary-itemiterator object at 0x02F5F420>\n>>> list(dd_iter)  #必须用list()迭代遍历\n[('websit', 'www.liuguoquan.com'), ('age', 40), ('name', 'liu')]\n\n>>> dd\n{'websit': 'www.liuguoquan.com', 'age': 40, 'name': 'liu'}\n>>> dd.keys() #列出键的列表\n['websit', 'age', 'name']\n\n>>> dd.values() #列出值的列表\n['www.liuguoquan.com', 40, 'liu']\npop和popitem\n删除字典键值对\n>>> dd\n{'websit': 'www.liuguoquan.com', 'age': 40, 'name': 'liu'}\n>>> dd.pop(\"name\") #删除指定键\n'liu'\n\n>>> dd\n{'websit': 'www.liuguoquan.com', 'age': 40}\n>>> dd.pop() #参数不能省略\n\nTraceback (most recent call last):\n  File \"<pyshell#198>\", line 1, in <module>\n    dd.pop()\nTypeError: pop expected at least 1 arguments, got 0\n\n\n>>> dd\n{'websit': 'www.liuguoquan.com', 'age': 40}\n>>> dd.popitem() #随机删除一个键值对\n('websit', 'www.liuguoquan.com')\n\n>>> dd\n{'age': 40}\n>>> dd.popitem()\n('age', 40)\n\n>>> dd\n{}\nupdate\n更新字典\n>>> d1={\"name\":\"liu\"}\n>>> d2={\"age\":20}\n>>> d1.update(d2) #将字典到d2添加到d1中，更新字典\n>>> d1\n{'age': 20, 'name': 'liu'}\n>>> d2\n{'age': 20}\n\n>>> d2.update([(\"name\",\"lee\"),(\"lang\",\"python\")]) #更新字典\n>>> d2\n{'lang': 'python', 'age': 20, 'name': 'lee'}\nhas_key\n判断字典中是否存在某个键\n>>> d2\n{'lang': 'python', 'age': 20, 'name': 'lee'}\n>>> d2.has_key(\"name\")\nTrue\n>>> d2.has_key(\"web\")\nFalse\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "5"}