{"title": "SCrapy爬虫大战京东商城 - 个人文章 ", "index": "python", "content": "SCrapy爬虫大战京东商城\n引言\n上一篇已经讲过怎样获取链接，怎样获得参数了，详情请看python爬取京东商城普通篇\n代码详解\n首先应该构造请求，这里使用scrapy.Request,这个方法默认调用的是start_urls构造请求，如果要改变默认的请求，那么必须重载该方法，这个方法的返回值必须是一个可迭代的对象，一般是用yield返回，代码如下：\n    def start_requests(self):\n        for i in range(1,101):\n            page=i*2-1    #这里是构造请求url的page,表示奇数\n            url=self.start_url+str(page)\n            yield scrapy.Request(url,meta={'search_page':page+1},callback=self.parse_url)   #这里使用meta想回调函数传入数据，回调函数使用response.meta['search-page']接受数据\n下面就是解析网页了，从上面看出这里的解析回调函数是parse_url,因此在此函数中解析网页。这里还是和上面说的一样，这个url得到的仅仅是前一半的信息，如果想要得到后一半的信息还有再次请求，这里还有注意的就是一个技巧：一般先解析出一个数据的数组，不急着取出第一个数，先要用if语句判断，因为如果得到的是[]，那么直接取出[0]是会报错的，这只是一个避免报错的方法吧，代码如下:\n    def parse_url(self,response):\n        if response.status==200:   #判断是否请求成功\n            # print response.url\n            pids = set()    #这个集合用于过滤和保存得到的id,用于作为后面的ajax请求的url构成\n            try:\n                all_goods = response.xpath(\"//div[@id='J_goodsList']/ul/li\")   #首先得到所有衣服的整个框架，然后从中抽取每一个框架\n\n                for goods in all_goods:   #从中解析每一个\n                    # scrapy.shell.inspect_response(response,self)   #这是一个调试的方法，这里会直接打开调试模式\n                    items = JdSpiderItem()   #定义要抓取的数据\n                    img_url_src = goods.xpath(\"div/div[1]/a/img/@src\").extract()  # 如果不存在就是一个空数组[]，因此不能在这里取[0]\n                    img_url_delay = goods.xpath(\n                        \"div/div[1]/a/img/@data-lazy-img\").extract()  # 这个是没有加载出来的图片，这里不能写上数组取第一个[0]\n                    price = goods.xpath(\"div/div[3]/strong/i/text()\").extract()  #价格\n                    cloths_name = goods.xpath(\"div/div[4]/a/em/text()\").extract()\n                    shop_id = goods.xpath(\"div/div[7]/@ data-shopid\").extract()\n                    cloths_url = goods.xpath(\"div/div[1]/a/@href\").extract()\n                    person_number = goods.xpath(\"div/div[5]/strong/a/text()\").extract()\n                    pid = goods.xpath(\"@data-pid\").extract()\n                    # product_id=goods.xpath(\"@data-sku\").extract()\n                    if pid:\n                        pids.add(pid[0])\n                    if img_url_src:  # 如果img_url_src存在\n                        print img_url_src[0]\n                        items['img_url'] = img_url_src[0]\n                    if img_url_delay:  # 如果到了没有加载完成的图片，就取这个url\n                        print img_url_delay[0]\n                        items['img_url'] = img_url_delay[0]  # 这里如果数组不是空的，就能写了\n                    if price:\n                        items['price'] = price[0]\n                    if cloths_name:\n                        items['cloths_name'] = cloths_name[0]\n                    if shop_id:\n                        items['shop_id'] = shop_id[0]\n                        shop_url = \"https://mall.jd.com/index-\" + str(shop_id[0]) + \".html\"\n                        items['shop_url'] = shop_url\n                    if cloths_url:\n                        items['cloths_url'] = cloths_url[0]\n                    if person_number:\n                        items['person_number'] = person_number[0]\n                    # if product_id:\n                    #     print \"************************************csdjkvjfskvnk***********************\"\n                    #     print self.comments_url.format(str(product_id[0]),str(self.count))\n                    #     yield scrapy.Request(url=self.comments_url.format(str(product_id[0]),str(self.count)),callback=self.comments)\n                    #yield scrapy.Request写在这里就是每解析一个键裤子就会调用回调函数一次\n                    yield items\n            except Exception:\n                print \"********************************************ERROR**********************************************************************\"\n\n            yield scrapy.Request(url=self.search_url.format(str(response.meta['search_page']),\",\".join(pids)),callback=self.next_half_parse)    #再次请求，这里是请求ajax加载的数据，必须放在这里，因为只有等到得到所有的pid才能构成这个请求，回调函数用于下面的解析\n从上面代码的最后可以看出最后就是解析ajax加载的网页了，这里调用的next_half_parse函数，和解析前面一个网页一样，这里需要的注意的是，如果前面定义的数据没有搜索完毕是不能使用yield items的，必须将items通过meta传入下一个回调函数继续完善后才能yield items,这里就不需要了，代码如下：\n#分析异步加载的网页\n    def next_half_parse(self,response):\n        if response.status==200:\n            print response.url\n            items=JdSpiderItem()\n            #scrapy.shell.inspect_response(response,self)    #y用来调试的\n            try:\n                lis=response.xpath(\"//li[@class='gl-item']\")\n                for li in lis:\n                    cloths_url=li.xpath(\"div/div[1]/a/@href\").extract()\n                    img_url_1=li.xpath(\"div/div[1]/a/img/@src\").extract()\n                    img_url_2=li.xpath(\"div/div[1]/a/img/@data-lazy-img\").extract()\n                    cloths_name=li.xpath(\"div/div[4]/a/em/text()\").extract()\n                    price=li.xpath(\"div/div[3]/strong/i/text()\").extract()\n                    shop_id=li.xpath(\"div/div[7]/@data-shopid\").extract()\n                    person_number=li.xpath(\"div/div[5]/strong/a/text()\").extract()\n                    if cloths_url:\n                        print cloths_url[0]\n                        items['cloths_url']=cloths_url[0]\n                    if img_url_1:\n                        print img_url_1[0]\n                        items['img_url']=img_url_1\n                    if img_url_2:\n                        print img_url_2[0]\n                        items['img_url']=img_url_2[0]\n                    if cloths_name:\n                        items['cloths_name']=cloths_name[0]\n                    if price:\n                        items['price']=price[0]\n                    if shop_id:\n                        items['shop_id']=shop_id[0]\n                        items['shop_url']=\"https://mall.jd.com/index-\" + str(shop_id[0]) + \".html\"\n                    if person_number:\n                        items['person_number']=person_number[0]\n                    yield items   #又一次的生成，这里是完整的数据，因此可以yield items\n            except Exception:\n                print \"**************************************************\"\n当然这里还用到了设置请求池，mysql存储，没有使用到ip代理，这个在我前面的博客中又讲到，这里就不再赘述了，想看源代码的朋友请点击这里\n小技巧\n\n人们会抱怨为什么自己的爬虫在中途断开就要重头开始爬，为什么不能从断开那里开始爬呢，这里提供一个方法：在配置文件settings.py中加入JOBDIR=file_name,这里的file_name是一个文件的名字\n设置下载延迟防止被ban:DOWNLOAD_DELAY = 2:设置每一次的间隔时间   RANDOMIZE_DOWNLOAD_DELAY = True:这个是随机设置延迟时间  在设置的时间的0.5-1.5倍之间，这样可以更有效的防止被ban,一般是配套使用的\nROBOTSTXT_OBEY = False :这里是表示不遵循robots.txt文件，默认是True表示遵循，这里将之改成False\nCONCURRENT_REQUESTS :设置最大请求数，这里默认的时16，我们可以根据自己电脑的配置改的大一点来加快请求的速度\n\n更多文章请看本人博客\n\n                ", "mainLikeNum": ["1 "], "mainBookmarkNum": "1"}