{"title": "TensorFlow学习笔记（11）：数据操作指南 - 数据实验室 ", "index": "tensorflow,python,机器学习", "content": "引言\n用TensorFlow做好一个机器学习项目，需要具备多种代码能力：\n\n工程开发能力：怎么读取数据、怎么设计与运行Computation Graph、怎么保存与恢复变量、怎么保存统计结果、怎么共享变量、怎么分布式部署\n数据操作能力：怎么将原始数据一步步转化为模型需要的数据，中间可能涉及到Tensor转换、字符串处理、JSON处理等\n模型理论知识：线性回归，逻辑回归，softmax regression，支持向量机，决策树，随机森林，GBDT，CNN，RNN\n数值计算理论知识：交叉熵数值计算的潜在问题（为什么要用tf.nn.softmax_cross_entropy_with_logits），梯度下降法，海森矩阵与特征向量，牛顿法，Adam梯度法。\n\n本系列文章已对TensorFlow的工程开发和与模型理论知识的结合做了较多的总结。本文的目的是聚焦于数据操作能力，讲述TensorFlow中比较重要的一些API，帮助大家实现各自的业务逻辑。\nTensor Transformation\n拼接\nTensorFlow提供两种类型的拼接：\n\ntf.concat(values, axis, name='concat')：按照指定的已经存在的轴进行拼接\ntf.stack(values, axis=0, name='stack')：按照指定的新建的轴进行拼接\n\nt1 = [[1, 2, 3], [4, 5, 6]]\nt2 = [[7, 8, 9], [10, 11, 12]]\ntf.concat([t1, t2], 0) ==> [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]\ntf.concat([t1, t2], 1) ==> [[1, 2, 3, 7, 8, 9], [4, 5, 6, 10, 11, 12]]\ntf.stack([t1, t2], 0)  ==> [[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]]\ntf.stack([t1, t2], 1)  ==> [[[1, 2, 3], [7, 8, 9]], [[4, 5, 6], [10, 11, 12]]]\ntf.stack([t1, t2], 2)  ==> [[[1, 7], [2, 8], [3, 9]], [[4, 10], [5, 11], [6, 12]]]\n上面的结果读起来不太直观，我们从shape角度看一下就很容易明白了：\nt1 = [[1, 2, 3], [4, 5, 6]]\nt2 = [[7, 8, 9], [10, 11, 12]]\ntf.concat([t1, t2], 0)  # [2,3] + [2,3] ==> [4, 3]\ntf.concat([t1, t2], 1)  # [2,3] + [2,3] ==> [2, 6]\ntf.stack([t1, t2], 0)   # [2,3] + [2,3] ==> [2*,2,3]\ntf.stack([t1, t2], 1)   # [2,3] + [2,3] ==> [2,2*,3]\ntf.stack([t1, t2], 2)   # [2,3] + [2,3] ==> [2,3,2*]\n抽取\n\ntf.slice(input_, begin, size, name=None)：按照指定的下标范围抽取连续区域的子集\ntf.gather(params, indices, validate_indices=None, name=None)：按照指定的下标集合从axis=0中抽取子集，适合抽取不连续区域的子集\n\ninput = [[[1, 1, 1], [2, 2, 2]],\n         [[3, 3, 3], [4, 4, 4]],\n         [[5, 5, 5], [6, 6, 6]]]\ntf.slice(input, [1, 0, 0], [1, 1, 3]) ==> [[[3, 3, 3]]]\ntf.slice(input, [1, 0, 0], [1, 2, 3]) ==> [[[3, 3, 3],\n                                            [4, 4, 4]]]\ntf.slice(input, [1, 0, 0], [2, 1, 3]) ==> [[[3, 3, 3]],\n                                           [[5, 5, 5]]]\n                                           \ntf.gather(input, [0, 2]) ==> [[[1, 1, 1], [2, 2, 2]],\n                              [[5, 5, 5], [6, 6, 6]]]\n假设我们要从input中抽取[[[3, 3, 3]]]，这个输出在inputaxis=0的下标是1，axis=1的下标是0，axis=2的下标是0-2，所以begin=[1,0,0]，size=[1,1,3]。\n假设我们要从input中抽取[[[3, 3, 3], [4, 4, 4]]]，这个输出在inputaxis=0的下标是1，axis=1的下标是0-1，axis=2的下标是0-2，所以begin=[1,0,0]，size=[1,2,3]。\n假设我们要从input中抽取[[[3, 3, 3], [5, 5, 5]]]，这个输出在inputaxis=0的下标是1-2，axis=1的下标是0，axis=2的下标是0-2，所以begin=[1,0,0]，size=[2,1,3]。\n假设我们要从input中抽取[[[1, 1, 1], [2, 2, 2]],[[5, 5, 5], [6, 6, 6]]]，这个输出在input的axis=0的下标是[0, 2]，不连续，可以用tf.gather抽取。\n类型转化\n\ntf.string_to_number(string_tensor, out_type=None, name=None): 将字符串转化为tf.float32（默认）和tf.int32\ntf.to_double(x, name='ToDouble')：转化为tf.float64\ntf.to_float(x, name='ToFloat')：转化为tf.float32\ntf.to_int32(x, name='ToInt32')：转化为tf.int32\ntf.to_int64(x, name='ToInt64')：转化为tf.int64\ntf.cast(x, dtype, name=None)：转化为dtype指定的类型\n\n形状转化\ntf.reshape(tensor, shape, name=None)：转化为新shape，若有一个维度设置为-1，会自动推导\nSparseTensor\nTensorFlow使用三个dense tensor来表达一个sparse tensor：indices、values、dense_shape。\n假如我们有一个dense tensor：\n[[1, 0, 0, 0]\n [0, 0, 2, 0]\n [0, 0, 0, 0]]\n那么用SparseTensor表达这个数据对应的三个dense tensor如下：\n\nindices：[[0, 0], [1, 2]]\nvalues：[1, 2]\ndense_shape：[3, 4]\n\n可以通过以下两种方法，将sparse tensor转化为dense tensor：\n\ntf.sparse_to_dense(sparse_indices, output_shape, sparse_values, default_value=0, validate_indices=True, name=None)\ntf.sparse_tensor_to_dense(sp_input, default_value=0, validate_indices=True, name=None)\n\n字符串操作\n拆分\ntf.string_split(source, delimiter=' ')\nsource是一维数组，用于将一组字符串按照delimiter拆分为多个元素，返回值为一个SparseTensor。\n假如有两个字符串，source[0]是“hello world”，source[1]是“a b c”，那么输出结果如下：\n\nst.indices： [0, 0; 0, 1; 1, 0; 1, 1; 1, 2]\nst.values： ['hello', 'world', 'a', 'b', 'c']\nst.dense_shape：[2, 3]\n\n拼接\ntf.string_join(inputs, separator=None, name=None)，用起来比较简单：\ntf.string_join([\"hello\", \"world\"], separator=\" \") ==> \"hello world\"\n自定义op\n通过tf.py_func(func, inp, Tout, stateful=True, name=None)可以将任意的python函数func转变为TensorFlow op。\nfunc接收的输入必须是numpy array，可以接受多个输入参数；输出也是numpy array，也可以有多个输出。inp传入输入值，Tout指定输出的基本数据类型。\n先看一个解析json的例子，输入是一个json array，输出是一个特征矩阵。\nimport tensorflow as tf\nimport numpy as np\nimport json\n\njson_str_1 = '''\n{\"name\": \"shuiping.chen\",\n\"score\": 95,\n\"department\": \"industrial engineering\",\n\"rank\": 2\n}\n'''\njson_str_2 = '''\n{\"name\": \"zhuibing.dan\",\n\"score\": 87,\n\"department\": \"production engineering\",\n\"rank\": 4\n}\n'''\n\ninput_array = np.array([json_str_1, json_str_2])\n\ndef parse_json(json_str_array):\n    fea_dict_array = [ json.loads(item) for item in json_str_array ]\n    ret_feature = []\n    for fea_dict in fea_dict_array:\n        feature = [fea_dict[\"score\"], fea_dict[\"rank\"]]\n        ret_feature.append(feature)\n    return np.array(ret_feature, dtype=np.float32)\n\nparse_json_op = tf.py_func(parse_json, [input_array], tf.float32)\nsess = tf.Session()\nprint sess.run(parse_json_op)\n再看一个多输入多输出的例子，输入两个numpy array，输出三个array，分别是和、差、乘积。\narray1 = np.array([[1, 2], [3, 4]], dtype=np.float32)\narray2 = np.array([[5, 6], [7, 8]], dtype=np.float32)\n\ndef add_minus_dot(array1, array2):\n    return array1 + array2, array1 - array2, np.dot(array1, array2)\n\nadd_minus_dot_op = tf.py_func(add_minus_dot, [array1, array2], [tf.float32, tf.float32, tf.float32])\nprint sess.run(add_minus_dot_op)\n\n                ", "mainLikeNum": ["2 "], "mainBookmarkNum": "8"}