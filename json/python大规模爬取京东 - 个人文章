{"title": "python大规模爬取京东 - 个人文章 ", "index": "python", "content": "python大规模爬取京东\n主要工具\n\nscrapy\nBeautifulSoup\nrequests\n\n分析步骤\n\n\n打开京东首页，输入裤子将会看到页面跳转到了这里，这就是我们要分析的起点\n我们可以看到这个页面并不是完全的，当我们往下拉的时候将会看到图片在不停的加载，这就是ajax,但是当我们下拉到底的时候就会看到整个页面加载了60条裤子的信息，我们打开chrome的调试工具，查找页面元素时可以看到每条裤子的信息都在<li class='gl-item'></li>这个标签中，如下图：\n\n\n接着我们打开网页源码就会发现其实网页源码只有前30条的数据，后面30条的数据找不到，因此这里就会想到ajax，一种异步加载的方式，于是我们就要开始抓包了，我们打开chrome按F12，点击上面的NetWork,然后点击XHR,这个比较容易好找,下面开始抓包，如下图：\n\n从上面可以找到请求的url，发现有很长的一大段，我们试着去掉一些看看可不可以打开，简化之后的url=https://search.jd.com/s_new.p...{0}&s=26&scrolling=y&pos=30&show_items={1}这里的showitems是裤子的id,page是翻页的，可以看出来我们只需要改动两处就可以打开不同的网页了，这里的page很好找，你会发现一个很好玩的事情，就是主网页的page是奇数，但是异步加载的网页中的page是偶数，因此这里只要填上偶数就可以了，但是填奇数也是可以访问的。这里的show_items就是id了，我们可以在页面的源码中找到，通过查找可以看到id在li标签的data-pid中，详情请看下图\n\n上面我们知道怎样找参数了，现在就可以撸代码了\n\n代码讲解\n首先我们要获取网页的源码，这里我用的requests库，安装方法为pip install requests，代码如下:\n    def get_html(self):\n        res = requests.get(self.url, headers=self.headers)\n        html = res.text     \n        return html    #返回的源代码\n根据上面的分析可以知道，第二步就是得到异步加载的url中的参数show_items,就是li标签中的data-pid,代码如下：\n    def get_pids(self):\n        html = self.get_html()\n        soup = BeautifulSoup(html, 'lxml')    #创建BeautifulSoup对象\n        lis = soup.find_all(\"li\", class_='gl-item')   #查找li标签\n        for li in lis:\n            data_pid = li.get(\"data-pid\")      #得到li标签下的data-pid\n            if (data_pid):\n                self.pids.add(data_pid)    #这里的self.pids是一个集合，用于过滤重复的\n下面就是获取前30张图片的url了，也就是主网页上的图片，其中一个问题是img标签的属性并不是一样的，也就是源码中的img中不都是src属性，一开始已经加载出来的图片就是src属性，但是没有加载出来的图片是data-lazy-img，因此在解析页面的时候要加上讨论。代码如下：\n    def get_src_imgs_data(self):\n        html = self.get_html()\n        soup = BeautifulSoup(html, 'lxml')\n        divs = soup.find_all(\"div\", class_='p-img')  # 图片\n        # divs_prices = soup.find_all(\"div\", class_='p-price')   #价格\n        for div in divs:\n            img_1 = div.find(\"img\").get('data-lazy-img')  # 得到没有加载出来的url\n            img_2 = div.find(\"img\").get(\"src\")  # 得到已经加载出来的url\n            if img_1:\n                print img_1\n                self.sql.save_img(img_1)\n                self.img_urls.add(img_1)\n            if img_2:\n                print img_2\n                self.sql.save_img(img_2)\n                self.img_urls.add(img_2)\n前三十张图片找到了，现在开始找后三十张图片了，当然是要请求那个异步加载的url，前面已经把需要的参数给找到了，下面就好办了，直接贴代码：\n    def get_extend_imgs_data(self):\n        # self.search_urls=self.search_urls+','.join(self.pids)\n        self.search_urls = self.search_urls.format(str(self.search_page), ','.join(self.pids))  #拼凑url,将获得的单数拼成url,其中show_items中的id是用','隔开的，因此要对集合中的每一个id分割，page就是偶数，这里直接用主网页的page加一就可以了\n        print self.search_urls\n        html = requests.get(self.search_urls, headers=self.headers).text   #请求\n        soup = BeautifulSoup(html, 'lxml')   \n        div_search = soup.find_all(\"div\", class_='p-img')   #解析\n        for div in div_search:  \n            img_3 = div.find(\"img\").get('data-lazy-img')    #这里可以看到分开查找img属性了\n            img_4 = div.find(\"img\").get(\"src\")\n\n            if img_3:    #如果是data-lazy-img\n                print img_3\n                self.sql.save_img(img_3)    #存储到数据库\n                self.img_urls.add(img_3)      #用集合去重\n            if img_4:    #如果是src属性\n                print img_4\n                self.sql.save_img(img_4)     \n                self.img_urls.add(img_4)\n通过上面就可以爬取了，但是还是要考虑速度的问题，这里我用了多线程，直接每一页面开启一个线程，速度还是可以的，感觉这个速度还是可以的，几分钟解决问题，总共爬取了100个网页,这里的存储方式是mysql数据库存储的，要用发哦MySQLdb这个库，详情自己百度，当然也可以用mogodb但是还没有学呢，想要的源码的朋友请看GitHub源码\n拓展\n写到这里可以看到搜索首页的网址中keyword和wq都是你输入的词，如果你想要爬取更多的信息，可以将这两个词改成你想要搜索的词即可，直接将汉字写上，在请求的时候会自动帮你编码的，我也试过了，可以抓取源码的，如果你想要不断的抓取，可以将要搜索的词写上文件里，然后从文件中读取就可以了。以上只是一个普通的爬虫，并没有用到什么框架，接下来将会写scrapy框架爬取的，请继续关注我的博客哦！！！\n本人博客\n\n                ", "mainLikeNum": ["0 "], "mainBookmarkNum": "4"}